record_number,buggy_code,fixed_code,code_similarity
150001,"/** 
 * Push a code pointer location onto the code locations deque, optionally performing a sanity check first.<p>
 * @param code The code object into which this interior pointer points
 * @param ipLoc The location of the pointer into this code object
 */
private void codeLocationsPush(ObjectReference code,Address ipLoc) throws InlinePragma {
  if (VALIDATE_REFS) {
    Address ip=ipLoc.loadAddress();
    Offset offset=ip.diff(code.toAddress());
    if (offset.sLT(Offset.zero()) || offset.sGT(Offset.fromIntZeroExtend(1 << 24))) {
      Log.writeln(""String_Node_Str"");
      Log.write(""String_Node_Str"");
      Log.writeln(code);
      Log.write(""String_Node_Str"");
      Log.writeln(ip);
      Log.write(""String_Node_Str"");
      Log.writeln(offset);
      Log.write(""String_Node_Str"");
      Log.writeln(ipLoc);
      if (!failed)       failed=true;
    }
  }
  trace.addInteriorRootLocation(code,ipLoc);
}","/** 
 * Push a code pointer location onto the code locations deque, optionally performing a sanity check first.<p>
 * @param code The code object into which this interior pointer points
 * @param ipLoc The location of the pointer into this code object
 */
private void codeLocationsPush(ObjectReference code,Address ipLoc) throws InlinePragma {
  if (VALIDATE_REFS) {
    Address ip=ipLoc.loadAddress();
    Offset offset=ip.diff(code.toAddress());
    if (offset.sLT(Offset.zero()) || offset.sGT(Offset.fromIntZeroExtend(ObjectModel.getObjectSize(code)))) {
      Log.writeln(""String_Node_Str"");
      Log.write(""String_Node_Str"");
      Log.writeln(code);
      Log.write(""String_Node_Str"");
      Log.writeln(ip);
      Log.write(""String_Node_Str"");
      Log.writeln(offset);
      Log.write(""String_Node_Str"");
      Log.writeln(ipLoc);
      if (!failed)       failed=true;
    }
  }
  trace.addInteriorRootLocation(code,ipLoc);
}",0.9794372294372294
150002,"/** 
 * Check if object might be a TIB.
 * @param obj address of object to check
 * @return <code>false</code> if the object is in the wrongallocation scheme/area for a TIB, <code>true</code> otherwise
 */
public static boolean mightBeTIB(ObjectReference obj) throws InlinePragma, UninterruptiblePragma {
  return !obj.isNull() && Space.isImmortal(obj);
}","/** 
 * Check if object might be a TIB.
 * @param obj address of object to check
 * @return <code>false</code> if the object is in the wrongallocation scheme/area for a TIB, <code>true</code> otherwise
 */
public static boolean mightBeTIB(ObjectReference obj) throws InlinePragma, UninterruptiblePragma {
  return !obj.isNull() && Space.isMappedObject(obj) && Space.isImmortal(obj)&& Space.isMappedObject(ObjectReference.fromObject(VM_ObjectModel.getTIB(obj)));
}",0.8386308068459658
150003,"/** 
 * Internal allocation slow path.  This is called whenever the bump pointer reaches the internal limit.  The code is forced out of line.  If required we perform an external slow path take, which we inline into this method since this is already out of line.
 * @param start The start address for the pending allocation
 * @param end The end address for the pending allocation
 * @param align The requested alignment
 * @param offset The offset from the alignment 
 * @param inGC Is the allocation request occuring during GC.
 * @return The address of the first byte of the allocated region
 * @throws NoInlinePragma
 */
private final Address allocSlow(Address start,Address end,int align,int offset,boolean inGC) throws NoInlinePragma {
  Address rtn=null;
  Address card=null;
  if (SUPPORT_CARD_SCANNING)   getCard(start.plus(CARD_MASK));
  if (end.GT(limit)) {
    rtn=allocSlowInline(end.diff(start).toInt(),align,offset,inGC);
    if (SUPPORT_CARD_SCANNING && card.NE(getCard(rtn.plus(CARD_MASK))))     card=getCard(rtn);
  }
 else {
    while (internalLimit.LE(end))     internalLimit=internalLimit.plus(STEP_SIZE);
    if (internalLimit.GT(limit))     internalLimit=limit;
    fillAlignmentGap(cursor,start);
    cursor=end;
    rtn=start;
  }
  if (SUPPORT_CARD_SCANNING && !rtn.isZero())   createCardAnchor(card,rtn,end.diff(start).toInt());
  return rtn;
}","/** 
 * Internal allocation slow path.  This is called whenever the bump pointer reaches the internal limit.  The code is forced out of line.  If required we perform an external slow path take, which we inline into this method since this is already out of line.
 * @param start The start address for the pending allocation
 * @param end The end address for the pending allocation
 * @param align The requested alignment
 * @param offset The offset from the alignment 
 * @param inGC Is the allocation request occuring during GC.
 * @return The address of the first byte of the allocated region
 * @throws NoInlinePragma
 */
private final Address allocSlow(Address start,Address end,int align,int offset,boolean inGC) throws NoInlinePragma {
  Address rtn=null;
  Address card=null;
  if (SUPPORT_CARD_SCANNING)   card=getCard(start.plus(CARD_MASK));
  if (end.GT(limit)) {
    rtn=allocSlowInline(end.diff(start).toInt(),align,offset,inGC);
    if (SUPPORT_CARD_SCANNING && card.NE(getCard(rtn.plus(CARD_MASK))))     card=getCard(rtn);
  }
 else {
    while (internalLimit.LE(end))     internalLimit=internalLimit.plus(STEP_SIZE);
    if (internalLimit.GT(limit))     internalLimit=limit;
    fillAlignmentGap(cursor,start);
    cursor=end;
    rtn=start;
  }
  if (SUPPORT_CARD_SCANNING && !rtn.isZero())   createCardAnchor(card,rtn,end.diff(start).toInt());
  return rtn;
}",0.9981785063752276
150004,"/** 
 * Create a new Lock instance using the appropriate VM-specific concrete Lock sub-class.
 * @param name The string to be associated with this lock instance
 * @return A concrete VM-specific Lock instance.
 */
public static Lock newLock(String name){
  try {
    return (Lock)lockClass.newInstance();
  }
 catch (  Exception e) {
    assertions.fail(""String_Node_Str"");
    return null;
  }
}","/** 
 * Create a new Lock instance using the appropriate VM-specific concrete Lock sub-class.
 * @param name The string to be associated with this lock instance
 * @return A concrete VM-specific Lock instance.
 */
public static Lock newLock(String name){
  Lock lock=null;
  try {
    lock=(Lock)lockClass.newInstance();
    lock.setName(name);
    return lock;
  }
 catch (  Exception e) {
    assertions.fail(""String_Node_Str"");
    return null;
  }
}",0.9163722025912838
150005,"/** 
 * Return a slot (location of an address) given an object address and a reference number.
 * @param object The address of an object
 * @param reference The number of a field in a scalar or the indexinto an array
 * @return The address of the relevant slot within the object
 */
Address getSlot(ObjectReference object,int reference) throws InlinePragma {
  Address addr=object.toAddress();
  if (isReferenceArray)   return addr.plus(arrayOffset).plus(reference << LOG_BYTES_IN_ADDRESS);
 else   return addr.plus(offsets[reference]);
}","/** 
 * Return a slot (location of an address) given an object address and a reference number.
 * @param object The address of an object
 * @param reference The number of a field in a scalar or the indexinto an array
 * @return The address of the relevant slot within the object
 */
Address getSlot(ObjectReference object,int reference) throws InlinePragma {
  Address addr=object.toAddress();
  if (isReferenceArray)   return addr.plus(VM.ARRAY_BASE_OFFSET).plus(reference << LOG_BYTES_IN_ADDRESS);
 else   return addr.plus(offsets[reference]);
}",0.9732718894009216
150006,"/** 
 * Check for memory exhaustion, possibly throwing an out of memory exception and/or triggering another GC.
 * @param why Why the collection was triggered
 * @param async True if this collection was asynchronously triggered.
 */
private static final void checkForExhaustion(int why,boolean async) throws LogicallyUninterruptiblePragma {
  double usage=Plan.reservedMemory().toLong() / ((double)Plan.totalMemory().toLong());
  if (usage > OUT_OF_MEMORY_THRESHOLD) {
    if (why == INTERNAL_GC_TRIGGER) {
      if (Options.verbose.getValue() >= 2) {
        VM.sysWriteln(""String_Node_Str"",usage);
        VM.sysWriteln(""String_Node_Str"",(long)(Plan.reservedMemory().toLong() / 1024));
        VM.sysWriteln(""String_Node_Str"",(long)(Plan.totalMemory().toLong() / 1024));
      }
      if (VM.debugOOM || Options.verbose.getValue() >= 5)       VM.sysWriteln(""String_Node_Str"");
      MM_Interface.emergencyGrowHeap(512 * (1 << 10));
      OutOfMemoryError oome=new OutOfMemoryError();
      MM_Interface.emergencyGrowHeap(-(512 * (1 << 10)));
      if (VM.debugOOM || Options.verbose.getValue() >= 5)       VM.sysWriteln(""String_Node_Str"");
      throw oome;
    }
    ReferenceProcessor.setClearSoftReferences(true);
    if (!async)     triggerCollection(INTERNAL_GC_TRIGGER);
  }
}","/** 
 * Check for memory exhaustion, possibly throwing an out of memory exception and/or triggering another GC.
 * @param why Why the collection was triggered
 * @param async True if this collection was asynchronously triggered.
 */
private static final void checkForExhaustion(int why,boolean async) throws LogicallyUninterruptiblePragma {
  double usage=Plan.reservedMemory().toLong() / ((double)Plan.totalMemory().toLong());
  if (usage > OUT_OF_MEMORY_THRESHOLD) {
    if (why == INTERNAL_GC_TRIGGER) {
      if (Options.verbose.getValue() >= 2) {
        VM.sysWriteln(""String_Node_Str"",usage);
        VM.sysWriteln(""String_Node_Str"",(long)(Plan.reservedMemory().toLong() / 1024));
        VM.sysWriteln(""String_Node_Str"",(long)(Plan.totalMemory().toLong() / 1024));
      }
      if (VM.debugOOM || Options.verbose.getValue() >= 5)       VM.sysWriteln(""String_Node_Str"");
      int currentAvail=ActivePlan.global().getPagesAvail() << LOG_BYTES_IN_PAGE;
      int headroom=OOM_EXN_HEADROOM_BYTES - currentAvail;
      MM_Interface.emergencyGrowHeap(headroom);
      OutOfMemoryError oome=new OutOfMemoryError();
      MM_Interface.emergencyGrowHeap(-headroom);
      if (VM.debugOOM || Options.verbose.getValue() >= 5)       VM.sysWriteln(""String_Node_Str"");
      throw oome;
    }
    ReferenceProcessor.setClearSoftReferences(true);
    if (!async)     triggerCollection(INTERNAL_GC_TRIGGER);
  }
}",0.9305091044221478
150007,"/** 
 * Write boot image to disk.
 * @param imageFileName the name of the image file
 */
public void write(String imageCodeFileName,String imageDataFileName,String imageRMapFileName) throws IOException {
  if (trace) {
    say((numObjects / 1024) + ""String_Node_Str"");
    say((numAddresses / 1024) + ""String_Node_Str"");
    say(numNulledReferences + ""String_Node_Str"" + ""String_Node_Str"");
    say((VM_Statics.getNumberOfSlots() / 1024) + ""String_Node_Str"");
    say((getDataSize() / 1024) + ""String_Node_Str"");
    say((getCodeSize() / 1024) + ""String_Node_Str"");
    say(""String_Node_Str"" + imageDataFileName);
  }
  FileOutputStream dataOut=new FileOutputStream(imageDataFileName);
  dataOut.write(bootImageData,0,getDataSize());
  dataOut.flush();
  dataOut.close();
  if (trace) {
    say(""String_Node_Str"" + imageCodeFileName);
  }
  FileOutputStream codeOut=new FileOutputStream(imageCodeFileName);
  codeOut.write(bootImageCode,0,getCodeSize());
  codeOut.flush();
  codeOut.close();
  if (trace) {
    say(""String_Node_Str"" + imageRMapFileName);
  }
  bootImageData=null;
  bootImageCode=null;
  System.gc();
  bootImageRMap=new byte[referenceMapReferences << BYTES_IN_WORD];
  rMapSize=org.mmtk.vm.ScanBootImage.encodeRMap(bootImageRMap,referenceMap,referenceMapLimit);
  FileOutputStream rmapOut=new FileOutputStream(imageRMapFileName);
  rmapOut.write(bootImageRMap,0,rMapSize);
  rmapOut.flush();
  rmapOut.close();
  if (trace) {
    say(""String_Node_Str"" + referenceMapReferences);
  }
  org.mmtk.vm.ScanBootImage.encodingStats();
}","/** 
 * Write boot image to disk.
 * @param imageFileName the name of the image file
 */
public void write(String imageCodeFileName,String imageDataFileName,String imageRMapFileName) throws IOException {
  if (trace) {
    say((numObjects / 1024) + ""String_Node_Str"");
    say((numAddresses / 1024) + ""String_Node_Str"");
    say(numNulledReferences + ""String_Node_Str"" + ""String_Node_Str"");
    say((VM_Statics.getNumberOfSlots() / 1024) + ""String_Node_Str"");
    say((getDataSize() / 1024) + ""String_Node_Str"");
    say((getCodeSize() / 1024) + ""String_Node_Str"");
    say(""String_Node_Str"" + imageDataFileName);
  }
  FileOutputStream dataOut=new FileOutputStream(imageDataFileName);
  dataOut.write(bootImageData,0,getDataSize());
  dataOut.flush();
  dataOut.close();
  if (trace) {
    say(""String_Node_Str"" + imageCodeFileName);
  }
  FileOutputStream codeOut=new FileOutputStream(imageCodeFileName);
  codeOut.write(bootImageCode,0,getCodeSize());
  codeOut.flush();
  codeOut.close();
  if (trace) {
    say(""String_Node_Str"" + imageRMapFileName);
  }
  bootImageData=null;
  bootImageCode=null;
  System.gc();
  bootImageRMap=new byte[referenceMapReferences << LOG_BYTES_IN_WORD];
  rMapSize=org.mmtk.vm.ScanBootImage.encodeRMap(bootImageRMap,referenceMap,referenceMapLimit);
  FileOutputStream rmapOut=new FileOutputStream(imageRMapFileName);
  rmapOut.write(bootImageRMap,0,rMapSize);
  rmapOut.flush();
  rmapOut.close();
  if (trace) {
    say(""String_Node_Str"" + referenceMapReferences);
  }
  org.mmtk.vm.ScanBootImage.encodingStats();
}",0.9987096774193548
150008,"/** 
 * Atomically set the live bit for a given object
 * @param object The object whose live bit is to be set.
 * @return True if the bit was changed to true.
 */
public static final boolean liveObject(ObjectReference object) throws InlinePragma {
  return liveAddress(VM.objectModel.refToAddress(object),true);
}","/** 
 * Atomically set the live bit for a given object
 * @param object The object whose live bit is to be set.
 * @return True if the bit was changed to true.
 */
public static final boolean liveObject(ObjectReference object) throws InlinePragma {
  return liveAddress(VM.objectModel.objectStartRef(object),true);
}",0.9587301587301588
150009,"/** 
 * Perform a per-collector collection phase.
 * @param phaseId The collection phase to perform
 * @param primary Use this thread for single-threaded local activities.
 */
public final void collectionPhase(int phaseId,boolean primary) throws InlinePragma {
  if (phaseId == CopyMS.PREPARE) {
    super.collectionPhase(phaseId,primary);
    mature.prepare();
    trace.prepare();
    return;
  }
  if (phaseId == CopyMS.START_CLOSURE) {
    trace.startTrace();
    return;
  }
  if (phaseId == CopyMS.COMPLETE_CLOSURE) {
    trace.completeTrace();
    return;
  }
  if (phaseId == CopyMS.RELEASE) {
    mature.releaseCollector();
    trace.release();
    super.collectionPhase(phaseId,primary);
    return;
  }
  super.collectionPhase(phaseId,primary);
}","/** 
 * Perform a per-collector collection phase.
 * @param phaseId The collection phase to perform
 * @param primary Use this thread for single-threaded local activities.
 */
public final void collectionPhase(int phaseId,boolean primary) throws InlinePragma {
  if (phaseId == CopyMS.PREPARE) {
    super.collectionPhase(phaseId,primary);
    mature.prepare();
    trace.prepare();
    return;
  }
  if (phaseId == CopyMS.START_CLOSURE) {
    trace.startTrace();
    return;
  }
  if (phaseId == CopyMS.COMPLETE_CLOSURE) {
    trace.completeTrace();
    return;
  }
  if (phaseId == CopyMS.RELEASE) {
    mature.releaseCollector();
    mature.releaseMutator();
    trace.release();
    super.collectionPhase(phaseId,primary);
    return;
  }
  super.collectionPhase(phaseId,primary);
}",0.981205443940376
150010,"/** 
 * Create a new (local) instance.
 */
public CopyMSCollector(){
  mature=new MarkSweepLocal(CopyMS.msSpace);
  trace=new CopyMSTraceLocal(global().trace);
}","/** 
 * Create a new (local) instance.
 */
public CopyMSCollector(){
  mature=new MarkSweepLocal(CopyMS.msSpace);
  trace=new CopyMSTraceLocal(global().trace);
  sanityChecker=new CopyMSSanityCheckerLocal();
}",0.8702702702702703
150011,"/** 
 * Perform any post-copy actions.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(ObjectReference object,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  CopyMS.msSpace.writeMarkBit(object);
  MarkSweepLocal.liveObject(object);
}","/** 
 * Perform any post-copy actions.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(ObjectReference object,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  CopyMS.msSpace.postCopy(object,true);
}",0.9225
150012,"/** 
 * Where do we send copied objects ?
 * @return The allocator for copied objects
 */
public final int getAllocator() throws InlinePragma {
  return Gen.ALLOC_MATURE;
}","/** 
 * Where do we send copied objects ?
 * @return The allocator for copied objects
 */
public final int getAllocator() throws InlinePragma {
  return Gen.ALLOC_MATURE_MAJORGC;
}",0.9772727272727272
150013,"/** 
 * @return The allocator to use when copying objects during this trace.
 */
public final int getAllocator() throws InlinePragma {
  return Gen.ALLOC_MATURE;
}","/** 
 * @return The allocator to use when copying objects during this trace.
 */
public final int getAllocator() throws InlinePragma {
  return Gen.ALLOC_MATURE_MINORGC;
}",0.9760479041916168
150014,"/** 
 * Allocate space for copying an object (this method <i>does not</i> copy the object, it only allocates space)
 * @param original A reference to the original object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @return The address of the first byte of the allocated region
 */
public Address allocCopy(ObjectReference original,int bytes,int align,int offset,int allocator) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    Assert._assert(bytes <= Plan.LOS_SIZE_THRESHOLD);
    Assert._assert(allocator == GenCopy.ALLOC_MATURE);
  }
  Address result=mature.alloc(bytes,align,offset,true);
  return result;
}","/** 
 * Allocate space for copying an object (this method <i>does not</i> copy the object, it only allocates space)
 * @param original A reference to the original object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @return The address of the first byte of the allocated region
 */
public Address allocCopy(ObjectReference original,int bytes,int align,int offset,int allocator) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    Assert._assert(bytes <= Plan.LOS_SIZE_THRESHOLD);
    Assert._assert(allocator == GenCopy.ALLOC_MATURE_MINORGC || allocator == GenCopy.ALLOC_MATURE_MAJORGC);
  }
  Address result=mature.alloc(bytes,align,offset,true);
  return result;
}",0.9646430953969312
150015,"/** 
 * Allocate space for copying an object (this method <i>does not</i> copy the object, it only allocates space)
 * @param original A reference to the original object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @param allocator The allocator to use.
 * @return The address of the first byte of the allocated region
 */
public final Address allocCopy(ObjectReference original,int bytes,int align,int offset,int allocator) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    Assert._assert(bytes <= Plan.LOS_SIZE_THRESHOLD);
    Assert._assert(allocator == GenMS.ALLOC_MATURE);
  }
  if (Stats.GATHER_MARK_CONS_STATS) {
    if (Space.isInSpace(GenMS.NURSERY,original))     GenMS.nurseryMark.inc(bytes);
  }
  return mature.alloc(bytes,align,offset,GenMS.msSpace.inMSCollection());
}","/** 
 * Allocate space for copying an object (this method <i>does not</i> copy the object, it only allocates space)
 * @param original A reference to the original object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @param allocator The allocator to use.
 * @return The address of the first byte of the allocated region
 */
public final Address allocCopy(ObjectReference original,int bytes,int align,int offset,int allocator) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    Assert._assert(bytes <= Plan.LOS_SIZE_THRESHOLD);
    Assert._assert(allocator == GenMS.ALLOC_MATURE_MINORGC || allocator == GenMS.ALLOC_MATURE_MAJORGC);
  }
  if (Stats.GATHER_MARK_CONS_STATS) {
    if (Space.isInSpace(GenMS.NURSERY,original))     GenMS.nurseryMark.inc(bytes);
  }
  return mature.alloc(bytes,align,offset,GenMS.msSpace.inMSCollection());
}",0.9722976643128736
150016,"/** 
 * Perform any post-copy actions.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(ObjectReference object,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  GenMS.msSpace.writeMarkBit(object);
  MarkSweepLocal.liveObject(object);
}","/** 
 * Perform any post-copy actions.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(ObjectReference object,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  GenMS.msSpace.postCopy(object,allocator == GenMS.ALLOC_MATURE_MAJORGC);
}",0.8691476590636255
150017,"/** 
 * Perform post-allocation actions.  Initialize the object header for objects in the mark-sweep space, and delegate to the superclass for other objects.
 * @param ref The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public void postAlloc(ObjectReference ref,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  if (allocator == MS.ALLOC_DEFAULT)   MS.msSpace.initializeHeader(ref);
 else   super.postAlloc(ref,typeRef,bytes,allocator);
}","/** 
 * Perform post-allocation actions.  Initialize the object header for objects in the mark-sweep space, and delegate to the superclass for other objects.
 * @param ref The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public void postAlloc(ObjectReference ref,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  if (allocator == MS.ALLOC_DEFAULT)   MS.msSpace.postAlloc(ref);
 else   super.postAlloc(ref,typeRef,bytes,allocator);
}",0.9806351665375678
150018,"/** 
 * Prepare for a collection. If paranoid, perform a sanity check.
 */
public final void prepare(){
  if (Options.fragmentationStats.getValue())   fragmentationStatistics(true);
  flushFreeLists();
}","/** 
 * Prepare for a collection. If paranoid, perform a sanity check.
 */
public final void prepare(){
  if (Options.fragmentationStats.getValue())   fragmentationStatistics(true);
  if (HEADER_MARK_BITS && Options.eagerCompleteSweep.getValue()) {
    consumeBlockLists(msSpace.getPreviousMarkState());
  }
  flushFreeLists();
}",0.7631578947368421
150019,"/** 
 * Prepare the next block in the free block list for use by the free list allocator.  In the case of lazy sweeping this involves sweeping the available cells.  <b>The sweeping operation must ensure that cells are pre-zeroed</b>, as this method must return pre-zeroed cells.
 * @param block The block to be prepared for use
 * @param sizeClass The size class of the block
 * @return The address of the first pre-zeroed cell in the free listfor this block, or zero if there are no available cells.
 */
protected final Address advanceToBlock(Address block,int sizeClass){
  if (LAZY_SWEEP)   return makeFreeListFromLiveBits(block,sizeClass);
 else   return getFreeList(block);
}","/** 
 * Prepare the next block in the free block list for use by the free list allocator.  In the case of lazy sweeping this involves sweeping the available cells.  <b>The sweeping operation must ensure that cells are pre-zeroed</b>, as this method must return pre-zeroed cells.
 * @param block The block to be prepared for use
 * @param sizeClass The size class of the block
 * @return The address of the first pre-zeroed cell in the free listfor this block, or zero if there are no available cells.
 */
protected final Address advanceToBlock(Address block,int sizeClass){
  if (LAZY_SWEEP)   return makeFreeListFromLiveBits(block,sizeClass,msSpace.getMarkState());
 else   return getFreeList(block);
}",0.9833694866232828
150020,"public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        Log.write(""String_Node_Str"");
        writeThreadIdToLog(VM_Thread.getCurrentThread());
        Log.write(""String_Node_Str"");
        Log.write(ticket);
        Log.write(""String_Node_Str"");
        Log.write(id);
        Log.write(""String_Node_Str"");
        Log.write(name);
        Log.write(""String_Node_Str"");
        Log.write(serving);
        Log.write(""String_Node_Str"");
        Log.write(VM_Time.cyclesToMillis(waitTime));
        Log.write(""String_Node_Str"");
        Log.writelnNoFlush();
        VM_Thread t=thread;
        if (t == null)         Log.writeln(""String_Node_Str"",false);
 else {
          Log.write(""String_Node_Str"");
          writeThreadIdToLog(t);
          Log.write(""String_Node_Str"");
          Log.writeln(where,false);
        }
        Log.write(""String_Node_Str"");
        Log.writeln(localStart,false);
        for (int i=(serving + 90) % 100; i != serving; i=(i + 1) % 100) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          Log.write(""String_Node_Str"");
          Log.write(i);
          Log.write(""String_Node_Str"");
          Log.write(servingHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(tidHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(startHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(endHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(VM_Time.cyclesToMillis(startHistory[i] - localStart));
          Log.writelnNoFlush();
        }
        Log.flush();
      }
      if (waitTime > TIME_OUT) {
        Log.write(""String_Node_Str"");
        writeThreadIdToLog(VM_Thread.getCurrentThread());
        Log.writeln();
        VM_Scheduler.dumpStack();
        Assert.fail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    Log.write(""String_Node_Str"");
    writeThreadIdToLog(thread);
    Log.write(""String_Node_Str"");
    Log.write(id);
    Log.write(""String_Node_Str"");
    Log.write(name);
    Log.writeln();
  }
  VM_Magic.isync();
}","public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        Log.write(""String_Node_Str"");
        writeThreadIdToLog(VM_Thread.getCurrentThread());
        Log.write(""String_Node_Str"");
        Log.write(ticket);
        Log.write(""String_Node_Str"");
        Log.write(id);
        Log.write(""String_Node_Str"");
        Log.write(name);
        Log.write(""String_Node_Str"");
        Log.write(serving);
        Log.write(""String_Node_Str"");
        Log.write(VM_Time.cyclesToMillis(waitTime));
        Log.write(""String_Node_Str"");
        Log.writelnNoFlush();
        VM_Thread t=thread;
        if (t == null)         Log.writeln(""String_Node_Str"",false);
 else {
          Log.write(""String_Node_Str"");
          writeThreadIdToLog(t);
          Log.write(""String_Node_Str"");
          Log.writeln(where,false);
        }
        Log.write(""String_Node_Str"");
        Log.writeln(localStart,false);
        for (int i=(serving + 90) % 100; i != (serving % 100); i=(i + 1) % 100) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          Log.write(""String_Node_Str"");
          Log.write(i);
          Log.write(""String_Node_Str"");
          Log.write(servingHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(tidHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(startHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(endHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(VM_Time.cyclesToMillis(startHistory[i] - localStart));
          Log.writelnNoFlush();
        }
        Log.flush();
      }
      if (waitTime > TIME_OUT) {
        Log.write(""String_Node_Str"");
        writeThreadIdToLog(VM_Thread.getCurrentThread());
        Log.writeln();
        VM_Scheduler.dumpStack();
        Assert.fail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    Log.write(""String_Node_Str"");
    writeThreadIdToLog(thread);
    Log.write(""String_Node_Str"");
    Log.write(id);
    Log.write(""String_Node_Str"");
    Log.write(name);
    Log.writeln();
  }
  VM_Magic.isync();
}",0.9986399183951036
150021,"/** 
 * Should the IR be printed before and/or after this phase?
 * @param options controlling compiler options
 * @param before query control
 * @return true or false.
 */
final boolean printingEnabled(OPT_Options options,boolean before){
  return false;
}","/** 
 * Should the IR be printed before and/or after this phase?
 * @param options controlling compiler options
 * @param before query control
 * @return true or false.
 */
public final boolean printingEnabled(OPT_Options options,boolean before){
  return false;
}",0.9865642994241842
150022,"/** 
 * Returns ""Dominator Tree""
 * @return ""Dominator Tree""
 */
final String getName(){
  return ""String_Node_Str"";
}","/** 
 * Returns ""Dominator Tree""
 * @return ""Dominator Tree""
 */
public final String getName(){
  return ""String_Node_Str"";
}",0.97119341563786
150023,"/** 
 * Should this phase be performed?
 * @param options controlling compiler options
 * @return true or false
 */
final boolean shouldPerform(OPT_Options options){
  return options.SSA || options.PRINT_DOMINATORS;
}","/** 
 * Should this phase be performed?
 * @param options controlling compiler options
 * @return true or false
 */
public final boolean shouldPerform(OPT_Options options){
  return options.SSA || options.PRINT_DOMINATORS;
}",0.984126984126984
150024,"/** 
 * Main driver.
 * @param ir the governing IR
 */
final void perform(OPT_IR ir){
  if (!ir.HIRInfo.dominatorsAreComputed)   return;
  try {
    OPT_DominatorTree.perform(ir,true);
  }
 catch (  OPT_OperationNotImplementedException e) {
    if (ir.options.PRINT_DOMINATORS || ir.options.PRINT_SSA) {
      OPT_Compiler.report(e.getMessage());
    }
  }
}","/** 
 * Main driver.
 * @param ir the governing IR
 */
public final void perform(OPT_IR ir){
  if (!ir.HIRInfo.dominatorsAreComputed)   return;
  try {
    OPT_DominatorTree.perform(ir,true);
  }
 catch (  OPT_OperationNotImplementedException e) {
    if (ir.options.PRINT_DOMINATORS || ir.options.PRINT_SSA) {
      OPT_Compiler.report(e.getMessage());
    }
  }
}",0.9903181189488244
150025,"/** 
 * Should the IR be printed before and/or after this phase?
 * @param options controlling compiler options
 * @param before query control
 * @return true or false
 */
final boolean printingEnabled(OPT_Options options,boolean before){
  return false;
}","/** 
 * Should the IR be printed before and/or after this phase?
 * @param options controlling compiler options
 * @param before query control
 * @return true or false
 */
public final boolean printingEnabled(OPT_Options options,boolean before){
  return false;
}",0.9865125240847784
150026,"/** 
 * Return a string representation of this phase
 * @return ""Post-Dominators""
 */
final String getName(){
  return ""String_Node_Str"";
}","/** 
 * Return a string representation of this phase
 * @return ""Post-Dominators""
 */
public final String getName(){
  return ""String_Node_Str"";
}",0.975438596491228
150027,"/** 
 * Should this phase be performed?  This is a member of a composite phase, so always return true.  The parent composite phase will dictate.
 * @param options controlling compiler options
 */
final boolean shouldPerform(OPT_Options options){
  return true;
}","/** 
 * Should this phase be performed?  This is a member of a composite phase, so always return true.  The parent composite phase will dictate.
 * @param options controlling compiler options
 */
public final boolean shouldPerform(OPT_Options options){
  return true;
}",0.9868173258003766
150028,"/** 
 * @param unfactor Should we unfactor the CFG before computingdominators?
 */
OPT_PostDominatorsPhase(boolean unfactor){
  this.unfactor=unfactor;
}","/** 
 * @param unfactor Should we unfactor the CFG before computingdominators?
 */
public OPT_PostDominatorsPhase(boolean unfactor){
  this.unfactor=unfactor;
}",0.977635782747604
150029,"/** 
 * Main driver for the post-dominator calculation.
 */
final void perform(OPT_IR ir){
  try {
    ir.HIRInfo.postDominatorsAreComputed=false;
    OPT_LTDominators.perform(ir,false,unfactor);
    OPT_DominatorTree.perform(ir,false);
    ir.HIRInfo.postDominatorsAreComputed=true;
  }
 catch (  OPT_OperationNotImplementedException e) {
    OPT_Options options=ir.options;
    if (options.PRINT_POST_DOMINATORS) {
      OPT_Compiler.report(e.getMessage());
    }
  }
}","/** 
 * Main driver for the post-dominator calculation.
 */
public final void perform(OPT_IR ir){
  try {
    ir.HIRInfo.postDominatorsAreComputed=false;
    OPT_LTDominators.perform(ir,false,unfactor);
    OPT_DominatorTree.perform(ir,false);
    ir.HIRInfo.postDominatorsAreComputed=true;
  }
 catch (  OPT_OperationNotImplementedException e) {
    OPT_Options options=ir.options;
    if (options.PRINT_POST_DOMINATORS) {
      OPT_Compiler.report(e.getMessage());
    }
  }
}",0.9926238145416229
150030,"static void gc(){
  MM_Interface.gc();
}","static void gc(){
  if (VM_Synchronization.testAndSet(instance,gcLockOffset,1)) {
    MM_Interface.gc();
    VM_Synchronization.fetchAndStore(instance,gcLockOffset,0);
  }
}",0.3755868544600939
150031,"/** 
 * Allocate something like ""new int[cnt]"" or ""new Foo[cnt]"".
 * @param numElements number of array elements
 * @param logElementSize size in bytes of an array element, log base 2.
 * @param headerSize size in bytes of array header
 * @param tib type information block for array object
 * @param allocator int that encodes which allocator should be used
 * @param align the alignment requested; must be a power of 2.
 * @param offset the offset at which the alignment is desired.
 * @return array object with header installed and all elements set to zero/null See also: bytecode 0xbc (""newarray"") and 0xbd (""anewarray"")
 */
public static Object resolvedNewArray(int numElements,int logElementSize,int headerSize,Object[] tib,int allocator,int align,int offset) throws OutOfMemoryError, NegativeArraySizeException {
  if (numElements < 0)   raiseNegativeArraySizeException();
  if (VM.ForceFrequentGC && VM_Scheduler.allProcessorsInitialized) {
    if (countDownToGC-- <= 0) {
      VM.sysWrite(""String_Node_Str"");
      countDownToGC=GCInterval;
      MM_Interface.gc();
    }
  }
  return MM_Interface.allocateArray(numElements,logElementSize,headerSize,tib,allocator,align,offset);
}","/** 
 * Allocate something like ""new int[cnt]"" or ""new Foo[cnt]"".
 * @param numElements number of array elements
 * @param logElementSize size in bytes of an array element, log base 2.
 * @param headerSize size in bytes of array header
 * @param tib type information block for array object
 * @param allocator int that encodes which allocator should be used
 * @param align the alignment requested; must be a power of 2.
 * @param offset the offset at which the alignment is desired.
 * @return array object with header installed and all elements set to zero/null See also: bytecode 0xbc (""newarray"") and 0xbd (""anewarray"")
 */
public static Object resolvedNewArray(int numElements,int logElementSize,int headerSize,Object[] tib,int allocator,int align,int offset) throws OutOfMemoryError, NegativeArraySizeException {
  if (numElements < 0)   raiseNegativeArraySizeException();
  if (VM.ForceFrequentGC && VM_Scheduler.allProcessorsInitialized) {
    if (countDownToGC-- <= 0) {
      VM.sysWrite(""String_Node_Str"");
      countDownToGC=GCInterval;
      System.gc();
    }
  }
  return MM_Interface.allocateArray(numElements,logElementSize,headerSize,tib,allocator,align,offset);
}",0.9055649241146712
150032,"/** 
 * Deliver a hardware exception to current java thread.
 * @param trapCode code indicating kind of exception that was trapped (see TRAP_xxx, above)
 * @param trapInfo array subscript (for array bounds trap, only)does not return  (stack is unwound, starting at trap site, and execution resumes in a catch block somewhere up the stack) /or/  execution resumes at instruction following trap  (for TRAP_STACK_OVERFLOW) <p> Note:     Control reaches here by the actions of an  external ""C"" signal handler which saves the register state of the trap site into the  ""hardwareExceptionRegisters"" field of the current  VM_Thread object.  The signal handler also inserts a <hardware trap> frame onto the stack immediately above this frame, for use by  VM_HardwareTrapGCMapIterator during garbage collection.
 */
static void deliverHardwareException(int trapCode,int trapInfo){
  VM_Thread myThread=VM_Thread.getCurrentThread();
  VM_Registers exceptionRegisters=myThread.hardwareExceptionRegisters;
  if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) && myThread.stack.length < (STACK_SIZE_MAX >> LOG_BYTES_IN_ADDRESS) && !myThread.hasNativeStackFrame()) {
    if (trapCode == TRAP_JNI_STACK) {
      VM_Thread.resizeCurrentStack(myThread.stack.length + STACK_SIZE_JNINATIVE_GROW,exceptionRegisters);
    }
 else {
      VM_Thread.resizeCurrentStack(myThread.stack.length + STACK_SIZE_GROW,exceptionRegisters);
    }
    if (VM.VerifyAssertions)     VM._assert(exceptionRegisters.inuse == true);
    exceptionRegisters.inuse=false;
    VM_Magic.restoreHardwareExceptionState(exceptionRegisters);
    if (VM.VerifyAssertions)     VM._assert(NOT_REACHED);
  }
  if (VM.ForceFrequentGC && VM_Scheduler.allProcessorsInitialized) {
    VM.sysWrite(""String_Node_Str"");
    MM_Interface.gc();
  }
  Throwable exceptionObject;
switch (trapCode) {
case TRAP_NULL_POINTER:
    exceptionObject=new java.lang.NullPointerException();
  break;
case TRAP_ARRAY_BOUNDS:
exceptionObject=new java.lang.ArrayIndexOutOfBoundsException(trapInfo);
break;
case TRAP_DIVIDE_BY_ZERO:
exceptionObject=new java.lang.ArithmeticException();
break;
case TRAP_STACK_OVERFLOW:
case TRAP_JNI_STACK:
exceptionObject=new java.lang.StackOverflowError();
break;
case TRAP_CHECKCAST:
exceptionObject=new java.lang.ClassCastException();
break;
case TRAP_MUST_IMPLEMENT:
exceptionObject=new java.lang.IncompatibleClassChangeError();
break;
case TRAP_STORE_CHECK:
exceptionObject=new java.lang.ArrayStoreException();
break;
default :
exceptionObject=new java.lang.UnknownError();
VM_Scheduler.traceback(""String_Node_Str"");
break;
}
VM.disableGC();
deliverException(exceptionObject,exceptionRegisters);
}","/** 
 * Deliver a hardware exception to current java thread.
 * @param trapCode code indicating kind of exception that was trapped (see TRAP_xxx, above)
 * @param trapInfo array subscript (for array bounds trap, only)does not return  (stack is unwound, starting at trap site, and execution resumes in a catch block somewhere up the stack) /or/  execution resumes at instruction following trap  (for TRAP_STACK_OVERFLOW) <p> Note:     Control reaches here by the actions of an  external ""C"" signal handler which saves the register state of the trap site into the  ""hardwareExceptionRegisters"" field of the current  VM_Thread object.  The signal handler also inserts a <hardware trap> frame onto the stack immediately above this frame, for use by  VM_HardwareTrapGCMapIterator during garbage collection.
 */
static void deliverHardwareException(int trapCode,int trapInfo){
  VM_Thread myThread=VM_Thread.getCurrentThread();
  VM_Registers exceptionRegisters=myThread.hardwareExceptionRegisters;
  if ((trapCode == TRAP_STACK_OVERFLOW || trapCode == TRAP_JNI_STACK) && myThread.stack.length < (STACK_SIZE_MAX >> LOG_BYTES_IN_ADDRESS) && !myThread.hasNativeStackFrame()) {
    if (trapCode == TRAP_JNI_STACK) {
      VM_Thread.resizeCurrentStack(myThread.stack.length + STACK_SIZE_JNINATIVE_GROW,exceptionRegisters);
    }
 else {
      VM_Thread.resizeCurrentStack(myThread.stack.length + STACK_SIZE_GROW,exceptionRegisters);
    }
    if (VM.VerifyAssertions)     VM._assert(exceptionRegisters.inuse == true);
    exceptionRegisters.inuse=false;
    VM_Magic.restoreHardwareExceptionState(exceptionRegisters);
    if (VM.VerifyAssertions)     VM._assert(NOT_REACHED);
  }
  if (VM.ForceFrequentGC && VM_Scheduler.allProcessorsInitialized) {
    VM.sysWrite(""String_Node_Str"");
    System.gc();
  }
  Throwable exceptionObject;
switch (trapCode) {
case TRAP_NULL_POINTER:
    exceptionObject=new java.lang.NullPointerException();
  break;
case TRAP_ARRAY_BOUNDS:
exceptionObject=new java.lang.ArrayIndexOutOfBoundsException(trapInfo);
break;
case TRAP_DIVIDE_BY_ZERO:
exceptionObject=new java.lang.ArithmeticException();
break;
case TRAP_STACK_OVERFLOW:
case TRAP_JNI_STACK:
exceptionObject=new java.lang.StackOverflowError();
break;
case TRAP_CHECKCAST:
exceptionObject=new java.lang.ClassCastException();
break;
case TRAP_MUST_IMPLEMENT:
exceptionObject=new java.lang.IncompatibleClassChangeError();
break;
case TRAP_STORE_CHECK:
exceptionObject=new java.lang.ArrayStoreException();
break;
default :
exceptionObject=new java.lang.UnknownError();
VM_Scheduler.traceback(""String_Node_Str"");
break;
}
VM.disableGC();
deliverException(exceptionObject,exceptionRegisters);
}",0.9966304754773492
150033,"/** 
 * Allocate something like ""new Foo()"".
 * @param size size of object (including header), in bytes
 * @param tib  type information block for object
 * @param hasFinalizer does this type have a finalizer?
 * @param allocator int that encodes which allocator should be used
 * @param align the alignment requested; must be a power of 2.
 * @param offset the offset at which the alignment is desired.
 * @return object with header installed and all fields set to zero/null(ready for initializer to be run on it) See also: bytecode 0xbb (""new"")
 */
public static Object resolvedNewScalar(int size,Object[] tib,boolean hasFinalizer,int allocator,int align,int offset) throws OutOfMemoryError {
  if (VM.ForceFrequentGC && VM_Scheduler.allProcessorsInitialized) {
    if (countDownToGC-- <= 0) {
      VM.sysWrite(""String_Node_Str"");
      countDownToGC=GCInterval;
      MM_Interface.gc();
    }
  }
  Object newObj=MM_Interface.allocateScalar(size,tib,allocator,align,offset);
  if (hasFinalizer)   MM_Interface.addFinalizer(newObj);
  return newObj;
}","/** 
 * Allocate something like ""new Foo()"".
 * @param size size of object (including header), in bytes
 * @param tib  type information block for object
 * @param hasFinalizer does this type have a finalizer?
 * @param allocator int that encodes which allocator should be used
 * @param align the alignment requested; must be a power of 2.
 * @param offset the offset at which the alignment is desired.
 * @return object with header installed and all fields set to zero/null(ready for initializer to be run on it) See also: bytecode 0xbb (""new"")
 */
public static Object resolvedNewScalar(int size,Object[] tib,boolean hasFinalizer,int allocator,int align,int offset) throws OutOfMemoryError {
  if (VM.ForceFrequentGC && VM_Scheduler.allProcessorsInitialized) {
    if (countDownToGC-- <= 0) {
      VM.sysWrite(""String_Node_Str"");
      countDownToGC=GCInterval;
      System.gc();
    }
  }
  Object newObj=MM_Interface.allocateScalar(size,tib,allocator,align,offset);
  if (hasFinalizer)   MM_Interface.addFinalizer(newObj);
  return newObj;
}",0.9914285714285714
150034,"/** 
 * Computes all roots.  This method establishes all roots for collection and places them in the root values, root locations and interior root locations queues.  This method should not have side effects (such as copying or forwarding of objects).  There are a number of important preconditions: <ul>  <li> All objects used in the course of GC (such as the GC thread objects) need to be ""pre-copied"" prior to calling this method. <li> The <code>threadCounter</code> must be reset so that load balancing parallel GC can share the work of scanning threads. </ul> TODO rewrite to avoid the per-thread synchronization, like precopy.
 * @param trace The trace object to use to report root locations.
 */
public static void computeAllRoots(TraceLocal trace){
  boolean processCodeLocations=MM_Interface.MOVES_OBJECTS;
  ScanStatics.scanStatics(trace);
  while (true) {
    int threadIndex=threadCounter.increment();
    if (threadIndex > VM_Scheduler.threadHighWatermark)     break;
    VM_Thread thread=VM_Scheduler.threads[threadIndex];
    if (thread == null)     continue;
    ScanThread.scanThread(thread,trace,processCodeLocations);
    trace.addRootLocation(VM_Magic.objectAsAddress(VM_Scheduler.threads).plus(threadIndex << LOG_BYTES_IN_ADDRESS));
  }
  Collection.rendezvous(4200);
}","/** 
 * Computes all roots.  This method establishes all roots for collection and places them in the root values, root locations and interior root locations queues.  This method should not have side effects (such as copying or forwarding of objects).  There are a number of important preconditions: <ul>  <li> All objects used in the course of GC (such as the GC thread objects) need to be ""pre-copied"" prior to calling this method. <li> The <code>threadCounter</code> must be reset so that load balancing parallel GC can share the work of scanning threads. </ul> TODO rewrite to avoid the per-thread synchronization, like precopy.
 * @param trace The trace object to use to report root locations.
 */
public static void computeAllRoots(TraceLocal trace){
  boolean processCodeLocations=MM_Interface.MOVES_OBJECTS;
  ScanStatics.scanStatics(trace);
  while (true) {
    int threadIndex=threadCounter.increment();
    if (threadIndex > VM_Scheduler.threadHighWatermark)     break;
    VM_Thread thread=VM_Scheduler.threads[threadIndex];
    if (thread == null)     continue;
    ScanThread.scanThread(thread,trace,processCodeLocations);
    trace.addRootLocation(VM_Magic.objectAsAddress(VM_Scheduler.threads).plus(threadIndex << LOG_BYTES_IN_ADDRESS));
  }
  ActivePlan.flushRememberedSets();
  Collection.rendezvous(4200);
}",0.9862280030604438
150035,"/** 
 * Constructor Note that the collector is a consumer of remsets, while the mutator is a producer.  The <code>GenMutator</code> class is responsible for construction of the WriteBuffer (producer).
 * @see GenMutator
 */
public GenCollector(){
  remset=new WriteBuffer(global().remsetPool);
  global().remsetPool.newConsumer();
  arrayRemset=new AddressPairDeque(global().arrayRemsetPool);
  global().arrayRemsetPool.newConsumer();
  traceRemset=new AddressDeque(""String_Node_Str"",global().remsetPool);
  nurseryTrace=new GenNurseryTraceLocal(global().nurseryTrace,this);
  sanityChecker=new GenSanityCheckerLocal();
}","/** 
 * Constructor Note that the collector is a consumer of remsets, while the mutator is a producer.  The <code>GenMutator</code> class is responsible for construction of the WriteBuffer (producer).
 * @see GenMutator
 */
public GenCollector(){
  global().remsetPool.newConsumer();
  arrayRemset=new AddressPairDeque(global().arrayRemsetPool);
  global().arrayRemsetPool.newConsumer();
  remset=new AddressDeque(""String_Node_Str"",global().remsetPool);
  nurseryTrace=new GenNurseryTraceLocal(global().nurseryTrace,this);
  sanityChecker=new GenSanityCheckerLocal();
}",0.8352941176470589
150036,"/** 
 * Process any remembered set entries.
 */
protected void flushRememberedSets(){
  logMessage(5,""String_Node_Str"");
  remset.flushLocal();
  while (!traceRemset.isEmpty()) {
    traceRemset.pop();
  }
  logMessage(5,""String_Node_Str"");
  while (!arrayRemset.isEmpty()) {
    arrayRemset.pop1();
    arrayRemset.pop2();
  }
}","/** 
 * Process any remembered set entries.
 */
protected void flushRememberedSets(){
  logMessage(5,""String_Node_Str"");
  while (!remset.isEmpty()) {
    remset.pop();
  }
  logMessage(5,""String_Node_Str"");
  while (!arrayRemset.isEmpty()) {
    arrayRemset.pop1();
    arrayRemset.pop2();
  }
}",0.9408
150037,"/** 
 * Constructor
 */
public GenMatureTraceLocal(Trace trace,GenCollector plan){
  super(trace);
  this.remset=plan.remset;
  this.traceRemset=plan.traceRemset;
  this.arrayRemset=plan.arrayRemset;
}","/** 
 * Constructor
 */
public GenMatureTraceLocal(Trace trace,GenCollector plan){
  super(trace);
  this.remset=plan.remset;
  this.arrayRemset=plan.arrayRemset;
}",0.8986301369863013
150038,"/** 
 * Constructor
 */
public GenNurseryTraceLocal(Trace trace,GenCollector plan){
  super(trace);
  this.remset=plan.remset;
  this.traceRemset=plan.traceRemset;
  this.arrayRemset=plan.arrayRemset;
}","/** 
 * Constructor
 */
public GenNurseryTraceLocal(Trace trace,GenCollector plan){
  super(trace);
  this.remset=plan.remset;
  this.arrayRemset=plan.arrayRemset;
}",0.8991825613079019
150039,"/** 
 * Process any remembered set entries.
 */
protected void flushRememberedSets() throws InlinePragma {
  logMessage(5,""String_Node_Str"");
  remset.flushLocal();
  while (!traceRemset.isEmpty()) {
    Address loc=traceRemset.pop();
    traceObjectLocation(loc,false);
  }
  logMessage(5,""String_Node_Str"");
  arrayRemset.flushLocal();
  while (!arrayRemset.isEmpty()) {
    Address start=arrayRemset.pop1();
    Address guard=arrayRemset.pop2();
    while (start.LT(guard)) {
      traceObjectLocation(start,false);
      start=start.plus(BYTES_IN_ADDRESS);
    }
  }
}","/** 
 * Process any remembered set entries.
 */
protected void flushRememberedSets() throws InlinePragma {
  logMessage(5,""String_Node_Str"");
  while (!remset.isEmpty()) {
    Address loc=remset.pop();
    traceObjectLocation(loc,false);
  }
  logMessage(5,""String_Node_Str"");
  arrayRemset.flushLocal();
  while (!arrayRemset.isEmpty()) {
    Address start=arrayRemset.pop1();
    Address guard=arrayRemset.pop2();
    while (start.LT(guard)) {
      traceObjectLocation(start,false);
      start=start.plus(BYTES_IN_ADDRESS);
    }
  }
}",0.9666966696669668
150040,"public static boolean validRef(ObjectReference ref) throws UninterruptiblePragma {
  if (ref.isNull())   return true;
  if (!Space.isMappedObject(ref)) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    Space.printVMMap();
    return false;
  }
  if (MM_Interface.MOVES_OBJECTS) {
  }
  Object[] tib=VM_ObjectModel.getTIB(ref);
  Address tibAddr=VM_Magic.objectAsAddress(tib);
  if (!Space.isMappedObject(ref)) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(tibAddr);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  if (tibAddr.isZero()) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  if (tib.length == 0) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(tibAddr);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  ObjectReference type=ObjectReference.fromObject(tib[0]);
  if (!validType(type)) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(VM_Magic.objectAsAddress(tib));
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(type);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  return true;
}","public static boolean validRef(ObjectReference ref) throws UninterruptiblePragma {
  if (ref.isNull())   return true;
  if (!Space.isMappedObject(ref)) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    Space.printVMMap();
    return false;
  }
  if (MM_Interface.MOVES_OBJECTS) {
  }
  Object[] tib=VM_ObjectModel.getTIB(ref);
  Address tibAddr=VM_Magic.objectAsAddress(tib);
  if (!Space.isMappedObject(ObjectReference.fromObject(tib))) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(tibAddr);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  if (tibAddr.isZero()) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  if (tib.length == 0) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(tibAddr);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  ObjectReference type=ObjectReference.fromObject(tib[0]);
  if (!validType(type)) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(ref);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(VM_Magic.objectAsAddress(tib));
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(type);
    VM.sysWrite(""String_Node_Str"");
    return false;
  }
  return true;
}",0.9874908020603383
150041,"/** 
 * Prepare a mutator for a collection.
 * @param m the mutator to prepare
 */
public static void prepareMutator(MutatorContext m){
  VM_Processor vp=((SelectedMutatorContext)m).getProcessor();
  int vpStatus=vp.vpStatus;
  if (vpStatus == VM_Processor.BLOCKED_IN_NATIVE) {
    VM_Thread t=vp.activeThread;
    t.contextRegisters.setInnermost(Address.zero(),t.jniEnv.topJavaFP());
  }
 else {
    VM_Thread t=VM_Thread.getCurrentThread();
    Address fp=VM_Magic.getFramePointer();
    while (true) {
      Address caller_ip=VM_Magic.getReturnAddress(fp);
      Address caller_fp=VM_Magic.getCallerFramePointer(fp);
      if (VM_Magic.getCallerFramePointer(caller_fp).EQ(STACKFRAME_SENTINEL_FP))       VM.sysFail(""String_Node_Str"");
      int compiledMethodId=VM_Magic.getCompiledMethodID(caller_fp);
      VM_CompiledMethod compiledMethod=VM_CompiledMethods.getCompiledMethod(compiledMethodId);
      VM_Method method=compiledMethod.getMethod();
      VM_Atom cls=method.getDeclaringClass().getDescriptor();
      VM_Atom name=method.getName();
      if (name == runAtom && cls == collectorThreadAtom) {
        t.contextRegisters.setInnermost(caller_ip,caller_fp);
        break;
      }
      fp=caller_fp;
    }
  }
}","/** 
 * Prepare a mutator for a collection.
 * @param m the mutator to prepare
 */
public static void prepareMutator(MutatorContext m){
  VM_Processor vp=((SelectedMutatorContext)m).getProcessor();
  int vpStatus=vp.vpStatus;
  if (vpStatus == VM_Processor.BLOCKED_IN_NATIVE) {
    VM_Thread t=vp.activeThread;
    t.contextRegisters.setInnermost(Address.zero(),t.jniEnv.topJavaFP());
  }
}",0.4829721362229102
150042,"/** 
 * Perform a per-collector collection phase.
 * @param phaseId The unique phase identifier
 * @param primary Should this thread be used to execute any single-threadedlocal operations?
 */
public void collectionPhase(int phaseId,boolean primary) throws InlinePragma {
  if (phaseId == StopTheWorld.PREPARE) {
    return;
  }
  if (phaseId == StopTheWorld.PRECOPY) {
    if (ActivePlan.constraints().movesObjects()) {
      Scanning.preCopyGCInstances(getCurrentTrace());
    }
    return;
  }
  if (phaseId == StopTheWorld.ROOTS) {
    Scanning.computeAllRoots(getCurrentTrace());
    return;
  }
  if (phaseId == StopTheWorld.SOFT_REFS) {
    if (primary && !Options.noReferenceTypes.getValue())     ReferenceProcessor.processSoftReferences(global().isCurrentGCNursery());
    return;
  }
  if (phaseId == StopTheWorld.WEAK_REFS) {
    if (primary && !Options.noReferenceTypes.getValue())     ReferenceProcessor.processWeakReferences(global().isCurrentGCNursery());
    return;
  }
  if (phaseId == StopTheWorld.FINALIZABLE) {
    if (primary) {
      if (Options.noFinalizer.getValue())       Finalizer.kill();
 else       Finalizer.moveToFinalizable(getCurrentTrace());
    }
    return;
  }
  if (phaseId == StopTheWorld.PHANTOM_REFS) {
    if (primary && !Options.noReferenceTypes.getValue())     ReferenceProcessor.processPhantomReferences(global().isCurrentGCNursery());
    return;
  }
  if (phaseId == StopTheWorld.FORWARD_REFS) {
    if (primary && !Options.noReferenceTypes.getValue() && ActivePlan.constraints().needsForwardAfterLiveness()) {
      ReferenceProcessor.forwardReferences();
    }
    return;
  }
  if (phaseId == StopTheWorld.FORWARD_FINALIZABLE) {
    if (primary && !Options.noFinalizer.getValue() && ActivePlan.constraints().needsForwardAfterLiveness()) {
      Finalizer.forward(getCurrentTrace());
    }
    return;
  }
  if (phaseId == StopTheWorld.COMPLETE) {
    return;
  }
  if (phaseId == StopTheWorld.RELEASE) {
    return;
  }
  if (Options.sanityCheck.getValue() && getSanityChecker().collectionPhase(phaseId,primary)) {
    return;
  }
  Log.write(""String_Node_Str"");
  Log.write(Phase.getName(phaseId));
  Log.writeln(""String_Node_Str"");
  Assert.fail(""String_Node_Str"");
}","/** 
 * Perform a per-collector collection phase.
 * @param phaseId The unique phase identifier
 * @param primary Should this thread be used to execute any single-threadedlocal operations?
 */
public void collectionPhase(int phaseId,boolean primary) throws InlinePragma {
  if (phaseId == StopTheWorld.INITIATE) {
    Collection.prepareCollector(this);
    return;
  }
  if (phaseId == StopTheWorld.PREPARE) {
    return;
  }
  if (phaseId == StopTheWorld.PRECOPY) {
    if (ActivePlan.constraints().movesObjects()) {
      Scanning.preCopyGCInstances(getCurrentTrace());
    }
    return;
  }
  if (phaseId == StopTheWorld.ROOTS) {
    Scanning.computeAllRoots(getCurrentTrace());
    return;
  }
  if (phaseId == StopTheWorld.SOFT_REFS) {
    if (primary && !Options.noReferenceTypes.getValue())     ReferenceProcessor.processSoftReferences(global().isCurrentGCNursery());
    return;
  }
  if (phaseId == StopTheWorld.WEAK_REFS) {
    if (primary && !Options.noReferenceTypes.getValue())     ReferenceProcessor.processWeakReferences(global().isCurrentGCNursery());
    return;
  }
  if (phaseId == StopTheWorld.FINALIZABLE) {
    if (primary) {
      if (Options.noFinalizer.getValue())       Finalizer.kill();
 else       Finalizer.moveToFinalizable(getCurrentTrace());
    }
    return;
  }
  if (phaseId == StopTheWorld.PHANTOM_REFS) {
    if (primary && !Options.noReferenceTypes.getValue())     ReferenceProcessor.processPhantomReferences(global().isCurrentGCNursery());
    return;
  }
  if (phaseId == StopTheWorld.FORWARD_REFS) {
    if (primary && !Options.noReferenceTypes.getValue() && ActivePlan.constraints().needsForwardAfterLiveness()) {
      ReferenceProcessor.forwardReferences();
    }
    return;
  }
  if (phaseId == StopTheWorld.FORWARD_FINALIZABLE) {
    if (primary && !Options.noFinalizer.getValue() && ActivePlan.constraints().needsForwardAfterLiveness()) {
      Finalizer.forward(getCurrentTrace());
    }
    return;
  }
  if (phaseId == StopTheWorld.COMPLETE) {
    return;
  }
  if (phaseId == StopTheWorld.RELEASE) {
    return;
  }
  if (Options.sanityCheck.getValue() && getSanityChecker().collectionPhase(phaseId,primary)) {
    return;
  }
  Log.write(""String_Node_Str"");
  Log.write(Phase.getName(phaseId));
  Log.writeln(""String_Node_Str"");
  Assert.fail(""String_Node_Str"");
}",0.9786202336345604
150043,"/** 
 * Fill the specified region with the alignment value.
 * @param start The start of the region.
 * @param end A pointer past the end of the region.
 */
final public static void fillAlignmentGap(Address start,Address end) throws InlinePragma {
  while (start.LT(end)) {
    start.store(ALIGNMENT_VALUE);
    start=start.add(BYTES_IN_INT);
  }
}","/** 
 * Fill the specified region with the alignment value.
 * @param start The start of the region.
 * @param end A pointer past the end of the region.
 */
final public static void fillAlignmentGap(Address start,Address end) throws InlinePragma {
  if ((MAX_ALIGNMENT - MIN_ALIGNMENT) == BYTES_IN_INT) {
    if (!end.diff(start).isZero()) {
      start.store(ALIGNMENT_VALUE);
    }
  }
 else {
    while (start.LT(end)) {
      start.store(ALIGNMENT_VALUE);
      start=start.add(BYTES_IN_INT);
    }
  }
}",0.6542056074766355
150044,"/** 
 * Allocate space for a new object.  This is frequently executed code and  the coding is deliberaetly sensitive to the optimizing compiler. After changing this, always check the IR/MC that is generated.
 * @param bytes The number of bytes allocated
 * @param align The requested alignment
 * @param offset The offset from the alignment 
 * @return The address of the first byte of the allocated region
 */
final public Address alloc(int bytes,int align,int offset) throws InlinePragma {
  Address oldCursor=alignAllocation(cursor,align,offset);
  Address newCursor=oldCursor.add(bytes);
  if (newCursor.GT(limit))   return allocSlow(bytes,align,offset);
  cursor=newCursor;
  return oldCursor;
}","/** 
 * Allocate space for a new object.  This is frequently executed code and  the coding is deliberaetly sensitive to the optimizing compiler. After changing this, always check the IR/MC that is generated.
 * @param bytes The number of bytes allocated
 * @param align The requested alignment
 * @param offset The offset from the alignment 
 * @return The address of the first byte of the allocated region
 */
final public Address alloc(int bytes,int align,int offset) throws InlinePragma {
  Address oldCursor=alignAllocationNoFill(cursor,align,offset);
  Address newCursor=oldCursor.add(bytes);
  if (newCursor.GT(limit))   return allocSlow(bytes,align,offset);
  fillAlignmentGap(cursor,oldCursor);
  cursor=newCursor;
  return oldCursor;
}",0.969529085872576
150045,"private void processEdge(OPT_LSTNode n,OPT_BasicBlock source,OPT_BasicBlock target,float prob,float weight){
  if (target.getScratchFlag())   return;
  if (n.loop.get(target.getNumber())) {
    OPT_LSTNode other=lst.getLoop(target);
    if (other == n) {
      target.augmentExecutionFrequency(prob * weight);
    }
 else {
      float exitWeight=computeLoopExitWeight(other);
      for (Iterator i=other.loopExits.iterator(); i.hasNext(); ) {
        OPT_LSTNode.Edge exit=(OPT_LSTNode.Edge)i.next();
        float myWeight=exit.source.getExecutionFrequency() * exit.probability;
        float myFraction=myWeight / exitWeight;
        processEdge(n,source,exit.target,prob * myFraction,weight);
      }
    }
  }
 else {
    n.addLoopExit(source,target,prob);
  }
}","private void processEdge(OPT_LSTNode n,OPT_BasicBlock source,OPT_BasicBlock target,float prob,float weight){
  if (target.getScratchFlag())   return;
  if (n.loop.get(target.getNumber())) {
    OPT_LSTNode other=lst.getLoop(target);
    if (other == n) {
      target.augmentExecutionFrequency(prob * weight);
    }
 else {
      target.setScratchFlag();
      float exitWeight=computeLoopExitWeight(other);
      for (Iterator i=other.loopExits.iterator(); i.hasNext(); ) {
        OPT_LSTNode.Edge exit=(OPT_LSTNode.Edge)i.next();
        float myWeight=exit.source.getExecutionFrequency() * exit.probability;
        float myFraction=myWeight / exitWeight;
        processEdge(n,source,exit.target,prob * myFraction,weight);
      }
      target.clearScratchFlag();
    }
  }
 else {
    n.addLoopExit(source,target,prob);
  }
}",0.9599499374217773
150046,"/** 
 * How much time do we expect to spend in the method in the future if we take no recompilation action? The key assumption is that we'll spend just as much time  executing in the the method in the future as we have done so far in the past.
 * @param hme The VM_HotMethodEvent in question
 * @return estimate of future execution time to be spent in this method
 */
double futureTimeForMethod(VM_HotMethodEvent hme){
  VM_AOSOptions opts=VM_Controller.options;
  double numSamples=hme.getNumSamples();
  double timePerSample=(double)VM.interruptQuantum;
  if (!VM.UseEpilogueYieldPoints) {
    timePerSample/=2.0;
  }
  if (VM_Controller.options.mlCBS()) {
    timePerSample/=(double)VM.CBSMethodSamplesPerTick;
  }
  double timeInMethodSoFar=numSamples * timePerSample;
  return timeInMethodSoFar;
}","/** 
 * How much time do we expect to spend in the method in the future if we take no recompilation action? The key assumption is that we'll spend just as much time  executing in the the method in the future as we have done so far in the past.
 * @param hme The VM_HotMethodEvent in question
 * @return estimate of future execution time to be spent in this method
 */
double futureTimeForMethod(VM_HotMethodEvent hme){
  double numSamples=hme.getNumSamples();
  double timePerSample=(double)VM.interruptQuantum;
  if (!VM.UseEpilogueYieldPoints) {
    timePerSample/=2.0;
  }
  if (VM_Controller.options.mlCBS()) {
    timePerSample/=(double)VM.CBSMethodSamplesPerTick;
  }
  double timeInMethodSoFar=numSamples * timePerSample;
  return timeInMethodSoFar;
}",0.9717948717948718
150047,"public String toString(){
  VM_CompiledMethod cm=VM_CompiledMethods.getCompiledMethod(cmid);
  VM_Method m=cm.getMethod();
  return ""String_Node_Str"" + Integer.toHexString(cmid) + ""String_Node_Str""+ ""String_Node_Str""+ origIdx;
}","public String toString(){
  VM_CompiledMethod cm=VM_CompiledMethods.getCompiledMethod(cmid);
  return ""String_Node_Str"" + Integer.toHexString(cmid) + ""String_Node_Str""+ ""String_Node_Str""+ origIdx;
}",0.9295774647887324
150048,"/** 
 * Explicitly copy parameters to a system call into the appropriate physical registers as defined by the calling convention.  Note that for a system call (ie., a call to C), the order of parameters on the stack is <em> reversed </em> compared to the normal RVM calling convention TODO: much of this code is exactly the same as in expandParametersToCall(). factor out the common code. Note: Assumes that ESP points to the word before the slot where the first parameter should be stored.
 */
private static int expandParametersToSysCall(OPT_Instruction call,OPT_IR ir){
  int nGPRParams=0;
  int nFPRParams=0;
  int parameterBytes=0;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Register ESP=phys.getESP();
  int FPRRegisterParams=countFPRParams(call);
  FPRRegisterParams=Math.min(FPRRegisterParams,OPT_PhysicalRegisterSet.getNumberOfFPRParams());
  int numParams=MIR_Call.getNumberOfParams(call);
  for (int i=numParams - 1; i >= 0; i--) {
    OPT_Operand param=MIR_Call.getClearParam(call,i);
    MIR_Call.setParam(call,i,null);
    VM_TypeReference paramType=param.getType();
    if (paramType.isFloatType() || paramType.isDoubleType()) {
      nFPRParams++;
      int size=paramType.isFloatType() ? 4 : 8;
      parameterBytes-=size;
      OPT_Operand M=new OPT_StackLocationOperand(false,parameterBytes,size);
      call.insertBefore(MIR_Move.create(IA32_FMOV,M,param));
    }
 else {
      nGPRParams++;
      parameterBytes-=4;
      call.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(parameterBytes + 4)));
      call.insertBefore(MIR_UnaryNoRes.create(IA32_PUSH,param));
    }
  }
  return parameterBytes;
}","/** 
 * Explicitly copy parameters to a system call into the appropriate physical registers as defined by the calling convention.  Note that for a system call (ie., a call to C), the order of parameters on the stack is <em> reversed </em> compared to the normal RVM calling convention TODO: much of this code is exactly the same as in expandParametersToCall(). factor out the common code. Note: Assumes that ESP points to the word before the slot where the first parameter should be stored.
 */
private static int expandParametersToSysCall(OPT_Instruction call,OPT_IR ir){
  int nGPRParams=0;
  int nFPRParams=0;
  int parameterBytes=0;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  int numParams=MIR_Call.getNumberOfParams(call);
  for (int i=numParams - 1; i >= 0; i--) {
    OPT_Operand param=MIR_Call.getClearParam(call,i);
    MIR_Call.setParam(call,i,null);
    VM_TypeReference paramType=param.getType();
    if (paramType.isFloatType() || paramType.isDoubleType()) {
      nFPRParams++;
      int size=paramType.isFloatType() ? 4 : 8;
      parameterBytes-=size;
      OPT_Operand M=new OPT_StackLocationOperand(false,parameterBytes,size);
      call.insertBefore(MIR_Move.create(IA32_FMOV,M,param));
    }
 else {
      nGPRParams++;
      parameterBytes-=4;
      call.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(parameterBytes + 4)));
      call.insertBefore(MIR_UnaryNoRes.create(IA32_PUSH,param));
    }
  }
  return parameterBytes;
}",0.9437699680511182
150049,"/** 
 * Explicitly copy parameters to a call into the appropriate physical registers as defined by the calling convention. Note: Assumes that ESP points to the word before the slot where the first parameter should be stored.
 */
private static int expandParametersToCall(OPT_Instruction call,OPT_IR ir){
  int nGPRParams=0;
  int nFPRParams=0;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  int FPRRegisterParams=countFPRParams(call);
  FPRRegisterParams=Math.min(FPRRegisterParams,OPT_PhysicalRegisterSet.getNumberOfFPRParams());
  int parameterBytes=0;
  OPT_Register ESP=phys.getESP();
  call.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(0)));
  int numParams=MIR_Call.getNumberOfParams(call);
  int nParamsInRegisters=0;
  for (int i=0; i < numParams; i++) {
    OPT_Operand param=MIR_Call.getClearParam(call,i);
    MIR_Call.setParam(call,i,null);
    VM_TypeReference paramType=param.getType();
    if (paramType.isFloatType() || paramType.isDoubleType()) {
      nFPRParams++;
      int size=paramType.isFloatType() ? 4 : 8;
      parameterBytes-=size;
      if (nFPRParams > OPT_PhysicalRegisterSet.getNumberOfFPRParams()) {
        OPT_Operand M=new OPT_StackLocationOperand(false,parameterBytes,size);
        call.insertBefore(MIR_Move.create(IA32_FMOV,M,param));
      }
 else {
        OPT_Register phy=phys.getFPRParam(FPRRegisterParams - nFPRParams);
        OPT_RegisterOperand real=new OPT_RegisterOperand(phy,paramType);
        call.insertBefore(MIR_Move.create(IA32_FMOV,real,param));
        MIR_Call.setParam(call,nParamsInRegisters++,real.copy());
      }
    }
 else {
      nGPRParams++;
      parameterBytes-=4;
      if (nGPRParams > OPT_PhysicalRegisterSet.getNumberOfGPRParams()) {
        call.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(parameterBytes + 4)));
        call.insertBefore(MIR_UnaryNoRes.create(IA32_PUSH,param));
      }
 else {
        OPT_Register phy=phys.getGPRParam(nGPRParams - 1);
        OPT_RegisterOperand real=new OPT_RegisterOperand(phy,paramType);
        call.insertBefore(MIR_Move.create(IA32_MOV,real,param));
        MIR_Call.setParam(call,nParamsInRegisters++,real.copy());
      }
    }
  }
  return parameterBytes;
}","/** 
 * Explicitly copy parameters to a call into the appropriate physical registers as defined by the calling convention. Note: Assumes that ESP points to the word before the slot where the first parameter should be stored.
 */
private static int expandParametersToCall(OPT_Instruction call,OPT_IR ir){
  int nGPRParams=0;
  int nFPRParams=0;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  int FPRRegisterParams=countFPRParams(call);
  FPRRegisterParams=Math.min(FPRRegisterParams,OPT_PhysicalRegisterSet.getNumberOfFPRParams());
  int parameterBytes=0;
  call.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(0)));
  int numParams=MIR_Call.getNumberOfParams(call);
  int nParamsInRegisters=0;
  for (int i=0; i < numParams; i++) {
    OPT_Operand param=MIR_Call.getClearParam(call,i);
    MIR_Call.setParam(call,i,null);
    VM_TypeReference paramType=param.getType();
    if (paramType.isFloatType() || paramType.isDoubleType()) {
      nFPRParams++;
      int size=paramType.isFloatType() ? 4 : 8;
      parameterBytes-=size;
      if (nFPRParams > OPT_PhysicalRegisterSet.getNumberOfFPRParams()) {
        OPT_Operand M=new OPT_StackLocationOperand(false,parameterBytes,size);
        call.insertBefore(MIR_Move.create(IA32_FMOV,M,param));
      }
 else {
        OPT_Register phy=phys.getFPRParam(FPRRegisterParams - nFPRParams);
        OPT_RegisterOperand real=new OPT_RegisterOperand(phy,paramType);
        call.insertBefore(MIR_Move.create(IA32_FMOV,real,param));
        MIR_Call.setParam(call,nParamsInRegisters++,real.copy());
      }
    }
 else {
      nGPRParams++;
      parameterBytes-=4;
      if (nGPRParams > OPT_PhysicalRegisterSet.getNumberOfGPRParams()) {
        call.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(parameterBytes + 4)));
        call.insertBefore(MIR_UnaryNoRes.create(IA32_PUSH,param));
      }
 else {
        OPT_Register phy=phys.getGPRParam(nGPRParams - 1);
        OPT_RegisterOperand real=new OPT_RegisterOperand(phy,paramType);
        call.insertBefore(MIR_Move.create(IA32_MOV,real,param));
        MIR_Call.setParam(call,nParamsInRegisters++,real.copy());
      }
    }
  }
  return parameterBytes;
}",0.9922656960873522
150050,"/** 
 * We have to save/restore the non-volatile registers around syscalls, to protect ourselves from malicious C compilers and Linux kernels. Although the register allocator is not yet ready to insert these spills, allocate space on the stack in preparation. For now, we naively save/restore all nonvolatiles.
 */
public static void allocateSpaceForSysCall(OPT_IR ir){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_StackManager sm=(OPT_StackManager)ir.stackManager;
  int nToSave=OPT_PhysicalRegisterSet.getNumberOfNonvolatileGPRs() + 1;
  sm.allocateSpaceForSysCall(nToSave);
}","/** 
 * We have to save/restore the non-volatile registers around syscalls, to protect ourselves from malicious C compilers and Linux kernels. Although the register allocator is not yet ready to insert these spills, allocate space on the stack in preparation. For now, we naively save/restore all nonvolatiles.
 */
public static void allocateSpaceForSysCall(OPT_IR ir){
  OPT_StackManager sm=(OPT_StackManager)ir.stackManager;
  int nToSave=OPT_PhysicalRegisterSet.getNumberOfNonvolatileGPRs() + 1;
  sm.allocateSpaceForSysCall(nToSave);
}",0.9406631762652704
150051,"/** 
 * Insert a spill of a physical register before instruction s.
 * @param s the instruction before which the spill should occur
 * @param r the register (should be physical) to spill
 * @param type one of INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE, orCONDITION_VALUE
 * @param location the spill location, as an offset from the framepointer
 */
final void insertSpillBefore(OPT_Instruction s,OPT_Register r,byte type,int location){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Operator move=getMoveOperator(type);
  byte size=getSizeOfType(type);
  OPT_RegisterOperand rOp;
switch (type) {
case FLOAT_VALUE:
    rOp=F(r);
  break;
case DOUBLE_VALUE:
rOp=D(r);
break;
default :
rOp=new OPT_RegisterOperand(r,VM_TypeReference.Int);
break;
}
OPT_StackLocationOperand spill=new OPT_StackLocationOperand(true,-location,size);
s.insertBefore(MIR_Move.create(move,spill,rOp));
}","/** 
 * Insert a spill of a physical register before instruction s.
 * @param s the instruction before which the spill should occur
 * @param r the register (should be physical) to spill
 * @param type one of INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE, orCONDITION_VALUE
 * @param location the spill location, as an offset from the framepointer
 */
final void insertSpillBefore(OPT_Instruction s,OPT_Register r,byte type,int location){
  OPT_Operator move=getMoveOperator(type);
  byte size=getSizeOfType(type);
  OPT_RegisterOperand rOp;
switch (type) {
case FLOAT_VALUE:
    rOp=F(r);
  break;
case DOUBLE_VALUE:
rOp=D(r);
break;
default :
rOp=new OPT_RegisterOperand(r,VM_TypeReference.Int);
break;
}
OPT_StackLocationOperand spill=new OPT_StackLocationOperand(true,-location,size);
s.insertBefore(MIR_Move.create(move,spill,rOp));
}",0.960648148148148
150052,"/** 
 * Insert the epilogue before a particular return instruction.
 * @param ret the return instruction.
 */
private void insertEpilogue(OPT_Instruction ret){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Register ESP=phys.getESP();
  OPT_Register PR=phys.getPR();
  if (ir.compiledMethod.isSaveVolatile()) {
    restoreVolatileRegisters(ret);
    restoreFloatingPointState(ret);
  }
  restoreNonVolatiles(ret);
  int frameSize=getFrameFixedSize();
  ret.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(frameSize)));
  OPT_MemoryOperand fpHome=OPT_MemoryOperand.BD(new OPT_RegisterOperand(PR,VM_TypeReference.Int),VM_Entrypoints.framePointerField.getOffset(),(byte)WORDSIZE,null,null);
  ret.insertBefore(MIR_Nullary.create(IA32_POP,fpHome));
}","/** 
 * Insert the epilogue before a particular return instruction.
 * @param ret the return instruction.
 */
private void insertEpilogue(OPT_Instruction ret){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Register PR=phys.getPR();
  if (ir.compiledMethod.isSaveVolatile()) {
    restoreVolatileRegisters(ret);
    restoreFloatingPointState(ret);
  }
  restoreNonVolatiles(ret);
  int frameSize=getFrameFixedSize();
  ret.insertBefore(MIR_UnaryNoRes.create(REQUIRE_ESP,IC(frameSize)));
  OPT_MemoryOperand fpHome=OPT_MemoryOperand.BD(new OPT_RegisterOperand(PR,VM_TypeReference.Int),VM_Entrypoints.framePointerField.getOffset(),(byte)WORDSIZE,null,null);
  ret.insertBefore(MIR_Nullary.create(IA32_POP,fpHome));
}",0.9775725593667546
150053,"/** 
 * In instruction s, replace all appearances of a symbolic register  operand with uses of the appropriate spill location, as cached by the register allocator.
 * @param s the instruction to mutate.
 * @param symb the symbolic register operand to replace
 */
void replaceOperandWithSpillLocation(OPT_Instruction s,OPT_RegisterOperand symb){
  int location=OPT_RegisterAllocatorState.getSpill(symb.register);
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Operand M=null;
  int type=OPT_PhysicalRegisterSet.getPhysicalRegisterType(symb.register);
  int size=OPT_PhysicalRegisterSet.getSpillSize(type);
  M=new OPT_StackLocationOperand(true,-location,(byte)size);
  s.replaceOperand(symb,M);
}","/** 
 * In instruction s, replace all appearances of a symbolic register  operand with uses of the appropriate spill location, as cached by the register allocator.
 * @param s the instruction to mutate.
 * @param symb the symbolic register operand to replace
 */
void replaceOperandWithSpillLocation(OPT_Instruction s,OPT_RegisterOperand symb){
  int location=OPT_RegisterAllocatorState.getSpill(symb.register);
  OPT_Operand M=null;
  int type=OPT_PhysicalRegisterSet.getPhysicalRegisterType(symb.register);
  int size=OPT_PhysicalRegisterSet.getSpillSize(type);
  M=new OPT_StackLocationOperand(true,-location,(byte)size);
  s.replaceOperand(symb,M);
}",0.9505813953488372
150054,"/** 
 * Clean up some junk that's left in the IR after register allocation, and add epilogue code.
 */
void cleanUpAndInsertEpilogue(){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Instruction inst=ir.firstInstructionInCodeOrder().nextInstructionInCodeOrder();
  for (; inst != null; inst=inst.nextInstructionInCodeOrder()) {
switch (inst.getOpcode()) {
case IA32_MOV_opcode:
      OPT_Operand result=MIR_Move.getResult(inst);
    OPT_Operand val=MIR_Move.getValue(inst);
  if (result.similar(val)) {
    inst=inst.remove();
  }
break;
case IA32_FMOV_opcode:
result=MIR_Move.getResult(inst);
val=MIR_Move.getValue(inst);
if (result.similar(val)) {
inst=inst.remove();
}
break;
case IA32_RET_opcode:
if (frameIsRequired()) {
insertEpilogue(inst);
}
default :
break;
}
}
rewriteStackLocations();
}","/** 
 * Clean up some junk that's left in the IR after register allocation, and add epilogue code.
 */
void cleanUpAndInsertEpilogue(){
  OPT_Instruction inst=ir.firstInstructionInCodeOrder().nextInstructionInCodeOrder();
  for (; inst != null; inst=inst.nextInstructionInCodeOrder()) {
switch (inst.getOpcode()) {
case IA32_MOV_opcode:
      OPT_Operand result=MIR_Move.getResult(inst);
    OPT_Operand val=MIR_Move.getValue(inst);
  if (result.similar(val)) {
    inst=inst.remove();
  }
break;
case IA32_FMOV_opcode:
result=MIR_Move.getResult(inst);
val=MIR_Move.getValue(inst);
if (result.similar(val)) {
inst=inst.remove();
}
break;
case IA32_RET_opcode:
if (frameIsRequired()) {
insertEpilogue(inst);
}
default :
break;
}
}
rewriteStackLocations();
}",0.9569620253164556
150055,"/** 
 * Insert code into the prologue to save the floating point state.
 * @param inst the first instruction after the prologue.  
 */
private void saveFloatingPointState(OPT_Instruction inst){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Operand M=new OPT_StackLocationOperand(true,-fsaveLocation,4);
  inst.insertBefore(MIR_FSave.create(IA32_FNSAVE,M));
}","/** 
 * Insert code into the prologue to save the floating point state.
 * @param inst the first instruction after the prologue.  
 */
private void saveFloatingPointState(OPT_Instruction inst){
  OPT_Operand M=new OPT_StackLocationOperand(true,-fsaveLocation,4);
  inst.insertBefore(MIR_FSave.create(IA32_FNSAVE,M));
}",0.9034090909090908
150056,"/** 
 * Insert code into the epilogue to restore the floating point state.
 * @param inst the return instruction after the epilogue.  
 */
private void restoreFloatingPointState(OPT_Instruction inst){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Operand M=new OPT_StackLocationOperand(true,-fsaveLocation,4);
  inst.insertBefore(MIR_FSave.create(IA32_FRSTOR,M));
}","/** 
 * Insert code into the epilogue to restore the floating point state.
 * @param inst the return instruction after the epilogue.  
 */
private void restoreFloatingPointState(OPT_Instruction inst){
  OPT_Operand M=new OPT_StackLocationOperand(true,-fsaveLocation,4);
  inst.insertBefore(MIR_FSave.create(IA32_FRSTOR,M));
}",0.9052924791086352
150057,"/** 
 * Rewrite a move instruction if it has 2 memory operands. One of the 2 memory operands must be a stack location operand.  Move the SP to the appropriate location and use a push or pop instruction.
 */
private void rewriteMoveInstruction(OPT_Instruction s){
  if (mutateMoveToNop(s))   return;
  OPT_Register ESP=ir.regpool.getPhysicalRegisterSet().getESP();
  OPT_Operand result=MIR_Move.getResult(s);
  OPT_Operand val=MIR_Move.getValue(s);
  if (result instanceof OPT_StackLocationOperand) {
    if (val instanceof OPT_MemoryOperand || val instanceof OPT_StackLocationOperand) {
      int offset=((OPT_StackLocationOperand)result).getOffset();
      byte size=((OPT_StackLocationOperand)result).getSize();
      offset=FPOffset2SPOffset(offset) + size;
      moveESPBefore(s,offset);
      MIR_UnaryNoRes.mutate(s,IA32_PUSH,val);
    }
  }
 else {
    if (result instanceof OPT_MemoryOperand) {
      if (val instanceof OPT_StackLocationOperand) {
        int offset=((OPT_StackLocationOperand)val).getOffset();
        offset=FPOffset2SPOffset(offset);
        moveESPBefore(s,offset);
        MIR_Nullary.mutate(s,IA32_POP,result);
      }
    }
  }
}","/** 
 * Rewrite a move instruction if it has 2 memory operands. One of the 2 memory operands must be a stack location operand.  Move the SP to the appropriate location and use a push or pop instruction.
 */
private void rewriteMoveInstruction(OPT_Instruction s){
  if (mutateMoveToNop(s))   return;
  OPT_Operand result=MIR_Move.getResult(s);
  OPT_Operand val=MIR_Move.getValue(s);
  if (result instanceof OPT_StackLocationOperand) {
    if (val instanceof OPT_MemoryOperand || val instanceof OPT_StackLocationOperand) {
      int offset=((OPT_StackLocationOperand)result).getOffset();
      byte size=((OPT_StackLocationOperand)result).getSize();
      offset=FPOffset2SPOffset(offset) + size;
      moveESPBefore(s,offset);
      MIR_UnaryNoRes.mutate(s,IA32_PUSH,val);
    }
  }
 else {
    if (result instanceof OPT_MemoryOperand) {
      if (val instanceof OPT_StackLocationOperand) {
        int offset=((OPT_StackLocationOperand)val).getOffset();
        offset=FPOffset2SPOffset(offset);
        moveESPBefore(s,offset);
        MIR_Nullary.mutate(s,IA32_POP,result);
      }
    }
  }
}",0.9712007089056268
150058,"/** 
 * Insert a load of a physical register from a spill location before  instruction s.
 * @param s the instruction before which the spill should occur
 * @param r the register (should be physical) to spill
 * @param type one of INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE, orCONDITION_VALUE
 * @param location the spill location
 */
final void insertUnspillBefore(OPT_Instruction s,OPT_Register r,byte type,int location){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  OPT_Operator move=getMoveOperator(type);
  byte size=getSizeOfType(type);
  OPT_RegisterOperand rOp;
switch (type) {
case FLOAT_VALUE:
    rOp=F(r);
  break;
case DOUBLE_VALUE:
rOp=D(r);
break;
default :
rOp=new OPT_RegisterOperand(r,VM_TypeReference.Int);
break;
}
OPT_StackLocationOperand spill=new OPT_StackLocationOperand(true,-location,size);
s.insertBefore(MIR_Move.create(move,rOp,spill));
}","/** 
 * Insert a load of a physical register from a spill location before  instruction s.
 * @param s the instruction before which the spill should occur
 * @param r the register (should be physical) to spill
 * @param type one of INT_VALUE, FLOAT_VALUE, DOUBLE_VALUE, orCONDITION_VALUE
 * @param location the spill location
 */
final void insertUnspillBefore(OPT_Instruction s,OPT_Register r,byte type,int location){
  OPT_Operator move=getMoveOperator(type);
  byte size=getSizeOfType(type);
  OPT_RegisterOperand rOp;
switch (type) {
case FLOAT_VALUE:
    rOp=F(r);
  break;
case DOUBLE_VALUE:
rOp=D(r);
break;
default :
rOp=new OPT_RegisterOperand(r,VM_TypeReference.Int);
break;
}
OPT_StackLocationOperand spill=new OPT_StackLocationOperand(true,-location,size);
s.insertBefore(MIR_Move.create(move,rOp,spill));
}",0.960093896713615
150059,"/** 
 * Read the contents of the field. If the contents of this field is an object, return that object. If the contents of this field is a primitive, get the value and wrap it in an object.
 */
public final Object getObjectUnchecked(Object obj){
  VM_TypeReference type=getType();
  if (type.isReferenceType()) {
    return getObjectValueUnchecked(obj);
  }
 else {
    if (type.isCharType())     return new Character(getCharValueUnchecked(obj));
    if (type.isDoubleType())     return new Double(getDoubleValueUnchecked(obj));
    if (type.isFloatType())     return new Float(getFloatValueUnchecked(obj));
    if (type.isLongType())     return new Long(getLongValueUnchecked(obj));
    if (type.isIntType())     return new Integer(getIntValueUnchecked(obj));
    if (type.isShortType())     return new Short(getShortValueUnchecked(obj));
    if (type.isByteType())     return new Byte(getByteValueUnchecked(obj));
    if (type.isBooleanType())     return new Boolean(getBooleanValueUnchecked(obj));
    return null;
  }
}","/** 
 * Read the contents of the field. If the contents of this field is an object, return that object. If the contents of this field is a primitive, get the value and wrap it in an object.
 */
public final Object getObjectUnchecked(Object obj){
  VM_TypeReference type=getType();
  if (type.isReferenceType()) {
    return getObjectValueUnchecked(obj);
  }
 else {
    if (type.isCharType())     return new Character(getCharValueUnchecked(obj));
    if (type.isDoubleType())     return new Double(getDoubleValueUnchecked(obj));
    if (type.isFloatType())     return new Float(getFloatValueUnchecked(obj));
    if (type.isLongType())     return new Long(getLongValueUnchecked(obj));
    if (type.isIntType())     return new Integer(getIntValueUnchecked(obj));
    if (type.isShortType())     return new Short(getShortValueUnchecked(obj));
    if (type.isByteType())     return new Byte(getByteValueUnchecked(obj));
    if (type.isBooleanType())     return Boolean.valueOf(getBooleanValueUnchecked(obj));
    return null;
  }
}",0.9941463414634146
150060,"/** 
 * Analyze the bytecodes and build the basic blocks with their predecessors. The results will be used by VM_BuildReferenceMaps
 */
public void determineTheBasicBlocks(VM_NormalMethod method){
  VM_ExceptionHandlerMap exceptions;
  int retList[];
  VM_BytecodeStream bcodes;
  VM_BasicBlock currentBB;
  byte lastInstrType;
  int lastInstrStart;
  int nextRetList=0;
  numJsrs=0;
  gcPointCount=1;
  bcodes=method.getBytecodes();
  bytelength=bcodes.length();
  maxStackHeight=method.getOperandWords();
  byteToBlockMap=new short[bytelength];
  java.util.Arrays.fill(byteToBlockMap,(short)VM_BasicBlock.NOTBLOCK);
  basicBlocks=new VM_BasicBlock[2];
  bbf=new VM_BasicBlockFactory();
  exceptions=method.getExceptionHandlerMap();
  retList=null;
  if (nextInstructionStart == null || nextInstructionStart.length < bytelength) {
    nextInstructionStart=new int[bytelength];
  }
  basicBlocks[VM_BasicBlock.EXITBLOCK]=new VM_BasicBlock(bytelength,bytelength,VM_BasicBlock.EXITBLOCK);
  currentBB=bbf.newBlock(0);
  addBasicBlock(currentBB);
  currentBB.setState(VM_BasicBlock.METHODENTRY);
  lastInstrType=NONBRANCH;
  lastInstrStart=0;
  if (exceptions != null) {
    setupHandlerBBs(exceptions);
    setupTryStartBBs(exceptions);
  }
  while (bcodes.hasMoreBytecodes()) {
    if (lastInstrType == NONBRANCH) {
      if (byteToBlockMap[bcodes.index()] == VM_BasicBlock.NOTBLOCK) {
        byteToBlockMap[bcodes.index()]=(short)currentBB.getBlockNumber();
      }
 else {
        currentBB.setEnd(lastInstrStart);
        basicBlocks[byteToBlockMap[bcodes.index()]].addPredecessor(currentBB);
        currentBB=basicBlocks[byteToBlockMap[bcodes.index()]];
      }
    }
 else {
      if (lastInstrType == CONDITIONAL_BRANCH) {
        currentBB.setEnd(lastInstrStart);
        if (byteToBlockMap[bcodes.index()] == VM_BasicBlock.NOTBLOCK) {
          VM_BasicBlock newBB=bbf.newBlock(bcodes.index());
          addBasicBlock(newBB);
          newBB.addPredecessor(currentBB);
          currentBB=newBB;
          byteToBlockMap[bcodes.index()]=(short)currentBB.getBlockNumber();
        }
 else {
          basicBlocks[byteToBlockMap[bcodes.index()]].addPredecessor(currentBB);
          currentBB=basicBlocks[byteToBlockMap[bcodes.index()]];
        }
      }
 else {
        if (lastInstrType == BRANCH) {
          currentBB.setEnd(lastInstrStart);
          if (byteToBlockMap[bcodes.index()] == VM_BasicBlock.NOTBLOCK) {
            VM_BasicBlock newBB=bbf.newBlock(bcodes.index());
            addBasicBlock(newBB);
            currentBB=newBB;
            byteToBlockMap[bcodes.index()]=(short)currentBB.getBlockNumber();
          }
 else {
            currentBB=basicBlocks[byteToBlockMap[bcodes.index()]];
          }
        }
      }
    }
    int savedStart=lastInstrStart;
    lastInstrStart=bcodes.index();
    nextInstructionStart[savedStart]=lastInstrStart;
    lastInstrType=NONBRANCH;
switch (bcodes.nextInstruction()) {
case JBC_ifeq:
case JBC_ifne:
case JBC_iflt:
case JBC_ifge:
case JBC_ifgt:
case JBC_ifle:
case JBC_if_icmpeq:
case JBC_if_icmpne:
case JBC_if_icmplt:
case JBC_if_icmpge:
case JBC_if_icmpgt:
case JBC_if_icmple:
case JBC_if_acmpeq:
case JBC_if_acmpne:
case JBC_ifnull:
case JBC_ifnonnull:
{
        lastInstrType=CONDITIONAL_BRANCH;
        int offset=bcodes.getBranchOffset();
        if (offset < 0)         gcPointCount++;
        int branchtarget=lastInstrStart + offset;
        processBranchTarget(lastInstrStart,branchtarget);
        break;
      }
case JBC_jsr:
{
      lastInstrType=BRANCH;
      int offset=bcodes.getBranchOffset();
      int branchtarget=lastInstrStart + offset;
      processBranchTarget(lastInstrStart,branchtarget);
      int jsrentryBBNum=byteToBlockMap[branchtarget];
      VM_BasicBlock bb=basicBlocks[jsrentryBBNum];
      if ((bb.getState() & VM_BasicBlock.JSRENTRY) == 0)       numJsrs++;
      bb.setState(VM_BasicBlock.JSRENTRY);
      gcPointCount=gcPointCount + 1;
      break;
    }
case JBC_jsr_w:
{
    lastInstrType=BRANCH;
    int offset=bcodes.getWideBranchOffset();
    int branchtarget=lastInstrStart + offset;
    processBranchTarget(lastInstrStart,branchtarget);
    int jsrentryBBNum=byteToBlockMap[branchtarget];
    VM_BasicBlock bb=basicBlocks[jsrentryBBNum];
    if ((bb.getState() & VM_BasicBlock.JSRENTRY) == 0)     numJsrs++;
    bb.setState(VM_BasicBlock.JSRENTRY);
    gcPointCount=gcPointCount + 1;
    break;
  }
case JBC_goto:
{
  lastInstrType=BRANCH;
  int offset=bcodes.getBranchOffset();
  if (offset < 0)   gcPointCount++;
  int branchtarget=lastInstrStart + offset;
  processBranchTarget(lastInstrStart,branchtarget);
  break;
}
case JBC_goto_w:
{
int offset=bcodes.getWideBranchOffset();
if (offset < 0) gcPointCount++;
int branchtarget=lastInstrStart + offset;
processBranchTarget(lastInstrStart,branchtarget);
break;
}
case JBC_tableswitch:
{
bcodes.alignSwitch();
int def=bcodes.getDefaultSwitchOffset();
processBranchTarget(lastInstrStart,lastInstrStart + def);
int low=bcodes.getLowSwitchValue();
int high=bcodes.getHighSwitchValue();
int n=high - low + 1;
for (int i=0; i < n; i++) {
int offset=bcodes.getTableSwitchOffset(i);
processBranchTarget(lastInstrStart,lastInstrStart + offset);
}
bcodes.skipTableSwitchOffsets(n);
break;
}
case JBC_lookupswitch:
{
bcodes.alignSwitch();
int def=bcodes.getDefaultSwitchOffset();
int npairs=bcodes.getSwitchLength();
processBranchTarget(lastInstrStart,lastInstrStart + def);
for (int i=0; i < npairs; i++) {
int offset=bcodes.getLookupSwitchOffset(i);
processBranchTarget(lastInstrStart,lastInstrStart + offset);
}
bcodes.skipLookupSwitchPairs(npairs);
break;
}
case JBC_ireturn:
case JBC_lreturn:
case JBC_freturn:
case JBC_dreturn:
case JBC_areturn:
case JBC_return:
{
lastInstrType=BRANCH;
basicBlocks[VM_BasicBlock.EXITBLOCK].addPredecessor(currentBB);
if (method.isSynchronized() || VM.UseEpilogueYieldPoints) gcPointCount++;
break;
}
case JBC_ret:
{
lastInstrType=BRANCH;
int index=bcodes.getLocalNumber();
int blocknum=currentBB.getBlockNumber();
basicBlocks[blocknum].setState(VM_BasicBlock.JSREXIT);
if (retList == null) retList=new int[10];
if (nextRetList >= retList.length) {
int[] biggerRetList=new int[nextRetList + 10];
for (int i=0; i < nextRetList; i++) biggerRetList[i]=retList[i];
retList=biggerRetList;
biggerRetList=null;
}
retList[nextRetList++]=blocknum;
break;
}
case JBC_wide:
{
int widecode=bcodes.getWideOpcode();
int index=bcodes.getWideLocalNumber();
if (widecode == JBC_ret) {
lastInstrType=BRANCH;
int blocknum=currentBB.getBlockNumber();
basicBlocks[blocknum].setState(VM_BasicBlock.JSREXIT);
if (retList == null) retList=new int[10];
if (nextRetList >= retList.length) {
int[] biggerRetList=new int[nextRetList + 10];
for (int i=0; i < nextRetList; i++) biggerRetList[i]=retList[i];
retList=biggerRetList;
biggerRetList=null;
}
retList[nextRetList++]=blocknum;
}
 else if (widecode == JBC_iinc) {
int val=bcodes.getWideIncrement();
}
 else {
}
}
case JBC_athrow:
{
lastInstrType=BRANCH;
processAthrow(exceptions,lastInstrStart);
gcPointCount++;
break;
}
case JBC_aaload:
case JBC_iaload:
case JBC_faload:
case JBC_baload:
case JBC_caload:
case JBC_saload:
case JBC_laload:
case JBC_daload:
case JBC_lastore:
case JBC_dastore:
case JBC_iastore:
case JBC_fastore:
case JBC_aastore:
case JBC_bastore:
case JBC_castore:
case JBC_sastore:
case JBC_putfield:
case JBC_getfield:
case JBC_getstatic:
case JBC_putstatic:
case JBC_irem:
case JBC_idiv:
case JBC_lrem:
case JBC_ldiv:
case JBC_invokevirtual:
case JBC_invokespecial:
case JBC_invokestatic:
case JBC_invokeinterface:
case JBC_instanceof:
case JBC_checkcast:
case JBC_monitorenter:
case JBC_monitorexit:
case JBC_new:
case JBC_newarray:
case JBC_anewarray:
case JBC_multianewarray:
{
bcodes.skipInstruction();
byteToBlockMap[lastInstrStart]=(short)currentBB.getBlockNumber();
gcPointCount=gcPointCount + 1;
break;
}
default :
{
bcodes.skipInstruction();
byteToBlockMap[lastInstrStart]=(short)currentBB.getBlockNumber();
break;
}
}
}
currentBB.setEnd(lastInstrStart);
if (exceptions != null) {
processExceptionHandlers(exceptions);
markTryBlocks(exceptions);
}
if (retList != null) {
processRetList(retList,nextRetList);
}
}","/** 
 * Analyze the bytecodes and build the basic blocks with their predecessors. The results will be used by VM_BuildReferenceMaps
 */
public void determineTheBasicBlocks(VM_NormalMethod method){
  VM_ExceptionHandlerMap exceptions;
  int retList[];
  VM_BytecodeStream bcodes;
  VM_BasicBlock currentBB;
  byte lastInstrType;
  int lastInstrStart;
  int nextRetList=0;
  numJsrs=0;
  gcPointCount=1;
  bcodes=method.getBytecodes();
  bytelength=bcodes.length();
  maxStackHeight=method.getOperandWords();
  byteToBlockMap=new short[bytelength];
  java.util.Arrays.fill(byteToBlockMap,(short)VM_BasicBlock.NOTBLOCK);
  basicBlocks=new VM_BasicBlock[2];
  bbf=new VM_BasicBlockFactory();
  exceptions=method.getExceptionHandlerMap();
  retList=null;
  if (nextInstructionStart == null || nextInstructionStart.length < bytelength) {
    nextInstructionStart=new int[bytelength];
  }
  basicBlocks[VM_BasicBlock.EXITBLOCK]=new VM_BasicBlock(bytelength,bytelength,VM_BasicBlock.EXITBLOCK);
  currentBB=bbf.newBlock(0);
  addBasicBlock(currentBB);
  currentBB.setState(VM_BasicBlock.METHODENTRY);
  lastInstrType=NONBRANCH;
  lastInstrStart=0;
  if (exceptions != null) {
    setupHandlerBBs(exceptions);
    setupTryStartBBs(exceptions);
  }
  while (bcodes.hasMoreBytecodes()) {
    if (lastInstrType == NONBRANCH) {
      if (byteToBlockMap[bcodes.index()] == VM_BasicBlock.NOTBLOCK) {
        byteToBlockMap[bcodes.index()]=(short)currentBB.getBlockNumber();
      }
 else {
        currentBB.setEnd(lastInstrStart);
        basicBlocks[byteToBlockMap[bcodes.index()]].addPredecessor(currentBB);
        currentBB=basicBlocks[byteToBlockMap[bcodes.index()]];
      }
    }
 else {
      if (lastInstrType == CONDITIONAL_BRANCH) {
        currentBB.setEnd(lastInstrStart);
        if (byteToBlockMap[bcodes.index()] == VM_BasicBlock.NOTBLOCK) {
          VM_BasicBlock newBB=bbf.newBlock(bcodes.index());
          addBasicBlock(newBB);
          newBB.addPredecessor(currentBB);
          currentBB=newBB;
          byteToBlockMap[bcodes.index()]=(short)currentBB.getBlockNumber();
        }
 else {
          basicBlocks[byteToBlockMap[bcodes.index()]].addPredecessor(currentBB);
          currentBB=basicBlocks[byteToBlockMap[bcodes.index()]];
        }
      }
 else {
        if (lastInstrType == BRANCH) {
          currentBB.setEnd(lastInstrStart);
          if (byteToBlockMap[bcodes.index()] == VM_BasicBlock.NOTBLOCK) {
            VM_BasicBlock newBB=bbf.newBlock(bcodes.index());
            addBasicBlock(newBB);
            currentBB=newBB;
            byteToBlockMap[bcodes.index()]=(short)currentBB.getBlockNumber();
          }
 else {
            currentBB=basicBlocks[byteToBlockMap[bcodes.index()]];
          }
        }
      }
    }
    int savedStart=lastInstrStart;
    lastInstrStart=bcodes.index();
    nextInstructionStart[savedStart]=lastInstrStart;
    lastInstrType=NONBRANCH;
switch (bcodes.nextInstruction()) {
case JBC_ifeq:
case JBC_ifne:
case JBC_iflt:
case JBC_ifge:
case JBC_ifgt:
case JBC_ifle:
case JBC_if_icmpeq:
case JBC_if_icmpne:
case JBC_if_icmplt:
case JBC_if_icmpge:
case JBC_if_icmpgt:
case JBC_if_icmple:
case JBC_if_acmpeq:
case JBC_if_acmpne:
case JBC_ifnull:
case JBC_ifnonnull:
{
        lastInstrType=CONDITIONAL_BRANCH;
        int offset=bcodes.getBranchOffset();
        if (offset < 0)         gcPointCount++;
        int branchtarget=lastInstrStart + offset;
        processBranchTarget(lastInstrStart,branchtarget);
        break;
      }
case JBC_jsr:
{
      lastInstrType=BRANCH;
      int offset=bcodes.getBranchOffset();
      int branchtarget=lastInstrStart + offset;
      processBranchTarget(lastInstrStart,branchtarget);
      int jsrentryBBNum=byteToBlockMap[branchtarget];
      VM_BasicBlock bb=basicBlocks[jsrentryBBNum];
      if ((bb.getState() & VM_BasicBlock.JSRENTRY) == 0)       numJsrs++;
      bb.setState(VM_BasicBlock.JSRENTRY);
      gcPointCount=gcPointCount + 1;
      break;
    }
case JBC_jsr_w:
{
    lastInstrType=BRANCH;
    int offset=bcodes.getWideBranchOffset();
    int branchtarget=lastInstrStart + offset;
    processBranchTarget(lastInstrStart,branchtarget);
    int jsrentryBBNum=byteToBlockMap[branchtarget];
    VM_BasicBlock bb=basicBlocks[jsrentryBBNum];
    if ((bb.getState() & VM_BasicBlock.JSRENTRY) == 0)     numJsrs++;
    bb.setState(VM_BasicBlock.JSRENTRY);
    gcPointCount=gcPointCount + 1;
    break;
  }
case JBC_goto:
{
  lastInstrType=BRANCH;
  int offset=bcodes.getBranchOffset();
  if (offset < 0)   gcPointCount++;
  int branchtarget=lastInstrStart + offset;
  processBranchTarget(lastInstrStart,branchtarget);
  break;
}
case JBC_goto_w:
{
int offset=bcodes.getWideBranchOffset();
if (offset < 0) gcPointCount++;
int branchtarget=lastInstrStart + offset;
processBranchTarget(lastInstrStart,branchtarget);
break;
}
case JBC_tableswitch:
{
bcodes.alignSwitch();
int def=bcodes.getDefaultSwitchOffset();
processBranchTarget(lastInstrStart,lastInstrStart + def);
int low=bcodes.getLowSwitchValue();
int high=bcodes.getHighSwitchValue();
int n=high - low + 1;
for (int i=0; i < n; i++) {
int offset=bcodes.getTableSwitchOffset(i);
processBranchTarget(lastInstrStart,lastInstrStart + offset);
}
bcodes.skipTableSwitchOffsets(n);
break;
}
case JBC_lookupswitch:
{
bcodes.alignSwitch();
int def=bcodes.getDefaultSwitchOffset();
int npairs=bcodes.getSwitchLength();
processBranchTarget(lastInstrStart,lastInstrStart + def);
for (int i=0; i < npairs; i++) {
int offset=bcodes.getLookupSwitchOffset(i);
processBranchTarget(lastInstrStart,lastInstrStart + offset);
}
bcodes.skipLookupSwitchPairs(npairs);
break;
}
case JBC_ireturn:
case JBC_lreturn:
case JBC_freturn:
case JBC_dreturn:
case JBC_areturn:
case JBC_return:
{
lastInstrType=BRANCH;
basicBlocks[VM_BasicBlock.EXITBLOCK].addPredecessor(currentBB);
if (method.isSynchronized() || VM.UseEpilogueYieldPoints) gcPointCount++;
break;
}
case JBC_ret:
{
lastInstrType=BRANCH;
int index=bcodes.getLocalNumber();
int blocknum=currentBB.getBlockNumber();
basicBlocks[blocknum].setState(VM_BasicBlock.JSREXIT);
if (retList == null) retList=new int[10];
if (nextRetList >= retList.length) {
int[] biggerRetList=new int[nextRetList + 10];
for (int i=0; i < nextRetList; i++) biggerRetList[i]=retList[i];
retList=biggerRetList;
biggerRetList=null;
}
retList[nextRetList++]=blocknum;
break;
}
case JBC_wide:
{
int widecode=bcodes.getWideOpcode();
int index=bcodes.getWideLocalNumber();
if (widecode == JBC_ret) {
lastInstrType=BRANCH;
int blocknum=currentBB.getBlockNumber();
basicBlocks[blocknum].setState(VM_BasicBlock.JSREXIT);
if (retList == null) retList=new int[10];
if (nextRetList >= retList.length) {
int[] biggerRetList=new int[nextRetList + 10];
for (int i=0; i < nextRetList; i++) biggerRetList[i]=retList[i];
retList=biggerRetList;
biggerRetList=null;
}
retList[nextRetList++]=blocknum;
}
 else if (widecode == JBC_iinc) {
int val=bcodes.getWideIncrement();
}
 else {
}
break;
}
case JBC_athrow:
{
lastInstrType=BRANCH;
processAthrow(exceptions,lastInstrStart);
gcPointCount++;
break;
}
case JBC_aaload:
case JBC_iaload:
case JBC_faload:
case JBC_baload:
case JBC_caload:
case JBC_saload:
case JBC_laload:
case JBC_daload:
case JBC_lastore:
case JBC_dastore:
case JBC_iastore:
case JBC_fastore:
case JBC_aastore:
case JBC_bastore:
case JBC_castore:
case JBC_sastore:
case JBC_putfield:
case JBC_getfield:
case JBC_getstatic:
case JBC_putstatic:
case JBC_irem:
case JBC_idiv:
case JBC_lrem:
case JBC_ldiv:
case JBC_invokevirtual:
case JBC_invokespecial:
case JBC_invokestatic:
case JBC_invokeinterface:
case JBC_instanceof:
case JBC_checkcast:
case JBC_monitorenter:
case JBC_monitorexit:
case JBC_new:
case JBC_newarray:
case JBC_anewarray:
case JBC_multianewarray:
{
bcodes.skipInstruction();
byteToBlockMap[lastInstrStart]=(short)currentBB.getBlockNumber();
gcPointCount=gcPointCount + 1;
break;
}
default :
{
bcodes.skipInstruction();
byteToBlockMap[lastInstrStart]=(short)currentBB.getBlockNumber();
break;
}
}
}
currentBB.setEnd(lastInstrStart);
if (exceptions != null) {
processExceptionHandlers(exceptions);
markTryBlocks(exceptions);
}
if (retList != null) {
processRetList(retList,nextRetList);
}
}",0.9995716296432288
150061,"/** 
 * Stage 1: Complete the expression trees and identify tree roots. Complete BURS trees by adding leaf nodes as needed, and creating tree edges by calling insertChild1() or insertChild2() This step is also where we introduce intermediate tree nodes for  any LIR instruction that has > 2 ""real"" operands e.g., a CALL. We also mark nodes that must be tree roots.
 * @param dg  The dependence graph. 
 */
private void buildTrees(OPT_DepGraph dg){
  OPT_DepGraphNode bbNodes=(OPT_DepGraphNode)dg.firstNode();
  OPT_Instruction firstInstruction=bbNodes.instruction();
  for (OPT_DepGraphNode n=bbNodes; n != null; n=(OPT_DepGraphNode)n.getNext()) {
    OPT_BURS_TreeNode cur_parent=new OPT_BURS_TreeNode(n);
    n.scratchObject=cur_parent;
    OPT_Instruction instr=n.instruction();
    for (OPT_OperandEnumeration uses=instr.getUses(); uses.hasMoreElements(); ) {
      OPT_Operand op=uses.next();
      if (op == null)       continue;
      OPT_BURS_TreeNode child;
      if (op instanceof OPT_RegisterOperand) {
        OPT_RegisterOperand regOp=(OPT_RegisterOperand)op;
        if (regOp.register.isValidation())         continue;
        OPT_DepGraphEdge e=OPT_DepGraphEdge.findInputEdge(n,op);
        if (e == null) {
          child=Register;
        }
 else {
          child=(OPT_BURS_TreeNode)e.fromNode().scratchObject;
        }
      }
 else       if (op instanceof OPT_IntConstantOperand) {
        child=new OPT_BURS_IntConstantTreeNode(((OPT_IntConstantOperand)op).value);
      }
 else       if (op instanceof OPT_LongConstantOperand) {
        child=LongConstant;
      }
 else       if (op instanceof OPT_AddressConstantOperand) {
        child=AddressConstant;
      }
 else       if (op instanceof OPT_BranchOperand && instr.isCall()) {
        child=BranchTarget;
      }
 else       if (op instanceof OPT_InlinedOsrTypeInfoOperand && instr.isYieldPoint()) {
        child=NullTreeNode;
      }
 else {
        continue;
      }
      if (cur_parent.child1 == null) {
        cur_parent.child1=child;
      }
 else       if (cur_parent.child2 == null) {
        cur_parent.child2=child;
      }
 else {
        OPT_BURS_TreeNode child1=cur_parent.child2;
        OPT_BURS_TreeNode aux=new OPT_BURS_TreeNode(OTHER_OPERAND_opcode);
        cur_parent.child2=aux;
        cur_parent=aux;
        cur_parent.child1=child1;
        cur_parent.child2=child;
      }
    }
switch (instr.getOpcode()) {
case CALL_opcode:
case SYSCALL_opcode:
case YIELDPOINT_OSR_opcode:
      if (cur_parent.child2 == null)       cur_parent.child2=NullTreeNode;
case RETURN_opcode:
    if (cur_parent.child1 == null)     cur_parent.child1=NullTreeNode;
}
if (mustBeTreeRoot(n)) {
  makeTreeRoot((OPT_BURS_TreeNode)n.scratchObject);
}
}
}","/** 
 * Stage 1: Complete the expression trees and identify tree roots. Complete BURS trees by adding leaf nodes as needed, and creating tree edges by calling insertChild1() or insertChild2() This step is also where we introduce intermediate tree nodes for  any LIR instruction that has > 2 ""real"" operands e.g., a CALL. We also mark nodes that must be tree roots.
 * @param dg  The dependence graph. 
 */
private void buildTrees(OPT_DepGraph dg){
  OPT_DepGraphNode bbNodes=(OPT_DepGraphNode)dg.firstNode();
  for (OPT_DepGraphNode n=bbNodes; n != null; n=(OPT_DepGraphNode)n.getNext()) {
    OPT_BURS_TreeNode cur_parent=new OPT_BURS_TreeNode(n);
    n.scratchObject=cur_parent;
    OPT_Instruction instr=n.instruction();
    for (OPT_OperandEnumeration uses=instr.getUses(); uses.hasMoreElements(); ) {
      OPT_Operand op=uses.next();
      if (op == null)       continue;
      OPT_BURS_TreeNode child;
      if (op instanceof OPT_RegisterOperand) {
        OPT_RegisterOperand regOp=(OPT_RegisterOperand)op;
        if (regOp.register.isValidation())         continue;
        OPT_DepGraphEdge e=OPT_DepGraphEdge.findInputEdge(n,op);
        if (e == null) {
          child=Register;
        }
 else {
          child=(OPT_BURS_TreeNode)e.fromNode().scratchObject;
        }
      }
 else       if (op instanceof OPT_IntConstantOperand) {
        child=new OPT_BURS_IntConstantTreeNode(((OPT_IntConstantOperand)op).value);
      }
 else       if (op instanceof OPT_LongConstantOperand) {
        child=LongConstant;
      }
 else       if (op instanceof OPT_AddressConstantOperand) {
        child=AddressConstant;
      }
 else       if (op instanceof OPT_BranchOperand && instr.isCall()) {
        child=BranchTarget;
      }
 else       if (op instanceof OPT_InlinedOsrTypeInfoOperand && instr.isYieldPoint()) {
        child=NullTreeNode;
      }
 else {
        continue;
      }
      if (cur_parent.child1 == null) {
        cur_parent.child1=child;
      }
 else       if (cur_parent.child2 == null) {
        cur_parent.child2=child;
      }
 else {
        OPT_BURS_TreeNode child1=cur_parent.child2;
        OPT_BURS_TreeNode aux=new OPT_BURS_TreeNode(OTHER_OPERAND_opcode);
        cur_parent.child2=aux;
        cur_parent=aux;
        cur_parent.child1=child1;
        cur_parent.child2=child;
      }
    }
switch (instr.getOpcode()) {
case CALL_opcode:
case SYSCALL_opcode:
case YIELDPOINT_OSR_opcode:
      if (cur_parent.child2 == null)       cur_parent.child2=NullTreeNode;
case RETURN_opcode:
    if (cur_parent.child1 == null)     cur_parent.child1=NullTreeNode;
}
if (mustBeTreeRoot(n)) {
  makeTreeRoot((OPT_BURS_TreeNode)n.scratchObject);
}
}
}",0.9892791127541588
150062,"/** 
 * Take a string (most likely a command-line argument) and try to proccess it as an option command.  Return true if the string was understood, false  otherwise.
 * @param arg a String to try to process as an option command
 * @return true if successful, false otherwise
 */
public static boolean process(String arg){
  if (arg.equals(""String_Node_Str"")) {
    printHelp();
    return true;
  }
  if (arg.equals(""String_Node_Str"")) {
    printOptions();
    return true;
  }
  if (arg.equals(""String_Node_Str"")) {
    printHelp();
    return true;
  }
  int split=arg.indexOf('=');
  if (split == -1) {
    VM.sysWriteln(""String_Node_Str"" + arg + ""String_Node_Str"");
    return false;
  }
  String name=arg.substring(0,split);
  String value=arg.substring(split + 1);
  Option o=Option.getOption(name);
  if (o == null)   return false;
switch (o.getType()) {
case Option.BOOLEAN_OPTION:
    if (value.equals(""String_Node_Str"")) {
      ((BooleanOption)o).setValue(true);
      return true;
    }
 else     if (value.equals(""String_Node_Str"")) {
      ((BooleanOption)o).setValue(false);
      return true;
    }
  return false;
case Option.INT_OPTION:
int ival=VM_CommandLineArgs.primitiveParseInt(value);
((IntOption)o).setValue(ival);
return true;
case Option.FLOAT_OPTION:
float fval=VM_CommandLineArgs.primitiveParseFloat(value);
((FloatOption)o).setValue(fval);
return true;
case Option.STRING_OPTION:
((StringOption)o).setValue(value);
return true;
case Option.ENUM_OPTION:
((EnumOption)o).setValue(value);
return true;
case Option.PAGES_OPTION:
long pval=VM_CommandLineArgs.parseMemorySize(o.getName(),""String_Node_Str"" + o.getKey() + ""String_Node_Str"",""String_Node_Str"",1,""String_Node_Str"" + o.getKey() + ""String_Node_Str""+ value,value);
if (pval < 0) return false;
((PagesOption)o).setBytes(Extent.fromIntSignExtend((int)pval));
return true;
case Option.MICROSECONDS_OPTION:
int mval=VM_CommandLineArgs.primitiveParseInt(value);
mval=mval;
((MicrosecondsOption)o).setMicroseconds(mval);
return true;
}
return false;
}","/** 
 * Take a string (most likely a command-line argument) and try to proccess it as an option command.  Return true if the string was understood, false  otherwise.
 * @param arg a String to try to process as an option command
 * @return true if successful, false otherwise
 */
public static boolean process(String arg){
  if (arg.equals(""String_Node_Str"")) {
    printHelp();
    return true;
  }
  if (arg.equals(""String_Node_Str"")) {
    printOptions();
    return true;
  }
  if (arg.equals(""String_Node_Str"")) {
    printHelp();
    return true;
  }
  int split=arg.indexOf('=');
  if (split == -1) {
    VM.sysWriteln(""String_Node_Str"" + arg + ""String_Node_Str"");
    return false;
  }
  String name=arg.substring(0,split);
  String value=arg.substring(split + 1);
  Option o=Option.getOption(name);
  if (o == null)   return false;
switch (o.getType()) {
case Option.BOOLEAN_OPTION:
    if (value.equals(""String_Node_Str"")) {
      ((BooleanOption)o).setValue(true);
      return true;
    }
 else     if (value.equals(""String_Node_Str"")) {
      ((BooleanOption)o).setValue(false);
      return true;
    }
  return false;
case Option.INT_OPTION:
int ival=VM_CommandLineArgs.primitiveParseInt(value);
((IntOption)o).setValue(ival);
return true;
case Option.FLOAT_OPTION:
float fval=VM_CommandLineArgs.primitiveParseFloat(value);
((FloatOption)o).setValue(fval);
return true;
case Option.STRING_OPTION:
((StringOption)o).setValue(value);
return true;
case Option.ENUM_OPTION:
((EnumOption)o).setValue(value);
return true;
case Option.PAGES_OPTION:
long pval=VM_CommandLineArgs.parseMemorySize(o.getName(),""String_Node_Str"" + o.getKey() + ""String_Node_Str"",""String_Node_Str"",1,""String_Node_Str"" + o.getKey() + ""String_Node_Str""+ value,value);
if (pval < 0) return false;
((PagesOption)o).setBytes(Extent.fromIntSignExtend((int)pval));
return true;
case Option.MICROSECONDS_OPTION:
int mval=VM_CommandLineArgs.primitiveParseInt(value);
((MicrosecondsOption)o).setMicroseconds(mval);
return true;
}
return false;
}",0.9972832798221783
150063,"/** 
 * Set up to scan the current stack frame.  This means examining the frame to discover the method being invoked and then retrieving the associated metadata (stack maps etc).  Certain frames should not be scanned---these are identified and skipped.
 * @param verbosity The level of verbosity to be used whenperforming the scan.
 * @return True if the frame should be scanned, false if it shouldbe skipped.
 */
private boolean setUpFrame(int verbosity){
  int compiledMethodId=VM_Magic.getCompiledMethodID(fp);
  if (compiledMethodId == VM_Constants.INVISIBLE_METHOD_ID) {
    if (verbosity >= 1)     Log.writeln(""String_Node_Str"");
    return false;
  }
  compiledMethod=VM_CompiledMethods.getCompiledMethod(compiledMethodId);
  compiledMethod.setObsolete(false);
  VM_Method method=compiledMethod.getMethod();
  compiledMethodType=compiledMethod.getCompilerType();
  if (verbosity >= 1)   printMethodHeader();
  if (compiledMethodType == VM_CompiledMethod.TRAP)   return false;
  Offset offset=compiledMethod.getInstructionOffset(ip);
  iterator=iteratorGroup.selectIterator(compiledMethod);
  iterator.setupIterator(compiledMethod,offset,fp);
  if (verbosity >= 2)   dumpStackFrame(verbosity);
  if (verbosity >= 3)   Log.writeln(""String_Node_Str"");
  return true;
}","/** 
 * Set up to scan the current stack frame.  This means examining the frame to discover the method being invoked and then retrieving the associated metadata (stack maps etc).  Certain frames should not be scanned---these are identified and skipped.
 * @param verbosity The level of verbosity to be used whenperforming the scan.
 * @return True if the frame should be scanned, false if it shouldbe skipped.
 */
private boolean setUpFrame(int verbosity){
  int compiledMethodId=VM_Magic.getCompiledMethodID(fp);
  if (compiledMethodId == VM_Constants.INVISIBLE_METHOD_ID) {
    if (verbosity >= 1)     Log.writeln(""String_Node_Str"");
    return false;
  }
  compiledMethod=VM_CompiledMethods.getCompiledMethod(compiledMethodId);
  compiledMethod.setObsolete(false);
  compiledMethodType=compiledMethod.getCompilerType();
  if (verbosity >= 1)   printMethodHeader();
  if (compiledMethodType == VM_CompiledMethod.TRAP)   return false;
  Offset offset=compiledMethod.getInstructionOffset(ip);
  iterator=iteratorGroup.selectIterator(compiledMethod);
  iterator.setupIterator(compiledMethod,offset,fp);
  if (verbosity >= 2)   dumpStackFrame(verbosity);
  if (verbosity >= 3)   Log.writeln(""String_Node_Str"");
  return true;
}",0.9811774128954746
150064,"/** 
 * writes a <code>long</code> in hexadecimal
 * @param w the Word to be logged
 * @param bytes the number of bytes from the long to be logged.  Ifless than 8 then the least significant bytes are logged and some of the most significant bytes are ignored.
 */
private static void writeHex(Word w,int bytes){
  int hexDigits=bytes * (1 << LOG_HEX_DIGITS_IN_BYTE);
  int nextDigit;
  char[] intBuffer=getIntBuffer();
  write(HEX_PREFIX);
  for (int digitNumber=hexDigits - 1; digitNumber >= 0; digitNumber--) {
    nextDigit=w.rshl(digitNumber << LOG_BITS_IN_HEX_DIGIT).toInt() & 0xf;
    char nextChar=Barriers.getArrayNoBarrier(hexDigitCharacter,nextDigit);
    add(nextChar);
  }
}","/** 
 * writes a <code>long</code> in hexadecimal
 * @param w the Word to be logged
 * @param bytes the number of bytes from the long to be logged.  Ifless than 8 then the least significant bytes are logged and some of the most significant bytes are ignored.
 */
private static void writeHex(Word w,int bytes){
  int hexDigits=bytes * (1 << LOG_HEX_DIGITS_IN_BYTE);
  int nextDigit;
  write(HEX_PREFIX);
  for (int digitNumber=hexDigits - 1; digitNumber >= 0; digitNumber--) {
    nextDigit=w.rshl(digitNumber << LOG_BITS_IN_HEX_DIGIT).toInt() & 0xf;
    char nextChar=Barriers.getArrayNoBarrier(hexDigitCharacter,nextDigit);
    add(nextChar);
  }
}",0.9737827715355806
150065,"/** 
 * Perform a sanity traversal of a linked list of blocks, checking that the double links are sane, and returning the length of the list.
 * @param block The first block in the list to be checked
 * @param prev The previous block in the list (possibly null)
 * @param verbose If true then produce large amounts of debuggingoutput detailing the composition of the list.
 * @return The length of the list
 */
final static int sanityTraverse(Address block,Address prev,boolean verbose){
  if (verbose)   Log.write(""String_Node_Str"");
  boolean first=true;
  int blocks=0;
  while (!block.isZero()) {
    if (Assert.VERIFY_ASSERTIONS)     Assert._assert(getPrevBlock(block).EQ(prev));
    blocks++;
    if (verbose) {
      if (!first)       Log.write(""String_Node_Str"");
 else       first=false;
      Log.write(block);
    }
    prev=block;
    block=getNextBlock(block);
    Log.flush();
  }
  if (verbose)   Log.write(""String_Node_Str"");
  return blocks;
}","/** 
 * Perform a sanity traversal of a linked list of blocks, checking that the double links are sane, and returning the length of the list.
 * @param block The first block in the list to be checked
 * @param prev The previous block in the list (possibly null)
 * @param verbose If true then produce large amounts of debuggingoutput detailing the composition of the list.
 * @return The length of the list
 */
final static int sanityTraverse(Address block,Address prev,boolean verbose){
  if (verbose)   Log.write(""String_Node_Str"");
  boolean first=true;
  int blocks=0;
  while (!block.isZero()) {
    if (Assert.VERIFY_ASSERTIONS)     Assert._assert(getPrevBlock(block).EQ(prev));
    blocks++;
    if (verbose) {
      if (!first)       Log.write(""String_Node_Str"");
 else       first=false;
      Log.write(block);
    }
    block=getNextBlock(block);
    Log.flush();
  }
  if (verbose)   Log.write(""String_Node_Str"");
  return blocks;
}",0.9915966386554622
150066,"/** 
 * Perform a linear scan through a single contigious region
 * @param scanner The scan object to delegate to.
 * @param start The start of this region
 */
private void scanRegion(LinearScan scanner,Address start) throws InlinePragma {
  Address end=start.add(REGION_LIMIT_OFFSET).loadAddress();
  Address dataEnd=start.add(DATA_END_OFFSET).loadAddress();
  Address currentLimit=(dataEnd.isZero() ? cursor : dataEnd);
  ObjectReference current=ObjectModel.getObjectFromStartAddress(start.add(DATA_START_OFFSET));
  while (ObjectModel.refToAddress(current).LT(currentLimit)) {
    ObjectReference next=ObjectModel.getNextObject(current);
    scanner.scan(current);
    current=next;
  }
}","/** 
 * Perform a linear scan through a single contigious region
 * @param scanner The scan object to delegate to.
 * @param start The start of this region
 */
private void scanRegion(LinearScan scanner,Address start) throws InlinePragma {
  Address dataEnd=start.add(DATA_END_OFFSET).loadAddress();
  Address currentLimit=(dataEnd.isZero() ? cursor : dataEnd);
  ObjectReference current=ObjectModel.getObjectFromStartAddress(start.add(DATA_START_OFFSET));
  while (ObjectModel.refToAddress(current).LT(currentLimit)) {
    ObjectReference next=ObjectModel.getNextObject(current);
    scanner.scan(current);
    current=next;
  }
}",0.9546142208774584
150067,"/** 
 * Given an instruction, attempt to simplify it. The instruction will be mutated in place. <p> We don't deal with branching operations here --  doing peephole optimizations of branches is the job of a separate module.
 * @param regpool register pool in case simplification requires a temporary register
 * @param s the instruction to simplify
 * @return one of UNCHANGED, MOVE_FOLDED, MOVE_REDUCED, TRAP_REDUCED, REDUCED
 */
public static byte simplify(OPT_AbstractRegisterPool regpool,OPT_Instruction s){
switch (s.getOpcode()) {
case GUARD_COMBINE_opcode:
{
      OPT_Operand op2=Binary.getVal2(s);
      if (op2 instanceof OPT_TrueGuardOperand) {
        OPT_Operand op1=Binary.getVal1(s);
        if (op1 instanceof OPT_TrueGuardOperand) {
          Move.mutate(s,GUARD_MOVE,Binary.getClearResult(s),op1);
          return MOVE_FOLDED;
        }
 else {
          Move.mutate(s,GUARD_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
          return MOVE_REDUCED;
        }
      }
    }
  return UNCHANGED;
case TRAP_IF_opcode:
{
  OPT_Operand op1=TrapIf.getVal1(s);
  OPT_Operand op2=TrapIf.getVal2(s);
  if (op1.isConstant()) {
    if (op2.isConstant()) {
      int willTrap=TrapIf.getCond(s).evaluate(op1,op2);
      if (willTrap == OPT_ConditionOperand.TRUE) {
        Trap.mutate(s,TRAP,TrapIf.getClearGuardResult(s),TrapIf.getClearTCode(s));
        return TRAP_REDUCED;
      }
 else       if (willTrap == OPT_ConditionOperand.FALSE) {
        Move.mutate(s,GUARD_MOVE,TrapIf.getClearGuardResult(s),TG());
        return MOVE_FOLDED;
      }
    }
 else {
      TrapIf.mutate(s,TRAP_IF,TrapIf.getClearGuardResult(s),TrapIf.getClearVal2(s),TrapIf.getClearVal1(s),TrapIf.getClearCond(s).flipOperands(),TrapIf.getClearTCode(s));
    }
  }
}
return UNCHANGED;
case NULL_CHECK_opcode:
{
OPT_Operand ref=NullCheck.getRef(s);
if (ref.isNullConstant()) {
Trap.mutate(s,TRAP,NullCheck.getClearGuardResult(s),OPT_TrapCodeOperand.NullPtr());
return TRAP_REDUCED;
}
 else if (ref.isStringConstant()) {
Move.mutate(s,GUARD_MOVE,NullCheck.getClearGuardResult(s),TG());
return MOVE_FOLDED;
}
 else if (ref.isAddressConstant()) {
if (ref.asAddressConstant().value.isZero()) {
  Trap.mutate(s,TRAP,NullCheck.getClearGuardResult(s),OPT_TrapCodeOperand.NullPtr());
  return TRAP_REDUCED;
}
 else {
  Move.mutate(s,GUARD_MOVE,NullCheck.getClearGuardResult(s),TG());
  return MOVE_FOLDED;
}
}
return UNCHANGED;
}
case INT_ZERO_CHECK_opcode:
{
OPT_Operand op=ZeroCheck.getValue(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
if (val == 0) {
Trap.mutate(s,TRAP,ZeroCheck.getClearGuardResult(s),OPT_TrapCodeOperand.DivByZero());
return TRAP_REDUCED;
}
 else {
Move.mutate(s,GUARD_MOVE,ZeroCheck.getClearGuardResult(s),TG());
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case LONG_ZERO_CHECK_opcode:
{
OPT_Operand op=ZeroCheck.getValue(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
if (val == 0L) {
Trap.mutate(s,TRAP,ZeroCheck.getClearGuardResult(s),OPT_TrapCodeOperand.DivByZero());
return TRAP_REDUCED;
}
 else {
Move.mutate(s,GUARD_MOVE,ZeroCheck.getClearGuardResult(s),TG());
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case CHECKCAST_opcode:
{
OPT_Operand ref=TypeCheck.getRef(s);
if (ref.isNullConstant()) {
Empty.mutate(s,NOP);
return REDUCED;
}
 else if (ref.isStringConstant()) {
s.operator=CHECKCAST_NOTNULL;
return simplify(regpool,s);
}
 else {
VM_TypeReference lhsType=TypeCheck.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.YES) {
Empty.mutate(s,NOP);
return REDUCED;
}
}
}
return UNCHANGED;
case CHECKCAST_NOTNULL_opcode:
{
OPT_Operand ref=TypeCheck.getRef(s);
VM_TypeReference lhsType=TypeCheck.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.YES) {
Empty.mutate(s,NOP);
return REDUCED;
}
 else if (ans == OPT_Constants.NO) {
VM_Type rType=rhsType.peekResolvedType();
if (rType != null && rType.isClassType() && rType.asClass().isFinal()) {
Trap.mutate(s,TRAP,null,OPT_TrapCodeOperand.CheckCast());
return TRAP_REDUCED;
}
}
}
return UNCHANGED;
case INSTANCEOF_opcode:
{
OPT_Operand ref=InstanceOf.getRef(s);
if (ref.isNullConstant()) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
 else if (ref.isStringConstant()) {
s.operator=INSTANCEOF_NOTNULL;
return simplify(regpool,s);
}
VM_TypeReference lhsType=InstanceOf.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.NO) {
VM_Type rType=rhsType.peekResolvedType();
if (rType != null && rType.isClassType() && rType.asClass().isFinal()) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case INSTANCEOF_NOTNULL_opcode:
{
OPT_Operand ref=InstanceOf.getRef(s);
VM_TypeReference lhsType=InstanceOf.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.YES) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(1));
return MOVE_FOLDED;
}
 else if (ans == OPT_Constants.NO) {
VM_Type rType=rhsType.peekResolvedType();
if (rType != null && rType.isClassType() && rType.asClass().isFinal()) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case INT_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,INT_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,INT_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (tv.isIntConstant() && fv.isIntConstant() && !CondMove.getCond(s).isFLOATINGPOINT()) {
int itv=tv.asIntConstant().value;
int ifv=fv.asIntConstant().value;
OPT_Operator op=null;
if (val1.isLong()) {
op=BOOLEAN_CMP_LONG;
}
 else if (val1.isFloat()) {
op=BOOLEAN_CMP_FLOAT;
}
 else if (val1.isDouble()) {
op=BOOLEAN_CMP_DOUBLE;
}
 else {
op=BOOLEAN_CMP_INT;
}
if (itv == 1 && ifv == 0) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s),new OPT_BranchProfileOperand());
return REDUCED;
}
if (itv == 0 && ifv == 1) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s).flipCode(),new OPT_BranchProfileOperand());
return REDUCED;
}
}
}
return UNCHANGED;
case LONG_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,LONG_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,LONG_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (tv.isLongConstant() && fv.isLongConstant() && !CondMove.getCond(s).isFLOATINGPOINT()) {
long itv=tv.asLongConstant().value;
long ifv=fv.asLongConstant().value;
OPT_Operator op=null;
if (val1.isLong()) {
op=BOOLEAN_CMP_LONG;
}
 else if (val1.isFloat()) {
op=BOOLEAN_CMP_FLOAT;
}
 else if (val1.isDouble()) {
op=BOOLEAN_CMP_DOUBLE;
}
 else {
op=BOOLEAN_CMP_INT;
}
if (itv == 1 && ifv == 0) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s),new OPT_BranchProfileOperand());
return REDUCED;
}
if (itv == 0 && ifv == 1) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s).flipCode(),new OPT_BranchProfileOperand());
return REDUCED;
}
}
}
return UNCHANGED;
case FLOAT_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,FLOAT_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,FLOAT_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case DOUBLE_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,DOUBLE_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,DOUBLE_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case REF_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
if (val1.isConstant()) {
OPT_Operand val2=CondMove.getVal2(s);
if (val2.isConstant()) {
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,REF_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
 else {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
}
if (CondMove.getTrueValue(s).similar(CondMove.getFalseValue(s))) {
OPT_Operand val=CondMove.getClearTrueValue(s);
Move.mutate(s,REF_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case GUARD_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
if (val1.isConstant()) {
OPT_Operand val2=CondMove.getVal2(s);
if (val2.isConstant()) {
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond == OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,GUARD_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
 else {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
}
if (CondMove.getTrueValue(s).similar(CondMove.getFalseValue(s))) {
OPT_Operand val=CondMove.getClearTrueValue(s);
Move.mutate(s,GUARD_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case BOOLEAN_NOT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
if (val == 0) {
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(1));
}
 else {
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(0));
}
return MOVE_FOLDED;
}
}
return UNCHANGED;
case BOOLEAN_CMP_INT_opcode:
if (CF_INT) {
OPT_Operand op1=BooleanCmp.getVal1(s);
OPT_Operand op2=BooleanCmp.getVal2(s);
if (op1.isConstant()) {
if (op2.isConstant()) {
int cond=BooleanCmp.getCond(s).evaluate(op1,op2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
Move.mutate(s,INT_MOVE,BooleanCmp.getResult(s),(cond == OPT_ConditionOperand.TRUE) ? IC(1) : IC(0));
return MOVE_FOLDED;
}
}
 else {
OPT_Operand tmp=BooleanCmp.getClearVal1(s);
BooleanCmp.setVal1(s,BooleanCmp.getClearVal2(s));
BooleanCmp.setVal2(s,tmp);
BooleanCmp.getCond(s).flipOperands();
}
}
}
return UNCHANGED;
case BOOLEAN_CMP_ADDR_opcode:
if (CF_ADDR) {
OPT_Operand op1=BooleanCmp.getVal1(s);
OPT_Operand op2=BooleanCmp.getVal2(s);
if (op1.isConstant()) {
if (op2.isConstant()) {
int cond=BooleanCmp.getCond(s).evaluate(op1,op2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
Move.mutate(s,REF_MOVE,BooleanCmp.getResult(s),(cond == OPT_ConditionOperand.TRUE) ? IC(1) : IC(0));
return MOVE_FOLDED;
}
}
 else {
OPT_Operand tmp=BooleanCmp.getClearVal1(s);
BooleanCmp.setVal1(s,BooleanCmp.getClearVal2(s));
BooleanCmp.setVal2(s,tmp);
BooleanCmp.getCond(s).flipOperands();
}
}
}
return UNCHANGED;
case INT_ADD_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 + val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_AND_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 & val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (val2 == -1) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_DIV_opcode:
if (CF_INT) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(1));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (val2 == 0) {
return UNCHANGED;
}
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(val1 / val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 1) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s));
return MOVE_REDUCED;
}
int power=PowerOf2(val2);
if (power != -1) {
Binary.mutate(s,INT_SHR,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s),IC(power));
return REDUCED;
}
}
}
}
return UNCHANGED;
case INT_MUL_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 * val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1) {
Unary.mutate(s,INT_NEG,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (val2 == 1) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (s.getPrev() != null) {
int cost=0;
for (int i=1; i < 32; i++) {
if ((val2 & (1 << i)) != 0) {
cost++;
}
}
if (cost < 5) {
OPT_RegisterOperand val1Operand=Binary.getClearVal1(s).asRegister();
OPT_RegisterOperand resultOperand=regpool.makeTempInt();
OPT_Instruction move;
if ((val2 & 1) == 1) {
move=Move.create(INT_MOVE,resultOperand,val1Operand);
}
 else {
move=Move.create(INT_MOVE,resultOperand,IC(0));
}
move.copyPosition(s);
s.insertBefore(move);
for (int i=1; i < 32; i++) {
if ((val2 & (1 << i)) != 0) {
OPT_RegisterOperand tempInt=regpool.makeTempInt();
OPT_Instruction shift=Binary.create(INT_SHL,tempInt,val1Operand.copyRO(),IC(i));
shift.copyPosition(s);
s.insertBefore(shift);
OPT_Instruction add=Binary.create(INT_ADD,resultOperand.copyRO(),resultOperand.copyRO(),tempInt.copyRO());
add.copyPosition(s);
s.insertBefore(add);
}
}
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),resultOperand.copyRO());
return REDUCED;
}
}
}
}
}
return UNCHANGED;
case INT_NEG_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_NOT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(~val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_OR_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 | val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(-1));
return MOVE_FOLDED;
}
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_REM_opcode:
if (CF_INT) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (val2 == 0) {
return UNCHANGED;
}
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(val1 % val2));
return MOVE_FOLDED;
}
 else {
if ((val2 == 1) || (val2 == -1)) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
int power=PowerOf2(val2);
if (power != -1) {
Binary.mutate(s,INT_AND,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s),IC(val2 - 1));
return REDUCED;
}
}
}
}
return UNCHANGED;
case INT_SHL_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 << val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= 32) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case INT_SHR_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 >> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_SUB_opcode:
if (CF_INT) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 - val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
Binary.mutate(s,INT_ADD,Binary.getClearResult(s),Binary.getClearVal1(s),IC(-val2));
return REDUCED;
}
}
}
return UNCHANGED;
case INT_USHR_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 >>> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= 32) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case INT_XOR_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 ^ val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1) {
Unary.mutate(s,INT_NOT,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_ADD_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isConstant()) {
Address val2=getAddressValue(op2);
OPT_Operand op1=Binary.getVal1(s);
if (op1.isConstant()) {
Address val1=getAddressValue(op1);
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.add(val2.toWord().toOffset())));
return MOVE_FOLDED;
}
 else {
if (val2.isZero()) {
if (op1.isIntLike()) {
Unary.mutate(s,INT_2ADDRSigExt,Binary.getClearResult(s),Binary.getClearVal1(s));
}
 else {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
}
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_AND_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isAddressConstant()) {
Word val2=op2.asAddressConstant().value.toWord();
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.and(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2.isZero()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(Address.zero()));
return MOVE_FOLDED;
}
if (val2.isMax()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_SHL_opcode:
if (CF_ADDR) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.lsh(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= 32) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case REF_SHR_opcode:
if (CF_ADDR) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.rsha(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_NOT_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isAddressConstant()) {
Word val=op.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(val.not().toAddress()));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case REF_OR_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isAddressConstant()) {
Word val2=op2.asAddressConstant().value.toWord();
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.or(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2.isMax()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(Address.max()));
return MOVE_FOLDED;
}
if (val2.isZero()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_SUB_opcode:
if (CF_ADDR) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isConstant()) {
Address val2=getAddressValue(op2);
if (op1.isConstant()) {
Address val1=getAddressValue(op1);
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.sub(val2.toWord().toOffset())));
return MOVE_FOLDED;
}
 else {
if (val2.isZero()) {
if (op1.isIntLike()) {
Unary.mutate(s,INT_2ADDRSigExt,Binary.getClearResult(s),Binary.getClearVal1(s));
}
 else {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
}
return MOVE_REDUCED;
}
Binary.mutate(s,REF_ADD,Binary.getClearResult(s),Binary.getClearVal1(s),AC(Address.zero().sub(val2.toWord().toOffset())));
return REDUCED;
}
}
}
return UNCHANGED;
case REF_USHR_opcode:
if (CF_ADDR) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.rshl(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= 32) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case REF_XOR_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isAddressConstant()) {
Word val2=op2.asAddressConstant().value.toWord();
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.xor(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2.isMax()) {
Unary.mutate(s,REF_NOT,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2.isZero()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_ADD_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 + val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_AND_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 & val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0L));
return MOVE_FOLDED;
}
if (val2 == -1) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_CMP_opcode:
if (CF_LONG) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
long val2=op2.asLongConstant().value;
int result=(val1 > val2) ? 1 : ((val1 == val2) ? 0 : -1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case LONG_DIV_opcode:
if (CF_LONG) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(1));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (val2 == 0L) {
return UNCHANGED;
}
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(val1 / val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 1L) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_MUL_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 * val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1L) {
Move.mutate(s,LONG_NEG,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0L));
return MOVE_FOLDED;
}
if (val2 == 1L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_NEG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_NOT_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(~val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_OR_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 | val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 == -1L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(-1L));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_REM_opcode:
if (CF_LONG) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (val2 == 0L) {
return UNCHANGED;
}
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(val1 % val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 1L) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_SHL_opcode:
if (CF_LONG) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 << val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= 64) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_SHR_opcode:
if (CF_LONG) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 >> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_SUB_opcode:
if (CF_LONG) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 - val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
Binary.mutate(s,LONG_ADD,Binary.getClearResult(s),Binary.getClearVal1(s),LC(-val2));
return REDUCED;
}
}
}
return UNCHANGED;
case LONG_USHR_opcode:
if (CF_LONG) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 >>> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= 64) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_XOR_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 ^ val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1L) {
Unary.mutate(s,LONG_NOT,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case FLOAT_ADD_opcode:
if (CF_FLOAT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
float val2=op2.asFloatConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 + val2));
return MOVE_FOLDED;
}
if (val2 == 0.0f) {
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case FLOAT_CMPG_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
int result=(val1 < val2) ? -1 : ((val1 == val2) ? 0 : 1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_CMPL_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
int result=(val1 > val2) ? 1 : ((val1 == val2) ? 0 : -1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_DIV_opcode:
if (CF_FLOAT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 / val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_MUL_opcode:
if (CF_FLOAT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
float val2=op2.asFloatConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 * val2));
return MOVE_FOLDED;
}
if (val2 == 1.0f) {
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case FLOAT_NEG_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_REM_opcode:
if (CF_FLOAT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 % val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_SUB_opcode:
if (CF_FLOAT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
float val2=op2.asFloatConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 - val2));
return MOVE_FOLDED;
}
if (val2 == 0.0f) {
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_ADD_opcode:
if (CF_DOUBLE) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
double val2=op2.asDoubleConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 + val2));
return MOVE_FOLDED;
}
if (val2 == 0.0) {
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_CMPG_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
int result=(val1 < val2) ? -1 : ((val1 == val2) ? 0 : 1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_CMPL_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
int result=(val1 > val2) ? 1 : ((val1 == val2) ? 0 : -1);
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_DIV_opcode:
if (CF_DOUBLE) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 / val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_MUL_opcode:
if (CF_DOUBLE) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
double val2=op2.asDoubleConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 * val2));
return MOVE_FOLDED;
}
if (val2 == 1.0) {
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_NEG_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_REM_opcode:
if (CF_DOUBLE) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 % val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_SUB_opcode:
if (CF_DOUBLE) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
double val2=op2.asDoubleConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 - val2));
return MOVE_FOLDED;
}
if (val2 == 0.0) {
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_2FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC((float)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((int)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC((long)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_AS_LONG_BITS_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC(Double.doubleToLongBits(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC((double)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2BYTE_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((byte)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2USHORT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((char)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC((float)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC((long)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2ADDRSigExt_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(Address.fromIntSignExtend(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2ADDRZerExt_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(Address.fromIntZeroExtend(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2ADDR_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(Address.fromLong(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2SHORT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((short)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_BITS_AS_FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC(Float.intBitsToFloat(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case ADDR_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isAddressConstant()) {
Address val=op.asAddressConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(val.toInt()));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case ADDR_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isAddressConstant()) {
Address val=op.asAddressConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC(val.toLong()));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_2DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC((double)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((int)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC((long)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_AS_INT_BITS_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(Float.floatToIntBits(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC((float)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((int)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC((double)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_BITS_AS_DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC(Double.longBitsToDouble(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
default :
return UNCHANGED;
}
}","/** 
 * Given an instruction, attempt to simplify it. The instruction will be mutated in place. <p> We don't deal with branching operations here --  doing peephole optimizations of branches is the job of a separate module.
 * @param regpool register pool in case simplification requires a temporary register
 * @param s the instruction to simplify
 * @return one of UNCHANGED, MOVE_FOLDED, MOVE_REDUCED, TRAP_REDUCED, REDUCED
 */
public static byte simplify(OPT_AbstractRegisterPool regpool,OPT_Instruction s){
switch (s.getOpcode()) {
case GUARD_COMBINE_opcode:
{
      OPT_Operand op2=Binary.getVal2(s);
      if (op2 instanceof OPT_TrueGuardOperand) {
        OPT_Operand op1=Binary.getVal1(s);
        if (op1 instanceof OPT_TrueGuardOperand) {
          Move.mutate(s,GUARD_MOVE,Binary.getClearResult(s),op1);
          return MOVE_FOLDED;
        }
 else {
          Move.mutate(s,GUARD_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
          return MOVE_REDUCED;
        }
      }
    }
  return UNCHANGED;
case TRAP_IF_opcode:
{
  OPT_Operand op1=TrapIf.getVal1(s);
  OPT_Operand op2=TrapIf.getVal2(s);
  if (op1.isConstant()) {
    if (op2.isConstant()) {
      int willTrap=TrapIf.getCond(s).evaluate(op1,op2);
      if (willTrap == OPT_ConditionOperand.TRUE) {
        Trap.mutate(s,TRAP,TrapIf.getClearGuardResult(s),TrapIf.getClearTCode(s));
        return TRAP_REDUCED;
      }
 else       if (willTrap == OPT_ConditionOperand.FALSE) {
        Move.mutate(s,GUARD_MOVE,TrapIf.getClearGuardResult(s),TG());
        return MOVE_FOLDED;
      }
    }
 else {
      TrapIf.mutate(s,TRAP_IF,TrapIf.getClearGuardResult(s),TrapIf.getClearVal2(s),TrapIf.getClearVal1(s),TrapIf.getClearCond(s).flipOperands(),TrapIf.getClearTCode(s));
    }
  }
}
return UNCHANGED;
case NULL_CHECK_opcode:
{
OPT_Operand ref=NullCheck.getRef(s);
if (ref.isNullConstant()) {
Trap.mutate(s,TRAP,NullCheck.getClearGuardResult(s),OPT_TrapCodeOperand.NullPtr());
return TRAP_REDUCED;
}
 else if (ref.isStringConstant()) {
Move.mutate(s,GUARD_MOVE,NullCheck.getClearGuardResult(s),TG());
return MOVE_FOLDED;
}
 else if (ref.isAddressConstant()) {
if (ref.asAddressConstant().value.isZero()) {
  Trap.mutate(s,TRAP,NullCheck.getClearGuardResult(s),OPT_TrapCodeOperand.NullPtr());
  return TRAP_REDUCED;
}
 else {
  Move.mutate(s,GUARD_MOVE,NullCheck.getClearGuardResult(s),TG());
  return MOVE_FOLDED;
}
}
return UNCHANGED;
}
case INT_ZERO_CHECK_opcode:
{
OPT_Operand op=ZeroCheck.getValue(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
if (val == 0) {
Trap.mutate(s,TRAP,ZeroCheck.getClearGuardResult(s),OPT_TrapCodeOperand.DivByZero());
return TRAP_REDUCED;
}
 else {
Move.mutate(s,GUARD_MOVE,ZeroCheck.getClearGuardResult(s),TG());
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case LONG_ZERO_CHECK_opcode:
{
OPT_Operand op=ZeroCheck.getValue(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
if (val == 0L) {
Trap.mutate(s,TRAP,ZeroCheck.getClearGuardResult(s),OPT_TrapCodeOperand.DivByZero());
return TRAP_REDUCED;
}
 else {
Move.mutate(s,GUARD_MOVE,ZeroCheck.getClearGuardResult(s),TG());
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case CHECKCAST_opcode:
{
OPT_Operand ref=TypeCheck.getRef(s);
if (ref.isNullConstant()) {
Empty.mutate(s,NOP);
return REDUCED;
}
 else if (ref.isStringConstant()) {
s.operator=CHECKCAST_NOTNULL;
return simplify(regpool,s);
}
 else {
VM_TypeReference lhsType=TypeCheck.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.YES) {
Empty.mutate(s,NOP);
return REDUCED;
}
}
}
return UNCHANGED;
case CHECKCAST_NOTNULL_opcode:
{
OPT_Operand ref=TypeCheck.getRef(s);
VM_TypeReference lhsType=TypeCheck.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.YES) {
Empty.mutate(s,NOP);
return REDUCED;
}
 else if (ans == OPT_Constants.NO) {
VM_Type rType=rhsType.peekResolvedType();
if (rType != null && rType.isClassType() && rType.asClass().isFinal()) {
Trap.mutate(s,TRAP,null,OPT_TrapCodeOperand.CheckCast());
return TRAP_REDUCED;
}
}
}
return UNCHANGED;
case INSTANCEOF_opcode:
{
OPT_Operand ref=InstanceOf.getRef(s);
if (ref.isNullConstant()) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
 else if (ref.isStringConstant()) {
s.operator=INSTANCEOF_NOTNULL;
return simplify(regpool,s);
}
VM_TypeReference lhsType=InstanceOf.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.NO) {
VM_Type rType=rhsType.peekResolvedType();
if (rType != null && rType.isClassType() && rType.asClass().isFinal()) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case INSTANCEOF_NOTNULL_opcode:
{
OPT_Operand ref=InstanceOf.getRef(s);
VM_TypeReference lhsType=InstanceOf.getType(s).getTypeRef();
VM_TypeReference rhsType=ref.getType();
byte ans=OPT_ClassLoaderProxy.includesType(lhsType,rhsType);
if (ans == OPT_Constants.YES) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(1));
return MOVE_FOLDED;
}
 else if (ans == OPT_Constants.NO) {
VM_Type rType=rhsType.peekResolvedType();
if (rType != null && rType.isClassType() && rType.asClass().isFinal()) {
Move.mutate(s,INT_MOVE,InstanceOf.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case INT_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,INT_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,INT_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (tv.isIntConstant() && fv.isIntConstant() && !CondMove.getCond(s).isFLOATINGPOINT()) {
int itv=tv.asIntConstant().value;
int ifv=fv.asIntConstant().value;
OPT_Operator op=null;
if (val1.isLong()) {
op=BOOLEAN_CMP_LONG;
}
 else if (val1.isFloat()) {
op=BOOLEAN_CMP_FLOAT;
}
 else if (val1.isDouble()) {
op=BOOLEAN_CMP_DOUBLE;
}
 else {
op=BOOLEAN_CMP_INT;
}
if (itv == 1 && ifv == 0) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s),new OPT_BranchProfileOperand());
return REDUCED;
}
if (itv == 0 && ifv == 1) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s).flipCode(),new OPT_BranchProfileOperand());
return REDUCED;
}
}
}
return UNCHANGED;
case LONG_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,LONG_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,LONG_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (tv.isLongConstant() && fv.isLongConstant() && !CondMove.getCond(s).isFLOATINGPOINT()) {
long itv=tv.asLongConstant().value;
long ifv=fv.asLongConstant().value;
OPT_Operator op=null;
if (val1.isLong()) {
op=BOOLEAN_CMP_LONG;
}
 else if (val1.isFloat()) {
op=BOOLEAN_CMP_FLOAT;
}
 else if (val1.isDouble()) {
op=BOOLEAN_CMP_DOUBLE;
}
 else {
op=BOOLEAN_CMP_INT;
}
if (itv == 1 && ifv == 0) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s),new OPT_BranchProfileOperand());
return REDUCED;
}
if (itv == 0 && ifv == 1) {
BooleanCmp.mutate(s,op,CondMove.getClearResult(s),CondMove.getClearVal1(s),CondMove.getClearVal2(s),CondMove.getClearCond(s).flipCode(),new OPT_BranchProfileOperand());
return REDUCED;
}
}
}
return UNCHANGED;
case FLOAT_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,FLOAT_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,FLOAT_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case DOUBLE_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
OPT_Operand val2=CondMove.getVal2(s);
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,DOUBLE_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (val1.isConstant() && !val2.isConstant()) {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
OPT_Operand tv=CondMove.getTrueValue(s);
OPT_Operand fv=CondMove.getFalseValue(s);
if (tv.similar(fv)) {
Move.mutate(s,DOUBLE_MOVE,CondMove.getClearResult(s),tv);
return tv.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case REF_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
if (val1.isConstant()) {
OPT_Operand val2=CondMove.getVal2(s);
if (val2.isConstant()) {
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,REF_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
 else {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
}
if (CondMove.getTrueValue(s).similar(CondMove.getFalseValue(s))) {
OPT_Operand val=CondMove.getClearTrueValue(s);
Move.mutate(s,REF_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case GUARD_COND_MOVE_opcode:
{
OPT_Operand val1=CondMove.getVal1(s);
if (val1.isConstant()) {
OPT_Operand val2=CondMove.getVal2(s);
if (val2.isConstant()) {
int cond=CondMove.getCond(s).evaluate(val1,val2);
if (cond == OPT_ConditionOperand.UNKNOWN) {
OPT_Operand val=(cond == OPT_ConditionOperand.TRUE) ? CondMove.getClearTrueValue(s) : CondMove.getClearFalseValue(s);
Move.mutate(s,GUARD_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
 else {
OPT_Operand tmp=CondMove.getClearVal1(s);
CondMove.setVal1(s,CondMove.getClearVal2(s));
CondMove.setVal2(s,tmp);
CondMove.getCond(s).flipOperands();
}
}
if (CondMove.getTrueValue(s).similar(CondMove.getFalseValue(s))) {
OPT_Operand val=CondMove.getClearTrueValue(s);
Move.mutate(s,GUARD_MOVE,CondMove.getClearResult(s),val);
return val.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
}
return UNCHANGED;
case BOOLEAN_NOT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
if (val == 0) {
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(1));
}
 else {
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(0));
}
return MOVE_FOLDED;
}
}
return UNCHANGED;
case BOOLEAN_CMP_INT_opcode:
if (CF_INT) {
OPT_Operand op1=BooleanCmp.getVal1(s);
OPT_Operand op2=BooleanCmp.getVal2(s);
if (op1.isConstant()) {
if (op2.isConstant()) {
int cond=BooleanCmp.getCond(s).evaluate(op1,op2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
Move.mutate(s,INT_MOVE,BooleanCmp.getResult(s),(cond == OPT_ConditionOperand.TRUE) ? IC(1) : IC(0));
return MOVE_FOLDED;
}
}
 else {
OPT_Operand tmp=BooleanCmp.getClearVal1(s);
BooleanCmp.setVal1(s,BooleanCmp.getClearVal2(s));
BooleanCmp.setVal2(s,tmp);
BooleanCmp.getCond(s).flipOperands();
}
}
}
return UNCHANGED;
case BOOLEAN_CMP_ADDR_opcode:
if (CF_ADDR) {
OPT_Operand op1=BooleanCmp.getVal1(s);
OPT_Operand op2=BooleanCmp.getVal2(s);
if (op1.isConstant()) {
if (op2.isConstant()) {
int cond=BooleanCmp.getCond(s).evaluate(op1,op2);
if (cond != OPT_ConditionOperand.UNKNOWN) {
Move.mutate(s,REF_MOVE,BooleanCmp.getResult(s),(cond == OPT_ConditionOperand.TRUE) ? IC(1) : IC(0));
return MOVE_FOLDED;
}
}
 else {
OPT_Operand tmp=BooleanCmp.getClearVal1(s);
BooleanCmp.setVal1(s,BooleanCmp.getClearVal2(s));
BooleanCmp.setVal2(s,tmp);
BooleanCmp.getCond(s).flipOperands();
}
}
}
return UNCHANGED;
case INT_ADD_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 + val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_AND_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 & val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (val2 == -1) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_DIV_opcode:
if (CF_INT) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(1));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (val2 == 0) {
return UNCHANGED;
}
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(val1 / val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 1) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s));
return MOVE_REDUCED;
}
int power=PowerOf2(val2);
if (power != -1) {
Binary.mutate(s,INT_SHR,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s),IC(power));
return REDUCED;
}
}
}
}
return UNCHANGED;
case INT_MUL_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 * val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1) {
Unary.mutate(s,INT_NEG,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (val2 == 1) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (s.getPrev() != null) {
int cost=0;
for (int i=1; i < BITS_IN_INT; i++) {
if ((val2 & (1 << i)) != 0) {
cost++;
}
}
if (cost < 5) {
OPT_RegisterOperand val1Operand=Binary.getClearVal1(s).asRegister();
OPT_RegisterOperand resultOperand=regpool.makeTempInt();
OPT_Instruction move;
if ((val2 & 1) == 1) {
move=Move.create(INT_MOVE,resultOperand,val1Operand);
}
 else {
move=Move.create(INT_MOVE,resultOperand,IC(0));
}
move.copyPosition(s);
s.insertBefore(move);
for (int i=1; i < BITS_IN_INT; i++) {
if ((val2 & (1 << i)) != 0) {
OPT_RegisterOperand tempInt=regpool.makeTempInt();
OPT_Instruction shift=Binary.create(INT_SHL,tempInt,val1Operand.copyRO(),IC(i));
shift.copyPosition(s);
s.insertBefore(shift);
OPT_Instruction add=Binary.create(INT_ADD,resultOperand.copyRO(),resultOperand.copyRO(),tempInt.copyRO());
add.copyPosition(s);
s.insertBefore(add);
}
}
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),resultOperand.copyRO());
return REDUCED;
}
}
}
}
}
return UNCHANGED;
case INT_NEG_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_NOT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(~val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_OR_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 | val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(-1));
return MOVE_FOLDED;
}
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_REM_opcode:
if (CF_INT) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (val2 == 0) {
return UNCHANGED;
}
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(val1 % val2));
return MOVE_FOLDED;
}
 else {
if ((val2 == 1) || (val2 == -1)) {
Move.mutate(s,INT_MOVE,GuardedBinary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
int power=PowerOf2(val2);
if (power != -1) {
Binary.mutate(s,INT_AND,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s),IC(val2 - 1));
return REDUCED;
}
}
}
}
return UNCHANGED;
case INT_SHL_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 << val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= BITS_IN_INT) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case INT_SHR_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 >> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case INT_SUB_opcode:
if (CF_INT) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 - val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
Binary.mutate(s,INT_ADD,Binary.getClearResult(s),Binary.getClearVal1(s),IC(-val2));
return REDUCED;
}
}
}
return UNCHANGED;
case INT_USHR_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 >>> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= BITS_IN_INT) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case INT_XOR_opcode:
if (CF_INT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
if (op1.isIntConstant()) {
int val1=op1.asIntConstant().value;
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(val1 ^ val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1) {
Unary.mutate(s,INT_NOT,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_ADD_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isConstant()) {
Address val2=getAddressValue(op2);
OPT_Operand op1=Binary.getVal1(s);
if (op1.isConstant()) {
Address val1=getAddressValue(op1);
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.add(val2.toWord().toOffset())));
return MOVE_FOLDED;
}
 else {
if (val2.isZero()) {
if (op1.isIntLike()) {
Unary.mutate(s,INT_2ADDRSigExt,Binary.getClearResult(s),Binary.getClearVal1(s));
}
 else {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
}
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_AND_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isAddressConstant()) {
Word val2=op2.asAddressConstant().value.toWord();
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.and(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2.isZero()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(Address.zero()));
return MOVE_FOLDED;
}
if (val2.isMax()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_SHL_opcode:
if (CF_ADDR) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.lsh(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= BITS_IN_ADDRESS) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case REF_SHR_opcode:
if (CF_ADDR) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.rsha(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_NOT_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isAddressConstant()) {
Word val=op.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(val.not().toAddress()));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case REF_OR_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isAddressConstant()) {
Word val2=op2.asAddressConstant().value.toWord();
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.or(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2.isMax()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(Address.max()));
return MOVE_FOLDED;
}
if (val2.isZero()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case REF_SUB_opcode:
if (CF_ADDR) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isConstant()) {
Address val2=getAddressValue(op2);
if (op1.isConstant()) {
Address val1=getAddressValue(op1);
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.sub(val2.toWord().toOffset())));
return MOVE_FOLDED;
}
 else {
if (val2.isZero()) {
if (op1.isIntLike()) {
Unary.mutate(s,INT_2ADDRSigExt,Binary.getClearResult(s),Binary.getClearVal1(s));
}
 else {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
}
return MOVE_REDUCED;
}
Binary.mutate(s,REF_ADD,Binary.getClearResult(s),Binary.getClearVal1(s),AC(Address.zero().sub(val2.toWord().toOffset())));
return REDUCED;
}
}
}
return UNCHANGED;
case REF_USHR_opcode:
if (CF_ADDR) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.rshl(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= BITS_IN_ADDRESS) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case REF_XOR_opcode:
if (CF_ADDR) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isAddressConstant()) {
Word val2=op2.asAddressConstant().value.toWord();
if (op1.isAddressConstant()) {
Word val1=op1.asAddressConstant().value.toWord();
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),AC(val1.xor(val2).toAddress()));
return MOVE_FOLDED;
}
 else {
if (val2.isMax()) {
Unary.mutate(s,REF_NOT,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2.isZero()) {
Move.mutate(s,REF_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_ADD_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 + val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_AND_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 & val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0L));
return MOVE_FOLDED;
}
if (val2 == -1) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_CMP_opcode:
if (CF_LONG) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
long val2=op2.asLongConstant().value;
int result=(val1 > val2) ? 1 : ((val1 == val2) ? 0 : -1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case LONG_DIV_opcode:
if (CF_LONG) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(1));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (val2 == 0L) {
return UNCHANGED;
}
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(val1 / val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 1L) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),GuardedBinary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_MUL_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 * val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1L) {
Move.mutate(s,LONG_NEG,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0L));
return MOVE_FOLDED;
}
if (val2 == 1L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_NEG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_NOT_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(~val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_OR_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return op1.isConstant() ? MOVE_FOLDED : MOVE_REDUCED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 | val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 == -1L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(-1L));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_REM_opcode:
if (CF_LONG) {
OPT_Operand op1=GuardedBinary.getVal1(s);
OPT_Operand op2=GuardedBinary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (val2 == 0L) {
return UNCHANGED;
}
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(val1 % val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 1L) {
Move.mutate(s,LONG_MOVE,GuardedBinary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_SHL_opcode:
if (CF_LONG) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 << val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= BITS_IN_LONG) {
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_SHR_opcode:
if (CF_LONG) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 >> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case LONG_SUB_opcode:
if (CF_LONG) {
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 - val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
Binary.mutate(s,LONG_ADD,Binary.getClearResult(s),Binary.getClearVal1(s),LC(-val2));
return REDUCED;
}
}
}
return UNCHANGED;
case LONG_USHR_opcode:
if (CF_LONG) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isIntConstant()) {
int val2=op2.asIntConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 >>> val2));
return MOVE_FOLDED;
}
 else {
if (val2 == 0) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
if (val2 >= BITS_IN_LONG) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
}
}
}
return UNCHANGED;
case LONG_XOR_opcode:
if (CF_LONG) {
canonicalizeCommutativeOperator(s);
OPT_Operand op1=Binary.getVal1(s);
OPT_Operand op2=Binary.getVal2(s);
if (op1.similar(op2)) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(0));
return MOVE_FOLDED;
}
if (op2.isLongConstant()) {
long val2=op2.asLongConstant().value;
if (op1.isLongConstant()) {
long val1=op1.asLongConstant().value;
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),LC(val1 ^ val2));
return MOVE_FOLDED;
}
 else {
if (val2 == -1L) {
Unary.mutate(s,LONG_NOT,Binary.getClearResult(s),Binary.getClearVal1(s));
return REDUCED;
}
if (val2 == 0L) {
Move.mutate(s,LONG_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
}
return UNCHANGED;
case FLOAT_ADD_opcode:
if (CF_FLOAT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
float val2=op2.asFloatConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 + val2));
return MOVE_FOLDED;
}
if (val2 == 0.0f) {
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case FLOAT_CMPG_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
int result=(val1 < val2) ? -1 : ((val1 == val2) ? 0 : 1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_CMPL_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
int result=(val1 > val2) ? 1 : ((val1 == val2) ? 0 : -1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_DIV_opcode:
if (CF_FLOAT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 / val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_MUL_opcode:
if (CF_FLOAT) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
float val2=op2.asFloatConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 * val2));
return MOVE_FOLDED;
}
if (val2 == 1.0f) {
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case FLOAT_NEG_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_REM_opcode:
if (CF_FLOAT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
float val2=op2.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 % val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case FLOAT_SUB_opcode:
if (CF_FLOAT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isFloatConstant()) {
float val2=op2.asFloatConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isFloatConstant()) {
float val1=op1.asFloatConstant().value;
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),FC(val1 - val2));
return MOVE_FOLDED;
}
if (val2 == 0.0f) {
Move.mutate(s,FLOAT_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_ADD_opcode:
if (CF_DOUBLE) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
double val2=op2.asDoubleConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 + val2));
return MOVE_FOLDED;
}
if (val2 == 0.0) {
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_CMPG_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
int result=(val1 < val2) ? -1 : ((val1 == val2) ? 0 : 1);
Move.mutate(s,INT_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_CMPL_opcode:
if (CF_INT) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
int result=(val1 > val2) ? 1 : ((val1 == val2) ? 0 : -1);
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),IC(result));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_DIV_opcode:
if (CF_DOUBLE) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 / val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_MUL_opcode:
if (CF_DOUBLE) {
canonicalizeCommutativeOperator(s);
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
double val2=op2.asDoubleConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 * val2));
return MOVE_FOLDED;
}
if (val2 == 1.0) {
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_NEG_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC(-val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_REM_opcode:
if (CF_DOUBLE) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
double val2=op2.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 % val2));
return MOVE_FOLDED;
}
}
}
return UNCHANGED;
case DOUBLE_SUB_opcode:
if (CF_DOUBLE) {
OPT_Operand op2=Binary.getVal2(s);
if (op2.isDoubleConstant()) {
double val2=op2.asDoubleConstant().value;
OPT_Operand op1=Binary.getVal1(s);
if (op1.isDoubleConstant()) {
double val1=op1.asDoubleConstant().value;
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),DC(val1 - val2));
return MOVE_FOLDED;
}
if (val2 == 0.0) {
Move.mutate(s,DOUBLE_MOVE,Binary.getClearResult(s),Binary.getClearVal1(s));
return MOVE_REDUCED;
}
}
}
return UNCHANGED;
case DOUBLE_2FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC((float)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((int)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC((long)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case DOUBLE_AS_LONG_BITS_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isDoubleConstant()) {
double val=op.asDoubleConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC(Double.doubleToLongBits(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC((double)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2BYTE_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((byte)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2USHORT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((char)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC((float)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC((long)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2ADDRSigExt_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(Address.fromIntSignExtend(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2ADDRZerExt_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(Address.fromIntZeroExtend(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2ADDR_opcode:
if (CF_ADDR) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,REF_MOVE,Unary.getClearResult(s),AC(Address.fromLong(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_2SHORT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((short)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case INT_BITS_AS_FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isIntConstant()) {
int val=op.asIntConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC(Float.intBitsToFloat(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case ADDR_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isAddressConstant()) {
Address val=op.asAddressConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(val.toInt()));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case ADDR_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isAddressConstant()) {
Address val=op.asAddressConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC(val.toLong()));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_2DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC((double)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((int)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_2LONG_opcode:
if (CF_LONG) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,LONG_MOVE,Unary.getClearResult(s),LC((long)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case FLOAT_AS_INT_BITS_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isFloatConstant()) {
float val=op.asFloatConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC(Float.floatToIntBits(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2FLOAT_opcode:
if (CF_FLOAT) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,FLOAT_MOVE,Unary.getClearResult(s),FC((float)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2INT_opcode:
if (CF_INT) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,INT_MOVE,Unary.getClearResult(s),IC((int)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_2DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC((double)val));
return MOVE_FOLDED;
}
}
return UNCHANGED;
case LONG_BITS_AS_DOUBLE_opcode:
if (CF_DOUBLE) {
OPT_Operand op=Unary.getVal(s);
if (op.isLongConstant()) {
long val=op.asLongConstant().value;
Move.mutate(s,DOUBLE_MOVE,Unary.getClearResult(s),DC(Double.longBitsToDouble(val)));
return MOVE_FOLDED;
}
}
return UNCHANGED;
default :
return UNCHANGED;
}
}",0.9988365447419988
150068,"/** 
 * Emit code to implement the tableswitch bytecode
 * @param defaultval bcIndex of the default target
 * @param low low value of switch
 * @param high high value of switch
 */
protected final void emit_tableswitch(int defaultval,int low,int high){
  int bTarget=biStart + defaultval;
  int mTarget=bytecodeMap[bTarget];
  int n=high - low + 1;
  int firstCounter=edgeCounterIdx;
  popInt(T0);
  if (VM_Assembler.fits(16,-low)) {
    asm.emitADDI(T0,-low,T0);
  }
 else {
    asm.emitLVAL(T1,low);
    asm.emitSUBFC(T0,T1,T0);
  }
  asm.emitLVAL(T2,n);
  asm.emitCMPL(T0,T2);
  if (options.EDGE_COUNTERS) {
    edgeCounterIdx+=n + 1;
    asm.emitLAddrToc(T2,VM_Entrypoints.edgeCountersField.getOffset());
    asm.emitLAddrOffset(T2,T2,getEdgeCounterOffset());
    VM_ForwardReference fr=asm.emitForwardBC(LT);
    incEdgeCounter(T2,S0,firstCounter + n);
    asm.emitB(mTarget,bTarget);
    fr.resolve(asm);
  }
 else {
    if (bTarget - SHORT_FORWARD_LIMIT < biStart) {
      asm.emitShortBC(GE,mTarget,bTarget);
    }
 else {
      asm.emitBC(GE,mTarget,bTarget);
    }
  }
  VM_ForwardReference fr1=asm.emitForwardBL();
  for (int i=0; i < n; i++) {
    int offset=bcodes.getTableSwitchOffset(i);
    bTarget=biStart + offset;
    mTarget=bytecodeMap[bTarget];
    asm.emitSwitchCase(i,mTarget,bTarget);
  }
  bcodes.skipTableSwitchOffsets(n);
  fr1.resolve(asm);
  asm.emitMFLR(T1);
  asm.emitSLWI(T0,T0,LOG_BYTES_IN_INT);
  if (options.EDGE_COUNTERS) {
    incEdgeCounterIdx(T2,S0,firstCounter,T0);
  }
  asm.emitLIntX(T0,T0,T1);
  asm.emitADD(T1,T1,T0);
  asm.emitMTCTR(T1);
  asm.emitBCCTR();
}","/** 
 * Emit code to implement the tableswitch bytecode
 * @param defaultval bcIndex of the default target
 * @param low low value of switch
 * @param high high value of switch
 */
protected final void emit_tableswitch(int defaultval,int low,int high){
  int bTarget=biStart + defaultval;
  int mTarget=bytecodeMap[bTarget];
  int n=high - low + 1;
  int firstCounter=edgeCounterIdx;
  popInt(T0);
  if (VM_Assembler.fits(-low,16)) {
    asm.emitADDI(T0,-low,T0);
  }
 else {
    asm.emitLVAL(T1,low);
    asm.emitSUBFC(T0,T1,T0);
  }
  asm.emitLVAL(T2,n);
  asm.emitCMPL(T0,T2);
  if (options.EDGE_COUNTERS) {
    edgeCounterIdx+=n + 1;
    asm.emitLAddrToc(T2,VM_Entrypoints.edgeCountersField.getOffset());
    asm.emitLAddrOffset(T2,T2,getEdgeCounterOffset());
    VM_ForwardReference fr=asm.emitForwardBC(LT);
    incEdgeCounter(T2,S0,firstCounter + n);
    asm.emitB(mTarget,bTarget);
    fr.resolve(asm);
  }
 else {
    if (bTarget - SHORT_FORWARD_LIMIT < biStart) {
      asm.emitShortBC(GE,mTarget,bTarget);
    }
 else {
      asm.emitBC(GE,mTarget,bTarget);
    }
  }
  VM_ForwardReference fr1=asm.emitForwardBL();
  for (int i=0; i < n; i++) {
    int offset=bcodes.getTableSwitchOffset(i);
    bTarget=biStart + offset;
    mTarget=bytecodeMap[bTarget];
    asm.emitSwitchCase(i,mTarget,bTarget);
  }
  bcodes.skipTableSwitchOffsets(n);
  fr1.resolve(asm);
  asm.emitMFLR(T1);
  asm.emitSLWI(T0,T0,LOG_BYTES_IN_INT);
  if (options.EDGE_COUNTERS) {
    incEdgeCounterIdx(T2,S0,firstCounter,T0);
  }
  asm.emitLIntX(T0,T0,T1);
  asm.emitADD(T1,T1,T0);
  asm.emitMTCTR(T1);
  asm.emitBCCTR();
}",0.9968827930174564
150069,"/** 
 * Reorder code using Algo2 (Bottom-Up Positioning) from Pettis and Hansen PLDI'90.
 * @param ir the OPT_IR to reorder.
 */
private void doPettisHansenAlgo2(OPT_IR ir){
  int numBlocks=0;
  SortedSet edges=new TreeSet();
  Set chainHeads=new HashSet();
  OPT_BasicBlock entry=ir.cfg.entry();
  if (VM.VerifyAssertions)   VM._assert(ir.cfg.entry() == ir.cfg.firstInCodeOrder());
  for (OPT_BasicBlock bb=entry; bb != null; bb=bb.nextBasicBlockInCodeOrder()) {
    numBlocks++;
    chainHeads.add(bb);
    bb.scratchObject=bb;
    OPT_BasicBlock ft=bb.getFallThroughBlock();
    if (ft != null) {
      bb.appendInstruction(Goto.create(GOTO,ft.makeJumpTarget()));
    }
    float bw=bb.getExecutionFrequency();
    for (OPT_WeightedBranchTargets wbt=new OPT_WeightedBranchTargets(bb); wbt.hasMoreElements(); wbt.advance()) {
      edges.add(new Edge(bb,wbt.curBlock(),wbt.curWeight() * bw));
    }
  }
  if (DEBUG)   VM.sysWriteln(""String_Node_Str"" + edges);
  ir.cfg.clearCodeOrder();
  for (Iterator edgesI=edges.iterator(); edgesI.hasNext(); ) {
    Edge e=(Edge)edgesI.next();
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"" + e);
    if (e.target == entry) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (e.source.nextBasicBlockInCodeOrder() != null) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (e.target.prevBasicBlockInCodeOrder() != null) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (e.source.scratchObject == e.target.scratchObject) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"");
    chainHeads.remove(e.target);
    ir.cfg.linkInCodeOrder(e.source,e.target);
    OPT_BasicBlock newChain=(OPT_BasicBlock)e.source.scratchObject;
    for (OPT_BasicBlock ptr=e.target; ptr != null; ptr=ptr.nextBasicBlockInCodeOrder()) {
      ptr.scratchObject=newChain;
    }
  }
  if (DEBUG)   VM.sysWriteln(""String_Node_Str"");
  Map chainInfo=new HashMap();
  for (Iterator chainI=chainHeads.iterator(); chainI.hasNext(); ) {
    OPT_BasicBlock head=(OPT_BasicBlock)chainI.next();
    if (DEBUG)     dumpChain(head);
    chainInfo.put(head,new ChainInfo(head));
  }
  for (Iterator edgesI=edges.iterator(); edgesI.hasNext(); ) {
    Edge e=(Edge)edgesI.next();
    if (e.source.scratchObject != e.target.scratchObject) {
      Object sourceChain=e.source.scratchObject;
      Object targetChain=e.target.scratchObject;
      ChainInfo sourceInfo=(ChainInfo)chainInfo.get(sourceChain);
      ChainInfo targetInfo=(ChainInfo)chainInfo.get(targetChain);
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"" + sourceChain + ""String_Node_Str""+ targetChain+ ""String_Node_Str""+ e.weight+ ""String_Node_Str"");
      Object value=sourceInfo.outWeights.get(targetInfo);
      float weight=e.weight;
      if (value != null) {
        weight+=((Float)value).floatValue();
      }
      sourceInfo.outWeights.put(targetInfo,new Float(weight));
      targetInfo.inWeight+=e.weight;
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"" + targetInfo + ""String_Node_Str""+ sourceInfo.outWeights.get(targetInfo));
    }
  }
  if (DEBUG)   VM.sysWriteln(""String_Node_Str"" + chainInfo);
  OPT_BasicBlock lastNode=null;
  ChainInfo nextChoice=(ChainInfo)chainInfo.get(entry);
  int numPlaced=0;
  ir.cfg._firstNode=entry;
  while (true) {
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"" + nextChoice);
    if (lastNode != null)     ir.cfg.linkInCodeOrder(lastNode,nextChoice.head);
    for (OPT_BasicBlock ptr=nextChoice.head; ptr != null; ptr=ptr.nextBasicBlockInCodeOrder()) {
      numPlaced++;
      lastNode=ptr;
    }
    chainInfo.remove(nextChoice.head);
    if (chainInfo.isEmpty())     break;
    for (Iterator i=nextChoice.outWeights.keySet().iterator(); i.hasNext(); ) {
      ChainInfo target=(ChainInfo)i.next();
      if (DEBUG)       VM.sysWrite(""String_Node_Str"" + target);
      float weight=((Float)nextChoice.outWeights.get(target)).floatValue();
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"" + weight);
      target.placedWeight+=weight;
      target.inWeight-=weight;
    }
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"" + chainInfo);
    nextChoice=null;
    float placedWeight=0f;
    for (Iterator i=chainInfo.values().iterator(); i.hasNext(); ) {
      ChainInfo cand=(ChainInfo)i.next();
      if (cand.placedWeight > 0f) {
        if (nextChoice == null) {
          if (DEBUG)           VM.sysWriteln(""String_Node_Str"" + cand);
          nextChoice=cand;
        }
 else         if (cand.inWeight < nextChoice.inWeight || (cand.inWeight == nextChoice.inWeight && cand.placedWeight > nextChoice.placedWeight)) {
          if (DEBUG)           VM.sysWriteln(cand + ""String_Node_Str"" + nextChoice);
          nextChoice=cand;
        }
      }
    }
    if (nextChoice != null)     continue;
    for (Iterator i=chainInfo.values().iterator(); i.hasNext(); ) {
      ChainInfo cand=(ChainInfo)i.next();
      if (nextChoice == null) {
        if (DEBUG)         VM.sysWriteln(""String_Node_Str"" + cand);
        nextChoice=cand;
      }
 else       if (cand.inWeight < nextChoice.inWeight) {
        if (DEBUG)         VM.sysWriteln(cand + ""String_Node_Str"" + nextChoice);
        nextChoice=cand;
      }
    }
  }
  if (VM.VerifyAssertions)   VM._assert(numPlaced == numBlocks);
  ir.cfg._lastNode=lastNode;
}","/** 
 * Reorder code using Algo2 (Bottom-Up Positioning) from Pettis and Hansen PLDI'90.
 * @param ir the OPT_IR to reorder.
 */
private void doPettisHansenAlgo2(OPT_IR ir){
  int numBlocks=0;
  SortedSet edges=new TreeSet();
  Set chainHeads=new HashSet();
  OPT_BasicBlock entry=ir.cfg.entry();
  if (VM.VerifyAssertions)   VM._assert(ir.cfg.entry() == ir.cfg.firstInCodeOrder());
  for (OPT_BasicBlock bb=entry; bb != null; bb=bb.nextBasicBlockInCodeOrder()) {
    numBlocks++;
    chainHeads.add(bb);
    bb.scratchObject=bb;
    OPT_BasicBlock ft=bb.getFallThroughBlock();
    if (ft != null) {
      bb.appendInstruction(Goto.create(GOTO,ft.makeJumpTarget()));
    }
    float bw=bb.getExecutionFrequency();
    for (OPT_WeightedBranchTargets wbt=new OPT_WeightedBranchTargets(bb); wbt.hasMoreElements(); wbt.advance()) {
      edges.add(new Edge(bb,wbt.curBlock(),wbt.curWeight() * bw));
    }
  }
  if (DEBUG)   VM.sysWriteln(""String_Node_Str"" + edges);
  ir.cfg.clearCodeOrder();
  for (Iterator edgesI=edges.iterator(); edgesI.hasNext(); ) {
    Edge e=(Edge)edgesI.next();
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"" + e);
    if (e.target == entry) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (e.source.nextBasicBlockInCodeOrder() != null) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (e.target.prevBasicBlockInCodeOrder() != null) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (e.source.scratchObject == e.target.scratchObject) {
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"");
      continue;
    }
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"");
    chainHeads.remove(e.target);
    ir.cfg.linkInCodeOrder(e.source,e.target);
    OPT_BasicBlock newChain=(OPT_BasicBlock)e.source.scratchObject;
    for (OPT_BasicBlock ptr=e.target; ptr != null; ptr=ptr.nextBasicBlockInCodeOrder()) {
      ptr.scratchObject=newChain;
    }
  }
  if (DEBUG)   VM.sysWriteln(""String_Node_Str"");
  Map chainInfo=new HashMap();
  for (Iterator chainI=chainHeads.iterator(); chainI.hasNext(); ) {
    OPT_BasicBlock head=(OPT_BasicBlock)chainI.next();
    if (DEBUG)     dumpChain(head);
    chainInfo.put(head,new ChainInfo(head));
  }
  for (Iterator edgesI=edges.iterator(); edgesI.hasNext(); ) {
    Edge e=(Edge)edgesI.next();
    if (e.source.scratchObject != e.target.scratchObject) {
      Object sourceChain=e.source.scratchObject;
      Object targetChain=e.target.scratchObject;
      ChainInfo sourceInfo=(ChainInfo)chainInfo.get(sourceChain);
      ChainInfo targetInfo=(ChainInfo)chainInfo.get(targetChain);
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"" + sourceChain + ""String_Node_Str""+ targetChain+ ""String_Node_Str""+ e.weight+ ""String_Node_Str"");
      Object value=sourceInfo.outWeights.get(targetInfo);
      float weight=e.weight;
      if (value != null) {
        weight+=((Float)value).floatValue();
      }
      sourceInfo.outWeights.put(targetInfo,new Float(weight));
      targetInfo.inWeight+=e.weight;
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"" + targetInfo + ""String_Node_Str""+ sourceInfo.outWeights.get(targetInfo));
    }
  }
  if (DEBUG)   VM.sysWriteln(""String_Node_Str"" + chainInfo);
  OPT_BasicBlock lastNode=null;
  ChainInfo nextChoice=(ChainInfo)chainInfo.get(entry);
  int numPlaced=0;
  ir.cfg._firstNode=entry;
  while (true) {
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"" + nextChoice);
    if (lastNode != null)     ir.cfg.linkInCodeOrder(lastNode,nextChoice.head);
    for (OPT_BasicBlock ptr=nextChoice.head; ptr != null; ptr=ptr.nextBasicBlockInCodeOrder()) {
      numPlaced++;
      lastNode=ptr;
    }
    chainInfo.remove(nextChoice.head);
    if (chainInfo.isEmpty())     break;
    for (Iterator i=nextChoice.outWeights.keySet().iterator(); i.hasNext(); ) {
      ChainInfo target=(ChainInfo)i.next();
      if (DEBUG)       VM.sysWrite(""String_Node_Str"" + target);
      float weight=((Float)nextChoice.outWeights.get(target)).floatValue();
      if (DEBUG)       VM.sysWriteln(""String_Node_Str"" + weight);
      target.placedWeight+=weight;
      target.inWeight-=weight;
    }
    if (DEBUG)     VM.sysWriteln(""String_Node_Str"" + chainInfo);
    nextChoice=null;
    float placedWeight=0f;
    for (Iterator i=chainInfo.values().iterator(); i.hasNext(); ) {
      ChainInfo cand=(ChainInfo)i.next();
      if (cand.placedWeight > 0f) {
        if (nextChoice == null) {
          if (DEBUG)           VM.sysWriteln(""String_Node_Str"" + cand);
          nextChoice=cand;
        }
 else         if (cand.inWeight > nextChoice.inWeight || (cand.inWeight == nextChoice.inWeight && cand.placedWeight > nextChoice.placedWeight)) {
          if (DEBUG)           VM.sysWriteln(cand + ""String_Node_Str"" + nextChoice);
          nextChoice=cand;
        }
      }
    }
    if (nextChoice != null)     continue;
    for (Iterator i=chainInfo.values().iterator(); i.hasNext(); ) {
      ChainInfo cand=(ChainInfo)i.next();
      if (nextChoice == null) {
        if (DEBUG)         VM.sysWriteln(""String_Node_Str"" + cand);
        nextChoice=cand;
      }
 else       if (cand.inWeight < nextChoice.inWeight) {
        if (DEBUG)         VM.sysWriteln(cand + ""String_Node_Str"" + nextChoice);
        nextChoice=cand;
      }
    }
  }
  if (VM.VerifyAssertions)   VM._assert(numPlaced == numBlocks);
  ir.cfg._lastNode=lastNode;
}",0.9998164464023496
150070,"/** 
 * ""Semantic inlining"" of methods of the VM_Magic class. Based on the methodName, generate a sequence of opt instructions that implement the magic, updating the expression stack as necessary.
 * @param bc2ir the bc2ir object that is generating the ir containing this magic
 * @param gc must be bc2ir.gc
 * @param meth the VM_Method that is the magic method
 */
static boolean generateMagic(OPT_BC2IR bc2ir,OPT_GenerationContext gc,VM_MethodReference meth) throws OPT_MagicNotImplementedException {
  if (gc.method.hasNoInlinePragma())   gc.allocFrame=true;
  bc2ir.markBBUnsafeForScheduling();
  VM_Atom methodName=meth.getName();
  boolean address=(meth.getType() == VM_TypeReference.Address);
  VM_TypeReference[] types=meth.getParameterTypes();
  VM_TypeReference returnType=meth.getReturnType();
  if (address && isLoad(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(returnType);
    bc2ir.appendInstruction(Load.create(getOperator(returnType,LOAD_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U(),returnType);
  }
 else   if (address && isPrepare(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(returnType);
    bc2ir.appendInstruction(Prepare.create(getOperator(returnType,PREPARE_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U(),returnType);
  }
 else   if (address && methodName == VM_MagicNames.attempt) {
    VM_TypeReference attemptType=types[0];
    OPT_Operand offset=(types.length == 2) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(getOperator(attemptType,ATTEMPT_OP),test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U(),returnType);
  }
 else   if (address && methodName == VM_MagicNames.store) {
    VM_TypeReference storeType=types[0];
    OPT_Operand offset=(types.length == 1) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(getOperator(storeType,STORE_OP),val,base,offset,null));
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    OPT_RegisterOperand rop=gc.temps.makePROp();
    bc2ir.markGuardlessNonNull(rop);
    bc2ir.push(rop);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    OPT_Operand val=bc2ir.popRef();
    if (val instanceof OPT_RegisterOperand) {
      bc2ir.appendInstruction(Move.create(REF_MOVE,gc.temps.makePROp(),val));
    }
 else {
      String msg=""String_Node_Str"";
      throw OPT_MagicNotImplementedException.UNEXPECTED(msg);
    }
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    OPT_Instruction s=bc2ir.generateAnewarray(meth.getType().getArrayElementType());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    OPT_Operand op1=bc2ir.pop();
    bc2ir.clearCurrentGuard();
    if (bc2ir.do_NullCheck(op1))     return true;
    OPT_RegisterOperand t=gc.temps.makeTempInt();
    OPT_Instruction s=GuardedUnary.create(ARRAYLENGTH,t,op1,bc2ir.getCurrentGuard());
    bc2ir.push(t.copyD2U());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offsetI=gc.temps.makeTempInt();
    OPT_RegisterOperand offset=gc.temps.makeTempOffset();
    OPT_RegisterOperand result;
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        result=gc.temps.makeTemp(VM_TypeReference.Byte);
        bc2ir.appendInstruction(Load.create(BYTE_LOAD,result,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        result=gc.temps.makeTemp(VM_TypeReference.Int);
        bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
        bc2ir.appendInstruction(Load.create(INT_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      result=gc.temps.makeTemp(elementType);
      bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
      bc2ir.appendInstruction(Load.create(REF_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
    bc2ir.push(result.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offsetI=gc.temps.makeTempInt();
    OPT_RegisterOperand offset=gc.temps.makeTempOffset();
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        bc2ir.appendInstruction(Store.create(BYTE_STORE,val,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
        bc2ir.appendInstruction(Store.create(INT_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
      bc2ir.appendInstruction(Store.create(REF_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getWordAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setWordAtOffset) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Load.create(LONG_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setLongAtOffset) {
    OPT_Operand val=bc2ir.popLong();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(LONG_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getDoubleAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Load.create(DOUBLE_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setDoubleAtOffset) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(DOUBLE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectArrayAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 4) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,loc));
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Byte);
    bc2ir.appendInstruction(Load.create(BYTE_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(BYTE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Char);
    bc2ir.appendInstruction(Load.create(USHORT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(SHORT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryWord) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryAddress) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryWord) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryAddress) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 3) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),loc));
  }
 else   if (meth.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=meth.getParameterTypes();
    int numArgs=args.length;
    VM_Field ip=VM_Entrypoints.getSysCallField(meth.getName().toString());
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(ip);
    OPT_Instruction call=Call.create(SYSCALL,null,null,mo,null,args.length);
    for (int i=args.length - 1; i >= 0; i--) {
      Call.setParam(call,i,bc2ir.pop(args[i]));
    }
    if (!returnType.isVoidType()) {
      OPT_RegisterOperand op0=gc.temps.makeTemp(returnType);
      Call.setResult(call,op0);
      bc2ir.push(op0.copyD2U(),returnType);
    }
    bc2ir.appendInstruction(call);
  }
 else   if (methodName == VM_MagicNames.threadAsCollectorThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsProcessor) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Processor);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsAddress) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObject) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObjectArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsRegisters) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsShortArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ShortArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsStack) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.floatAsIntBits) {
    OPT_Operand val=bc2ir.popFloat();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Unary.create(FLOAT_AS_INT_BITS,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.intBitsAsFloat) {
    OPT_Operand val=bc2ir.popInt();
    OPT_RegisterOperand op0=gc.temps.makeTempFloat();
    bc2ir.appendInstruction(Unary.create(INT_BITS_AS_FLOAT,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.doubleAsLongBits) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Unary.create(DOUBLE_AS_LONG_BITS,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.longBitsAsDouble) {
    OPT_Operand val=bc2ir.popLong();
    OPT_RegisterOperand op0=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Unary.create(LONG_BITS_AS_DOUBLE,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand guard=OPT_BC2IR.getGuard(val);
    if (guard == null) {
      guard=new OPT_TrueGuardOperand();
    }
    OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(GuardedUnary.create(GET_OBJ_TIB,tibPtr,val,guard));
    OPT_RegisterOperand op0;
    VM_TypeReference argType=val.getType();
    if (argType.isArrayType()) {
      op0=gc.temps.makeTemp(VM_TypeReference.VM_Array);
    }
 else {
      if (argType == VM_TypeReference.JavaLangObject || argType == VM_TypeReference.JavaLangCloneable || argType == VM_TypeReference.JavaIoSerializable) {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Type);
      }
 else {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Class);
      }
    }
    bc2ir.markGuardlessNonNull(op0);
    bc2ir.appendInstruction(Unary.create(GET_TYPE_FROM_TIB,op0,tibPtr.copyD2U()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    OPT_Operand val=bc2ir.popRef();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(GuardedUnary.create(ARRAYLENGTH,op0,val,new OPT_TrueGuardOperand()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    OPT_Instruction s=Call.create0(CALL,null,bc2ir.popRef(),null);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    OPT_Operand code=bc2ir.popRef();
    OPT_Operand args=bc2ir.popRef();
    bc2ir.appendInstruction(Call.create1(CALL,null,code,null,args));
  }
 else   if ((methodName == VM_MagicNames.invokeMethodReturningObject) || (methodName == VM_MagicNames.invokeMethodReturningVoid) || (methodName == VM_MagicNames.invokeMethodReturningLong)|| (methodName == VM_MagicNames.invokeMethodReturningDouble)|| (methodName == VM_MagicNames.invokeMethodReturningFloat)|| (methodName == VM_MagicNames.invokeMethodReturningInt)) {
    OPT_Operand spills=bc2ir.popRef();
    OPT_Operand fprs=bc2ir.popRef();
    OPT_Operand gprs=bc2ir.popRef();
    OPT_Operand code=bc2ir.popRef();
    OPT_RegisterOperand res=null;
    if (methodName == VM_MagicNames.invokeMethodReturningObject) {
      res=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
      bc2ir.push(res.copyD2U());
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningLong) {
      res=gc.temps.makeTemp(VM_TypeReference.Long);
      bc2ir.push(res.copyD2U(),VM_TypeReference.Long);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
      res=gc.temps.makeTempDouble();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Double);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
      res=gc.temps.makeTempFloat();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Float);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningInt) {
      res=gc.temps.makeTempInt();
      bc2ir.push(res.copyD2U());
    }
    VM_Field target=VM_Entrypoints.reflectiveMethodInvokerInstructionsField;
    OPT_MethodOperand met=OPT_MethodOperand.STATIC(target);
    OPT_Instruction s=Call.create4(CALL,res,new OPT_AddressConstantOperand(target.getOffset()),met,code,gprs,fprs,spills);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.saveThreadStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_AddressConstantOperand(target.getOffset()),mo,p1));
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    OPT_Operand p2=bc2ir.popRef();
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.threadSwitchInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create2(CALL,null,new OPT_AddressConstantOperand(target.getOffset()),mo,p1,p2));
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    VM_Field target=VM_Entrypoints.restoreHardwareExceptionStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_AddressConstantOperand(target.getOffset()),mo,bc2ir.popRef()));
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Prepare.create(PREPARE_INT,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareObject) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareAddress) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareWord) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    OPT_Operand newVal=bc2ir.popInt();
    OPT_Operand oldVal=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_INT,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptObject) {
    OPT_Operand newVal=bc2ir.popRef();
    OPT_Operand oldVal=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptAddress) {
    OPT_Operand newVal=bc2ir.popAddress();
    OPT_Operand oldVal=bc2ir.popAddress();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptWord) {
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (generatePolymorphicMagic(bc2ir,gc,meth,methodName)) {
    return true;
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Nullary.create(GET_TIME_BASE,op0));
    bc2ir.pushDual(op0.copyD2U());
  }
 else {
    return OPT_GenerateMachineSpecificMagic.generateMagic(bc2ir,gc,meth);
  }
  return true;
}","/** 
 * ""Semantic inlining"" of methods of the VM_Magic class. Based on the methodName, generate a sequence of opt instructions that implement the magic, updating the expression stack as necessary.
 * @param bc2ir the bc2ir object that is generating the ir containing this magic
 * @param gc must be bc2ir.gc
 * @param meth the VM_Method that is the magic method
 */
static boolean generateMagic(OPT_BC2IR bc2ir,OPT_GenerationContext gc,VM_MethodReference meth) throws OPT_MagicNotImplementedException {
  if (gc.method.hasNoInlinePragma())   gc.allocFrame=true;
  bc2ir.markBBUnsafeForScheduling();
  VM_Atom methodName=meth.getName();
  boolean address=(meth.getType() == VM_TypeReference.Address);
  VM_TypeReference[] types=meth.getParameterTypes();
  VM_TypeReference returnType=meth.getReturnType();
  if (address && isLoad(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(returnType);
    bc2ir.appendInstruction(Load.create(getOperator(returnType,LOAD_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U(),returnType);
  }
 else   if (address && isPrepare(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(returnType);
    bc2ir.appendInstruction(Prepare.create(getOperator(returnType,PREPARE_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U(),returnType);
  }
 else   if (address && methodName == VM_MagicNames.attempt) {
    VM_TypeReference attemptType=types[0];
    OPT_Operand offset=(types.length == 2) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(getOperator(attemptType,ATTEMPT_OP),test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U(),returnType);
  }
 else   if (address && methodName == VM_MagicNames.store) {
    VM_TypeReference storeType=types[0];
    OPT_Operand offset=(types.length == 1) ? new OPT_AddressConstantOperand(Address.zero()) : bc2ir.popAddress();
    OPT_Operand val=bc2ir.pop(storeType);
    OPT_Operand base=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(getOperator(storeType,STORE_OP),val,base,offset,null));
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    OPT_RegisterOperand rop=gc.temps.makePROp();
    bc2ir.markGuardlessNonNull(rop);
    bc2ir.push(rop);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    OPT_Operand val=bc2ir.popRef();
    if (val instanceof OPT_RegisterOperand) {
      bc2ir.appendInstruction(Move.create(REF_MOVE,gc.temps.makePROp(),val));
    }
 else {
      String msg=""String_Node_Str"";
      throw OPT_MagicNotImplementedException.UNEXPECTED(msg);
    }
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    OPT_Instruction s=bc2ir.generateAnewarray(meth.getType().getArrayElementType());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    OPT_Operand op1=bc2ir.pop();
    bc2ir.clearCurrentGuard();
    if (bc2ir.do_NullCheck(op1))     return true;
    OPT_RegisterOperand t=gc.temps.makeTempInt();
    OPT_Instruction s=GuardedUnary.create(ARRAYLENGTH,t,op1,bc2ir.getCurrentGuard());
    bc2ir.push(t.copyD2U());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offsetI=gc.temps.makeTempInt();
    OPT_RegisterOperand offset=gc.temps.makeTempOffset();
    OPT_RegisterOperand result;
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        result=gc.temps.makeTemp(VM_TypeReference.Byte);
        bc2ir.appendInstruction(Load.create(BYTE_LOAD,result,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        result=gc.temps.makeTemp(VM_TypeReference.Int);
        bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
        bc2ir.appendInstruction(Load.create(INT_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      result=gc.temps.makeTemp(elementType);
      bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
      bc2ir.appendInstruction(Load.create(REF_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
    bc2ir.push(result.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offsetI=gc.temps.makeTempInt();
    OPT_RegisterOperand offset=gc.temps.makeTempOffset();
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        bc2ir.appendInstruction(Store.create(BYTE_STORE,val,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
        bc2ir.appendInstruction(Store.create(INT_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      bc2ir.appendInstruction(Binary.create(INT_SHL,offsetI,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Unary.create(INT_2ADDRZerExt,offset,offsetI.copy()));
      bc2ir.appendInstruction(Store.create(REF_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getWordAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setWordAtOffset) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Load.create(LONG_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setLongAtOffset) {
    OPT_Operand val=bc2ir.popLong();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(LONG_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getDoubleAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Load.create(DOUBLE_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setDoubleAtOffset) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(DOUBLE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectArrayAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 4) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,loc));
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Byte);
    bc2ir.appendInstruction(Load.create(BYTE_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(BYTE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Char);
    bc2ir.appendInstruction(Load.create(USHORT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(SHORT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryWord) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryAddress) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryWord) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryAddress) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 3) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_AddressConstantOperand(Offset.zero()),loc));
  }
 else   if (meth.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=meth.getParameterTypes();
    int numArgs=args.length;
    VM_Field ip=VM_Entrypoints.getSysCallField(meth.getName().toString());
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(ip);
    OPT_Instruction call=Call.create(SYSCALL,null,null,mo,null,args.length);
    for (int i=args.length - 1; i >= 0; i--) {
      Call.setParam(call,i,bc2ir.pop(args[i]));
    }
    if (!returnType.isVoidType()) {
      OPT_RegisterOperand op0=gc.temps.makeTemp(returnType);
      Call.setResult(call,op0);
      bc2ir.push(op0.copyD2U(),returnType);
    }
    bc2ir.appendInstruction(call);
  }
 else   if (methodName == VM_MagicNames.threadAsCollectorThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsProcessor) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Processor);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsAddress) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObject) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObjectArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsRegisters) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_BootstrapClassLoader.getBootstrapClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsShortArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ShortArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsStack) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.floatAsIntBits) {
    OPT_Operand val=bc2ir.popFloat();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Unary.create(FLOAT_AS_INT_BITS,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.intBitsAsFloat) {
    OPT_Operand val=bc2ir.popInt();
    OPT_RegisterOperand op0=gc.temps.makeTempFloat();
    bc2ir.appendInstruction(Unary.create(INT_BITS_AS_FLOAT,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.doubleAsLongBits) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Unary.create(DOUBLE_AS_LONG_BITS,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.longBitsAsDouble) {
    OPT_Operand val=bc2ir.popLong();
    OPT_RegisterOperand op0=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Unary.create(LONG_BITS_AS_DOUBLE,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand guard=OPT_BC2IR.getGuard(val);
    if (guard == null) {
      guard=new OPT_TrueGuardOperand();
    }
    OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(GuardedUnary.create(GET_OBJ_TIB,tibPtr,val,guard));
    OPT_RegisterOperand op0;
    VM_TypeReference argType=val.getType();
    if (argType.isArrayType()) {
      op0=gc.temps.makeTemp(VM_TypeReference.VM_Array);
    }
 else {
      if (argType == VM_TypeReference.JavaLangObject || argType == VM_TypeReference.JavaLangCloneable || argType == VM_TypeReference.JavaIoSerializable) {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Type);
      }
 else {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Class);
      }
    }
    bc2ir.markGuardlessNonNull(op0);
    bc2ir.appendInstruction(Unary.create(GET_TYPE_FROM_TIB,op0,tibPtr.copyD2U()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    OPT_Operand val=bc2ir.popRef();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(GuardedUnary.create(ARRAYLENGTH,op0,val,new OPT_TrueGuardOperand()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    OPT_Instruction s=Call.create0(CALL,null,bc2ir.popRef(),null);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    OPT_Operand code=bc2ir.popRef();
    OPT_Operand args=bc2ir.popRef();
    bc2ir.appendInstruction(Call.create1(CALL,null,code,null,args));
  }
 else   if ((methodName == VM_MagicNames.invokeMethodReturningObject) || (methodName == VM_MagicNames.invokeMethodReturningVoid) || (methodName == VM_MagicNames.invokeMethodReturningLong)|| (methodName == VM_MagicNames.invokeMethodReturningDouble)|| (methodName == VM_MagicNames.invokeMethodReturningFloat)|| (methodName == VM_MagicNames.invokeMethodReturningInt)) {
    OPT_Operand spills=bc2ir.popRef();
    OPT_Operand fprs=bc2ir.popRef();
    OPT_Operand gprs=bc2ir.popRef();
    OPT_Operand code=bc2ir.popRef();
    OPT_RegisterOperand res=null;
    if (methodName == VM_MagicNames.invokeMethodReturningObject) {
      res=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
      bc2ir.push(res.copyD2U());
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningLong) {
      res=gc.temps.makeTemp(VM_TypeReference.Long);
      bc2ir.push(res.copyD2U(),VM_TypeReference.Long);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
      res=gc.temps.makeTempDouble();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Double);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
      res=gc.temps.makeTempFloat();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Float);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningInt) {
      res=gc.temps.makeTempInt();
      bc2ir.push(res.copyD2U());
    }
    VM_Field target=VM_Entrypoints.reflectiveMethodInvokerInstructionsField;
    OPT_MethodOperand met=OPT_MethodOperand.STATIC(target);
    OPT_Instruction s=Call.create4(CALL,res,new OPT_AddressConstantOperand(target.getOffset()),met,code,gprs,fprs,spills);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.saveThreadStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_AddressConstantOperand(target.getOffset()),mo,p1));
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    OPT_Operand p2=bc2ir.popRef();
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.threadSwitchInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create2(CALL,null,new OPT_AddressConstantOperand(target.getOffset()),mo,p1,p2));
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    VM_Field target=VM_Entrypoints.restoreHardwareExceptionStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_AddressConstantOperand(target.getOffset()),mo,bc2ir.popRef()));
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Prepare.create(PREPARE_INT,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareObject) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareAddress) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareWord) {
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    OPT_Operand newVal=bc2ir.popInt();
    OPT_Operand oldVal=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_INT,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptObject) {
    OPT_Operand newVal=bc2ir.popRef();
    OPT_Operand oldVal=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptAddress) {
    OPT_Operand newVal=bc2ir.popAddress();
    OPT_Operand oldVal=bc2ir.popAddress();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptWord) {
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand offset=bc2ir.popAddress();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (generatePolymorphicMagic(bc2ir,gc,meth,methodName)) {
    return true;
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Nullary.create(GET_TIME_BASE,op0));
    bc2ir.pushDual(op0.copyD2U());
  }
 else {
    return OPT_GenerateMachineSpecificMagic.generateMagic(bc2ir,gc,meth);
  }
  return true;
}",0.9998305371970851
150071,"/** 
 * Does the passed object have an entry in the table?
 * @param object The object to find an entry for
 * @return True if there is an entry for that object.
 */
public final boolean contains(Word key){
  return !getEntry(key,false).isZero();
}","/** 
 * Does the passed object have an entry in the table?
 * @param key The key to find an entry for
 * @return True if there is an entry for that object.
 */
public final boolean contains(Word key){
  return !getEntry(key,false).isZero();
}",0.963265306122449
150072,"/** 
 * Create a new data table of a specified size.
 * @param space The space to acquire the data structure from.
 * @param logSize The log of the number of table entries. 
 * @param entrySize The size of each entry.
 */
protected SimpleHashtable(RawPageSpace rps,int logSize,Extent es){
  mask=Word.fromInt((1 << logSize) - 1);
  entrySize=es.add(BYTES_IN_WORD);
  size=Extent.fromInt((1 << logSize) * entrySize.toInt());
  base=Address.zero();
  space=rps;
  valid=false;
}","/** 
 * Create a new data table of a specified size.
 * @param rps The space to acquire the data structure from.
 * @param logSize The log of the number of table entries. 
 * @param es The size of each entry.
 */
protected SimpleHashtable(RawPageSpace rps,int logSize,Extent es){
  mask=Word.fromInt((1 << logSize) - 1);
  entrySize=es.add(BYTES_IN_WORD);
  size=Extent.fromInt((1 << logSize) * entrySize.toInt());
  base=Address.zero();
  space=rps;
  valid=false;
}",0.9819724284199364
150073,"/** 
 * Compute the hashtable index for a given object.
 * @param ref The object.
 * @return The index. 
 */
private final int computeHash(Word key) throws InlinePragma {
  return key.rshl(HASH_SHIFT).and(mask).toInt();
}","/** 
 * Compute the hashtable index for a given object.
 * @param key The key.
 * @return The index. 
 */
private final int computeHash(Word key) throws InlinePragma {
  return key.rshl(HASH_SHIFT).and(mask).toInt();
}",0.9658314350797268
150074,"/** 
 * Given a key, return a pointer to the payload.
 * @param entry The entry
 * @return The object reference.
 */
public final Address getPayloadAddress(Word key){
  Address entry=getEntry(key,false);
  if (entry.isZero())   return Address.zero();
  return entry.add(DATA_OFFSET);
}","/** 
 * Given a key, return a pointer to the payload.
 * @param key The key 
 * @return The object reference.
 */
public final Address getPayloadAddress(Word key){
  Address entry=getEntry(key,false);
  if (entry.isZero())   return Address.zero();
  return entry.add(DATA_OFFSET);
}",0.9735449735449736
150075,"/** 
 * Create a new data table of a specified size.
 * @param space The space to acquire the data structure from.
 * @param logSize The log of the number of table entries. 
 */
public SanityDataTable(RawPageSpace rps,int logSize){
  super(rps,logSize,Extent.fromInt(BYTES_IN_WORD));
}","/** 
 * Create a new data table of a specified size.
 * @param rps The space to acquire the data structure from.
 * @param logSize The log of the number of table entries. 
 */
public SanityDataTable(RawPageSpace rps,int logSize){
  super(rps,logSize,Extent.fromInt(BYTES_IN_WORD));
}",0.9859154929577464
150076,"/** 
 * Converts the given HIR to LIR.
 * @param ir IR to convert
 */
static void convert(OPT_IR ir,OPT_Options options){
  for (OPT_Instruction s=ir.firstInstructionInCodeOrder(); s != null; s=s.nextInstructionInCodeOrder()) {
switch (s.getOpcode()) {
case GETSTATIC_opcode:
{
        OPT_LocationOperand loc=GetStatic.getClearLocation(s);
        OPT_RegisterOperand result=GetStatic.getClearResult(s);
        OPT_Operand address=ir.regpool.makeJTOCOp(ir,s);
        OPT_Operand offset=GetStatic.getClearOffset(s);
        Load.mutate(s,OPT_IRTools.getLoadOp(loc.getFieldRef()),result,address,offset,loc);
      }
    break;
case PUTSTATIC_opcode:
{
    OPT_LocationOperand loc=PutStatic.getClearLocation(s);
    OPT_Operand value=PutStatic.getClearValue(s);
    OPT_Operand address=ir.regpool.makeJTOCOp(ir,s);
    OPT_Operand offset=PutStatic.getClearOffset(s);
    Store.mutate(s,OPT_IRTools.getStoreOp(loc.getFieldRef()),value,address,offset,loc);
  }
break;
case PUTFIELD_opcode:
{
OPT_LocationOperand loc=PutField.getClearLocation(s);
OPT_Operand value=PutField.getClearValue(s);
OPT_Operand address=PutField.getClearRef(s);
OPT_Operand offset=PutField.getClearOffset(s);
Store.mutate(s,OPT_IRTools.getStoreOp(loc.getFieldRef()),value,address,offset,loc,PutField.getClearGuard(s));
}
break;
case GETFIELD_opcode:
{
OPT_LocationOperand loc=GetField.getClearLocation(s);
OPT_RegisterOperand result=GetField.getClearResult(s);
OPT_Operand address=GetField.getClearRef(s);
OPT_Operand offset=GetField.getClearOffset(s);
Load.mutate(s,OPT_IRTools.getLoadOp(loc.getFieldRef()),result,address,offset,loc,GetField.getClearGuard(s));
}
break;
case INT_ALOAD_opcode:
doArrayLoad(s,ir,INT_LOAD,2);
break;
case LONG_ALOAD_opcode:
doArrayLoad(s,ir,LONG_LOAD,3);
break;
case FLOAT_ALOAD_opcode:
doArrayLoad(s,ir,FLOAT_LOAD,2);
break;
case DOUBLE_ALOAD_opcode:
doArrayLoad(s,ir,DOUBLE_LOAD,3);
break;
case REF_ALOAD_opcode:
doArrayLoad(s,ir,REF_LOAD,LOG_BYTES_IN_ADDRESS);
break;
case BYTE_ALOAD_opcode:
doArrayLoad(s,ir,BYTE_LOAD,0);
break;
case UBYTE_ALOAD_opcode:
doArrayLoad(s,ir,UBYTE_LOAD,0);
break;
case USHORT_ALOAD_opcode:
doArrayLoad(s,ir,USHORT_LOAD,1);
break;
case SHORT_ALOAD_opcode:
doArrayLoad(s,ir,SHORT_LOAD,1);
break;
case INT_ASTORE_opcode:
doArrayStore(s,ir,INT_STORE,2);
break;
case LONG_ASTORE_opcode:
doArrayStore(s,ir,LONG_STORE,3);
break;
case FLOAT_ASTORE_opcode:
doArrayStore(s,ir,FLOAT_STORE,2);
break;
case DOUBLE_ASTORE_opcode:
doArrayStore(s,ir,DOUBLE_STORE,3);
break;
case REF_ASTORE_opcode:
doArrayStore(s,ir,REF_STORE,LOG_BYTES_IN_ADDRESS);
break;
case BYTE_ASTORE_opcode:
doArrayStore(s,ir,BYTE_STORE,0);
break;
case SHORT_ASTORE_opcode:
doArrayStore(s,ir,SHORT_STORE,1);
break;
case CALL_opcode:
s=callHelper(s,ir);
break;
case SYSCALL_opcode:
OPT_CallingConvention.expandSysCall(s,ir);
break;
case TABLESWITCH_opcode:
s=tableswitch(s,ir);
break;
case LOOKUPSWITCH_opcode:
s=lookup(s,ir);
break;
case OBJARRAY_STORE_CHECK_opcode:
s=OPT_DynamicTypeCheckExpansion.arrayStoreCheck(s,ir,true);
break;
case OBJARRAY_STORE_CHECK_NOTNULL_opcode:
s=OPT_DynamicTypeCheckExpansion.arrayStoreCheck(s,ir,false);
break;
case CHECKCAST_opcode:
case CHECKCAST_UNRESOLVED_opcode:
s=OPT_DynamicTypeCheckExpansion.checkcast(s,ir);
break;
case CHECKCAST_NOTNULL_opcode:
s=OPT_DynamicTypeCheckExpansion.checkcastNotNull(s,ir);
break;
case MUST_IMPLEMENT_INTERFACE_opcode:
s=OPT_DynamicTypeCheckExpansion.mustImplementInterface(s,ir);
break;
case IG_CLASS_TEST_opcode:
IfCmp.mutate(s,REF_IFCMP,null,getTIB(s,ir,InlineGuard.getClearValue(s),InlineGuard.getClearGuard(s)),getTIB(s,ir,InlineGuard.getGoal(s).asType()),OPT_ConditionOperand.NOT_EQUAL(),InlineGuard.getClearTarget(s),InlineGuard.getClearBranchProfile(s));
break;
case IG_METHOD_TEST_opcode:
{
OPT_MethodOperand methOp=InlineGuard.getClearGoal(s).asMethod();
OPT_RegisterOperand t1=getTIB(s,ir,InlineGuard.getClearValue(s),InlineGuard.getClearGuard(s));
OPT_Operand t2=getTIB(s,ir,methOp.getTarget().getDeclaringClass());
IfCmp.mutate(s,REF_IFCMP,null,getInstanceMethod(s,ir,t1,methOp.getTarget()),getInstanceMethod(s,ir,t2,methOp.getTarget()),OPT_ConditionOperand.NOT_EQUAL(),InlineGuard.getClearTarget(s),InlineGuard.getClearBranchProfile(s));
break;
}
case INSTANCEOF_opcode:
case INSTANCEOF_UNRESOLVED_opcode:
s=OPT_DynamicTypeCheckExpansion.instanceOf(s,ir);
break;
case INSTANCEOF_NOTNULL_opcode:
s=OPT_DynamicTypeCheckExpansion.instanceOfNotNull(s,ir);
break;
case INT_ZERO_CHECK_opcode:
{
TrapIf.mutate(s,TRAP_IF,ZeroCheck.getClearGuardResult(s),ZeroCheck.getClearValue(s),IC(0),OPT_ConditionOperand.EQUAL(),OPT_TrapCodeOperand.DivByZero());
}
break;
case LONG_ZERO_CHECK_opcode:
{
TrapIf.mutate(s,TRAP_IF,ZeroCheck.getClearGuardResult(s),ZeroCheck.getClearValue(s),IC(0),OPT_ConditionOperand.EQUAL(),OPT_TrapCodeOperand.DivByZero());
}
break;
case BOUNDS_CHECK_opcode:
{
OPT_RegisterOperand array_length=InsertGuardedUnary(s,ir,ARRAYLENGTH,VM_TypeReference.Int,BoundsCheck.getClearRef(s),BoundsCheck.getClearGuard(s));
TrapIf.mutate(s,TRAP_IF,BoundsCheck.getClearGuardResult(s),array_length.copyD2U(),BoundsCheck.getClearIndex(s),OPT_ConditionOperand.LOWER_EQUAL(),OPT_TrapCodeOperand.ArrayBounds());
}
break;
case GET_CLASS_OBJECT_opcode:
{
OPT_Operand TIB=getTIB(s,ir,(OPT_TypeOperand)Unary.getClearVal(s));
OPT_RegisterOperand type=ir.regpool.makeTemp(VM_TypeReference.VM_Type);
s.insertBefore(Unary.create(GET_TYPE_FROM_TIB,type,TIB));
Load.mutate(s,REF_LOAD,Unary.getClearResult(s),type.copyD2U(),AC(VM_Entrypoints.classForTypeField.getOffset()),null);
}
break;
case RESOLVE_MEMBER_opcode:
s=resolveMember(s,ir);
break;
default :
break;
}
}
}","/** 
 * Converts the given HIR to LIR.
 * @param ir IR to convert
 */
static void convert(OPT_IR ir,OPT_Options options){
  boolean didArrayStoreCheck=false;
  for (OPT_Instruction s=ir.firstInstructionInCodeOrder(); s != null; s=s.nextInstructionInCodeOrder()) {
switch (s.getOpcode()) {
case GETSTATIC_opcode:
{
        OPT_LocationOperand loc=GetStatic.getClearLocation(s);
        OPT_RegisterOperand result=GetStatic.getClearResult(s);
        OPT_Operand address=ir.regpool.makeJTOCOp(ir,s);
        OPT_Operand offset=GetStatic.getClearOffset(s);
        Load.mutate(s,OPT_IRTools.getLoadOp(loc.getFieldRef()),result,address,offset,loc);
      }
    break;
case PUTSTATIC_opcode:
{
    OPT_LocationOperand loc=PutStatic.getClearLocation(s);
    OPT_Operand value=PutStatic.getClearValue(s);
    OPT_Operand address=ir.regpool.makeJTOCOp(ir,s);
    OPT_Operand offset=PutStatic.getClearOffset(s);
    Store.mutate(s,OPT_IRTools.getStoreOp(loc.getFieldRef()),value,address,offset,loc);
  }
break;
case PUTFIELD_opcode:
{
OPT_LocationOperand loc=PutField.getClearLocation(s);
OPT_Operand value=PutField.getClearValue(s);
OPT_Operand address=PutField.getClearRef(s);
OPT_Operand offset=PutField.getClearOffset(s);
Store.mutate(s,OPT_IRTools.getStoreOp(loc.getFieldRef()),value,address,offset,loc,PutField.getClearGuard(s));
}
break;
case GETFIELD_opcode:
{
OPT_LocationOperand loc=GetField.getClearLocation(s);
OPT_RegisterOperand result=GetField.getClearResult(s);
OPT_Operand address=GetField.getClearRef(s);
OPT_Operand offset=GetField.getClearOffset(s);
Load.mutate(s,OPT_IRTools.getLoadOp(loc.getFieldRef()),result,address,offset,loc,GetField.getClearGuard(s));
}
break;
case INT_ALOAD_opcode:
doArrayLoad(s,ir,INT_LOAD,2);
break;
case LONG_ALOAD_opcode:
doArrayLoad(s,ir,LONG_LOAD,3);
break;
case FLOAT_ALOAD_opcode:
doArrayLoad(s,ir,FLOAT_LOAD,2);
break;
case DOUBLE_ALOAD_opcode:
doArrayLoad(s,ir,DOUBLE_LOAD,3);
break;
case REF_ALOAD_opcode:
doArrayLoad(s,ir,REF_LOAD,LOG_BYTES_IN_ADDRESS);
break;
case BYTE_ALOAD_opcode:
doArrayLoad(s,ir,BYTE_LOAD,0);
break;
case UBYTE_ALOAD_opcode:
doArrayLoad(s,ir,UBYTE_LOAD,0);
break;
case USHORT_ALOAD_opcode:
doArrayLoad(s,ir,USHORT_LOAD,1);
break;
case SHORT_ALOAD_opcode:
doArrayLoad(s,ir,SHORT_LOAD,1);
break;
case INT_ASTORE_opcode:
doArrayStore(s,ir,INT_STORE,2);
break;
case LONG_ASTORE_opcode:
doArrayStore(s,ir,LONG_STORE,3);
break;
case FLOAT_ASTORE_opcode:
doArrayStore(s,ir,FLOAT_STORE,2);
break;
case DOUBLE_ASTORE_opcode:
doArrayStore(s,ir,DOUBLE_STORE,3);
break;
case REF_ASTORE_opcode:
doArrayStore(s,ir,REF_STORE,LOG_BYTES_IN_ADDRESS);
break;
case BYTE_ASTORE_opcode:
doArrayStore(s,ir,BYTE_STORE,0);
break;
case SHORT_ASTORE_opcode:
doArrayStore(s,ir,SHORT_STORE,1);
break;
case CALL_opcode:
s=callHelper(s,ir);
break;
case SYSCALL_opcode:
OPT_CallingConvention.expandSysCall(s,ir);
break;
case TABLESWITCH_opcode:
s=tableswitch(s,ir);
break;
case LOOKUPSWITCH_opcode:
s=lookup(s,ir);
break;
case OBJARRAY_STORE_CHECK_opcode:
s=OPT_DynamicTypeCheckExpansion.arrayStoreCheck(s,ir,true);
didArrayStoreCheck=true;
break;
case OBJARRAY_STORE_CHECK_NOTNULL_opcode:
s=OPT_DynamicTypeCheckExpansion.arrayStoreCheck(s,ir,false);
didArrayStoreCheck=true;
break;
case CHECKCAST_opcode:
case CHECKCAST_UNRESOLVED_opcode:
s=OPT_DynamicTypeCheckExpansion.checkcast(s,ir);
break;
case CHECKCAST_NOTNULL_opcode:
s=OPT_DynamicTypeCheckExpansion.checkcastNotNull(s,ir);
break;
case MUST_IMPLEMENT_INTERFACE_opcode:
s=OPT_DynamicTypeCheckExpansion.mustImplementInterface(s,ir);
break;
case IG_CLASS_TEST_opcode:
IfCmp.mutate(s,REF_IFCMP,null,getTIB(s,ir,InlineGuard.getClearValue(s),InlineGuard.getClearGuard(s)),getTIB(s,ir,InlineGuard.getGoal(s).asType()),OPT_ConditionOperand.NOT_EQUAL(),InlineGuard.getClearTarget(s),InlineGuard.getClearBranchProfile(s));
break;
case IG_METHOD_TEST_opcode:
{
OPT_MethodOperand methOp=InlineGuard.getClearGoal(s).asMethod();
OPT_RegisterOperand t1=getTIB(s,ir,InlineGuard.getClearValue(s),InlineGuard.getClearGuard(s));
OPT_Operand t2=getTIB(s,ir,methOp.getTarget().getDeclaringClass());
IfCmp.mutate(s,REF_IFCMP,null,getInstanceMethod(s,ir,t1,methOp.getTarget()),getInstanceMethod(s,ir,t2,methOp.getTarget()),OPT_ConditionOperand.NOT_EQUAL(),InlineGuard.getClearTarget(s),InlineGuard.getClearBranchProfile(s));
break;
}
case INSTANCEOF_opcode:
case INSTANCEOF_UNRESOLVED_opcode:
s=OPT_DynamicTypeCheckExpansion.instanceOf(s,ir);
break;
case INSTANCEOF_NOTNULL_opcode:
s=OPT_DynamicTypeCheckExpansion.instanceOfNotNull(s,ir);
break;
case INT_ZERO_CHECK_opcode:
{
TrapIf.mutate(s,TRAP_IF,ZeroCheck.getClearGuardResult(s),ZeroCheck.getClearValue(s),IC(0),OPT_ConditionOperand.EQUAL(),OPT_TrapCodeOperand.DivByZero());
}
break;
case LONG_ZERO_CHECK_opcode:
{
TrapIf.mutate(s,TRAP_IF,ZeroCheck.getClearGuardResult(s),ZeroCheck.getClearValue(s),IC(0),OPT_ConditionOperand.EQUAL(),OPT_TrapCodeOperand.DivByZero());
}
break;
case BOUNDS_CHECK_opcode:
{
OPT_RegisterOperand array_length=InsertGuardedUnary(s,ir,ARRAYLENGTH,VM_TypeReference.Int,BoundsCheck.getClearRef(s),BoundsCheck.getClearGuard(s));
TrapIf.mutate(s,TRAP_IF,BoundsCheck.getClearGuardResult(s),array_length.copyD2U(),BoundsCheck.getClearIndex(s),OPT_ConditionOperand.LOWER_EQUAL(),OPT_TrapCodeOperand.ArrayBounds());
}
break;
case GET_CLASS_OBJECT_opcode:
{
OPT_Operand TIB=getTIB(s,ir,(OPT_TypeOperand)Unary.getClearVal(s));
OPT_RegisterOperand type=ir.regpool.makeTemp(VM_TypeReference.VM_Type);
s.insertBefore(Unary.create(GET_TYPE_FROM_TIB,type,TIB));
Load.mutate(s,REF_LOAD,Unary.getClearResult(s),type.copyD2U(),AC(VM_Entrypoints.classForTypeField.getOffset()),null);
}
break;
case RESOLVE_MEMBER_opcode:
s=resolveMember(s,ir);
break;
default :
break;
}
}
if (didArrayStoreCheck) {
branchOpts.perform(ir,true);
}
}",0.987448433248486
150077,"/** 
 * Expand an instanceof instruction into the LIR sequence that implements  the dynamic type check.  Ref is known to never contain a null ptr at  runtime.
 * @param s an INSTANCEOF_NOTNULL instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction instanceOfNotNull(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand result=InstanceOf.getClearResult(s);
  VM_TypeReference LHStype=InstanceOf.getType(s).getTypeRef();
  OPT_Operand ref=InstanceOf.getClearRef(s);
  OPT_Operand guard=InstanceOf.getClearGuard(s);
  OPT_Instruction next=s.nextInstructionInCodeOrder();
  if (next.operator() == INT_IFCMP && IfCmp.getVal1(next) instanceof OPT_RegisterOperand && result.similar(IfCmp.getVal1(next))) {
    OPT_Operand val2=IfCmp.getVal2(next);
    if (VM.VerifyAssertions)     VM._assert(val2.isIntConstant());
    int ival2=((OPT_IntConstantOperand)val2).value;
    OPT_ConditionOperand cond=IfCmp.getCond(next);
    boolean branchCondition=(((ival2 == 0) && (cond.isNOT_EQUAL() || cond.isLESS_EQUAL())) || ((ival2 == 1) && (cond.isEQUAL() || cond.isGREATER_EQUAL())));
    OPT_BasicBlock branchBB=next.getBranchTarget();
    OPT_RegisterOperand oldGuard=IfCmp.getGuardResult(next);
    next.remove();
    OPT_BasicBlock fallThroughBB=fallThroughBB(s,ir);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    if (branchCondition) {
      return generateBranchingTypeCheck(s,ir,ref.copy(),LHStype,RHStib,branchBB,fallThroughBB,oldGuard,IfCmp.getClearBranchProfile(next).flip());
    }
 else {
      return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,fallThroughBB,branchBB,oldGuard,IfCmp.getClearBranchProfile(next));
    }
  }
 else {
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    return generateValueProducingTypeCheck(s,ir,ref.copy(),LHStype,RHStib,result);
  }
}","/** 
 * Expand an instanceof instruction into the LIR sequence that implements  the dynamic type check.  Ref is known to never contain a null ptr at  runtime.
 * @param s an INSTANCEOF_NOTNULL instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction instanceOfNotNull(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand result=InstanceOf.getClearResult(s);
  VM_TypeReference LHStype=InstanceOf.getType(s).getTypeRef();
  OPT_Operand ref=InstanceOf.getClearRef(s);
  OPT_Operand guard=InstanceOf.getClearGuard(s);
  OPT_Instruction next=s.nextInstructionInCodeOrder();
  if (next.operator() == INT_IFCMP && IfCmp.getVal1(next) instanceof OPT_RegisterOperand && result.similar(IfCmp.getVal1(next))) {
    OPT_Operand val2=IfCmp.getVal2(next);
    if (VM.VerifyAssertions)     VM._assert(val2.isIntConstant());
    int ival2=((OPT_IntConstantOperand)val2).value;
    OPT_ConditionOperand cond=IfCmp.getCond(next);
    boolean branchCondition=(((ival2 == 0) && (cond.isNOT_EQUAL() || cond.isLESS_EQUAL())) || ((ival2 == 1) && (cond.isEQUAL() || cond.isGREATER_EQUAL())));
    OPT_BasicBlock branchBB=next.getBranchTarget();
    OPT_RegisterOperand oldGuard=IfCmp.getGuardResult(next);
    next.remove();
    OPT_BasicBlock fallThroughBB=fallThroughBB(s,ir);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    if (branchCondition) {
      return generateBranchingTypeCheck(s,ir,ref.copy(),LHStype,RHStib,branchBB,fallThroughBB,oldGuard,IfCmp.getClearBranchProfile(next).flip());
    }
 else {
      return generateBranchingTypeCheck(s,ir,ref.copy(),LHStype,RHStib,fallThroughBB,branchBB,oldGuard,IfCmp.getClearBranchProfile(next));
    }
  }
 else {
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    return generateValueProducingTypeCheck(s,ir,ref.copy(),LHStype,RHStib,result);
  }
}",0.9981456953642384
150078,"/** 
 * Expand an object array store check into the LIR sequence that  implements it.
 * @param s an OBJARRAY_STORE_CHECK instruction to expand 
 * @param ir the enclosing OPT_IR
 * @param couldBeNull is it possible that the element being stored is null?
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction arrayStoreCheck(OPT_Instruction s,OPT_IR ir,boolean couldBeNull){
  OPT_RegisterOperand guardResult=StoreCheck.getClearGuardResult(s);
  OPT_Operand arrayRef=StoreCheck.getClearRef(s);
  OPT_Operand elemRef=StoreCheck.getClearVal(s);
  OPT_Operand guard=StoreCheck.getClearGuard(s);
  if (elemRef instanceof OPT_NullConstantOperand) {
    OPT_Instruction continueAt=s.prevInstructionInCodeOrder();
    s.remove();
    return continueAt;
  }
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock contBlock=myBlock.splitNodeAt(s,ir);
  OPT_BasicBlock trapBlock=myBlock.createSubBlock(s.bcIndex,ir,.0001f);
  OPT_BasicBlock curBlock=myBlock;
  s.remove();
  OPT_Instruction trap=Trap.create(TRAP,null,OPT_TrapCodeOperand.StoreCheck());
  trap.copyPosition(s);
  trapBlock.appendInstruction(trap);
  ir.cfg.addLastInCodeOrder(trapBlock);
  OPT_Operand rhsGuard=guard;
  if (couldBeNull) {
    rhsGuard=ir.regpool.makeTempValidation();
    contBlock.prependInstruction(Binary.create(GUARD_COMBINE,guardResult,guardResult.copyRO(),rhsGuard.copy()));
    curBlock.appendInstruction(IfCmp.create(REF_IFCMP,rhsGuard.asRegister(),elemRef,new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),contBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
    curBlock.insertOut(contBlock);
    curBlock=advanceBlock(s.bcIndex,curBlock,ir);
  }
  VM_Type compType=arrayRef.getType().peekResolvedType();
  if (compType != null && !compType.isJavaLangObjectType()) {
    if (compType.getDimensionality() == 1) {
      VM_Class etc=(VM_Class)compType.asArray().getElementType();
      if (etc.isResolved() && etc.isFinal()) {
        if (VM.VerifyAssertions)         VM._assert(!etc.isInterface());
        OPT_RegisterOperand rhsTIB=getTIB(curBlock.lastInstruction(),ir,elemRef.copy(),rhsGuard.copy());
        OPT_Operand etTIB=getTIB(curBlock.lastInstruction(),ir,etc);
        curBlock.appendInstruction(IfCmp.create(REF_IFCMP,guardResult.copyRO(),rhsTIB,etTIB,OPT_ConditionOperand.NOT_EQUAL(),trapBlock.makeJumpTarget(),OPT_BranchProfileOperand.never()));
        curBlock.insertOut(trapBlock);
        curBlock.insertOut(contBlock);
        ir.cfg.linkInCodeOrder(curBlock,contBlock);
        return curBlock.lastInstruction();
      }
    }
    OPT_RegisterOperand lhsTIB=getTIB(curBlock.lastInstruction(),ir,arrayRef,guard);
    if (((arrayRef instanceof OPT_RegisterOperand) && ((OPT_RegisterOperand)arrayRef).isDeclaredType()) || compType == VM_Type.JavaLangObjectArrayType) {
      OPT_Operand declTIB=getTIB(curBlock.lastInstruction(),ir,compType);
      curBlock.appendInstruction(IfCmp.create(REF_IFCMP,guardResult.copyRO(),declTIB,lhsTIB,OPT_ConditionOperand.EQUAL(),contBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
      curBlock.insertOut(contBlock);
      curBlock=advanceBlock(s.bcIndex,curBlock,ir);
    }
    OPT_RegisterOperand rhsTIB=getTIB(curBlock.lastInstruction(),ir,elemRef.copy(),rhsGuard.copy());
    OPT_RegisterOperand lhsElemTIB=InsertUnary(curBlock.lastInstruction(),ir,GET_ARRAY_ELEMENT_TIB_FROM_TIB,VM_TypeReference.JavaLangObjectArray,lhsTIB.copyRO());
    curBlock.appendInstruction(IfCmp.create(REF_IFCMP,guardResult.copyRO(),rhsTIB,lhsElemTIB,OPT_ConditionOperand.EQUAL(),contBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
    curBlock.insertOut(contBlock);
    curBlock=advanceBlock(s.bcIndex,curBlock,ir);
    if (compType.getDimensionality() == 1) {
      VM_Class etc=(VM_Class)compType.asArray().getElementType();
      if (etc.isResolved() && !etc.isInterface() && !etc.isJavaLangObjectType()) {
        OPT_RegisterOperand lhsElemType=InsertUnary(curBlock.lastInstruction(),ir,GET_TYPE_FROM_TIB,VM_TypeReference.VM_Type,lhsElemTIB.copyU2U());
        OPT_RegisterOperand rhsSuperclassIds=InsertUnary(curBlock.lastInstruction(),ir,GET_SUPERCLASS_IDS_FROM_TIB,VM_TypeReference.ShortArray,rhsTIB.copyD2U());
        OPT_RegisterOperand lhsElemDepth=getField(curBlock.lastInstruction(),ir,lhsElemType,VM_Entrypoints.depthField,TG());
        OPT_RegisterOperand rhsSuperclassIdsLength=InsertGuardedUnary(curBlock.lastInstruction(),ir,ARRAYLENGTH,VM_TypeReference.Int,rhsSuperclassIds.copyD2U(),TG());
        curBlock.appendInstruction(IfCmp.create(INT_IFCMP,guardResult.copyRO(),lhsElemDepth,rhsSuperclassIdsLength,OPT_ConditionOperand.GREATER_EQUAL(),trapBlock.makeJumpTarget(),OPT_BranchProfileOperand.never()));
        curBlock.insertOut(trapBlock);
        curBlock=advanceBlock(s.bcIndex,curBlock,ir);
        OPT_RegisterOperand lhsElemId=getField(curBlock.lastInstruction(),ir,lhsElemType.copyD2U(),VM_Entrypoints.idField,TG());
        OPT_RegisterOperand refCandidate=ir.regpool.makeTemp(VM_TypeReference.Short);
        OPT_LocationOperand loc=new OPT_LocationOperand(VM_TypeReference.Short);
        if (LOWER_ARRAY_ACCESS) {
          OPT_RegisterOperand lhsDepthOffset=InsertBinary(curBlock.lastInstruction(),ir,INT_SHL,VM_TypeReference.Int,lhsElemDepth.copyD2U(),IC(1));
          lhsDepthOffset=InsertUnary(curBlock.lastInstruction(),ir,INT_2ADDRZerExt,VM_TypeReference.Offset,lhsDepthOffset.copy());
          curBlock.appendInstruction(Load.create(USHORT_LOAD,refCandidate,rhsSuperclassIds,lhsDepthOffset,loc,TG()));
        }
 else {
          curBlock.appendInstruction(ALoad.create(USHORT_ALOAD,refCandidate,rhsSuperclassIds,lhsElemDepth,loc,TG()));
        }
        curBlock.appendInstruction(IfCmp.create(INT_IFCMP,guardResult.copyRO(),refCandidate.copyD2U(),lhsElemId,OPT_ConditionOperand.NOT_EQUAL(),trapBlock.makeJumpTarget(),OPT_BranchProfileOperand.never()));
        curBlock.insertOut(trapBlock);
        curBlock.insertOut(contBlock);
        ir.cfg.linkInCodeOrder(curBlock,contBlock);
        return curBlock.lastInstruction();
      }
    }
  }
  VM_Method target=VM_Entrypoints.checkstoreMethod;
  OPT_Instruction call=Call.create2(CALL,null,AC(target.getOffset()),OPT_MethodOperand.STATIC(target),rhsGuard.copy(),arrayRef.copy(),elemRef.copy());
  call.copyPosition(s);
  curBlock.appendInstruction(call);
  curBlock.insertOut(contBlock);
  ir.cfg.linkInCodeOrder(curBlock,contBlock);
  return callHelper(call,ir);
}","/** 
 * Expand an object array store check into the LIR sequence that  implements it.
 * @param s an OBJARRAY_STORE_CHECK instruction to expand 
 * @param ir the enclosing OPT_IR
 * @param couldBeNull is it possible that the element being stored is null?
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction arrayStoreCheck(OPT_Instruction s,OPT_IR ir,boolean couldBeNull){
  OPT_RegisterOperand guardResult=StoreCheck.getClearGuardResult(s);
  OPT_Operand arrayRef=StoreCheck.getClearRef(s);
  OPT_Operand elemRef=StoreCheck.getClearVal(s);
  OPT_Operand guard=StoreCheck.getClearGuard(s);
  if (elemRef instanceof OPT_NullConstantOperand) {
    OPT_Instruction continueAt=s.prevInstructionInCodeOrder();
    s.remove();
    return continueAt;
  }
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock contBlock=myBlock.splitNodeAt(s,ir);
  OPT_BasicBlock trapBlock=myBlock.createSubBlock(s.bcIndex,ir,.0001f);
  OPT_BasicBlock curBlock=myBlock;
  s.remove();
  OPT_Instruction trap=Trap.create(TRAP,null,OPT_TrapCodeOperand.StoreCheck());
  trap.copyPosition(s);
  trapBlock.appendInstruction(trap);
  ir.cfg.addLastInCodeOrder(trapBlock);
  OPT_Operand rhsGuard=guard;
  if (couldBeNull) {
    rhsGuard=ir.regpool.makeTempValidation();
    contBlock.prependInstruction(Binary.create(GUARD_COMBINE,guardResult,guardResult.copyRO(),rhsGuard.copy()));
    curBlock.appendInstruction(IfCmp.create(REF_IFCMP,rhsGuard.asRegister(),elemRef,new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),contBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
    curBlock.insertOut(contBlock);
    curBlock=advanceBlock(s.bcIndex,curBlock,ir);
  }
  VM_Type compType=arrayRef.getType().peekResolvedType();
  if (compType != null && !compType.isJavaLangObjectType()) {
    if (compType.getDimensionality() == 1) {
      VM_Class etc=(VM_Class)compType.asArray().getElementType();
      if (etc.isResolved() && etc.isFinal()) {
        if (VM.VerifyAssertions)         VM._assert(!etc.isInterface());
        OPT_RegisterOperand rhsTIB=getTIB(curBlock.lastInstruction(),ir,elemRef.copy(),rhsGuard.copy());
        OPT_Operand etTIB=getTIB(curBlock.lastInstruction(),ir,etc);
        curBlock.appendInstruction(IfCmp.create(REF_IFCMP,guardResult.copyRO(),rhsTIB,etTIB,OPT_ConditionOperand.NOT_EQUAL(),trapBlock.makeJumpTarget(),OPT_BranchProfileOperand.never()));
        curBlock.insertOut(trapBlock);
        curBlock.insertOut(contBlock);
        ir.cfg.linkInCodeOrder(curBlock,contBlock);
        return curBlock.lastInstruction();
      }
    }
    OPT_RegisterOperand lhsTIB=getTIB(curBlock.lastInstruction(),ir,arrayRef,guard);
    if (((arrayRef instanceof OPT_RegisterOperand) && ((OPT_RegisterOperand)arrayRef).isDeclaredType()) || compType == VM_Type.JavaLangObjectArrayType) {
      OPT_Operand declTIB=getTIB(curBlock.lastInstruction(),ir,compType);
      curBlock.appendInstruction(IfCmp.create(REF_IFCMP,guardResult.copyRO(),declTIB,lhsTIB,OPT_ConditionOperand.EQUAL(),contBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
      curBlock.insertOut(contBlock);
      curBlock=advanceBlock(s.bcIndex,curBlock,ir);
    }
    OPT_RegisterOperand rhsTIB=getTIB(curBlock.lastInstruction(),ir,elemRef.copy(),rhsGuard.copy());
    OPT_RegisterOperand lhsElemTIB=InsertUnary(curBlock.lastInstruction(),ir,GET_ARRAY_ELEMENT_TIB_FROM_TIB,VM_TypeReference.JavaLangObjectArray,lhsTIB.copyRO());
    curBlock.appendInstruction(IfCmp.create(REF_IFCMP,guardResult.copyRO(),rhsTIB,lhsElemTIB,OPT_ConditionOperand.EQUAL(),contBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
    curBlock.insertOut(contBlock);
    curBlock=advanceBlock(s.bcIndex,curBlock,ir);
    if (compType.getDimensionality() == 1) {
      VM_Class etc=(VM_Class)compType.asArray().getElementType();
      if (etc.isResolved() && !etc.isInterface() && !etc.isJavaLangObjectType()) {
        OPT_RegisterOperand lhsElemType=InsertUnary(curBlock.lastInstruction(),ir,GET_TYPE_FROM_TIB,VM_TypeReference.VM_Type,lhsElemTIB.copyU2U());
        OPT_RegisterOperand rhsSuperclassIds=InsertUnary(curBlock.lastInstruction(),ir,GET_SUPERCLASS_IDS_FROM_TIB,VM_TypeReference.ShortArray,rhsTIB.copyD2U());
        OPT_RegisterOperand lhsElemDepth=getField(curBlock.lastInstruction(),ir,lhsElemType,VM_Entrypoints.depthField,TG());
        OPT_RegisterOperand rhsSuperclassIdsLength=InsertGuardedUnary(curBlock.lastInstruction(),ir,ARRAYLENGTH,VM_TypeReference.Int,rhsSuperclassIds.copyD2U(),TG());
        curBlock.appendInstruction(IfCmp.create(INT_IFCMP,guardResult.copyRO(),lhsElemDepth,rhsSuperclassIdsLength,OPT_ConditionOperand.GREATER_EQUAL(),trapBlock.makeJumpTarget(),OPT_BranchProfileOperand.never()));
        curBlock.insertOut(trapBlock);
        curBlock=advanceBlock(s.bcIndex,curBlock,ir);
        OPT_RegisterOperand lhsElemId=getField(curBlock.lastInstruction(),ir,lhsElemType.copyD2U(),VM_Entrypoints.idField,TG());
        OPT_RegisterOperand refCandidate=ir.regpool.makeTemp(VM_TypeReference.Short);
        OPT_LocationOperand loc=new OPT_LocationOperand(VM_TypeReference.Short);
        if (LOWER_ARRAY_ACCESS) {
          OPT_RegisterOperand lhsDepthOffset=InsertBinary(curBlock.lastInstruction(),ir,INT_SHL,VM_TypeReference.Int,lhsElemDepth.copyD2U(),IC(1));
          lhsDepthOffset=InsertUnary(curBlock.lastInstruction(),ir,INT_2ADDRZerExt,VM_TypeReference.Offset,lhsDepthOffset.copy());
          curBlock.appendInstruction(Load.create(USHORT_LOAD,refCandidate,rhsSuperclassIds,lhsDepthOffset,loc,TG()));
        }
 else {
          curBlock.appendInstruction(ALoad.create(USHORT_ALOAD,refCandidate,rhsSuperclassIds,lhsElemDepth.copyRO(),loc,TG()));
        }
        curBlock.appendInstruction(IfCmp.create(INT_IFCMP,guardResult.copyRO(),refCandidate.copyD2U(),lhsElemId,OPT_ConditionOperand.NOT_EQUAL(),trapBlock.makeJumpTarget(),OPT_BranchProfileOperand.never()));
        curBlock.insertOut(trapBlock);
        curBlock.insertOut(contBlock);
        ir.cfg.linkInCodeOrder(curBlock,contBlock);
        return curBlock.lastInstruction();
      }
    }
  }
  VM_Method target=VM_Entrypoints.checkstoreMethod;
  OPT_Instruction call=Call.create2(CALL,null,AC(target.getOffset()),OPT_MethodOperand.STATIC(target),rhsGuard.copy(),arrayRef.copy(),elemRef.copy());
  call.copyPosition(s);
  curBlock.appendInstruction(call);
  curBlock.insertOut(contBlock);
  ir.cfg.linkInCodeOrder(curBlock,contBlock);
  return callHelper(call,ir);
}",0.9993043209399396
150079,"/** 
 * Generate a branching dynamic type check. This routine assumes that the CFG and code order are already  correctly established. This routine must either remove s or mutuate it. 
 * @param s          The OPT_Instruction that is to be replaced by a branching type check
 * @param ir         The OPT_IR containing the instruction to be expanded.
 * @param RHSobj     The OPT_RegisterOperand containing the rhs object.
 * @param LHStype    The VM_TypeReference to be tested against.
 * @param RHStib     The OPT_RegisterOperand containing the TIB of the rhs.
 * @param trueBlock  The OPT_BasicBlock to continue at if the typecheck evaluates to true
 * @param falseBlock The OPT_BasicBlock to continue at if the typecheck evaluates to false.
 * @param falseProb   The probability that typecheck will branch to the falseBlock
 * @return the opt instruction immediately before the instruction to continue expansion.
 */
private static OPT_Instruction generateBranchingTypeCheck(OPT_Instruction s,OPT_IR ir,OPT_Operand RHSobj,VM_TypeReference LHStype,OPT_RegisterOperand RHStib,OPT_BasicBlock trueBlock,OPT_BasicBlock falseBlock,OPT_RegisterOperand oldGuard,OPT_BranchProfileOperand falseProb){
  OPT_Instruction continueAt=Goto.create(GOTO,trueBlock.makeJumpTarget());
  continueAt.copyPosition(s);
  s.insertBefore(continueAt);
  s.remove();
  if (LHStype.isClassType()) {
    VM_Class LHSclass=(VM_Class)LHStype.peekResolvedType();
    if (LHSclass != null && LHSclass.isResolved()) {
      if (LHSclass.isInterface()) {
        int interfaceIndex=LHSclass.getDoesImplementIndex();
        int interfaceMask=LHSclass.getDoesImplementBitMask();
        OPT_RegisterOperand doesImpl=InsertUnary(continueAt,ir,GET_DOES_IMPLEMENT_FROM_TIB,VM_TypeReference.IntArray,RHStib);
        if (VM_DynamicTypeCheck.MIN_DOES_IMPLEMENT_SIZE <= interfaceIndex) {
          OPT_RegisterOperand doesImplLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,doesImpl.copyD2U(),TG());
          OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,doesImplLength,IC(interfaceIndex),OPT_ConditionOperand.LESS_EQUAL(),falseBlock.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          continueAt.insertBefore(lengthCheck);
          OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
          oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
          oldBlock.insertOut(falseBlock);
        }
        OPT_RegisterOperand entry=InsertLoadOffset(continueAt,ir,INT_LOAD,VM_TypeReference.Int,doesImpl,Offset.fromIntZeroExtend(interfaceIndex << 2),new OPT_LocationOperand(VM_TypeReference.Int),TG());
        OPT_RegisterOperand bit=InsertBinary(continueAt,ir,INT_AND,VM_TypeReference.Int,entry,IC(interfaceMask));
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,bit,IC(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
 else {
        if (LHSclass.isFinal()) {
          OPT_Operand classTIB=getTIB(continueAt,ir,LHSclass);
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
          return continueAt;
        }
 else {
          int LHSDepth=LHSclass.getTypeDepth();
          int LHSId=LHSclass.getId();
          OPT_RegisterOperand superclassIds=InsertUnary(continueAt,ir,GET_SUPERCLASS_IDS_FROM_TIB,VM_TypeReference.ShortArray,RHStib);
          if (VM_DynamicTypeCheck.MIN_SUPERCLASS_IDS_SIZE <= LHSDepth) {
            OPT_RegisterOperand superclassIdsLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,superclassIds.copyD2U(),TG());
            OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,superclassIdsLength,IC(LHSDepth),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
            continueAt.insertBefore(lengthCheck);
            OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
            oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
            oldBlock.insertOut(falseBlock);
          }
          OPT_RegisterOperand refCandidate=InsertLoadOffset(continueAt,ir,USHORT_LOAD,VM_TypeReference.Short,superclassIds,Offset.fromIntZeroExtend(LHSDepth << 1),new OPT_LocationOperand(VM_TypeReference.Short),TG());
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,refCandidate,IC(LHSId),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
          return continueAt;
        }
      }
    }
 else {
      OPT_RegisterOperand result=ir.regpool.makeTempInt();
      VM_Method target=VM_Entrypoints.instanceOfMethod;
      OPT_Instruction call=Call.create2(CALL,result,AC(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,IC(LHStype.getId()));
      call.copyPosition(continueAt);
      continueAt.insertBefore(call);
      call=callHelper(call,ir);
      continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,result.copyD2U(),IC(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
      return continueAt;
    }
  }
  if (LHStype.isArrayType()) {
    VM_Array LHSArray=(VM_Array)LHStype.peekResolvedType();
    if (LHSArray != null) {
      OPT_Operand classTIB=getTIB(continueAt,ir,LHSArray);
      VM_Type innermostElementType=LHSArray.getInnermostElementType();
      if (innermostElementType.isPrimitiveType() || (innermostElementType.asClass().isResolved() && innermostElementType.asClass().isFinal())) {
        continueAt.insertBefore(IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
      OPT_Instruction shortcircuit=IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.EQUAL(),trueBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
      continueAt.insertBefore(shortcircuit);
      OPT_BasicBlock myBlock=shortcircuit.getBasicBlock();
      OPT_BasicBlock mainBlock=myBlock.splitNodeWithLinksAt(shortcircuit,ir);
      myBlock.insertOut(trueBlock);
      OPT_RegisterOperand rhsType=InsertUnary(continueAt,ir,GET_TYPE_FROM_TIB,VM_TypeReference.VM_Type,RHStib.copyD2U());
      if (innermostElementType.isJavaLangObjectType()) {
        OPT_IntConstantOperand lhsDimension=IC(LHStype.getDimensionality());
        OPT_RegisterOperand rhsDimension=getField(continueAt,ir,rhsType,VM_Entrypoints.dimensionField);
        OPT_Instruction dimTest=IfCmp2.create(INT_IFCMP2,oldGuard,rhsDimension,lhsDimension,OPT_ConditionOperand.GREATER(),trueBlock.makeJumpTarget(),((OPT_BranchProfileOperand)falseProb.copy()).flip(),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),(OPT_BranchProfileOperand)falseProb.copy());
        continueAt.insertBefore(dimTest);
        OPT_BasicBlock testBlock=mainBlock.splitNodeWithLinksAt(dimTest,ir);
        mainBlock.insertOut(trueBlock);
        mainBlock.insertOut(falseBlock);
        OPT_RegisterOperand rhsInnermostElementType=getField(continueAt,ir,rhsType.copyU2U(),VM_Entrypoints.innermostElementTypeField);
        OPT_RegisterOperand rhsInnermostElementTypeDimension=getField(continueAt,ir,rhsInnermostElementType,VM_Entrypoints.dimensionField);
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,rhsInnermostElementTypeDimension,IC(0),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
    }
    VM_Method target=VM_Entrypoints.instanceOfMethod;
    OPT_RegisterOperand callResult=ir.regpool.makeTempInt();
    OPT_Instruction call=Call.create2(CALL,callResult,AC(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,IC(LHStype.getId()));
    call.copyPosition(continueAt);
    continueAt.insertBefore(call);
    call=callHelper(call,ir);
    continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,callResult.copyD2U(),IC(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
    return continueAt;
  }
  OPT_OptimizingCompilerException.UNREACHABLE();
  return null;
}","/** 
 * Generate a branching dynamic type check. This routine assumes that the CFG and code order are already  correctly established. This routine must either remove s or mutuate it. 
 * @param s          The OPT_Instruction that is to be replaced by a branching type check
 * @param ir         The OPT_IR containing the instruction to be expanded.
 * @param RHSobj     The OPT_RegisterOperand containing the rhs object.
 * @param LHStype    The VM_TypeReference to be tested against.
 * @param RHStib     The OPT_RegisterOperand containing the TIB of the rhs.
 * @param trueBlock  The OPT_BasicBlock to continue at if the typecheck evaluates to true
 * @param falseBlock The OPT_BasicBlock to continue at if the typecheck evaluates to false.
 * @param falseProb   The probability that typecheck will branch to the falseBlock
 * @return the opt instruction immediately before the instruction to continue expansion.
 */
private static OPT_Instruction generateBranchingTypeCheck(OPT_Instruction s,OPT_IR ir,OPT_Operand RHSobj,VM_TypeReference LHStype,OPT_RegisterOperand RHStib,OPT_BasicBlock trueBlock,OPT_BasicBlock falseBlock,OPT_RegisterOperand oldGuard,OPT_BranchProfileOperand falseProb){
  OPT_Instruction continueAt=Goto.create(GOTO,trueBlock.makeJumpTarget());
  continueAt.copyPosition(s);
  s.insertBefore(continueAt);
  s.remove();
  if (LHStype.isClassType()) {
    VM_Class LHSclass=(VM_Class)LHStype.peekResolvedType();
    if (LHSclass != null && LHSclass.isResolved()) {
      if (LHSclass.isInterface()) {
        int interfaceIndex=LHSclass.getDoesImplementIndex();
        int interfaceMask=LHSclass.getDoesImplementBitMask();
        OPT_RegisterOperand doesImpl=InsertUnary(continueAt,ir,GET_DOES_IMPLEMENT_FROM_TIB,VM_TypeReference.IntArray,RHStib);
        if (VM_DynamicTypeCheck.MIN_DOES_IMPLEMENT_SIZE <= interfaceIndex) {
          OPT_RegisterOperand doesImplLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,doesImpl.copyD2U(),TG());
          OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,doesImplLength,IC(interfaceIndex),OPT_ConditionOperand.LESS_EQUAL(),falseBlock.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          if (oldGuard != null)           oldGuard=oldGuard.copyD2D();
          continueAt.insertBefore(lengthCheck);
          OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
          oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
          oldBlock.insertOut(falseBlock);
        }
        OPT_RegisterOperand entry=InsertLoadOffset(continueAt,ir,INT_LOAD,VM_TypeReference.Int,doesImpl,Offset.fromIntZeroExtend(interfaceIndex << 2),new OPT_LocationOperand(VM_TypeReference.Int),TG());
        OPT_RegisterOperand bit=InsertBinary(continueAt,ir,INT_AND,VM_TypeReference.Int,entry,IC(interfaceMask));
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,bit,IC(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
 else {
        if (LHSclass.isFinal()) {
          OPT_Operand classTIB=getTIB(continueAt,ir,LHSclass);
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
          return continueAt;
        }
 else {
          int LHSDepth=LHSclass.getTypeDepth();
          int LHSId=LHSclass.getId();
          OPT_RegisterOperand superclassIds=InsertUnary(continueAt,ir,GET_SUPERCLASS_IDS_FROM_TIB,VM_TypeReference.ShortArray,RHStib);
          if (VM_DynamicTypeCheck.MIN_SUPERCLASS_IDS_SIZE <= LHSDepth) {
            OPT_RegisterOperand superclassIdsLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,superclassIds.copyD2U(),TG());
            OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,superclassIdsLength,IC(LHSDepth),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
            if (oldGuard != null)             oldGuard=oldGuard.copyD2D();
            continueAt.insertBefore(lengthCheck);
            OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
            oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
            oldBlock.insertOut(falseBlock);
          }
          OPT_RegisterOperand refCandidate=InsertLoadOffset(continueAt,ir,USHORT_LOAD,VM_TypeReference.Short,superclassIds,Offset.fromIntZeroExtend(LHSDepth << 1),new OPT_LocationOperand(VM_TypeReference.Short),TG());
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,refCandidate,IC(LHSId),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
          return continueAt;
        }
      }
    }
 else {
      OPT_RegisterOperand result=ir.regpool.makeTempInt();
      VM_Method target=VM_Entrypoints.instanceOfMethod;
      OPT_Instruction call=Call.create2(CALL,result,AC(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,IC(LHStype.getId()));
      call.copyPosition(continueAt);
      continueAt.insertBefore(call);
      call=callHelper(call,ir);
      continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,result.copyD2U(),IC(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
      return continueAt;
    }
  }
  if (LHStype.isArrayType()) {
    VM_Array LHSArray=(VM_Array)LHStype.peekResolvedType();
    if (LHSArray != null) {
      OPT_Operand classTIB=getTIB(continueAt,ir,LHSArray);
      VM_Type innermostElementType=LHSArray.getInnermostElementType();
      if (innermostElementType.isPrimitiveType() || (innermostElementType.asClass().isResolved() && innermostElementType.asClass().isFinal())) {
        continueAt.insertBefore(IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
      OPT_Instruction shortcircuit=IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.EQUAL(),trueBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
      if (oldGuard != null)       oldGuard=oldGuard.copyD2D();
      continueAt.insertBefore(shortcircuit);
      OPT_BasicBlock myBlock=shortcircuit.getBasicBlock();
      OPT_BasicBlock mainBlock=myBlock.splitNodeWithLinksAt(shortcircuit,ir);
      myBlock.insertOut(trueBlock);
      OPT_RegisterOperand rhsType=InsertUnary(continueAt,ir,GET_TYPE_FROM_TIB,VM_TypeReference.VM_Type,RHStib.copyD2U());
      if (innermostElementType.isJavaLangObjectType()) {
        OPT_IntConstantOperand lhsDimension=IC(LHStype.getDimensionality());
        OPT_RegisterOperand rhsDimension=getField(continueAt,ir,rhsType,VM_Entrypoints.dimensionField);
        OPT_Instruction dimTest=IfCmp2.create(INT_IFCMP2,oldGuard,rhsDimension,lhsDimension,OPT_ConditionOperand.GREATER(),trueBlock.makeJumpTarget(),((OPT_BranchProfileOperand)falseProb.copy()).flip(),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),(OPT_BranchProfileOperand)falseProb.copy());
        if (oldGuard != null)         oldGuard=oldGuard.copyD2D();
        continueAt.insertBefore(dimTest);
        OPT_BasicBlock testBlock=mainBlock.splitNodeWithLinksAt(dimTest,ir);
        mainBlock.insertOut(trueBlock);
        mainBlock.insertOut(falseBlock);
        OPT_RegisterOperand rhsInnermostElementType=getField(continueAt,ir,rhsType.copyU2U(),VM_Entrypoints.innermostElementTypeField);
        OPT_RegisterOperand rhsInnermostElementTypeDimension=getField(continueAt,ir,rhsInnermostElementType,VM_Entrypoints.dimensionField);
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,rhsInnermostElementTypeDimension,IC(0),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
    }
    VM_Method target=VM_Entrypoints.instanceOfMethod;
    OPT_RegisterOperand callResult=ir.regpool.makeTempInt();
    OPT_Instruction call=Call.create2(CALL,callResult,AC(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,IC(LHStype.getId()));
    call.copyPosition(continueAt);
    continueAt.insertBefore(call);
    call=callHelper(call,ir);
    continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,callResult.copyD2U(),IC(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
    return continueAt;
  }
  OPT_OptimizingCompilerException.UNREACHABLE();
  return null;
}",0.9830550098231828
150080,"/** 
 * Return a generation context that represents the  execution of inlDec in the context <parent,ebag> for the call instruction callSite. <p> PRECONDITION: inlDec.isYes() <p> POSTCONDITIONS:  Let gc be the returned generation context. <ul> <li> gc.cfg.firstInCodeOrder is the entry to the inlined context <li>gc.cfg.lastInCodeOrder is the exit from the inlined context <li> OPT_GenerationContext.transferState(parent, child) has been called. </ul>
 * @param inlDec the inlining decision to execute
 * @param parent the caller generation context
 * @param ebag exception handler scope for the caller
 * @param callSite the callsite to execute
 * @return a generation context that represents the execution of theinline decision in the given context
 */
public static OPT_GenerationContext execute(OPT_InlineDecision inlDec,OPT_GenerationContext parent,OPT_ExceptionHandlerBasicBlockBag ebag,OPT_Instruction callSite){
  if (inlDec.needsGuard()) {
    OPT_GenerationContext container=OPT_GenerationContext.createSynthetic(parent,ebag);
    container.cfg.breakCodeOrder(container.prologue,container.epilogue);
    VM_Method[] targets=inlDec.getTargets();
    byte[] guards=inlDec.getGuards();
    OPT_GenerationContext[] children=new OPT_GenerationContext[targets.length];
    for (int i=0; i < targets.length; i++) {
      VM_NormalMethod callee=(VM_NormalMethod)targets[i];
      if (parent.options.PRINT_INLINE_REPORT) {
        String guard=guards[i] == OPT_Options.IG_CLASS_TEST ? ""String_Node_Str"" : ""String_Node_Str"";
        VM.sysWrite(""String_Node_Str"" + guard + ""String_Node_Str""+ callee+ ""String_Node_Str""+ callSite.position.getMethod()+ ""String_Node_Str""+ callSite.bcIndex+ ""String_Node_Str"");
      }
      children[i]=OPT_GenerationContext.createChildContext(parent,ebag,callee,callSite);
      OPT_BC2IR.generateHIR(children[i]);
      OPT_GenerationContext.transferState(parent,children[i]);
    }
    if (Call.hasResult(callSite)) {
      OPT_Register reg=Call.getResult(callSite).register;
      container.result=children[0].result;
      for (int i=1; i < targets.length; i++) {
        container.result=OPT_Operand.meet(container.result,children[i].result,reg);
      }
      container.result=OPT_Operand.meet(container.result,Call.getResult(callSite),reg);
    }
    OPT_BasicBlock testFailed=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
    testFailed.exceptionHandlers=ebag;
    OPT_Instruction call=callSite.copyWithoutLinks();
    Call.getMethod(call).setIsGuardedInlineOffBranch(true);
    call.bcIndex=callSite.bcIndex;
    call.position=callSite.position;
    if (COUNT_FAILED_GUARDS && VM_Controller.options.INSERT_DEBUGGING_COUNTERS) {
      String eventName=""String_Node_Str"" + callSite.position.getMethod().toString();
      OPT_Instruction counterInst=VM_AOSDatabase.debuggingCounterData.getCounterInstructionForEvent(eventName);
      testFailed.appendInstruction(counterInst);
    }
    if (inlDec.OSRTestFailed()) {
      OPT_Instruction lastOsrBarrier=(OPT_Instruction)callSite.scratchObject;
      OPT_Instruction s=OPT_BC2IR._osrHelper(lastOsrBarrier);
      s.position=callSite.position;
      s.bcIndex=callSite.bcIndex;
      testFailed.appendInstruction(s);
    }
 else {
      testFailed.appendInstruction(call);
    }
    testFailed.appendInstruction(call);
    testFailed.insertOut(container.epilogue);
    container.cfg.linkInCodeOrder(testFailed,container.epilogue);
    if (ebag != null) {
      for (OPT_BasicBlockEnumeration e=ebag.enumerator(); e.hasMoreElements(); ) {
        OPT_BasicBlock handler=e.next();
        testFailed.insertOut(handler);
      }
    }
    testFailed.setCanThrowExceptions();
    testFailed.setMayThrowUncaughtException();
    testFailed.setInfrequent();
    OPT_BasicBlock firstIfBlock=testFailed;
    OPT_RegisterOperand receiver=Call.getParam(callSite,0).asRegister();
    OPT_MethodOperand mo=Call.getMethod(callSite);
    boolean isInterface=mo.isInterface();
    if (isInterface) {
      if (VM.BuildForIMTInterfaceInvocation || (VM.BuildForITableInterfaceInvocation && VM.DirectlyIndexedITables)) {
        VM_Type interfaceType=mo.getTarget().getDeclaringClass();
        VM_TypeReference recTypeRef=receiver.type;
        VM_Class recType=(VM_Class)recTypeRef.peekResolvedType();
        boolean requiresImplementsTest=true;
        if (recType != null && recType.isResolved() && !recType.isInterface()) {
          byte doesImplement=OPT_ClassLoaderProxy.includesType(interfaceType.getTypeRef(),recTypeRef);
          requiresImplementsTest=doesImplement != OPT_Constants.YES;
        }
        if (requiresImplementsTest) {
          OPT_Instruction dtc=TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),new OPT_TypeOperand(interfaceType),Call.getGuard(callSite).copy());
          dtc.copyPosition(callSite);
          testFailed.prependInstruction(dtc);
        }
      }
    }
    for (int i=children.length - 1; i >= 0; i--, testFailed=firstIfBlock) {
      firstIfBlock=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
      firstIfBlock.exceptionHandlers=ebag;
      OPT_BasicBlock lastIfBlock=firstIfBlock;
      VM_Method target=children[i].method;
      OPT_Instruction tmp;
      if (isInterface) {
        VM_Class callDeclClass=mo.getTarget().getDeclaringClass();
        if (!callDeclClass.isInterface()) {
          throw new OPT_OptimizingCompilerException(""String_Node_Str"");
        }
        byte doesImplement=OPT_ClassLoaderProxy.includesType(callDeclClass.getTypeRef(),target.getDeclaringClass().getTypeRef());
        if (doesImplement != OPT_Constants.YES) {
          if (parent.options.PRINT_INLINE_REPORT) {
            VM.sysWrite(""String_Node_Str"" + callDeclClass + ""String_Node_Str"");
          }
          firstIfBlock=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
          firstIfBlock.exceptionHandlers=ebag;
          OPT_RegisterOperand instanceOfResult=parent.temps.makeTempInt();
          tmp=InstanceOf.create(INSTANCEOF_NOTNULL,instanceOfResult,new OPT_TypeOperand(callDeclClass),receiver.copy(),Call.getGuard(callSite));
          tmp.copyPosition(callSite);
          firstIfBlock.appendInstruction(tmp);
          tmp=IfCmp.create(INT_IFCMP,parent.temps.makeTempValidation(),instanceOfResult.copyD2U(),new OPT_IntConstantOperand(0),OPT_ConditionOperand.EQUAL(),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          tmp.copyPosition(callSite);
          firstIfBlock.appendInstruction(tmp);
          firstIfBlock.insertOut(testFailed);
          firstIfBlock.insertOut(lastIfBlock);
          container.cfg.linkInCodeOrder(firstIfBlock,lastIfBlock);
        }
      }
      if (guards[i] == OPT_Options.IG_CLASS_TEST) {
        tmp=InlineGuard.create(IG_CLASS_TEST,receiver.copyU2U(),Call.getGuard(callSite).copy(),new OPT_TypeOperand(target.getDeclaringClass()),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
      }
 else       if (guards[i] == OPT_Options.IG_METHOD_TEST) {
        if (isInterface) {
          OPT_RegisterOperand t=parent.temps.makeTempInt();
          OPT_Instruction test=InstanceOf.create(INSTANCEOF_NOTNULL,t,new OPT_TypeOperand(target.getDeclaringClass().getTypeRef()),receiver);
          test.copyPosition(callSite);
          lastIfBlock.appendInstruction(test);
          OPT_Instruction cmp=IfCmp.create(INT_IFCMP,parent.temps.makeTempValidation(),t.copyD2U(),new OPT_IntConstantOperand(0),OPT_ConditionOperand.EQUAL(),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          cmp.copyPosition(callSite);
          lastIfBlock.appendInstruction(cmp);
          OPT_BasicBlock subclassTest=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
          lastIfBlock.insertOut(testFailed);
          lastIfBlock.insertOut(subclassTest);
          container.cfg.linkInCodeOrder(lastIfBlock,subclassTest);
          lastIfBlock=subclassTest;
        }
        tmp=InlineGuard.create(IG_METHOD_TEST,receiver.copyU2U(),Call.getGuard(callSite).copy(),OPT_MethodOperand.VIRTUAL(target.getMemberRef().asMethodReference(),target),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
      }
 else {
        tmp=InlineGuard.create(IG_PATCH_POINT,receiver.copyU2U(),Call.getGuard(callSite).copy(),OPT_MethodOperand.VIRTUAL(target.getMemberRef().asMethodReference(),target),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
      }
      tmp.copyPosition(callSite);
      lastIfBlock.appendInstruction(tmp);
      lastIfBlock.insertOut(testFailed);
      lastIfBlock.insertOut(children[i].prologue);
      container.cfg.linkInCodeOrder(lastIfBlock,children[i].cfg.firstInCodeOrder());
      if (children[i].epilogue != null) {
        children[i].epilogue.appendInstruction(container.epilogue.makeGOTO());
        children[i].epilogue.insertOut(container.epilogue);
      }
      container.cfg.linkInCodeOrder(children[i].cfg.lastInCodeOrder(),testFailed);
    }
    container.prologue.insertOut(testFailed);
    container.cfg.linkInCodeOrder(container.prologue,testFailed);
    return container;
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(inlDec.getNumberOfTargets() == 1);
    VM_NormalMethod callee=(VM_NormalMethod)inlDec.getTargets()[0];
    if (parent.options.PRINT_INLINE_REPORT) {
      VM.sysWrite(""String_Node_Str"" + callee + ""String_Node_Str""+ callSite.position.getMethod()+ ""String_Node_Str""+ callSite.bcIndex+ ""String_Node_Str"");
    }
    OPT_GenerationContext child=OPT_GenerationContext.createChildContext(parent,ebag,callee,callSite);
    OPT_BC2IR.generateHIR(child);
    OPT_GenerationContext.transferState(parent,child);
    return child;
  }
}","/** 
 * Return a generation context that represents the  execution of inlDec in the context <parent,ebag> for the call instruction callSite. <p> PRECONDITION: inlDec.isYes() <p> POSTCONDITIONS:  Let gc be the returned generation context. <ul> <li> gc.cfg.firstInCodeOrder is the entry to the inlined context <li>gc.cfg.lastInCodeOrder is the exit from the inlined context <li> OPT_GenerationContext.transferState(parent, child) has been called. </ul>
 * @param inlDec the inlining decision to execute
 * @param parent the caller generation context
 * @param ebag exception handler scope for the caller
 * @param callSite the callsite to execute
 * @return a generation context that represents the execution of theinline decision in the given context
 */
public static OPT_GenerationContext execute(OPT_InlineDecision inlDec,OPT_GenerationContext parent,OPT_ExceptionHandlerBasicBlockBag ebag,OPT_Instruction callSite){
  if (inlDec.needsGuard()) {
    OPT_GenerationContext container=OPT_GenerationContext.createSynthetic(parent,ebag);
    container.cfg.breakCodeOrder(container.prologue,container.epilogue);
    VM_Method[] targets=inlDec.getTargets();
    byte[] guards=inlDec.getGuards();
    OPT_GenerationContext[] children=new OPT_GenerationContext[targets.length];
    for (int i=0; i < targets.length; i++) {
      VM_NormalMethod callee=(VM_NormalMethod)targets[i];
      if (parent.options.PRINT_INLINE_REPORT) {
        String guard=guards[i] == OPT_Options.IG_CLASS_TEST ? ""String_Node_Str"" : ""String_Node_Str"";
        VM.sysWrite(""String_Node_Str"" + guard + ""String_Node_Str""+ callee+ ""String_Node_Str""+ callSite.position.getMethod()+ ""String_Node_Str""+ callSite.bcIndex+ ""String_Node_Str"");
      }
      children[i]=OPT_GenerationContext.createChildContext(parent,ebag,callee,callSite);
      OPT_BC2IR.generateHIR(children[i]);
      OPT_GenerationContext.transferState(parent,children[i]);
    }
    if (Call.hasResult(callSite)) {
      OPT_Register reg=Call.getResult(callSite).register;
      container.result=children[0].result;
      for (int i=1; i < targets.length; i++) {
        container.result=OPT_Operand.meet(container.result,children[i].result,reg);
      }
      container.result=OPT_Operand.meet(container.result,Call.getResult(callSite),reg);
    }
    OPT_BasicBlock testFailed=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
    testFailed.exceptionHandlers=ebag;
    OPT_Instruction call=callSite.copyWithoutLinks();
    Call.getMethod(call).setIsGuardedInlineOffBranch(true);
    call.bcIndex=callSite.bcIndex;
    call.position=callSite.position;
    if (COUNT_FAILED_GUARDS && VM_Controller.options.INSERT_DEBUGGING_COUNTERS) {
      String eventName=""String_Node_Str"" + callSite.position.getMethod().toString();
      OPT_Instruction counterInst=VM_AOSDatabase.debuggingCounterData.getCounterInstructionForEvent(eventName);
      testFailed.appendInstruction(counterInst);
    }
    if (inlDec.OSRTestFailed()) {
      OPT_Instruction lastOsrBarrier=(OPT_Instruction)callSite.scratchObject;
      OPT_Instruction s=OPT_BC2IR._osrHelper(lastOsrBarrier);
      s.position=callSite.position;
      s.bcIndex=callSite.bcIndex;
      testFailed.appendInstruction(s);
    }
 else {
      testFailed.appendInstruction(call);
    }
    testFailed.appendInstruction(call);
    testFailed.insertOut(container.epilogue);
    container.cfg.linkInCodeOrder(testFailed,container.epilogue);
    if (ebag != null) {
      for (OPT_BasicBlockEnumeration e=ebag.enumerator(); e.hasMoreElements(); ) {
        OPT_BasicBlock handler=e.next();
        testFailed.insertOut(handler);
      }
    }
    testFailed.setCanThrowExceptions();
    testFailed.setMayThrowUncaughtException();
    testFailed.setInfrequent();
    OPT_BasicBlock firstIfBlock=testFailed;
    OPT_RegisterOperand receiver=Call.getParam(callSite,0).asRegister();
    OPT_MethodOperand mo=Call.getMethod(callSite);
    boolean isInterface=mo.isInterface();
    if (isInterface) {
      if (VM.BuildForIMTInterfaceInvocation || (VM.BuildForITableInterfaceInvocation && VM.DirectlyIndexedITables)) {
        VM_Type interfaceType=mo.getTarget().getDeclaringClass();
        VM_TypeReference recTypeRef=receiver.type;
        VM_Class recType=(VM_Class)recTypeRef.peekResolvedType();
        boolean requiresImplementsTest=true;
        if (recType != null && recType.isResolved() && !recType.isInterface()) {
          byte doesImplement=OPT_ClassLoaderProxy.includesType(interfaceType.getTypeRef(),recTypeRef);
          requiresImplementsTest=doesImplement != OPT_Constants.YES;
        }
        if (requiresImplementsTest) {
          OPT_Instruction dtc=TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),new OPT_TypeOperand(interfaceType),Call.getGuard(callSite).copy());
          dtc.copyPosition(callSite);
          testFailed.prependInstruction(dtc);
        }
      }
    }
    for (int i=children.length - 1; i >= 0; i--, testFailed=firstIfBlock) {
      firstIfBlock=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
      firstIfBlock.exceptionHandlers=ebag;
      OPT_BasicBlock lastIfBlock=firstIfBlock;
      VM_Method target=children[i].method;
      OPT_Instruction tmp;
      if (isInterface) {
        VM_Class callDeclClass=mo.getTarget().getDeclaringClass();
        if (!callDeclClass.isInterface()) {
          throw new OPT_OptimizingCompilerException(""String_Node_Str"");
        }
        byte doesImplement=OPT_ClassLoaderProxy.includesType(callDeclClass.getTypeRef(),target.getDeclaringClass().getTypeRef());
        if (doesImplement != OPT_Constants.YES) {
          if (parent.options.PRINT_INLINE_REPORT) {
            VM.sysWrite(""String_Node_Str"" + callDeclClass + ""String_Node_Str"");
          }
          firstIfBlock=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
          firstIfBlock.exceptionHandlers=ebag;
          OPT_RegisterOperand instanceOfResult=parent.temps.makeTempInt();
          tmp=InstanceOf.create(INSTANCEOF_NOTNULL,instanceOfResult,new OPT_TypeOperand(callDeclClass),receiver.copy(),Call.getGuard(callSite));
          tmp.copyPosition(callSite);
          firstIfBlock.appendInstruction(tmp);
          tmp=IfCmp.create(INT_IFCMP,parent.temps.makeTempValidation(),instanceOfResult.copyD2U(),new OPT_IntConstantOperand(0),OPT_ConditionOperand.EQUAL(),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          tmp.copyPosition(callSite);
          firstIfBlock.appendInstruction(tmp);
          firstIfBlock.insertOut(testFailed);
          firstIfBlock.insertOut(lastIfBlock);
          container.cfg.linkInCodeOrder(firstIfBlock,lastIfBlock);
        }
      }
      if (guards[i] == OPT_Options.IG_CLASS_TEST) {
        tmp=InlineGuard.create(IG_CLASS_TEST,receiver.copyU2U(),Call.getGuard(callSite).copy(),new OPT_TypeOperand(target.getDeclaringClass()),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
      }
 else       if (guards[i] == OPT_Options.IG_METHOD_TEST) {
        if (isInterface) {
          OPT_RegisterOperand t=parent.temps.makeTempInt();
          OPT_Instruction test=InstanceOf.create(INSTANCEOF_NOTNULL,t,new OPT_TypeOperand(target.getDeclaringClass().getTypeRef()),receiver.copyU2U());
          test.copyPosition(callSite);
          lastIfBlock.appendInstruction(test);
          OPT_Instruction cmp=IfCmp.create(INT_IFCMP,parent.temps.makeTempValidation(),t.copyD2U(),new OPT_IntConstantOperand(0),OPT_ConditionOperand.EQUAL(),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          cmp.copyPosition(callSite);
          lastIfBlock.appendInstruction(cmp);
          OPT_BasicBlock subclassTest=new OPT_BasicBlock(callSite.bcIndex,callSite.position,parent.cfg);
          lastIfBlock.insertOut(testFailed);
          lastIfBlock.insertOut(subclassTest);
          container.cfg.linkInCodeOrder(lastIfBlock,subclassTest);
          lastIfBlock=subclassTest;
        }
        tmp=InlineGuard.create(IG_METHOD_TEST,receiver.copyU2U(),Call.getGuard(callSite).copy(),OPT_MethodOperand.VIRTUAL(target.getMemberRef().asMethodReference(),target),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
      }
 else {
        tmp=InlineGuard.create(IG_PATCH_POINT,receiver.copyU2U(),Call.getGuard(callSite).copy(),OPT_MethodOperand.VIRTUAL(target.getMemberRef().asMethodReference(),target),testFailed.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
      }
      tmp.copyPosition(callSite);
      lastIfBlock.appendInstruction(tmp);
      lastIfBlock.insertOut(testFailed);
      lastIfBlock.insertOut(children[i].prologue);
      container.cfg.linkInCodeOrder(lastIfBlock,children[i].cfg.firstInCodeOrder());
      if (children[i].epilogue != null) {
        children[i].epilogue.appendInstruction(container.epilogue.makeGOTO());
        children[i].epilogue.insertOut(container.epilogue);
      }
      container.cfg.linkInCodeOrder(children[i].cfg.lastInCodeOrder(),testFailed);
    }
    container.prologue.insertOut(testFailed);
    container.cfg.linkInCodeOrder(container.prologue,testFailed);
    return container;
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(inlDec.getNumberOfTargets() == 1);
    VM_NormalMethod callee=(VM_NormalMethod)inlDec.getTargets()[0];
    if (parent.options.PRINT_INLINE_REPORT) {
      VM.sysWrite(""String_Node_Str"" + callee + ""String_Node_Str""+ callSite.position.getMethod()+ ""String_Node_Str""+ callSite.bcIndex+ ""String_Node_Str"");
    }
    OPT_GenerationContext child=OPT_GenerationContext.createChildContext(parent,ebag,callee,callSite);
    OPT_BC2IR.generateHIR(child);
    OPT_GenerationContext.transferState(parent,child);
    return child;
  }
}",0.999484907798496
150081,"/** 
 * After register allocation, go back through the IR and insert compensating code to deal with spills.
 * @param set information from linear scan analysis
 */
void insertSpillCode(OPT_LinearScan.ActiveSet set){
  if (USE_LINEAR_SCAN) {
    activeSet=set;
  }
  if (verboseDebug) {
    System.out.println(""String_Node_Str"");
  }
  for (Enumeration blocks=ir.getBasicBlocks(); blocks.hasMoreElements(); ) {
    OPT_BasicBlock bb=(OPT_BasicBlock)blocks.nextElement();
    for (Enumeration e=bb.forwardInstrEnumerator(); e.hasMoreElements(); ) {
      boolean beCheap=(ir.options.FREQ_FOCUS_EFFORT && bb.getInfrequent());
      OPT_Instruction s=(OPT_Instruction)e.nextElement();
      if (verboseDebug) {
        System.out.println(s);
      }
      restoreScratchRegistersBefore(s);
      if (s.operator == BBEND || isPEIWithCatch(s) || s.isBranch() || s.isReturn()) {
        restoreAllScratchRegistersBefore(s);
      }
      if (s.operator == YIELDPOINT_PROLOGUE) {
        restoreAllScratchRegistersBefore(s);
      }
      if (s.isGCPoint()) {
        markDirtyScratchRegisters(s);
      }
      for (Enumeration ops=s.getOperands(); ops.hasMoreElements(); ) {
        OPT_Operand op=(OPT_Operand)ops.nextElement();
        if (op != null && op.isRegister()) {
          OPT_Register r=op.asRegister().register;
          if (!r.isPhysical()) {
            ScratchRegister scratch=getCurrentScratchRegister(r,s);
            if (verboseDebug) {
              System.out.println(r + ""String_Node_Str"" + scratch);
            }
            if (scratch != null) {
              boolean defined=definedIn(r,s) || definesSpillLocation(r,s);
              if (defined) {
                scratch.setDirty(true);
              }
              replaceRegisterWithScratch(s,r,scratch.scratch);
            }
 else {
              if (needScratch(r,s)) {
                boolean used=usedIn(r,s) || usesSpillLocation(r,s);
                boolean defined=definedIn(r,s) || definesSpillLocation(r,s);
                if (used) {
                  if (!usedIn(r,s)) {
                    OPT_Register r2=spillLocationUse(r,s);
                    scratch=moveToScratchBefore(s,r2,beCheap);
                    if (verboseDebug) {
                      System.out.println(""String_Node_Str"" + r2 + ""String_Node_Str""+ scratch);
                    }
                  }
 else {
                    scratch=moveToScratchBefore(s,r,beCheap);
                    if (verboseDebug) {
                      System.out.println(""String_Node_Str"" + r + ""String_Node_Str""+ scratch);
                    }
                  }
                }
                if (defined) {
                  scratch=holdInScratchAfter(s,r,beCheap);
                  scratch.setDirty(true);
                  if (verboseDebug) {
                    System.out.println(""String_Node_Str"" + r + ""String_Node_Str""+ scratch);
                  }
                }
                replaceRegisterWithScratch(s,r,scratch.scratch);
              }
 else {
                if (s.operator != YIELDPOINT_OSR) {
                  replaceOperandWithSpillLocation(s,op.asRegister());
                  VM._assert(NOT_REACHED);
                }
              }
            }
          }
        }
      }
      if (isSysCall(s)) {
        OPT_CallingConvention.saveNonvolatilesAroundSysCall(s,ir);
      }
    }
  }
}","/** 
 * After register allocation, go back through the IR and insert compensating code to deal with spills.
 * @param set information from linear scan analysis
 */
void insertSpillCode(OPT_LinearScan.ActiveSet set){
  if (USE_LINEAR_SCAN) {
    activeSet=set;
  }
  if (verboseDebug) {
    System.out.println(""String_Node_Str"");
  }
  for (Enumeration blocks=ir.getBasicBlocks(); blocks.hasMoreElements(); ) {
    OPT_BasicBlock bb=(OPT_BasicBlock)blocks.nextElement();
    for (Enumeration e=bb.forwardInstrEnumerator(); e.hasMoreElements(); ) {
      boolean beCheap=(ir.options.FREQ_FOCUS_EFFORT && bb.getInfrequent());
      OPT_Instruction s=(OPT_Instruction)e.nextElement();
      if (verboseDebug) {
        System.out.println(s);
      }
      restoreScratchRegistersBefore(s);
      if (s.operator == BBEND || isPEIWithCatch(s) || s.isBranch() || s.isReturn()) {
        restoreAllScratchRegistersBefore(s);
      }
      if (s.operator == YIELDPOINT_PROLOGUE) {
        restoreAllScratchRegistersBefore(s);
      }
      if (s.isGCPoint()) {
        markDirtyScratchRegisters(s);
      }
      for (Enumeration ops=s.getOperands(); ops.hasMoreElements(); ) {
        OPT_Operand op=(OPT_Operand)ops.nextElement();
        if (op != null && op.isRegister()) {
          OPT_Register r=op.asRegister().register;
          if (!r.isPhysical()) {
            ScratchRegister scratch=getCurrentScratchRegister(r,s);
            if (verboseDebug) {
              System.out.println(r + ""String_Node_Str"" + scratch);
            }
            if (scratch != null) {
              boolean defined=definedIn(r,s) || definesSpillLocation(r,s);
              if (defined) {
                scratch.setDirty(true);
              }
              replaceRegisterWithScratch(s,r,scratch.scratch);
            }
 else {
              if (needScratch(r,s)) {
                boolean used=usedIn(r,s) || usesSpillLocation(r,s);
                boolean defined=definedIn(r,s) || definesSpillLocation(r,s);
                if (used) {
                  if (!usedIn(r,s)) {
                    OPT_Register r2=spillLocationUse(r,s);
                    scratch=moveToScratchBefore(s,r2,beCheap);
                    if (verboseDebug) {
                      System.out.println(""String_Node_Str"" + r2 + ""String_Node_Str""+ scratch);
                    }
                  }
 else {
                    scratch=moveToScratchBefore(s,r,beCheap);
                    if (verboseDebug) {
                      System.out.println(""String_Node_Str"" + r + ""String_Node_Str""+ scratch);
                    }
                  }
                }
                if (defined) {
                  scratch=holdInScratchAfter(s,r,beCheap);
                  scratch.setDirty(true);
                  if (verboseDebug) {
                    System.out.println(""String_Node_Str"" + r + ""String_Node_Str""+ scratch);
                  }
                }
                replaceRegisterWithScratch(s,r,scratch.scratch);
              }
 else {
                replaceOperandWithSpillLocation(s,op.asRegister());
                VM._assert(NOT_REACHED);
              }
            }
          }
        }
      }
      if (isSysCall(s)) {
        OPT_CallingConvention.saveNonvolatilesAroundSysCall(s,ir);
      }
    }
  }
}",0.973897389738974
150082,"/** 
 * Append an instruction after a store instruction that caches value in register r.
 */
static void appendMove(OPT_Register r,OPT_Operand src,OPT_Instruction store){
  VM_TypeReference type=src.getType();
  OPT_RegisterOperand rop=new OPT_RegisterOperand(r,type);
  store.insertAfter(Move.create(OPT_IRTools.getMoveOp(type),rop,src));
}","/** 
 * Append an instruction after a store instruction that caches value in register r.
 */
static void appendMove(OPT_Register r,OPT_Operand src,OPT_Instruction store){
  VM_TypeReference type=src.getType();
  OPT_RegisterOperand rop=new OPT_RegisterOperand(r,type);
  store.insertAfter(Move.create(OPT_IRTools.getMoveOp(type),rop,src.copy()));
}",0.9898403483309144
150083,"/** 
 * Expansion of INT_DIV and INT_REM
 * @param s the instruction to expand
 * @param result the result operand
 * @param val1 the first operand
 * @param val2 the second operand
 * @param isDiv true for div, false for rem
 */
protected final void INT_DIVIDES(OPT_Instruction s,OPT_RegisterOperand result,OPT_Operand val1,OPT_Operand val2,boolean isDiv){
  EMIT(MIR_Move.create(IA32_MOV,new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int),val1));
  EMIT(MIR_ConvertDW2QW.create(IA32_CDQ,new OPT_RegisterOperand(getEDX(),VM_TypeReference.Int),new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int)));
  if (val2 instanceof OPT_IntConstantOperand) {
    OPT_RegisterOperand temp=regpool.makeTempInt();
    EMIT(MIR_Move.create(IA32_MOV,temp,val2));
    val2=temp;
  }
  EMIT(MIR_Divide.mutate(s,IA32_IDIV,new OPT_RegisterOperand(getEDX(),VM_TypeReference.Int),new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int),val2,GuardedBinary.getGuard(s)));
  if (isDiv) {
    EMIT(MIR_Move.create(IA32_MOV,result.copyD2D(),new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int)));
  }
 else {
    EMIT(MIR_Move.create(IA32_MOV,result.copyD2D(),new OPT_RegisterOperand(getEDX(),VM_TypeReference.Int)));
  }
}","/** 
 * Expansion of INT_DIV and INT_REM
 * @param s the instruction to expand
 * @param result the result operand
 * @param val1 the first operand
 * @param val2 the second operand
 * @param isDiv true for div, false for rem
 */
protected final void INT_DIVIDES(OPT_Instruction s,OPT_RegisterOperand result,OPT_Operand val1,OPT_Operand val2,boolean isDiv){
  EMIT(MIR_Move.create(IA32_MOV,new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int),val1));
  EMIT(MIR_ConvertDW2QW.create(IA32_CDQ,new OPT_RegisterOperand(getEDX(),VM_TypeReference.Int),new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int)));
  if (val2 instanceof OPT_IntConstantOperand) {
    OPT_RegisterOperand temp=regpool.makeTempInt();
    EMIT(MIR_Move.create(IA32_MOV,temp,val2));
    val2=temp.copyRO();
  }
  EMIT(MIR_Divide.mutate(s,IA32_IDIV,new OPT_RegisterOperand(getEDX(),VM_TypeReference.Int),new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int),val2,GuardedBinary.getGuard(s)));
  if (isDiv) {
    EMIT(MIR_Move.create(IA32_MOV,result.copyD2D(),new OPT_RegisterOperand(getEAX(),VM_TypeReference.Int)));
  }
 else {
    EMIT(MIR_Move.create(IA32_MOV,result.copyD2D(),new OPT_RegisterOperand(getEDX(),VM_TypeReference.Int)));
  }
}",0.996273291925466
150084,"/** 
 * Expansion of LOWTABLESWITCH.  
 * @param s the instruction to expand
 */
protected final void LOWTABLESWITCH(OPT_Instruction s){
  OPT_RegisterOperand newIndex=regpool.makeTempInt();
  EMIT(MIR_Move.create(IA32_MOV,newIndex,LowTableSwitch.getIndex(s)));
  int number=LowTableSwitch.getNumberOfTargets(s);
  OPT_Instruction s2=CPOS(s,MIR_LowTableSwitch.create(MIR_LOWTABLESWITCH,newIndex,number * 2));
  for (int i=0; i < number; i++) {
    MIR_LowTableSwitch.setTarget(s2,i,LowTableSwitch.getTarget(s,i));
    MIR_LowTableSwitch.setBranchProfile(s2,i,LowTableSwitch.getBranchProfile(s,i));
  }
  EMIT(s2);
}","/** 
 * Expansion of LOWTABLESWITCH.  
 * @param s the instruction to expand
 */
protected final void LOWTABLESWITCH(OPT_Instruction s){
  OPT_RegisterOperand newIndex=regpool.makeTempInt();
  EMIT(MIR_Move.create(IA32_MOV,newIndex,LowTableSwitch.getIndex(s)));
  int number=LowTableSwitch.getNumberOfTargets(s);
  OPT_Instruction s2=CPOS(s,MIR_LowTableSwitch.create(MIR_LOWTABLESWITCH,newIndex.copyRO(),number * 2));
  for (int i=0; i < number; i++) {
    MIR_LowTableSwitch.setTarget(s2,i,LowTableSwitch.getTarget(s,i));
    MIR_LowTableSwitch.setBranchProfile(s2,i,LowTableSwitch.getBranchProfile(s,i));
  }
  EMIT(s2);
}",0.9927360774818402
150085,"/** 
 * expand an FCLEAR pseudo-insruction using FFREEs.
 * @param s the instruction to expand
 * @param phys controlling physical register set
 */
private static void expandFClear(OPT_Instruction s,OPT_IR ir){
  int nSave=MIR_UnaryNoRes.getVal(s).asIntConstant().value;
  int fpStackHeight=ir.MIRInfo.fpStackHeight;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  for (int i=nSave; i < fpStackHeight; i++) {
    OPT_Register f=phys.getFPR(i);
    s.insertBefore(MIR_UnaryAcc.create(IA32_FFREE,D(f)));
  }
  s.remove();
}","/** 
 * expand an FCLEAR pseudo-insruction using FFREEs.
 * @param s the instruction to expand
 * @param phys controlling physical register set
 */
private static void expandFClear(OPT_Instruction s,OPT_IR ir){
  int nSave=MIR_UnaryNoRes.getVal(s).asIntConstant().value;
  int fpStackHeight=ir.MIRInfo.fpStackHeight;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  for (int i=nSave; i < fpStackHeight; i++) {
    OPT_Register f=phys.getFPR(i);
    s.insertBefore(MIR_Nullary.create(IA32_FFREE,D(f)));
  }
  s.remove();
}",0.9861751152073732
150086,"/** 
 * @param ir the IR to expand
 * @return return value is garbage for IA32
 */
public final static int expand(OPT_IR ir){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  for (OPT_Instruction next, p=ir.firstInstructionInCodeOrder(); p != null; p=next) {
    next=p.nextInstructionInCodeOrder();
    p.setmcOffset(-1);
    p.scratchObject=null;
switch (p.getOpcode()) {
case MIR_LOWTABLESWITCH_opcode:
{
        OPT_BasicBlock thisBlock=p.getBasicBlock();
        OPT_BasicBlock nextBlock=thisBlock.splitNodeWithLinksAt(p,ir);
        nextBlock.firstInstruction().setmcOffset(-1);
        int NumTargets=MIR_LowTableSwitch.getNumberOfTargets(p);
        for (int i=0; i < NumTargets; i++) {
          thisBlock.appendInstruction(MIR_CaseLabel.create(IA32_OFFSET,IC(i),MIR_LowTableSwitch.getClearTarget(p,i)));
        }
        OPT_Register regS=MIR_LowTableSwitch.getIndex(p).register;
        nextBlock.appendInstruction(MIR_BinaryAcc.create(IA32_SHL,new OPT_RegisterOperand(regS,VM_TypeReference.Int),IC(2)));
        nextBlock.appendInstruction(MIR_BinaryAcc.create(IA32_ADD,new OPT_RegisterOperand(regS,VM_TypeReference.Int),OPT_MemoryOperand.I(new OPT_RegisterOperand(phys.getESP(),VM_TypeReference.Int),(byte)4,null,null)));
        nextBlock.appendInstruction(MIR_Move.create(IA32_MOV,new OPT_RegisterOperand(regS,VM_TypeReference.Int),OPT_MemoryOperand.I(new OPT_RegisterOperand(regS,VM_TypeReference.Int),(byte)4,null,null)));
        nextBlock.appendInstruction(MIR_BinaryAcc.create(IA32_ADD,OPT_MemoryOperand.I(new OPT_RegisterOperand(phys.getESP(),VM_TypeReference.Int),(byte)4,null,null),new OPT_RegisterOperand(regS,VM_TypeReference.Int)));
        nextBlock.appendInstruction(MIR_Return.create(IA32_RET,IC(0),null,null));
        MIR_Call.mutate0(p,IA32_CALL,null,null,nextBlock.makeJumpTarget(),null);
      }
    break;
case IA32_TEST_opcode:
  if (MIR_Test.getVal2(p).isMemory()) {
    OPT_Operand tmp=MIR_Test.getClearVal1(p);
    MIR_Test.setVal1(p,MIR_Test.getClearVal2(p));
    MIR_Test.setVal2(p,tmp);
  }
break;
case NULL_CHECK_opcode:
{
OPT_Operand ref=NullCheck.getRef(p);
MIR_TrapIf.mutate(p,IA32_TRAPIF,null,ref.copy(),IC(0),OPT_IA32ConditionOperand.EQ(),OPT_TrapCodeOperand.NullPtr());
}
case IA32_TRAPIF_opcode:
{
OPT_BasicBlock thisBlock=p.getBasicBlock();
OPT_BasicBlock trap=thisBlock.createSubBlock(p.bcIndex,ir,0f);
OPT_BasicBlock nextBlock=thisBlock.splitNodeWithLinksAt(p,ir);
OPT_TrapCodeOperand tc=MIR_TrapIf.getClearTrapCode(p);
p.remove();
nextBlock.firstInstruction().setmcOffset(-1);
OPT_Instruction cmp=MIR_Compare.create(IA32_CMP,MIR_TrapIf.getVal1(p),MIR_TrapIf.getVal2(p));
if (p.isMarkedAsPEI()) {
cmp.markAsPEI();
cmp.copyPosition(p);
ir.MIRInfo.gcIRMap.insertTwin(p,cmp);
}
thisBlock.appendInstruction(cmp);
thisBlock.appendInstruction(MIR_CondBranch.create(IA32_JCC,MIR_TrapIf.getCond(p),trap.makeJumpTarget(),null));
ir.cfg.addLastInCodeOrder(trap);
if (tc.isArrayBounds()) {
OPT_Operand index=MIR_TrapIf.getVal2(p);
if (!(index instanceof OPT_RegisterOperand || index instanceof OPT_IntConstantOperand)) {
  index=IC(0xdeadbeef);
}
OPT_MemoryOperand mo=OPT_MemoryOperand.BD(new OPT_RegisterOperand(phys.getPR(),VM_TypeReference.Int),VM_Entrypoints.arrayIndexTrapParamField.getOffset(),(byte)4,null,null);
trap.appendInstruction(MIR_Move.create(IA32_MOV,mo,index.copy()));
}
trap.appendInstruction(MIR_Trap.mutate(p,IA32_INT,null,tc));
ir.MIRInfo.gcIRMap.moveToEnd(p);
if (tc.isStackOverflow()) {
trap.appendInstruction(MIR_Branch.create(IA32_JMP,nextBlock.makeJumpTarget()));
}
}
break;
case IA32_FMOV_ENDING_LIVE_RANGE_opcode:
OPT_Operand result=MIR_Move.getResult(p);
OPT_Operand value=MIR_Move.getValue(p);
if (result.isRegister() && value.isRegister()) {
if (result.similar(value)) {
p.remove();
}
 else {
int i=OPT_PhysicalRegisterSet.getFPRIndex(result.asRegister().register);
int j=OPT_PhysicalRegisterSet.getFPRIndex(value.asRegister().register);
if (i == 0) {
MIR_XChng.mutate(p,IA32_FXCH,result,value);
}
 else if (j == 0) {
MIR_XChng.mutate(p,IA32_FXCH,value,result);
}
 else {
expandFmov(p,phys);
}
}
}
 else {
expandFmov(p,phys);
}
break;
case DUMMY_DEF_opcode:
case DUMMY_USE_opcode:
case REQUIRE_ESP_opcode:
case ADVISE_ESP_opcode:
p.remove();
break;
case IA32_FMOV_opcode:
expandFmov(p,phys);
break;
case IA32_FCLEAR_opcode:
expandFClear(p,ir);
break;
case IA32_JCC2_opcode:
p.insertBefore(MIR_CondBranch.create(IA32_JCC,MIR_CondBranch2.getCond1(p),MIR_CondBranch2.getTarget1(p),MIR_CondBranch2.getBranchProfile1(p)));
MIR_CondBranch.mutate(p,IA32_JCC,MIR_CondBranch2.getCond2(p),MIR_CondBranch2.getTarget2(p),MIR_CondBranch2.getBranchProfile2(p));
break;
case CALL_SAVE_VOLATILE_opcode:
p.operator=IA32_CALL;
break;
case IA32_LOCK_CMPXCHG_opcode:
p.insertBefore(MIR_Empty.create(IA32_LOCK));
p.operator=IA32_CMPXCHG;
break;
case YIELDPOINT_PROLOGUE_opcode:
expandYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromPrologueMethod,OPT_IA32ConditionOperand.NE());
break;
case YIELDPOINT_EPILOGUE_opcode:
expandYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromEpilogueMethod,OPT_IA32ConditionOperand.NE());
break;
case YIELDPOINT_BACKEDGE_opcode:
expandYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromBackedgeMethod,OPT_IA32ConditionOperand.GT());
break;
case YIELDPOINT_OSR_opcode:
expandUnconditionalYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromOsrOptMethod);
break;
case IR_ENDPROLOGUE_opcode:
p.remove();
ir.MIRInfo.instAfterPrologue=next;
break;
}
}
return 0;
}","/** 
 * @param ir the IR to expand
 * @return return value is garbage for IA32
 */
public final static int expand(OPT_IR ir){
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  for (OPT_Instruction next, p=ir.firstInstructionInCodeOrder(); p != null; p=next) {
    next=p.nextInstructionInCodeOrder();
    p.setmcOffset(-1);
    p.scratchObject=null;
switch (p.getOpcode()) {
case MIR_LOWTABLESWITCH_opcode:
{
        OPT_BasicBlock thisBlock=p.getBasicBlock();
        OPT_BasicBlock nextBlock=thisBlock.splitNodeWithLinksAt(p,ir);
        nextBlock.firstInstruction().setmcOffset(-1);
        int NumTargets=MIR_LowTableSwitch.getNumberOfTargets(p);
        for (int i=0; i < NumTargets; i++) {
          thisBlock.appendInstruction(MIR_CaseLabel.create(IA32_OFFSET,IC(i),MIR_LowTableSwitch.getClearTarget(p,i)));
        }
        OPT_Register regS=MIR_LowTableSwitch.getIndex(p).register;
        nextBlock.appendInstruction(MIR_BinaryAcc.create(IA32_SHL,new OPT_RegisterOperand(regS,VM_TypeReference.Int),IC(2)));
        nextBlock.appendInstruction(MIR_BinaryAcc.create(IA32_ADD,new OPT_RegisterOperand(regS,VM_TypeReference.Int),OPT_MemoryOperand.I(new OPT_RegisterOperand(phys.getESP(),VM_TypeReference.Int),(byte)4,null,null)));
        nextBlock.appendInstruction(MIR_Move.create(IA32_MOV,new OPT_RegisterOperand(regS,VM_TypeReference.Int),OPT_MemoryOperand.I(new OPT_RegisterOperand(regS,VM_TypeReference.Int),(byte)4,null,null)));
        nextBlock.appendInstruction(MIR_BinaryAcc.create(IA32_ADD,OPT_MemoryOperand.I(new OPT_RegisterOperand(phys.getESP(),VM_TypeReference.Int),(byte)4,null,null),new OPT_RegisterOperand(regS,VM_TypeReference.Int)));
        nextBlock.appendInstruction(MIR_Return.create(IA32_RET,IC(0),null,null));
        MIR_Call.mutate0(p,IA32_CALL,null,null,nextBlock.makeJumpTarget(),null);
      }
    break;
case IA32_TEST_opcode:
  if (MIR_Test.getVal2(p).isMemory()) {
    OPT_Operand tmp=MIR_Test.getClearVal1(p);
    MIR_Test.setVal1(p,MIR_Test.getClearVal2(p));
    MIR_Test.setVal2(p,tmp);
  }
break;
case NULL_CHECK_opcode:
{
OPT_Operand ref=NullCheck.getRef(p);
MIR_TrapIf.mutate(p,IA32_TRAPIF,null,ref.copy(),IC(0),OPT_IA32ConditionOperand.EQ(),OPT_TrapCodeOperand.NullPtr());
}
case IA32_TRAPIF_opcode:
{
OPT_BasicBlock thisBlock=p.getBasicBlock();
OPT_BasicBlock trap=thisBlock.createSubBlock(p.bcIndex,ir,0f);
thisBlock.insertOut(trap);
OPT_BasicBlock nextBlock=thisBlock.splitNodeWithLinksAt(p,ir);
OPT_TrapCodeOperand tc=MIR_TrapIf.getClearTrapCode(p);
p.remove();
nextBlock.firstInstruction().setmcOffset(-1);
OPT_Instruction cmp=MIR_Compare.create(IA32_CMP,MIR_TrapIf.getVal1(p),MIR_TrapIf.getVal2(p));
if (p.isMarkedAsPEI()) {
cmp.markAsPEI();
cmp.copyPosition(p);
ir.MIRInfo.gcIRMap.insertTwin(p,cmp);
}
thisBlock.appendInstruction(cmp);
thisBlock.appendInstruction(MIR_CondBranch.create(IA32_JCC,MIR_TrapIf.getCond(p),trap.makeJumpTarget(),null));
ir.cfg.addLastInCodeOrder(trap);
if (tc.isArrayBounds()) {
OPT_Operand index=MIR_TrapIf.getVal2(p);
if (!(index instanceof OPT_RegisterOperand || index instanceof OPT_IntConstantOperand)) {
  index=IC(0xdeadbeef);
}
OPT_MemoryOperand mo=OPT_MemoryOperand.BD(new OPT_RegisterOperand(phys.getPR(),VM_TypeReference.Int),VM_Entrypoints.arrayIndexTrapParamField.getOffset(),(byte)4,null,null);
trap.appendInstruction(MIR_Move.create(IA32_MOV,mo,index.copy()));
}
trap.appendInstruction(MIR_Trap.mutate(p,IA32_INT,null,tc));
ir.MIRInfo.gcIRMap.moveToEnd(p);
if (tc.isStackOverflow()) {
trap.appendInstruction(MIR_Branch.create(IA32_JMP,nextBlock.makeJumpTarget()));
}
}
break;
case IA32_FMOV_ENDING_LIVE_RANGE_opcode:
OPT_Operand result=MIR_Move.getResult(p);
OPT_Operand value=MIR_Move.getValue(p);
if (result.isRegister() && value.isRegister()) {
if (result.similar(value)) {
p.remove();
}
 else {
int i=OPT_PhysicalRegisterSet.getFPRIndex(result.asRegister().register);
int j=OPT_PhysicalRegisterSet.getFPRIndex(value.asRegister().register);
if (i == 0) {
MIR_XChng.mutate(p,IA32_FXCH,result,value);
}
 else if (j == 0) {
MIR_XChng.mutate(p,IA32_FXCH,value,result);
}
 else {
expandFmov(p,phys);
}
}
}
 else {
expandFmov(p,phys);
}
break;
case DUMMY_DEF_opcode:
case DUMMY_USE_opcode:
case REQUIRE_ESP_opcode:
case ADVISE_ESP_opcode:
p.remove();
break;
case IA32_FMOV_opcode:
expandFmov(p,phys);
break;
case IA32_FCLEAR_opcode:
expandFClear(p,ir);
break;
case IA32_JCC2_opcode:
p.insertBefore(MIR_CondBranch.create(IA32_JCC,MIR_CondBranch2.getCond1(p),MIR_CondBranch2.getTarget1(p),MIR_CondBranch2.getBranchProfile1(p)));
MIR_CondBranch.mutate(p,IA32_JCC,MIR_CondBranch2.getCond2(p),MIR_CondBranch2.getTarget2(p),MIR_CondBranch2.getBranchProfile2(p));
break;
case CALL_SAVE_VOLATILE_opcode:
p.operator=IA32_CALL;
break;
case IA32_LOCK_CMPXCHG_opcode:
p.insertBefore(MIR_Empty.create(IA32_LOCK));
p.operator=IA32_CMPXCHG;
break;
case YIELDPOINT_PROLOGUE_opcode:
expandYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromPrologueMethod,OPT_IA32ConditionOperand.NE());
break;
case YIELDPOINT_EPILOGUE_opcode:
expandYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromEpilogueMethod,OPT_IA32ConditionOperand.NE());
break;
case YIELDPOINT_BACKEDGE_opcode:
expandYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromBackedgeMethod,OPT_IA32ConditionOperand.GT());
break;
case YIELDPOINT_OSR_opcode:
expandUnconditionalYieldpoint(p,ir,VM_Entrypoints.optThreadSwitchFromOsrOptMethod);
break;
case IR_ENDPROLOGUE_opcode:
p.remove();
ir.MIRInfo.instAfterPrologue=next;
break;
}
}
return 0;
}",0.9975358218490464
150087,"/** 
 * Work around some problems with PEI-generated values and  handlers.  Namely, if a PEI has a return value, rename the result register before and after the PEI in order to reflect the fact that the PEI may not actually assign the result register.
 */
private void patchPEIgeneratedValues(){
  if (!ir.hasReachableExceptionHandlers())   return;
  HashSet needed=new HashSet(4);
  OPT_BasicBlockEnumeration blocks=ir.getBasicBlocks();
  while (blocks.hasMoreElements()) {
    OPT_BasicBlock block=blocks.next();
    if (block.getExceptionalOut().hasMoreElements()) {
      OPT_Instruction pei=block.lastRealInstruction();
      if (pei != null && pei.isPEI() && ResultCarrier.conforms(pei)) {
        boolean copyNeeded=false;
        OPT_RegisterOperand v=ResultCarrier.getResult(pei);
        if (v != null) {
          OPT_Register orig=v.register;
{
            OPT_BasicBlockEnumeration out=block.getApplicableExceptionalOut(pei);
            while (out.hasMoreElements()) {
              OPT_BasicBlock exp=out.next();
              OPT_LiveSet explive=live.getLiveInfo(exp).in();
              if (explive.contains(orig)) {
                copyNeeded=true;
                break;
              }
            }
          }
          if (copyNeeded) {
            OPT_BasicBlockEnumeration out=block.getApplicableExceptionalOut(pei);
            while (out.hasMoreElements()) {
              OPT_BasicBlock exp=out.next();
              needed.add(new OPT_Pair(exp,v));
            }
          }
        }
      }
    }
  }
  Iterator copies=needed.iterator();
  while (copies.hasNext()) {
    OPT_Pair copy=(OPT_Pair)copies.next();
    OPT_BasicBlock inBlock=(OPT_BasicBlock)copy.first;
    OPT_RegisterOperand registerOp=(OPT_RegisterOperand)copy.second;
    VM_TypeReference type=registerOp.type;
    OPT_Register register=registerOp.register;
    OPT_Register temp=ir.regpool.getReg(register);
    inBlock.prependInstruction(OPT_SSA.makeMoveInstruction(ir,register,temp,type));
    OPT_LiveAnalysis.BBLiveElement inl=live.getLiveInfo(inBlock);
    inl.gen().add(new OPT_RegisterOperand(temp,type));
    inl.in().add(new OPT_RegisterOperand(temp,type));
    OPT_BasicBlockEnumeration outBlocks=inBlock.getIn();
    while (outBlocks.hasMoreElements()) {
      OPT_BasicBlock outBlock=outBlocks.next();
      OPT_Instruction x=OPT_SSA.makeMoveInstruction(ir,temp,register,type);
      OPT_SSA.addAtEnd(ir,outBlock,x,true);
      OPT_LiveAnalysis.BBLiveElement ol=live.getLiveInfo(outBlock);
      ol.BBKillSet().add(new OPT_RegisterOperand(temp,type));
    }
  }
}","/** 
 * Work around some problems with PEI-generated values and  handlers.  Namely, if a PEI has a return value, rename the result register before and after the PEI in order to reflect the fact that the PEI may not actually assign the result register.
 */
private void patchPEIgeneratedValues(){
  if (!ir.hasReachableExceptionHandlers())   return;
  HashSet needed=new HashSet(4);
  OPT_BasicBlockEnumeration blocks=ir.getBasicBlocks();
  while (blocks.hasMoreElements()) {
    OPT_BasicBlock block=blocks.next();
    if (block.getExceptionalOut().hasMoreElements()) {
      OPT_Instruction pei=block.lastRealInstruction();
      if (pei != null && pei.isPEI() && ResultCarrier.conforms(pei)) {
        boolean copyNeeded=false;
        OPT_RegisterOperand v=ResultCarrier.getResult(pei);
        if (v != null) {
          OPT_Register orig=v.register;
{
            OPT_BasicBlockEnumeration out=block.getApplicableExceptionalOut(pei);
            while (out.hasMoreElements()) {
              OPT_BasicBlock exp=out.next();
              OPT_LiveSet explive=live.getLiveInfo(exp).in();
              if (explive.contains(orig)) {
                copyNeeded=true;
                break;
              }
            }
          }
          if (copyNeeded) {
            OPT_BasicBlockEnumeration out=block.getApplicableExceptionalOut(pei);
            while (out.hasMoreElements()) {
              OPT_BasicBlock exp=out.next();
              needed.add(new OPT_Pair(exp,v));
            }
          }
        }
      }
    }
  }
  if (!needed.isEmpty()) {
    for (Iterator copies=needed.iterator(); copies.hasNext(); ) {
      OPT_Pair copy=(OPT_Pair)copies.next();
      OPT_BasicBlock inBlock=(OPT_BasicBlock)copy.first;
      OPT_RegisterOperand registerOp=(OPT_RegisterOperand)copy.second;
      VM_TypeReference type=registerOp.type;
      OPT_Register register=registerOp.register;
      OPT_Register temp=ir.regpool.getReg(register);
      inBlock.prependInstruction(OPT_SSA.makeMoveInstruction(ir,register,temp,type));
      OPT_BasicBlockEnumeration outBlocks=inBlock.getIn();
      while (outBlocks.hasMoreElements()) {
        OPT_BasicBlock outBlock=outBlocks.next();
        OPT_Instruction x=OPT_SSA.makeMoveInstruction(ir,temp,register,type);
        OPT_SSA.addAtEnd(ir,outBlock,x,true);
      }
    }
    prepare();
  }
}",0.8972533062054934
150088,"/** 
 * removes the head element from the list
 */
final public OPT_LinkedListElement removeHead(){
  if (start == null)   return null;
  OPT_LinkedListElement result=start;
  start=result.next;
  result.next=null;
  return result;
}","/** 
 * removes the head element from the list
 */
final public OPT_LinkedListElement removeHead(){
  if (start == null)   return null;
  OPT_LinkedListElement result=start;
  start=result.next;
  if (start == null)   end=null;
  result.next=null;
  return result;
}",0.933867735470942
150089,"private final int genCode(OPT_IR ir,boolean shouldPrint){
  int mi=0;
  VM_CodeArray machinecodes=ir.MIRInfo.machinecode;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  boolean unsafeCondDispl=machinecodes.length() > MAX_COND_DISPL;
  boolean unsafeDispl=machinecodes.length() > MAX_DISPL;
  for (OPT_Instruction p=ir.firstInstructionInCodeOrder(); p != null; p=p.nextInstructionInCodeOrder()) {
    int inst=p.operator().instTemplate;
switch (p.getOpcode()) {
case LABEL_opcode:
      for (BranchSrcElement bSrc=(BranchSrcElement)p.scratchObject; bSrc != null; bSrc=bSrc.next) {
        OPT_Instruction branchStmt=bSrc.source;
        int bo=branchStmt.getmcOffset() - (1 << LG_INSTRUCTION_WIDTH);
        int bi=bo >> LG_INSTRUCTION_WIDTH;
        int targetOffset=(mi - bi) << LG_INSTRUCTION_WIDTH;
        boolean setLink=false;
        if (targetOffset > MAX_DISPL << LG_INSTRUCTION_WIDTH) {
          throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"",targetOffset);
        }
switch (branchStmt.getOpcode()) {
case PPC_B_opcode:
case PPC_BL_opcode:
          machinecodes.set(bi,machinecodes.get(bi) | targetOffset & LI_MASK);
        break;
case PPC_DATA_LABEL_opcode:
      machinecodes.set(bi,targetOffset & LI_MASK);
    break;
case IG_PATCH_POINT_opcode:
  break;
case PPC_BCL_opcode:
setLink=true;
default :
if (targetOffset <= MAX_COND_DISPL << 2) {
machinecodes.set(bi,machinecodes.get(bi) | targetOffset & BD_MASK);
if (DEBUG) {
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(disasm(machinecodes.get(bi),0) + ""String_Node_Str"");
}
}
 else {
branchStmt.setmcOffset(branchStmt.getmcOffset() + (1 << LG_INSTRUCTION_WIDTH));
machinecodes.set(bi,flipCondition(machinecodes.get(bi)));
machinecodes.set(bi,machinecodes.get(bi) | (2 << LG_INSTRUCTION_WIDTH));
machinecodes.set(bi,machinecodes.get(bi) & 0xfffffffe);
machinecodes.set(bi + 1,Btemplate | ((targetOffset - 4) & LI_MASK));
if (setLink) machinecodes.set(bi + 1,machinecodes.get(bi + 1) | 1);
if (DEBUG) {
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(disasm(machinecodes.get(bi),0) + ""String_Node_Str"");
  VM.sysWrite(disasm(machinecodes.get(bi + 1),0) + ""String_Node_Str"");
}
}
break;
}
unresolvedBranches--;
}
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
break;
case BBEND_opcode:
case UNINT_BEGIN_opcode:
case UNINT_END_opcode:
case GUARD_MOVE_opcode:
case GUARD_COMBINE_opcode:
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
break;
case PPC_DATA_INT_opcode:
{
int value=MIR_DataInt.getValue(p).value;
machinecodes.set(mi++,value);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_DATA_LABEL_opcode:
{
OPT_Instruction target=MIR_DataLabel.getTarget(p).target;
int targetOffset=resolveBranch(p,target,mi);
machinecodes.set(mi++,targetOffset);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_CRAND_opcode:
case PPC_CRANDC_opcode:
case PPC_CROR_opcode:
case PPC_CRORC_opcode:
{
int op0=MIR_Condition.getResultBit(p).value & REG_MASK;
int op1=MIR_Condition.getValue1Bit(p).value & REG_MASK;
int op2=MIR_Condition.getValue2Bit(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ADD_opcode:
case PPC_ADDr_opcode:
case PPC_ADDC_opcode:
case PPC_ADDE_opcode:
case PPC_SUBF_opcode:
case PPC_SUBFr_opcode:
case PPC_SUBFC_opcode:
case PPC_SUBFCr_opcode:
case PPC_SUBFE_opcode:
case PPC_FADD_opcode:
case PPC_FADDS_opcode:
case PPC_FDIV_opcode:
case PPC_FDIVS_opcode:
case PPC_DIVW_opcode:
case PPC_DIVWU_opcode:
case PPC_MULLW_opcode:
case PPC_MULHW_opcode:
case PPC_MULHWU_opcode:
case PPC_FSUB_opcode:
case PPC_FSUBS_opcode:
case PPC64_MULLD_opcode:
case PPC64_DIVD_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZX_opcode:
case PPC_LWARX_opcode:
case PPC_LBZX_opcode:
case PPC_LHAX_opcode:
case PPC_LHZX_opcode:
case PPC_LFDX_opcode:
case PPC_LFSX_opcode:
case PPC_LIntX_opcode:
case PPC_LAddrARX_opcode:
case PPC_LAddrX_opcode:
case PPC64_LDX_opcode:
{
int op0=MIR_Load.getResult(p).register.number & REG_MASK;
int op1=MIR_Load.getAddress(p).register.number & REG_MASK;
int op2=MIR_Load.getOffset(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STWX_opcode:
case PPC_STWCXr_opcode:
case PPC_STBX_opcode:
case PPC_STHX_opcode:
case PPC_STFDX_opcode:
case PPC_STFSX_opcode:
case PPC_STAddrCXr_opcode:
case PPC_STAddrX_opcode:
case PPC_STAddrUX_opcode:
{
int op0=MIR_Store.getValue(p).register.number & REG_MASK;
int op1=MIR_Store.getAddress(p).register.number & REG_MASK;
int op2=MIR_Store.getOffset(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZUX_opcode:
case PPC_LBZUX_opcode:
case PPC_LIntUX_opcode:
case PPC_LAddrUX_opcode:
{
int op0=MIR_LoadUpdate.getResult(p).register.number & REG_MASK;
int op1=MIR_LoadUpdate.getAddress(p).register.number & REG_MASK;
int op2=MIR_LoadUpdate.getOffset(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZU_opcode:
{
int op0=MIR_LoadUpdate.getResult(p).register.number & REG_MASK;
int op1=MIR_LoadUpdate.getAddress(p).register.number & REG_MASK;
int op2=MIR_LoadUpdate.getOffset(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_TW_opcode:
case PPC_TAddr_opcode:
case PPC64_TD_opcode:
{
int op0=MIR_Trap.getCond(p).value;
int op1=MIR_Trap.getValue1(p).register.number & REG_MASK;
int op2=MIR_Trap.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_TWI_opcode:
case PPC64_TDI_opcode:
{
int op0=MIR_Trap.getCond(p).value;
int op1=MIR_Trap.getValue1(p).register.number & REG_MASK;
int op2=MIR_Trap.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case NULL_CHECK_opcode:
{
int op0=OPT_PowerPCTrapOperand.LOWER;
int op1=((OPT_RegisterOperand)NullCheck.getRef(p)).register.number & REG_MASK;
int op2=1;
inst=PPC64_TDI.instTemplate;
inst=PPC_TWI.instTemplate;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LDI_opcode:
case PPC_LDIS_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | op1));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ADDIC_opcode:
case PPC_ADDICr_opcode:
case PPC_SUBFIC_opcode:
case PPC_MULLI_opcode:
case PPC_ADDI_opcode:
case PPC_ADDIS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_CNTLZW_opcode:
case PPC_CNTLZAddr_opcode:
case PPC_EXTSB_opcode:
case PPC_EXTSBr_opcode:
case PPC_EXTSH_opcode:
case PPC_EXTSHr_opcode:
case PPC64_EXTSW_opcode:
case PPC64_EXTSWr_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_EXTZW_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
int op3high=1;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ADDZE_opcode:
case PPC_SUBFZE_opcode:
case PPC_NEG_opcode:
case PPC_NEGr_opcode:
case PPC_ADDME_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_XORI_opcode:
case PPC_XORIS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_AND_opcode:
case PPC_ANDr_opcode:
case PPC_NAND_opcode:
case PPC_NANDr_opcode:
case PPC_ANDC_opcode:
case PPC_ANDCr_opcode:
case PPC_OR_opcode:
case PPC_ORr_opcode:
case PPC_NOR_opcode:
case PPC_NORr_opcode:
case PPC_ORC_opcode:
case PPC_ORCr_opcode:
case PPC_XOR_opcode:
case PPC_XORr_opcode:
case PPC_EQV_opcode:
case PPC_EQVr_opcode:
case PPC_SLW_opcode:
case PPC_SLWr_opcode:
case PPC_SRW_opcode:
case PPC_SRWr_opcode:
case PPC_SRAW_opcode:
case PPC_SRAWr_opcode:
case PPC64_SLD_opcode:
case PPC64_SLDr_opcode:
case PPC64_SRD_opcode:
case PPC64_SRDr_opcode:
case PPC64_SRAD_opcode:
case PPC64_SRADr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MOVE_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
int op1=MIR_Move.getValue(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAddrI_opcode:
case PPC_SRWI_opcode:
case PPC_SRWIr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int shift=MIR_Binary.getValue2(p).asIntConstant().value & REG_MASK;
int op2=(32 - shift);
int op3=shift;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SLWI_opcode:
case PPC_SLWIr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int shift=MIR_Binary.getValue2(p).asIntConstant().value & REG_MASK;
int op2=shift;
int op3=(31 - shift);
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAAddrI_opcode:
case PPC_SRAWI_opcode:
case PPC_SRAWIr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAAddrI_opcode:
case PPC64_SRADI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SIXBIT_MASK;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAddrI_opcode:
case PPC64_SRDI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op3=MIR_Binary.getValue2(p).asIntConstant().value & SIXBIT_MASK;
int op2=64 - op3;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_SLDI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int shift=MIR_Binary.getValue2(p).asIntConstant().value & SIXBIT_MASK;
int op2=shift;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3=63 - shift;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_RLDICR_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & SIXBIT_MASK;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3=MIR_RotateAndMask.getMaskEnd(p).value & SIXBIT_MASK;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
if (VM.VerifyAssertions) {
int op4=MIR_RotateAndMask.getMaskBegin(p).value & SIXBIT_MASK;
VM._assert(op4 == 0);
}
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_RLDICL_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & SIXBIT_MASK;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & SIXBIT_MASK;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
if (VM.VerifyAssertions) {
int op4=MIR_RotateAndMask.getMaskEnd(p).value & SIXBIT_MASK;
VM._assert(op4 == 63);
}
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ANDIr_opcode:
case PPC_ANDISr_opcode:
case PPC_ORI_opcode:
case PPC_ORIS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_RLWINM_opcode:
case PPC_RLWINMr_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & REG_MASK;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & REG_MASK;
int op4=MIR_RotateAndMask.getMaskEnd(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)| (op4 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_RLWIMI_opcode:
case PPC_RLWIMIr_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op0f=MIR_RotateAndMask.getSource(p).register.number & REG_MASK;
if (op0 != op0f) throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"");
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & REG_MASK;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & REG_MASK;
int op4=MIR_RotateAndMask.getMaskEnd(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)| (op4 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_RLWNM_opcode:
case PPC_RLWNMr_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asRegister().register.number & REG_MASK;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & REG_MASK;
int op4=MIR_RotateAndMask.getMaskEnd(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)| (op4 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_B_opcode:
{
OPT_BranchOperand o=MIR_Branch.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
machinecodes.set(mi++,inst | (targetOffset & LI_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BLR_opcode:
case PPC_BCTR_opcode:
{
machinecodes.set(mi++,inst);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BC_opcode:
case PPC_BCOND_opcode:
case PPC_BCC_opcode:
{
int op0=MIR_CondBranch.getValue(p).register.number & REG_MASK;
int op1=MIR_CondBranch.getCond(p).value;
int bo_bi=op0 << 2 | op1;
OPT_BranchOperand o=MIR_CondBranch.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
if (targetOffset == 0) {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
if (unsafeCondDispl) {
machinecodes.set(mi++,NOPtemplate);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
 else if (targetOffset < MIN_COND_DISPL << 2) {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
machinecodes.set(mi++,inst | flipCondition(bo_bi << 16) | (2 << 2));
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
machinecodes.set(mi++,Btemplate | ((targetOffset - 4) & LI_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
 else {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16) | (targetOffset & BD_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
break;
case PPC_BCLR_opcode:
case PPC_BCCTR_opcode:
{
int op0=MIR_CondBranch.getValue(p).register.number & REG_MASK;
int op1=MIR_CondBranch.getCond(p).value;
int bo_bi=op0 << 2 | op1;
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0));
}
break;
case PPC_BL_opcode:
case PPC_BL_SYS_opcode:
{
OPT_BranchOperand o=(OPT_BranchOperand)MIR_Call.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
machinecodes.set(mi++,inst | (targetOffset & LI_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BLRL_opcode:
case PPC_BCTRL_opcode:
case PPC_BCTRL_SYS_opcode:
{
machinecodes.set(mi++,inst);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BCL_opcode:
{
int op0=MIR_CondCall.getValue(p).register.number & REG_MASK;
int op1=MIR_CondCall.getCond(p).value;
int bo_bi=op0 << 2 | op1;
OPT_BranchOperand o=(OPT_BranchOperand)MIR_CondCall.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
if (targetOffset == 0) {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
if (unsafeCondDispl) {
machinecodes.set(mi++,NOPtemplate);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
 else if (targetOffset < MIN_COND_DISPL << 2) {
throw new OPT_OperationNotImplementedException(""String_Node_Str"");
}
 else {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16) | (targetOffset & BD_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
break;
case PPC_BCLRL_opcode:
{
int op0=MIR_CondCall.getValue(p).register.number & REG_MASK;
int op1=MIR_CondCall.getCond(p).value;
int bo_bi=op0 << 2 | op1;
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0));
}
break;
case PPC_CMP_opcode:
case PPC_CMPL_opcode:
case PPC64_CMP_opcode:
case PPC64_CMPL_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 23) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_CMPI_opcode:
case PPC_CMPLI_opcode:
case PPC64_CMPI_opcode:
case PPC64_CMPLI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 23) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FMR_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
int op1=MIR_Move.getValue(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FABS_opcode:
case PPC_FNEG_opcode:
case PPC_FRSP_opcode:
case PPC_FCTIW_opcode:
case PPC_FCTIWZ_opcode:
case PPC64_FCFID_opcode:
case PPC64_FCTIDZ_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FCMPO_opcode:
case PPC_FCMPU_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 23) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FMUL_opcode:
case PPC_FMULS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 6)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FMADD_opcode:
case PPC_FMADDS_opcode:
case PPC_FMSUB_opcode:
case PPC_FMSUBS_opcode:
case PPC_FNMADD_opcode:
case PPC_FNMADDS_opcode:
case PPC_FNMSUB_opcode:
case PPC_FNMSUBS_opcode:
case PPC_FSEL_opcode:
{
int op0=MIR_Ternary.getResult(p).register.number & REG_MASK;
int op1=MIR_Ternary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Ternary.getValue2(p).register.number & REG_MASK;
int op3=MIR_Ternary.getValue3(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 6)| (op3 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZ_opcode:
case PPC_LBZ_opcode:
case PPC_LHA_opcode:
case PPC_LHZ_opcode:
case PPC_LFD_opcode:
case PPC_LFS_opcode:
case PPC_LMW_opcode:
case PPC_LAddr_opcode:
case PPC_LInt_opcode:
{
int op0=MIR_Load.getResult(p).register.number & REG_MASK;
int op1=MIR_Load.getOffset(p).asIntConstant().value & SHORT_MASK;
int op2=MIR_Load.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | op1| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_LD_opcode:
case PPC_LAddr_opcode:
case PPC_LInt_opcode:
{
int op0=MIR_Load.getResult(p).register.number & REG_MASK;
int op1=(MIR_Load.getOffset(p).asIntConstant().value >> 2) & SHORT14_MASK;
int op2=MIR_Load.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 2)| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STW_opcode:
case PPC_STB_opcode:
case PPC_STH_opcode:
case PPC_STFD_opcode:
case PPC_STFS_opcode:
case PPC_STMW_opcode:
case PPC_STAddr_opcode:
{
int op0=MIR_Store.getValue(p).register.number & REG_MASK;
int op1=MIR_Store.getOffset(p).asIntConstant().value & SHORT_MASK;
int op2=MIR_Store.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | op1| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STAddrU_opcode:
case PPC_STWU_opcode:
case PPC_STFDU_opcode:
case PPC_STFSU_opcode:
{
int op0=MIR_StoreUpdate.getValue(p).register.number & REG_MASK;
int op1=MIR_StoreUpdate.getAddress(p).register.number & REG_MASK;
int op2=MIR_StoreUpdate.getOffset(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_STD_opcode:
case PPC_STAddr_opcode:
{
int op0=MIR_Store.getValue(p).register.number & REG_MASK;
int op1=(MIR_Store.getOffset(p).asIntConstant().value >> 2) & SHORT14_MASK;
int op2=MIR_Store.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 2)| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STAddrU_opcode:
{
int op0=MIR_StoreUpdate.getValue(p).register.number & REG_MASK;
int op1=(MIR_StoreUpdate.getOffset(p).asIntConstant().value >> 2) & SHORT14_MASK;
int op2=MIR_StoreUpdate.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 2)| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MFSPR_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
int op1=phys.getSPR(MIR_Move.getValue(p).register);
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MTSPR_opcode:
{
int op0=phys.getSPR(MIR_Move.getResult(p).register);
int op1=MIR_Move.getValue(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MFTB_opcode:
case PPC_MFTBU_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SYNC_opcode:
case PPC_ISYNC_opcode:
{
machinecodes.set(mi++,inst);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_DCBST_opcode:
case PPC_DCBF_opcode:
case PPC_ICBI_opcode:
{
int op0=MIR_CacheOp.getAddress(p).register.number & REG_MASK;
int op1=MIR_CacheOp.getOffset(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case IG_PATCH_POINT_opcode:
{
OPT_BranchOperand bop=InlineGuard.getTarget(p);
OPT_Instruction target=bop.target;
if (VM.VerifyAssertions) {
VM._assert(target.getOpcode() == LABEL_opcode);
}
int targetOffset=resolveBranch(p,target,mi);
machinecodes.set(mi++,NOPtemplate);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG_CODE_PATCH) {
VM.sysWrite(""String_Node_Str"",mi - 1);
VM.sysWrite(""String_Node_Str"");
VM.sysWriteHex(machinecodes.get(mi - 1));
VM.sysWrite(""String_Node_Str"");
}
}
break;
default :
throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"",p);
}
}
if (unresolvedBranches != 0) throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"");
if (shouldPrint) {
OPT_Compiler.header(""String_Node_Str"",ir.method);
for (int i=0; i < machinecodes.length(); i++) {
System.out.print(VM_Services.getHexString(i << LG_INSTRUCTION_WIDTH,true) + ""String_Node_Str"" + VM_Services.getHexString(machinecodes.get(i),false));
System.out.print(""String_Node_Str"");
System.out.print(disasm(machinecodes.get(i),i << LG_INSTRUCTION_WIDTH));
System.out.println();
}
}
return mi;
}","private final int genCode(OPT_IR ir,boolean shouldPrint){
  int mi=0;
  VM_CodeArray machinecodes=ir.MIRInfo.machinecode;
  OPT_PhysicalRegisterSet phys=ir.regpool.getPhysicalRegisterSet();
  boolean unsafeCondDispl=machinecodes.length() > MAX_COND_DISPL;
  boolean unsafeDispl=machinecodes.length() > MAX_DISPL;
  for (OPT_Instruction p=ir.firstInstructionInCodeOrder(); p != null; p=p.nextInstructionInCodeOrder()) {
    int inst=p.operator().instTemplate;
switch (p.getOpcode()) {
case LABEL_opcode:
      for (BranchSrcElement bSrc=(BranchSrcElement)p.scratchObject; bSrc != null; bSrc=bSrc.next) {
        OPT_Instruction branchStmt=bSrc.source;
        int bo=branchStmt.getmcOffset() - (1 << LG_INSTRUCTION_WIDTH);
        int bi=bo >> LG_INSTRUCTION_WIDTH;
        int targetOffset=(mi - bi) << LG_INSTRUCTION_WIDTH;
        boolean setLink=false;
        if (targetOffset > MAX_DISPL << LG_INSTRUCTION_WIDTH) {
          throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"",targetOffset);
        }
switch (branchStmt.getOpcode()) {
case PPC_B_opcode:
case PPC_BL_opcode:
          machinecodes.set(bi,machinecodes.get(bi) | targetOffset & LI_MASK);
        break;
case PPC_DATA_LABEL_opcode:
      machinecodes.set(bi,targetOffset);
    break;
case IG_PATCH_POINT_opcode:
  break;
case PPC_BCL_opcode:
setLink=true;
default :
if (targetOffset <= MAX_COND_DISPL << 2) {
machinecodes.set(bi,machinecodes.get(bi) | targetOffset & BD_MASK);
if (DEBUG) {
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(disasm(machinecodes.get(bi),0) + ""String_Node_Str"");
}
}
 else {
branchStmt.setmcOffset(branchStmt.getmcOffset() + (1 << LG_INSTRUCTION_WIDTH));
machinecodes.set(bi,flipCondition(machinecodes.get(bi)));
machinecodes.set(bi,machinecodes.get(bi) | (2 << LG_INSTRUCTION_WIDTH));
machinecodes.set(bi,machinecodes.get(bi) & 0xfffffffe);
machinecodes.set(bi + 1,Btemplate | ((targetOffset - 4) & LI_MASK));
if (setLink) machinecodes.set(bi + 1,machinecodes.get(bi + 1) | 1);
if (DEBUG) {
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(disasm(machinecodes.get(bi),0) + ""String_Node_Str"");
  VM.sysWrite(disasm(machinecodes.get(bi + 1),0) + ""String_Node_Str"");
}
}
break;
}
unresolvedBranches--;
}
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
break;
case BBEND_opcode:
case UNINT_BEGIN_opcode:
case UNINT_END_opcode:
case GUARD_MOVE_opcode:
case GUARD_COMBINE_opcode:
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
break;
case PPC_DATA_INT_opcode:
{
int value=MIR_DataInt.getValue(p).value;
machinecodes.set(mi++,value);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_DATA_LABEL_opcode:
{
OPT_Instruction target=MIR_DataLabel.getTarget(p).target;
int targetOffset=resolveBranch(p,target,mi);
machinecodes.set(mi++,targetOffset);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_CRAND_opcode:
case PPC_CRANDC_opcode:
case PPC_CROR_opcode:
case PPC_CRORC_opcode:
{
int op0=MIR_Condition.getResultBit(p).value & REG_MASK;
int op1=MIR_Condition.getValue1Bit(p).value & REG_MASK;
int op2=MIR_Condition.getValue2Bit(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ADD_opcode:
case PPC_ADDr_opcode:
case PPC_ADDC_opcode:
case PPC_ADDE_opcode:
case PPC_SUBF_opcode:
case PPC_SUBFr_opcode:
case PPC_SUBFC_opcode:
case PPC_SUBFCr_opcode:
case PPC_SUBFE_opcode:
case PPC_FADD_opcode:
case PPC_FADDS_opcode:
case PPC_FDIV_opcode:
case PPC_FDIVS_opcode:
case PPC_DIVW_opcode:
case PPC_DIVWU_opcode:
case PPC_MULLW_opcode:
case PPC_MULHW_opcode:
case PPC_MULHWU_opcode:
case PPC_FSUB_opcode:
case PPC_FSUBS_opcode:
case PPC64_MULLD_opcode:
case PPC64_DIVD_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZX_opcode:
case PPC_LWARX_opcode:
case PPC_LBZX_opcode:
case PPC_LHAX_opcode:
case PPC_LHZX_opcode:
case PPC_LFDX_opcode:
case PPC_LFSX_opcode:
case PPC_LIntX_opcode:
case PPC_LAddrARX_opcode:
case PPC_LAddrX_opcode:
case PPC64_LDX_opcode:
{
int op0=MIR_Load.getResult(p).register.number & REG_MASK;
int op1=MIR_Load.getAddress(p).register.number & REG_MASK;
int op2=MIR_Load.getOffset(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STWX_opcode:
case PPC_STWCXr_opcode:
case PPC_STBX_opcode:
case PPC_STHX_opcode:
case PPC_STFDX_opcode:
case PPC_STFSX_opcode:
case PPC_STAddrCXr_opcode:
case PPC_STAddrX_opcode:
case PPC_STAddrUX_opcode:
{
int op0=MIR_Store.getValue(p).register.number & REG_MASK;
int op1=MIR_Store.getAddress(p).register.number & REG_MASK;
int op2=MIR_Store.getOffset(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZUX_opcode:
case PPC_LBZUX_opcode:
case PPC_LIntUX_opcode:
case PPC_LAddrUX_opcode:
{
int op0=MIR_LoadUpdate.getResult(p).register.number & REG_MASK;
int op1=MIR_LoadUpdate.getAddress(p).register.number & REG_MASK;
int op2=MIR_LoadUpdate.getOffset(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZU_opcode:
{
int op0=MIR_LoadUpdate.getResult(p).register.number & REG_MASK;
int op1=MIR_LoadUpdate.getAddress(p).register.number & REG_MASK;
int op2=MIR_LoadUpdate.getOffset(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_TW_opcode:
case PPC_TAddr_opcode:
case PPC64_TD_opcode:
{
int op0=MIR_Trap.getCond(p).value;
int op1=MIR_Trap.getValue1(p).register.number & REG_MASK;
int op2=MIR_Trap.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_TWI_opcode:
case PPC64_TDI_opcode:
{
int op0=MIR_Trap.getCond(p).value;
int op1=MIR_Trap.getValue1(p).register.number & REG_MASK;
int op2=MIR_Trap.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case NULL_CHECK_opcode:
{
int op0=OPT_PowerPCTrapOperand.LOWER;
int op1=((OPT_RegisterOperand)NullCheck.getRef(p)).register.number & REG_MASK;
int op2=1;
inst=PPC64_TDI.instTemplate;
inst=PPC_TWI.instTemplate;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LDI_opcode:
case PPC_LDIS_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | op1));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ADDIC_opcode:
case PPC_ADDICr_opcode:
case PPC_SUBFIC_opcode:
case PPC_MULLI_opcode:
case PPC_ADDI_opcode:
case PPC_ADDIS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_CNTLZW_opcode:
case PPC_CNTLZAddr_opcode:
case PPC_EXTSB_opcode:
case PPC_EXTSBr_opcode:
case PPC_EXTSH_opcode:
case PPC_EXTSHr_opcode:
case PPC64_EXTSW_opcode:
case PPC64_EXTSWr_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_EXTZW_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
int op3high=1;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ADDZE_opcode:
case PPC_SUBFZE_opcode:
case PPC_NEG_opcode:
case PPC_NEGr_opcode:
case PPC_ADDME_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_XORI_opcode:
case PPC_XORIS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_AND_opcode:
case PPC_ANDr_opcode:
case PPC_NAND_opcode:
case PPC_NANDr_opcode:
case PPC_ANDC_opcode:
case PPC_ANDCr_opcode:
case PPC_OR_opcode:
case PPC_ORr_opcode:
case PPC_NOR_opcode:
case PPC_NORr_opcode:
case PPC_ORC_opcode:
case PPC_ORCr_opcode:
case PPC_XOR_opcode:
case PPC_XORr_opcode:
case PPC_EQV_opcode:
case PPC_EQVr_opcode:
case PPC_SLW_opcode:
case PPC_SLWr_opcode:
case PPC_SRW_opcode:
case PPC_SRWr_opcode:
case PPC_SRAW_opcode:
case PPC_SRAWr_opcode:
case PPC64_SLD_opcode:
case PPC64_SLDr_opcode:
case PPC64_SRD_opcode:
case PPC64_SRDr_opcode:
case PPC64_SRAD_opcode:
case PPC64_SRADr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MOVE_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
int op1=MIR_Move.getValue(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAddrI_opcode:
case PPC_SRWI_opcode:
case PPC_SRWIr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int shift=MIR_Binary.getValue2(p).asIntConstant().value & REG_MASK;
int op2=(32 - shift);
int op3=shift;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SLWI_opcode:
case PPC_SLWIr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int shift=MIR_Binary.getValue2(p).asIntConstant().value & REG_MASK;
int op2=shift;
int op3=(31 - shift);
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAAddrI_opcode:
case PPC_SRAWI_opcode:
case PPC_SRAWIr_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAAddrI_opcode:
case PPC64_SRADI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SIXBIT_MASK;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SRAddrI_opcode:
case PPC64_SRDI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op3=MIR_Binary.getValue2(p).asIntConstant().value & SIXBIT_MASK;
int op2=64 - op3;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_SLDI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int shift=MIR_Binary.getValue2(p).asIntConstant().value & SIXBIT_MASK;
int op2=shift;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3=63 - shift;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_RLDICR_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & SIXBIT_MASK;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3=MIR_RotateAndMask.getMaskEnd(p).value & SIXBIT_MASK;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
if (VM.VerifyAssertions) {
int op4=MIR_RotateAndMask.getMaskBegin(p).value & SIXBIT_MASK;
VM._assert(op4 == 0);
}
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_RLDICL_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & SIXBIT_MASK;
int op2low=op2 & 0x1F;
int op2high=(op2 & 0x20) >>> 5;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & SIXBIT_MASK;
int op3low=op3 & 0x1F;
int op3high=(op3 & 0x20) >>> 5;
if (VM.VerifyAssertions) {
int op4=MIR_RotateAndMask.getMaskEnd(p).value & SIXBIT_MASK;
VM._assert(op4 == 63);
}
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2low << 11)| (op2high << 1)| (op3low << 6)| (op3high << 5)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_ANDIr_opcode:
case PPC_ANDISr_opcode:
case PPC_ORI_opcode:
case PPC_ORIS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_RLWINM_opcode:
case PPC_RLWINMr_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & REG_MASK;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & REG_MASK;
int op4=MIR_RotateAndMask.getMaskEnd(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)| (op4 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_RLWIMI_opcode:
case PPC_RLWIMIr_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op0f=MIR_RotateAndMask.getSource(p).register.number & REG_MASK;
if (op0 != op0f) throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"");
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asIntConstant().value & REG_MASK;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & REG_MASK;
int op4=MIR_RotateAndMask.getMaskEnd(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)| (op4 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_RLWNM_opcode:
case PPC_RLWNMr_opcode:
{
int op0=MIR_RotateAndMask.getResult(p).register.number & REG_MASK;
int op1=MIR_RotateAndMask.getValue(p).register.number & REG_MASK;
int op2=MIR_RotateAndMask.getShift(p).asRegister().register.number & REG_MASK;
int op3=MIR_RotateAndMask.getMaskBegin(p).value & REG_MASK;
int op4=MIR_RotateAndMask.getMaskEnd(p).value & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)| (op2 << 11)| (op3 << 6)| (op4 << 1)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_B_opcode:
{
OPT_BranchOperand o=MIR_Branch.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
machinecodes.set(mi++,inst | (targetOffset & LI_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BLR_opcode:
case PPC_BCTR_opcode:
{
machinecodes.set(mi++,inst);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BC_opcode:
case PPC_BCOND_opcode:
case PPC_BCC_opcode:
{
int op0=MIR_CondBranch.getValue(p).register.number & REG_MASK;
int op1=MIR_CondBranch.getCond(p).value;
int bo_bi=op0 << 2 | op1;
OPT_BranchOperand o=MIR_CondBranch.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
if (targetOffset == 0) {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
if (unsafeCondDispl) {
machinecodes.set(mi++,NOPtemplate);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
 else if (targetOffset < MIN_COND_DISPL << 2) {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
machinecodes.set(mi++,inst | flipCondition(bo_bi << 16) | (2 << 2));
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
machinecodes.set(mi++,Btemplate | ((targetOffset - 4) & LI_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
 else {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16) | (targetOffset & BD_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
break;
case PPC_BCLR_opcode:
case PPC_BCCTR_opcode:
{
int op0=MIR_CondBranch.getValue(p).register.number & REG_MASK;
int op1=MIR_CondBranch.getCond(p).value;
int bo_bi=op0 << 2 | op1;
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0));
}
break;
case PPC_BL_opcode:
case PPC_BL_SYS_opcode:
{
OPT_BranchOperand o=(OPT_BranchOperand)MIR_Call.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
machinecodes.set(mi++,inst | (targetOffset & LI_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BLRL_opcode:
case PPC_BCTRL_opcode:
case PPC_BCTRL_SYS_opcode:
{
machinecodes.set(mi++,inst);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_BCL_opcode:
{
int op0=MIR_CondCall.getValue(p).register.number & REG_MASK;
int op1=MIR_CondCall.getCond(p).value;
int bo_bi=op0 << 2 | op1;
OPT_BranchOperand o=(OPT_BranchOperand)MIR_CondCall.getTarget(p);
int targetOffset=resolveBranch(p,o.target,mi);
if (targetOffset == 0) {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
if (unsafeCondDispl) {
machinecodes.set(mi++,NOPtemplate);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
 else if (targetOffset < MIN_COND_DISPL << 2) {
throw new OPT_OperationNotImplementedException(""String_Node_Str"");
}
 else {
if (DEBUG) VM.sysWrite(""String_Node_Str"");
machinecodes.set(mi++,inst | (bo_bi << 16) | (targetOffset & BD_MASK));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0) + ""String_Node_Str"");
}
}
break;
case PPC_BCLRL_opcode:
{
int op0=MIR_CondCall.getValue(p).register.number & REG_MASK;
int op1=MIR_CondCall.getCond(p).value;
int bo_bi=op0 << 2 | op1;
machinecodes.set(mi++,inst | (bo_bi << 16));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG) VM.sysWrite(disasm(machinecodes.get(mi - 1),0));
}
break;
case PPC_CMP_opcode:
case PPC_CMPL_opcode:
case PPC64_CMP_opcode:
case PPC64_CMPL_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 23) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_CMPI_opcode:
case PPC_CMPLI_opcode:
case PPC64_CMPI_opcode:
case PPC64_CMPLI_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 23) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FMR_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
int op1=MIR_Move.getValue(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FABS_opcode:
case PPC_FNEG_opcode:
case PPC_FRSP_opcode:
case PPC_FCTIW_opcode:
case PPC_FCTIWZ_opcode:
case PPC64_FCFID_opcode:
case PPC64_FCTIDZ_opcode:
{
int op0=MIR_Unary.getResult(p).register.number & REG_MASK;
int op1=MIR_Unary.getValue(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FCMPO_opcode:
case PPC_FCMPU_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 23) | (op1 << 16)| (op2 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FMUL_opcode:
case PPC_FMULS_opcode:
{
int op0=MIR_Binary.getResult(p).register.number & REG_MASK;
int op1=MIR_Binary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Binary.getValue2(p).asRegister().register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 6)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_FMADD_opcode:
case PPC_FMADDS_opcode:
case PPC_FMSUB_opcode:
case PPC_FMSUBS_opcode:
case PPC_FNMADD_opcode:
case PPC_FNMADDS_opcode:
case PPC_FNMSUB_opcode:
case PPC_FNMSUBS_opcode:
case PPC_FSEL_opcode:
{
int op0=MIR_Ternary.getResult(p).register.number & REG_MASK;
int op1=MIR_Ternary.getValue1(p).register.number & REG_MASK;
int op2=MIR_Ternary.getValue2(p).register.number & REG_MASK;
int op3=MIR_Ternary.getValue3(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| (op2 << 6)| (op3 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_LWZ_opcode:
case PPC_LBZ_opcode:
case PPC_LHA_opcode:
case PPC_LHZ_opcode:
case PPC_LFD_opcode:
case PPC_LFS_opcode:
case PPC_LMW_opcode:
case PPC_LAddr_opcode:
case PPC_LInt_opcode:
{
int op0=MIR_Load.getResult(p).register.number & REG_MASK;
int op1=MIR_Load.getOffset(p).asIntConstant().value & SHORT_MASK;
int op2=MIR_Load.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | op1| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_LD_opcode:
case PPC_LAddr_opcode:
case PPC_LInt_opcode:
{
int op0=MIR_Load.getResult(p).register.number & REG_MASK;
int op1=(MIR_Load.getOffset(p).asIntConstant().value >> 2) & SHORT14_MASK;
int op2=MIR_Load.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 2)| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STW_opcode:
case PPC_STB_opcode:
case PPC_STH_opcode:
case PPC_STFD_opcode:
case PPC_STFS_opcode:
case PPC_STMW_opcode:
case PPC_STAddr_opcode:
{
int op0=MIR_Store.getValue(p).register.number & REG_MASK;
int op1=MIR_Store.getOffset(p).asIntConstant().value & SHORT_MASK;
int op2=MIR_Store.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | op1| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STAddrU_opcode:
case PPC_STWU_opcode:
case PPC_STFDU_opcode:
case PPC_STFSU_opcode:
{
int op0=MIR_StoreUpdate.getValue(p).register.number & REG_MASK;
int op1=MIR_StoreUpdate.getAddress(p).register.number & REG_MASK;
int op2=MIR_StoreUpdate.getOffset(p).asIntConstant().value & SHORT_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)| op2));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC64_STD_opcode:
case PPC_STAddr_opcode:
{
int op0=MIR_Store.getValue(p).register.number & REG_MASK;
int op1=(MIR_Store.getOffset(p).asIntConstant().value >> 2) & SHORT14_MASK;
int op2=MIR_Store.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 2)| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_STAddrU_opcode:
{
int op0=MIR_StoreUpdate.getValue(p).register.number & REG_MASK;
int op1=(MIR_StoreUpdate.getOffset(p).asIntConstant().value >> 2) & SHORT14_MASK;
int op2=MIR_StoreUpdate.getAddress(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 2)| (op2 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MFSPR_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
int op1=phys.getSPR(MIR_Move.getValue(p).register);
machinecodes.set(mi++,(inst | (op0 << 21) | (op1 << 16)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MTSPR_opcode:
{
int op0=phys.getSPR(MIR_Move.getResult(p).register);
int op1=MIR_Move.getValue(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_MFTB_opcode:
case PPC_MFTBU_opcode:
{
int op0=MIR_Move.getResult(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 21)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_SYNC_opcode:
case PPC_ISYNC_opcode:
{
machinecodes.set(mi++,inst);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case PPC_DCBST_opcode:
case PPC_DCBF_opcode:
case PPC_ICBI_opcode:
{
int op0=MIR_CacheOp.getAddress(p).register.number & REG_MASK;
int op1=MIR_CacheOp.getOffset(p).register.number & REG_MASK;
machinecodes.set(mi++,(inst | (op0 << 16) | (op1 << 11)));
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
}
break;
case IG_PATCH_POINT_opcode:
{
OPT_BranchOperand bop=InlineGuard.getTarget(p);
OPT_Instruction target=bop.target;
if (VM.VerifyAssertions) {
VM._assert(target.getOpcode() == LABEL_opcode);
}
int targetOffset=resolveBranch(p,target,mi);
machinecodes.set(mi++,NOPtemplate);
p.setmcOffset(mi << LG_INSTRUCTION_WIDTH);
if (DEBUG_CODE_PATCH) {
VM.sysWrite(""String_Node_Str"",mi - 1);
VM.sysWrite(""String_Node_Str"");
VM.sysWriteHex(machinecodes.get(mi - 1));
VM.sysWrite(""String_Node_Str"");
}
}
break;
default :
throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"",p);
}
}
if (unresolvedBranches != 0) throw new OPT_OptimizingCompilerException(""String_Node_Str"",""String_Node_Str"");
if (shouldPrint) {
OPT_Compiler.header(""String_Node_Str"",ir.method);
for (int i=0; i < machinecodes.length(); i++) {
System.out.print(VM_Services.getHexString(i << LG_INSTRUCTION_WIDTH,true) + ""String_Node_Str"" + VM_Services.getHexString(machinecodes.get(i),false));
System.out.print(""String_Node_Str"");
System.out.print(disasm(machinecodes.get(i),i << LG_INSTRUCTION_WIDTH));
System.out.println();
}
}
return mi;
}",0.9998206278026904
150090,"/** 
 * Start the server and wait if necessary WARNING: allocates memory
 * @param wait Whether to wait
 * @param port The port to talk to the GCspy client (e.g. visualiser)
 */
public static final void startGCspyServer(int port,boolean wait) throws InterruptiblePragma {
  String eventNames[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String generalInfo=""String_Node_Str"";
  ServerInterpreter.init(""String_Node_Str"",port,eventNames,true,generalInfo);
  int tilesize=Options.gcspyTileSize.getValue();
  ss0Driver=new ContiguousSpaceDriver(""String_Node_Str"",copySpace0,tilesize,true);
  ss1Driver=new ContiguousSpaceDriver(""String_Node_Str"",copySpace1,tilesize,false);
  immortalDriver=new ContiguousSpaceDriver(""String_Node_Str"",immortalSpace,tilesize,false);
  losDriver=new TreadmillDriver(""String_Node_Str"",loSpace,tilesize,LOS_SIZE_THRESHOLD,false);
  gcspyEvent_=BEFORE_COLLECTION;
  ServerInterpreter.startServer(wait);
}","/** 
 * Start the server and wait if necessary WARNING: allocates memory
 * @param wait Whether to wait
 * @param port The port to talk to the GCspy client (e.g. visualiser)
 */
public final void startGCspyServer(int port,boolean wait) throws InterruptiblePragma {
  String eventNames[]={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String generalInfo=""String_Node_Str"";
  ServerInterpreter.init(""String_Node_Str"",port,eventNames,true,generalInfo);
  int tilesize=Options.gcspyTileSize.getValue();
  ss0Driver=new ContiguousSpaceDriver(""String_Node_Str"",copySpace0,tilesize,true);
  ss1Driver=new ContiguousSpaceDriver(""String_Node_Str"",copySpace1,tilesize,false);
  immortalDriver=new ContiguousSpaceDriver(""String_Node_Str"",immortalSpace,tilesize,false);
  losDriver=new TreadmillDriver(""String_Node_Str"",loSpace,tilesize,LOS_SIZE_THRESHOLD,false);
  gcspyEvent_=BEFORE_COLLECTION;
  ServerInterpreter.startServer(wait);
}",0.9962785752259437
150091,"/** 
 * Start the GCspy server WARNING: allocates memory indirectly
 */
public static void startGCspyServer() throws InterruptiblePragma {
  int port=getGCspyPort();
  Log.write(""String_Node_Str"");
  Log.write(port);
  Log.write(""String_Node_Str"");
  Log.writeln(getGCspyWait());
  if (port > 0) {
    SSGCspy.startGCspyServer(port,getGCspyWait());
    Log.writeln(""String_Node_Str"");
  }
}","/** 
 * Start the GCspy server WARNING: allocates memory indirectly
 */
public static void startGCspyServer() throws InterruptiblePragma {
  int port=getGCspyPort();
  Log.write(""String_Node_Str"");
  Log.write(port);
  Log.write(""String_Node_Str"");
  Log.writeln(getGCspyWait());
  if (port > 0) {
    ActivePlan.global().startGCspyServer(port,getGCspyWait());
    Log.writeln(""String_Node_Str"");
  }
}",0.9318181818181818
150092,"public char[] format_long(long value) throws UninterruptiblePragma {
  if (VM_HardwarePerformanceMonitors.verbose >= 10) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteLong(value);
    VM.sysWrite(""String_Node_Str"");
  }
  int i;
  for (i=0; i < MAX_LONG_LENGTH; i++) {
    l_buffer[i]=' ';
    f_buffer[i]=' ';
  }
  for (; i < MAX_LONG_FORMAT_LENGTH; i++) {
    f_buffer[i]=' ';
  }
  long l_value=value;
  int l_index=MAX_LONG_LENGTH - 1;
  while (l_value > 0) {
    int remainder=(int)(l_value - ((int)(l_value / 10)) * 10);
    l_buffer[l_index]=(char)((int)'0' + remainder);
    l_value=(int)(l_value / 10);
    l_index--;
  }
  int length=(MAX_LONG_LENGTH - 1) - l_index;
  if (VM_HardwarePerformanceMonitors.verbose >= 10) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(l_buffer,MAX_LONG_LENGTH);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(l_index);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(length);
    VM.sysWrite(""String_Node_Str"");
  }
  l_index=MAX_LONG_LENGTH - 1;
  int f_index=MAX_LONG_FORMAT_LENGTH - 1;
  while (length > 3 && l_index >= 2 && f_index >= 3) {
    f_buffer[f_index]=l_buffer[l_index];
    f_buffer[f_index - 1]=l_buffer[l_index - 1];
    f_buffer[f_index - 2]=l_buffer[l_index - 2];
    f_buffer[f_index - 3]=',';
    f_index-=4;
    l_index-=3;
    length-=3;
  }
  if (l_index < 2) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteLong(value);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(l_index,MAX_LONG_LENGTH);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(length);
    VM.sysWrite(""String_Node_Str"");
    VM.sysExit(VM.EXIT_STATUS_HPM_TROUBLE);
  }
  if (f_index < 3) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteLong(value);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(f_index,MAX_LONG_FORMAT_LENGTH);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(length);
    VM.sysWrite(""String_Node_Str"");
    VM.sysExit(VM.EXIT_STATUS_HPM_TROUBLE);
  }
  if (length > 0) {
    while (length > 0) {
      f_buffer[f_index]=l_buffer[l_index];
      f_index--;
      l_index--;
      length--;
    }
  }
  if (VM_HardwarePerformanceMonitors.verbose >= 10) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(f_buffer,MAX_LONG_FORMAT_LENGTH);
    VM.sysWrite(""String_Node_Str"");
  }
  return f_buffer;
}","public char[] format_long(long value) throws UninterruptiblePragma {
  if (VM_HardwarePerformanceMonitors.verbose >= 10) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteLong(value);
    VM.sysWrite(""String_Node_Str"");
  }
  int i;
  for (i=0; i < MAX_LONG_LENGTH; i++) {
    l_buffer[i]=' ';
    f_buffer[i]=' ';
  }
  for (; i < MAX_LONG_FORMAT_LENGTH; i++) {
    f_buffer[i]=' ';
  }
  long l_value=value;
  int l_index=MAX_LONG_LENGTH - 1;
  while (l_value > 0) {
    int remainder=(int)(l_value - (l_value / 10) * 10);
    l_buffer[l_index]=(char)((int)'0' + remainder);
    l_value=l_value / 10;
    l_index--;
  }
  int length=(MAX_LONG_LENGTH - 1) - l_index;
  if (VM_HardwarePerformanceMonitors.verbose >= 10) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(l_buffer,MAX_LONG_LENGTH);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(l_index);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(length);
    VM.sysWrite(""String_Node_Str"");
  }
  l_index=MAX_LONG_LENGTH - 1;
  int f_index=MAX_LONG_FORMAT_LENGTH - 1;
  while (length > 3 && l_index >= 2 && f_index >= 3) {
    f_buffer[f_index]=l_buffer[l_index];
    f_buffer[f_index - 1]=l_buffer[l_index - 1];
    f_buffer[f_index - 2]=l_buffer[l_index - 2];
    f_buffer[f_index - 3]=',';
    f_index-=4;
    l_index-=3;
    length-=3;
  }
  if (l_index < 2) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteLong(value);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(l_index,MAX_LONG_LENGTH);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(length);
    VM.sysWrite(""String_Node_Str"");
    VM.sysExit(VM.EXIT_STATUS_HPM_TROUBLE);
  }
  if (f_index < 3) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteLong(value);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(f_index,MAX_LONG_FORMAT_LENGTH);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(length);
    VM.sysWrite(""String_Node_Str"");
    VM.sysExit(VM.EXIT_STATUS_HPM_TROUBLE);
  }
  if (length > 0) {
    while (length > 0) {
      f_buffer[f_index]=l_buffer[l_index];
      f_index--;
      l_index--;
      length--;
    }
  }
  if (VM_HardwarePerformanceMonitors.verbose >= 10) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(f_buffer,MAX_LONG_FORMAT_LENGTH);
    VM.sysWrite(""String_Node_Str"");
  }
  return f_buffer;
}",0.9969485614646904
150093,"protected final void SHL_USHR(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x < y) {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (y - x)) & 0x1f),IC(y),IC(31)));
  }
 else {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(x - y),IC(y),IC(31 - (x - y))));
  }
}","protected final void SHL_USHR(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x <= y) {
    EMIT(MIR_RotateAndMask.create(PPC64_RLDICL,def,left,IC(64 - (y - x)),IC(y),IC(63)));
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (y - x)) & 0x1f),IC(y),IC(31)));
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(false);
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(x - y),IC(y),IC(31 - (x - y))));
  }
}",0.8556910569105691
150094,"protected final void USHR_SHL(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x < y) {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(y - x),IC(0),IC(31 - y)));
  }
 else {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (x - y)) & 0x1f),IC(x - y),IC(31 - y)));
  }
}","protected final void USHR_SHL(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x <= y) {
    EMIT(MIR_RotateAndMask.create(PPC64_RLDICR,def,left,IC(y - x),IC(0),IC(63 - y)));
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(y - x),IC(0),IC(31 - y)));
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(false);
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (x - y)) & 0x1f),IC(x - y),IC(31 - y)));
  }
}",0.8588832487309644
150095,"/** 
 * Initialize for boot image writing
 */
public static void init(String bootstrapClasspath){
  applicationRepositories=""String_Node_Str"";
  VM_BootstrapClassLoader.boot(bootstrapClasspath);
  VM_ApplicationClassLoader2.boot(applicationRepositories);
  StandardClassInitializerMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardClassInitializerMethodDescriptor=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectInitializerMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectInitializerMethodDescriptor=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectInitializerHelperMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectFinalizerMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectFinalizerMethodDescriptor=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  codeAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  constantValueAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  lineNumberTableAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  exceptionsAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  sourceFileAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  localVariableTableAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  deprecatedAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  innerClassesAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  syntheticAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  arrayNullCheckAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  VM_Type.init();
}","/** 
 * Initialize for boot image writing
 */
public static void init(String bootstrapClasspath){
  applicationRepositories=""String_Node_Str"";
  VM_BootstrapClassLoader.boot(bootstrapClasspath);
  StandardClassInitializerMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardClassInitializerMethodDescriptor=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectInitializerMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectInitializerMethodDescriptor=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectInitializerHelperMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectFinalizerMethodName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  StandardObjectFinalizerMethodDescriptor=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  codeAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  constantValueAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  lineNumberTableAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  exceptionsAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  sourceFileAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  localVariableTableAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  deprecatedAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  innerClassesAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  syntheticAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  arrayNullCheckAttributeName=VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"");
  VM_Type.init();
}",0.9818511796733213
150096,"/** 
 * Set list of places to be searched for application classes and resources. Do NOT set the java.class.path property; it is probably too early in the VM's booting cycle to set properties.
 * @param classpath path specification in standard ""classpath"" format
 */
public static void stashApplicationRepositories(String classpath){
  if (DBG_APP_CL) {
    VM.sysWriteln(""String_Node_Str"" + ""String_Node_Str"",classpath);
  }
  if (appCL != null && !classpath.equals(applicationRepositories)) {
    appCL=null;
    if (DBG_APP_CL)     VM.sysWriteln(""String_Node_Str"");
  }
  VM_ApplicationClassLoader2.setApplicationRepositories(classpath);
  applicationRepositories=classpath;
}","/** 
 * Set list of places to be searched for application classes and resources. Do NOT set the java.class.path property; it is probably too early in the VM's booting cycle to set properties.
 * @param classpath path specification in standard ""classpath"" format
 */
public static void stashApplicationRepositories(String classpath){
  if (DBG_APP_CL) {
    VM.sysWriteln(""String_Node_Str"" + ""String_Node_Str"",classpath);
  }
  if (appCL != null && !classpath.equals(applicationRepositories)) {
    appCL=null;
    if (DBG_APP_CL)     VM.sysWriteln(""String_Node_Str"");
  }
  applicationRepositories=classpath;
}",0.9301242236024844
150097,"public static ClassLoader getApplicationClassLoader(){
  if (!VM.runningVM)   return null;
  if (!appCLReady)   return VM_BootstrapClassLoader.getBootstrapClassLoader();
  if (appCL != null)   return appCL;
  if (gettingAppCL > 0 || DBG_APP_CL)   VM.sysWriteln(""String_Node_Str"",gettingAppCL > 0 ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",gettingAppCL,""String_Node_Str"");
  if (gettingAppCL > 0) {
    VM.sysFail(""String_Node_Str"");
  }
  ++gettingAppCL;
  String r=getApplicationRepositories();
  if (VM_Properties.verboseBoot >= 1 || DBG_APP_CL)   VM.sysWriteln(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",r,""String_Node_Str"");
  if (USE_OLD_APP_CLASSLOADER) {
    appCL=new ApplicationClassLoader(r);
  }
 else {
    VM_ApplicationClassLoader2.setApplicationRepositories(r);
    appCL=VM_ApplicationClassLoader2.getApplicationClassLoader();
  }
  if (VM_Properties.verboseBoot >= 1 || DBG_APP_CL)   VM.sysWriteln(""String_Node_Str"",appCL.toString());
  --gettingAppCL;
  return appCL;
}","public static ClassLoader getApplicationClassLoader(){
  if (!VM.runningVM)   return null;
  if (!appCLReady)   return VM_BootstrapClassLoader.getBootstrapClassLoader();
  if (appCL != null)   return appCL;
  if (gettingAppCL > 0 || DBG_APP_CL)   VM.sysWriteln(""String_Node_Str"",gettingAppCL > 0 ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",gettingAppCL,""String_Node_Str"");
  if (gettingAppCL > 0) {
    VM.sysFail(""String_Node_Str"");
  }
  ++gettingAppCL;
  String r=getApplicationRepositories();
  if (VM_Properties.verboseBoot >= 1 || DBG_APP_CL)   VM.sysWriteln(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",r,""String_Node_Str"");
  appCL=new ApplicationClassLoader(r);
  if (VM_Properties.verboseBoot >= 1 || DBG_APP_CL)   VM.sysWriteln(""String_Node_Str"",appCL.toString());
  --gettingAppCL;
  return appCL;
}",0.9035040431266846
150098,"/** 
 * Return the number of pages reserved for use given the pending allocation.  This is <i>exclusive of</i> space reserved for copying.
 * @return The number of pages reserved given the pendingallocation, excluding space reserved for copying.
 */
protected static final int getPagesUsed(){
  int pages=getCommonPagesReserved();
  pages+=nurserySpace.reservedPages();
  return pages;
}","/** 
 * Return the number of pages reserved for use given the pending allocation.  This is <i>exclusive of</i> space reserved for copying.
 * @return The number of pages reserved given the pendingallocation, excluding space reserved for copying.
 */
protected static final int getPagesUsed(){
  int pages=getCommonPagesReserved();
  pages+=nurserySpace.reservedPages();
  pages+=msSpace.reservedPages();
  return pages;
}",0.9282178217821784
150099,"protected final void SHL_USHR(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x <= y) {
    EMIT(MIR_RotateAndMask.create(PPC64_RLDICL,def,left,IC(64 - (y - x)),IC(y),IC(63)));
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (y - x)) & 0x1f),IC(y),IC(31)));
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(false);
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(x - y),IC(y),IC(31 - (x - y))));
  }
}","protected final void SHL_USHR(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x <= y) {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (y - x)) & 0x1f),IC(y),IC(31)));
  }
 else {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(x - y),IC(y),IC(31 - (x - y))));
  }
}",0.7289340101522843
150100,"protected final void USHR_SHL(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x <= y) {
    EMIT(MIR_RotateAndMask.create(PPC64_RLDICR,def,left,IC(y - x),IC(0),IC(63 - y)));
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(y - x),IC(0),IC(31 - y)));
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(false);
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (x - y)) & 0x1f),IC(x - y),IC(31 - y)));
  }
}","protected final void USHR_SHL(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left,OPT_IntConstantOperand shift1,OPT_IntConstantOperand shift2){
  int x=shift1.value;
  int y=shift2.value;
  if (x <= y) {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC(y - x),IC(0),IC(31 - y)));
  }
 else {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM,def,left,IC((32 - (x - y)) & 0x1f),IC(x - y),IC(31 - y)));
  }
}",0.7647058823529411
150101,"/** 
 * @param level the minimum optimization level at which the branch optimizations should be performed.
 * @param mayReorderCode are we allowed to change the code order?
 * @param mayDuplicateCondBranches are we allowed to duplicate conditional branches?
 */
public OPT_BranchOptimizations(int level,boolean mayReorderCode,boolean mayDuplicateCondBranches){
  super(level);
  mayReorderCode=mayReorderCode;
  mayDuplicateCondBranches=mayDuplicateCondBranches;
}","/** 
 * @param level the minimum optimization level at which the branch optimizations should be performed.
 * @param mayReorderCode are we allowed to change the code order?
 * @param mayDuplicateCondBranches are we allowed to duplicate conditional branches?
 */
public OPT_BranchOptimizations(int level,boolean mayReorderCode,boolean mayDuplicateCondBranches){
  super(level);
  this.mayReorderCode=mayReorderCode;
  this.mayDuplicateCondBranches=mayDuplicateCondBranches;
}",0.9893390191897654
150102,"/** 
 * Complete the task of booting Jikes RVM. Done in a secondary method mainly because this code doesn't have to be uninterruptible and this is the cleanest way to make that distinction.
 */
private static void finishBooting() throws InterruptiblePragma {
  if (!singleVirtualProcessor) {
    VM_SysCall.sysPthreadSetupSignalHandling();
    VM_Processor.getCurrentProcessor().pthread_id=VM_SysCall.sysPthreadSelf();
  }
  VM_Thread.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.setupProcessor(VM_Processor.getCurrentProcessor());
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"",VM_Magic.objectAsAddress(VM_BootRecord.the_boot_record));
  MM_Interface.boot(VM_BootRecord.the_boot_record);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageOne();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_BaselineCompiler.initOptions();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_QuickCompiler.initOptions();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  createClassObjects();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.fetchCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.earlyProcessCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.postBoot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String bootstrapClasses=VM_CommandLineArgs.getBootstrapClasses();
  VM_ClassLoader.boot();
  VM_BootstrapClassLoader.boot(bootstrapClasses);
  VM_ApplicationClassLoader2.boot(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageTwo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  java.lang.JikesRVMSupport.javaLangSystemEarlyInitializers();
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  VM.safeToAllocateJavaThread=true;
  VM_Scheduler.giveBootVM_ThreadAJavaLangThread();
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  java.lang.JikesRVMSupport.javaLangSystemLateInitializers();
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Lock.boot();
  if (BuildForHPM) {
    if (VM_HardwarePerformanceMonitors.enabled()) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWriteln(""String_Node_Str"");
      VM_HardwarePerformanceMonitors.boot();
    }
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Scheduler.boot();
  VM.dynamicClassLoadingEnabled=true;
  com.ibm.JikesRVM.jni.VM_JNIEnvironment.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread.getCurrentThread().initializeJNIEnv();
  runClassInitializer(""String_Node_Str"");
  VM_HardwarePerformanceMonitors.setUpHPMinfo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  VM_FileSystem.initializeStandardStreams();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM.fullyBooted=true;
  MM_Interface.fullyBootedVM();
  VM_BaselineCompiler.fullyBootedVM();
  VM_QuickCompiler.fullyBootedVM();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_RuntimeCompiler.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String[] applicationArguments=VM_CommandLineArgs.lateProcessCommandLineArguments();
  if (VM.verboseClassLoading || verboseBoot >= 1)   VM.sysWrite(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  JikesRVMSocketImpl.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  com.ibm.JikesRVM.adaptive.VM_Controller.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  if (applicationArguments.length == 0) {
    pleaseSpecifyAClass();
  }
  if (applicationArguments.length > 0 && !VM_TypeDescriptorParsing.isJavaClassName(applicationArguments[0])) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(applicationArguments[0]);
    VM.sysWrite(""String_Node_Str"");
    pleaseSpecifyAClass();
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_ClassLoader.getApplicationClassLoader();
  VM_ClassLoader.declareApplicationClassLoaderIsReady();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  java.lang.JikesRVMSupport.javaLangSystemLateInitializers();
  runClassInitializer(""String_Node_Str"");
  VM_EdgeCounts.boot();
  if (verboseBoot >= 2)   VM.sysWriteln(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  Thread mainThread=new MainThread(applicationArguments);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  mainThread.start();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread t=new DebuggerThread();
  t.start(VM_Scheduler.debuggerQueue);
  if (VM_HardwarePerformanceMonitors.enabled()) {
    if (!VM_HardwarePerformanceMonitors.thread_group) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWrite(""String_Node_Str"");
      VM_SysCall.sysHPMresetMyThread();
    }
  }
  if (VM.TraceThreads)   VM_Scheduler.trace(""String_Node_Str"",""String_Node_Str"");
  if (verboseBoot >= 2)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread.terminate();
  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);
}","/** 
 * Complete the task of booting Jikes RVM. Done in a secondary method mainly because this code doesn't have to be uninterruptible and this is the cleanest way to make that distinction.
 */
private static void finishBooting() throws InterruptiblePragma {
  if (!singleVirtualProcessor) {
    VM_SysCall.sysPthreadSetupSignalHandling();
    VM_Processor.getCurrentProcessor().pthread_id=VM_SysCall.sysPthreadSelf();
  }
  VM_Thread.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.setupProcessor(VM_Processor.getCurrentProcessor());
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"",VM_Magic.objectAsAddress(VM_BootRecord.the_boot_record));
  MM_Interface.boot(VM_BootRecord.the_boot_record);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageOne();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_BaselineCompiler.initOptions();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_QuickCompiler.initOptions();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  createClassObjects();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.fetchCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.earlyProcessCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.postBoot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String bootstrapClasses=VM_CommandLineArgs.getBootstrapClasses();
  VM_ClassLoader.boot();
  VM_BootstrapClassLoader.boot(bootstrapClasses);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageTwo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  java.lang.JikesRVMSupport.javaLangSystemEarlyInitializers();
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  VM.safeToAllocateJavaThread=true;
  VM_Scheduler.giveBootVM_ThreadAJavaLangThread();
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  java.lang.JikesRVMSupport.javaLangSystemLateInitializers();
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Lock.boot();
  if (BuildForHPM) {
    if (VM_HardwarePerformanceMonitors.enabled()) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWriteln(""String_Node_Str"");
      VM_HardwarePerformanceMonitors.boot();
    }
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Scheduler.boot();
  VM.dynamicClassLoadingEnabled=true;
  com.ibm.JikesRVM.jni.VM_JNIEnvironment.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread.getCurrentThread().initializeJNIEnv();
  runClassInitializer(""String_Node_Str"");
  VM_HardwarePerformanceMonitors.setUpHPMinfo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  VM_FileSystem.initializeStandardStreams();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM.fullyBooted=true;
  MM_Interface.fullyBootedVM();
  VM_BaselineCompiler.fullyBootedVM();
  VM_QuickCompiler.fullyBootedVM();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_RuntimeCompiler.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String[] applicationArguments=VM_CommandLineArgs.lateProcessCommandLineArguments();
  if (VM.verboseClassLoading || verboseBoot >= 1)   VM.sysWrite(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  JikesRVMSocketImpl.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  com.ibm.JikesRVM.adaptive.VM_Controller.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  if (applicationArguments.length == 0) {
    pleaseSpecifyAClass();
  }
  if (applicationArguments.length > 0 && !VM_TypeDescriptorParsing.isJavaClassName(applicationArguments[0])) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(applicationArguments[0]);
    VM.sysWrite(""String_Node_Str"");
    pleaseSpecifyAClass();
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_ClassLoader.getApplicationClassLoader();
  VM_ClassLoader.declareApplicationClassLoaderIsReady();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  java.lang.JikesRVMSupport.javaLangSystemLateInitializers();
  runClassInitializer(""String_Node_Str"");
  VM_EdgeCounts.boot();
  if (verboseBoot >= 2)   VM.sysWriteln(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  Thread mainThread=new MainThread(applicationArguments);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  mainThread.start();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread t=new DebuggerThread();
  t.start(VM_Scheduler.debuggerQueue);
  if (VM_HardwarePerformanceMonitors.enabled()) {
    if (!VM_HardwarePerformanceMonitors.thread_group) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWrite(""String_Node_Str"");
      VM_SysCall.sysHPMresetMyThread();
    }
  }
  if (VM.TraceThreads)   VM_Scheduler.trace(""String_Node_Str"",""String_Node_Str"");
  if (verboseBoot >= 2)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread.terminate();
  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);
}",0.9963335143943508
150103,"/** 
 * Dump state of virtual machine.
 */
public static void dumpVirtualMachine() throws InterruptiblePragma {
  VM_Processor processor;
  VM.sysWrite(""String_Node_Str"");
  for (int i=1; i <= numProcessors; ++i) {
    processor=processors[i];
    processor.dumpProcessorState();
  }
  VM.sysWrite(""String_Node_Str"");
  wakeupQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  wakeupQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  debuggerQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  deadVPQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  collectorQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  finalizerQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  for (int i=1; i < threads.length; ++i) {
    if (threads[i] != null) {
      threads[i].dump();
      VM.sysWrite(""String_Node_Str"");
    }
  }
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(""String_Node_Str"");
  for (int i=PRIMORDIAL_PROCESSOR_ID; i <= numProcessors; ++i) {
    processor=processors[i];
    int unallocated=processor.lastLockIndex - processor.nextLockIndex + 1;
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(i);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(processor.locksAllocated);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(processor.locksFreed);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(processor.freeLocks);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(unallocated);
    VM.sysWrite(""String_Node_Str"");
  }
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(""String_Node_Str"");
  for (int i=0; i < locks.length; ++i)   if (locks[i] != null)   locks[i].dump();
  VM.sysWrite(""String_Node_Str"");
}","/** 
 * Dump state of virtual machine.
 */
public static void dumpVirtualMachine() throws InterruptiblePragma {
  VM_Processor processor;
  VM.sysWrite(""String_Node_Str"");
  for (int i=1; i <= numProcessors; ++i) {
    processor=processors[i];
    processor.dumpProcessorState();
  }
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(""String_Node_Str"");
  wakeupQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  debuggerQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  deadVPQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  collectorQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  finalizerQueue.dump();
  VM.sysWrite(""String_Node_Str"");
  for (int i=1; i < threads.length; ++i) {
    if (threads[i] != null) {
      threads[i].dump();
      VM.sysWrite(""String_Node_Str"");
    }
  }
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(""String_Node_Str"");
  for (int i=PRIMORDIAL_PROCESSOR_ID; i <= numProcessors; ++i) {
    processor=processors[i];
    int unallocated=processor.lastLockIndex - processor.nextLockIndex + 1;
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(i);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(processor.locksAllocated);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(processor.locksFreed);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(processor.freeLocks);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWriteInt(unallocated);
    VM.sysWrite(""String_Node_Str"");
  }
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(""String_Node_Str"");
  for (int i=0; i < locks.length; ++i)   if (locks[i] != null)   locks[i].dump();
  VM.sysWrite(""String_Node_Str"");
}",0.9932266009852216
150104,"/** 
 * Initialization: set up data structures and sampling objects.
 */
public void initialize(){
  if (VM.LogAOSEvents)   VM_AOSLogging.DCGOrganizerThreadStarted();
  numberOfBufferTriples=VM_Controller.options.DCG_SAMPLE_SIZE;
  numberOfBufferTriples*=VM_Scheduler.numProcessors;
  bufferSize=numberOfBufferTriples * 3;
  buffer=new int[bufferSize];
  ((VM_EdgeListener)listener).setBuffer(buffer);
  VM_RuntimeMeasurements.installTimerContextListener((VM_EdgeListener)listener);
}","/** 
 * Initialization: set up data structures and sampling objects.
 */
public void initialize(){
  if (VM.LogAOSEvents)   VM_AOSLogging.DCGOrganizerThreadStarted();
  if (VM_Controller.options.cgCBS()) {
    numberOfBufferTriples=VM_Controller.options.DCG_SAMPLE_SIZE * VM.CBSCallSamplesPerTick;
  }
 else {
    numberOfBufferTriples=VM_Controller.options.DCG_SAMPLE_SIZE;
  }
  numberOfBufferTriples*=VM_Scheduler.numProcessors;
  bufferSize=numberOfBufferTriples * 3;
  buffer=new int[bufferSize];
  ((VM_EdgeListener)listener).setBuffer(buffer);
  if (VM_Controller.options.cgTimer()) {
    VM_RuntimeMeasurements.installTimerContextListener((VM_EdgeListener)listener);
  }
 else   if (VM_Controller.options.cgCBS()) {
    VM_RuntimeMeasurements.installCBSContextListener((VM_EdgeListener)listener);
  }
 else {
    if (VM.VerifyAssertions)     VM._assert(false,""String_Node_Str"");
  }
}",0.7020348837209303
150105,"/** 
 * Print out the number of pages and or megabytes, depending on the mode.
 * @param pages The number of pages
 * @param mode An enumeration type that specifies the format for theprining (PAGES, MB, PAGES_MB, or MB_PAGES).
 */
private static void printPages(int pages,int mode){
  double mb=Conversions.pagesToMBytes(pages);
switch (mode) {
case PAGES:
    Log.write(pages);
  Log.write(""String_Node_Str"");
break;
case MB:
Log.write(mb);
Log.write(""String_Node_Str"");
break;
case PAGES_MB:
Log.write(pages);
Log.write(""String_Node_Str"");
Log.write(mb);
Log.write(""String_Node_Str"");
break;
case MB_PAGES:
Log.write(mb);
Log.write(""String_Node_Str"");
Log.write(pages);
Log.write(""String_Node_Str"");
break;
default :
Assert.fail(""String_Node_Str"");
}
}","/** 
 * Print out the number of pages and or megabytes, depending on the mode.
 * @param pages The number of pages
 * @param mode An enumeration type that specifies the format for theprining (PAGES, MB, PAGES_MB, or MB_PAGES).
 */
private static void printPages(int pages,int mode){
  double mb=(double)(pages << LOG_BYTES_IN_PAGE) / (double)(1 << 20);
switch (mode) {
case PAGES:
    Log.write(pages);
  Log.write(""String_Node_Str"");
break;
case MB:
Log.write(mb);
Log.write(""String_Node_Str"");
break;
case PAGES_MB:
Log.write(pages);
Log.write(""String_Node_Str"");
Log.write(mb);
Log.write(""String_Node_Str"");
break;
case MB_PAGES:
Log.write(mb);
Log.write(""String_Node_Str"");
Log.write(pages);
Log.write(""String_Node_Str"");
break;
default :
Assert.fail(""String_Node_Str"");
}
}",0.9451697127937336
150106,"/** 
 * Check if object might be a TIB.
 * @param obj address of object to check
 * @return <code>false</code> if the object is in the wrongallocation scheme/area for a TIB, <code>true</code> otherwise
 */
public static boolean mightBeTIB(ObjectReference obj) throws InlinePragma, UninterruptiblePragma {
  return Space.isImmortal(obj);
}","/** 
 * Check if object might be a TIB.
 * @param obj address of object to check
 * @return <code>false</code> if the object is in the wrongallocation scheme/area for a TIB, <code>true</code> otherwise
 */
public static boolean mightBeTIB(ObjectReference obj) throws InlinePragma, UninterruptiblePragma {
  return !obj.isNull() && Space.isImmortal(obj);
}",0.9754689754689756
150107,"/** 
 * This method is called periodically by the allocation subsystem (by default, each time a page is consumed), and provides the collector with an opportunity to collect.<p> We trigger a collection whenever an allocation request is made that would take the number of pages in use (committed for use) beyond the number of pages available.  Collections are triggered through the runtime, and ultimately call the <code>collect()</code> method of this class or its superclass.<p> This method is clearly interruptible since it can lead to a GC. However, the caller is typically uninterruptible and this fiat allows  the interruptibility check to work.  The caveat is that the caller  of this method must code as though the method is interruptible.  In practice, this means that, after this call, processor-specific values must be reloaded.
 * @see org.mmtk.policy.Space#acquire(int)
 * @param mustCollect if <code>true</code> then a collection isrequired and must be triggered.  Otherwise a collection is only triggered if we deem it necessary.
 * @param space the space that triggered the polling (i.e. the spaceinto which an allocation is about to occur).
 * @return True if a collection has been triggered
 */
public final boolean poll(boolean mustCollect,Space space) throws LogicallyUninterruptiblePragma {
  if (collectionsInitiated > 0 || !initialized)   return false;
  mustCollect|=stressTestGCRequired();
  boolean heapFull=getPagesReserved() > getTotalPages();
  boolean nurseryFull=nurserySpace.reservedPages() > nurserySize.getMaxNursery();
  int newMetaDataPages=metaDataSpace.committedPages() - previousMetaDataPages;
  if (mustCollect || heapFull || nurseryFull|| (progress && (newMetaDataPages > metaDataLimit.getPages()))) {
    if (space == metaDataSpace) {
      awaitingCollection=true;
      return false;
    }
    required=space.reservedPages() - space.committedPages();
    if (space == nurserySpace)     required=required << 1;
    Collection.triggerCollection(Collection.RESOURCE_GC_TRIGGER);
    return true;
  }
  return false;
}","/** 
 * This method is called periodically by the allocation subsystem (by default, each time a page is consumed), and provides the collector with an opportunity to collect.<p> We trigger a collection whenever an allocation request is made that would take the number of pages in use (committed for use) beyond the number of pages available.  Collections are triggered through the runtime, and ultimately call the <code>collect()</code> method of this class or its superclass.<p> This method is clearly interruptible since it can lead to a GC. However, the caller is typically uninterruptible and this fiat allows  the interruptibility check to work.  The caveat is that the caller  of this method must code as though the method is interruptible.  In practice, this means that, after this call, processor-specific values must be reloaded.
 * @see org.mmtk.policy.Space#acquire(int)
 * @param mustCollect if <code>true</code> then a collection isrequired and must be triggered.  Otherwise a collection is only triggered if we deem it necessary.
 * @param space the space that triggered the polling (i.e. the spaceinto which an allocation is about to occur).
 * @return True if a collection has been triggered
 */
public final boolean poll(boolean mustCollect,Space space) throws LogicallyUninterruptiblePragma {
  if (collectionsInitiated > 0 || !initialized)   return false;
  mustCollect|=stressTestGCRequired();
  boolean heapFull=getPagesReserved() > getTotalPages();
  boolean nurseryFull=nurserySpace.reservedPages() > nurserySize.getMaxNursery();
  boolean metaDataFull=metaDataSpace.reservedPages() > META_DATA_FULL_THRESHOLD;
  int newMetaDataPages=metaDataSpace.committedPages() - previousMetaDataPages;
  if (mustCollect || heapFull || nurseryFull|| metaDataFull(progress && (newMetaDataPages > metaDataLimit.getPages()))) {
    if (space == metaDataSpace) {
      awaitingCollection=true;
      return false;
    }
    required=space.reservedPages() - space.committedPages();
    if (space == nurserySpace)     required=required << 1;
    Collection.triggerCollection(Collection.RESOURCE_GC_TRIGGER);
    return true;
  }
  return false;
}",0.9778834720570748
150108,"/** 
 * This method is called periodically by the allocation subsystem (by default, each time a page is consumed), and provides the collector with an opportunity to collect.<p> We trigger a collection whenever an allocation request is made that would take the number of pages in use (committed for use) beyond the number of pages available.  Collections are triggered through the runtime, and ultimately call the <code>collect()</code> method of this class or its superclass.<p> This method is clearly interruptible since it can lead to a GC. However, the caller is typically uninterruptible and this fiat allows  the interruptibility check to work.  The caveat is that the caller  of this method must code as though the method is interruptible.  In practice, this means that, after this call, processor-specific values must be reloaded.
 * @see org.mmtk.policy.Space#acquire(int)
 * @param mustCollect if <code>true</code> then a collection isrequired and must be triggered.  Otherwise a collection is only triggered if we deem it necessary.
 * @param space the space that triggered the polling (i.e. the spaceinto which an allocation is about to occur).
 * @return True if a collection has been triggered
 */
public final boolean poll(boolean mustCollect,Space space) throws LogicallyUninterruptiblePragma {
  if (collectionsInitiated > 0 || !initialized || space == metaDataSpace)   return false;
  mustCollect|=stressTestGCRequired();
  boolean heapFull=getPagesReserved() > getTotalPages();
  boolean nurseryFull=nurserySpace.reservedPages() > nurserySize.getMaxNursery();
  if (mustCollect || heapFull || nurseryFull) {
    required=space.reservedPages() - space.committedPages();
    if (space == nurserySpace || (Plan.COPY_MATURE() && (space == activeMatureSpace)))     required=required << 1;
    int nurseryYield=((int)((float)nurserySpace.committedPages() * SURVIVAL_ESTIMATE)) << 1;
    fullHeapGC=mustCollect || (nurseryYield < required) || fullHeapGC;
    Collection.triggerCollection(Collection.RESOURCE_GC_TRIGGER);
    return true;
  }
  return false;
}","/** 
 * This method is called periodically by the allocation subsystem (by default, each time a page is consumed), and provides the collector with an opportunity to collect.<p> We trigger a collection whenever an allocation request is made that would take the number of pages in use (committed for use) beyond the number of pages available.  Collections are triggered through the runtime, and ultimately call the <code>collect()</code> method of this class or its superclass.<p> This method is clearly interruptible since it can lead to a GC. However, the caller is typically uninterruptible and this fiat allows  the interruptibility check to work.  The caveat is that the caller  of this method must code as though the method is interruptible.  In practice, this means that, after this call, processor-specific values must be reloaded.
 * @see org.mmtk.policy.Space#acquire(int)
 * @param mustCollect if <code>true</code> then a collection isrequired and must be triggered.  Otherwise a collection is only triggered if we deem it necessary.
 * @param space the space that triggered the polling (i.e. the spaceinto which an allocation is about to occur).
 * @return True if a collection has been triggered
 */
public final boolean poll(boolean mustCollect,Space space) throws LogicallyUninterruptiblePragma {
  if (collectionsInitiated > 0 || !initialized || space == metaDataSpace)   return false;
  mustCollect|=stressTestGCRequired();
  boolean heapFull=getPagesReserved() > getTotalPages();
  boolean nurseryFull=nurserySpace.reservedPages() > nurserySize.getMaxNursery();
  boolean metaDataFull=metaDataSpace.reservedPages() > META_DATA_FULL_THRESHOLD;
  if (mustCollect || heapFull || nurseryFull|| metaDataFull) {
    required=space.reservedPages() - space.committedPages();
    if (space == nurserySpace || (Plan.COPY_MATURE() && (space == activeMatureSpace)))     required=required << 1;
    int nurseryYield=((int)((float)nurserySpace.committedPages() * SURVIVAL_ESTIMATE)) << 1;
    fullHeapGC=mustCollect || (nurseryYield < required) || fullHeapGC;
    Collection.triggerCollection(Collection.RESOURCE_GC_TRIGGER);
    return true;
  }
  return false;
}",0.9773371104815864
150109,"final Address alloc() throws InlinePragma {
  Address rtn=rps.acquire(PAGES_PER_BUFFER);
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(rtn.EQ(bufferStart(rtn)));
  return rtn;
}","final Address alloc() throws InlinePragma {
  Address rtn=rps.acquire(PAGES_PER_BUFFER);
  if (rtn.isZero()) {
    Space.printUsageMB();
    Assert.fail(""String_Node_Str"");
  }
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(rtn.EQ(bufferStart(rtn)));
  return rtn;
}",0.8035714285714286
150110,"/** 
 * Print a message of a method name
 */
protected final void printMethodMessage(){
  String compilerName=getCompilerName();
  VM.sysWrite(""String_Node_Str"" + Character.toUpperCase(compilerName.charAt(0)) + compilerName.substring(1));
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(method.getDeclaringClass().toString());
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(method.getName());
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(method.getDescriptor());
  VM.sysWrite(""String_Node_Str"");
}","/** 
 * Print a message of a method name
 */
protected final void printMethodMessage(){
  String compilerName=getCompilerName();
  if (compilerName.equals(""String_Node_Str"")) {
    VM.sysWrite(""String_Node_Str"");
  }
 else   if (compilerName.equals(""String_Node_Str"")) {
    VM.sysWrite(""String_Node_Str"");
  }
 else   if (VM.VerifyAssertions) {
    VM._assert(false,""String_Node_Str"");
  }
  VM.sysWrite(method.getDeclaringClass().toString());
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(method.getName());
  VM.sysWrite(""String_Node_Str"");
  VM.sysWrite(method.getDescriptor());
  VM.sysWrite(""String_Node_Str"");
}",0.3172905525846702
150111,"/** 
 * Returns a common superclass of the two types. NOTE: If both types are references, but are not both loaded, then this may be a conservative approximation (java.lang.Object). If there is no common superclass, than null is returned.
 */
public static VM_TypeReference findCommonSuperclass(VM_TypeReference t1,VM_TypeReference t2){
  if (t1 == t2)   return t1;
  if (t1.isPrimitiveType() || t2.isPrimitiveType()) {
    if (t1.isIntLikeType() && t2.isIntLikeType()) {
      if (t1.isIntType() || t2.isIntType())       return VM_TypeReference.Int;
      if (t1.isCharType() || t2.isCharType())       return VM_TypeReference.Char;
      if (t1.isShortType() || t2.isShortType())       return VM_TypeReference.Short;
      if (t1.isByteType() || t2.isByteType())       return VM_TypeReference.Byte;
    }
 else     if (t1.isWordType() && t2.isWordType()) {
      return VM_TypeReference.Word;
    }
    return null;
  }
  if (t1 == VM_TypeReference.NULL_TYPE)   return t2;
  if (t2 == VM_TypeReference.NULL_TYPE)   return t1;
  if (OPT_IRGenOptions.DBG_TYPE)   VM.sysWrite(""String_Node_Str"" + t1 + ""String_Node_Str""+ t2);
  int arrayDimensions=0;
  while (t1.isArrayType() && t2.isArrayType()) {
    ++arrayDimensions;
    t1=t1.getArrayElementType();
    t2=t2.getArrayElementType();
  }
  if (t1.isPrimitiveType() || t2.isPrimitiveType()) {
    VM_TypeReference type=VM_TypeReference.JavaLangObject;
    if (t1 == t2) {
      if (t1.isWordType()) {
        arrayDimensions++;
        type=t1;
      }
 else {
        if (VM.VerifyAssertions)         VM._assert(false);
      }
    }
    --arrayDimensions;
    while (arrayDimensions-- > 0)     type=type.getArrayTypeForElementType();
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + type);
    return type;
  }
  if (!t1.isClassType() || !t2.isClassType()) {
    VM_TypeReference type=VM_TypeReference.JavaLangObject;
    while (arrayDimensions-- > 0)     type=type.getArrayTypeForElementType();
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + type);
    return type;
  }
  VM_Class c1=(VM_Class)t1.peekResolvedType();
  VM_Class c2=(VM_Class)t2.peekResolvedType();
  if (c1 != null && c2 != null) {
    OPT_Stack s1=new OPT_Stack();
    do {
      s1.push(c1);
      c1=c1.getSuperClass();
    }
 while (c1 != null);
    OPT_Stack s2=new OPT_Stack();
    do {
      s2.push(c2);
      c2=c2.getSuperClass();
    }
 while (c2 != null);
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + s1);
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + s2);
    VM_TypeReference best=VM_TypeReference.JavaLangObject;
    while (!s1.empty() && !s2.empty()) {
      VM_Class temp=(VM_Class)s1.pop();
      if (temp == s2.pop())       best=temp.getTypeRef();
 else       break;
    }
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + best);
    while (arrayDimensions-- > 0)     best=best.getArrayTypeForElementType();
    return best;
  }
 else {
    if (OPT_IRGenOptions.DBG_TYPE && c1 == null)     VM.sysWrite(c1 + ""String_Node_Str"");
    if (OPT_IRGenOptions.DBG_TYPE && c2 == null)     VM.sysWrite(c2 + ""String_Node_Str"");
    VM_TypeReference common=VM_TypeReference.JavaLangObject;
    while (arrayDimensions-- > 0)     common=common.getArrayTypeForElementType();
    return common;
  }
}","/** 
 * Returns a common superclass of the two types. NOTE: If both types are references, but are not both loaded, then this may be a conservative approximation (java.lang.Object). If there is no common superclass, than null is returned.
 */
public static VM_TypeReference findCommonSuperclass(VM_TypeReference t1,VM_TypeReference t2){
  if (t1 == t2)   return t1;
  if (t1.isPrimitiveType() || t2.isPrimitiveType()) {
    if (t1.isIntLikeType() && t2.isIntLikeType()) {
      if (t1.isIntType() || t2.isIntType())       return VM_TypeReference.Int;
      if (t1.isCharType() || t2.isCharType())       return VM_TypeReference.Char;
      if (t1.isShortType() || t2.isShortType())       return VM_TypeReference.Short;
      if (t1.isByteType() || t2.isByteType())       return VM_TypeReference.Byte;
    }
 else     if (t1.isWordType() && t2.isWordType()) {
      return VM_TypeReference.Word;
    }
    return null;
  }
  if (t1 == VM_TypeReference.NULL_TYPE)   return t2;
  if (t2 == VM_TypeReference.NULL_TYPE)   return t1;
  if (OPT_IRGenOptions.DBG_TYPE)   VM.sysWrite(""String_Node_Str"" + t1 + ""String_Node_Str""+ t2);
  int arrayDimensions=0;
  while (t1.isArrayType() && t2.isArrayType()) {
    ++arrayDimensions;
    t1=t1.getArrayElementType();
    t2=t2.getArrayElementType();
  }
  if (t1.isPrimitiveType() || t2.isPrimitiveType()) {
    VM_TypeReference type=VM_TypeReference.JavaLangObject;
    if (t1 == t2) {
      if (t1.isWordType() && t2.isWordType()) {
        arrayDimensions++;
        type=t1;
      }
 else       if (t1.isCodeType() && t2.isCodeType()) {
        arrayDimensions++;
        type=t1;
      }
 else {
        if (VM.VerifyAssertions)         VM._assert(false);
      }
    }
    --arrayDimensions;
    while (arrayDimensions-- > 0)     type=type.getArrayTypeForElementType();
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + type);
    return type;
  }
  if (!t1.isClassType() || !t2.isClassType()) {
    VM_TypeReference type=VM_TypeReference.JavaLangObject;
    while (arrayDimensions-- > 0)     type=type.getArrayTypeForElementType();
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + type);
    return type;
  }
  VM_Class c1=(VM_Class)t1.peekResolvedType();
  VM_Class c2=(VM_Class)t2.peekResolvedType();
  if (c1 != null && c2 != null) {
    OPT_Stack s1=new OPT_Stack();
    do {
      s1.push(c1);
      c1=c1.getSuperClass();
    }
 while (c1 != null);
    OPT_Stack s2=new OPT_Stack();
    do {
      s2.push(c2);
      c2=c2.getSuperClass();
    }
 while (c2 != null);
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + s1);
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + s2);
    VM_TypeReference best=VM_TypeReference.JavaLangObject;
    while (!s1.empty() && !s2.empty()) {
      VM_Class temp=(VM_Class)s1.pop();
      if (temp == s2.pop())       best=temp.getTypeRef();
 else       break;
    }
    if (OPT_IRGenOptions.DBG_TYPE)     VM.sysWrite(""String_Node_Str"" + best);
    while (arrayDimensions-- > 0)     best=best.getArrayTypeForElementType();
    return best;
  }
 else {
    if (OPT_IRGenOptions.DBG_TYPE && c1 == null)     VM.sysWrite(c1 + ""String_Node_Str"");
    if (OPT_IRGenOptions.DBG_TYPE && c2 == null)     VM.sysWrite(c2 + ""String_Node_Str"");
    VM_TypeReference common=VM_TypeReference.JavaLangObject;
    while (arrayDimensions-- > 0)     common=common.getArrayTypeForElementType();
    return common;
  }
}",0.9816311535635562
150112,"public static void zero(Address start,Extent len) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert((len.toInt() & (BYTES_IN_WORD - 1)) == 0 && (start.toInt() & (BYTES_IN_WORD - 1)) == 0);
  if (len.GT(Extent.fromIntZeroExtend(256)))   org.mmtk.vm.Memory.zero(start,len);
 else   zeroSmall(start,len);
}","/** 
 * Zero a region of memory
 * @param start The start of the region to be zeroed (must be 4-byte aligned)
 * @param bytes The number of bytes to be zeroed (must be 4-byte aligned)
 */
public static void zero(Address start,Extent bytes) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    assertAligned(start.toInt());
    assertAligned(bytes.toInt());
  }
  if (bytes.GT(Extent.fromIntZeroExtend(SMALL_REGION_THRESHOLD)))   org.mmtk.vm.Memory.zero(start,bytes);
 else   zeroSmall(start,bytes);
}",0.2695547533092659
150113,"public static void set(Address start,int len,int v) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert((len & (BYTES_IN_WORD - 1)) == 0 && (start.toInt() & (BYTES_IN_WORD - 1)) == 0);
  for (int i=0; i < len; i+=BYTES_IN_WORD)   start.store(Word.fromInt(v),Offset.fromInt(i));
}","/** 
 * Set a region of memory
 * @param start The start of the region to be zeroed (must be 4-byte aligned)
 * @param bytes The number of bytes to be zeroed (must be 4-byte aligned)
 * @param value The value to which the integers in the region should be set
 */
public static void set(Address start,int bytes,int value) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    assertAligned(start.toInt());
    assertAligned(bytes);
  }
  Address end=start.add(bytes);
  for (Address addr=start; addr.LT(end); addr=addr.add(BYTES_IN_INT))   addr.store(value);
}",0.2641946697566628
150114,"public static void zeroPages(Address start,int len) throws InlinePragma {
  org.mmtk.vm.Memory.zeroPages(start,len);
}","/** 
 * Zero a page-aligned region of memory
 * @param start The start of the region to be zeroed (must be page aligned)
 * @param bytes The number of bytes to be zeroed (must be page aligned)
 */
public static void zeroPages(Address start,int bytes) throws InlinePragma {
  org.mmtk.vm.Memory.zeroPages(start,bytes);
}",0.5125858123569794
150115,"public static void zeroSmall(Address start,Extent len) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert((len.toInt() & (BYTES_IN_WORD - 1)) == 0 && (start.toInt() & (BYTES_IN_WORD - 1)) == 0);
  Address end=start.add(len);
  for (Address i=start; i.LT(end); i=i.add(BYTES_IN_WORD))   i.store(Word.zero());
}","/** 
 * Zero a small region of memory
 * @param start The start of the region to be zeroed (must be 4-byte aligned)
 * @param bytes The number of bytes to be zeroed (must be 4-byte aligned)
 */
public static void zeroSmall(Address start,Extent bytes) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS) {
    assertAligned(start.toInt());
    assertAligned(bytes.toInt());
  }
  Address end=start.add(bytes);
  for (Address addr=start; addr.LT(end); addr=addr.add(BYTES_IN_INT))   addr.store(0);
}",0.2922705314009662
150116,"public static void assertIsZeroed(Address start,int size) throws NoInlinePragma {
  Assert._assert(isSetHelper(start,size,true,Word.zero()));
}","/** 
 * Assert that a memory range is zeroed.  An assertion failure will occur if the region is not zeroed. this is in the inline allocation sequence when Assert.VERIFY_ASSERTIONS is true, it is carefully written to reduce the impact on code space.
 * @param start The start address of the range to be checked
 * @param bytes The size of the region to be checked, in bytes
 */
public static void assertIsZeroed(Address start,int bytes) throws NoInlinePragma {
  Assert._assert(isSet(start,bytes,true,0));
}",0.3636363636363636
150117,"public static boolean IsZeroed(Address start,int size) throws InlinePragma {
  return isSetHelper(start,size,false,Word.zero());
}","/** 
 * Check that a memory range is zeroed
 * @param start The start address of the range to be checked
 * @param bytes The size of the region to be checked, in bytes
 * @return True if the region is zeroed
 */
public static boolean IsZeroed(Address start,int bytes) throws InlinePragma {
  return isSet(start,bytes,false,0);
}",0.4017467248908297
150118,"public static void dumpMemory(Address addr,int before,int after){
  org.mmtk.vm.Memory.dumpMemory(addr,before,after);
}","/** 
 * Dump the contents of memory around a given address
 * @param addr The address around which the memory should be dumped
 * @param beforeBytes The number of bytes before the address to beincluded in the dump
 * @param afterBytes The number of bytes after the address to beincluded in the dump
 */
public static void dumpMemory(Address addr,int beforeBytes,int afterBytes){
  org.mmtk.vm.Memory.dumpMemory(addr,beforeBytes,afterBytes);
}",0.4242424242424242
150119,"/** 
 * Scan static variables (JTOC) for object references. Executed by all GC threads in parallel, with each doing a portion of the JTOC.
 */
public static void scanStatics(AddressDeque rootLocations) throws UninterruptiblePragma {
  int numSlots=VM_Statics.getNumberOfSlots();
  Address slots=VM_Statics.getSlots();
  int chunkSize=512;
  int slot, start, end, stride, slotAddress;
  VM_CollectorThread ct;
  stride=chunkSize * VM_CollectorThread.numCollectors();
  ct=VM_Magic.threadAsCollectorThread(VM_Thread.getCurrentThread());
  start=(ct.getGCOrdinal() - 1) * chunkSize;
  while (start < numSlots) {
    end=start + chunkSize;
    if (end > numSlots)     end=numSlots;
    for (slot=start; slot < end; slot++) {
      if (!VM_Statics.isReference(slot))       continue;
      rootLocations.push(slots.add(slot << LOG_BYTES_IN_ADDRESS));
    }
    start=start + stride;
  }
}","/** 
 * Scan static variables (JTOC) for object references.  Executed by all GC threads in parallel, with each doing a portion of the JTOC.
 */
public static void scanStatics(AddressDeque rootLocations) throws UninterruptiblePragma {
  int numSlots=VM_Statics.getNumberOfSlots();
  Address slots=VM_Statics.getSlots();
  int chunkSize=512;
  int slot, start, end, stride, slotAddress;
  VM_CollectorThread ct;
  stride=chunkSize * VM_CollectorThread.numCollectors();
  ct=VM_Magic.threadAsCollectorThread(VM_Thread.getCurrentThread());
  start=(ct.getGCOrdinal() - 1) * chunkSize;
  while (start < numSlots) {
    end=start + chunkSize;
    if (end > numSlots)     end=numSlots;
    for (slot=start; slot < end; slot++) {
      if (!VM_Statics.isReference(slot))       continue;
      rootLocations.push(slots.add(slot << LOG_BYTES_IN_SLOT));
    }
    start=start + stride;
  }
}",0.9931895573212258
150120,"/** 
 * Generate instructions for a basic block. May discover other basic blocks that need to be generated along the way.
 * @param fromIndex bytecode index to start from
 */
private void generateFrom(int fromIndex){
  if (DBG_BB || DBG_SELECTED) {
    db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
  }
  currentBBLE.setGenerated();
  endOfBasicBlock=fallThrough=false;
  lastInstr=null;
  bcodes.reset(fromIndex);
  while (true) {
    currentBBLE.high=instrIndex=bcodes.index();
    int code=bcodes.nextInstruction();
    if (DBG_BCPARSE) {
      db(""String_Node_Str"" + instrIndex + ""String_Node_Str""+ code+ ""String_Node_Str""+ Integer.toHexString(code));
    }
    OPT_Instruction s=null;
    lastOsrBarrier=null;
switch (code) {
case JBC_nop:
      break;
case JBC_aconst_null:
    push(new OPT_NullConstantOperand());
  break;
case JBC_iconst_m1:
case JBC_iconst_0:
case JBC_iconst_1:
case JBC_iconst_2:
case JBC_iconst_3:
case JBC_iconst_4:
case JBC_iconst_5:
push(new OPT_IntConstantOperand(code - JBC_iconst_0));
break;
case JBC_lconst_0:
case JBC_lconst_1:
pushDual(new OPT_LongConstantOperand(code - JBC_lconst_0));
break;
case JBC_fconst_0:
push(new OPT_FloatConstantOperand(0.f));
break;
case JBC_fconst_1:
push(new OPT_FloatConstantOperand(1.f));
break;
case JBC_fconst_2:
push(new OPT_FloatConstantOperand(2.f));
break;
case JBC_dconst_0:
pushDual(new OPT_DoubleConstantOperand(0.));
break;
case JBC_dconst_1:
pushDual(new OPT_DoubleConstantOperand(1.));
break;
case JBC_bipush:
push(new OPT_IntConstantOperand(bcodes.getByteValue()));
break;
case JBC_sipush:
push(new OPT_IntConstantOperand(bcodes.getShortValue()));
break;
case JBC_ldc:
push(getConstantOperand(bcodes.getConstantIndex()));
break;
case JBC_ldc_w:
push(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_ldc2_w:
pushDual(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_iload:
s=do_iload(bcodes.getLocalNumber());
break;
case JBC_lload:
s=do_lload(bcodes.getLocalNumber());
break;
case JBC_fload:
s=do_fload(bcodes.getLocalNumber());
break;
case JBC_dload:
s=do_dload(bcodes.getLocalNumber());
break;
case JBC_aload:
s=do_aload(bcodes.getLocalNumber());
break;
case JBC_iload_0:
case JBC_iload_1:
case JBC_iload_2:
case JBC_iload_3:
s=do_iload(code - JBC_iload_0);
break;
case JBC_lload_0:
case JBC_lload_1:
case JBC_lload_2:
case JBC_lload_3:
s=do_lload(code - JBC_lload_0);
break;
case JBC_fload_0:
case JBC_fload_1:
case JBC_fload_2:
case JBC_fload_3:
s=do_fload(code - JBC_fload_0);
break;
case JBC_dload_0:
case JBC_dload_1:
case JBC_dload_2:
case JBC_dload_3:
s=do_dload(code - JBC_dload_0);
break;
case JBC_aload_0:
case JBC_aload_1:
case JBC_aload_2:
case JBC_aload_3:
s=do_aload(code - JBC_aload_0);
break;
case JBC_iaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=_aloadHelper(INT_ALOAD,ref,index,VM_TypeReference.Int);
}
break;
case JBC_laload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=_aloadHelper(LONG_ALOAD,ref,index,VM_TypeReference.Long);
}
break;
case JBC_faload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=_aloadHelper(FLOAT_ALOAD,ref,index,VM_TypeReference.Float);
}
break;
case JBC_daload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=_aloadHelper(DOUBLE_ALOAD,ref,index,VM_TypeReference.Double);
}
break;
case JBC_aaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
s=_aloadHelper(REF_ALOAD,ref,index,type);
}
break;
case JBC_baload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) s=_aloadHelper(BYTE_ALOAD,ref,index,VM_TypeReference.Byte);
 else s=_aloadHelper(UBYTE_ALOAD,ref,index,VM_TypeReference.Boolean);
}
break;
case JBC_caload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=_aloadHelper(USHORT_ALOAD,ref,index,VM_TypeReference.Char);
}
break;
case JBC_saload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=_aloadHelper(SHORT_ALOAD,ref,index,VM_TypeReference.Short);
}
break;
case JBC_istore:
s=do_store(bcodes.getLocalNumber(),popInt());
break;
case JBC_lstore:
s=do_store(bcodes.getLocalNumber(),popLong());
break;
case JBC_fstore:
s=do_store(bcodes.getLocalNumber(),popFloat());
break;
case JBC_dstore:
s=do_store(bcodes.getLocalNumber(),popDouble());
break;
case JBC_astore:
s=do_astore(bcodes.getLocalNumber());
break;
case JBC_istore_0:
case JBC_istore_1:
case JBC_istore_2:
case JBC_istore_3:
s=do_store(code - JBC_istore_0,popInt());
break;
case JBC_lstore_0:
case JBC_lstore_1:
case JBC_lstore_2:
case JBC_lstore_3:
s=do_store(code - JBC_lstore_0,popLong());
break;
case JBC_fstore_0:
case JBC_fstore_1:
case JBC_fstore_2:
case JBC_fstore_3:
s=do_store(code - JBC_fstore_0,popFloat());
break;
case JBC_dstore_0:
case JBC_dstore_1:
case JBC_dstore_2:
case JBC_dstore_3:
s=do_store(code - JBC_dstore_0,popDouble());
break;
case JBC_astore_0:
case JBC_astore_1:
case JBC_astore_2:
case JBC_astore_3:
s=do_astore(code - JBC_astore_0);
break;
case JBC_iastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=AStore.create(INT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Int),getCurrentGuard());
}
break;
case JBC_lastore:
{
OPT_Operand val=popLong();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=AStore.create(LONG_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Long),getCurrentGuard());
}
break;
case JBC_fastore:
{
OPT_Operand val=popFloat();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=AStore.create(FLOAT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Float),getCurrentGuard());
}
break;
case JBC_dastore:
{
OPT_Operand val=popDouble();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=AStore.create(DOUBLE_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Double),getCurrentGuard());
}
break;
case JBC_aastore:
{
OPT_Operand val=pop();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
if (do_CheckStore(ref,val,type)) break;
s=AStore.create(REF_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_bastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) type=VM_TypeReference.Byte;
 else type=VM_TypeReference.Boolean;
s=AStore.create(BYTE_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_castore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Char),getCurrentGuard());
}
break;
case JBC_sastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Short),getCurrentGuard());
}
break;
case JBC_pop:
stack.pop();
break;
case JBC_pop2:
stack.pop2();
break;
case JBC_dup:
{
OPT_Operand op1=stack.pop();
stack.push(op1);
s=pushCopy(op1);
}
break;
case JBC_dup_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op1);
stack.push(op3);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op2);
stack.push(op1);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
OPT_Operand op4=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op4);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_swap:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
}
break;
case JBC_iadd:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_ADD,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ladd:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_ADD,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fadd:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_ADD,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dadd:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_ADD,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_isub:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SUB,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lsub:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SUB,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fsub:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_SUB,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dsub:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_SUB,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_imul:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_MUL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lmul:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_MUL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fmul:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_MUL,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dmul:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_MUL,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_idiv:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_ldiv:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_fdiv:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_DIV,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_ddiv:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_DIV,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_irem:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_lrem:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_frem:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_REM,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_drem:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_REM,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_ineg:
s=_unaryHelper(INT_NEG,popInt(),VM_TypeReference.Int);
break;
case JBC_lneg:
s=_unaryDualHelper(LONG_NEG,popLong(),VM_TypeReference.Long);
break;
case JBC_fneg:
s=_unaryHelper(FLOAT_NEG,popFloat(),VM_TypeReference.Float);
break;
case JBC_dneg:
s=_unaryDualHelper(DOUBLE_NEG,popDouble(),VM_TypeReference.Double);
break;
case JBC_ishl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ishr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_USHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_USHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iand:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_AND,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_land:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_AND,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ior:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_OR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_OR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ixor:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_XOR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lxor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_XOR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iinc:
{
int index=bcodes.getLocalNumber();
s=do_iinc(index,bcodes.getIncrement());
}
break;
case JBC_i2l:
s=_unaryDualHelper(INT_2LONG,popInt(),VM_TypeReference.Long);
break;
case JBC_i2f:
s=_unaryHelper(INT_2FLOAT,popInt(),VM_TypeReference.Float);
break;
case JBC_i2d:
s=_unaryDualHelper(INT_2DOUBLE,popInt(),VM_TypeReference.Double);
break;
case JBC_l2i:
s=_unaryHelper(LONG_2INT,popLong(),VM_TypeReference.Int);
break;
case JBC_l2f:
s=_unaryHelper(LONG_2FLOAT,popLong(),VM_TypeReference.Float);
break;
case JBC_l2d:
s=_unaryDualHelper(LONG_2DOUBLE,popLong(),VM_TypeReference.Double);
break;
case JBC_f2i:
s=_unaryHelper(FLOAT_2INT,popFloat(),VM_TypeReference.Int);
break;
case JBC_f2l:
s=_unaryDualHelper(FLOAT_2LONG,popFloat(),VM_TypeReference.Long);
break;
case JBC_f2d:
s=_unaryDualHelper(FLOAT_2DOUBLE,popFloat(),VM_TypeReference.Double);
break;
case JBC_d2i:
s=_unaryHelper(DOUBLE_2INT,popDouble(),VM_TypeReference.Int);
break;
case JBC_d2l:
s=_unaryDualHelper(DOUBLE_2LONG,popDouble(),VM_TypeReference.Long);
break;
case JBC_d2f:
s=_unaryHelper(DOUBLE_2FLOAT,popDouble(),VM_TypeReference.Float);
break;
case JBC_int2byte:
s=_unaryHelper(INT_2BYTE,popInt(),VM_TypeReference.Byte);
break;
case JBC_int2char:
s=_unaryHelper(INT_2USHORT,popInt(),VM_TypeReference.Char);
break;
case JBC_int2short:
s=_unaryHelper(INT_2SHORT,popInt(),VM_TypeReference.Short);
break;
case JBC_lcmp:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryHelper(LONG_CMP,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpl:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpg:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpl:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpg:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ifeq:
s=_intIfHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifne:
s=_intIfHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_iflt:
s=_intIfHelper(OPT_ConditionOperand.LESS());
break;
case JBC_ifge:
s=_intIfHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_ifgt:
s=_intIfHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_ifle:
s=_intIfHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_icmpeq:
s=_intIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_icmpne:
s=_intIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_if_icmplt:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS());
break;
case JBC_if_icmpge:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_if_icmpgt:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_if_icmple:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_acmpeq:
s=_refIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_acmpne:
s=_refIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto:
{
int offset=bcodes.getBranchOffset();
if (offset != 3) s=_gotoHelper(offset);
}
break;
case JBC_jsr:
s=_jsrHelper(bcodes.getBranchOffset());
break;
case JBC_ret:
s=_retHelper(bcodes.getLocalNumber());
break;
case JBC_tableswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int low=bcodes.getLowSwitchValue();
int high=bcodes.getHighSwitchValue();
int number=high - low + 1;
if (CF_TABLESWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeTableSwitchOffset(v1,low,high);
int offset=match == 0 ? defaultoff : match;
bcodes.skipTableSwitchOffsets(number);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=TableSwitch.create(TABLESWITCH,op0,null,null,new OPT_IntConstantOperand(low),new OPT_IntConstantOperand(high),generateTarget(defaultoff),null,number * 2);
for (int i=0; i < number; ++i) {
TableSwitch.setTarget(s,i,generateTarget(bcodes.getTableSwitchOffset(i)));
}
bcodes.skipTableSwitchOffsets(number);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(number + 1);
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_lookupswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int numpairs=bcodes.getSwitchLength();
if (numpairs == 0) {
s=_gotoHelper(defaultoff);
break;
}
if (CF_LOOKUPSWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeLookupSwitchOffset(v1,numpairs);
int offset=match == 0 ? defaultoff : match;
bcodes.skipLookupSwitchPairs(numpairs);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=LookupSwitch.create(LOOKUPSWITCH,op0,null,null,generateTarget(defaultoff),null,numpairs * 3);
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setMatch(s,i,new OPT_IntConstantOperand(bcodes.getLookupSwitchValue(i)));
LookupSwitch.setTarget(s,i,generateTarget(bcodes.getLookupSwitchOffset(i)));
}
bcodes.skipLookupSwitchPairs(numpairs);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(numpairs + 1);
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_ireturn:
_returnHelper(INT_MOVE,popInt());
break;
case JBC_lreturn:
_returnHelper(LONG_MOVE,popLong());
break;
case JBC_freturn:
_returnHelper(FLOAT_MOVE,popFloat());
break;
case JBC_dreturn:
_returnHelper(DOUBLE_MOVE,popDouble());
break;
case JBC_areturn:
{
OPT_Operand op0=popRef();
if (VM.VerifyAssertions && !op0.isDefinitelyNull()) {
VM_TypeReference retType=op0.getType();
if (retType.isWordType()) {
VM._assert(gc.method.getReturnType().isWordType());
}
 else {
if (retType != VM_TypeReference.JavaLangObject) {
assertIsAssignable(gc.method.getReturnType(),retType);
}
}
}
_returnHelper(REF_MOVE,op0);
}
break;
case JBC_return:
_returnHelper(null,null);
break;
case JBC_getstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
if (!fieldType.isDoubleType() && !fieldType.isFloatType()) {
if (field.isFinal()) {
VM_Class declaringClass=field.getDeclaringClass();
if (declaringClass.isInitialized() || (VM.writingBootImage && declaringClass.isInBootImage())) {
try {
if (fieldType.isPrimitiveType()) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
if (OPT_StaticFieldReader.isStaticFieldNull(field)) {
push(new OPT_NullConstantOperand(),fieldType);
break;
}
 else {
VM_TypeReference rtType=OPT_StaticFieldReader.getTypeFromStaticField(field);
if (rtType == VM_TypeReference.JavaLangString) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
t.type=rtType;
if (rtType != fieldType) t.clearDeclaredType();
t.setPreciseType();
markGuardlessNonNull(t);
}
}
}
}
 catch (NoSuchFieldException e) {
}
}
}
}
}
s=GetStatic.create(GETSTATIC,t,offsetOp,fieldOp);
push(t.copyD2U(),fieldType);
}
break;
case JBC_putstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand r=pop(fieldType);
s=PutStatic.create(PUTSTATIC,r,offsetOp,fieldOp);
}
break;
case JBC_getfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
}
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
s=GetField.create(GETFIELD,t,op1,offsetOp,fieldOp,getCurrentGuard());
push(t.copyD2U(),fieldType);
}
break;
case JBC_putfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
OPT_Operand val=pop(fieldType);
OPT_Operand obj=popRef();
clearCurrentGuard();
if (do_NullCheck(obj)) break;
s=PutField.create(PUTFIELD,val,obj,offsetOp,fieldOp,getCurrentGuard());
}
break;
case JBC_invokevirtual:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
OPT_MethodOperand methOp=OPT_MethodOperand.VIRTUAL(ref,target);
if (this.osrGuardedInline) {
lastOsrBarrier=_createOsrBarrier();
}
s=_callHelper(ref,methOp);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
if (VM.VerifyAssertions) VM._assert(target != null);
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean isExtant=false;
boolean isPreciseType=false;
VM_TypeReference tr=null;
if (receiver.isRegister()) {
OPT_RegisterOperand rop=receiver.asRegister();
isExtant=rop.isExtant();
isPreciseType=rop.isPreciseType();
tr=rop.type;
}
 else if (receiver.isStringConstant()) {
isExtant=true;
isPreciseType=true;
tr=VM_TypeReference.JavaLangString;
}
 else if (VM.VerifyAssertions) {
VM._assert(false,""String_Node_Str"");
}
if (isPreciseType && target != null) {
methOp.refine(target,true);
}
VM_Type type=tr.peekResolvedType();
if (type != null && type.isResolved() && type.isClassType() && target != null && type != target.getDeclaringClass()) {
VM_Method vmeth=OPT_ClassLoaderProxy.lookupMethod(type.asClass(),ref);
if (vmeth != null && vmeth != target) {
methOp.refine(vmeth,isPreciseType);
}
}
if (maybeInlineMethod(shouldInline(s,isExtant),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokespecial:
{
VM_MethodReference ref=bcodes.getMethodReference();
VM_Method target=ref.resolveInvokeSpecial();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.SPECIAL(ref,target));
if (target == null) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokestatic:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.STATIC(ref,target));
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokeinterface:
{
VM_MethodReference ref=bcodes.getMethodReference();
bcodes.alignInvokeInterface();
VM_Method resolvedMethod=null;
resolvedMethod=ref.peekInterfaceMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.INTERFACE(ref,resolvedMethod));
OPT_RegisterOperand receiver=Call.getParam(s,0).asRegister();
VM_Class receiverType=(VM_Class)receiver.type.peekResolvedType();
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean requiresImplementsTest=VM.BuildForIMTInterfaceInvocation || (VM.BuildForITableInterfaceInvocation && VM.DirectlyIndexedITables);
if (requiresImplementsTest) {
if (resolvedMethod == null) {
OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
OPT_Instruction getTib=GuardedUnary.create(GET_OBJ_TIB,tibPtr,receiver.copyU2U(),getCurrentGuard());
appendInstruction(getTib);
getTib.bcIndex=RUNTIME_SERVICES_BCI;
VM_Method target=VM_Entrypoints.unresolvedInvokeinterfaceImplementsTestMethod;
OPT_Instruction callCheck=Call.create2(CALL,null,new OPT_IntConstantOperand(target.getOffset()),OPT_MethodOperand.STATIC(target),new OPT_IntConstantOperand(ref.getId()),tibPtr.copyD2U());
if (gc.options.NO_CALLEE_EXCEPTIONS) {
callCheck.markAsNonPEI();
}
appendInstruction(callCheck);
callCheck.bcIndex=RUNTIME_SERVICES_BCI;
requiresImplementsTest=false;
rectifyStateWithErrorHandler();
}
 else {
VM_Type interfaceType=resolvedMethod.getDeclaringClass();
if (receiverType != null && receiverType.isResolved() && !receiverType.isInterface()) {
byte doesImplement=OPT_ClassLoaderProxy.includesType(interfaceType.getTypeRef(),receiverType.getTypeRef());
requiresImplementsTest=doesImplement != YES;
}
}
}
VM_Method vmeth=null;
if (receiverType != null && receiverType.isInitialized() && !receiverType.isInterface()) {
vmeth=OPT_ClassLoaderProxy.lookupMethod(receiverType,ref);
}
if (vmeth != null) {
VM_MethodReference vmethRef=vmeth.getMemberRef().asMethodReference();
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
rectifyStateWithErrorHandler();
}
OPT_MethodOperand mop=OPT_MethodOperand.VIRTUAL(vmethRef,vmeth);
if (receiver.isPreciseType()) {
mop.refine(vmeth,true);
}
Call.setMethod(s,mop);
boolean unresolved=vmethRef.needsDynamicLink(bcodes.method());
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(vmeth.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,receiver.isExtant()),s)) {
return;
}
}
 else {
if (resolvedMethod != null && maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
 else {
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
}
}
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_xxxunusedxxx:
OPT_OptimizingCompilerException.UNREACHABLE();
break;
case JBC_new:
{
VM_TypeReference klass=bcodes.getTypeReference();
OPT_RegisterOperand t=gc.temps.makeTemp(klass);
t.setPreciseType();
markGuardlessNonNull(t);
OPT_Operator operator;
OPT_TypeOperand klassOp;
VM_Class klassType=(VM_Class)klass.peekResolvedType();
if (klassType != null && (klassType.isInitialized() || klassType.isInBootImage())) {
klassOp=makeTypeOperand(klassType);
operator=NEW;
}
 else {
operator=NEW_UNRESOLVED;
klassOp=makeTypeOperand(klass);
}
s=New.create(operator,t,klassOp);
push(t.copyD2U());
rectifyStateWithErrorHandler();
}
break;
case JBC_newarray:
{
VM_Type array=bcodes.getPrimitiveArrayType();
OPT_TypeOperand arrayOp=makeTypeOperand(array);
OPT_RegisterOperand t=gc.temps.makeTemp(array.getTypeRef());
t.setPreciseType();
markGuardlessNonNull(t);
s=NewArray.create(NEWARRAY,t,arrayOp,popInt());
push(t.copyD2U());
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_anewarray:
{
VM_TypeReference elementTypeRef=bcodes.getTypeReference();
s=generateAnewarray(elementTypeRef);
}
break;
case JBC_arraylength:
{
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
if (VM.VerifyAssertions) VM._assert(getArrayTypeOf(op1).isArrayType());
OPT_RegisterOperand t=gc.temps.makeTempInt();
s=GuardedUnary.create(ARRAYLENGTH,t,op1,getCurrentGuard());
push(t.copyD2U());
}
break;
case JBC_athrow:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
VM_TypeReference type=getRefTypeOf(op0);
if (VM.VerifyAssertions) {
if (type != VM_TypeReference.JavaLangObject) assertIsAssignable(VM_TypeReference.JavaLangThrowable,type);
}
if (!gc.method.isInterruptible()) {
appendInstruction(Empty.create(UNINT_END));
}
endOfBasicBlock=true;
OPT_BasicBlock definiteTarget=rectifyStateWithExceptionHandler(type,true);
if (definiteTarget != null) {
appendInstruction(CacheOp.create(SET_CAUGHT_EXCEPTION,op0));
s=Goto.create(GOTO,definiteTarget.makeJumpTarget());
}
 else {
s=Athrow.create(ATHROW,(OPT_RegisterOperand)op0);
}
}
break;
case JBC_checkcast:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (typeRef.isWordType()) {
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
if (DBG_CF) db(""String_Node_Str"" + typeRef);
break;
}
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_CHECKCAST && !classLoading) {
if (op2.isDefinitelyNull()) {
push(op2);
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
if (OPT_ClassLoaderProxy.includesType(typeRef,type) == YES) {
push(op2);
if (DBG_CF) db(""String_Node_Str"" + op2 + ""String_Node_Str""+ typeRef+ ""String_Node_Str""+ type);
break;
}
}
if (!gc.options.NO_CHECKCAST) {
if (classLoading) {
s=TypeCheck.create(CHECKCAST_UNRESOLVED,op2,makeTypeOperand(typeRef));
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=TypeCheck.create(CHECKCAST_NOTNULL,op2,typeOp,getGuard(op2));
}
 else {
s=TypeCheck.create(CHECKCAST,op2,typeOp);
}
}
}
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangClassCastException);
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_instanceof:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_INSTANCEOF && !classLoading) {
if (op2.isDefinitelyNull()) {
push(new OPT_IntConstantOperand(0));
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
int answer=OPT_ClassLoaderProxy.includesType(typeRef,type);
if (answer == YES && isNonNull(op2)) {
push(new OPT_IntConstantOperand(1));
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
break;
}
 else if (answer == NO) {
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
push(new OPT_IntConstantOperand(0));
break;
}
}
OPT_RegisterOperand t=gc.temps.makeTempInt();
if (classLoading) {
s=InstanceOf.create(INSTANCEOF_UNRESOLVED,t,makeTypeOperand(typeRef),op2);
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=InstanceOf.create(INSTANCEOF_NOTNULL,t,typeOp,op2,getGuard(op2));
}
 else {
s=InstanceOf.create(INSTANCEOF,t,typeOp,op2);
}
}
push(t.copyD2U());
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_monitorenter:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (VM.VerifyAssertions) VM._assert(op0.isRef());
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITORENTER,op0,getCurrentGuard());
}
}
break;
case JBC_monitorexit:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITOREXIT,op0,getCurrentGuard());
}
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangIllegalMonitorStateException);
}
break;
case JBC_wide:
{
int widecode=bcodes.getWideOpcode();
int index=bcodes.getWideLocalNumber();
switch (widecode) {
case JBC_iload:
s=do_iload(index);
break;
case JBC_lload:
s=do_lload(index);
break;
case JBC_fload:
s=do_fload(index);
break;
case JBC_dload:
s=do_dload(index);
break;
case JBC_aload:
s=do_aload(index);
break;
case JBC_istore:
s=do_store(index,popInt());
break;
case JBC_lstore:
s=do_store(index,popLong());
break;
case JBC_fstore:
s=do_store(index,popFloat());
break;
case JBC_dstore:
s=do_store(index,popDouble());
break;
case JBC_astore:
s=do_astore(index);
break;
case JBC_iinc:
s=do_iinc(index,bcodes.getWideIncrement());
break;
case JBC_ret:
s=_retHelper(index);
break;
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
}
break;
case JBC_multianewarray:
{
VM_TypeReference arrayType=bcodes.getTypeReference();
OPT_TypeOperand typeOp=makeTypeOperand(arrayType);
int dimensions=bcodes.getArrayDimension();
OPT_TypeOperand dimArrayType=makeTypeOperand(VM_Array.IntArray);
OPT_RegisterOperand dimArray=gc.temps.makeTemp(VM_TypeReference.IntArray);
markGuardlessNonNull(dimArray);
dimArray.setPreciseType();
appendInstruction(NewArray.create(NEWARRAY,dimArray,dimArrayType,new OPT_IntConstantOperand(dimensions)));
for (int i=dimensions; i > 0; i--) {
OPT_LocationOperand loc=new OPT_LocationOperand(VM_TypeReference.Int);
appendInstruction(AStore.create(INT_ASTORE,popInt(),dimArray.copyD2U(),new OPT_IntConstantOperand(i - 1),loc,new OPT_TrueGuardOperand()));
}
OPT_RegisterOperand result=gc.temps.makeTemp(arrayType);
markGuardlessNonNull(result);
result.setPreciseType();
appendInstruction(NewArray.create(NEWOBJMULTIARRAY,result,typeOp,dimArray.copyD2U()));
push(result.copyD2U());
rectifyStateWithErrorHandler();
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_ifnull:
s=_refIfNullHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifnonnull:
s=_refIfNullHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto_w:
{
int offset=bcodes.getWideBranchOffset();
if (offset != 5) s=_gotoHelper(offset);
}
break;
case JBC_jsr_w:
s=_jsrHelper(bcodes.getWideBranchOffset());
break;
case JBC_impdep1:
{
int pseudo_opcode=bcodes.nextPseudoInstruction();
switch (pseudo_opcode) {
case PSEUDO_LoadIntConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new OPT_IntConstantOperand(value));
param1=param2;
param2=value;
break;
}
case PSEUDO_LoadLongConst:
{
long value=bcodes.readLongConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateLongLiteral(value);
pushDual(new OPT_LongConstantOperand(value,offset));
break;
}
case PSEUDO_LoadWordConst:
{
Address a;
a=Address.fromIntSignExtend(bcodes.readIntConst());
a=Address.fromLong(bcodes.readLongConst());
push(new OPT_AddressConstantOperand(a));
if (VM.TraceOnStackReplacement) VM.sysWrite(""String_Node_Str"");
VM.sysWrite(a);
VM.sysWriteln();
break;
}
case PSEUDO_LoadFloatConst:
{
int ibits=bcodes.readIntConst();
float value=Float.intBitsToFloat(ibits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateFloatLiteral(ibits);
push(new OPT_FloatConstantOperand(value,offset));
break;
}
case PSEUDO_LoadDoubleConst:
{
long lbits=bcodes.readLongConst();
double value=VM_Magic.longBitsAsDouble(lbits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + lbits);
int offset=VM_Statics.findOrCreateDoubleLiteral(lbits);
pushDual(new OPT_DoubleConstantOperand(value,offset));
break;
}
case PSEUDO_LoadRetAddrConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new ReturnAddressOperand(value));
break;
}
case PSEUDO_InvokeStatic:
{
VM_Method meth=null;
int targetidx=bcodes.readIntConst();
switch (targetidx) {
case GETREFAT:
meth=VM_Entrypoints.osrGetRefAtMethod;
break;
case CLEANREFS:
meth=VM_Entrypoints.osrCleanRefsMethod;
break;
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + targetidx);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.STATIC(meth));
Call.setAddress(s,new OPT_IntConstantOperand(meth.getOffset()));
if (targetidx == GETREFAT) {
Object realObj=OSR_ObjectHolder.getRefAt(param1,param2);
if (VM.VerifyAssertions) VM._assert(realObj != null);
VM_TypeReference klass=VM_Magic.getObjectType(realObj).getTypeRef();
OPT_RegisterOperand op0=gc.temps.makeTemp(klass);
Call.setResult(s,op0);
pop();
push(op0.copyD2U(),klass);
}
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_InvokeCompiledMethod:
{
int cmid=bcodes.readIntConst();
int origBCIdx=bcodes.readIntConst();
VM_CompiledMethod cm=VM_CompiledMethods.getCompiledMethod(cmid);
VM_Method meth=cm.getMethod();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.COMPILED(meth,cm.getOsrJTOCoffset()));
s.bcIndex=origBCIdx + bciAdjustment;
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_ParamInitEnd:
{
break;
}
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + pseudo_opcode);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
break;
}
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (s != null && !currentBBLE.isSelfRegen()) {
appendInstruction(s);
}
if (VM.VerifyAssertions) VM._assert(bcodes.index() <= runoff);
if (!endOfBasicBlock && bcodes.index() == runoff) {
if (DBG_BB || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
endOfBasicBlock=fallThrough=true;
}
if (endOfBasicBlock) {
if (currentBBLE.isSelfRegen()) {
currentBBLE.block.deleteOut();
if (DBG_CFG || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE.block);
return;
}
if (fallThrough) {
if (VM.VerifyAssertions) VM._assert(bcodes.index() < bcodes.length());
currentBBLE.fallThrough=getOrCreateBlock(bcodes.index());
currentBBLE.block.insertOut(currentBBLE.fallThrough.block);
}
return;
}
}
}","/** 
 * Generate instructions for a basic block. May discover other basic blocks that need to be generated along the way.
 * @param fromIndex bytecode index to start from
 */
private void generateFrom(int fromIndex){
  if (DBG_BB || DBG_SELECTED) {
    db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
  }
  currentBBLE.setGenerated();
  endOfBasicBlock=fallThrough=false;
  lastInstr=null;
  bcodes.reset(fromIndex);
  while (true) {
    currentBBLE.high=instrIndex=bcodes.index();
    int code=bcodes.nextInstruction();
    if (DBG_BCPARSE) {
      db(""String_Node_Str"" + instrIndex + ""String_Node_Str""+ code+ ""String_Node_Str""+ Integer.toHexString(code));
    }
    OPT_Instruction s=null;
    lastOsrBarrier=null;
switch (code) {
case JBC_nop:
      break;
case JBC_aconst_null:
    push(new OPT_NullConstantOperand());
  break;
case JBC_iconst_m1:
case JBC_iconst_0:
case JBC_iconst_1:
case JBC_iconst_2:
case JBC_iconst_3:
case JBC_iconst_4:
case JBC_iconst_5:
push(new OPT_IntConstantOperand(code - JBC_iconst_0));
break;
case JBC_lconst_0:
case JBC_lconst_1:
pushDual(new OPT_LongConstantOperand(code - JBC_lconst_0));
break;
case JBC_fconst_0:
push(new OPT_FloatConstantOperand(0.f));
break;
case JBC_fconst_1:
push(new OPT_FloatConstantOperand(1.f));
break;
case JBC_fconst_2:
push(new OPT_FloatConstantOperand(2.f));
break;
case JBC_dconst_0:
pushDual(new OPT_DoubleConstantOperand(0.));
break;
case JBC_dconst_1:
pushDual(new OPT_DoubleConstantOperand(1.));
break;
case JBC_bipush:
push(new OPT_IntConstantOperand(bcodes.getByteValue()));
break;
case JBC_sipush:
push(new OPT_IntConstantOperand(bcodes.getShortValue()));
break;
case JBC_ldc:
push(getConstantOperand(bcodes.getConstantIndex()));
break;
case JBC_ldc_w:
push(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_ldc2_w:
pushDual(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_iload:
s=do_iload(bcodes.getLocalNumber());
break;
case JBC_lload:
s=do_lload(bcodes.getLocalNumber());
break;
case JBC_fload:
s=do_fload(bcodes.getLocalNumber());
break;
case JBC_dload:
s=do_dload(bcodes.getLocalNumber());
break;
case JBC_aload:
s=do_aload(bcodes.getLocalNumber());
break;
case JBC_iload_0:
case JBC_iload_1:
case JBC_iload_2:
case JBC_iload_3:
s=do_iload(code - JBC_iload_0);
break;
case JBC_lload_0:
case JBC_lload_1:
case JBC_lload_2:
case JBC_lload_3:
s=do_lload(code - JBC_lload_0);
break;
case JBC_fload_0:
case JBC_fload_1:
case JBC_fload_2:
case JBC_fload_3:
s=do_fload(code - JBC_fload_0);
break;
case JBC_dload_0:
case JBC_dload_1:
case JBC_dload_2:
case JBC_dload_3:
s=do_dload(code - JBC_dload_0);
break;
case JBC_aload_0:
case JBC_aload_1:
case JBC_aload_2:
case JBC_aload_3:
s=do_aload(code - JBC_aload_0);
break;
case JBC_iaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=_aloadHelper(INT_ALOAD,ref,index,VM_TypeReference.Int);
}
break;
case JBC_laload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=_aloadHelper(LONG_ALOAD,ref,index,VM_TypeReference.Long);
}
break;
case JBC_faload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=_aloadHelper(FLOAT_ALOAD,ref,index,VM_TypeReference.Float);
}
break;
case JBC_daload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=_aloadHelper(DOUBLE_ALOAD,ref,index,VM_TypeReference.Double);
}
break;
case JBC_aaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
s=_aloadHelper(REF_ALOAD,ref,index,type);
}
break;
case JBC_baload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) s=_aloadHelper(BYTE_ALOAD,ref,index,VM_TypeReference.Byte);
 else s=_aloadHelper(UBYTE_ALOAD,ref,index,VM_TypeReference.Boolean);
}
break;
case JBC_caload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=_aloadHelper(USHORT_ALOAD,ref,index,VM_TypeReference.Char);
}
break;
case JBC_saload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=_aloadHelper(SHORT_ALOAD,ref,index,VM_TypeReference.Short);
}
break;
case JBC_istore:
s=do_store(bcodes.getLocalNumber(),popInt());
break;
case JBC_lstore:
s=do_store(bcodes.getLocalNumber(),popLong());
break;
case JBC_fstore:
s=do_store(bcodes.getLocalNumber(),popFloat());
break;
case JBC_dstore:
s=do_store(bcodes.getLocalNumber(),popDouble());
break;
case JBC_astore:
s=do_astore(bcodes.getLocalNumber());
break;
case JBC_istore_0:
case JBC_istore_1:
case JBC_istore_2:
case JBC_istore_3:
s=do_store(code - JBC_istore_0,popInt());
break;
case JBC_lstore_0:
case JBC_lstore_1:
case JBC_lstore_2:
case JBC_lstore_3:
s=do_store(code - JBC_lstore_0,popLong());
break;
case JBC_fstore_0:
case JBC_fstore_1:
case JBC_fstore_2:
case JBC_fstore_3:
s=do_store(code - JBC_fstore_0,popFloat());
break;
case JBC_dstore_0:
case JBC_dstore_1:
case JBC_dstore_2:
case JBC_dstore_3:
s=do_store(code - JBC_dstore_0,popDouble());
break;
case JBC_astore_0:
case JBC_astore_1:
case JBC_astore_2:
case JBC_astore_3:
s=do_astore(code - JBC_astore_0);
break;
case JBC_iastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=AStore.create(INT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Int),getCurrentGuard());
}
break;
case JBC_lastore:
{
OPT_Operand val=popLong();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=AStore.create(LONG_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Long),getCurrentGuard());
}
break;
case JBC_fastore:
{
OPT_Operand val=popFloat();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=AStore.create(FLOAT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Float),getCurrentGuard());
}
break;
case JBC_dastore:
{
OPT_Operand val=popDouble();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=AStore.create(DOUBLE_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Double),getCurrentGuard());
}
break;
case JBC_aastore:
{
OPT_Operand val=pop();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
if (do_CheckStore(ref,val,type)) break;
s=AStore.create(REF_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_bastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) type=VM_TypeReference.Byte;
 else type=VM_TypeReference.Boolean;
s=AStore.create(BYTE_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_castore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Char),getCurrentGuard());
}
break;
case JBC_sastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Short),getCurrentGuard());
}
break;
case JBC_pop:
stack.pop();
break;
case JBC_pop2:
stack.pop2();
break;
case JBC_dup:
{
OPT_Operand op1=stack.pop();
stack.push(op1);
s=pushCopy(op1);
}
break;
case JBC_dup_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op1);
stack.push(op3);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op2);
stack.push(op1);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
OPT_Operand op4=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op4);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_swap:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
}
break;
case JBC_iadd:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_ADD,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ladd:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_ADD,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fadd:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_ADD,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dadd:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_ADD,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_isub:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SUB,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lsub:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SUB,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fsub:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_SUB,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dsub:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_SUB,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_imul:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_MUL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lmul:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_MUL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fmul:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_MUL,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dmul:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_MUL,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_idiv:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_ldiv:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_fdiv:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_DIV,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_ddiv:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_DIV,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_irem:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_lrem:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_frem:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_REM,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_drem:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_REM,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_ineg:
s=_unaryHelper(INT_NEG,popInt(),VM_TypeReference.Int);
break;
case JBC_lneg:
s=_unaryDualHelper(LONG_NEG,popLong(),VM_TypeReference.Long);
break;
case JBC_fneg:
s=_unaryHelper(FLOAT_NEG,popFloat(),VM_TypeReference.Float);
break;
case JBC_dneg:
s=_unaryDualHelper(DOUBLE_NEG,popDouble(),VM_TypeReference.Double);
break;
case JBC_ishl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ishr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_USHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_USHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iand:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_AND,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_land:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_AND,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ior:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_OR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_OR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ixor:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_XOR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lxor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_XOR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iinc:
{
int index=bcodes.getLocalNumber();
s=do_iinc(index,bcodes.getIncrement());
}
break;
case JBC_i2l:
s=_unaryDualHelper(INT_2LONG,popInt(),VM_TypeReference.Long);
break;
case JBC_i2f:
s=_unaryHelper(INT_2FLOAT,popInt(),VM_TypeReference.Float);
break;
case JBC_i2d:
s=_unaryDualHelper(INT_2DOUBLE,popInt(),VM_TypeReference.Double);
break;
case JBC_l2i:
s=_unaryHelper(LONG_2INT,popLong(),VM_TypeReference.Int);
break;
case JBC_l2f:
s=_unaryHelper(LONG_2FLOAT,popLong(),VM_TypeReference.Float);
break;
case JBC_l2d:
s=_unaryDualHelper(LONG_2DOUBLE,popLong(),VM_TypeReference.Double);
break;
case JBC_f2i:
s=_unaryHelper(FLOAT_2INT,popFloat(),VM_TypeReference.Int);
break;
case JBC_f2l:
s=_unaryDualHelper(FLOAT_2LONG,popFloat(),VM_TypeReference.Long);
break;
case JBC_f2d:
s=_unaryDualHelper(FLOAT_2DOUBLE,popFloat(),VM_TypeReference.Double);
break;
case JBC_d2i:
s=_unaryHelper(DOUBLE_2INT,popDouble(),VM_TypeReference.Int);
break;
case JBC_d2l:
s=_unaryDualHelper(DOUBLE_2LONG,popDouble(),VM_TypeReference.Long);
break;
case JBC_d2f:
s=_unaryHelper(DOUBLE_2FLOAT,popDouble(),VM_TypeReference.Float);
break;
case JBC_int2byte:
s=_unaryHelper(INT_2BYTE,popInt(),VM_TypeReference.Byte);
break;
case JBC_int2char:
s=_unaryHelper(INT_2USHORT,popInt(),VM_TypeReference.Char);
break;
case JBC_int2short:
s=_unaryHelper(INT_2SHORT,popInt(),VM_TypeReference.Short);
break;
case JBC_lcmp:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryHelper(LONG_CMP,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpl:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpg:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpl:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpg:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ifeq:
s=_intIfHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifne:
s=_intIfHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_iflt:
s=_intIfHelper(OPT_ConditionOperand.LESS());
break;
case JBC_ifge:
s=_intIfHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_ifgt:
s=_intIfHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_ifle:
s=_intIfHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_icmpeq:
s=_intIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_icmpne:
s=_intIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_if_icmplt:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS());
break;
case JBC_if_icmpge:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_if_icmpgt:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_if_icmple:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_acmpeq:
s=_refIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_acmpne:
s=_refIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto:
{
int offset=bcodes.getBranchOffset();
if (offset != 3) s=_gotoHelper(offset);
}
break;
case JBC_jsr:
s=_jsrHelper(bcodes.getBranchOffset());
break;
case JBC_ret:
s=_retHelper(bcodes.getLocalNumber());
break;
case JBC_tableswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int low=bcodes.getLowSwitchValue();
int high=bcodes.getHighSwitchValue();
int number=high - low + 1;
if (CF_TABLESWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeTableSwitchOffset(v1,low,high);
int offset=match == 0 ? defaultoff : match;
bcodes.skipTableSwitchOffsets(number);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=TableSwitch.create(TABLESWITCH,op0,null,null,new OPT_IntConstantOperand(low),new OPT_IntConstantOperand(high),generateTarget(defaultoff),null,number * 2);
for (int i=0; i < number; ++i) {
TableSwitch.setTarget(s,i,generateTarget(bcodes.getTableSwitchOffset(i)));
}
bcodes.skipTableSwitchOffsets(number);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(number + 1);
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_lookupswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int numpairs=bcodes.getSwitchLength();
if (numpairs == 0) {
s=_gotoHelper(defaultoff);
break;
}
if (CF_LOOKUPSWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeLookupSwitchOffset(v1,numpairs);
int offset=match == 0 ? defaultoff : match;
bcodes.skipLookupSwitchPairs(numpairs);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=LookupSwitch.create(LOOKUPSWITCH,op0,null,null,generateTarget(defaultoff),null,numpairs * 3);
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setMatch(s,i,new OPT_IntConstantOperand(bcodes.getLookupSwitchValue(i)));
LookupSwitch.setTarget(s,i,generateTarget(bcodes.getLookupSwitchOffset(i)));
}
bcodes.skipLookupSwitchPairs(numpairs);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(numpairs + 1);
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_ireturn:
_returnHelper(INT_MOVE,popInt());
break;
case JBC_lreturn:
_returnHelper(LONG_MOVE,popLong());
break;
case JBC_freturn:
_returnHelper(FLOAT_MOVE,popFloat());
break;
case JBC_dreturn:
_returnHelper(DOUBLE_MOVE,popDouble());
break;
case JBC_areturn:
{
OPT_Operand op0=popRef();
if (VM.VerifyAssertions && !op0.isDefinitelyNull()) {
VM_TypeReference retType=op0.getType();
if (retType.isWordType()) {
VM._assert(gc.method.getReturnType().isWordType());
}
 else {
if (retType != VM_TypeReference.JavaLangObject) {
assertIsAssignable(gc.method.getReturnType(),retType);
}
}
}
_returnHelper(REF_MOVE,op0);
}
break;
case JBC_return:
_returnHelper(null,null);
break;
case JBC_getstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
if (!fieldType.isDoubleType() && !fieldType.isFloatType()) {
if (field.isFinal()) {
VM_Class declaringClass=field.getDeclaringClass();
if (declaringClass.isInitialized() || (VM.writingBootImage && declaringClass.isInBootImage())) {
try {
if (fieldType.isPrimitiveType()) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
if (OPT_StaticFieldReader.isStaticFieldNull(field)) {
push(new OPT_NullConstantOperand(),fieldType);
break;
}
 else {
VM_TypeReference rtType=OPT_StaticFieldReader.getTypeFromStaticField(field);
if (rtType == VM_TypeReference.JavaLangString) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
t.type=rtType;
if (rtType != fieldType) t.clearDeclaredType();
t.setPreciseType();
markGuardlessNonNull(t);
}
}
}
}
 catch (NoSuchFieldException e) {
}
}
}
}
}
s=GetStatic.create(GETSTATIC,t,offsetOp,fieldOp);
push(t.copyD2U(),fieldType);
}
break;
case JBC_putstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand r=pop(fieldType);
s=PutStatic.create(PUTSTATIC,r,offsetOp,fieldOp);
}
break;
case JBC_getfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
}
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
s=GetField.create(GETFIELD,t,op1,offsetOp,fieldOp,getCurrentGuard());
push(t.copyD2U(),fieldType);
}
break;
case JBC_putfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
OPT_Operand val=pop(fieldType);
OPT_Operand obj=popRef();
clearCurrentGuard();
if (do_NullCheck(obj)) break;
s=PutField.create(PUTFIELD,val,obj,offsetOp,fieldOp,getCurrentGuard());
}
break;
case JBC_invokevirtual:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
OPT_MethodOperand methOp=OPT_MethodOperand.VIRTUAL(ref,target);
if (this.osrGuardedInline) {
lastOsrBarrier=_createOsrBarrier();
}
s=_callHelper(ref,methOp);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
if (VM.VerifyAssertions) VM._assert(target != null);
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean isExtant=false;
boolean isPreciseType=false;
VM_TypeReference tr=null;
if (receiver.isRegister()) {
OPT_RegisterOperand rop=receiver.asRegister();
isExtant=rop.isExtant();
isPreciseType=rop.isPreciseType();
tr=rop.type;
}
 else if (receiver.isStringConstant()) {
isExtant=true;
isPreciseType=true;
tr=VM_TypeReference.JavaLangString;
}
 else if (VM.VerifyAssertions) {
VM._assert(false,""String_Node_Str"");
}
VM_Type type=tr.peekResolvedType();
if (type != null && type.isResolved() && type.isClassType() && target != null) {
if (type == target.getDeclaringClass()) {
if (isPreciseType) {
methOp.refine(target,true);
}
}
 else {
VM_Method vmeth=OPT_ClassLoaderProxy.lookupMethod(type.asClass(),ref);
if (vmeth != null && vmeth != target) {
methOp.refine(vmeth,isPreciseType);
}
}
}
if (maybeInlineMethod(shouldInline(s,isExtant),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokespecial:
{
VM_MethodReference ref=bcodes.getMethodReference();
VM_Method target=ref.resolveInvokeSpecial();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.SPECIAL(ref,target));
if (target == null) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokestatic:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.STATIC(ref,target));
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokeinterface:
{
VM_MethodReference ref=bcodes.getMethodReference();
bcodes.alignInvokeInterface();
VM_Method resolvedMethod=null;
resolvedMethod=ref.peekInterfaceMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.INTERFACE(ref,resolvedMethod));
OPT_RegisterOperand receiver=Call.getParam(s,0).asRegister();
VM_Class receiverType=(VM_Class)receiver.type.peekResolvedType();
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean requiresImplementsTest=VM.BuildForIMTInterfaceInvocation || (VM.BuildForITableInterfaceInvocation && VM.DirectlyIndexedITables);
if (requiresImplementsTest) {
if (resolvedMethod == null) {
OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
OPT_Instruction getTib=GuardedUnary.create(GET_OBJ_TIB,tibPtr,receiver.copyU2U(),getCurrentGuard());
appendInstruction(getTib);
getTib.bcIndex=RUNTIME_SERVICES_BCI;
VM_Method target=VM_Entrypoints.unresolvedInvokeinterfaceImplementsTestMethod;
OPT_Instruction callCheck=Call.create2(CALL,null,new OPT_IntConstantOperand(target.getOffset()),OPT_MethodOperand.STATIC(target),new OPT_IntConstantOperand(ref.getId()),tibPtr.copyD2U());
if (gc.options.NO_CALLEE_EXCEPTIONS) {
callCheck.markAsNonPEI();
}
appendInstruction(callCheck);
callCheck.bcIndex=RUNTIME_SERVICES_BCI;
requiresImplementsTest=false;
rectifyStateWithErrorHandler();
}
 else {
VM_Type interfaceType=resolvedMethod.getDeclaringClass();
if (receiverType != null && receiverType.isResolved() && !receiverType.isInterface()) {
byte doesImplement=OPT_ClassLoaderProxy.includesType(interfaceType.getTypeRef(),receiverType.getTypeRef());
requiresImplementsTest=doesImplement != YES;
}
}
}
VM_Method vmeth=null;
if (receiverType != null && receiverType.isInitialized() && !receiverType.isInterface()) {
vmeth=OPT_ClassLoaderProxy.lookupMethod(receiverType,ref);
}
if (vmeth != null) {
VM_MethodReference vmethRef=vmeth.getMemberRef().asMethodReference();
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
rectifyStateWithErrorHandler();
}
OPT_MethodOperand mop=OPT_MethodOperand.VIRTUAL(vmethRef,vmeth);
if (receiver.isPreciseType()) {
mop.refine(vmeth,true);
}
Call.setMethod(s,mop);
boolean unresolved=vmethRef.needsDynamicLink(bcodes.method());
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(vmeth.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,receiver.isExtant()),s)) {
return;
}
}
 else {
if (resolvedMethod != null && maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
 else {
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
}
}
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_xxxunusedxxx:
OPT_OptimizingCompilerException.UNREACHABLE();
break;
case JBC_new:
{
VM_TypeReference klass=bcodes.getTypeReference();
OPT_RegisterOperand t=gc.temps.makeTemp(klass);
t.setPreciseType();
markGuardlessNonNull(t);
OPT_Operator operator;
OPT_TypeOperand klassOp;
VM_Class klassType=(VM_Class)klass.peekResolvedType();
if (klassType != null && (klassType.isInitialized() || klassType.isInBootImage())) {
klassOp=makeTypeOperand(klassType);
operator=NEW;
}
 else {
operator=NEW_UNRESOLVED;
klassOp=makeTypeOperand(klass);
}
s=New.create(operator,t,klassOp);
push(t.copyD2U());
rectifyStateWithErrorHandler();
}
break;
case JBC_newarray:
{
VM_Type array=bcodes.getPrimitiveArrayType();
OPT_TypeOperand arrayOp=makeTypeOperand(array);
OPT_RegisterOperand t=gc.temps.makeTemp(array.getTypeRef());
t.setPreciseType();
markGuardlessNonNull(t);
s=NewArray.create(NEWARRAY,t,arrayOp,popInt());
push(t.copyD2U());
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_anewarray:
{
VM_TypeReference elementTypeRef=bcodes.getTypeReference();
s=generateAnewarray(elementTypeRef);
}
break;
case JBC_arraylength:
{
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
if (VM.VerifyAssertions) VM._assert(getArrayTypeOf(op1).isArrayType());
OPT_RegisterOperand t=gc.temps.makeTempInt();
s=GuardedUnary.create(ARRAYLENGTH,t,op1,getCurrentGuard());
push(t.copyD2U());
}
break;
case JBC_athrow:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
VM_TypeReference type=getRefTypeOf(op0);
if (VM.VerifyAssertions) {
if (type != VM_TypeReference.JavaLangObject) assertIsAssignable(VM_TypeReference.JavaLangThrowable,type);
}
if (!gc.method.isInterruptible()) {
appendInstruction(Empty.create(UNINT_END));
}
endOfBasicBlock=true;
OPT_BasicBlock definiteTarget=rectifyStateWithExceptionHandler(type,true);
if (definiteTarget != null) {
appendInstruction(CacheOp.create(SET_CAUGHT_EXCEPTION,op0));
s=Goto.create(GOTO,definiteTarget.makeJumpTarget());
}
 else {
s=Athrow.create(ATHROW,(OPT_RegisterOperand)op0);
}
}
break;
case JBC_checkcast:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (typeRef.isWordType()) {
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
if (DBG_CF) db(""String_Node_Str"" + typeRef);
break;
}
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_CHECKCAST && !classLoading) {
if (op2.isDefinitelyNull()) {
push(op2);
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
if (OPT_ClassLoaderProxy.includesType(typeRef,type) == YES) {
push(op2);
if (DBG_CF) db(""String_Node_Str"" + op2 + ""String_Node_Str""+ typeRef+ ""String_Node_Str""+ type);
break;
}
}
if (!gc.options.NO_CHECKCAST) {
if (classLoading) {
s=TypeCheck.create(CHECKCAST_UNRESOLVED,op2,makeTypeOperand(typeRef));
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=TypeCheck.create(CHECKCAST_NOTNULL,op2,typeOp,getGuard(op2));
}
 else {
s=TypeCheck.create(CHECKCAST,op2,typeOp);
}
}
}
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangClassCastException);
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_instanceof:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_INSTANCEOF && !classLoading) {
if (op2.isDefinitelyNull()) {
push(new OPT_IntConstantOperand(0));
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
int answer=OPT_ClassLoaderProxy.includesType(typeRef,type);
if (answer == YES && isNonNull(op2)) {
push(new OPT_IntConstantOperand(1));
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
break;
}
 else if (answer == NO) {
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
push(new OPT_IntConstantOperand(0));
break;
}
}
OPT_RegisterOperand t=gc.temps.makeTempInt();
if (classLoading) {
s=InstanceOf.create(INSTANCEOF_UNRESOLVED,t,makeTypeOperand(typeRef),op2);
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=InstanceOf.create(INSTANCEOF_NOTNULL,t,typeOp,op2,getGuard(op2));
}
 else {
s=InstanceOf.create(INSTANCEOF,t,typeOp,op2);
}
}
push(t.copyD2U());
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_monitorenter:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (VM.VerifyAssertions) VM._assert(op0.isRef());
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITORENTER,op0,getCurrentGuard());
}
}
break;
case JBC_monitorexit:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITOREXIT,op0,getCurrentGuard());
}
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangIllegalMonitorStateException);
}
break;
case JBC_wide:
{
int widecode=bcodes.getWideOpcode();
int index=bcodes.getWideLocalNumber();
switch (widecode) {
case JBC_iload:
s=do_iload(index);
break;
case JBC_lload:
s=do_lload(index);
break;
case JBC_fload:
s=do_fload(index);
break;
case JBC_dload:
s=do_dload(index);
break;
case JBC_aload:
s=do_aload(index);
break;
case JBC_istore:
s=do_store(index,popInt());
break;
case JBC_lstore:
s=do_store(index,popLong());
break;
case JBC_fstore:
s=do_store(index,popFloat());
break;
case JBC_dstore:
s=do_store(index,popDouble());
break;
case JBC_astore:
s=do_astore(index);
break;
case JBC_iinc:
s=do_iinc(index,bcodes.getWideIncrement());
break;
case JBC_ret:
s=_retHelper(index);
break;
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
}
break;
case JBC_multianewarray:
{
VM_TypeReference arrayType=bcodes.getTypeReference();
OPT_TypeOperand typeOp=makeTypeOperand(arrayType);
int dimensions=bcodes.getArrayDimension();
OPT_TypeOperand dimArrayType=makeTypeOperand(VM_Array.IntArray);
OPT_RegisterOperand dimArray=gc.temps.makeTemp(VM_TypeReference.IntArray);
markGuardlessNonNull(dimArray);
dimArray.setPreciseType();
appendInstruction(NewArray.create(NEWARRAY,dimArray,dimArrayType,new OPT_IntConstantOperand(dimensions)));
for (int i=dimensions; i > 0; i--) {
OPT_LocationOperand loc=new OPT_LocationOperand(VM_TypeReference.Int);
appendInstruction(AStore.create(INT_ASTORE,popInt(),dimArray.copyD2U(),new OPT_IntConstantOperand(i - 1),loc,new OPT_TrueGuardOperand()));
}
OPT_RegisterOperand result=gc.temps.makeTemp(arrayType);
markGuardlessNonNull(result);
result.setPreciseType();
appendInstruction(NewArray.create(NEWOBJMULTIARRAY,result,typeOp,dimArray.copyD2U()));
push(result.copyD2U());
rectifyStateWithErrorHandler();
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_ifnull:
s=_refIfNullHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifnonnull:
s=_refIfNullHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto_w:
{
int offset=bcodes.getWideBranchOffset();
if (offset != 5) s=_gotoHelper(offset);
}
break;
case JBC_jsr_w:
s=_jsrHelper(bcodes.getWideBranchOffset());
break;
case JBC_impdep1:
{
int pseudo_opcode=bcodes.nextPseudoInstruction();
switch (pseudo_opcode) {
case PSEUDO_LoadIntConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new OPT_IntConstantOperand(value));
param1=param2;
param2=value;
break;
}
case PSEUDO_LoadLongConst:
{
long value=bcodes.readLongConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateLongLiteral(value);
pushDual(new OPT_LongConstantOperand(value,offset));
break;
}
case PSEUDO_LoadWordConst:
{
Address a;
a=Address.fromIntSignExtend(bcodes.readIntConst());
a=Address.fromLong(bcodes.readLongConst());
push(new OPT_AddressConstantOperand(a));
if (VM.TraceOnStackReplacement) VM.sysWrite(""String_Node_Str"");
VM.sysWrite(a);
VM.sysWriteln();
break;
}
case PSEUDO_LoadFloatConst:
{
int ibits=bcodes.readIntConst();
float value=Float.intBitsToFloat(ibits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateFloatLiteral(ibits);
push(new OPT_FloatConstantOperand(value,offset));
break;
}
case PSEUDO_LoadDoubleConst:
{
long lbits=bcodes.readLongConst();
double value=VM_Magic.longBitsAsDouble(lbits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + lbits);
int offset=VM_Statics.findOrCreateDoubleLiteral(lbits);
pushDual(new OPT_DoubleConstantOperand(value,offset));
break;
}
case PSEUDO_LoadRetAddrConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new ReturnAddressOperand(value));
break;
}
case PSEUDO_InvokeStatic:
{
VM_Method meth=null;
int targetidx=bcodes.readIntConst();
switch (targetidx) {
case GETREFAT:
meth=VM_Entrypoints.osrGetRefAtMethod;
break;
case CLEANREFS:
meth=VM_Entrypoints.osrCleanRefsMethod;
break;
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + targetidx);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.STATIC(meth));
Call.setAddress(s,new OPT_IntConstantOperand(meth.getOffset()));
if (targetidx == GETREFAT) {
Object realObj=OSR_ObjectHolder.getRefAt(param1,param2);
if (VM.VerifyAssertions) VM._assert(realObj != null);
VM_TypeReference klass=VM_Magic.getObjectType(realObj).getTypeRef();
OPT_RegisterOperand op0=gc.temps.makeTemp(klass);
Call.setResult(s,op0);
pop();
push(op0.copyD2U(),klass);
}
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_InvokeCompiledMethod:
{
int cmid=bcodes.readIntConst();
int origBCIdx=bcodes.readIntConst();
VM_CompiledMethod cm=VM_CompiledMethods.getCompiledMethod(cmid);
VM_Method meth=cm.getMethod();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.COMPILED(meth,cm.getOsrJTOCoffset()));
s.bcIndex=origBCIdx + bciAdjustment;
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_ParamInitEnd:
{
break;
}
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + pseudo_opcode);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
break;
}
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (s != null && !currentBBLE.isSelfRegen()) {
appendInstruction(s);
}
if (VM.VerifyAssertions) VM._assert(bcodes.index() <= runoff);
if (!endOfBasicBlock && bcodes.index() == runoff) {
if (DBG_BB || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
endOfBasicBlock=fallThrough=true;
}
if (endOfBasicBlock) {
if (currentBBLE.isSelfRegen()) {
currentBBLE.block.deleteOut();
if (DBG_CFG || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE.block);
return;
}
if (fallThrough) {
if (VM.VerifyAssertions) VM._assert(bcodes.index() < bcodes.length());
currentBBLE.fallThrough=getOrCreateBlock(bcodes.index());
currentBBLE.block.insertOut(currentBBLE.fallThrough.block);
}
return;
}
}
}",0.9940842663394754
150121,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(ObjectReference object,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  TraceGenerator.addTraceObject(object,allocator);
switch (allocator) {
case ALLOC_DEFAULT:
    break;
case ALLOC_IMMORTAL:
  immortalSpace.postAlloc(object);
break;
case ALLOC_LOS:
loSpace.initializeHeader(object);
break;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
}
traceInducedGC=TraceGenerator.MERLIN_ANALYSIS;
TraceGenerator.traceAlloc(allocator == ALLOC_IMMORTAL,object,typeRef,bytes);
traceInducedGC=false;
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(ObjectReference object,ObjectReference typeRef,int bytes,int allocator) throws InlinePragma {
  TraceGenerator.addTraceObject(object,allocator);
switch (allocator) {
case ALLOC_DEFAULT:
    break;
case ALLOC_IMMORTAL:
  ImmortalSpace.postAlloc(object);
break;
case ALLOC_LOS:
loSpace.initializeHeader(object);
break;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
}
traceInducedGC=TraceGenerator.MERLIN_ANALYSIS;
TraceGenerator.traceAlloc(allocator == ALLOC_IMMORTAL,object,typeRef,bytes);
traceInducedGC=false;
}",0.9988888888888888
150122,"/** 
 * Return the appropriate value. 
 * @return the trace rate.
 */
public int getValue() throws UninterruptiblePragma {
  return (this.value < LOG_BYTES_IN_ADDRESS) ? 0 : this.value - LOG_BYTES_IN_ADDRESS;
}","/** 
 * Return the appropriate value. 
 * @return the trace rate.
 */
public int getValue() throws UninterruptiblePragma {
  return (this.value < LOG_BYTES_IN_ADDRESS) ? 0 : 1 << (this.value - LOG_BYTES_IN_ADDRESS);
}",0.9836065573770492
150123,"/** 
 * This routine is the guts of the SSA construction phase for scalars.  See renameSymbolicRegisters for more details.
 * @param X basic block to search dominator tree from
 * @param S stack of names for each register
 * @param ir governing IR
 */
private void search(OPT_BasicBlock X,Stack[] S){
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  OPT_SSADictionary dictionary=ir.HIRInfo.SSADictionary;
  for (OPT_InstructionEnumeration ie=X.forwardInstrEnumerator(); ie.hasMoreElements(); ) {
    OPT_Instruction A=ie.next();
    if (A.operator() != PHI) {
      for (int u=A.getNumberOfDefs(); u < A.getNumberOfOperands(); u++) {
        OPT_Operand op=A.getOperand(u);
        if (op instanceof OPT_RegisterOperand) {
          OPT_RegisterOperand rop=(OPT_RegisterOperand)op;
          OPT_Register r1=rop.register;
          if (r1.isSSA())           continue;
          if (r1.isPhysical())           continue;
          OPT_RegisterOperand r2=(OPT_RegisterOperand)S[r1.getNumber()].peek();
          if (DEBUG)           System.out.println(""String_Node_Str"" + r1 + ""String_Node_Str""+ r2);
          if (r2 != null) {
            rop.register=r2.register;
            OPT_DefUse.recordUse(rop);
          }
        }
      }
    }
    for (int d=0; d < A.getNumberOfDefs(); d++) {
      OPT_Operand op=A.getOperand(d);
      if (op instanceof OPT_RegisterOperand) {
        OPT_RegisterOperand rop=(OPT_RegisterOperand)op;
        OPT_Register r1=rop.register;
        if (r1.isSSA())         continue;
        if (r1.isPhysical())         continue;
        OPT_Register r2=ir.regpool.getReg(r1);
        if (DEBUG)         System.out.println(""String_Node_Str"" + r2 + ""String_Node_Str""+ r1+ ""String_Node_Str""+ A);
        S[r1.getNumber()].push(new OPT_RegisterOperand(r2,rop.type));
        rop.setRegister(r2);
        r2.scratchObject=r1;
      }
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  for (OPT_BasicBlockEnumeration y=X.getOut(); y.hasMoreElements(); ) {
    OPT_BasicBlock Y=y.next();
    if (DEBUG)     System.out.println(""String_Node_Str"" + Y);
    int j=numPredProcessed[Y.getNumber()]++;
    if (Y.isExit())     continue;
    OPT_Instruction s=Y.firstRealInstruction();
    if (s == null)     continue;
    if (DEBUG)     System.out.println(""String_Node_Str"" + j);
    while (s.operator() == PHI) {
      OPT_Operand val=Phi.getValue(s,j);
      if (val.isRegister()) {
        OPT_Register r1=((OPT_RegisterOperand)Phi.getValue(s,j)).register;
        if (!r1.isSSA()) {
          OPT_RegisterOperand r2=(OPT_RegisterOperand)S[r1.getNumber()].peek();
          if (r2 == null) {
            Phi.setValue(s,j,new OPT_UnreachableOperand());
          }
 else {
            OPT_RegisterOperand rop=r2.copyRO();
            Phi.setValue(s,j,rop);
            OPT_DefUse.recordUse(rop);
          }
          Phi.setPred(s,j,new OPT_BasicBlockOperand(X));
        }
      }
      s=s.nextInstructionInCodeOrder();
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  for (Enumeration c=ir.HIRInfo.dominatorTree.getChildren(X); c.hasMoreElements(); ) {
    OPT_DominatorTreeNode v=(OPT_DominatorTreeNode)c.nextElement();
    search(v.getBlock(),S);
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  for (OPT_InstructionEnumeration a=X.forwardInstrEnumerator(); a.hasMoreElements(); ) {
    OPT_Instruction A=a.next();
    for (int d=0; d < A.getNumberOfDefs(); d++) {
      OPT_Operand newOp=A.getOperand(d);
      if (newOp == null)       continue;
      if (!newOp.isRegister())       continue;
      OPT_Register newReg=newOp.asRegister().register;
      if (newReg.isSSA())       continue;
      if (newReg.isPhysical())       continue;
      OPT_Register r1=(OPT_Register)newReg.scratchObject;
      S[r1.getNumber()].pop();
      if (DEBUG)       System.out.println(""String_Node_Str"" + r1);
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
}","/** 
 * This routine is the guts of the SSA construction phase for scalars.  See renameSymbolicRegisters for more details.
 * @param X basic block to search dominator tree from
 * @param S stack of names for each register
 */
private void search(OPT_BasicBlock X,Stack[] S){
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  OPT_SSADictionary dictionary=ir.HIRInfo.SSADictionary;
  for (OPT_InstructionEnumeration ie=X.forwardInstrEnumerator(); ie.hasMoreElements(); ) {
    OPT_Instruction A=ie.next();
    if (A.operator() != PHI) {
      for (int u=A.getNumberOfDefs(); u < A.getNumberOfOperands(); u++) {
        OPT_Operand op=A.getOperand(u);
        if (op instanceof OPT_RegisterOperand) {
          OPT_RegisterOperand rop=(OPT_RegisterOperand)op;
          OPT_Register r1=rop.register;
          if (r1.isSSA())           continue;
          if (r1.isPhysical())           continue;
          OPT_RegisterOperand r2=(OPT_RegisterOperand)S[r1.getNumber()].peek();
          if (DEBUG)           System.out.println(""String_Node_Str"" + r1 + ""String_Node_Str""+ r2);
          if (r2 != null) {
            rop.register=r2.register;
            OPT_DefUse.recordUse(rop);
          }
        }
      }
    }
    for (int d=0; d < A.getNumberOfDefs(); d++) {
      OPT_Operand op=A.getOperand(d);
      if (op instanceof OPT_RegisterOperand) {
        OPT_RegisterOperand rop=(OPT_RegisterOperand)op;
        OPT_Register r1=rop.register;
        if (r1.isSSA())         continue;
        if (r1.isPhysical())         continue;
        OPT_Register r2=ir.regpool.getReg(r1);
        if (DEBUG)         System.out.println(""String_Node_Str"" + r2 + ""String_Node_Str""+ r1+ ""String_Node_Str""+ A);
        S[r1.getNumber()].push(new OPT_RegisterOperand(r2,rop.type));
        rop.setRegister(r2);
        r2.scratchObject=r1;
      }
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  for (OPT_BasicBlockEnumeration y=X.getOut(); y.hasMoreElements(); ) {
    OPT_BasicBlock Y=y.next();
    if (DEBUG)     System.out.println(""String_Node_Str"" + Y);
    int j=numPredProcessed[Y.getNumber()]++;
    if (Y.isExit())     continue;
    OPT_Instruction s=Y.firstRealInstruction();
    if (s == null)     continue;
    if (DEBUG)     System.out.println(""String_Node_Str"" + j);
    while (s.operator() == PHI) {
      OPT_Operand val=Phi.getValue(s,j);
      if (val.isRegister()) {
        OPT_Register r1=((OPT_RegisterOperand)Phi.getValue(s,j)).register;
        if (!r1.isSSA()) {
          OPT_RegisterOperand r2=(OPT_RegisterOperand)S[r1.getNumber()].peek();
          if (r2 == null) {
            Phi.setValue(s,j,new OPT_UnreachableOperand());
          }
 else {
            OPT_RegisterOperand rop=r2.copyRO();
            Phi.setValue(s,j,rop);
            OPT_DefUse.recordUse(rop);
          }
          Phi.setPred(s,j,new OPT_BasicBlockOperand(X));
        }
      }
      s=s.nextInstructionInCodeOrder();
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  for (Enumeration c=ir.HIRInfo.dominatorTree.getChildren(X); c.hasMoreElements(); ) {
    OPT_DominatorTreeNode v=(OPT_DominatorTreeNode)c.nextElement();
    search(v.getBlock(),S);
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
  for (OPT_InstructionEnumeration a=X.forwardInstrEnumerator(); a.hasMoreElements(); ) {
    OPT_Instruction A=a.next();
    for (int d=0; d < A.getNumberOfDefs(); d++) {
      OPT_Operand newOp=A.getOperand(d);
      if (newOp == null)       continue;
      if (!newOp.isRegister())       continue;
      OPT_Register newReg=newOp.asRegister().register;
      if (newReg.isSSA())       continue;
      if (newReg.isPhysical())       continue;
      OPT_Register r1=(OPT_Register)newReg.scratchObject;
      S[r1.getNumber()].pop();
      if (DEBUG)       System.out.println(""String_Node_Str"" + r1);
    }
  }
  if (DEBUG)   System.out.println(""String_Node_Str"" + X);
}",0.9966988318943626
150124,"/** 
 * Rename the symbolic registers so that each register has only one  definition. <p><em> Note </em>: call this after phi functions have been inserted. <p> <b> Algorithm:</b> from Cytron et. al 91 <pre> call search(entry) search(X): for each statement A in X do if A is not-phi for each r in RHS(A) do if !r.isSSA, replace r with TOP(S(r)) done fi for each r in LHS(A) do if !r.isSSA r2 = new temp register push r2 onto S(r) replace r in A by r2 fi done done (end of first loop) for each Y in succ(X) do j <- whichPred(Y,X) for each phi-function F in Y do replace the j-th operand (r) in RHS(F) with TOP(S(r)) done done (end of second loop) for each Y in Children(X) do call search(Y) done (end of third loop) for each assignment A in X do for each r in LHS(A) do pop(S(r)) done done (end of fourth loop) end <pre>
 * @param ir the governing IR
 * @param symbolicRegisters mapping from integer to symbolic registers
 */
private void renameSymbolicRegisters(OPT_Register[] symbolicRegisters){
  OPT_SSADictionary dictionary=ir.HIRInfo.SSADictionary;
  int n=ir.getNumberOfSymbolicRegisters();
  Stack[] S=new Stack[n + 1];
  for (int i=0; i < S.length; i++) {
    S[i]=new Stack();
    if (i >= symbolicRegisters.length)     continue;
    OPT_Register r=symbolicRegisters[i];
    S[i].push(null);
  }
  OPT_BasicBlock entry=ir.cfg.entry();
  OPT_DefUse.clearDU(ir);
  numPredProcessed=new int[ir.getMaxBasicBlockNumber()];
  search(entry,S);
  OPT_DefUse.recomputeSSA(ir);
  rectifyPhiTypes();
}","/** 
 * Rename the symbolic registers so that each register has only one  definition. <p><em> Note </em>: call this after phi functions have been inserted. <p> <b> Algorithm:</b> from Cytron et. al 91 <pre> call search(entry) search(X): for each statement A in X do if A is not-phi for each r in RHS(A) do if !r.isSSA, replace r with TOP(S(r)) done fi for each r in LHS(A) do if !r.isSSA r2 = new temp register push r2 onto S(r) replace r in A by r2 fi done done (end of first loop) for each Y in succ(X) do j <- whichPred(Y,X) for each phi-function F in Y do replace the j-th operand (r) in RHS(F) with TOP(S(r)) done done (end of second loop) for each Y in Children(X) do call search(Y) done (end of third loop) for each assignment A in X do for each r in LHS(A) do pop(S(r)) done done (end of fourth loop) end <pre>
 * @param symbolicRegisters mapping from integer to symbolic registers
 */
private void renameSymbolicRegisters(OPT_Register[] symbolicRegisters){
  OPT_SSADictionary dictionary=ir.HIRInfo.SSADictionary;
  int n=ir.getNumberOfSymbolicRegisters();
  Stack[] S=new Stack[n + 1];
  for (int i=0; i < S.length; i++) {
    S[i]=new Stack();
    if (i >= symbolicRegisters.length)     continue;
    OPT_Register r=symbolicRegisters[i];
    S[i].push(null);
  }
  OPT_BasicBlock entry=ir.cfg.entry();
  OPT_DefUse.clearDU(ir);
  numPredProcessed=new int[ir.getMaxBasicBlockNumber()];
  search(entry,S);
  OPT_DefUse.recomputeSSA(ir);
  rectifyPhiTypes();
}",0.9898853674983142
150125,"/** 
 * Calculate SSA form for an IR.  This routine holds the guts of the transformation.
 * @param ir the governing IR
 * @param scalarsOnly: should we compute SSA only for scalar variables?
 * @param backwards: If this is true, then every statement thatcan leave the procedure is considered to <em> use </em> every heap  variable.  This option is useful for backwards analyses such as dead store elimination.
 * @param heapTypes: If this variable is non-null, then heap array SSAform will restrict itself to this set of types. If this is null, build  heap array SSA for all types.
 * @param insertUsePhis: Should we insert uphi functions for heap arraySSA? ie., should we create a new name for each heap array at every use  of the heap array? This option is useful for some analyses, such as our redundant load elimination algorithm.
 * @param insertPEIDeps: Should we model exceptions with an explicitheap variable for exception state? This option is useful for global code placement algorithms.
 * @param excludeGuards: Should we exclude guard registers from SSA?
 */
private void computeSSA(OPT_IR ir,boolean scalarsOnly,boolean backwards,Set heapTypes,boolean insertUsePhis,boolean insertPEIDeps,boolean excludeGuards){
  if (ir.options.READS_KILL)   insertUsePhis=true;
  if (!scalarsOnly)   ir.HIRInfo.SSADictionary=new OPT_SSADictionary(heapTypes,insertUsePhis,insertPEIDeps,ir);
 else   ir.HIRInfo.SSADictionary=new OPT_SSADictionary(null,insertUsePhis,insertPEIDeps,ir);
  if (DEBUG)   System.out.println(""String_Node_Str"");
  OPT_DefUse.computeDU(ir);
  OPT_DefUse.recomputeSSA(ir);
  OPT_Register[] symbolicRegisters=getSymbolicRegisters();
  if (DEBUG)   System.out.println(""String_Node_Str"");
  OPT_BitVector[] defSets=getDefSets();
  if (DEBUG)   System.out.println(""String_Node_Str"");
  insertPhiFunctions(ir,defSets,symbolicRegisters,excludeGuards);
  if (!scalarsOnly) {
    insertHeapVariables(ir,backwards);
  }
  if (DEBUG)   System.out.println(""String_Node_Str"");
  if (DEBUG)   OPT_SSA.printInstructions(ir);
  if (DEBUG)   System.out.println(""String_Node_Str"");
  renameSymbolicRegisters(symbolicRegisters);
  if (!scalarsOnly) {
    renameHeapVariables(ir);
  }
  if (DEBUG)   System.out.println(""String_Node_Str"");
  if (ir.options.PRINT_SSA)   OPT_SSA.printInstructions(ir);
}","/** 
 * Calculate SSA form for an IR.  This routine holds the guts of the transformation.
 * @param ir the governing IR
 * @param scalarsOnly should we compute SSA only for scalar variables?
 * @param backwards If this is true, then every statement thatcan leave the procedure is considered to <em> use </em> every heap  variable.  This option is useful for backwards analyses such as dead store elimination.
 * @param heapTypes If this variable is non-null, then heap array SSAform will restrict itself to this set of types. If this is null, build  heap array SSA for all types.
 * @param insertUsePhis Should we insert uphi functions for heap arraySSA? ie., should we create a new name for each heap array at every use  of the heap array? This option is useful for some analyses, such as our redundant load elimination algorithm.
 * @param insertPEIDeps Should we model exceptions with an explicitheap variable for exception state? This option is useful for global code placement algorithms.
 * @param excludeGuards Should we exclude guard registers from SSA?
 */
private void computeSSA(OPT_IR ir,boolean scalarsOnly,boolean backwards,Set heapTypes,boolean insertUsePhis,boolean insertPEIDeps,boolean excludeGuards){
  if (ir.options.READS_KILL)   insertUsePhis=true;
  if (!scalarsOnly)   ir.HIRInfo.SSADictionary=new OPT_SSADictionary(heapTypes,insertUsePhis,insertPEIDeps,ir);
 else   ir.HIRInfo.SSADictionary=new OPT_SSADictionary(null,insertUsePhis,insertPEIDeps,ir);
  if (DEBUG)   System.out.println(""String_Node_Str"");
  OPT_DefUse.computeDU(ir);
  OPT_DefUse.recomputeSSA(ir);
  OPT_Register[] symbolicRegisters=getSymbolicRegisters();
  if (DEBUG)   System.out.println(""String_Node_Str"");
  OPT_BitVector[] defSets=getDefSets();
  if (DEBUG)   System.out.println(""String_Node_Str"");
  insertPhiFunctions(ir,defSets,symbolicRegisters,excludeGuards);
  if (!scalarsOnly) {
    insertHeapVariables(ir,backwards);
  }
  if (DEBUG)   System.out.println(""String_Node_Str"");
  if (DEBUG)   OPT_SSA.printInstructions(ir);
  if (DEBUG)   System.out.println(""String_Node_Str"");
  renameSymbolicRegisters(symbolicRegisters);
  if (!scalarsOnly) {
    renameHeapVariables(ir);
  }
  if (DEBUG)   System.out.println(""String_Node_Str"");
  if (ir.options.PRINT_SSA)   OPT_SSA.printInstructions(ir);
}",0.998696219035202
150126,"/** 
 * Return the meet of the types on the rhs of a phi instruction
 * @param s phi instruction
 * @param a VM_type, or null if all rhs types are nullSIDE EFFECT: bashes the OPT_Instruction scratch field.
 */
private static VM_TypeReference meetPhiType(OPT_Instruction s){
  VM_TypeReference result=null;
  for (int i=0; i < Phi.getNumberOfValues(s); i++) {
    OPT_Operand val=Phi.getValue(s,i);
    if (val instanceof OPT_UnreachableOperand)     continue;
    VM_TypeReference t=val.getType();
    if (t == null) {
      s.scratch=FOUND_NULL_TYPE;
      continue;
    }
 else     if (result == null) {
      result=t;
      continue;
    }
 else {
      VM_TypeReference meet=OPT_ClassLoaderProxy.findCommonSuperclass(result,t);
      if (meet == null) {
        if ((result.isIntLikeType() && (t.isReferenceType() || t.isWordType())) || ((result.isReferenceType() || result.isWordType()) && t.isIntLikeType())) {
          meet=VM_TypeReference.Int;
        }
 else         if (result.isReferenceType() && t.isWordType()) {
          meet=t;
        }
 else         if (result.isWordType() && t.isReferenceType()) {
          meet=result;
        }
      }
      if (VM.VerifyAssertions && meet == null) {
        VM._assert(false,result + ""String_Node_Str"" + t+ ""String_Node_Str"");
      }
      result=meet;
    }
  }
  return result;
}","/** 
 * Return the meet of the types on the rhs of a phi instruction
 * @param s phi instructionSIDE EFFECT: bashes the OPT_Instruction scratch field.
 */
private static VM_TypeReference meetPhiType(OPT_Instruction s){
  VM_TypeReference result=null;
  for (int i=0; i < Phi.getNumberOfValues(s); i++) {
    OPT_Operand val=Phi.getValue(s,i);
    if (val instanceof OPT_UnreachableOperand)     continue;
    VM_TypeReference t=val.getType();
    if (t == null) {
      s.scratch=FOUND_NULL_TYPE;
      continue;
    }
 else     if (result == null) {
      result=t;
      continue;
    }
 else {
      VM_TypeReference meet=OPT_ClassLoaderProxy.findCommonSuperclass(result,t);
      if (meet == null) {
        if ((result.isIntLikeType() && (t.isReferenceType() || t.isWordType())) || ((result.isReferenceType() || result.isWordType()) && t.isIntLikeType())) {
          meet=VM_TypeReference.Int;
        }
 else         if (result.isReferenceType() && t.isWordType()) {
          meet=t;
        }
 else         if (result.isWordType() && t.isReferenceType()) {
          meet=result;
        }
      }
      if (VM.VerifyAssertions && meet == null) {
        VM._assert(false,result + ""String_Node_Str"" + t+ ""String_Node_Str"");
      }
      result=meet;
    }
  }
  return result;
}",0.9790794979079498
150127,"/** 
 * Store a copy of the Heap variables each instruction defs.
 * @param IR governing IR
 * @param store place to store copies
 */
private void copyHeapDefs(OPT_IR ir,HashMap store){
  OPT_SSADictionary dictionary=ir.HIRInfo.SSADictionary;
  for (OPT_BasicBlockEnumeration be=ir.forwardBlockEnumerator(); be.hasMoreElements(); ) {
    OPT_BasicBlock bb=be.next();
    for (Enumeration e=dictionary.getAllInstructions(bb); e.hasMoreElements(); ) {
      OPT_Instruction s=(OPT_Instruction)e.nextElement();
      store.put(s,ir.HIRInfo.SSADictionary.getHeapDefs(s));
    }
  }
}","/** 
 * Store a copy of the Heap variables each instruction defs.
 * @param ir governing IR
 * @param store place to store copies
 */
private void copyHeapDefs(OPT_IR ir,HashMap store){
  OPT_SSADictionary dictionary=ir.HIRInfo.SSADictionary;
  for (OPT_BasicBlockEnumeration be=ir.forwardBlockEnumerator(); be.hasMoreElements(); ) {
    OPT_BasicBlock bb=be.next();
    for (Enumeration e=dictionary.getAllInstructions(bb); e.hasMoreElements(); ) {
      OPT_Instruction s=(OPT_Instruction)e.nextElement();
      store.put(s,ir.HIRInfo.SSADictionary.getHeapDefs(s));
    }
  }
}",0.996545768566494
150128,"/** 
 * Read a reference. Take appropriate read barrier action, and return the value that was read.<p> This is a <b>substituting<b> barrier.  The call to this barrier takes the place of a load.<p>
 * @param src The object being read.
 * @param src The address being read.
 * @param context The context in which the read arose (getfield, for example)
 * @return The reference that was read.
 */
public final Address readBarrier(ObjectReference src,Address slot,int context) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(false);
  return Address.max();
}","/** 
 * Read a reference. Take appropriate read barrier action, and return the value that was read.<p> This is a <b>substituting<b> barrier.  The call to this barrier takes the place of a load.<p>
 * @param src The object reference being read.
 * @param context The context in which the read arose (getfield, for example)
 * @return The reference that was read.
 */
public final Address readBarrier(ObjectReference src,Address slot,int context) throws InlinePragma {
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(false);
  return Address.max();
}",0.9591474245115452
150129,"/** 
 * If the object in question has been forwarded, return its forwarded value.  Mature objects are never forwarded in this collector, so this method is a no-op.<p>
 * @param object The object which may have been forwarded.
 * @param space The space in which the object resides.
 * @return The forwarded value for <code>object</code>.
 */
public static final ObjectReference getForwardedMatureReference(ObjectReference object){
  return object;
}","/** 
 * If the object in question has been forwarded, return its forwarded value.  Mature objects are never forwarded in this collector, so this method is a no-op.<p>
 * @param object The object which may have been forwarded.
 * @return The forwarded value for <code>object</code>.
 */
public static final ObjectReference getForwardedMatureReference(ObjectReference object){
  return object;
}",0.9346016646848988
150130,"/** 
 * Forward the mature space object referred to by a given address and update the address if necessary.  This <i>does not</i> enqueue the referent for processing; the referent must be explicitly enqueued if it is to be processed.<p> <i>In this case do nothing since the mature space is non-copying.</i>
 * @param location The location whose referent is to be forwarded ifnecessary.  The location will be updated if the referent is forwarded.
 * @param object The referent object.
 * @param space The space in which the referent object resides.
 */
protected static void forwardMatureObjectLocation(Address location,ObjectReference object){
}","/** 
 * Forward the mature space object referred to by a given address and update the address if necessary.  This <i>does not</i> enqueue the referent for processing; the referent must be explicitly enqueued if it is to be processed.<p> <i>In this case do nothing since the mature space is non-copying.</i>
 * @param location The location whose referent is to be forwarded ifnecessary.  The location will be updated if the referent is forwarded.
 * @param object The referent object.
 */
protected static void forwardMatureObjectLocation(Address location,ObjectReference object){
}",0.9477977161500816
150131,"/** 
 * Prepare for a collection.  Clear the treadmill to-space head and prepare the collector.  If paranoid, perform a sanity check.
 * @param vm Unused
 * @param mr Unused
 */
public final void prepare(){
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(treadmill.toSpaceEmpty());
}","/** 
 * Prepare for a collection.  Clear the treadmill to-space head and prepare the collector.  If paranoid, perform a sanity check.
 */
public final void prepare(){
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(treadmill.toSpaceEmpty());
}",0.9242424242424242
150132,"/** 
 * Finish up after a collection.
 * @param vm Unused
 * @param mr Unused
 */
public void release(){
  sweepLargePages();
}","/** 
 * Finish up after a collection.
 */
public void release(){
  sweepLargePages();
}",0.8130841121495327
150133,"/** 
 * Return the size of the per-superpage header required by this system.  In this case it is just the underlying superpage header size.
 * @param sizeClass The size class of the cells contained by thissuperpage.
 * @return The size of the per-superpage header required by thissystem.
 */
protected final int superPageHeaderSize() throws InlinePragma {
  return Treadmill.headerSize();
}","/** 
 * Return the size of the per-superpage header required by this system.  In this case it is just the underlying superpage header size.
 * @return The size of the per-superpage header required by thissystem.
 */
protected final int superPageHeaderSize() throws InlinePragma {
  return Treadmill.headerSize();
}",0.8920454545454546
150134,"/** 
 * Attempt to log <code>object</code> for coalescing RC. This is used to handle a race to log the object, and returns <code>true</code> if we are to log the object and <code>false</code> if we lost the race to log the object. <p>If this method returns <code>true</code>, it leaves the object in the <code>BEING_LOGGED</code> state.  It is the responsibility of the caller to change the object to <code>LOGGED</code> once the logging is complete.
 * @see makeLogged
 * @param object The object in question
 * @return <code>true</code> if the race to log<code>object</code>was won.
 */
public static boolean attemptToLog(ObjectReference object) throws UninterruptiblePragma, InlinePragma {
  Word oldValue;
  do {
    oldValue=ObjectModel.prepareAvailableBits(object);
    if (oldValue.and(LOGGING_MASK).EQ(LOGGED))     return false;
  }
 while ((oldValue.and(LOGGING_MASK).EQ(BEING_LOGGED)) || !ObjectModel.attemptAvailableBits(object,oldValue,oldValue.or(BEING_LOGGED)));
  if (Assert.VERIFY_ASSERTIONS) {
    Word value=ObjectModel.readAvailableBitsWord(object);
    Assert._assert(value.and(LOGGING_MASK).EQ(BEING_LOGGED));
  }
  return true;
}","/** 
 * Attempt to log <code>object</code> for coalescing RC. This is used to handle a race to log the object, and returns <code>true</code> if we are to log the object and <code>false</code> if we lost the race to log the object. <p>If this method returns <code>true</code>, it leaves the object in the <code>BEING_LOGGED</code> state.  It is the responsibility of the caller to change the object to <code>LOGGED</code> once the logging is complete.
 * @see #makeLogged(ObjectReference)
 * @param object The object in question
 * @return <code>true</code> if the race to log<code>object</code>was won.
 */
public static boolean attemptToLog(ObjectReference object) throws UninterruptiblePragma, InlinePragma {
  Word oldValue;
  do {
    oldValue=ObjectModel.prepareAvailableBits(object);
    if (oldValue.and(LOGGING_MASK).EQ(LOGGED))     return false;
  }
 while ((oldValue.and(LOGGING_MASK).EQ(BEING_LOGGED)) || !ObjectModel.attemptAvailableBits(object,oldValue,oldValue.or(BEING_LOGGED)));
  if (Assert.VERIFY_ASSERTIONS) {
    Word value=ObjectModel.readAvailableBitsWord(object);
    Assert._assert(value.and(LOGGING_MASK).EQ(BEING_LOGGED));
  }
  return true;
}",0.9922413793103448
150135,"/** 
 * Signify completion of logging <code>object</code>. <code>object</code> is left in the <code>LOGGED</code> state.
 * @see attemptToLog
 * @param object The object whose state is to be changed.
 */
public static void makeLogged(ObjectReference object) throws UninterruptiblePragma, InlinePragma {
  Word value=ObjectModel.readAvailableBitsWord(object);
  Assert._assert(value.and(LOGGING_MASK).NE(LOGGED));
  ObjectModel.writeAvailableBitsWord(object,value.and(LOGGING_MASK.not()));
}","/** 
 * Signify completion of logging <code>object</code>. <code>object</code> is left in the <code>LOGGED</code> state.
 * @see #attemptToLog(ObjectReference)
 * @param object The object whose state is to be changed.
 */
public static void makeLogged(ObjectReference object) throws UninterruptiblePragma, InlinePragma {
  Word value=ObjectModel.readAvailableBitsWord(object);
  Assert._assert(value.and(LOGGING_MASK).NE(LOGGED));
  ObjectModel.writeAvailableBitsWord(object,value.and(LOGGING_MASK.not()));
}",0.9819639278557114
150136,"/** 
 * Coalesce two or three contigious lumps of units, removing start and end lumps from the free list as necessary.
 * @param start The index of the start of the first lump
 * @param start Index of the start of the last lump
 */
private final void coalesce(int start,int end){
  if (getFree(end))   removeFromFree(end);
  if (getFree(start))   removeFromFree(start);
  setSize(start,end - start + getSize(end));
}","/** 
 * Coalesce two or three contigious lumps of units, removing start and end lumps from the free list as necessary.
 * @param start The index of the start of the first lump
 * @param end The index of the start of the last lump
 */
private final void coalesce(int start,int end){
  if (getFree(end))   removeFromFree(end);
  if (getFree(start))   removeFromFree(start);
  setSize(start,end - start + getSize(end));
}",0.9808153477218226
150137,"/** 
 * Return true if a cell is on a given treadmill
 * @param cell The cell being searched for
 * @param head The head of the treadmill
 * @return True if the cell is found on the treadmill
 */
public final boolean isMember(Address node){
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(isNode(node));
  boolean result=false;
  if (lock != null)   lock.acquire();
  Address cur=head;
  while (!cur.isZero()) {
    if (cur.EQ(node)) {
      result=true;
      break;
    }
    cur=cur.loadAddress(NEXT_OFFSET);
  }
  if (lock != null)   lock.release();
  return result;
}","/** 
 * Return true if a cell is on a given treadmill
 * @param node The cell being searched for
 * @return True if the cell is found on the treadmill
 */
public final boolean isMember(Address node){
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(isNode(node));
  boolean result=false;
  if (lock != null)   lock.acquire();
  Address cur=head;
  while (!cur.isZero()) {
    if (cur.EQ(node)) {
      result=true;
      break;
    }
    cur=cur.loadAddress(NEXT_OFFSET);
  }
  if (lock != null)   lock.release();
  return result;
}",0.9556561085972852
150138,"/** 
 * writes a <code>long</code> in hexadecimal
 * @param l the Word to be logged
 * @param bytes the number of bytes from the long to be logged.  Ifless than 8 then the least significant bytes are logged and some of the most significant bytes are ignored.
 */
private static void writeHex(Word w,int bytes){
  int hexDigits=bytes * (1 << LOG_HEX_DIGITS_IN_BYTE);
  int nextDigit;
  char[] intBuffer=getIntBuffer();
  write(HEX_PREFIX);
  for (int digitNumber=hexDigits - 1; digitNumber >= 0; digitNumber--) {
    nextDigit=w.rshl(digitNumber << LOG_BITS_IN_HEX_DIGIT).toInt() & 0xf;
    char nextChar=Barriers.getArrayNoBarrier(hexDigitCharacter,nextDigit);
    add(nextChar);
  }
}","/** 
 * writes a <code>long</code> in hexadecimal
 * @param w the Word to be logged
 * @param bytes the number of bytes from the long to be logged.  Ifless than 8 then the least significant bytes are logged and some of the most significant bytes are ignored.
 */
private static void writeHex(Word w,int bytes){
  int hexDigits=bytes * (1 << LOG_HEX_DIGITS_IN_BYTE);
  int nextDigit;
  char[] intBuffer=getIntBuffer();
  write(HEX_PREFIX);
  for (int digitNumber=hexDigits - 1; digitNumber >= 0; digitNumber--) {
    nextDigit=w.rshl(digitNumber << LOG_BITS_IN_HEX_DIGIT).toInt() & 0xf;
    char nextChar=Barriers.getArrayNoBarrier(hexDigitCharacter,nextDigit);
    add(nextChar);
  }
}",0.9985401459854014
150139,"/** 
 * Return the superpage for a given cell.  If the cell is a small cell then this is found by masking the cell address to find the containing page.  Otherwise the first word of the cell contains the address of the page.
 * @param cell The address of the first word of the cell (exclusiveof any sub-class specific metadata).
 * @param small True if the cell is a small cell (single page superpage).
 * @return The address of the first word of the superpage containing<code>cell</code>.
 */
public static final Address getSuperPage(Address cell) throws InlinePragma {
  return cell.toWord().and(PAGE_MASK).toAddress();
}","/** 
 * Return the superpage for a given cell.  If the cell is a small cell then this is found by masking the cell address to find the containing page.  Otherwise the first word of the cell contains the address of the page.
 * @param cell The address of the first word of the cell (exclusiveof any sub-class specific metadata).
 * @return The address of the first word of the superpage containing<code>cell</code>.
 */
public static final Address getSuperPage(Address cell) throws InlinePragma {
  return cell.toWord().and(PAGE_MASK).toAddress();
}",0.9367521367521368
150140,"/** 
 * Constructor
 * @param vmr The virtual memory resource from which this free listallocator will acquire virtual memory.
 * @param mr The memory resource against which memory consumptionfor this free list allocator will be accounted.
 */
public LargeObjectAllocator(LargeObjectSpace space){
  this.space=space;
}","/** 
 * Constructor
 * @param space The space with which this large object allocatorwill be associated.
 */
public LargeObjectAllocator(LargeObjectSpace space){
  this.space=space;
}",0.6412825651302605
150141,"/** 
 * Free a cell.  If the cell is large (own superpage) then release the superpage, if not add to the super page's free list and if all cells on the superpage are free, then release the superpage.
 * @param cell The address of the first byte of the cell to be freed
 * @param sp The superpage containing the cell
 * @param sizeClass The sizeclass of the cell.
 */
public final void free(Address cell) throws InlinePragma {
  space.release(getSuperPage(cell));
}","/** 
 * Free a cell.  If the cell is large (own superpage) then release the superpage, if not add to the super page's free list and if all cells on the superpage are free, then release the superpage.
 * @param cell The address of the first byte of the cell to be freed
 */
public final void free(Address cell) throws InlinePragma {
  space.release(getSuperPage(cell));
}",0.8872901678657075
150142,"/** 
 * Return the live word for a region including a given address
 * @param addr The address for which the live word is required
 * @return A word containing live bits for the given address.
 */
protected static final Word getLiveBits(Address address){
  return getLiveWordAddress(address).loadWord();
}","/** 
 * Return the live word for a region including a given address
 * @param address The address for which the live word is required
 * @return A word containing live bits for the given address.
 */
protected static final Word getLiveBits(Address address){
  return getLiveWordAddress(address).loadWord();
}",0.99510603588907
150143,"/** 
 * Constructor
 * @param vmr The virtual memory resource from which this free listallocator will acquire virtual memory.
 * @param mr The memory resource against which memory consumptionfor this free list allocator will be accounted.
 */
public SegregatedFreeList(Space space){
  blockAllocator=new BlockAllocator(space);
  freeList=AddressArray.create(SIZE_CLASSES);
  firstBlock=AddressArray.create(SIZE_CLASSES);
  lastBlock=AddressArray.create(SIZE_CLASSES);
  currentBlock=AddressArray.create(SIZE_CLASSES);
  blockBucketHead=AddressArray.create(BLOCK_BUCKETS);
  blockBucketTail=AddressArray.create(BLOCK_BUCKETS);
}","/** 
 * Constructor
 * @param space The space with which this allocator will be associated
 */
public SegregatedFreeList(Space space){
  blockAllocator=new BlockAllocator(space);
  freeList=AddressArray.create(SIZE_CLASSES);
  firstBlock=AddressArray.create(SIZE_CLASSES);
  lastBlock=AddressArray.create(SIZE_CLASSES);
  currentBlock=AddressArray.create(SIZE_CLASSES);
  blockBucketHead=AddressArray.create(BLOCK_BUCKETS);
  blockBucketTail=AddressArray.create(BLOCK_BUCKETS);
}",0.8227848101265823
150144,"/** 
 * Get the ""next"" pointer in a buffer forming the linked buffer chain.
 * @param bufRef The buffer whose next field is to be returned.
 * @return The next field for this buffer.
 */
protected final Address getNext(Address buf){
  return buf.loadAddress();
}","/** 
 * Get the ""next"" pointer in a buffer forming the linked buffer chain.
 * @param buf The buffer whose next field is to be returned.
 * @return The next field for this buffer.
 */
protected final Address getNext(Address buf){
  return buf.loadAddress();
}",0.9942418426103646
150145,"/** 
 * Get the ""next"" pointer in a buffer forming the linked buffer chain.
 * @param bufRef The buffer whose next field is to be returned.
 * @return The next field for this buffer.
 */
protected final Address getPrev(Address buf){
  return buf.loadAddress(PREV_OFFSET);
}","/** 
 * Get the ""next"" pointer in a buffer forming the linked buffer chain.
 * @param buf The buffer whose next field is to be returned.
 * @return The next field for this buffer.
 */
protected final Address getPrev(Address buf){
  return buf.loadAddress(PREV_OFFSET);
}",0.994475138121547
150146,"/** 
 * Set the ""next"" pointer in a buffer forming the linked buffer chain.
 * @param bufRef The buffer whose next field is to be set.
 * @param next The reference to which next should point.
 */
private static final void setNext(Address buf,Address next){
  buf.store(next);
}","/** 
 * Set the ""next"" pointer in a buffer forming the linked buffer chain.
 * @param buf The buffer whose next field is to be set.
 * @param next The reference to which next should point.
 */
private static final void setNext(Address buf,Address next){
  buf.store(next);
}",0.9945553539019965
150147,"/** 
 * Set the ""prev"" pointer in a buffer forming the linked buffer chain.
 * @param bufRef The buffer whose next field is to be set.
 * @param next The reference to which next should point.
 */
private final void setPrev(Address buf,Address prev){
  buf.store(prev,PREV_OFFSET);
}","/** 
 * Set the ""prev"" pointer in a buffer forming the linked buffer chain.
 * @param buf The buffer whose next field is to be set.
 * @param prev The reference to which prev should point.
 */
private final void setPrev(Address buf,Address prev){
  buf.store(prev,PREV_OFFSET);
}",0.966131907308378
150148,"/** 
 * Constructor
 * @param rps The space from which the instance should obtain buffers.
 * @param airty The arity of the data to be enqueued
 */
public SortTODSharedDeque(RawPageSpace rps,int arity){
  super(rps,arity);
}","/** 
 * Constructor
 * @param rps The space from which the instance should obtain buffers.
 * @param arity The arity of the data to be enqueued
 */
public SortTODSharedDeque(RawPageSpace rps,int arity){
  super(rps,arity);
}",0.9910714285714286
150149,"/** 
 * Constructor
 * @param queue The shared queue to which this queue will appendits buffers (when full or flushed) and from which it will aquire new buffers when it has exhausted its own.
 */
public TraceBuffer(SharedDeque pool){
  super(pool);
}","/** 
 * Constructor
 * @param pool The shared queue to which this queue will append itsbuffers (when full or flushed) and from which it will aquire new buffers when it has exhausted its own.
 */
public TraceBuffer(SharedDeque pool){
  super(pool);
}",0.9659318637274548
150150,"/** 
 * The ""typical"" number of objects in each tile
 * @param blocksize The size of a tile
 * @return The maximum number of objects in a tile
 */
public int maxObjectsPerBlock(int blockSize){
  return blockSize / ServerInterpreter.computeHeaderSize();
}","/** 
 * The ""typical"" number of objects in each tile
 * @param blockSize The size of a tile
 * @return The maximum number of objects in a tile
 */
public int maxObjectsPerBlock(int blockSize){
  return blockSize / ServerInterpreter.computeHeaderSize();
}",0.9960629921259844
150151,"/** 
 * Create a new driver for this collector
 * @param name The name of this driver
 * @param lospace the large object space for this allocator
 * @param blocksize The tile size
 * @param size The size (in blocks) of the space
 * @param threshold the size threshold of the LOS
 * @param mainSpace Is this the main space?
 */
public TreadmillDriver(String name,LargeObjectSpace lospace,int blockSize,int threshold,boolean mainSpace){
  this.lospace=lospace;
  this.threshold=threshold;
  Address start=lospace.getStart();
  Extent extent=lospace.getExtent();
  this.blockSize=blockSize;
  maxAddr=start;
  int maxTileNum=countTileNum(extent,blockSize);
  tiles=new Tile[maxTileNum];
  for (int i=0; i < maxTileNum; i++)   tiles[i]=new Tile();
  subspace=new Subspace(start,start,0,blockSize,0);
  allTileNum=0;
  String tmp=(blockSize < 1024) ? ""String_Node_Str"" + blockSize + ""String_Node_Str"" : ""String_Node_Str"" + (blockSize / 1024) + ""String_Node_Str"";
  space=new ServerSpace(Plan.getNextServerSpaceId(),name,""String_Node_Str"",""String_Node_Str"",tmp,maxTileNum,""String_Node_Str"",mainSpace);
  setTilenames(subspace,0);
  usedSpaceStream=new Stream(space,LOS_USED_SPACE_STREAM,StreamConstants.INT_TYPE,""String_Node_Str"",0,blockSize,0,0,""String_Node_Str"",""String_Node_Str"",StreamConstants.PRESENTATION_PERCENT,StreamConstants.PAINT_STYLE_ZERO,0,Color.Red);
  objectsStream=new Stream(space,LOS_OBJECTS_STREAM,StreamConstants.SHORT_TYPE,""String_Node_Str"",0,(int)(blockSize / threshold),0,0,""String_Node_Str"",""String_Node_Str"",StreamConstants.PRESENTATION_PLUS,StreamConstants.PAINT_STYLE_ZERO,0,Color.Green);
  space.resize(0);
  zero();
}","/** 
 * Create a new driver for this collector
 * @param name The name of this driver
 * @param lospace the large object space for this allocator
 * @param blockSize The tile size
 * @param threshold the size threshold of the LOS
 * @param mainSpace Is this the main space?
 */
public TreadmillDriver(String name,LargeObjectSpace lospace,int blockSize,int threshold,boolean mainSpace){
  this.lospace=lospace;
  this.threshold=threshold;
  Address start=lospace.getStart();
  Extent extent=lospace.getExtent();
  this.blockSize=blockSize;
  maxAddr=start;
  int maxTileNum=countTileNum(extent,blockSize);
  tiles=new Tile[maxTileNum];
  for (int i=0; i < maxTileNum; i++)   tiles[i]=new Tile();
  subspace=new Subspace(start,start,0,blockSize,0);
  allTileNum=0;
  String tmp=(blockSize < 1024) ? ""String_Node_Str"" + blockSize + ""String_Node_Str"" : ""String_Node_Str"" + (blockSize / 1024) + ""String_Node_Str"";
  space=new ServerSpace(Plan.getNextServerSpaceId(),name,""String_Node_Str"",""String_Node_Str"",tmp,maxTileNum,""String_Node_Str"",mainSpace);
  setTilenames(subspace,0);
  usedSpaceStream=new Stream(space,LOS_USED_SPACE_STREAM,StreamConstants.INT_TYPE,""String_Node_Str"",0,blockSize,0,0,""String_Node_Str"",""String_Node_Str"",StreamConstants.PRESENTATION_PERCENT,StreamConstants.PAINT_STYLE_ZERO,0,Color.Red);
  objectsStream=new Stream(space,LOS_OBJECTS_STREAM,StreamConstants.SHORT_TYPE,""String_Node_Str"",0,(int)(blockSize / threshold),0,0,""String_Node_Str"",""String_Node_Str"",StreamConstants.PRESENTATION_PLUS,StreamConstants.PAINT_STYLE_ZERO,0,Color.Green);
  space.resize(0);
  zero();
}",0.9842251778533868
150152,"/** 
 * Gets the value of bits available for memory manager use in an object, in preparation for setting those bits.
 * @param o the address of the object
 * @return the value of the bits
 */
public static Word prepareAvailableBits(ObjectReference object){
  return null;
}","/** 
 * Gets the value of bits available for memory manager use in an object, in preparation for setting those bits.
 * @param object the address of the object
 * @return the value of the bits
 */
public static Word prepareAvailableBits(ObjectReference object){
  return null;
}",0.9909255898366606
150153,"/** 
 * Attempts to set the bits available for memory manager use in an object.  The attempt will only be successful if the current value of the bits matches <code>oldVal</code>.  The comparison with the current value and setting are atomic with respect to other allocators.
 * @param oject the address of the object
 * @param oldVal the required current value of the bits
 * @param newVal the desired new value of the bits
 * @return <code>true</code> if the bits were set,<code>false</code> otherwise
 */
public static boolean attemptAvailableBits(ObjectReference object,Word oldVal,Word newVal){
  return false;
}","/** 
 * Attempts to set the bits available for memory manager use in an object.  The attempt will only be successful if the current value of the bits matches <code>oldVal</code>.  The comparison with the current value and setting are atomic with respect to other allocators.
 * @param object the address of the object
 * @param oldVal the required current value of the bits
 * @param newVal the desired new value of the bits
 * @return <code>true</code> if the bits were set,<code>false</code> otherwise
 */
public static boolean attemptAvailableBits(ObjectReference object,Word oldVal,Word newVal){
  return false;
}",0.9991889699918896
150154,"/** 
 * Emit code to store to a float array
 */
protected final void emit_fastore(){
  VM_Barriers.compileModifyCheck(asm,12);
  asm.emitMOV_Reg_RegDisp(T0,SP,4);
  asm.emitMOV_Reg_RegDisp(S0,SP,8);
  genBoundsCheck(asm,T0,S0);
  asm.emitMOV_Reg_RegDisp(T1,SP,0);
  asm.emitMOV_RegIdx_Reg(S0,T0,asm.WORD,0,T1);
  asm.emitADD_Reg_Imm(SP,WORDSIZE * 3);
}","/** 
 * Emit code to store to a float array
 */
protected final void emit_fastore(){
  VM_Barriers.compileModifyCheck(asm,8);
  asm.emitMOV_Reg_RegDisp(T0,SP,4);
  asm.emitMOV_Reg_RegDisp(S0,SP,8);
  genBoundsCheck(asm,T0,S0);
  asm.emitMOV_Reg_RegDisp(T1,SP,0);
  asm.emitMOV_RegIdx_Reg(S0,T0,asm.WORD,0,T1);
  asm.emitADD_Reg_Imm(SP,WORDSIZE * 3);
}",0.9957325746799432
150155,"/** 
 * ""Semantic inlining"" of methods of the VM_Magic class. Based on the methodName, generate a sequence of opt instructions that implement the magic, updating the expression stack as necessary.
 * @param bc2ir the bc2ir object that is generating the ir containing this magic
 * @param gc must be bc2ir.gc
 * @param meth the VM_Method that is the magic method
 */
static boolean generateMagic(OPT_BC2IR bc2ir,OPT_GenerationContext gc,VM_MethodReference meth) throws OPT_MagicNotImplementedException {
  if (gc.method.hasNoInlinePragma())   gc.allocFrame=true;
  bc2ir.markBBUnsafeForScheduling();
  VM_Atom methodName=meth.getName();
  boolean address=(meth.getType() == VM_TypeReference.Address);
  VM_TypeReference[] types=meth.getParameterTypes();
  if (address && isLoad(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(meth.getReturnType());
    bc2ir.appendInstruction(Load.create(getOperator(meth.getReturnType(),LOAD_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U());
  }
 else   if (address && isPrepare(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(meth.getReturnType());
    bc2ir.appendInstruction(Prepare.create(getOperator(meth.getReturnType(),PREPARE_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U());
  }
 else   if (address && methodName == VM_MagicNames.attempt) {
    VM_TypeReference attemptType=types[0];
    OPT_Operand offset=(types.length == 2) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(getOperator(attemptType,ATTEMPT_OP),test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (address && methodName == VM_MagicNames.store) {
    VM_TypeReference storeType=types[0];
    OPT_Operand offset=(types.length == 1) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(getOperator(storeType,STORE_OP),val,base,offset,null));
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    OPT_RegisterOperand rop=gc.temps.makePROp();
    bc2ir.markGuardlessNonNull(rop);
    bc2ir.push(rop);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    OPT_Operand val=bc2ir.popRef();
    if (val instanceof OPT_RegisterOperand) {
      bc2ir.appendInstruction(Move.create(REF_MOVE,gc.temps.makePROp(),val));
    }
 else {
      String msg=""String_Node_Str"";
      throw OPT_MagicNotImplementedException.UNEXPECTED(msg);
    }
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    OPT_Instruction s=bc2ir.generateAnewarray(meth.getType().getArrayElementType());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    OPT_Operand op1=bc2ir.pop();
    bc2ir.clearCurrentGuard();
    if (bc2ir.do_NullCheck(op1))     return true;
    OPT_RegisterOperand t=gc.temps.makeTempInt();
    OPT_Instruction s=GuardedUnary.create(ARRAYLENGTH,t,op1,bc2ir.getCurrentGuard());
    bc2ir.push(t.copyD2U());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offset=gc.temps.makeTempInt();
    OPT_RegisterOperand result;
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        result=gc.temps.makeTemp(VM_TypeReference.Byte);
        bc2ir.appendInstruction(Load.create(BYTE_LOAD,result,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        result=gc.temps.makeTemp(VM_TypeReference.Int);
        bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Load.create(INT_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      result=gc.temps.makeTemp(elementType);
      bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Load.create(REF_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
    bc2ir.push(result.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offset=gc.temps.makeTempInt();
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        bc2ir.appendInstruction(Store.create(BYTE_STORE,val,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Store.create(INT_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Store.create(REF_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getWordAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setWordAtOffset) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Load.create(LONG_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setLongAtOffset) {
    OPT_Operand val=bc2ir.popLong();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(LONG_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getDoubleAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Load.create(DOUBLE_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setDoubleAtOffset) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(DOUBLE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectArrayAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 4) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,loc));
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Byte);
    bc2ir.appendInstruction(Load.create(BYTE_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(BYTE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Char);
    bc2ir.appendInstruction(Load.create(USHORT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(SHORT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,memAddr,new OPT_IntConstantOperand(0),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryWord) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_IntConstantOperand(0),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryAddress) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_IntConstantOperand(0),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,memAddr,new OPT_IntConstantOperand(0),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryWord) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_IntConstantOperand(0),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryAddress) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 3) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_IntConstantOperand(0),loc));
  }
 else   if (meth.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=meth.getParameterTypes();
    int numArgs=args.length;
    VM_Field ip=VM_Entrypoints.getSysCallField(meth.getName().toString());
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(ip);
    OPT_Instruction call=Call.create(SYSCALL,null,null,mo,null,args.length);
    for (int i=args.length - 1; i >= 0; i--) {
      Call.setParam(call,i,bc2ir.pop(args[i]));
    }
    VM_TypeReference rtype=meth.getReturnType();
    if (!rtype.isVoidType()) {
      OPT_RegisterOperand op0=gc.temps.makeTemp(rtype);
      Call.setResult(call,op0);
      bc2ir.push(op0.copyD2U(),rtype);
    }
    bc2ir.appendInstruction(call);
  }
 else   if (methodName == VM_MagicNames.threadAsCollectorThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsProcessor) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Processor);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsAddress) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObject) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObjectArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsRegisters) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsShortArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ShortArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsStack) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.floatAsIntBits) {
    OPT_Operand val=bc2ir.popFloat();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Unary.create(FLOAT_AS_INT_BITS,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.intBitsAsFloat) {
    OPT_Operand val=bc2ir.popInt();
    OPT_RegisterOperand op0=gc.temps.makeTempFloat();
    bc2ir.appendInstruction(Unary.create(INT_BITS_AS_FLOAT,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.doubleAsLongBits) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Unary.create(DOUBLE_AS_LONG_BITS,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.longBitsAsDouble) {
    OPT_Operand val=bc2ir.popLong();
    OPT_RegisterOperand op0=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Unary.create(LONG_BITS_AS_DOUBLE,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand guard=bc2ir.getGuard(val);
    if (guard == null) {
      guard=new OPT_TrueGuardOperand();
    }
    OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(GuardedUnary.create(GET_OBJ_TIB,tibPtr,val,guard));
    OPT_RegisterOperand op0;
    VM_TypeReference argType=val.getType();
    if (argType.isArrayType()) {
      op0=gc.temps.makeTemp(VM_TypeReference.VM_Array);
    }
 else {
      if (argType == VM_TypeReference.JavaLangObject || argType == VM_TypeReference.JavaLangCloneable || argType == VM_TypeReference.JavaIoSerializable) {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Type);
      }
 else {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Class);
      }
    }
    bc2ir.markGuardlessNonNull(op0);
    bc2ir.appendInstruction(Unary.create(GET_TYPE_FROM_TIB,op0,tibPtr.copyD2U()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    OPT_Operand val=bc2ir.popRef();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(GuardedUnary.create(ARRAYLENGTH,op0,val,new OPT_TrueGuardOperand()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    OPT_Instruction s=Call.create0(CALL,null,bc2ir.popRef(),null);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    OPT_Operand code=bc2ir.popRef();
    OPT_Operand args=bc2ir.popRef();
    bc2ir.appendInstruction(Call.create1(CALL,null,code,null,args));
  }
 else   if ((methodName == VM_MagicNames.invokeMethodReturningObject) || (methodName == VM_MagicNames.invokeMethodReturningVoid) || (methodName == VM_MagicNames.invokeMethodReturningLong)|| (methodName == VM_MagicNames.invokeMethodReturningDouble)|| (methodName == VM_MagicNames.invokeMethodReturningFloat)|| (methodName == VM_MagicNames.invokeMethodReturningInt)) {
    OPT_Operand spills=bc2ir.popRef();
    OPT_Operand fprs=bc2ir.popRef();
    OPT_Operand gprs=bc2ir.popRef();
    OPT_Operand code=bc2ir.popRef();
    OPT_RegisterOperand res=null;
    if (methodName == VM_MagicNames.invokeMethodReturningObject) {
      res=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
      bc2ir.push(res.copyD2U());
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningLong) {
      res=gc.temps.makeTemp(VM_TypeReference.Long);
      bc2ir.push(res.copyD2U(),VM_TypeReference.Long);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
      res=gc.temps.makeTempDouble();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Double);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
      res=gc.temps.makeTempFloat();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Float);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningInt) {
      res=gc.temps.makeTempInt();
      bc2ir.push(res.copyD2U());
    }
    VM_Field target=VM_Entrypoints.reflectiveMethodInvokerInstructionsField;
    OPT_MethodOperand met=OPT_MethodOperand.STATIC(target);
    OPT_Instruction s=Call.create4(CALL,res,new OPT_IntConstantOperand(target.getOffset()),met,code,gprs,fprs,spills);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.saveThreadStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_IntConstantOperand(target.getOffset()),mo,p1));
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    OPT_Operand p2=bc2ir.popRef();
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.threadSwitchInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create2(CALL,null,new OPT_IntConstantOperand(target.getOffset()),mo,p1,p2));
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    VM_Field target=VM_Entrypoints.restoreHardwareExceptionStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_IntConstantOperand(target.getOffset()),mo,bc2ir.popRef()));
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Prepare.create(PREPARE_INT,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareObject) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareAddress) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareWord) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    OPT_Operand newVal=bc2ir.popInt();
    OPT_Operand oldVal=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_INT,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptObject) {
    OPT_Operand newVal=bc2ir.popRef();
    OPT_Operand oldVal=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptAddress) {
    OPT_Operand newVal=bc2ir.popAddress();
    OPT_Operand oldVal=bc2ir.popAddress();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptWord) {
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (generatePolymorphicMagic(bc2ir,gc,meth,methodName)) {
    return true;
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Nullary.create(GET_TIME_BASE,op0));
    bc2ir.pushDual(op0.copyD2U());
  }
 else {
    return OPT_GenerateMachineSpecificMagic.generateMagic(bc2ir,gc,meth);
  }
  return true;
}","/** 
 * ""Semantic inlining"" of methods of the VM_Magic class. Based on the methodName, generate a sequence of opt instructions that implement the magic, updating the expression stack as necessary.
 * @param bc2ir the bc2ir object that is generating the ir containing this magic
 * @param gc must be bc2ir.gc
 * @param meth the VM_Method that is the magic method
 */
static boolean generateMagic(OPT_BC2IR bc2ir,OPT_GenerationContext gc,VM_MethodReference meth) throws OPT_MagicNotImplementedException {
  if (gc.method.hasNoInlinePragma())   gc.allocFrame=true;
  bc2ir.markBBUnsafeForScheduling();
  VM_Atom methodName=meth.getName();
  boolean address=(meth.getType() == VM_TypeReference.Address);
  VM_TypeReference[] types=meth.getParameterTypes();
  VM_TypeReference returnType=meth.getReturnType();
  if (address && isLoad(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(returnType);
    bc2ir.appendInstruction(Load.create(getOperator(returnType,LOAD_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U(),returnType);
  }
 else   if (address && isPrepare(methodName)) {
    OPT_Operand offset=(types.length == 0) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand result=gc.temps.makeTemp(returnType);
    bc2ir.appendInstruction(Prepare.create(getOperator(returnType,PREPARE_OP),result,base,offset,null));
    bc2ir.push(result.copyD2U(),returnType);
  }
 else   if (address && methodName == VM_MagicNames.attempt) {
    VM_TypeReference attemptType=types[0];
    OPT_Operand offset=(types.length == 2) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(getOperator(attemptType,ATTEMPT_OP),test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U(),returnType);
  }
 else   if (address && methodName == VM_MagicNames.store) {
    VM_TypeReference storeType=types[0];
    OPT_Operand offset=(types.length == 1) ? new OPT_IntConstantOperand(0) : bc2ir.pop();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand base=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(getOperator(storeType,STORE_OP),val,base,offset,null));
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    OPT_RegisterOperand rop=gc.temps.makePROp();
    bc2ir.markGuardlessNonNull(rop);
    bc2ir.push(rop);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    OPT_Operand val=bc2ir.popRef();
    if (val instanceof OPT_RegisterOperand) {
      bc2ir.appendInstruction(Move.create(REF_MOVE,gc.temps.makePROp(),val));
    }
 else {
      String msg=""String_Node_Str"";
      throw OPT_MagicNotImplementedException.UNEXPECTED(msg);
    }
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    OPT_Instruction s=bc2ir.generateAnewarray(meth.getType().getArrayElementType());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    OPT_Operand op1=bc2ir.pop();
    bc2ir.clearCurrentGuard();
    if (bc2ir.do_NullCheck(op1))     return true;
    OPT_RegisterOperand t=gc.temps.makeTempInt();
    OPT_Instruction s=GuardedUnary.create(ARRAYLENGTH,t,op1,bc2ir.getCurrentGuard());
    bc2ir.push(t.copyD2U());
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offset=gc.temps.makeTempInt();
    OPT_RegisterOperand result;
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        result=gc.temps.makeTemp(VM_TypeReference.Byte);
        bc2ir.appendInstruction(Load.create(BYTE_LOAD,result,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        result=gc.temps.makeTemp(VM_TypeReference.Int);
        bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Load.create(INT_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      result=gc.temps.makeTemp(elementType);
      bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Load.create(REF_LOAD,result,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
    bc2ir.push(result.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    VM_TypeReference elementType=meth.getType().getArrayElementType();
    OPT_Operand val=bc2ir.pop();
    OPT_Operand index=bc2ir.popInt();
    OPT_Operand ref=bc2ir.popRef();
    OPT_RegisterOperand offset=gc.temps.makeTempInt();
    if (meth.getType().isCodeArrayType()) {
      if (VM.BuildForIA32) {
        bc2ir.appendInstruction(Store.create(BYTE_STORE,val,ref,index,new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
 else       if (VM.BuildForPowerPC) {
        bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_INT)));
        bc2ir.appendInstruction(Store.create(INT_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
      }
    }
 else {
      bc2ir.appendInstruction(Binary.create(INT_SHL,offset,index,new OPT_IntConstantOperand(LOG_BYTES_IN_ADDRESS)));
      bc2ir.appendInstruction(Store.create(REF_STORE,val,ref,offset.copy(),new OPT_LocationOperand(elementType),new OPT_TrueGuardOperand()));
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getWordAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setWordAtOffset) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Load.create(LONG_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setLongAtOffset) {
    OPT_Operand val=bc2ir.popLong();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(LONG_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getDoubleAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Load.create(DOUBLE_LOAD,val,object,offset,null));
    bc2ir.pushDual(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setDoubleAtOffset) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(DOUBLE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectArrayAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 4) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,object,offset,loc));
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Byte);
    bc2ir.appendInstruction(Load.create(BYTE_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(BYTE_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Char);
    bc2ir.appendInstruction(Load.create(USHORT_LOAD,val,object,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand object=bc2ir.popRef();
    bc2ir.appendInstruction(Store.create(SHORT_STORE,val,object,offset,null));
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Load.create(INT_LOAD,val,memAddr,new OPT_IntConstantOperand(0),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryWord) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_IntConstantOperand(0),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getMemoryAddress) {
    OPT_Operand memAddr=bc2ir.popAddress();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Load.create(REF_LOAD,val,memAddr,new OPT_IntConstantOperand(0),null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    OPT_Operand val=bc2ir.popInt();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(INT_STORE,val,memAddr,new OPT_IntConstantOperand(0),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryWord) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_IntConstantOperand(0),null));
  }
 else   if (methodName == VM_MagicNames.setMemoryAddress) {
    OPT_LocationOperand loc=null;
    if (meth.getParameterTypes().length == 3) {
      loc=mapToMetadata(bc2ir.popInt());
    }
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand memAddr=bc2ir.popAddress();
    bc2ir.appendInstruction(Store.create(REF_STORE,val,memAddr,new OPT_IntConstantOperand(0),loc));
  }
 else   if (meth.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=meth.getParameterTypes();
    int numArgs=args.length;
    VM_Field ip=VM_Entrypoints.getSysCallField(meth.getName().toString());
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(ip);
    OPT_Instruction call=Call.create(SYSCALL,null,null,mo,null,args.length);
    for (int i=args.length - 1; i >= 0; i--) {
      Call.setParam(call,i,bc2ir.pop(args[i]));
    }
    if (!returnType.isVoidType()) {
      OPT_RegisterOperand op0=gc.temps.makeTemp(returnType);
      Call.setResult(call,op0);
      bc2ir.push(op0.copyD2U(),returnType);
    }
    bc2ir.appendInstruction(call);
  }
 else   if (methodName == VM_MagicNames.threadAsCollectorThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsProcessor) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Processor);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsAddress) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObject) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsObjectArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsType) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.VM_Type);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsThread) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsRegisters) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),VM_Atom.findOrCreateAsciiAtom(""String_Node_Str"")));
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsByteArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ByteArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsShortArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.ShortArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.objectAsIntArray) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popRef()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.addressAsStack) {
    OPT_RegisterOperand reg=gc.temps.makeTemp(VM_TypeReference.IntArray);
    bc2ir.appendInstruction(Move.create(REF_MOVE,reg,bc2ir.popAddress()));
    bc2ir.push(reg.copyD2U());
  }
 else   if (methodName == VM_MagicNames.floatAsIntBits) {
    OPT_Operand val=bc2ir.popFloat();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Unary.create(FLOAT_AS_INT_BITS,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.intBitsAsFloat) {
    OPT_Operand val=bc2ir.popInt();
    OPT_RegisterOperand op0=gc.temps.makeTempFloat();
    bc2ir.appendInstruction(Unary.create(INT_BITS_AS_FLOAT,op0,val));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.doubleAsLongBits) {
    OPT_Operand val=bc2ir.popDouble();
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Unary.create(DOUBLE_AS_LONG_BITS,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.longBitsAsDouble) {
    OPT_Operand val=bc2ir.popLong();
    OPT_RegisterOperand op0=gc.temps.makeTempDouble();
    bc2ir.appendInstruction(Unary.create(LONG_BITS_AS_DOUBLE,op0,val));
    bc2ir.pushDual(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    OPT_Operand val=bc2ir.popRef();
    OPT_Operand guard=bc2ir.getGuard(val);
    if (guard == null) {
      guard=new OPT_TrueGuardOperand();
    }
    OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
    bc2ir.appendInstruction(GuardedUnary.create(GET_OBJ_TIB,tibPtr,val,guard));
    OPT_RegisterOperand op0;
    VM_TypeReference argType=val.getType();
    if (argType.isArrayType()) {
      op0=gc.temps.makeTemp(VM_TypeReference.VM_Array);
    }
 else {
      if (argType == VM_TypeReference.JavaLangObject || argType == VM_TypeReference.JavaLangCloneable || argType == VM_TypeReference.JavaIoSerializable) {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Type);
      }
 else {
        op0=gc.temps.makeTemp(VM_TypeReference.VM_Class);
      }
    }
    bc2ir.markGuardlessNonNull(op0);
    bc2ir.appendInstruction(Unary.create(GET_TYPE_FROM_TIB,op0,tibPtr.copyD2U()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    OPT_Operand val=bc2ir.popRef();
    OPT_RegisterOperand op0=gc.temps.makeTempInt();
    bc2ir.appendInstruction(GuardedUnary.create(ARRAYLENGTH,op0,val,new OPT_TrueGuardOperand()));
    bc2ir.push(op0.copyD2U());
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    OPT_Instruction s=Call.create0(CALL,null,bc2ir.popRef(),null);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    OPT_Operand code=bc2ir.popRef();
    OPT_Operand args=bc2ir.popRef();
    bc2ir.appendInstruction(Call.create1(CALL,null,code,null,args));
  }
 else   if ((methodName == VM_MagicNames.invokeMethodReturningObject) || (methodName == VM_MagicNames.invokeMethodReturningVoid) || (methodName == VM_MagicNames.invokeMethodReturningLong)|| (methodName == VM_MagicNames.invokeMethodReturningDouble)|| (methodName == VM_MagicNames.invokeMethodReturningFloat)|| (methodName == VM_MagicNames.invokeMethodReturningInt)) {
    OPT_Operand spills=bc2ir.popRef();
    OPT_Operand fprs=bc2ir.popRef();
    OPT_Operand gprs=bc2ir.popRef();
    OPT_Operand code=bc2ir.popRef();
    OPT_RegisterOperand res=null;
    if (methodName == VM_MagicNames.invokeMethodReturningObject) {
      res=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
      bc2ir.push(res.copyD2U());
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningLong) {
      res=gc.temps.makeTemp(VM_TypeReference.Long);
      bc2ir.push(res.copyD2U(),VM_TypeReference.Long);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
      res=gc.temps.makeTempDouble();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Double);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
      res=gc.temps.makeTempFloat();
      bc2ir.push(res.copyD2U(),VM_TypeReference.Float);
    }
 else     if (methodName == VM_MagicNames.invokeMethodReturningInt) {
      res=gc.temps.makeTempInt();
      bc2ir.push(res.copyD2U());
    }
    VM_Field target=VM_Entrypoints.reflectiveMethodInvokerInstructionsField;
    OPT_MethodOperand met=OPT_MethodOperand.STATIC(target);
    OPT_Instruction s=Call.create4(CALL,res,new OPT_IntConstantOperand(target.getOffset()),met,code,gprs,fprs,spills);
    bc2ir.appendInstruction(s);
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.saveThreadStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_IntConstantOperand(target.getOffset()),mo,p1));
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    OPT_Operand p2=bc2ir.popRef();
    OPT_Operand p1=bc2ir.popRef();
    VM_Field target=VM_Entrypoints.threadSwitchInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create2(CALL,null,new OPT_IntConstantOperand(target.getOffset()),mo,p1,p2));
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    VM_Field target=VM_Entrypoints.restoreHardwareExceptionStateInstructionsField;
    OPT_MethodOperand mo=OPT_MethodOperand.STATIC(target);
    bc2ir.appendInstruction(Call.create1(CALL,null,new OPT_IntConstantOperand(target.getOffset()),mo,bc2ir.popRef()));
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Prepare.create(PREPARE_INT,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareObject) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.JavaLangObject);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareAddress) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Address);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.prepareWord) {
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand val=gc.temps.makeTemp(VM_TypeReference.Word);
    bc2ir.appendInstruction(Prepare.create(PREPARE_ADDR,val,base,offset,null));
    bc2ir.push(val.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    OPT_Operand newVal=bc2ir.popInt();
    OPT_Operand oldVal=bc2ir.popInt();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_INT,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptObject) {
    OPT_Operand newVal=bc2ir.popRef();
    OPT_Operand oldVal=bc2ir.popRef();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptAddress) {
    OPT_Operand newVal=bc2ir.popAddress();
    OPT_Operand oldVal=bc2ir.popAddress();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (methodName == VM_MagicNames.attemptWord) {
    OPT_Operand newVal=bc2ir.pop();
    OPT_Operand oldVal=bc2ir.pop();
    OPT_Operand offset=bc2ir.popInt();
    OPT_Operand base=bc2ir.popRef();
    OPT_RegisterOperand test=gc.temps.makeTempInt();
    bc2ir.appendInstruction(Attempt.create(ATTEMPT_ADDR,test,base,offset,oldVal,newVal,null));
    bc2ir.push(test.copyD2U());
  }
 else   if (generatePolymorphicMagic(bc2ir,gc,meth,methodName)) {
    return true;
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    OPT_RegisterOperand op0=gc.temps.makeTempLong();
    bc2ir.appendInstruction(Nullary.create(GET_TIME_BASE,op0));
    bc2ir.pushDual(op0.copyD2U());
  }
 else {
    return OPT_GenerateMachineSpecificMagic.generateMagic(bc2ir,gc,meth);
  }
  return true;
}",0.9948520698564408
150156,"/** 
 * Return the space into which an allocator is allocating.  The allocator, <code>a</code> may be assocaited with any plan instance.
 * @param a An allocator
 * @return The space into which <code>a</code> is allocating, or<code>null</code> if there is no space associated with <code>a</code>.
 */
private static Space getSpaceFromAllocatorAnyPlan(Allocator a){
  for (int i=0; i < plans.length; i++) {
    Space space=plans[i].getSpaceFromAllocator(a);
    if (space != null)     return space;
  }
  return null;
}","/** 
 * Return the space into which an allocator is allocating.  The allocator, <code>a</code> may be assocaited with any plan instance.
 * @param a An allocator
 * @return The space into which <code>a</code> is allocating, or<code>null</code> if there is no space associated with <code>a</code>.
 */
private static Space getSpaceFromAllocatorAnyPlan(Allocator a){
  for (int i=0; i < plans.length; i++) {
    if (plans[i] != null) {
      Space space=plans[i].getSpaceFromAllocator(a);
      if (space != null)       return space;
    }
  }
  return null;
}",0.9628252788104088
150157,"/** 
 * Construct SSA form to satisfy the desired options in ir.desiredSSAOptions. This module is lazy; if the actual SSA options satisfy the desired options, then do nothing.
 * @param ir the governing IR
 */
final public void perform(OPT_IR ir){
  if (ir.desiredSSAOptions.getAbort())   return;
  if (ir.actualSSAOptions != null)   if (ir.actualSSAOptions.satisfies(ir.desiredSSAOptions))   return;
  this.ir=ir;
  boolean scalarsOnly=ir.desiredSSAOptions.getScalarsOnly();
  boolean backwards=ir.desiredSSAOptions.getBackwards();
  Set heapTypes=ir.desiredSSAOptions.getHeapTypes();
  boolean insertUsePhis=ir.desiredSSAOptions.getInsertUsePhis();
  boolean insertPEIDeps=ir.desiredSSAOptions.getInsertPEIDeps();
  boolean excludeGuards=ir.desiredSSAOptions.getExcludeGuards();
  if (!ir.HIRInfo.dominatorsAreComputed)   throw new OPT_OptimizingCompilerException(""String_Node_Str"");
  ir.HIRInfo.SSADictionary=new OPT_SSADictionary(null,true,false,ir);
  prepare();
  if (true)   patchPEIgeneratedValues();
  if (ir.options.PRINT_SSA)   OPT_SSA.printInstructions(ir);
  computeSSA(ir,scalarsOnly,backwards,heapTypes,insertUsePhis,insertPEIDeps,excludeGuards);
  ir.actualSSAOptions=new OPT_SSAOptions();
  ir.actualSSAOptions.setScalarsOnly(scalarsOnly);
  ir.actualSSAOptions.setBackwards(backwards);
  ir.actualSSAOptions.setHeapTypes(heapTypes);
  ir.actualSSAOptions.setInsertUsePhis(insertUsePhis);
  ir.actualSSAOptions.setInsertPEIDeps(insertPEIDeps);
  ir.actualSSAOptions.setExcludeGuards(excludeGuards);
}","/** 
 * Construct SSA form to satisfy the desired options in ir.desiredSSAOptions. This module is lazy; if the actual SSA options satisfy the desired options, then do nothing.
 * @param ir the governing IR
 */
final public void perform(OPT_IR ir){
  if (ir.desiredSSAOptions.getAbort())   return;
  if (ir.actualSSAOptions != null)   if (ir.actualSSAOptions.satisfies(ir.desiredSSAOptions))   return;
  this.ir=ir;
  boolean scalarsOnly=ir.desiredSSAOptions.getScalarsOnly();
  boolean backwards=ir.desiredSSAOptions.getBackwards();
  Set heapTypes=ir.desiredSSAOptions.getHeapTypes();
  boolean insertUsePhis=ir.desiredSSAOptions.getInsertUsePhis();
  boolean insertPEIDeps=ir.desiredSSAOptions.getInsertPEIDeps();
  boolean excludeGuards=ir.desiredSSAOptions.getExcludeGuards();
  if (!ir.HIRInfo.dominatorsAreComputed)   throw new OPT_OptimizingCompilerException(""String_Node_Str"");
  ir.HIRInfo.SSADictionary=new OPT_SSADictionary(null,true,false,ir);
  prepare();
  if (true)   patchPEIgeneratedValues();
  if (ir.options.PRINT_SSA)   OPT_SSA.printInstructions(ir);
  computeSSA(ir,scalarsOnly,backwards,heapTypes,insertUsePhis,insertPEIDeps,excludeGuards);
  ir.actualSSAOptions=new OPT_SSAOptions();
  ir.actualSSAOptions.setScalarsOnly(scalarsOnly);
  ir.actualSSAOptions.setBackwards(backwards);
  ir.actualSSAOptions.setHeapTypes(heapTypes);
  ir.actualSSAOptions.setInsertUsePhis(insertUsePhis);
  ir.actualSSAOptions.setInsertPEIDeps(insertPEIDeps);
  ir.actualSSAOptions.setExcludeGuards(excludeGuards);
  ir.actualSSAOptions.setScalarValid(true);
  ir.actualSSAOptions.setHeapValid(!scalarsOnly);
}",0.9699680511182108
150158,"public void perform(OPT_IR ir){
  if (ir.hasReachableExceptionHandlers() || OPT_GCP.tooBig(ir))   return;
  verbose=OPT_LICM.verbose;
  this.ir=ir;
  dominator=ir.HIRInfo.dominatorTree;
  (new OPT_GlobalValueNumber()).perform(ir);
  valueNumbers=ir.HIRInfo.valueNumbers;
  if (true || ir.IRStage == ir.LIR) {
    if (verbose)     VM.sysWrite(""String_Node_Str"" + ir.method + ""String_Node_Str"");
    OPT_DefUse.computeDU(ir);
    OPT_Simple.copyPropagation(ir);
    OPT_DefUse.computeDU(ir);
    GlobalCSE(ir.firstBasicBlockInCodeOrder());
    if (VM.VerifyAssertions)     VM._assert(avail.size() == 0,avail.toString());
  }
}","public void perform(OPT_IR ir){
  if (ir.hasReachableExceptionHandlers() || OPT_GCP.tooBig(ir))   return;
  verbose=OPT_LICM.verbose;
  this.ir=ir;
  dominator=ir.HIRInfo.dominatorTree;
  (new OPT_GlobalValueNumber()).perform(ir);
  valueNumbers=ir.HIRInfo.valueNumbers;
  if (true || ir.IRStage == ir.LIR) {
    if (verbose)     VM.sysWrite(""String_Node_Str"" + ir.method + ""String_Node_Str"");
    OPT_DefUse.computeDU(ir);
    OPT_Simple.copyPropagation(ir);
    OPT_DefUse.computeDU(ir);
    GlobalCSE(ir.firstBasicBlockInCodeOrder());
    if (VM.VerifyAssertions) {
      VM._assert(avail.size() == 0,avail.toString());
    }
    ir.actualSSAOptions.setScalarValid(false);
  }
}",0.9563218390804598
150159,"/** 
 * Execute loop invariant code motion on the given IR.
 * @param ir
 */
public void perform(OPT_IR ir){
  this.ir=ir;
  if (DEBUG && ir.hasReachableExceptionHandlers()) {
    VM.sysWrite(""String_Node_Str"" + ir.method + ""String_Node_Str"");
    (new OPT_LiveAnalysis(false,false,true,false)).perform(ir);
    OPT_BasicBlockEnumeration e=ir.getBasicBlocks();
    while (e.hasMoreElements()) {
      OPT_BasicBlock b=e.next();
      if (b instanceof OPT_ExceptionHandlerBasicBlock)       VM.sysWrite(""String_Node_Str"" + b + ""String_Node_Str""+ ((OPT_ExceptionHandlerBasicBlock)b).getLiveSet()+ ""String_Node_Str"");
    }
  }
  if (ir.hasReachableExceptionHandlers() || OPT_GCP.tooBig(ir)) {
    resetLandingPads();
    return;
  }
  verbose=ir.options.VERBOSE_GCP;
  if (verbose && ir.options.hasMETHOD_TO_PRINT()) {
    verbose=ir.options.fuzzyMatchMETHOD_TO_PRINT(ir.method.toString());
    if (!verbose) {
      resetLandingPads();
      return;
    }
  }
  if (verbose)   VM.sysWrite(""String_Node_Str"" + ir.method + ""String_Node_Str"");
  initialize(ir);
  if (verbose)   OPT_SSA.printInstructions(ir);
  OPT_Instruction inst=ir.firstInstructionInCodeOrder();
  while (inst != null) {
    OPT_Instruction next=inst.nextInstructionInCodeOrder();
    if (DEBUG)     System.out.println(""String_Node_Str"" + inst);
    scheduleEarly(inst);
    inst=next;
  }
  inst=ir.lastInstructionInCodeOrder();
  while (inst != null) {
    OPT_Instruction next=inst.prevInstructionInCodeOrder();
    scheduleLate(inst);
    inst=next;
  }
  resetLandingPads();
  if (DEBUG)   OPT_SSA.printInstructions(ir);
}","/** 
 * Execute loop invariant code motion on the given IR.
 * @param ir
 */
public void perform(OPT_IR ir){
  this.ir=ir;
  if (DEBUG && ir.hasReachableExceptionHandlers()) {
    VM.sysWrite(""String_Node_Str"" + ir.method + ""String_Node_Str"");
    (new OPT_LiveAnalysis(false,false,true,false)).perform(ir);
    OPT_BasicBlockEnumeration e=ir.getBasicBlocks();
    while (e.hasMoreElements()) {
      OPT_BasicBlock b=e.next();
      if (b instanceof OPT_ExceptionHandlerBasicBlock)       VM.sysWrite(""String_Node_Str"" + b + ""String_Node_Str""+ ((OPT_ExceptionHandlerBasicBlock)b).getLiveSet()+ ""String_Node_Str"");
    }
  }
  if (ir.hasReachableExceptionHandlers() || OPT_GCP.tooBig(ir)) {
    resetLandingPads();
    return;
  }
  verbose=ir.options.VERBOSE_GCP;
  if (verbose && ir.options.hasMETHOD_TO_PRINT()) {
    verbose=ir.options.fuzzyMatchMETHOD_TO_PRINT(ir.method.toString());
    if (!verbose) {
      resetLandingPads();
      return;
    }
  }
  if (verbose)   VM.sysWrite(""String_Node_Str"" + ir.method + ""String_Node_Str"");
  initialize(ir);
  if (verbose)   OPT_SSA.printInstructions(ir);
  OPT_Instruction inst=ir.firstInstructionInCodeOrder();
  while (inst != null) {
    OPT_Instruction next=inst.nextInstructionInCodeOrder();
    if (DEBUG)     System.out.println(""String_Node_Str"" + inst);
    scheduleEarly(inst);
    inst=next;
  }
  inst=ir.lastInstructionInCodeOrder();
  while (inst != null) {
    OPT_Instruction next=inst.prevInstructionInCodeOrder();
    scheduleLate(inst);
    inst=next;
  }
  resetLandingPads();
  if (DEBUG)   OPT_SSA.printInstructions(ir);
  ir.actualSSAOptions.setScalarValid(false);
}",0.9860724233983288
150160,"/** 
 * Logs a message and traceback, then exits.
 * @param message the string to log
 */
public static void fail(String message){
  VM.sysFail(message);
}","/** 
 * Logs a message and traceback, then exits.   This two-argument form is needed for us to call before the VM's Integer class is initialized.  
 * @param message the string to log
 * @param number  an integer to append to <code>message</code>.  
 */
public static void fail(String message,int number){
  VM.sysFail(message,number);
}",0.6300813008130082
150161,"static void tracebackWithoutLock(String message){
  VM.sysWrite(message);
  VM.sysWrite(""String_Node_Str"");
  dumpStack(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
}","static void tracebackWithoutLock(){
  dumpStack(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
}",0.7534246575342466
150162,"/** 
 * Print interesting scheduler information, starting with a stack traceback. Note: the system could be in a fragile state when this method is called, so we try to rely on as little runtime functionality as possible (eg. use no bytecodes that require VM_Runtime support).
 */
static void traceback(String message){
  VM_Processor.getCurrentProcessor().disableThreadSwitching();
  lockOutput();
  tracebackWithoutLock(message);
  unlockOutput();
  VM_Processor.getCurrentProcessor().enableThreadSwitching();
}","static void traceback(String message,int number){
  VM_Processor.getCurrentProcessor().disableThreadSwitching();
  lockOutput();
  VM.sysWriteln(message,number);
  tracebackWithoutLock();
  unlockOutput();
  VM_Processor.getCurrentProcessor().enableThreadSwitching();
}",0.176696542893726
150163,"public void release(){
  long diff=(REPORT_SLOW) ? VM_Time.cycles() - start : 0;
  boolean show=(verbose > 1) || (diff > SLOW_THRESHOLD);
  if (show) {
    Log.write(""String_Node_Str"");
    thread.dumpToLog();
    Log.write(""String_Node_Str"");
    Log.write(id);
    Log.write(""String_Node_Str"");
    Log.write(name);
    Log.write(""String_Node_Str"");
    Log.write(VM_Time.cyclesToMillis(diff));
    Log.writeln(""String_Node_Str"");
  }
  if (REPORT_SLOW) {
    endHistory[serving % 100]=VM_Time.cycles();
    setLocker(0,null,-1);
  }
  VM_Magic.sync();
  VM_Synchronization.fetchAndAdd(this,servingFieldOffset,1);
}","public void release(){
  long diff=(REPORT_SLOW) ? VM_Time.cycles() - start : 0;
  boolean show=(verbose > 1) || (diff > SLOW_THRESHOLD);
  if (show) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWrite(""String_Node_Str"",name);
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(VM_Time.cyclesToMillis(diff));
    VM.sysWriteln(""String_Node_Str"");
  }
  if (REPORT_SLOW) {
    endHistory[serving % 100]=VM_Time.cycles();
    setLocker(0,null,-1);
  }
  VM_Magic.sync();
  VM_Synchronization.fetchAndAdd(this,servingFieldOffset,1);
}",0.8784119106699751
150164,"public void check(int w){
  if (!REPORT_SLOW)   return;
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(VM_Thread.getCurrentThread() == thread);
  long diff=(REPORT_SLOW) ? VM_Time.cycles() - start : 0;
  boolean show=(verbose > 1) || (diff > SLOW_THRESHOLD);
  if (show) {
    Log.write(""String_Node_Str"");
    thread.dumpToLog();
    Log.write(""String_Node_Str"");
    Log.write(w);
    Log.write(""String_Node_Str"");
    Log.write(id);
    Log.write(""String_Node_Str"");
    Log.write(name);
    Log.write(""String_Node_Str"");
    Log.write(VM_Time.cyclesToMillis(diff));
    Log.writeln(""String_Node_Str"");
  }
  where=w;
}","public void check(int w){
  if (!REPORT_SLOW)   return;
  if (Assert.VERIFY_ASSERTIONS)   Assert._assert(VM_Thread.getCurrentThread() == thread);
  long diff=(REPORT_SLOW) ? VM_Time.cycles() - start : 0;
  boolean show=(verbose > 1) || (diff > SLOW_THRESHOLD);
  if (show) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",w);
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWrite(""String_Node_Str"",name);
    VM.sysWrite(""String_Node_Str"",VM_Time.cyclesToMillis(diff));
    VM.sysWriteln(""String_Node_Str"");
  }
  where=w;
}",0.6868178001679262
150165,"public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        Log.write(""String_Node_Str"");
        VM_Thread.getCurrentThread().dumpToLog();
        Log.write(""String_Node_Str"");
        Log.write(ticket);
        Log.write(""String_Node_Str"");
        Log.write(id);
        Log.write(""String_Node_Str"");
        Log.write(name);
        Log.write(""String_Node_Str"");
        Log.write(serving);
        Log.write(""String_Node_Str"");
        Log.write(VM_Time.cyclesToMillis(waitTime));
        Log.write(""String_Node_Str"");
        Log.writelnNoFlush();
        VM_Thread t=thread;
        if (t == null)         Log.writeln(""String_Node_Str"",false);
 else {
          Log.write(""String_Node_Str"");
          t.dumpToLog();
          Log.write(""String_Node_Str"");
          Log.writeln(where,false);
        }
        Log.write(""String_Node_Str"");
        Log.writeln(localStart,false);
        for (int i=(serving + 90) % 100; i != serving; i=(i + 1) % 100) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          Log.write(""String_Node_Str"");
          Log.write(i);
          Log.write(""String_Node_Str"");
          Log.write(servingHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(tidHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(startHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(endHistory[i]);
          Log.write(""String_Node_Str"");
          Log.write(VM_Time.cyclesToMillis(startHistory[i] - localStart));
          Log.writelnNoFlush();
        }
        Log.flush();
      }
      if (waitTime > TIME_OUT) {
        Log.write(""String_Node_Str"");
        VM_Thread.getCurrentThread().dumpToLog();
        Log.writeln();
        VM_Scheduler.dumpStack();
        Assert.fail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    Log.write(""String_Node_Str"");
    thread.dumpToLog();
    Log.write(""String_Node_Str"");
    Log.write(id);
    Log.write(""String_Node_Str"");
    Log.write(name);
    Log.writeln();
  }
  VM_Magic.isync();
}","public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM.sysWrite(""String_Node_Str"",ticket);
        VM.sysWrite(""String_Node_Str"",id);
        VM.sysWrite(""String_Node_Str"",name);
        VM.sysWrite(""String_Node_Str"",serving);
        VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(waitTime),""String_Node_Str"");
        VM_Thread t=thread;
        if (t == null)         VM.sysWriteln(""String_Node_Str"");
 else {
          VM.sysWrite(""String_Node_Str"");
          t.dump(1);
          VM.sysWriteln(""String_Node_Str"",where);
        }
        VM.sysWriteln(""String_Node_Str"",localStart);
        for (int i=(serving + 90) % 100; i != serving; i=(i + 1) % 100) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          VM.sysWrite(""String_Node_Str"");
          VM.sysWrite(i,""String_Node_Str"",servingHistory[i]);
          VM.sysWrite(""String_Node_Str"",tidHistory[i]);
          VM.sysWrite(""String_Node_Str"",startHistory[i]);
          VM.sysWrite(""String_Node_Str"",endHistory[i]);
          VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(startHistory[i] - localStart));
        }
      }
      if (waitTime > TIME_OUT) {
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM_Scheduler.dumpStack();
        Assert.fail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWriteln(""String_Node_Str"",name);
  }
  VM_Magic.isync();
}",0.7154562383612663
150166,"public static void ptsysWriteln(String s1,String s2,String s3,String s4,String s5,String s6,String s7,int i8,String s9,String s10,String s11,String s12,String s13) throws NoInlinePragma {
  swLock();
  showProc();
  showThread();
  write(s1);
  write(s2);
  write(s3);
  write(s4);
  write(s5);
  write(s6);
  write(s7);
  write(i8);
  write(s9);
  write(s10);
  write(s11);
  write(s12);
  write(s13);
  writeln();
  swUnlock();
}","public static void ptsysWriteln(String s1,String s2,String s3,String s4,String s5,String s6,String s7,int i8,String s9,String s10,String s11,String s12,String s13,int i14) throws NoInlinePragma {
  swLock();
  showProc();
  showThread();
  write(s1);
  write(s2);
  write(s3);
  write(s4);
  write(s5);
  write(s6);
  write(s7);
  write(i8);
  write(s9);
  write(s10);
  write(s11);
  write(s12);
  write(s13);
  write(i14);
  writeln();
  swUnlock();
}",0.9751131221719456
150167,"private static void handlePossibleRecursiveCallToSysFail(String message){
  handlePossibleRecursiveExit(""String_Node_Str"",++inSysFail,message);
}","private static void handlePossibleRecursiveCallToSysFail(String message,int number){
  handlePossibleRecursiveExit(""String_Node_Str"",++inSysFail,message,number);
}",0.9415584415584416
150168,"/** 
 * Used only by VM.shutdown() 
 */
private static void handlePossibleRecursiveShutdown(){
  handlePossibleRecursiveExit(""String_Node_Str"",++inShutdown,null);
}","/** 
 * Used only by VM.shutdown() 
 */
private static void handlePossibleRecursiveShutdown(){
  handlePossibleRecursiveExit(""String_Node_Str"",++inShutdown);
}",0.9845201238390092
150169,"private static void handlePossibleRecursiveCallToSysExit(){
  handlePossibleRecursiveExit(""String_Node_Str"",++inSysExit,null);
}","private static void handlePossibleRecursiveCallToSysExit(){
  handlePossibleRecursiveExit(""String_Node_Str"",++inSysExit);
}",0.9800796812749004
150170,"/** 
 * Exit virtual machine due to internal failure of some sort.
 * @param message  error message describing the problem
 */
public static void sysFail(String message) throws NoInlinePragma {
  handlePossibleRecursiveCallToSysFail(message);
  VM_Scheduler.traceback(message);
  if (VM.runningVM)   VM.shutdown(exitStatusSysFail);
 else   VM.sysExit(exitStatusSysFail);
  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);
}","/** 
 * Exit virtual machine due to internal failure of some sort.  This two-argument form is  needed for us to call before the VM's Integer class is initialized.   
 * @param message  error message describing the problem
 * @param number  an integer to append to <code>message</code>.  
 */
public static void sysFail(String message,int number) throws NoInlinePragma {
  handlePossibleRecursiveCallToSysFail(message,number);
  VM_Scheduler.traceback(message,number);
  if (VM.runningVM)   VM.shutdown(exitStatusSysFail);
 else   VM.sysExit(exitStatusSysFail);
  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);
}",0.8187022900763359
150171,"/** 
 * @param called Name of the function called: ""sysExit"", ""sysFail"", or""shutdown"".
 * @param depth How deep are we in that function?
 * @param message What message did it have?  null means this particularshutdown function  does not come with a message. 
 */
private static void handlePossibleRecursiveExit(String called,int depth,String message){
  int nProcessors=VM_Scheduler.numProcessors;
  int nProcessorAdjust=nProcessors - 1;
  if (depth > 1 && (depth <= maxSystemTroubleRecursionDepth + nProcessorAdjust + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite)) {
    ptsysWriteln(""String_Node_Str"",called,""String_Node_Str"",depth > nProcessors ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",called,""String_Node_Str"",depth,""String_Node_Str"",message == null ? ""String_Node_Str"" : ""String_Node_Str"",message == null ? ""String_Node_Str"" : called,message == null ? ""String_Node_Str"" : ""String_Node_Str"",message == null ? ""String_Node_Str"" : message);
  }
  if (depth > maxSystemTroubleRecursionDepth + nProcessorAdjust) {
    dieAbruptlyRecursiveSystemTrouble();
    if (VM.VerifyAssertions)     VM._assert(VM.NOT_REACHED);
  }
}","/** 
 * @param called Name of the function called: ""sysExit"", ""sysFail"", or""shutdown"".
 * @param depth How deep are we in that function?
 * @param message What message did it have?  null means this particularshutdown function  does not come with a message.
 * @param showNumber Print <code>number</code> following<code>message</code>? 
 * @param number Print this number, if <code>showNumber</code> is true. 
 */
private static void handlePossibleRecursiveExit(String called,int depth,String message,boolean showNumber,int number){
  int nProcessors=VM_Scheduler.numProcessors;
  int nProcessorAdjust=nProcessors - 1;
  if (depth > 1 && (depth <= maxSystemTroubleRecursionDepth + nProcessorAdjust + VM.maxSystemTroubleRecursionDepthBeforeWeStopVMSysWrite)) {
    if (showNumber) {
      ptsysWriteln(""String_Node_Str"",called,""String_Node_Str"",depth > nProcessors ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",called,""String_Node_Str"",depth,""String_Node_Str"",message == null ? ""String_Node_Str"" : ""String_Node_Str"",message == null ? ""String_Node_Str"" : called,message == null ? ""String_Node_Str"" : ""String_Node_Str"",message == null ? ""String_Node_Str"" : message,number);
    }
 else {
      ptsysWriteln(""String_Node_Str"",called,""String_Node_Str"",depth > nProcessors ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"",called,""String_Node_Str"",depth,""String_Node_Str"",message == null ? ""String_Node_Str"" : ""String_Node_Str"",message == null ? ""String_Node_Str"" : called,message == null ? ""String_Node_Str"" : ""String_Node_Str"",message == null ? ""String_Node_Str"" : message);
    }
  }
  if (depth > maxSystemTroubleRecursionDepth + nProcessorAdjust) {
    dieAbruptlyRecursiveSystemTrouble();
    if (VM.VerifyAssertions)     VM._assert(VM.NOT_REACHED);
  }
}",0.785763175906913
150172,"protected final void LONG_2INT(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left){
  OPT_Register srcHigh=left.register;
  OPT_Register srcLow=regpool.getSecondReg(srcHigh);
  EMIT(MIR_Move.mutate(s,PPC_MOVE,def,I(srcLow)));
  EMIT(MIR_Unary.create(PPC64_EXTSW,I(srcHigh),left));
}","protected final void LONG_2INT(OPT_Instruction s,OPT_RegisterOperand def,OPT_RegisterOperand left){
  OPT_Register srcHigh=left.register;
  OPT_Register srcLow=regpool.getSecondReg(srcHigh);
  EMIT(MIR_Move.mutate(s,PPC_MOVE,def,I(srcLow)));
  EMIT(MIR_Unary.create(PPC64_EXTSW,def,left));
}",0.9779286926994908
150173,"void processCondRegion(Vector region) throws IOException {
  QuotedStringTokenizer pst=new QuotedStringTokenizer(params);
  if (!pst.hasMoreTokens())   throw new IOException(""String_Node_Str"");
  String arg=pst.nextToken();
  if (!pst.hasMoreTokens())   throw new IOException(""String_Node_Str"");
  String op=pst.nextToken();
  String[] value=new String[pst.countTokens()];
  for (int i=0; i < value.length; i++)   value[i]=pst.nextToken();
  if (DEBUG)   System.out.println(""String_Node_Str"" + arg + ""String_Node_Str""+ op+ ""String_Node_Str""+ value[0]);
  Vector newRegion=(Vector)region.elementAt(1);
  if (!evaluateConditional(arg,op,value)) {
    if (region.size() > 2)     newRegion=(Vector)region.elementAt(2);
 else     newRegion=new Vector();
    if (DEBUG)     System.out.println(""String_Node_Str"");
  }
 else {
    if (DEBUG)     System.out.println(""String_Node_Str"");
  }
  for (int j=0; j < newRegion.size(); j++) {
    try {
      String currentLine=(String)newRegion.elementAt(j);
      out.print(currentLine + ""String_Node_Str"");
    }
 catch (    ClassCastException e) {
      Vector tmpRegion=(Vector)newRegion.elementAt(j);
      processTemplateRegion(tmpRegion);
    }
  }
}","void processCondRegion(Vector region) throws IOException {
  QuotedStringTokenizer pst=new QuotedStringTokenizer(params);
  if (!pst.hasMoreTokens())   throw new IOException(""String_Node_Str"");
  String arg=pst.nextToken();
  if (!pst.hasMoreTokens())   throw new IOException(""String_Node_Str"");
  String op=pst.nextToken();
  String[] value=new String[pst.countTokens()];
  for (int i=0; i < value.length; i++)   value[i]=pst.nextToken();
  if (DEBUG) {
    if (value.length > 0)     System.out.println(""String_Node_Str"" + arg + ""String_Node_Str""+ op+ ""String_Node_Str""+ value[0]);
 else     System.out.println(""String_Node_Str"" + arg + ""String_Node_Str""+ op+ ""String_Node_Str"");
  }
  Vector newRegion=(Vector)region.elementAt(1);
  if (!evaluateConditional(arg,op,value)) {
    if (region.size() > 2)     newRegion=(Vector)region.elementAt(2);
 else     newRegion=new Vector();
    if (DEBUG)     System.out.println(""String_Node_Str"");
  }
 else {
    if (DEBUG)     System.out.println(""String_Node_Str"");
  }
  for (int j=0; j < newRegion.size(); j++) {
    try {
      String currentLine=(String)newRegion.elementAt(j);
      out.print(currentLine + ""String_Node_Str"");
    }
 catch (    ClassCastException e) {
      Vector tmpRegion=(Vector)newRegion.elementAt(j);
      processTemplateRegion(tmpRegion);
    }
  }
}",0.9474940334128878
150174,"/** 
 * Handle the C to Java transition:  JNI methods in VM_JNIFunctions.java. <pre> NOTE: -We need PR to access Java environment; we can get it from the  JNIEnv* (which is an interior pointer to the VM_JNIEnvironment) -Unlike the powerPC scheme which has a special prolog preceding the normal Java prolog, the Intel scheme replaces the Java prolog completely with the special prolog Stack on entry            Stack at end of prolog after call high memory                       high memory |            |                   |            | EBP ->  |saved FP    |                   |saved FP    | |  ...       |                   |  ...       | |            |                   |            | |arg n-1     |                   |arg n-1     | native     |  ...       |                   |  ...       |        caller     |arg 0       |                   |arg 0       | ESP ->  |return addr |                   |return addr | |            |           EBP ->  |saved FP    | |            |                   |methodID    | normal MethodID for JNI function |            |                   |saved JavaFP| offset to preceeding java frame |            |                   |saved edi   | to be used for JTOC |            |                   |  ""   ebx   | to be used for nonvolatile |            |                   |  ""   ecx   | to be used for scrach |            |                   |  ""   esi   | to be used for PR |            |                   |arg 0       | copied in reverse order |            |                   |  ...       | |            |           ESP ->  |arg n-1     | |            |                   |            | normally compiled Java code continue |            |                   |            | |            |                   |            | |            |                   |            | low memory                        low memory </pre>
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_NormalMethod method,int methodID){
  asm.emitPUSH_Reg(EBP);
  asm.emitMOV_Reg_Reg(EBP,SP);
  asm.emitPUSH_Imm(methodID);
  asm.emitSUB_Reg_Imm(SP,WORDSIZE);
  asm.emitPUSH_Reg(JTOC);
  asm.emitPUSH_Reg(EBX);
  asm.emitPUSH_Reg(S0);
  VM_ProcessorLocalState.emitPushProcessor(asm);
  asm.emitSUB_RegDisp_Imm(EBP,(2 * WORDSIZE),VM_Entrypoints.JNIExternalFunctionsField.getOffset());
  VM_TypeReference[] types=method.getParameterTypes();
  int numArguments=types.length;
  int argOffset=2;
  for (int i=0; i < numArguments; i++) {
    if (types[i].isLongType() || types[i].isDoubleType()) {
      asm.emitMOV_Reg_RegDisp(EBX,EBP,((argOffset + 1) * WORDSIZE));
      asm.emitPUSH_Reg(EBX);
      asm.emitMOV_Reg_RegDisp(EBX,EBP,(argOffset * WORDSIZE));
      asm.emitPUSH_Reg(EBX);
      argOffset+=2;
    }
 else {
      asm.emitMOV_Reg_RegDisp(EBX,EBP,(argOffset * WORDSIZE));
      asm.emitPUSH_Reg(EBX);
      argOffset++;
    }
  }
  int retryLabel=asm.getMachineCodeIndex();
  asm.emitMOV_Reg_RegDisp(EBX,EBP,(2 * WORDSIZE));
  VM_ProcessorLocalState.emitSetProcessor(asm,EBX,VM_Entrypoints.JNIEnvSavedPRField.getOffset());
  VM_ProcessorLocalState.emitMoveFieldToReg(asm,JTOC,VM_Entrypoints.jtocField.getOffset());
  VM_ProcessorLocalState.emitMoveFieldToReg(asm,T0,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitCMP_Reg_Imm(T0,VM_Processor.IN_NATIVE);
  VM_ForwardReference fr=asm.forwardJcc(asm.EQ);
  asm.emitMOV_Reg_RegDisp(T0,JTOC,VM_Entrypoints.the_boot_recordField.getOffset());
  asm.emitCALL_RegDisp(T0,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset());
  asm.emitJMP_Imm(retryLabel);
  fr.resolve(asm);
  asm.emitMOV_Reg_Imm(T1,VM_Processor.IN_JAVA);
  VM_ProcessorLocalState.emitCompareAndExchangeField(asm,VM_Entrypoints.vpStatusField.getOffset(),T1);
  asm.emitJCC_Cond_Imm(asm.NE,retryLabel);
  int numLocalVariables=method.getLocalWords() - method.getParameterWords();
  asm.emitSUB_Reg_Imm(SP,(numLocalVariables << LG_WORDSIZE));
  asm.emitMOV_Reg_RegDisp(S0,EBX,VM_Entrypoints.JNITopJavaFPField.getOffset());
  asm.emitSUB_Reg_Reg(S0,EBP);
  asm.emitMOV_RegDisp_Reg(EBP,SAVED_JAVA_FP_OFFSET,S0);
  VM_ProcessorLocalState.emitMoveRegToField(asm,VM_Entrypoints.framePointerField.getOffset(),EBP);
  asm.emitNOP();
}","/** 
 * Handle the C to Java transition:  JNI methods in VM_JNIFunctions.java. <pre> NOTE: -We need PR to access Java environment; we can get it from the  JNIEnv* (which is an interior pointer to the VM_JNIEnvironment) -Unlike the powerPC scheme which has a special prolog preceding the normal Java prolog, the Intel scheme replaces the Java prolog completely with the special prolog Stack on entry            Stack at end of prolog after call high memory                       high memory |            |                   |            | EBP ->  |saved FP    |                   |saved FP    | |  ...       |                   |  ...       | |            |                   |            | |arg n-1     |                   |arg n-1     | native     |  ...       |                   |  ...       |        caller     |arg 0       |                   |arg 0       | ESP ->  |return addr |                   |return addr | |            |           EBP ->  |saved FP    | |            |                   |methodID    | normal MethodID for JNI function |            |                   |saved JavaFP| offset to preceeding java frame |            |                   |saved edi   | to be used for JTOC |            |                   |  ""   ebx   | to be used for nonvolatile |            |                   |  ""   ecx   | to be used for scrach |            |                   |  ""   esi   | to be used for PR |            |                   |arg 0       | copied in reverse order |            |                   |  ...       | |            |           ESP ->  |arg n-1     | |            |                   |            | normally compiled Java code continue |            |                   |            | |            |                   |            | |            |                   |            | low memory                        low memory </pre>
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_NormalMethod method,int methodID){
  asm.emitPUSH_Reg(EBP);
  asm.emitMOV_Reg_Reg(EBP,SP);
  asm.emitPUSH_Imm(methodID);
  asm.emitSUB_Reg_Imm(SP,STACKFRAME_HEADER_SIZE - 2 * WORDSIZE);
  asm.emitPUSH_Reg(JTOC);
  asm.emitPUSH_Reg(EBX);
  asm.emitPUSH_Reg(S0);
  VM_ProcessorLocalState.emitPushProcessor(asm);
  asm.emitSUB_RegDisp_Imm(EBP,(2 * WORDSIZE),VM_Entrypoints.JNIExternalFunctionsField.getOffset());
  VM_TypeReference[] types=method.getParameterTypes();
  int numArguments=types.length;
  int argOffset=2;
  for (int i=0; i < numArguments; i++) {
    if (types[i].isLongType() || types[i].isDoubleType()) {
      asm.emitMOV_Reg_RegDisp(EBX,EBP,((argOffset + 1) * WORDSIZE));
      asm.emitPUSH_Reg(EBX);
      asm.emitMOV_Reg_RegDisp(EBX,EBP,(argOffset * WORDSIZE));
      asm.emitPUSH_Reg(EBX);
      argOffset+=2;
    }
 else {
      asm.emitMOV_Reg_RegDisp(EBX,EBP,(argOffset * WORDSIZE));
      asm.emitPUSH_Reg(EBX);
      argOffset++;
    }
  }
  int retryLabel=asm.getMachineCodeIndex();
  asm.emitMOV_Reg_RegDisp(EBX,EBP,(2 * WORDSIZE));
  VM_ProcessorLocalState.emitSetProcessor(asm,EBX,VM_Entrypoints.JNIEnvSavedPRField.getOffset());
  VM_ProcessorLocalState.emitMoveFieldToReg(asm,JTOC,VM_Entrypoints.jtocField.getOffset());
  VM_ProcessorLocalState.emitMoveFieldToReg(asm,T0,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitCMP_Reg_Imm(T0,VM_Processor.IN_NATIVE);
  VM_ForwardReference fr=asm.forwardJcc(asm.EQ);
  asm.emitMOV_Reg_RegDisp(T0,JTOC,VM_Entrypoints.the_boot_recordField.getOffset());
  asm.emitCALL_RegDisp(T0,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset());
  asm.emitJMP_Imm(retryLabel);
  fr.resolve(asm);
  asm.emitMOV_Reg_Imm(T1,VM_Processor.IN_JAVA);
  VM_ProcessorLocalState.emitCompareAndExchangeField(asm,VM_Entrypoints.vpStatusField.getOffset(),T1);
  asm.emitJCC_Cond_Imm(asm.NE,retryLabel);
  int numLocalVariables=method.getLocalWords() - method.getParameterWords();
  asm.emitSUB_Reg_Imm(SP,(numLocalVariables << LG_WORDSIZE));
  asm.emitMOV_Reg_RegDisp(S0,EBX,VM_Entrypoints.JNITopJavaFPField.getOffset());
  asm.emitSUB_Reg_Reg(S0,EBP);
  asm.emitMOV_RegDisp_Reg(EBP,SAVED_JAVA_FP_OFFSET,S0);
  VM_ProcessorLocalState.emitMoveRegToField(asm,VM_Entrypoints.framePointerField.getOffset(),EBP);
  asm.emitNOP();
}",0.9965414430530708
150175,"/** 
 * Convert address of object or chunk to address of slot in the object map.
 * @param addr The address of the object
 * @return The address of the slot
 */
private static final int addressToSlot(Address addr){
  if (Assert.VERIFY_ASSERTIONS) {
    boolean inHeap=VMResource.refInVM(addr);
    if (!inHeap)     debugln(0,""String_Node_Str"",addr);
    Assert._assert(inHeap,""String_Node_Str"");
  }
  return (addr.toWord().rshl(SLOT_OFFSET).toInt() & (BITMAPS_IN_PAGEMAP - 1));
}","/** 
 * Convert address of object or chunk to address of slot in the object map.
 * @param addr The address of the object
 * @return The address of the slot
 */
private static final int addressToSlot(Address addr){
  if (Assert.VERIFY_ASSERTIONS) {
    boolean inHeap=VMResource.addressInVM(addr);
    if (!inHeap)     debugln(0,""String_Node_Str"",addr);
    Assert._assert(inHeap,""String_Node_Str"");
  }
  return (addr.toWord().rshl(SLOT_OFFSET).toInt() & (BITMAPS_IN_PAGEMAP - 1));
}",0.9896265560165975
150176,"/** 
 * Convert address of object or chunk to index of page in the object map.
 * @param addr The address of the object
 * @return The address of the slot
 */
private static final int addressToPage(Address addr){
  if (Assert.VERIFY_ASSERTIONS) {
    boolean inHeap=VMResource.refInVM(addr);
    if (!inHeap)     debugln(0,""String_Node_Str"",addr);
    Assert._assert(inHeap,""String_Node_Str"");
    Assert._assert(((addr.toWord().rshl(PAGE_OFFSET).toInt()) < PAGEMAPS_IN_OBJECTMAP));
  }
  return addr.toWord().rshl(PAGE_OFFSET).toInt();
}","/** 
 * Convert address of object or chunk to index of page in the object map.
 * @param addr The address of the object
 * @return The address of the slot
 */
private static final int addressToPage(Address addr){
  if (Assert.VERIFY_ASSERTIONS) {
    boolean inHeap=VMResource.addressInVM(addr);
    if (!inHeap)     debugln(0,""String_Node_Str"",addr);
    Assert._assert(inHeap,""String_Node_Str"");
    Assert._assert(((addr.toWord().rshl(PAGE_OFFSET).toInt()) < PAGEMAPS_IN_OBJECTMAP));
  }
  return addr.toWord().rshl(PAGE_OFFSET).toInt();
}",0.9907407407407408
150177,"/** 
 * Is the method Uninterruptible? See the comment in   {@link #isInterruptible}
 */
public final boolean isUninterruptible(){
  if (isClassInitializer() || isObjectInitializer())   return false;
  if (isObjectInitializerHelper())   return false;
  if (exceptionTypes != null) {
    if (InterruptiblePragma.declaredBy(this))     return false;
    if (PreemptiblePragma.declaredBy(this))     return false;
    if (UninterruptibleNoWarnPragma.declaredBy(this))     return true;
    if (UninterruptiblePragma.declaredBy(this))     return true;
  }
  VM_Class[] interfaces=getDeclaringClass().getDeclaredInterfaces();
  for (int i=0; i < interfaces.length; i++) {
    if (interfaces[i].isUninterruptibleType())     return true;
  }
  return false;
}","/** 
 * Is the method Uninterruptible? See the comment in   {@link #isInterruptible}
 */
public final boolean isUninterruptible(){
  if (isClassInitializer() || isObjectInitializer())   return false;
  if (isObjectInitializerHelper())   return false;
  if (exceptionTypes != null) {
    if (InterruptiblePragma.declaredBy(this))     return false;
    if (PreemptiblePragma.declaredBy(this))     return false;
    if (UnpreemptiblePragma.declaredBy(this))     return false;
    if (UninterruptibleNoWarnPragma.declaredBy(this))     return true;
    if (UninterruptiblePragma.declaredBy(this))     return true;
  }
  VM_Class[] interfaces=getDeclaringClass().getDeclaredInterfaces();
  for (int i=0; i < interfaces.length; i++) {
    if (interfaces[i].isUninterruptibleType())     return true;
  }
  return false;
}",0.9590268886043534
150178,"/** 
 * Is the method Unpreemptible? See the comment in   {@link #isInterruptible}
 */
public final boolean isUnpreemptible(){
  if (isClassInitializer() || isObjectInitializer())   return false;
  if (isObjectInitializerHelper())   return false;
  if (exceptionTypes != null) {
    if (InterruptiblePragma.declaredBy(this))     return false;
    if (PreemptiblePragma.declaredBy(this))     return false;
    if (UnpreemptiblePragma.declaredBy(this))     return true;
  }
  VM_Class[] interfaces=getDeclaringClass().getDeclaredInterfaces();
  for (int i=0; i < interfaces.length; i++) {
    if (interfaces[i].isUnpreemptibleType())     return true;
  }
  return false;
}","/** 
 * Is the method Unpreemptible? See the comment in   {@link #isInterruptible}
 */
public final boolean isUnpreemptible(){
  if (isClassInitializer() || isObjectInitializer())   return false;
  if (isObjectInitializerHelper())   return false;
  if (exceptionTypes != null) {
    if (InterruptiblePragma.declaredBy(this))     return false;
    if (PreemptiblePragma.declaredBy(this))     return false;
    if (UnpreemptiblePragma.declaredBy(this))     return true;
    if (UninterruptibleNoWarnPragma.declaredBy(this))     return false;
    if (UninterruptiblePragma.declaredBy(this))     return false;
  }
  VM_Class[] interfaces=getDeclaringClass().getDeclaredInterfaces();
  for (int i=0; i < interfaces.length; i++) {
    if (interfaces[i].isUnpreemptibleType())     return true;
  }
  return false;
}",0.9066305818673884
150179,"/** 
 * Generate inline code sequence for specified method.
 * @param methodToBeCalled: method whose name indicates semantics of code to be generated
 * @return true if there was magic defined for the method
 */
private boolean generateInlineCode(VM_MethodReference methodToBeCalled){
  VM_Atom methodName=methodToBeCalled.getName();
  if (methodToBeCalled.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=methodToBeCalled.getParameterTypes();
    int paramWords=methodToBeCalled.getParameterWords();
    int gp=FIRST_OS_PARAMETER_GPR;
    int fp=FIRST_OS_PARAMETER_FPR;
    int stackIndex=paramWords;
    int paramBytes=(VM.BuildFor64Addr ? args.length : paramWords) * BYTES_IN_STACKSLOT;
    int callee_param_index=-BYTES_IN_STACKSLOT - paramBytes;
    for (int i=0; i < args.length; i++) {
      VM_TypeReference t=args[i];
      if (t.isLongType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_LONG;
        if (VM.BuildFor64Addr) {
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekLong(gp,gp,stackIndex);
            gp++;
          }
 else {
            peekLong(S0,S0,stackIndex);
            asm.emitSTD(S0,callee_param_index - BYTES_IN_LONG,FP);
          }
        }
 else {
          gp+=(gp + 1) & 0x01;
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex);
          }
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex + 1);
          }
 else {
            peekLong(S0,S1,stackIndex);
            asm.emitSTW(S0,callee_param_index - BYTES_IN_LONG,FP);
            asm.emitSTW(S1,callee_param_index - BYTES_IN_INT,FP);
          }
        }
      }
 else       if (t.isFloatType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekFloat(fp++,stackIndex);
        }
 else {
          peekFloat(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFS(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_FLOAT,FP);
        }
      }
 else       if (t.isDoubleType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_DOUBLE;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekDouble(fp++,stackIndex);
        }
 else {
          peekDouble(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFD(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_DOUBLE,FP);
        }
      }
 else       if (t.isIntLikeType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekInt(gp++,stackIndex);
        }
 else {
          peekInt(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
 else {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekAddr(gp++,stackIndex);
        }
 else {
          peekAddr(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
    }
    if (VM.VerifyAssertions) {
      VM._assert(stackIndex == 0);
    }
    VM_Field ip=VM_Entrypoints.getSysCallField(methodName.toString());
    generateSysCall(paramBytes,ip);
    discardSlots(paramWords);
    VM_TypeReference rtype=methodToBeCalled.getReturnType();
    if (rtype.isIntLikeType()) {
      pushInt(T0);
    }
 else     if (rtype.isWordType() || rtype.isReferenceType()) {
      pushAddr(T0);
    }
 else     if (rtype.isDoubleType()) {
      pushDouble(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isFloatType()) {
      pushFloat(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isLongType()) {
      pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
    }
    return true;
  }
  if (methodToBeCalled.getType() == VM_TypeReference.Address) {
    VM_TypeReference[] types=methodToBeCalled.getParameterTypes();
    if (methodName == VM_MagicNames.loadAddress || methodName == VM_MagicNames.loadObjectReference || methodName == VM_MagicNames.loadWord) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLAddr(T0,0,T0);
        pushAddr(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLAddrX(T0,T1,T0);
        pushAddr(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadChar || methodName == VM_MagicNames.loadShort) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLHZ(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLHZX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadByte) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLBZ(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLBZX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadInt || methodName == VM_MagicNames.loadFloat) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLInt(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLIntX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadDouble || methodName == VM_MagicNames.loadLong) {
      if (types.length == 0) {
        popAddr(T1);
        asm.emitLFD(F0,0,T1);
        pushDouble(F0);
      }
 else {
        popInt(T2);
        popAddr(T1);
        asm.emitLFDX(F0,T1,T2);
        pushDouble(F0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.prepareInt) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLWARX(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLWARX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.prepareWord || methodName == VM_MagicNames.prepareObjectReference || methodName == VM_MagicNames.prepareAddress) {
      if (types.length == 0) {
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitLWARX(T0,0,T0);
        }
 else {
          asm.emitLDARX(T0,0,T0);
        }
        pushAddr(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitLWARX(T0,T1,T0);
        }
 else {
          asm.emitLDARX(T0,T1,T0);
        }
        pushAddr(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.attempt && types[0] == VM_TypeReference.Int) {
      if (types.length == 2) {
        popInt(T2);
        discardSlot();
        popAddr(T0);
        asm.emitSTWCXr(T2,0,T0);
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popInt(T2);
        discardSlot();
        popAddr(T0);
        asm.emitSTWCXr(T2,T1,T0);
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.attempt && (types[0] == VM_TypeReference.Address || types[0] == VM_TypeReference.Word)) {
      if (types.length == 2) {
        popAddr(T2);
        discardSlot();
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitSTWCXr(T2,0,T0);
        }
 else {
          asm.emitSTDCXr(T2,0,T0);
        }
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T2);
        discardSlot();
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitSTWCXr(T2,T1,T0);
        }
 else {
          asm.emitSTDCXr(T2,T1,T0);
        }
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.store) {
      if (types[0] == VM_TypeReference.Word || types[0] == VM_TypeReference.Address) {
        if (types.length == 1) {
          popAddr(T1);
          popAddr(T0);
          asm.emitSTAddrX(T1,0,T0);
        }
 else {
          popInt(T1);
          popAddr(T2);
          popAddr(T0);
          asm.emitSTAddrX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Byte) {
        if (types.length == 1) {
          popInt(T1);
          popAddr(T0);
          asm.emitSTBX(T1,0,T0);
        }
 else {
          popInt(T1);
          popInt(T2);
          popAddr(T0);
          asm.emitSTBX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Int || types[0] == VM_TypeReference.Float) {
        if (types.length == 1) {
          popInt(T1);
          popAddr(T0);
          asm.emitSTWX(T1,0,T0);
        }
 else {
          popInt(T1);
          popInt(T2);
          popAddr(T0);
          asm.emitSTWX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Short || types[0] == VM_TypeReference.Char) {
        if (types.length == 1) {
          popInt(T1);
          popAddr(T0);
          asm.emitSTHX(T1,0,T0);
        }
 else {
          popInt(T1);
          popInt(T2);
          popAddr(T0);
          asm.emitSTHX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Double || types[0] == VM_TypeReference.Long) {
        if (types.length == 1) {
          popLong(T2,T1);
          popAddr(T0);
          if (VM.BuildFor32Addr) {
            asm.emitSTWX(T2,0,T0);
            asm.emitSTWX(T1,BYTES_IN_INT,T0);
          }
 else {
            asm.emitSTDX(T1,0,T0);
          }
        }
 else {
          popInt(T1);
          popLong(T3,T2);
          popAddr(T0);
          if (VM.BuildFor32Addr) {
            asm.emitSTWX(T3,T1,T0);
            asm.emitADDI(T1,BYTES_IN_INT,T1);
            asm.emitSTWX(T2,T1,T0);
          }
 else {
            asm.emitSTDX(T2,T1,T0);
          }
        }
        return true;
      }
    }
  }
  if (methodName == VM_MagicNames.getFramePointer) {
    pushAddr(FP);
  }
 else   if (methodName == VM_MagicNames.getCallerFramePointer) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setCallerFramePointer) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getCompiledMethodID) {
    popAddr(T0);
    asm.emitLInt(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
    pushInt(T1);
  }
 else   if (methodName == VM_MagicNames.setCompiledMethodID) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getNextInstructionAddress) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setNextInstructionAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getReturnAddressLocation) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    asm.emitADDI(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.getTocPointer || methodName == VM_MagicNames.getJTOC) {
    pushAddr(JTOC);
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    pushAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    popAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    if (VM.BuildFor64Addr) {
      asm.emitMFTB(T1);
    }
 else {
      int label=asm.getMachineCodeIndex();
      asm.emitMFTBU(T0);
      asm.emitMFTB(T1);
      asm.emitMFTBU(T2);
      asm.emitCMP(T0,T2);
      asm.emitBC(NE,label);
    }
    pushLong(T0,T1);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    peekAddr(T0,0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    asm.emitBCCTRL();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningVoid) {
    generateMethodInvocation();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningInt) {
    generateMethodInvocation();
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningLong) {
    generateMethodInvocation();
    pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
    generateMethodInvocation();
    pushFloat(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
    generateMethodInvocation();
    pushDouble(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningObject) {
    generateMethodInvocation();
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    VM_Array type=methodToBeCalled.getType().resolve().asArray();
    emit_resolved_newarray(type);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    emit_arraylength();
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iaload();
    }
 else {
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitLAddrX(T2,T0,T1);
      pushAddr(T2);
    }
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iastore();
    }
 else {
      popAddr(T2);
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitSTAddrX(T2,T0,T1);
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLIntX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset || methodName == VM_MagicNames.getWordAtOffset || methodName == VM_MagicNames.getObjectArrayAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLAddrX(T0,T1,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLBZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLHZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTWX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset || methodName == VM_MagicNames.setWordAtOffset) {
    if (methodToBeCalled.getParameterTypes().length == 4) {
      discardSlot();
    }
    popAddr(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTAddrX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTBX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTHX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset || methodName == VM_MagicNames.getDoubleAtOffset) {
    popInt(T2);
    popAddr(T1);
    asm.emitLFDX(F0,T1,T2);
    pushDouble(F0);
  }
 else   if ((methodName == VM_MagicNames.setLongAtOffset) || (methodName == VM_MagicNames.setDoubleAtOffset)) {
    popLong(T3,T2);
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWX(T3,T1,T0);
      asm.emitADDI(T1,BYTES_IN_INT,T1);
      asm.emitSTWX(T2,T1,T0);
    }
 else {
      asm.emitSTDX(T2,T1,T0);
    }
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    popAddr(T0);
    asm.emitLInt(T0,0,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getMemoryWord || methodName == VM_MagicNames.getMemoryAddress) {
    popAddr(T0);
    asm.emitLAddr(T0,0,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryWord || methodName == VM_MagicNames.setMemoryAddress) {
    if (methodToBeCalled.getParameterTypes().length == 3) {
      discardSlot();
    }
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitLWARX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.prepareObject || methodName == VM_MagicNames.prepareAddress || methodName == VM_MagicNames.prepareWord) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitLWARX(T0,T1,T0);
    }
 else {
      asm.emitLDARX(T0,T1,T0);
    }
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    popInt(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    asm.emitSTWCXr(T2,T1,T0);
    asm.emitLVAL(T0,0);
    VM_ForwardReference fr=asm.emitForwardBC(NE);
    asm.emitLVAL(T0,1);
    fr.resolve(asm);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.attemptObject || methodName == VM_MagicNames.attemptAddress || methodName == VM_MagicNames.attemptObjectReference || methodName == VM_MagicNames.attemptWord) {
    popAddr(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWCXr(T2,T1,T0);
    }
 else {
      asm.emitSTDCXr(T2,T1,T0);
    }
    asm.emitLVAL(T0,0);
    VM_ForwardReference fr=asm.emitForwardBC(NE);
    asm.emitLVAL(T0,1);
    fr.resolve(asm);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.saveThreadStateInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    peekAddr(T1,0);
    peekAddr(T0,1);
    asm.emitLAddrToc(S0,VM_Entrypoints.threadSwitchInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlots(2);
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.restoreHardwareExceptionStateInstructionsField.getOffset());
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.returnToNewStack) {
    peekAddr(FP,0);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.dynamicBridgeTo) {
    if (VM.VerifyAssertions)     VM._assert(klass.isDynamicBridge());
    peekAddr(T0,0);
    asm.emitMTCTR(T0);
    int offset=frameSize;
    for (int i=LAST_NONVOLATILE_FPR; i >= FIRST_VOLATILE_FPR; --i)     asm.emitLFD(i,offset-=BYTES_IN_DOUBLE,FP);
    for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_NONVOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    offset-=(FIRST_NONVOLATILE_GPR - LAST_VOLATILE_GPR - 1) * BYTES_IN_ADDRESS;
    for (int i=LAST_VOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    asm.emitLAddr(FP,0,FP);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCCTR();
  }
 else   if (methodName == VM_MagicNames.objectAsAddress || methodName == VM_MagicNames.addressAsByteArray || methodName == VM_MagicNames.addressAsIntArray || methodName == VM_MagicNames.addressAsObject || methodName == VM_MagicNames.addressAsObjectArray || methodName == VM_MagicNames.addressAsType || methodName == VM_MagicNames.objectAsType || methodName == VM_MagicNames.objectAsByteArray || methodName == VM_MagicNames.objectAsShortArray || methodName == VM_MagicNames.objectAsIntArray || methodName == VM_MagicNames.addressAsThread || methodName == VM_MagicNames.objectAsThread || methodName == VM_MagicNames.objectAsProcessor || methodName == VM_MagicNames.threadAsCollectorThread || methodName == VM_MagicNames.addressAsRegisters || methodName == VM_MagicNames.addressAsStack || methodName == VM_MagicNames.floatAsIntBits || methodName == VM_MagicNames.intBitsAsFloat || methodName == VM_MagicNames.doubleAsLongBits || methodName == VM_MagicNames.longBitsAsDouble) {
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    popAddr(T0);
    VM_ObjectModel.baselineEmitLoadTIB(asm,T0,T0);
    asm.emitLAddr(T0,TIB_TYPE_INDEX << LOG_BYTES_IN_ADDRESS,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    popAddr(T0);
    asm.emitLInt(T0,VM_ObjectModel.getArrayLengthOffset(),T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.sync) {
    asm.emitSYNC();
  }
 else   if (methodName == VM_MagicNames.isync) {
    asm.emitISYNC();
  }
 else   if (methodName == VM_MagicNames.dcbst) {
    popAddr(T0);
    asm.emitDCBST(0,T0);
  }
 else   if (methodName == VM_MagicNames.icbi) {
    popAddr(T0);
    asm.emitICBI(0,T0);
  }
 else   if (methodName == VM_MagicNames.wordToInt || methodName == VM_MagicNames.wordToAddress || methodName == VM_MagicNames.wordToOffset || methodName == VM_MagicNames.wordToObject || methodName == VM_MagicNames.wordFromObject || methodName == VM_MagicNames.wordToObjectReference || methodName == VM_MagicNames.wordToExtent || methodName == VM_MagicNames.wordToWord) {
  }
 else   if (methodName == VM_MagicNames.wordToLong) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordFromInt || methodName == VM_MagicNames.wordFromIntSignExtend) {
    if (VM.BuildFor64Addr) {
      popInt(T0);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromIntZeroExtend) {
    if (VM.BuildFor64Addr) {
      asm.emitLWZ(T0,spTopOffset + BYTES_IN_STACKSLOT - BYTES_IN_INT,FP);
      pokeAddr(T0,0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromLong) {
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.wordAdd) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitADD(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordSub || methodName == VM_MagicNames.wordDiff) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitSUBFC(T2,T0,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordEQ) {
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordNE) {
    generateAddrComparison(false,NE);
  }
 else   if (methodName == VM_MagicNames.wordLT) {
    generateAddrComparison(false,LT);
  }
 else   if (methodName == VM_MagicNames.wordLE) {
    generateAddrComparison(false,LE);
  }
 else   if (methodName == VM_MagicNames.wordGT) {
    generateAddrComparison(false,GT);
  }
 else   if (methodName == VM_MagicNames.wordGE) {
    generateAddrComparison(false,GE);
  }
 else   if (methodName == VM_MagicNames.wordsLT) {
    generateAddrComparison(true,LT);
  }
 else   if (methodName == VM_MagicNames.wordsLE) {
    generateAddrComparison(true,LE);
  }
 else   if (methodName == VM_MagicNames.wordsGT) {
    generateAddrComparison(true,GT);
  }
 else   if (methodName == VM_MagicNames.wordsGE) {
    generateAddrComparison(true,GE);
  }
 else   if (methodName == VM_MagicNames.wordIsZero || methodName == VM_MagicNames.wordIsNull) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordIsMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordOne) {
    asm.emitLVAL(T0,1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordAnd) {
    popAddr(T0);
    popAddr(T1);
    asm.emitAND(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordOr) {
    popAddr(T0);
    popAddr(T1);
    asm.emitOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordNot) {
    popAddr(T0);
    asm.emitLVAL(T1,-1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordXor) {
    popAddr(T0);
    popAddr(T1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordLsh) {
    popInt(T0);
    popAddr(T1);
    asm.emitSLAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRshl) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRsha) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRA_Addr(T2,T1,T0);
    pushAddr(T2);
  }
 else {
    return false;
  }
  return true;
}","/** 
 * Generate inline code sequence for specified method.
 * @param methodToBeCalled: method whose name indicates semantics of code to be generated
 * @return true if there was magic defined for the method
 */
private boolean generateInlineCode(VM_MethodReference methodToBeCalled){
  VM_Atom methodName=methodToBeCalled.getName();
  if (methodToBeCalled.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=methodToBeCalled.getParameterTypes();
    int paramWords=methodToBeCalled.getParameterWords();
    int gp=FIRST_OS_PARAMETER_GPR;
    int fp=FIRST_OS_PARAMETER_FPR;
    int stackIndex=paramWords;
    int paramBytes=(VM.BuildFor64Addr ? args.length : paramWords) * BYTES_IN_STACKSLOT;
    int callee_param_index=-BYTES_IN_STACKSLOT - paramBytes;
    for (int i=0; i < args.length; i++) {
      VM_TypeReference t=args[i];
      if (t.isLongType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_LONG;
        if (VM.BuildFor64Addr) {
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekLong(gp,gp,stackIndex);
            gp++;
          }
 else {
            peekLong(S0,S0,stackIndex);
            asm.emitSTD(S0,callee_param_index - BYTES_IN_LONG,FP);
          }
        }
 else {
          gp+=(gp + 1) & 0x01;
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex);
          }
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex + 1);
          }
 else {
            peekLong(S0,S1,stackIndex);
            asm.emitSTW(S0,callee_param_index - BYTES_IN_LONG,FP);
            asm.emitSTW(S1,callee_param_index - BYTES_IN_INT,FP);
          }
        }
      }
 else       if (t.isFloatType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekFloat(fp++,stackIndex);
        }
 else {
          peekFloat(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFS(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_FLOAT,FP);
        }
      }
 else       if (t.isDoubleType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_DOUBLE;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekDouble(fp++,stackIndex);
        }
 else {
          peekDouble(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFD(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_DOUBLE,FP);
        }
      }
 else       if (t.isIntLikeType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekInt(gp++,stackIndex);
        }
 else {
          peekInt(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
 else {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekAddr(gp++,stackIndex);
        }
 else {
          peekAddr(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
    }
    if (VM.VerifyAssertions) {
      VM._assert(stackIndex == 0);
    }
    VM_Field ip=VM_Entrypoints.getSysCallField(methodName.toString());
    generateSysCall(paramBytes,ip);
    discardSlots(paramWords);
    VM_TypeReference rtype=methodToBeCalled.getReturnType();
    if (rtype.isIntLikeType()) {
      pushInt(T0);
    }
 else     if (rtype.isWordType() || rtype.isReferenceType()) {
      pushAddr(T0);
    }
 else     if (rtype.isDoubleType()) {
      pushDouble(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isFloatType()) {
      pushFloat(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isLongType()) {
      pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
    }
    return true;
  }
  if (methodToBeCalled.getType() == VM_TypeReference.Address) {
    VM_TypeReference[] types=methodToBeCalled.getParameterTypes();
    if (methodName == VM_MagicNames.loadAddress || methodName == VM_MagicNames.loadObjectReference || methodName == VM_MagicNames.loadWord) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLAddr(T0,0,T0);
        pushAddr(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLAddrX(T0,T1,T0);
        pushAddr(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadChar || methodName == VM_MagicNames.loadShort) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLHZ(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLHZX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadByte) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLBZ(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLBZX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadInt || methodName == VM_MagicNames.loadFloat) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLInt(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLIntX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.loadDouble || methodName == VM_MagicNames.loadLong) {
      if (types.length == 0) {
        popAddr(T1);
        asm.emitLFD(F0,0,T1);
        pushDouble(F0);
      }
 else {
        popInt(T2);
        popAddr(T1);
        asm.emitLFDX(F0,T1,T2);
        pushDouble(F0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.prepareInt) {
      if (types.length == 0) {
        popAddr(T0);
        asm.emitLWARX(T0,0,T0);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        asm.emitLWARX(T0,T1,T0);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.prepareWord || methodName == VM_MagicNames.prepareObjectReference || methodName == VM_MagicNames.prepareAddress) {
      if (types.length == 0) {
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitLWARX(T0,0,T0);
        }
 else {
          asm.emitLDARX(T0,0,T0);
        }
        pushAddr(T0);
      }
 else {
        popInt(T1);
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitLWARX(T0,T1,T0);
        }
 else {
          asm.emitLDARX(T0,T1,T0);
        }
        pushAddr(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.attempt && types[0] == VM_TypeReference.Int) {
      if (types.length == 2) {
        popInt(T2);
        discardSlot();
        popAddr(T0);
        asm.emitSTWCXr(T2,0,T0);
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popInt(T2);
        discardSlot();
        popAddr(T0);
        asm.emitSTWCXr(T2,T1,T0);
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.attempt && (types[0] == VM_TypeReference.Address || types[0] == VM_TypeReference.Word)) {
      if (types.length == 2) {
        popAddr(T2);
        discardSlot();
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitSTWCXr(T2,0,T0);
        }
 else {
          asm.emitSTDCXr(T2,0,T0);
        }
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
 else {
        popInt(T1);
        popAddr(T2);
        discardSlot();
        popAddr(T0);
        if (VM.BuildFor32Addr) {
          asm.emitSTWCXr(T2,T1,T0);
        }
 else {
          asm.emitSTDCXr(T2,T1,T0);
        }
        asm.emitLVAL(T0,0);
        VM_ForwardReference fr=asm.emitForwardBC(NE);
        asm.emitLVAL(T0,1);
        fr.resolve(asm);
        pushInt(T0);
      }
      return true;
    }
    if (methodName == VM_MagicNames.store) {
      if (types[0] == VM_TypeReference.Word || types[0] == VM_TypeReference.ObjectReference || types[0] == VM_TypeReference.Address) {
        if (types.length == 1) {
          popAddr(T1);
          popAddr(T0);
          asm.emitSTAddrX(T1,0,T0);
        }
 else {
          popInt(T1);
          popAddr(T2);
          popAddr(T0);
          asm.emitSTAddrX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Byte) {
        if (types.length == 1) {
          popInt(T1);
          popAddr(T0);
          asm.emitSTBX(T1,0,T0);
        }
 else {
          popInt(T1);
          popInt(T2);
          popAddr(T0);
          asm.emitSTBX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Int || types[0] == VM_TypeReference.Float) {
        if (types.length == 1) {
          popInt(T1);
          popAddr(T0);
          asm.emitSTWX(T1,0,T0);
        }
 else {
          popInt(T1);
          popInt(T2);
          popAddr(T0);
          asm.emitSTWX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Short || types[0] == VM_TypeReference.Char) {
        if (types.length == 1) {
          popInt(T1);
          popAddr(T0);
          asm.emitSTHX(T1,0,T0);
        }
 else {
          popInt(T1);
          popInt(T2);
          popAddr(T0);
          asm.emitSTHX(T2,T1,T0);
        }
        return true;
      }
      if (types[0] == VM_TypeReference.Double || types[0] == VM_TypeReference.Long) {
        if (types.length == 1) {
          popLong(T2,T1);
          popAddr(T0);
          if (VM.BuildFor32Addr) {
            asm.emitSTWX(T2,0,T0);
            asm.emitSTWX(T1,BYTES_IN_INT,T0);
          }
 else {
            asm.emitSTDX(T1,0,T0);
          }
        }
 else {
          popInt(T1);
          popLong(T3,T2);
          popAddr(T0);
          if (VM.BuildFor32Addr) {
            asm.emitSTWX(T3,T1,T0);
            asm.emitADDI(T1,BYTES_IN_INT,T1);
            asm.emitSTWX(T2,T1,T0);
          }
 else {
            asm.emitSTDX(T2,T1,T0);
          }
        }
        return true;
      }
    }
  }
  if (methodName == VM_MagicNames.getFramePointer) {
    pushAddr(FP);
  }
 else   if (methodName == VM_MagicNames.getCallerFramePointer) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setCallerFramePointer) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getCompiledMethodID) {
    popAddr(T0);
    asm.emitLInt(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
    pushInt(T1);
  }
 else   if (methodName == VM_MagicNames.setCompiledMethodID) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getNextInstructionAddress) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setNextInstructionAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getReturnAddressLocation) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    asm.emitADDI(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.getTocPointer || methodName == VM_MagicNames.getJTOC) {
    pushAddr(JTOC);
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    pushAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    popAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    if (VM.BuildFor64Addr) {
      asm.emitMFTB(T1);
    }
 else {
      int label=asm.getMachineCodeIndex();
      asm.emitMFTBU(T0);
      asm.emitMFTB(T1);
      asm.emitMFTBU(T2);
      asm.emitCMP(T0,T2);
      asm.emitBC(NE,label);
    }
    pushLong(T0,T1);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    peekAddr(T0,0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    asm.emitBCCTRL();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningVoid) {
    generateMethodInvocation();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningInt) {
    generateMethodInvocation();
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningLong) {
    generateMethodInvocation();
    pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
    generateMethodInvocation();
    pushFloat(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
    generateMethodInvocation();
    pushDouble(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningObject) {
    generateMethodInvocation();
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    VM_Array type=methodToBeCalled.getType().resolve().asArray();
    emit_resolved_newarray(type);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    emit_arraylength();
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iaload();
    }
 else {
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitLAddrX(T2,T0,T1);
      pushAddr(T2);
    }
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iastore();
    }
 else {
      popAddr(T2);
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitSTAddrX(T2,T0,T1);
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLIntX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset || methodName == VM_MagicNames.getWordAtOffset || methodName == VM_MagicNames.getObjectArrayAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLAddrX(T0,T1,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLBZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLHZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTWX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset || methodName == VM_MagicNames.setWordAtOffset) {
    if (methodToBeCalled.getParameterTypes().length == 4) {
      discardSlot();
    }
    popAddr(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTAddrX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTBX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTHX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset || methodName == VM_MagicNames.getDoubleAtOffset) {
    popInt(T2);
    popAddr(T1);
    asm.emitLFDX(F0,T1,T2);
    pushDouble(F0);
  }
 else   if ((methodName == VM_MagicNames.setLongAtOffset) || (methodName == VM_MagicNames.setDoubleAtOffset)) {
    popLong(T3,T2);
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWX(T3,T1,T0);
      asm.emitADDI(T1,BYTES_IN_INT,T1);
      asm.emitSTWX(T2,T1,T0);
    }
 else {
      asm.emitSTDX(T2,T1,T0);
    }
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    popAddr(T0);
    asm.emitLInt(T0,0,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getMemoryWord || methodName == VM_MagicNames.getMemoryAddress) {
    popAddr(T0);
    asm.emitLAddr(T0,0,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryWord || methodName == VM_MagicNames.setMemoryAddress) {
    if (methodToBeCalled.getParameterTypes().length == 3) {
      discardSlot();
    }
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitLWARX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.prepareObject || methodName == VM_MagicNames.prepareAddress || methodName == VM_MagicNames.prepareWord) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitLWARX(T0,T1,T0);
    }
 else {
      asm.emitLDARX(T0,T1,T0);
    }
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    popInt(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    asm.emitSTWCXr(T2,T1,T0);
    asm.emitLVAL(T0,0);
    VM_ForwardReference fr=asm.emitForwardBC(NE);
    asm.emitLVAL(T0,1);
    fr.resolve(asm);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.attemptObject || methodName == VM_MagicNames.attemptAddress || methodName == VM_MagicNames.attemptObjectReference || methodName == VM_MagicNames.attemptWord) {
    popAddr(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWCXr(T2,T1,T0);
    }
 else {
      asm.emitSTDCXr(T2,T1,T0);
    }
    asm.emitLVAL(T0,0);
    VM_ForwardReference fr=asm.emitForwardBC(NE);
    asm.emitLVAL(T0,1);
    fr.resolve(asm);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.saveThreadStateInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    peekAddr(T1,0);
    peekAddr(T0,1);
    asm.emitLAddrToc(S0,VM_Entrypoints.threadSwitchInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlots(2);
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.restoreHardwareExceptionStateInstructionsField.getOffset());
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.returnToNewStack) {
    peekAddr(FP,0);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.dynamicBridgeTo) {
    if (VM.VerifyAssertions)     VM._assert(klass.isDynamicBridge());
    peekAddr(T0,0);
    asm.emitMTCTR(T0);
    int offset=frameSize;
    for (int i=LAST_NONVOLATILE_FPR; i >= FIRST_VOLATILE_FPR; --i)     asm.emitLFD(i,offset-=BYTES_IN_DOUBLE,FP);
    for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_NONVOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    offset-=(FIRST_NONVOLATILE_GPR - LAST_VOLATILE_GPR - 1) * BYTES_IN_ADDRESS;
    for (int i=LAST_VOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    asm.emitLAddr(FP,0,FP);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCCTR();
  }
 else   if (methodName == VM_MagicNames.objectAsAddress || methodName == VM_MagicNames.addressAsByteArray || methodName == VM_MagicNames.addressAsIntArray || methodName == VM_MagicNames.addressAsObject || methodName == VM_MagicNames.addressAsObjectArray || methodName == VM_MagicNames.addressAsType || methodName == VM_MagicNames.objectAsType || methodName == VM_MagicNames.objectAsByteArray || methodName == VM_MagicNames.objectAsShortArray || methodName == VM_MagicNames.objectAsIntArray || methodName == VM_MagicNames.addressAsThread || methodName == VM_MagicNames.objectAsThread || methodName == VM_MagicNames.objectAsProcessor || methodName == VM_MagicNames.threadAsCollectorThread || methodName == VM_MagicNames.addressAsRegisters || methodName == VM_MagicNames.addressAsStack || methodName == VM_MagicNames.floatAsIntBits || methodName == VM_MagicNames.intBitsAsFloat || methodName == VM_MagicNames.doubleAsLongBits || methodName == VM_MagicNames.longBitsAsDouble) {
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    popAddr(T0);
    VM_ObjectModel.baselineEmitLoadTIB(asm,T0,T0);
    asm.emitLAddr(T0,TIB_TYPE_INDEX << LOG_BYTES_IN_ADDRESS,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    popAddr(T0);
    asm.emitLInt(T0,VM_ObjectModel.getArrayLengthOffset(),T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.sync) {
    asm.emitSYNC();
  }
 else   if (methodName == VM_MagicNames.isync) {
    asm.emitISYNC();
  }
 else   if (methodName == VM_MagicNames.dcbst) {
    popAddr(T0);
    asm.emitDCBST(0,T0);
  }
 else   if (methodName == VM_MagicNames.icbi) {
    popAddr(T0);
    asm.emitICBI(0,T0);
  }
 else   if (methodName == VM_MagicNames.wordToInt || methodName == VM_MagicNames.wordToAddress || methodName == VM_MagicNames.wordToOffset || methodName == VM_MagicNames.wordToObject || methodName == VM_MagicNames.wordFromObject || methodName == VM_MagicNames.wordToObjectReference || methodName == VM_MagicNames.wordToExtent || methodName == VM_MagicNames.wordToWord) {
  }
 else   if (methodName == VM_MagicNames.wordToLong) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordFromInt || methodName == VM_MagicNames.wordFromIntSignExtend) {
    if (VM.BuildFor64Addr) {
      popInt(T0);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromIntZeroExtend) {
    if (VM.BuildFor64Addr) {
      asm.emitLWZ(T0,spTopOffset + BYTES_IN_STACKSLOT - BYTES_IN_INT,FP);
      pokeAddr(T0,0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromLong) {
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.wordAdd) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitADD(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordSub || methodName == VM_MagicNames.wordDiff) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitSUBFC(T2,T0,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordEQ) {
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordNE) {
    generateAddrComparison(false,NE);
  }
 else   if (methodName == VM_MagicNames.wordLT) {
    generateAddrComparison(false,LT);
  }
 else   if (methodName == VM_MagicNames.wordLE) {
    generateAddrComparison(false,LE);
  }
 else   if (methodName == VM_MagicNames.wordGT) {
    generateAddrComparison(false,GT);
  }
 else   if (methodName == VM_MagicNames.wordGE) {
    generateAddrComparison(false,GE);
  }
 else   if (methodName == VM_MagicNames.wordsLT) {
    generateAddrComparison(true,LT);
  }
 else   if (methodName == VM_MagicNames.wordsLE) {
    generateAddrComparison(true,LE);
  }
 else   if (methodName == VM_MagicNames.wordsGT) {
    generateAddrComparison(true,GT);
  }
 else   if (methodName == VM_MagicNames.wordsGE) {
    generateAddrComparison(true,GE);
  }
 else   if (methodName == VM_MagicNames.wordIsZero || methodName == VM_MagicNames.wordIsNull) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordIsMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordOne) {
    asm.emitLVAL(T0,1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordAnd) {
    popAddr(T0);
    popAddr(T1);
    asm.emitAND(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordOr) {
    popAddr(T0);
    popAddr(T1);
    asm.emitOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordNot) {
    popAddr(T0);
    asm.emitLVAL(T1,-1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordXor) {
    popAddr(T0);
    popAddr(T1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordLsh) {
    popInt(T0);
    popAddr(T1);
    asm.emitSLAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRshl) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRsha) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRA_Addr(T2,T1,T0);
    pushAddr(T2);
  }
 else {
    return false;
  }
  return true;
}",0.999052731291443
150180,"/** 
 * XXX This isn't needed under GNU Classpath 0.11 --- we properly want to create this at the time that we create the Class structure.  That's because the ProtectionDomain associated with a class is a final field in GNU Classpath 0.11's implementation.  
 */
public static void setClassProtectionDomain(Class c,ProtectionDomain pd){
  c.pd=pd;
}","/** 
 * However, under Classpath 0.10, we don't set the ProtectionDomain, and that might be necessary.  We have to use an ugly reflection hack, though, to use Classpath's java.lang.Class, since the field is private. 
 */
public static void setClassProtectionDomain(Class c,ProtectionDomain pd){
  VM_Entrypoints.javaLangClassProtectionDomain.setObjectValueUnchecked(c,pd);
}",0.2876901798063623
150181,"/** 
 * Really Print the stack trace. Delegate the actual printing of the stack trace to the VM_CompiledMethod; this means it will deal with inlining by the opt compiler in a sensible fashion.  This is not ever supposed to throw an OutOfMemoryError.  But if it should ever happen to do so, we will catch it in the caller, print().
 * @param out PrintLN to print on.
 * @param trigger The Throwable that caused the stack trace.Used to elide internal details from the stack trace. If null, then we print a full stack trace, without eliding the methods used internally to gather the stack trace.
 */
private void print4Real(PrintLN out,Throwable trigger,int depth){
  if (depth > printingMaxDepth) {
    VM.sysWriteln(""String_Node_Str"",depth,""String_Node_Str"",traceIndex);
    return;
  }
  int foundTriggerAt=-1;
  int lastFrame=compiledMethods.length - 1;
  lastFrame-=1;
  if (trigger != null) {
    Class triggerClass=trigger.getClass();
    for (int i=0; i <= lastFrame; ++i) {
      VM_CompiledMethod cm=compiledMethods[i];
      if (cm == null || cm.getCompilerType() == VM_CompiledMethod.TRAP)       continue;
      VM_Method m=cm.getMethod();
      VM_Class frameVM_Class=m.getDeclaringClass();
      if (frameVM_Class.getClassForType() == triggerClass) {
        foundTriggerAt=i;
        break;
      }
    }
  }
  while (foundTriggerAt + 2 < compiledMethods.length && compiledMethods[foundTriggerAt + 1] == null) {
    foundTriggerAt++;
  }
  VM_CompiledMethod bottom=compiledMethods[foundTriggerAt + 1];
  if (bottom.getMethod() == VM_Entrypoints.deliverHardwareExceptionMethod) {
    foundTriggerAt+=2;
  }
  int nPrinted=0;
  for (int i=foundTriggerAt + 1; i <= lastFrame; ++i, ++nPrinted) {
    VM_CompiledMethod cm=compiledMethods[i];
    if (nPrinted == elideAfterThisManyFrames) {
      int oldIndex=i;
      int newIndex=lastFrame - 9;
      if (newIndex > oldIndex) {
        i=newIndex;
        try {
          out.print(""String_Node_Str"");
          out.print(newIndex - oldIndex);
          out.println(""String_Node_Str"");
        }
 catch (        OutOfMemoryError e) {
          trigger.tallyOutOfMemoryError();
          if (out.isSysWrite()) {
            VM.sysWriteln(""String_Node_Str"");
          }
 else {
            VM.sysWriteln(""String_Node_Str"");
            VM.sysWriteln(""String_Node_Str"");
            throw e;
          }
        }
      }
    }
    try {
      if (cm == null) {
        out.println(""String_Node_Str"");
      }
 else {
        cm.printStackTrace(offsets[i],out);
      }
    }
 catch (    OutOfMemoryError e) {
      trigger.tallyOutOfMemoryError();
      if (out.isSysWrite()) {
        VM.sysWriteln(""String_Node_Str"");
      }
 else {
        try {
          out.flush();
          VM.sysWriteln();
        }
 catch (        OutOfMemoryError e2) {
          trigger.tallyOutOfMemoryError();
          VM.sysWriteln();
          VM.sysWriteln(""String_Node_Str"");
        }
        VM.sysWriteln(""String_Node_Str"");
        throw e;
      }
    }
  }
}","/** 
 * Really Print the stack trace. Delegate the actual printing of the stack trace to the VM_CompiledMethod; this means it will deal with inlining by the opt compiler in a sensible fashion.  This is not ever supposed to throw an OutOfMemoryError.  But if it should ever happen to do so, we will catch it in the caller, print().
 * @param out PrintLN to print on.
 * @param trigger The Throwable that caused the stack trace.Used to elide internal details from the stack trace. If null, then we print a full stack trace, without eliding the methods used internally to gather the stack trace.
 */
private void print4Real(PrintLN out,Throwable trigger,int depth){
  if (depth > printingMaxDepth) {
    VM.sysWriteln(""String_Node_Str"",depth,""String_Node_Str"",traceIndex);
    return;
  }
  int foundTriggerAt=-1;
  int lastFrame=compiledMethods.length - 1;
  for (; lastFrame > 0; --lastFrame) {
    VM_Method m=compiledMethods[lastFrame].getMethod();
    if (m == VM_Entrypoints.threadStartoffMethod)     continue;
    if (m == VM_Entrypoints.threadRunMethod)     continue;
    if (m == VM_Entrypoints.mainThreadRunMethod)     continue;
    break;
  }
  if (trigger != null) {
    Class triggerClass=trigger.getClass();
    for (int i=0; i <= lastFrame; ++i) {
      VM_CompiledMethod cm=compiledMethods[i];
      if (cm == null || cm.getCompilerType() == VM_CompiledMethod.TRAP)       continue;
      VM_Method m=cm.getMethod();
      VM_Class frameVM_Class=m.getDeclaringClass();
      if (frameVM_Class.getClassForType() == triggerClass) {
        foundTriggerAt=i;
        break;
      }
    }
  }
  while (foundTriggerAt + 2 < compiledMethods.length && compiledMethods[foundTriggerAt + 1] == null) {
    foundTriggerAt++;
  }
  VM_CompiledMethod bottom=compiledMethods[foundTriggerAt + 1];
  if (bottom.getMethod() == VM_Entrypoints.deliverHardwareExceptionMethod) {
    foundTriggerAt+=2;
  }
  int nPrinted=0;
  for (int i=foundTriggerAt + 1; i <= lastFrame; ++i, ++nPrinted) {
    VM_CompiledMethod cm=compiledMethods[i];
    if (nPrinted == elideAfterThisManyFrames) {
      int oldIndex=i;
      int newIndex=lastFrame - 9;
      if (newIndex > oldIndex) {
        i=newIndex;
        try {
          out.print(""String_Node_Str"");
          out.print(newIndex - oldIndex);
          out.println(""String_Node_Str"");
        }
 catch (        OutOfMemoryError e) {
          trigger.tallyOutOfMemoryError();
          if (out.isSysWrite()) {
            VM.sysWriteln(""String_Node_Str"");
          }
 else {
            VM.sysWriteln(""String_Node_Str"");
            VM.sysWriteln(""String_Node_Str"");
            throw e;
          }
        }
      }
    }
    try {
      if (cm == null) {
        out.println(""String_Node_Str"");
      }
 else {
        cm.printStackTrace(offsets[i],out);
      }
    }
 catch (    OutOfMemoryError e) {
      trigger.tallyOutOfMemoryError();
      if (out.isSysWrite()) {
        VM.sysWriteln(""String_Node_Str"");
      }
 else {
        try {
          out.flush();
          VM.sysWriteln();
        }
 catch (        OutOfMemoryError e2) {
          trigger.tallyOutOfMemoryError();
          VM.sysWriteln();
          VM.sysWriteln(""String_Node_Str"");
        }
        VM.sysWriteln(""String_Node_Str"");
        throw e;
      }
    }
  }
}",0.954574332909784
150182,"/** 
 * Create ""main"" thread. Taken: args[0]    = name of class containing ""main"" method args[1..N] = parameters to pass to ""main"" method
 */
MainThread(String args[]){
  super(args);
  this.args=args;
  this.vmdata.isMainThread=true;
  super.isSystemThread=false;
  if (dbg)   VM.sysWriteln(""String_Node_Str"",args.length,""String_Node_Str"");
}","/** 
 * Create ""main"" thread. Taken: args[0]    = name of class containing ""main"" method args[1..N] = parameters to pass to ""main"" method
 */
MainThread(String args[]){
  super(args);
  this.args=args;
  this.vmdata.isMainThread=true;
  this.vmdata.isSystemThread=false;
  if (dbg)   VM.sysWriteln(""String_Node_Str"",args.length,""String_Node_Str"");
}",0.976878612716763
150183,"/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC || IGNORE_REMSET) {
    threadLocalMaturePrepare(count);
    los.prepare();
    remset.resetLocal();
  }
 else   if (count == NON_PARTICIPANT)   flushRememberedSets();
}","/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC || IGNORE_REMSET) {
    threadLocalMaturePrepare(count);
    los.prepare();
    remset.resetLocal();
    arrayRemset.resetLocal();
  }
 else   if (count == NON_PARTICIPANT)   flushRememberedSets();
}",0.9755301794453508
150184,"/** 
 * Perform operations with <i>global</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>only one thread</i> executes this.<p> In this case, it means flipping semi-spaces, resetting the semi-space memory resource, and preparing each of the collectors.
 */
protected final void globalPrepare(){
  nurseryMR.reset();
  lastGCFull=fullHeapGC;
  if (fullHeapGC || IGNORE_REMSET) {
    if (fullHeapGC)     fullHeapTime.start();
    if (Stats.gatheringStats())     fullHeap.set();
    losSpace.prepare(losVM,losMR);
    globalMaturePrepare();
    ImmortalSpace.prepare(immortalVM,null);
    remsetPool.clearDeque(1);
  }
}","/** 
 * Perform operations with <i>global</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>only one thread</i> executes this.<p> In this case, it means flipping semi-spaces, resetting the semi-space memory resource, and preparing each of the collectors.
 */
protected final void globalPrepare(){
  nurseryMR.reset();
  lastGCFull=fullHeapGC;
  if (fullHeapGC || IGNORE_REMSET) {
    if (fullHeapGC)     fullHeapTime.start();
    if (Stats.gatheringStats())     fullHeap.set();
    losSpace.prepare(losVM,losMR);
    globalMaturePrepare();
    ImmortalSpace.prepare(immortalVM,null);
    remsetPool.clearDeque(1);
    arrayRemsetPool.clearDeque(2);
  }
}",0.974910394265233
150185,"/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC || IGNORE_REMSET) {
    threadLocalMaturePrepare(count);
    los.prepare();
    remset.resetLocal();
  }
 else   if (count == NON_PARTICIPANT)   flushRememberedSets();
}","/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC || IGNORE_REMSET) {
    threadLocalMaturePrepare(count);
    los.prepare();
    remset.resetLocal();
    arrayRemset.resetLocal();
  }
 else   if (count == NON_PARTICIPANT)   flushRememberedSets();
}",0.9755301794453508
150186,"/** 
 * Perform operations with <i>global</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>only one thread</i> executes this.<p> In this case, it means flipping semi-spaces, resetting the semi-space memory resource, and preparing each of the collectors.
 */
protected final void globalPrepare(){
  nurseryMR.reset();
  lastGCFull=fullHeapGC;
  if (fullHeapGC || IGNORE_REMSET) {
    if (fullHeapGC)     fullHeapTime.start();
    if (Stats.gatheringStats())     fullHeap.set();
    losSpace.prepare(losVM,losMR);
    globalMaturePrepare();
    ImmortalSpace.prepare(immortalVM,null);
    remsetPool.clearDeque(1);
  }
}","/** 
 * Perform operations with <i>global</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>only one thread</i> executes this.<p> In this case, it means flipping semi-spaces, resetting the semi-space memory resource, and preparing each of the collectors.
 */
protected final void globalPrepare(){
  nurseryMR.reset();
  lastGCFull=fullHeapGC;
  if (fullHeapGC || IGNORE_REMSET) {
    if (fullHeapGC)     fullHeapTime.start();
    if (Stats.gatheringStats())     fullHeap.set();
    losSpace.prepare(losVM,losMR);
    globalMaturePrepare();
    ImmortalSpace.prepare(immortalVM,null);
    remsetPool.clearDeque(1);
    arrayRemsetPool.clearDeque(2);
  }
}",0.974910394265233
150187,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address ref,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case NURSERY_SPACE:
    return;
case RC_SPACE:
  RefCountLocal.liveObject(ref);
case LOS_SPACE:
modBuffer.push(ref);
RefCountSpace.initializeHeader(ref,typeRef,true);
decBuffer.push(ref);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(ref);
return;
case IMMORTAL_SPACE:
if (RefCountSpace.RC_SANITY_CHECK) rc.addImmortalObject(ref);
modBuffer.push(ref);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address ref,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case NURSERY_SPACE:
    return;
case RC_SPACE:
  RefCountLocal.unsyncLiveObject(ref);
case LOS_SPACE:
modBuffer.push(ref);
RefCountSpace.initializeHeader(ref,typeRef,true);
decBuffer.push(ref);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(ref);
return;
case IMMORTAL_SPACE:
if (RefCountSpace.RC_SANITY_CHECK) rc.addImmortalObject(ref);
modBuffer.push(ref);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}",0.995656894679696
150188,"/** 
 * Perform any post-copy actions.  In this case nothing is required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(Address object,Address typeRef,int bytes) throws InlinePragma {
  CopySpace.clearGCBits(object);
  RefCountSpace.initializeHeader(object,typeRef,false);
  RefCountSpace.makeUnlogged(object);
  RefCountLocal.liveObject(object);
  if (RefCountSpace.RC_SANITY_CHECK) {
    RefCountLocal.sanityAllocCount(object);
  }
}","/** 
 * Perform any post-copy actions.  In this case nothing is required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(Address object,Address typeRef,int bytes) throws InlinePragma {
  CopySpace.clearGCBits(object);
  RefCountSpace.initializeHeader(object,typeRef,false);
  RefCountSpace.makeUnlogged(object);
  RefCountLocal.unsyncLiveObject(object);
  if (RefCountSpace.RC_SANITY_CHECK) {
    RefCountLocal.sanityAllocCount(object);
  }
}",0.9933333333333332
150189,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address object,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case RC_SPACE:
    RefCountLocal.liveObject(object);
case LOS_SPACE:
  if (WITH_COALESCING_RC)   modBuffer.pushOOL(object);
decBuffer.pushOOL(object);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(object);
RefCountSpace.initializeHeader(object,typeRef,true);
return;
case IMMORTAL_SPACE:
if (WITH_COALESCING_RC) modBuffer.pushOOL(object);
 else ImmortalSpace.postAlloc(object);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address object,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case RC_SPACE:
    RefCountLocal.unsyncLiveObject(object);
case LOS_SPACE:
  if (WITH_COALESCING_RC)   modBuffer.pushOOL(object);
decBuffer.pushOOL(object);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(object);
RefCountSpace.initializeHeader(object,typeRef,true);
return;
case IMMORTAL_SPACE:
if (WITH_COALESCING_RC) modBuffer.pushOOL(object);
 else ImmortalSpace.postAlloc(object);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}",0.9958027282266528
150190,"/** 
 * Set the live bit for a given object, without using synchronization primitives---must only be used when contention for live bit is strictly not possible
 * @param object The object whose live bit is to be set.
 */
protected static final void unsyncLiveObject(Address object) throws InlinePragma {
  liveAddress(ObjectModel.refToAddress(object),false);
}","/** 
 * Set the live bit for a given object, without using synchronization primitives---must only be used when contention for live bit is strictly not possible
 * @param object The object whose live bit is to be set.
 */
public static final void unsyncLiveObject(Address object) throws InlinePragma {
  liveAddress(ObjectModel.refToAddress(object),false);
}",0.9818688981868898
150191,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address ref,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case NURSERY_SPACE:
    return;
case RC_SPACE:
  RefCountLocal.liveObject(ref);
case LOS_SPACE:
modBuffer.push(ref);
RefCountSpace.initializeHeader(ref,typeRef,true);
decBuffer.push(ref);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(ref);
return;
case IMMORTAL_SPACE:
if (RefCountSpace.RC_SANITY_CHECK) rc.addImmortalObject(ref);
modBuffer.push(ref);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address ref,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case NURSERY_SPACE:
    return;
case RC_SPACE:
  RefCountLocal.unsyncLiveObject(ref);
case LOS_SPACE:
modBuffer.push(ref);
RefCountSpace.initializeHeader(ref,typeRef,true);
decBuffer.push(ref);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(ref);
return;
case IMMORTAL_SPACE:
if (RefCountSpace.RC_SANITY_CHECK) rc.addImmortalObject(ref);
modBuffer.push(ref);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}",0.995656894679696
150192,"/** 
 * Perform any post-copy actions.  In this case nothing is required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(Address object,Address typeRef,int bytes) throws InlinePragma {
  CopySpace.clearGCBits(object);
  RefCountSpace.initializeHeader(object,typeRef,false);
  RefCountSpace.makeUnlogged(object);
  RefCountLocal.liveObject(object);
  if (RefCountSpace.RC_SANITY_CHECK) {
    RefCountLocal.sanityAllocCount(object);
  }
}","/** 
 * Perform any post-copy actions.  In this case nothing is required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 */
public final void postCopy(Address object,Address typeRef,int bytes) throws InlinePragma {
  CopySpace.clearGCBits(object);
  RefCountSpace.initializeHeader(object,typeRef,false);
  RefCountSpace.makeUnlogged(object);
  RefCountLocal.unsyncLiveObject(object);
  if (RefCountSpace.RC_SANITY_CHECK) {
    RefCountLocal.sanityAllocCount(object);
  }
}",0.9933333333333332
150193,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address object,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case RC_SPACE:
    RefCountLocal.liveObject(object);
case LOS_SPACE:
  if (WITH_COALESCING_RC)   modBuffer.pushOOL(object);
decBuffer.pushOOL(object);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(object);
RefCountSpace.initializeHeader(object,typeRef,true);
return;
case IMMORTAL_SPACE:
if (WITH_COALESCING_RC) modBuffer.pushOOL(object);
 else ImmortalSpace.postAlloc(object);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param object The newly allocated object
 * @param typeRef the type reference for the instance being created
 * @param bytes The size of the space to be allocated (in bytes)
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(Address object,Address typeRef,int bytes,int allocator) throws InlinePragma {
switch (allocator) {
case RC_SPACE:
    RefCountLocal.unsyncLiveObject(object);
case LOS_SPACE:
  if (WITH_COALESCING_RC)   modBuffer.pushOOL(object);
decBuffer.pushOOL(object);
if (RefCountSpace.RC_SANITY_CHECK) RefCountLocal.sanityAllocCount(object);
RefCountSpace.initializeHeader(object,typeRef,true);
return;
case IMMORTAL_SPACE:
if (WITH_COALESCING_RC) modBuffer.pushOOL(object);
 else ImmortalSpace.postAlloc(object);
return;
default :
if (Assert.VERIFY_ASSERTIONS) Assert.fail(""String_Node_Str"");
return;
}
}",0.9958027282266528
150194,"/** 
 * Set the live bit for a given object, without using synchronization primitives---must only be used when contention for live bit is strictly not possible
 * @param object The object whose live bit is to be set.
 */
protected static final void unsyncLiveObject(Address object) throws InlinePragma {
  liveAddress(ObjectModel.refToAddress(object),false);
}","/** 
 * Set the live bit for a given object, without using synchronization primitives---must only be used when contention for live bit is strictly not possible
 * @param object The object whose live bit is to be set.
 */
public static final void unsyncLiveObject(Address object) throws InlinePragma {
  liveAddress(ObjectModel.refToAddress(object),false);
}",0.9818688981868898
150195,"private final void mutateTrapToCall(OPT_Instruction s,VM_Method target){
  int offset=target.getOffset();
  OPT_RegisterOperand tmp=regpool.makeTemp(VM_TypeReference.JavaLangObjectArray);
  OPT_Register JTOC=regpool.getPhysicalRegisterSet().getJTOC();
  OPT_MethodOperand meth=OPT_MethodOperand.STATIC(target);
  meth.setIsNonReturningCall(true);
  if (SI16(offset)) {
    EMIT(MIR_Load.create(PPC_LWZ,tmp,R(JTOC),I(offset)));
  }
 else {
    OPT_RegisterOperand tmp2=regpool.makeTempInt();
    IntConstant(tmp2.register,offset);
    EMIT(MIR_Load.create(PPC_LWZX,tmp,R(JTOC),tmp2));
  }
  EMIT(MIR_Move.create(PPC_MTSPR,R(CTR),tmp.copyD2U()));
  EMIT(MIR_Call.mutate0(s,PPC_BCTRL,null,null,meth));
}","private final void mutateTrapToCall(OPT_Instruction s,VM_Method target){
  int offset=target.getOffset();
  OPT_RegisterOperand tmp=regpool.makeTemp(VM_TypeReference.JavaLangObjectArray);
  OPT_Register JTOC=regpool.getPhysicalRegisterSet().getJTOC();
  OPT_MethodOperand meth=OPT_MethodOperand.STATIC(target);
  meth.setIsNonReturningCall(true);
  if (SI16(offset)) {
    EMIT(MIR_Load.create(PPC_LWZ,tmp,R(JTOC),I(offset)));
    EMIT(MIR_Load.create(PPC64_LD,tmp,L(JTOC),I(offset)));
  }
 else {
    OPT_RegisterOperand tmp2=regpool.makeTempInt();
    IntConstant(tmp2.register,offset);
    EMIT(MIR_Load.create(PPC_LWZX,tmp,R(JTOC),tmp2));
    EMIT(MIR_Load.create(PPC64_LDX,tmp,L(JTOC),tmp2));
  }
  EMIT(MIR_Move.create(PPC_MTSPR,R(CTR),tmp.copyD2U()));
  EMIT(MIR_Move.create(PPC_MTSPR,L(CTR),tmp.copyD2U()));
  EMIT(MIR_Call.mutate0(s,PPC_BCTRL,null,null,meth));
}",0.8911521323997453
150196,"/** 
 * Calling convention to implement calls to  native (C) routines using the AIX linkage conventions
 */
public static void expandSysCall(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand ip=null;
  OPT_RegisterOperand t1=OPT_ConvertToLowLevelIR.getStatic(s,ir,VM_Entrypoints.the_boot_recordField);
  OPT_RegisterOperand toc=OPT_ConvertToLowLevelIR.getField(s,ir,t1,VM_Entrypoints.sysTOCField);
  if (Call.getMethod(s) != null) {
    OPT_MethodOperand nat=Call.getClearMethod(s);
    VM_Field target=null;
    target=nat.getMemberRef().asFieldReference().resolve();
    ip=OPT_ConvertToLowLevelIR.getField(s,ir,t1.copyRO(),target);
  }
 else {
    ip=(OPT_RegisterOperand)Call.getClearAddress(s);
  }
  int numberParams=Call.getNumberOfParams(s);
  int parameterWords=0;
  for (int i=0; i < numberParams; i++) {
    parameterWords++;
    OPT_Operand op=Call.getParam(s,i);
    if (op instanceof OPT_RegisterOperand) {
      OPT_RegisterOperand reg=(OPT_RegisterOperand)op;
      if (reg.type.isLongType() || reg.type.isDoubleType())       parameterWords++;
    }
 else     if ((op instanceof OPT_LongConstantOperand) || (op instanceof OPT_DoubleConstantOperand))     parameterWords++;
  }
  int parameterWords=numberParams;
  ir.stackManager.allocateParameterSpace((6 + parameterWords) * BYTES_IN_ADDRESS);
  OPT_Instruction s2=Store.create(REF_STORE,ir.regpool.makeJTOCOp(ir,s),ir.regpool.makeFPOp(),I(20),null);
  s.insertBack(s2);
  s.insertBack(Move.create(REF_MOVE,ir.regpool.makeJTOCOp(ir,s),toc));
  Call.mutate0(s,SYSCALL,Call.getClearResult(s),ip,null);
  s2=Load.create(REF_LOAD,ir.regpool.makeJTOCOp(ir,s),ir.regpool.makeFPOp(),I(20),null);
  s.insertFront(s2);
  OPT_RegisterOperand temp=ir.regpool.makeTempInt();
  s2=Move.create(REF_MOVE,temp,I(ir.compiledMethod.getId()));
  OPT_RegisterOperand temp=ir.regpool.makeTempLong();
  s2=Move.create(REF_MOVE,temp,LC(ir.compiledMethod.getId()));
  OPT_Instruction s3=Store.create(REF_STORE,temp.copy(),ir.regpool.makeFPOp(),I(STACKFRAME_METHOD_ID_OFFSET),null);
  s.insertFront(s3);
  s.insertFront(s2);
}","/** 
 * Calling convention to implement calls to  native (C) routines using the AIX linkage conventions
 */
public static void expandSysCall(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand ip=null;
  OPT_RegisterOperand t1=OPT_ConvertToLowLevelIR.getStatic(s,ir,VM_Entrypoints.the_boot_recordField);
  OPT_RegisterOperand toc=OPT_ConvertToLowLevelIR.getField(s,ir,t1,VM_Entrypoints.sysTOCField);
  if (Call.getMethod(s) != null) {
    OPT_MethodOperand nat=Call.getClearMethod(s);
    VM_Field target=null;
    target=nat.getMemberRef().asFieldReference().resolve();
    ip=OPT_ConvertToLowLevelIR.getField(s,ir,t1.copyRO(),target);
  }
 else {
    ip=(OPT_RegisterOperand)Call.getClearAddress(s);
  }
  int numberParams=Call.getNumberOfParams(s);
  int parameterWords=0;
  for (int i=0; i < numberParams; i++) {
    parameterWords++;
    OPT_Operand op=Call.getParam(s,i);
    if (op instanceof OPT_RegisterOperand) {
      OPT_RegisterOperand reg=(OPT_RegisterOperand)op;
      if (reg.type.isLongType() || reg.type.isDoubleType())       parameterWords++;
    }
 else     if ((op instanceof OPT_LongConstantOperand) || (op instanceof OPT_DoubleConstantOperand))     parameterWords++;
  }
  int parameterWords=numberParams;
  ir.stackManager.allocateParameterSpace((6 + parameterWords) * BYTES_IN_ADDRESS);
  OPT_Instruction s2=Store.create(REF_STORE,ir.regpool.makeJTOCOp(ir,s),ir.regpool.makeFPOp(),I(5 * BYTES_IN_ADDRESS),null);
  s.insertBack(s2);
  s.insertBack(Move.create(REF_MOVE,ir.regpool.makeJTOCOp(ir,s),toc));
  Call.mutate0(s,SYSCALL,Call.getClearResult(s),ip,null);
  s2=Load.create(REF_LOAD,ir.regpool.makeJTOCOp(ir,s),ir.regpool.makeFPOp(),I(5 * BYTES_IN_ADDRESS),null);
  s.insertFront(s2);
  OPT_RegisterOperand temp=ir.regpool.makeTempInt();
  s2=Move.create(INT_MOVE,temp,I(ir.compiledMethod.getId()));
  OPT_Instruction s3=Store.create(INT_STORE,temp.copy(),ir.regpool.makeFPOp(),I(STACKFRAME_METHOD_ID_OFFSET),null);
  s.insertFront(s3);
  s.insertFront(s2);
}",0.9573576534385012
150197,"/** 
 * Expand an instanceof instruction into the LIR sequence that implements  the dynamic type check.  Ref is known to never contain a null ptr at  runtime.
 * @param s an INSTANCEOF_NOTNULL instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction instanceOfNotNull(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand result=InstanceOf.getClearResult(s);
  VM_TypeReference LHStype=InstanceOf.getType(s).getTypeRef();
  OPT_Operand ref=InstanceOf.getClearRef(s);
  OPT_Operand guard=InstanceOf.getClearGuard(s);
  OPT_Instruction next=s.nextInstructionInCodeOrder();
  if (next.operator() == INT_IFCMP && IfCmp.getVal1(next) instanceof OPT_RegisterOperand && result.similar(IfCmp.getVal1(next))) {
    OPT_Operand val2=IfCmp.getVal2(next);
    if (VM.VerifyAssertions)     VM._assert(val2.isIntConstant());
    int ival2=((OPT_IntConstantOperand)val2).value;
    OPT_ConditionOperand cond=IfCmp.getCond(next);
    boolean branchCondition=(((ival2 == 0) && (cond.isNOT_EQUAL() || cond.isLESS_EQUAL())) || ((ival2 == 1) && (cond.isEQUAL() || cond.isGREATER_EQUAL())));
    OPT_BasicBlock branchBB=next.getBranchTarget();
    OPT_RegisterOperand oldGuard=IfCmp.getGuardResult(next);
    next.remove();
    OPT_BasicBlock fallThroughBB=fallThroughBB(s,ir);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    if (branchCondition) {
      return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,branchBB,fallThroughBB,oldGuard);
    }
 else {
      return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,fallThroughBB,branchBB,oldGuard);
    }
  }
 else {
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    return generateValueProducingTypeCheck(s,ir,ref,LHStype,RHStib,result);
  }
}","/** 
 * Expand an instanceof instruction into the LIR sequence that implements  the dynamic type check.  Ref is known to never contain a null ptr at  runtime.
 * @param s an INSTANCEOF_NOTNULL instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction instanceOfNotNull(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand result=InstanceOf.getClearResult(s);
  VM_TypeReference LHStype=InstanceOf.getType(s).getTypeRef();
  OPT_Operand ref=InstanceOf.getClearRef(s);
  OPT_Operand guard=InstanceOf.getClearGuard(s);
  OPT_Instruction next=s.nextInstructionInCodeOrder();
  if (next.operator() == INT_IFCMP && IfCmp.getVal1(next) instanceof OPT_RegisterOperand && result.similar(IfCmp.getVal1(next))) {
    OPT_Operand val2=IfCmp.getVal2(next);
    if (VM.VerifyAssertions)     VM._assert(val2.isIntConstant());
    int ival2=((OPT_IntConstantOperand)val2).value;
    OPT_ConditionOperand cond=IfCmp.getCond(next);
    boolean branchCondition=(((ival2 == 0) && (cond.isNOT_EQUAL() || cond.isLESS_EQUAL())) || ((ival2 == 1) && (cond.isEQUAL() || cond.isGREATER_EQUAL())));
    OPT_BasicBlock branchBB=next.getBranchTarget();
    OPT_RegisterOperand oldGuard=IfCmp.getGuardResult(next);
    next.remove();
    OPT_BasicBlock fallThroughBB=fallThroughBB(s,ir);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    if (branchCondition) {
      return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,branchBB,fallThroughBB,oldGuard,IfCmp.getClearBranchProfile(next).flip());
    }
 else {
      return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,fallThroughBB,branchBB,oldGuard,IfCmp.getClearBranchProfile(next));
    }
  }
 else {
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
    return generateValueProducingTypeCheck(s,ir,ref,LHStype,RHStib,result);
  }
}",0.9795361527967258
150198,"/** 
 * Generate wrapper around branching type check to get a  value producing type check. 
 * @param s        The OPT_Instruction that is to be replaced by a value producing type check
 * @param ir       The OPT_IR containing the instruction to be expanded.
 * @param RHSobj   The OPT_RegisterOperand containing the rhs object.
 * @param LHStype  The VM_TypeReference to be tested against.
 * @param RHStib   The OPT_RegisterOperand containing the TIB of the rhs.
 * @param result   The OPT_RegisterOperand that the result of dynamic 
 * @return the opt instruction immediately before the instruction to continue expansion.
 */
private static OPT_Instruction convertToBranchingTypeCheck(OPT_Instruction s,OPT_IR ir,OPT_Operand RHSobj,VM_TypeReference LHStype,OPT_RegisterOperand RHStib,OPT_RegisterOperand result){
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock contBlock=myBlock.splitNodeAt(s,ir);
  OPT_BasicBlock trueBlock=myBlock.createSubBlock(s.bcIndex,ir);
  OPT_BasicBlock falseBlock=myBlock.createSubBlock(s.bcIndex,ir);
  myBlock.insertOut(trueBlock);
  myBlock.insertOut(falseBlock);
  trueBlock.insertOut(contBlock);
  falseBlock.insertOut(contBlock);
  ir.cfg.linkInCodeOrder(myBlock,trueBlock);
  ir.cfg.linkInCodeOrder(trueBlock,falseBlock);
  ir.cfg.linkInCodeOrder(falseBlock,contBlock);
  trueBlock.appendInstruction(Move.create(INT_MOVE,result,I(1)));
  trueBlock.appendInstruction(Goto.create(GOTO,contBlock.makeJumpTarget()));
  falseBlock.appendInstruction(Move.create(INT_MOVE,result.copyD2D(),I(0)));
  return generateBranchingTypeCheck(s,ir,RHSobj,LHStype,RHStib,trueBlock,falseBlock,null);
}","/** 
 * Generate wrapper around branching type check to get a  value producing type check. 
 * @param s        The OPT_Instruction that is to be replaced by a value producing type check
 * @param ir       The OPT_IR containing the instruction to be expanded.
 * @param RHSobj   The OPT_RegisterOperand containing the rhs object.
 * @param LHStype  The VM_TypeReference to be tested against.
 * @param RHStib   The OPT_RegisterOperand containing the TIB of the rhs.
 * @param result   The OPT_RegisterOperand that the result of dynamic 
 * @return the opt instruction immediately before the instruction to continue expansion.
 */
private static OPT_Instruction convertToBranchingTypeCheck(OPT_Instruction s,OPT_IR ir,OPT_Operand RHSobj,VM_TypeReference LHStype,OPT_RegisterOperand RHStib,OPT_RegisterOperand result){
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock contBlock=myBlock.splitNodeAt(s,ir);
  OPT_BasicBlock trueBlock=myBlock.createSubBlock(s.bcIndex,ir);
  OPT_BasicBlock falseBlock=myBlock.createSubBlock(s.bcIndex,ir);
  myBlock.insertOut(trueBlock);
  myBlock.insertOut(falseBlock);
  trueBlock.insertOut(contBlock);
  falseBlock.insertOut(contBlock);
  ir.cfg.linkInCodeOrder(myBlock,trueBlock);
  ir.cfg.linkInCodeOrder(trueBlock,falseBlock);
  ir.cfg.linkInCodeOrder(falseBlock,contBlock);
  trueBlock.appendInstruction(Move.create(INT_MOVE,result,I(1)));
  trueBlock.appendInstruction(Goto.create(GOTO,contBlock.makeJumpTarget()));
  falseBlock.appendInstruction(Move.create(INT_MOVE,result.copyD2D(),I(0)));
  return generateBranchingTypeCheck(s,ir,RHSobj,LHStype,RHStib,trueBlock,falseBlock,null,new OPT_BranchProfileOperand());
}",0.9905918057663126
150199,"/** 
 * Expand a checkcast instruction into the LIR sequence that implements the  dynamic type check, raising a ClassCastException when the type check  fails. Ref is known to never contain a null ptr at runtime.
 * @param s a CHECKCAST_NOTNULL instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction checkcastNotNull(OPT_Instruction s,OPT_IR ir){
  OPT_Operand ref=TypeCheck.getClearRef(s);
  VM_TypeReference LHStype=TypeCheck.getType(s).getTypeRef();
  OPT_Operand guard=TypeCheck.getClearGuard(s);
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock failBlock=myBlock.createSubBlock(s.bcIndex,ir,.0001f);
  OPT_BasicBlock succBlock=myBlock.splitNodeAt(s,ir);
  myBlock.insertOut(failBlock);
  myBlock.insertOut(succBlock);
  ir.cfg.linkInCodeOrder(myBlock,succBlock);
  ir.cfg.addLastInCodeOrder(failBlock);
  OPT_Instruction raiseError=Trap.create(TRAP,null,OPT_TrapCodeOperand.CheckCast());
  raiseError.copyPosition(s);
  failBlock.appendInstruction(raiseError);
  OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
  return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,succBlock,failBlock,null);
}","/** 
 * Expand a checkcast instruction into the LIR sequence that implements the  dynamic type check, raising a ClassCastException when the type check  fails. Ref is known to never contain a null ptr at runtime.
 * @param s a CHECKCAST_NOTNULL instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction checkcastNotNull(OPT_Instruction s,OPT_IR ir){
  OPT_Operand ref=TypeCheck.getClearRef(s);
  VM_TypeReference LHStype=TypeCheck.getType(s).getTypeRef();
  OPT_Operand guard=TypeCheck.getClearGuard(s);
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock failBlock=myBlock.createSubBlock(s.bcIndex,ir,.0001f);
  OPT_BasicBlock succBlock=myBlock.splitNodeAt(s,ir);
  myBlock.insertOut(failBlock);
  myBlock.insertOut(succBlock);
  ir.cfg.linkInCodeOrder(myBlock,succBlock);
  ir.cfg.addLastInCodeOrder(failBlock);
  OPT_Instruction raiseError=Trap.create(TRAP,null,OPT_TrapCodeOperand.CheckCast());
  raiseError.copyPosition(s);
  failBlock.appendInstruction(raiseError);
  OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard);
  return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,succBlock,failBlock,null,OPT_BranchProfileOperand.never());
}",0.986590816741162
150200,"/** 
 * Generate a branching dynamic type check. This routine assumes that the CFG and code order are already  correctly established. This routine must either remove s or mutuate it. 
 * @param s          The OPT_Instruction that is to be replaced by a branching type check
 * @param ir         The OPT_IR containing the instruction to be expanded.
 * @param RHSobj     The OPT_RegisterOperand containing the rhs object.
 * @param LHStype    The VM_TypeReference to be tested against.
 * @param RHStib     The OPT_RegisterOperand containing the TIB of the rhs.
 * @param trueBlock  The OPT_BasicBlock to continue at if the typecheck evaluates to true
 * @param falseBlock The OPT_BasicBlock to continue at if the typecheck evaluates to false.
 * @return the opt instruction immediately before the instruction to continue expansion.
 */
private static OPT_Instruction generateBranchingTypeCheck(OPT_Instruction s,OPT_IR ir,OPT_Operand RHSobj,VM_TypeReference LHStype,OPT_RegisterOperand RHStib,OPT_BasicBlock trueBlock,OPT_BasicBlock falseBlock,OPT_RegisterOperand oldGuard){
  OPT_Instruction continueAt=Goto.create(GOTO,trueBlock.makeJumpTarget());
  continueAt.copyPosition(s);
  s.insertBefore(continueAt);
  s.remove();
  if (LHStype.isClassType()) {
    VM_Class LHSclass=(VM_Class)LHStype.peekResolvedType();
    if (LHSclass != null && LHSclass.isResolved()) {
      if (LHSclass.isInterface()) {
        int interfaceIndex=LHSclass.getDoesImplementIndex();
        int interfaceMask=LHSclass.getDoesImplementBitMask();
        OPT_RegisterOperand doesImpl=InsertUnary(continueAt,ir,GET_DOES_IMPLEMENT_FROM_TIB,VM_TypeReference.IntArray,RHStib);
        if (VM_DynamicTypeCheck.MIN_DOES_IMPLEMENT_SIZE <= interfaceIndex) {
          OPT_RegisterOperand doesImplLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,doesImpl.copyD2U(),TG());
          OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,doesImplLength,I(interfaceIndex),OPT_ConditionOperand.LESS_EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
          continueAt.insertBefore(lengthCheck);
          OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
          oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
          oldBlock.insertOut(falseBlock);
        }
        OPT_RegisterOperand entry=InsertLoadOffset(continueAt,ir,INT_LOAD,VM_TypeReference.Int,doesImpl,interfaceIndex << 2,new OPT_LocationOperand(VM_TypeReference.Int),TG());
        OPT_RegisterOperand bit=InsertBinary(continueAt,ir,INT_AND,VM_TypeReference.Int,entry,I(interfaceMask));
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,bit,I(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
        return continueAt;
      }
 else {
        if (LHSclass.isFinal()) {
          OPT_Operand classTIB=getTIB(continueAt,ir,LHSclass);
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
          return continueAt;
        }
 else {
          int LHSDepth=LHSclass.getTypeDepth();
          int LHSId=LHSclass.getId();
          OPT_RegisterOperand superclassIds=InsertUnary(continueAt,ir,GET_SUPERCLASS_IDS_FROM_TIB,VM_TypeReference.ShortArray,RHStib);
          if (VM_DynamicTypeCheck.MIN_SUPERCLASS_IDS_SIZE <= LHSDepth) {
            OPT_RegisterOperand superclassIdsLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,superclassIds.copyD2U(),TG());
            OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,superclassIdsLength,I(LHSDepth),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
            continueAt.insertBefore(lengthCheck);
            OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
            oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
            oldBlock.insertOut(falseBlock);
          }
          OPT_RegisterOperand refCandidate=InsertLoadOffset(continueAt,ir,USHORT_LOAD,VM_TypeReference.Short,superclassIds,LHSDepth << 1,new OPT_LocationOperand(VM_TypeReference.Short),TG());
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,refCandidate,I(LHSId),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
          return continueAt;
        }
      }
    }
 else {
      OPT_RegisterOperand result=ir.regpool.makeTempInt();
      VM_Method target=VM_Entrypoints.instanceOfMethod;
      OPT_Instruction call=Call.create2(CALL,result,I(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,I(LHStype.getId()));
      call.copyPosition(continueAt);
      continueAt.insertBefore(call);
      call=callHelper(call,ir);
      continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,result.copyD2U(),I(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
      return continueAt;
    }
  }
  if (LHStype.isArrayType()) {
    VM_Array LHSArray=(VM_Array)LHStype.peekResolvedType();
    if (LHSArray != null) {
      OPT_Operand classTIB=getTIB(continueAt,ir,LHSArray);
      VM_Type innermostElementType=LHSArray.getInnermostElementType();
      if (innermostElementType.isPrimitiveType() || (innermostElementType.asClass().isResolved() && innermostElementType.asClass().isFinal())) {
        continueAt.insertBefore(IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
        return continueAt;
      }
      OPT_Instruction shortcircuit=IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.EQUAL(),trueBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
      continueAt.insertBefore(shortcircuit);
      OPT_BasicBlock myBlock=shortcircuit.getBasicBlock();
      OPT_BasicBlock mainBlock=myBlock.splitNodeWithLinksAt(shortcircuit,ir);
      myBlock.insertOut(trueBlock);
      OPT_RegisterOperand rhsType=InsertUnary(continueAt,ir,GET_TYPE_FROM_TIB,VM_TypeReference.VM_Type,RHStib.copyD2U());
      if (innermostElementType.isJavaLangObjectType()) {
        OPT_IntConstantOperand lhsDimension=I(LHStype.getDimensionality());
        OPT_RegisterOperand rhsDimension=getField(continueAt,ir,rhsType,VM_Entrypoints.dimensionField);
        OPT_Instruction dimTest=IfCmp2.create(INT_IFCMP2,oldGuard,rhsDimension,lhsDimension,OPT_ConditionOperand.GREATER(),trueBlock.makeJumpTarget(),new OPT_BranchProfileOperand(),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
        continueAt.insertBefore(dimTest);
        OPT_BasicBlock testBlock=mainBlock.splitNodeWithLinksAt(dimTest,ir);
        mainBlock.insertOut(trueBlock);
        mainBlock.insertOut(falseBlock);
        OPT_RegisterOperand rhsInnermostElementType=getField(continueAt,ir,rhsType.copyU2U(),VM_Entrypoints.innermostElementTypeField);
        OPT_RegisterOperand rhsInnermostElementTypeDimension=getField(continueAt,ir,rhsInnermostElementType,VM_Entrypoints.dimensionField);
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,rhsInnermostElementTypeDimension,I(0),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
        return continueAt;
      }
    }
    VM_Method target=VM_Entrypoints.instanceOfMethod;
    OPT_RegisterOperand callResult=ir.regpool.makeTempInt();
    OPT_Instruction call=Call.create2(CALL,callResult,I(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,I(LHStype.getId()));
    call.copyPosition(continueAt);
    continueAt.insertBefore(call);
    call=callHelper(call,ir);
    continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,callResult.copyD2U(),I(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),new OPT_BranchProfileOperand()));
    return continueAt;
  }
  OPT_OptimizingCompilerException.UNREACHABLE();
  return null;
}","/** 
 * Generate a branching dynamic type check. This routine assumes that the CFG and code order are already  correctly established. This routine must either remove s or mutuate it. 
 * @param s          The OPT_Instruction that is to be replaced by a branching type check
 * @param ir         The OPT_IR containing the instruction to be expanded.
 * @param RHSobj     The OPT_RegisterOperand containing the rhs object.
 * @param LHStype    The VM_TypeReference to be tested against.
 * @param RHStib     The OPT_RegisterOperand containing the TIB of the rhs.
 * @param trueBlock  The OPT_BasicBlock to continue at if the typecheck evaluates to true
 * @param falseBlock The OPT_BasicBlock to continue at if the typecheck evaluates to false.
 * @param falseProb   The probability that typecheck will branch to the falseBlock
 * @return the opt instruction immediately before the instruction to continue expansion.
 */
private static OPT_Instruction generateBranchingTypeCheck(OPT_Instruction s,OPT_IR ir,OPT_Operand RHSobj,VM_TypeReference LHStype,OPT_RegisterOperand RHStib,OPT_BasicBlock trueBlock,OPT_BasicBlock falseBlock,OPT_RegisterOperand oldGuard,OPT_BranchProfileOperand falseProb){
  OPT_Instruction continueAt=Goto.create(GOTO,trueBlock.makeJumpTarget());
  continueAt.copyPosition(s);
  s.insertBefore(continueAt);
  s.remove();
  if (LHStype.isClassType()) {
    VM_Class LHSclass=(VM_Class)LHStype.peekResolvedType();
    if (LHSclass != null && LHSclass.isResolved()) {
      if (LHSclass.isInterface()) {
        int interfaceIndex=LHSclass.getDoesImplementIndex();
        int interfaceMask=LHSclass.getDoesImplementBitMask();
        OPT_RegisterOperand doesImpl=InsertUnary(continueAt,ir,GET_DOES_IMPLEMENT_FROM_TIB,VM_TypeReference.IntArray,RHStib);
        if (VM_DynamicTypeCheck.MIN_DOES_IMPLEMENT_SIZE <= interfaceIndex) {
          OPT_RegisterOperand doesImplLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,doesImpl.copyD2U(),TG());
          OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,doesImplLength,I(interfaceIndex),OPT_ConditionOperand.LESS_EQUAL(),falseBlock.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
          continueAt.insertBefore(lengthCheck);
          OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
          oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
          oldBlock.insertOut(falseBlock);
        }
        OPT_RegisterOperand entry=InsertLoadOffset(continueAt,ir,INT_LOAD,VM_TypeReference.Int,doesImpl,interfaceIndex << 2,new OPT_LocationOperand(VM_TypeReference.Int),TG());
        OPT_RegisterOperand bit=InsertBinary(continueAt,ir,INT_AND,VM_TypeReference.Int,entry,I(interfaceMask));
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,bit,I(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
 else {
        if (LHSclass.isFinal()) {
          OPT_Operand classTIB=getTIB(continueAt,ir,LHSclass);
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
          return continueAt;
        }
 else {
          int LHSDepth=LHSclass.getTypeDepth();
          int LHSId=LHSclass.getId();
          OPT_RegisterOperand superclassIds=InsertUnary(continueAt,ir,GET_SUPERCLASS_IDS_FROM_TIB,VM_TypeReference.ShortArray,RHStib);
          if (VM_DynamicTypeCheck.MIN_SUPERCLASS_IDS_SIZE <= LHSDepth) {
            OPT_RegisterOperand superclassIdsLength=InsertGuardedUnary(continueAt,ir,ARRAYLENGTH,VM_TypeReference.Int,superclassIds.copyD2U(),TG());
            OPT_Instruction lengthCheck=IfCmp.create(INT_IFCMP,oldGuard,superclassIdsLength,I(LHSDepth),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
            continueAt.insertBefore(lengthCheck);
            OPT_BasicBlock oldBlock=continueAt.getBasicBlock();
            oldBlock.splitNodeWithLinksAt(lengthCheck,ir);
            oldBlock.insertOut(falseBlock);
          }
          OPT_RegisterOperand refCandidate=InsertLoadOffset(continueAt,ir,USHORT_LOAD,VM_TypeReference.Short,superclassIds,LHSDepth << 1,new OPT_LocationOperand(VM_TypeReference.Short),TG());
          continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,refCandidate,I(LHSId),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
          return continueAt;
        }
      }
    }
 else {
      OPT_RegisterOperand result=ir.regpool.makeTempInt();
      VM_Method target=VM_Entrypoints.instanceOfMethod;
      OPT_Instruction call=Call.create2(CALL,result,I(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,I(LHStype.getId()));
      call.copyPosition(continueAt);
      continueAt.insertBefore(call);
      call=callHelper(call,ir);
      continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,result.copyD2U(),I(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
      return continueAt;
    }
  }
  if (LHStype.isArrayType()) {
    VM_Array LHSArray=(VM_Array)LHStype.peekResolvedType();
    if (LHSArray != null) {
      OPT_Operand classTIB=getTIB(continueAt,ir,LHSArray);
      VM_Type innermostElementType=LHSArray.getInnermostElementType();
      if (innermostElementType.isPrimitiveType() || (innermostElementType.asClass().isResolved() && innermostElementType.asClass().isFinal())) {
        continueAt.insertBefore(IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
      OPT_Instruction shortcircuit=IfCmp.create(REF_IFCMP,oldGuard,RHStib,classTIB,OPT_ConditionOperand.EQUAL(),trueBlock.makeJumpTarget(),new OPT_BranchProfileOperand());
      continueAt.insertBefore(shortcircuit);
      OPT_BasicBlock myBlock=shortcircuit.getBasicBlock();
      OPT_BasicBlock mainBlock=myBlock.splitNodeWithLinksAt(shortcircuit,ir);
      myBlock.insertOut(trueBlock);
      OPT_RegisterOperand rhsType=InsertUnary(continueAt,ir,GET_TYPE_FROM_TIB,VM_TypeReference.VM_Type,RHStib.copyD2U());
      if (innermostElementType.isJavaLangObjectType()) {
        OPT_IntConstantOperand lhsDimension=I(LHStype.getDimensionality());
        OPT_RegisterOperand rhsDimension=getField(continueAt,ir,rhsType,VM_Entrypoints.dimensionField);
        OPT_Instruction dimTest=IfCmp2.create(INT_IFCMP2,oldGuard,rhsDimension,lhsDimension,OPT_ConditionOperand.GREATER(),trueBlock.makeJumpTarget(),((OPT_BranchProfileOperand)falseProb.copy()).flip(),OPT_ConditionOperand.LESS(),falseBlock.makeJumpTarget(),falseProb);
        continueAt.insertBefore(dimTest);
        OPT_BasicBlock testBlock=mainBlock.splitNodeWithLinksAt(dimTest,ir);
        mainBlock.insertOut(trueBlock);
        mainBlock.insertOut(falseBlock);
        OPT_RegisterOperand rhsInnermostElementType=getField(continueAt,ir,rhsType.copyU2U(),VM_Entrypoints.innermostElementTypeField);
        OPT_RegisterOperand rhsInnermostElementTypeDimension=getField(continueAt,ir,rhsInnermostElementType,VM_Entrypoints.dimensionField);
        continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,rhsInnermostElementTypeDimension,I(0),OPT_ConditionOperand.NOT_EQUAL(),falseBlock.makeJumpTarget(),falseProb));
        return continueAt;
      }
    }
    VM_Method target=VM_Entrypoints.instanceOfMethod;
    OPT_RegisterOperand callResult=ir.regpool.makeTempInt();
    OPT_Instruction call=Call.create2(CALL,callResult,I(target.getOffset()),OPT_MethodOperand.STATIC(target),RHSobj,I(LHStype.getId()));
    call.copyPosition(continueAt);
    continueAt.insertBefore(call);
    call=callHelper(call,ir);
    continueAt.insertBefore(IfCmp.create(INT_IFCMP,oldGuard,callResult.copyD2U(),I(0),OPT_ConditionOperand.EQUAL(),falseBlock.makeJumpTarget(),falseProb));
    return continueAt;
  }
  OPT_OptimizingCompilerException.UNREACHABLE();
  return null;
}",0.9602778654878432
150201,"/** 
 * Expand an instanceof instruction into the LIR sequence that implements the dynamic type check.  Ref may contain a null ptr at runtime.
 * @param s an INSTANCEOF or INSTANCEOF_UNRESOLVED instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction instanceOf(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand result=InstanceOf.getClearResult(s);
  VM_TypeReference LHStype=InstanceOf.getType(s).getTypeRef();
  OPT_Operand ref=InstanceOf.getClearRef(s);
  OPT_Instruction next=s.nextInstructionInCodeOrder();
  if (next.operator() == INT_IFCMP && IfCmp.getVal1(next) instanceof OPT_RegisterOperand && result.similar(IfCmp.getVal1(next))) {
    OPT_Operand val2=IfCmp.getVal2(next);
    if (VM.VerifyAssertions)     VM._assert(val2.isIntConstant());
    int ival2=((OPT_IntConstantOperand)val2).value;
    OPT_ConditionOperand cond=IfCmp.getCond(next);
    boolean branchCondition=(((ival2 == 0) && (cond.isNOT_EQUAL() || cond.isLESS_EQUAL())) || ((ival2 == 1) && (cond.isEQUAL() || cond.isGREATER_EQUAL())));
    OPT_BasicBlock branchBB=next.getBranchTarget();
    OPT_RegisterOperand oldGuard=IfCmp.getGuardResult(next);
    next.remove();
    OPT_BasicBlock fallThroughBB=fallThroughBB(s,ir);
    OPT_BasicBlock falseBranch=branchCondition ? fallThroughBB : branchBB;
    OPT_BasicBlock trueBranch=branchCondition ? branchBB : fallThroughBB;
    OPT_Instruction nullComp=IfCmp.create(REF_IFCMP,oldGuard.copyRO(),ref.copy(),new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),falseBranch.makeJumpTarget(),new OPT_BranchProfileOperand());
    s.insertBefore(nullComp);
    OPT_BasicBlock myBlock=s.getBasicBlock();
    OPT_BasicBlock instanceOfBlock=myBlock.splitNodeAt(nullComp,ir);
    myBlock.insertOut(instanceOfBlock);
    myBlock.insertOut(falseBranch);
    ir.cfg.linkInCodeOrder(myBlock,instanceOfBlock);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,oldGuard.copyRO());
    return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,trueBranch,falseBranch,oldGuard);
  }
 else {
    OPT_RegisterOperand guard=ir.regpool.makeTempValidation();
    OPT_BasicBlock instanceOfBlock=s.getBasicBlock().segregateInstruction(s,ir);
    OPT_BasicBlock prevBB=instanceOfBlock.prevBasicBlockInCodeOrder();
    OPT_BasicBlock nextBB=instanceOfBlock.nextBasicBlockInCodeOrder();
    OPT_BasicBlock nullCaseBB=instanceOfBlock.createSubBlock(s.bcIndex,ir,.01f);
    prevBB.appendInstruction(IfCmp.create(REF_IFCMP,guard,ref.copy(),new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),nullCaseBB.makeJumpTarget(),OPT_BranchProfileOperand.unlikely()));
    nullCaseBB.appendInstruction(Move.create(INT_MOVE,result.copyD2D(),I(0)));
    nullCaseBB.appendInstruction(Goto.create(GOTO,nextBB.makeJumpTarget()));
    prevBB.insertOut(nullCaseBB);
    nullCaseBB.insertOut(nextBB);
    ir.cfg.addLastInCodeOrder(nullCaseBB);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard.copyD2U());
    return generateValueProducingTypeCheck(s,ir,ref,LHStype,RHStib,result);
  }
}","/** 
 * Expand an instanceof instruction into the LIR sequence that implements the dynamic type check.  Ref may contain a null ptr at runtime.
 * @param s an INSTANCEOF or INSTANCEOF_UNRESOLVED instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction instanceOf(OPT_Instruction s,OPT_IR ir){
  OPT_RegisterOperand result=InstanceOf.getClearResult(s);
  VM_TypeReference LHStype=InstanceOf.getType(s).getTypeRef();
  OPT_Operand ref=InstanceOf.getClearRef(s);
  OPT_Instruction next=s.nextInstructionInCodeOrder();
  if (next.operator() == INT_IFCMP && IfCmp.getVal1(next) instanceof OPT_RegisterOperand && result.similar(IfCmp.getVal1(next))) {
    OPT_Operand val2=IfCmp.getVal2(next);
    if (VM.VerifyAssertions)     VM._assert(val2.isIntConstant());
    int ival2=((OPT_IntConstantOperand)val2).value;
    OPT_ConditionOperand cond=IfCmp.getCond(next);
    boolean branchCondition=(((ival2 == 0) && (cond.isNOT_EQUAL() || cond.isLESS_EQUAL())) || ((ival2 == 1) && (cond.isEQUAL() || cond.isGREATER_EQUAL())));
    OPT_BasicBlock branchBB=next.getBranchTarget();
    OPT_RegisterOperand oldGuard=IfCmp.getGuardResult(next);
    next.remove();
    OPT_BasicBlock fallThroughBB=fallThroughBB(s,ir);
    OPT_BasicBlock falseBranch=branchCondition ? fallThroughBB : branchBB;
    OPT_BasicBlock trueBranch=branchCondition ? branchBB : fallThroughBB;
    OPT_BranchProfileOperand bp=IfCmp.getClearBranchProfile(next);
    if (branchCondition)     bp=bp.flip();
    OPT_Instruction nullComp=IfCmp.create(REF_IFCMP,oldGuard.copyRO(),ref.copy(),new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),falseBranch.makeJumpTarget(),OPT_BranchProfileOperand.unlikely());
    s.insertBefore(nullComp);
    OPT_BasicBlock myBlock=s.getBasicBlock();
    OPT_BasicBlock instanceOfBlock=myBlock.splitNodeAt(nullComp,ir);
    myBlock.insertOut(instanceOfBlock);
    myBlock.insertOut(falseBranch);
    ir.cfg.linkInCodeOrder(myBlock,instanceOfBlock);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,oldGuard.copyRO());
    return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,trueBranch,falseBranch,oldGuard,bp);
  }
 else {
    OPT_RegisterOperand guard=ir.regpool.makeTempValidation();
    OPT_BasicBlock instanceOfBlock=s.getBasicBlock().segregateInstruction(s,ir);
    OPT_BasicBlock prevBB=instanceOfBlock.prevBasicBlockInCodeOrder();
    OPT_BasicBlock nextBB=instanceOfBlock.nextBasicBlockInCodeOrder();
    OPT_BasicBlock nullCaseBB=instanceOfBlock.createSubBlock(s.bcIndex,ir,.01f);
    prevBB.appendInstruction(IfCmp.create(REF_IFCMP,guard,ref.copy(),new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),nullCaseBB.makeJumpTarget(),OPT_BranchProfileOperand.unlikely()));
    nullCaseBB.appendInstruction(Move.create(INT_MOVE,result.copyD2D(),I(0)));
    nullCaseBB.appendInstruction(Goto.create(GOTO,nextBB.makeJumpTarget()));
    prevBB.insertOut(nullCaseBB);
    nullCaseBB.insertOut(nextBB);
    ir.cfg.addLastInCodeOrder(nullCaseBB);
    OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard.copyD2U());
    return generateValueProducingTypeCheck(s,ir,ref,LHStype,RHStib,result);
  }
}",0.9721867007672634
150202,"/** 
 * Expand a checkcast instruction into the LIR sequence that implements the  dynamic type check, raising a ClassCastException when the type check  fails. Ref may contain a null ptr at runtime.
 * @param s a CHECKCAST or CHECKCAST_UNRESOLVED instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction checkcast(OPT_Instruction s,OPT_IR ir){
  OPT_Operand ref=TypeCheck.getClearRef(s);
  VM_TypeReference LHStype=TypeCheck.getType(s).getTypeRef();
  OPT_RegisterOperand guard=ir.regpool.makeTempValidation();
  OPT_Instruction nullCond=IfCmp.create(REF_IFCMP,guard,ref.copy(),new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),null,new OPT_BranchProfileOperand());
  s.insertBefore(nullCond);
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock failBlock=myBlock.createSubBlock(s.bcIndex,ir,.0001f);
  OPT_BasicBlock instanceOfBlock=myBlock.splitNodeAt(nullCond,ir);
  OPT_BasicBlock succBlock=instanceOfBlock.splitNodeAt(s,ir);
  IfCmp.setTarget(nullCond,succBlock.makeJumpTarget());
  myBlock.insertOut(instanceOfBlock);
  myBlock.insertOut(succBlock);
  instanceOfBlock.insertOut(failBlock);
  instanceOfBlock.insertOut(succBlock);
  ir.cfg.linkInCodeOrder(myBlock,instanceOfBlock);
  ir.cfg.linkInCodeOrder(instanceOfBlock,succBlock);
  ir.cfg.addLastInCodeOrder(failBlock);
  OPT_Instruction raiseError=Trap.create(TRAP,null,OPT_TrapCodeOperand.CheckCast());
  raiseError.copyPosition(s);
  failBlock.appendInstruction(raiseError);
  OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard.copyD2U());
  return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,succBlock,failBlock,null);
}","/** 
 * Expand a checkcast instruction into the LIR sequence that implements the  dynamic type check, raising a ClassCastException when the type check  fails. Ref may contain a null ptr at runtime.
 * @param s a CHECKCAST or CHECKCAST_UNRESOLVED instruction to expand 
 * @param ir the enclosing OPT_IR
 * @return the last OPT_Instruction in the generated LIR sequence.
 */
static OPT_Instruction checkcast(OPT_Instruction s,OPT_IR ir){
  OPT_Operand ref=TypeCheck.getClearRef(s);
  VM_TypeReference LHStype=TypeCheck.getType(s).getTypeRef();
  OPT_RegisterOperand guard=ir.regpool.makeTempValidation();
  OPT_Instruction nullCond=IfCmp.create(REF_IFCMP,guard,ref.copy(),new OPT_NullConstantOperand(),OPT_ConditionOperand.EQUAL(),null,new OPT_BranchProfileOperand());
  s.insertBefore(nullCond);
  OPT_BasicBlock myBlock=s.getBasicBlock();
  OPT_BasicBlock failBlock=myBlock.createSubBlock(s.bcIndex,ir,.0001f);
  OPT_BasicBlock instanceOfBlock=myBlock.splitNodeAt(nullCond,ir);
  OPT_BasicBlock succBlock=instanceOfBlock.splitNodeAt(s,ir);
  IfCmp.setTarget(nullCond,succBlock.makeJumpTarget());
  myBlock.insertOut(instanceOfBlock);
  myBlock.insertOut(succBlock);
  instanceOfBlock.insertOut(failBlock);
  instanceOfBlock.insertOut(succBlock);
  ir.cfg.linkInCodeOrder(myBlock,instanceOfBlock);
  ir.cfg.linkInCodeOrder(instanceOfBlock,succBlock);
  ir.cfg.addLastInCodeOrder(failBlock);
  OPT_Instruction raiseError=Trap.create(TRAP,null,OPT_TrapCodeOperand.CheckCast());
  raiseError.copyPosition(s);
  failBlock.appendInstruction(raiseError);
  OPT_RegisterOperand RHStib=getTIB(s,ir,ref,guard.copyD2U());
  return generateBranchingTypeCheck(s,ir,ref,LHStype,RHStib,succBlock,failBlock,null,OPT_BranchProfileOperand.never());
}",0.9903874162540052
150203,"/** 
 * Emit code to do the C to Java transition:  JNI methods in VM_JNIFunctions.java
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_Method mth){
  int offset;
  asm.emitSTAddrU(FP,-JNI_GLUE_FRAME_SIZE,FP);
  String mthName=mth.getName().toString();
  if ((mthName.startsWith(""String_Node_Str"") && mthName.endsWith(""String_Node_Str"")) || mthName.equals(""String_Node_Str"")) {
    offset=STACKFRAME_HEADER_SIZE + 3 * BYTES_IN_STACKSLOT;
    for (int i=6; i <= 10; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=1; i <= 3; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_PARAMETER_FPR; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
  }
 else {
    convertParametersFromSVR4ToJava(asm,mth);
  }
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_RVM_RESERVED_NV_GPR; i <= LAST_RVM_RESERVED_NV_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitLVAL(S0,INVISIBLE_METHOD_ID);
  asm.emitMFLR(REGISTER_ZERO);
  asm.emitSTW(S0,STACKFRAME_METHOD_ID_OFFSET,FP);
  asm.emitSTAddr(REGISTER_ZERO,JNI_GLUE_FRAME_SIZE + STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitADDI(T0,-VM_Entrypoints.JNIExternalFunctionsField.getOffset(),T0);
  int retryLoop=asm.getMachineCodeIndex();
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T0);
  asm.emitLAddr(JTOC,VM_Entrypoints.JNIEnvSavedJTOCField.getOffset(),T0);
  asm.emitLVAL(S1,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitLWARX(S0,S1,PROCESSOR_REGISTER);
  asm.emitCMPI(S0,VM_Processor.BLOCKED_IN_NATIVE);
  VM_ForwardReference frBlocked=asm.emitForwardBC(EQ);
  asm.emitLVAL(S0,VM_Processor.IN_JAVA);
  asm.emitSTWCXr(S0,S1,PROCESSOR_REGISTER);
  asm.emitBC(NE,retryLoop);
  VM_ForwardReference frInJava=asm.emitForwardB();
  frBlocked.resolve(asm);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLAddr(S1,VM_Entrypoints.the_boot_recordField.getOffset(),JTOC);
  asm.emitMR(PROCESSOR_REGISTER,JTOC);
  asm.emitLAddr(JTOC,VM_Entrypoints.sysTOCField.getOffset(),S1);
  asm.emitLAddr(KLUDGE_TI_REG,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset(),S1);
  asm.emitMTLR(KLUDGE_TI_REG);
  asm.emitBCLRL();
  asm.emitMR(JTOC,PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitB(retryLoop);
  frInJava.resolve(asm);
  asm.emitLAddr(S0,VM_Entrypoints.JNITopJavaFPField.getOffset(),T0);
  asm.emitSUBFC(S0,FP,S0);
  asm.emitSTW(S0,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  VM_ForwardReference frNormalPrologue=asm.emitForwardBL();
  asm.emitLAddr(T2,VM_Entrypoints.activeThreadField.getOffset(),PROCESSOR_REGISTER);
  asm.emitLAddr(T2,VM_Entrypoints.jniEnvField.getOffset(),T2);
  asm.emitLInt(T3,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  asm.emitADD(T3,FP,T3);
  asm.emitSTAddr(T3,VM_Entrypoints.JNITopJavaFPField.getOffset(),T2);
  asm.emitCMPAddrI(T3,VM_Constants.STACKFRAME_SENTINEL_FP.toInt());
  VM_ForwardReference fr4=asm.emitForwardBC(EQ);
  asm.emitLAddr(S0,0,T3);
  fr4.resolve(asm);
  asm.emitSTAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T2);
  asm.emitLVAL(S0,VM_Processor.IN_NATIVE);
  asm.emitSTW(S0,VM_Entrypoints.vpStatusField.getOffset(),PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_RVM_RESERVED_NV_GPR; i <= LAST_RVM_RESERVED_NV_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitADDI(FP,JNI_GLUE_FRAME_SIZE,FP);
  asm.emitLAddr(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitMTLR(T2);
  asm.emitBCLR();
  frNormalPrologue.resolve(asm);
}","/** 
 * Emit code to do the C to Java transition:  JNI methods in VM_JNIFunctions.java
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_Method mth){
  int offset;
  boolean usesVarargs;
  int varargAmount=0;
  String mthName=mth.getName().toString();
  if ((mthName.startsWith(""String_Node_Str"") && mthName.endsWith(""String_Node_Str"")) || mthName.equals(""String_Node_Str""))   usesVarargs=true;
 else   usesVarargs=false;
  if (usesVarargs) {
    VM_TypeReference[] argTypes=mth.getParameterTypes();
    int argCount=argTypes.length;
    for (int i=0; i < argCount; i++) {
      if (argTypes[i].isLongType() || argTypes[i].isDoubleType())       varargAmount+=2 * BYTES_IN_ADDRESS;
 else       varargAmount+=BYTES_IN_ADDRESS;
    }
  }
  int glueFrameSize=JNI_GLUE_FRAME_SIZE + varargAmount;
  asm.emitSTAddrU(FP,-glueFrameSize,FP);
  if (usesVarargs) {
    offset=STACKFRAME_HEADER_SIZE + 3 * BYTES_IN_STACKSLOT;
    for (int i=6; i <= 10; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=1; i <= 3; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_PARAMETER_FPR; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
  }
 else {
    convertParametersFromSVR4ToJava(asm,mth);
  }
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_RVM_RESERVED_NV_GPR; i <= LAST_RVM_RESERVED_NV_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitLVAL(S0,INVISIBLE_METHOD_ID);
  asm.emitMFLR(REGISTER_ZERO);
  asm.emitSTW(S0,STACKFRAME_METHOD_ID_OFFSET,FP);
  asm.emitSTAddr(REGISTER_ZERO,glueFrameSize + STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitADDI(T0,-VM_Entrypoints.JNIExternalFunctionsField.getOffset(),T0);
  int retryLoop=asm.getMachineCodeIndex();
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T0);
  asm.emitLAddr(JTOC,VM_Entrypoints.JNIEnvSavedJTOCField.getOffset(),T0);
  asm.emitLVAL(S1,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitLWARX(S0,S1,PROCESSOR_REGISTER);
  asm.emitCMPI(S0,VM_Processor.BLOCKED_IN_NATIVE);
  VM_ForwardReference frBlocked=asm.emitForwardBC(EQ);
  asm.emitLVAL(S0,VM_Processor.IN_JAVA);
  asm.emitSTWCXr(S0,S1,PROCESSOR_REGISTER);
  asm.emitBC(NE,retryLoop);
  VM_ForwardReference frInJava=asm.emitForwardB();
  frBlocked.resolve(asm);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLAddr(S1,VM_Entrypoints.the_boot_recordField.getOffset(),JTOC);
  asm.emitMR(PROCESSOR_REGISTER,JTOC);
  asm.emitLAddr(JTOC,VM_Entrypoints.sysTOCField.getOffset(),S1);
  asm.emitLAddr(KLUDGE_TI_REG,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset(),S1);
  asm.emitMTLR(KLUDGE_TI_REG);
  asm.emitBCLRL();
  asm.emitMR(JTOC,PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitB(retryLoop);
  frInJava.resolve(asm);
  asm.emitLAddr(S0,VM_Entrypoints.JNITopJavaFPField.getOffset(),T0);
  asm.emitSUBFC(S0,FP,S0);
  asm.emitSTW(S0,glueFrameSize + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  VM_ForwardReference frNormalPrologue=asm.emitForwardBL();
  asm.emitLAddr(T2,VM_Entrypoints.activeThreadField.getOffset(),PROCESSOR_REGISTER);
  asm.emitLAddr(T2,VM_Entrypoints.jniEnvField.getOffset(),T2);
  asm.emitLInt(T3,glueFrameSize + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  asm.emitADD(T3,FP,T3);
  asm.emitSTAddr(T3,VM_Entrypoints.JNITopJavaFPField.getOffset(),T2);
  asm.emitCMPAddrI(T3,VM_Constants.STACKFRAME_SENTINEL_FP.toInt());
  VM_ForwardReference fr4=asm.emitForwardBC(EQ);
  asm.emitLAddr(S0,0,T3);
  fr4.resolve(asm);
  asm.emitSTAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T2);
  asm.emitLVAL(S0,VM_Processor.IN_NATIVE);
  asm.emitSTW(S0,VM_Entrypoints.vpStatusField.getOffset(),PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_RVM_RESERVED_NV_GPR; i <= LAST_RVM_RESERVED_NV_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitADDI(FP,glueFrameSize,FP);
  asm.emitLAddr(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitMTLR(T2);
  asm.emitBCLR();
  frNormalPrologue.resolve(asm);
}",0.8482142857142857
150204,"/** 
 * Common code shared by the JNI functions Call<type>Method (virtual method invocation)
 * @param obj the object instance 
 * @param methodID the method ID
 * @param expectReturnType the return type for checking purpose
 * @param skip4Args  true if the calling JNI Function takes 4 args before the varargfalse if the calling JNI Function takes 3 args before the vararg
 * @return an object that may be the return object or a wrapper for the primitive return value 
 */
public static Object invokeWithDotDotVarArg(Object obj,int methodID,VM_TypeReference expectReturnType,boolean skip4Args) throws Exception, VM_PragmaNoInline {
  VM_Address varargAddress=pushVarArgToSpillArea(methodID,skip4Args);
  return packageAndInvoke(obj,methodID,varargAddress,expectReturnType,skip4Args,AIX_VARARG);
  VM_Address glueFP=VM_Magic.getCallerFramePointer(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
  return packageAndInvoke(obj,methodID,glueFP,expectReturnType,skip4Args,SVR4_DOTARG);
}","/** 
 * Common code shared by the JNI functions Call<type>Method (virtual method invocation)
 * @param obj the object instance 
 * @param methodID the method ID
 * @param expectReturnType the return type for checking purpose
 * @param skip4Args  true if the calling JNI Function takes 4 args before the varargfalse if the calling JNI Function takes 3 args before the vararg
 * @return an object that may be the return object or a wrapper for the primitive return value 
 */
public static Object invokeWithDotDotVarArg(Object obj,int methodID,VM_TypeReference expectReturnType,boolean skip4Args) throws Exception, VM_PragmaNoInline {
  VM_Address varargAddress=pushVarArgToSpillArea(methodID,skip4Args);
  return packageAndInvoke(obj,methodID,varargAddress,expectReturnType,skip4Args,AIX_VARARG);
  VM_Address glueFP=VM_Magic.getCallerFramePointer(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
  return packageAndInvoke(obj,methodID,glueFP,expectReturnType,skip4Args,SVR4_DOTARG);
  VM_Address varargAddress=pushVarArgToSpillArea(methodID,skip4Args);
  return packageAndInvoke(obj,methodID,varargAddress,expectReturnType,skip4Args,OSX_DOTARG);
}",0.9243619489559164
150205,"/** 
 * This method supports var args passed from C In the AIX C convention, the caller keeps the first 8 words in registers and  the rest in the spill area in the caller frame.  The callee will push the values in registers out to the spill area of the caller frame and use the beginning  address of this spill area as the var arg address For the JNI functions that takes var args, their prolog code will save the var arg in the glue frame because the values in the register may be lost by  subsequent calls. This method copies the var arg values that were saved earlier in glue frame into the spill area of the original caller, thereby doing the work that the callee normally performs in the AIX C convention. NOTE:  this method assumes that it is immediately above the  invokeWithDotDotVarArg frame, the JNI frame, the glue frame and  the C caller frame in the respective order.   Therefore, this method will not work if called from anywhere else |  fp  | <- VM_JNIEnvironment.pushVarArgToSpillArea | mid  | | xxx  | |      | |      | |------|    |  fp  | <- VM_JNIEnvironment.invokeWithDotDotVarArg frame | mid  | | xxx  | |      | |      | |      | |------|    |  fp  | <- JNI method frame | mid  | | xxx  | |      | |      | |      | |------| |  fp  | <- glue frame | mid  | + xxx  + | r3   |   volatile save area | r4   | | r5   | | r6   |   vararg GPR[6-10]save area   <- VARARG_AREA_OFFSET | r7   | | r8   | | r9   | | r10  | | fpr1 |   vararg FPR[1-3] save area (also used as volatile FPR[1-6] save area) | fpr2 | | fpr3 | | fpr4 | | fpr5 | + fpr6 + | r13  |   nonvolatile GPR[13-31] save area | ...  | + r31  + | fpr14|   nonvolatile FPR[14-31] save area | ...  | | fpr31| |topjav|   offset to preceding Java to C glue frame |------|   | fp   | <- Native C caller frame | cr   | | lr   | | resv | | resv | + toc  + |   0  |    spill area initially not filled |   1  |    to be filled by this method |   2  | |   3  | |   4  | |   5  | |   6  | |   7  | |   8  |    spill area already filled by caller |   9  | |      | |      | |      |
 * @param methodID a VM_MemberReference id
 * @param skip4Args if true, the calling JNI function has 4 args before the varargif false, the calling JNI function has 3 args before the vararg
 * @return the starting address of the vararg in the caller stack frame
 */
private static VM_Address pushVarArgToSpillArea(int methodID,boolean skip4Args) throws Exception, VM_PragmaNoInline {
  int glueFrameSize=JNI_GLUE_FRAME_SIZE;
  VM_Address gluefp=VM_Magic.getMemoryAddress(VM_Magic.getFramePointer().add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  int varargGPROffset=VARARG_AREA_OFFSET + (skip4Args ? BYTES_IN_ADDRESS : 0);
  int varargFPROffset=varargGPROffset + 5 * BYTES_IN_ADDRESS;
  int spillAreaLimit=glueFrameSize + NATIVE_FRAME_HEADER_SIZE + 8 * BYTES_IN_ADDRESS;
  int spillAreaOffset=glueFrameSize + NATIVE_FRAME_HEADER_SIZE + (skip4Args ? 4 * BYTES_IN_ADDRESS : 3 * BYTES_IN_ADDRESS);
  VM_Address varargAddress=gluefp.add(spillAreaOffset);
  VM_Method targetMethod=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference[] argTypes=targetMethod.getParameterTypes();
  int argCount=argTypes.length;
  for (int i=0; i < argCount && spillAreaOffset < spillAreaLimit; i++) {
    VM_Word hiword, loword;
    if (argTypes[i].isFloatType() || argTypes[i].isDoubleType()) {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargFPROffset));
      varargFPROffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr) {
        loword=VM_Magic.getMemoryWord(gluefp.add(varargFPROffset));
        varargFPROffset+=BYTES_IN_ADDRESS;
      }
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr) {
        VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),loword);
        spillAreaOffset+=BYTES_IN_ADDRESS;
      }
    }
 else     if (argTypes[i].isLongType()) {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
      varargGPROffset+=BYTES_IN_ADDRESS;
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr && spillAreaOffset < spillAreaLimit) {
        loword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
        varargGPROffset+=BYTES_IN_ADDRESS;
        VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),loword);
        spillAreaOffset+=BYTES_IN_ADDRESS;
      }
    }
 else {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
      varargGPROffset+=BYTES_IN_ADDRESS;
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
    }
  }
  return varargAddress;
}","private static VM_Address pushVarArgToSpillArea(int methodID,boolean skip4Args) throws Exception, VM_PragmaNoInline {
  VM_Address currentfp=VM_Magic.getFramePointer();
  VM_Address gluefp=VM_Magic.getMemoryAddress(VM_Magic.getFramePointer().add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  VM_Address gluecallerfp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  VM_Method targetMethod=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference[] argTypes=targetMethod.getParameterTypes();
  int argCount=argTypes.length;
  int argSize=0;
  int registerBlock=(1 + LAST_OS_PARAMETER_GPR - FIRST_OS_PARAMETER_GPR) * BYTES_IN_ADDRESS;
  for (int i=0; i < argCount; i++) {
    if (argTypes[i].isDoubleType() || argTypes[i].isLongType())     argSize+=2 * BYTES_IN_ADDRESS;
 else     argSize+=BYTES_IN_ADDRESS;
  }
  VM_Address targetAddress=gluefp.add(STACKFRAME_HEADER_SIZE + ((skip4Args ? 4 : 3)) * BYTES_IN_ADDRESS);
  int spillRequiredAtOffset=registerBlock - ((skip4Args ? 4 : 3)) * BYTES_IN_ADDRESS;
  if (argSize > spillRequiredAtOffset) {
    VM_Word word;
    int targetOffset=0;
    int srcOffset=0;
    VM_Address srcAddress=gluecallerfp.add(14 * BYTES_IN_ADDRESS);
    for (targetOffset=spillRequiredAtOffset; targetOffset <= argSize; srcOffset+=BYTES_IN_ADDRESS, targetOffset+=BYTES_IN_ADDRESS) {
      word=VM_Magic.getMemoryWord(srcAddress.add(srcOffset));
      VM_Magic.setMemoryWord(targetAddress.add(targetOffset),word);
    }
  }
  return targetAddress;
}",0.0235507246376811
150206,"/** 
 * Common code shared by invokeWithJValue, invokeWithVarArg and invokeWithDotDotVarArg
 * @param obj the object instance 
 * @param methodID a VM_MemberReference id
 * @param argAddress a raw address for the argument array
 * @param expectReturnType the return type for checking purpose
 * @param skip4Args This flag is received from the JNI function and passed directly to VM_Reflection.invoke().   It is true if the actual method is to be invoked, which could be from the superclass. It is false if the method from the real class of the object  is to be invoked, which may not be the actual method specified by methodID
 * @param isVarArg  This flag describes whether the array of parameters is in var arg format orjvalue format
 * @return an object that may be the return object or a wrapper for the primitive return value 
 */
public static Object packageAndInvoke(Object obj,int methodID,VM_Address argAddress,VM_TypeReference expectReturnType,boolean skip4Args,int argtype) throws Exception {
  VM_Method targetMethod=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference returnType=targetMethod.getReturnType();
  if (expectReturnType == null) {
    if (!returnType.isReferenceType())     throw new Exception(""String_Node_Str"" + returnType);
  }
 else {
    if (returnType != expectReturnType)     throw new Exception(""String_Node_Str"" + expectReturnType + ""String_Node_Str""+ returnType);
  }
  Object[] argObjectArray;
switch (argtype) {
case SVR4_DOTARG:
    argObjectArray=packageParameterFromDotArgSVR4(targetMethod,argAddress,skip4Args);
  break;
case JVALUE_ARG:
argObjectArray=packageParameterFromJValue(targetMethod,argAddress);
break;
case SVR4_VARARG:
argObjectArray=packageParameterFromVarArgSVR4(targetMethod,argAddress);
break;
case SVR4_VARARG:
argObjectArray=packageParameterFromVarArg(targetMethod,argAddress);
break;
case AIX_VARARG:
argObjectArray=packageParameterFromVarArg(targetMethod,argAddress);
break;
default :
argObjectArray=null;
if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED);
}
Object returnObj=VM_Reflection.invoke(targetMethod,obj,argObjectArray,skip4Args);
return returnObj;
}","/** 
 * Common code shared by invokeWithJValue, invokeWithVarArg and invokeWithDotDotVarArg
 * @param obj the object instance 
 * @param methodID a VM_MemberReference id
 * @param argAddress a raw address for the argument array
 * @param expectReturnType the return type for checking purpose
 * @param skip4Args This flag is received from the JNI function and passed directly to VM_Reflection.invoke().   It is true if the actual method is to be invoked, which could be from the superclass. It is false if the method from the real class of the object  is to be invoked, which may not be the actual method specified by methodID
 * @param isVarArg  This flag describes whether the array of parameters is in var arg format orjvalue format
 * @return an object that may be the return object or a wrapper for the primitive return value 
 */
public static Object packageAndInvoke(Object obj,int methodID,VM_Address argAddress,VM_TypeReference expectReturnType,boolean skip4Args,int argtype) throws Exception {
  VM_Method targetMethod=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference returnType=targetMethod.getReturnType();
  if (expectReturnType == null) {
    if (!returnType.isReferenceType())     throw new Exception(""String_Node_Str"" + returnType);
  }
 else {
    if (returnType != expectReturnType)     throw new Exception(""String_Node_Str"" + expectReturnType + ""String_Node_Str""+ returnType);
  }
  Object[] argObjectArray;
switch (argtype) {
case SVR4_DOTARG:
    argObjectArray=packageParameterFromDotArgSVR4(targetMethod,argAddress,skip4Args);
  break;
case JVALUE_ARG:
argObjectArray=packageParameterFromJValue(targetMethod,argAddress);
break;
case SVR4_VARARG:
argObjectArray=packageParameterFromVarArgSVR4(targetMethod,argAddress);
break;
case SVR4_DOTARG:
case SVR4_VARARG:
argObjectArray=packageParameterFromVarArg(targetMethod,argAddress);
break;
case OSX_DOTARG:
argObjectArray=packageParameterFromVarArg(targetMethod,argAddress);
break;
case AIX_VARARG:
argObjectArray=packageParameterFromVarArg(targetMethod,argAddress);
break;
default :
argObjectArray=null;
if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED);
}
Object returnObj=VM_Reflection.invoke(targetMethod,obj,argObjectArray,skip4Args);
return returnObj;
}",0.9738503155996392
150207,"/** 
 * The current frame is expected to be one of the JNI functions  called from C,  below which is one or more native stack frames Skip over all frames below with saved code pointers outside of heap  (C frames),  stopping at the native frame immediately preceding the glue frame which  contains the method ID of the native method  (this is necessary to allow retrieving the  return address of the glue frame) Ton Ngo 7/30/01
 */
public static VM_Address unwindNativeStackFrame(VM_Address currfp) throws VM_PragmaUninterruptible {
  VM_Address ip, callee_fp;
  VM_Address fp=VM_Magic.getCallerFramePointer(currfp);
  do {
    callee_fp=fp;
    ip=VM_Magic.getReturnAddress(fp);
    fp=VM_Magic.getCallerFramePointer(fp);
  }
 while (!MM_Interface.refInVM(ip) && fp.NE(STACKFRAME_SENTINEL_FP));
  if (VM.BuildForPowerPC) {
    if (VM.BuildForSVR4ABI || VM.BuildForMachOABI) {
      if (MM_Interface.refInVM(ip)) {
        return fp;
      }
 else {
        return callee_fp;
      }
    }
 else {
      return callee_fp;
    }
  }
 else {
    return callee_fp;
  }
}","/** 
 * The current frame is expected to be one of the JNI functions  called from C,  below which is one or more native stack frames Skip over all frames below with saved code pointers outside of heap  (C frames),  stopping at the native frame immediately preceding the glue frame which  contains the method ID of the native method  (this is necessary to allow retrieving the  return address of the glue frame) Ton Ngo 7/30/01
 */
public static VM_Address unwindNativeStackFrame(VM_Address currfp) throws VM_PragmaUninterruptible {
  VM_Address ip, callee_fp;
  VM_Address fp=VM_Magic.getCallerFramePointer(currfp);
  do {
    callee_fp=fp;
    ip=VM_Magic.getReturnAddress(fp);
    fp=VM_Magic.getCallerFramePointer(fp);
  }
 while (!MM_Interface.refInVM(ip) && fp.NE(STACKFRAME_SENTINEL_FP));
  if (VM.BuildForPowerPC) {
    if (VM.BuildForSVR4ABI) {
      if (MM_Interface.refInVM(ip)) {
        return fp;
      }
 else {
        return callee_fp;
      }
    }
 else {
      return callee_fp;
    }
  }
 else {
    return callee_fp;
  }
}",0.9179706021811284
150208,"/** 
 * Allocate a stack
 * @param n The number of bytes to allocate
 * @param immortal  Is the stack immortal and non-moving?
 * @return The stack
 */
public static byte[] newStack(int bytes,boolean immortal) throws VM_PragmaInline, VM_PragmaInterruptible {
  if (!immortal || !VM.runningVM)   return new byte[bytes];
  int logAlignment=12;
  int alignment=1 << logAlignment;
  VM_Array stackType=VM_Array.ByteArray;
  Object[] stackTib=stackType.getTypeInformationBlock();
  int offset=VM_JavaHeader.computeArrayHeaderSize(stackType);
  int arraySize=VM_Memory.alignUp(stackType.getInstanceSize(bytes),BYTES_IN_PARTICLE);
  int fullSize=VM_Memory.alignUp(arraySize + alignment,BYTES_IN_PARTICLE);
  if (VM.VerifyAssertions)   VM._assert(alignment > offset);
  VM_Address fullRegion=VM_Interface.getPlan().alloc(fullSize,BYTES_IN_PARTICLE,0,Plan.IMMORTAL_SPACE);
  VM_Address tmp=fullRegion.add(alignment);
  VM_Word mask=VM_Word.one().lsh(logAlignment).sub(VM_Word.one()).not();
  VM_Address region=tmp.toWord().and(mask).sub(VM_Word.fromIntSignExtend(offset)).toAddress();
  Object result=VM_ObjectModel.initializeArray(region,stackTib,bytes,arraySize);
  VM_Interface.getPlan().postAlloc(VM_Magic.objectAsAddress(result),stackTib,arraySize,Plan.IMMORTAL_SPACE);
  return (byte[])result;
}","/** 
 * Allocate a stack
 * @param n The number of bytes to allocate
 * @param immortal  Is the stack immortal and non-moving?
 * @return The stack
 */
public static byte[] newStack(int bytes,boolean immortal) throws VM_PragmaInline, VM_PragmaInterruptible {
  if (!immortal || !VM.runningVM) {
    return new byte[bytes];
  }
 else {
    VM_Array stackType=VM_Array.ByteArray;
    int headerSize=VM_ObjectModel.computeArrayHeaderSize(stackType);
    int align=VM_ObjectModel.getAlignment(stackType);
    int offset=VM_ObjectModel.getOffsetForAlignment(stackType);
    int width=stackType.getLogElementSize();
    Object[] stackTib=stackType.getTypeInformationBlock();
    return (byte[])allocateArray(bytes,width,headerSize,stackTib,Plan.IMMORTAL_SPACE,align,offset);
  }
}",0.4433688286544046
150209,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param tib The TIB of the newly allocated object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(VM_Address ref,Object[] tib,int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
switch (allocator) {
case DEFAULT_SPACE:
    Header.initializeHeader(ref,tib,bytes,isScalar);
  return;
case IMMORTAL_SPACE:
ImmortalSpace.postAlloc(ref);
return;
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
}
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param tib The TIB of the newly allocated object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(VM_Address ref,Object[] tib,int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
switch (allocator) {
case LOS_SPACE:
case DEFAULT_SPACE:
    Header.initializeHeader(ref,tib,bytes,isScalar);
  return;
case IMMORTAL_SPACE:
ImmortalSpace.postAlloc(ref);
return;
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
}
}",0.9896640826873384
150210,"/** 
 * Return true if <code>obj</code> is a live object.
 * @param obj The object in question
 * @return True if <code>obj</code> is a live object.
 */
public static final boolean isLive(VM_Address obj){
  if (obj.isZero())   return false;
  VM_Address addr=VM_Interface.refToAddress(obj);
  byte space=VMResource.getSpace(addr);
switch (space) {
case DEFAULT_SPACE:
    return true;
case IMMORTAL_SPACE:
  return true;
case BOOT_SPACE:
return true;
case META_SPACE:
return true;
default :
if (VM_Interface.VerifyAssertions) spaceFailure(obj,space,""String_Node_Str"");
return false;
}
}","/** 
 * Return true if <code>obj</code> is a live object.
 * @param obj The object in question
 * @return True if <code>obj</code> is a live object.
 */
public static final boolean isLive(VM_Address obj){
  if (obj.isZero())   return false;
  VM_Address addr=VM_Interface.refToAddress(obj);
  byte space=VMResource.getSpace(addr);
switch (space) {
case LOS_SPACE:
    return true;
case DEFAULT_SPACE:
  return true;
case IMMORTAL_SPACE:
return true;
case BOOT_SPACE:
return true;
case META_SPACE:
return true;
default :
if (VM_Interface.VerifyAssertions) spaceFailure(obj,space,""String_Node_Str"");
return false;
}
}",0.9691923397169026
150211,"/** 
 * Allocate space (for an object)
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 * @return The address of the first byte of the allocated region
 */
public final VM_Address alloc(int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
switch (allocator) {
case DEFAULT_SPACE:
    return def.alloc(isScalar,bytes);
case IMMORTAL_SPACE:
  return immortal.alloc(isScalar,bytes);
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
return VM_Address.zero();
}
}","/** 
 * Allocate space (for an object)
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 * @return The address of the first byte of the allocated region
 */
public final VM_Address alloc(int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
switch (allocator) {
case LOS_SPACE:
case DEFAULT_SPACE:
    return def.alloc(isScalar,bytes);
case IMMORTAL_SPACE:
  return immortal.alloc(isScalar,bytes);
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
return VM_Address.zero();
}
}",0.9882697947214076
150212,"/** 
 * Allocate a large object.  Large objects are directly allocted and freed in page-grained units via the vm resource.  This routine returned zeroed memory.
 * @param bytes The required size of this space in bytes.
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @param inGC If true, this allocation is occuring with respect toa space that is currently being collected.
 * @return The address of the start of the newly allocated region atleast <code>bytes</code> bytes in size.
 */
final protected VM_Address allocSlowOnce(int bytes,int align,int offset,boolean inGC){
  int header=superPageHeaderSize() + cellHeaderSize();
  int pages=(getMaximumAlignedSize(bytes + header,align) + BYTES_IN_PAGE - 1) >> LOG_BYTES_IN_PAGE;
  VM_Address sp=allocSuperPage(pages);
  if (sp.isZero())   return sp;
  VM_Address cell=alignAllocation(sp.add(header),align,offset);
  Memory.zero(cell,VM_Extent.fromIntZeroExtend(bytes));
  return cell;
}","/** 
 * Allocate a large object.  Large objects are directly allocted and freed in page-grained units via the vm resource.  This routine returned zeroed memory.
 * @param bytes The required size of this space in bytes.
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @param inGC If true, this allocation is occuring with respect toa space that is currently being collected.
 * @return The address of the start of the newly allocated region atleast <code>bytes</code> bytes in size.
 */
final protected VM_Address allocSlowOnce(int bytes,int align,int offset,boolean inGC){
  int header=superPageHeaderSize() + cellHeaderSize();
  int maxbytes=getMaximumAlignedSize(bytes + header,align);
  int pages=(maxbytes + BYTES_IN_PAGE - 1) >> LOG_BYTES_IN_PAGE;
  VM_Address sp=allocSuperPage(pages);
  if (sp.isZero())   return sp;
  VM_Address cell=sp.add(header);
  Memory.zero(cell,VM_Extent.fromIntZeroExtend(maxbytes));
  return cell;
}",0.9525283797729618
150213,"/** 
 * Allocate space for an object
 * @param bytes The number of bytes allocated
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @return The address of the first byte of the allocated cell Willnot return zero.
 */
public final VM_Address alloc(int bytes,int align,int offset) throws VM_PragmaNoInline {
  VM_Address cell=allocSlow(bytes,align,offset,false);
  postAlloc(cell);
  return cell;
}","/** 
 * Allocate space for an object
 * @param bytes The number of bytes allocated
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @return The address of the first byte of the allocated cell Willnot return zero.
 */
public final VM_Address alloc(int bytes,int align,int offset) throws VM_PragmaNoInline {
  VM_Address cell=allocSlow(bytes,align,offset,false);
  postAlloc(cell);
  return alignAllocation(cell,align,offset);
}",0.9573033707865168
150214,"/** 
 * Allocate a large object.  Large objects are directly allocted and freed in page-grained units via the vm resource.  This routine returned zeroed memory.
 * @param bytes The required size of this space in bytes.
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @param inGC If true, this allocation is occuring with respect toa space that is currently being collected.
 * @return The address of the start of the newly allocated region atleast <code>bytes</code> bytes in size.
 */
final protected VM_Address allocSlowOnce(int bytes,int align,int offset,boolean inGC){
  int header=superPageHeaderSize() + cellHeaderSize();
  int pages=(getMaximumAlignedSize(bytes + header,align) + BYTES_IN_PAGE - 1) >> LOG_BYTES_IN_PAGE;
  VM_Address sp=allocSuperPage(pages);
  if (sp.isZero())   return sp;
  VM_Address cell=alignAllocation(sp.add(header),align,offset);
  Memory.zero(cell,VM_Extent.fromIntZeroExtend(bytes));
  return cell;
}","/** 
 * Allocate a large object.  Large objects are directly allocted and freed in page-grained units via the vm resource.  This routine returned zeroed memory.
 * @param bytes The required size of this space in bytes.
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @param inGC If true, this allocation is occuring with respect toa space that is currently being collected.
 * @return The address of the start of the newly allocated region atleast <code>bytes</code> bytes in size.
 */
final protected VM_Address allocSlowOnce(int bytes,int align,int offset,boolean inGC){
  int header=superPageHeaderSize() + cellHeaderSize();
  int maxbytes=getMaximumAlignedSize(bytes + header,align);
  int pages=(maxbytes + BYTES_IN_PAGE - 1) >> LOG_BYTES_IN_PAGE;
  VM_Address sp=allocSuperPage(pages);
  if (sp.isZero())   return sp;
  VM_Address cell=sp.add(header);
  Memory.zero(cell,VM_Extent.fromIntZeroExtend(maxbytes));
  return cell;
}",0.9525283797729618
150215,"/** 
 * Allocate space for an object
 * @param bytes The number of bytes allocated
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @return The address of the first byte of the allocated cell Willnot return zero.
 */
public final VM_Address alloc(int bytes,int align,int offset) throws VM_PragmaNoInline {
  VM_Address cell=allocSlow(bytes,align,offset,false);
  postAlloc(cell);
  return cell;
}","/** 
 * Allocate space for an object
 * @param bytes The number of bytes allocated
 * @param align The requested alignment.
 * @param offset The alignment offset.
 * @return The address of the first byte of the allocated cell Willnot return zero.
 */
public final VM_Address alloc(int bytes,int align,int offset) throws VM_PragmaNoInline {
  VM_Address cell=allocSlow(bytes,align,offset,false);
  postAlloc(cell);
  return alignAllocation(cell,align,offset);
}",0.9573033707865168
150216,"private void noncommutative(OPT_Instruction s,OPT_Operator opCode,OPT_IR ir){
  OPT_RegisterOperand result=Binary.getClearResult(s);
  OPT_Operand op1=Binary.getClearVal1(s);
  OPT_Operand op2=Binary.getClearVal2(s);
  if (result.similar(op1)) {
    OPT_DefUse.removeUse(op1.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    BinaryAcc.mutate(s,opCode,result,op2);
    return;
  }
  if (OPTIMIZE) {
    if (op1.isRegister()) {
      OPT_RegisterOperand rop1=op1.asRegister();
      if (!rop1.register.spansBasicBlock() && isDead(rop1.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock()) {
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.removeDef(result);
          OPT_DefUse.recordDefUse(rop1);
          OPT_DefUse.mergeRegisters(ir,rop1.register,result.register);
          rop1.register.putSSA(false);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop1.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
  }
  if (result.similar(op2)) {
    OPT_RegisterOperand tmp=ir.regpool.makeTemp(op1);
    OPT_Instruction move=Move.create(getMoveOp(tmp.type),tmp.copyRO(),op1.copy());
    s.insertBefore(move);
    OPT_DefUse.updateDUForNewInstruction(move);
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(tmp);
    if (op1.isRegister()) {
      OPT_DefUse.removeUse(op1.asRegister());
    }
    BinaryAcc.mutate(s,opCode,tmp,op2);
    move=Move.create(getMoveOp(tmp.type),result.copyRO(),tmp.copyRO());
    s.insertAfter(move);
    OPT_DefUse.updateDUForNewInstruction(move);
  }
 else {
    OPT_Instruction move=Move.create(getMoveOp(result.type),result.copyRO(),op1.copy());
    OPT_DefUse.updateDUForNewInstruction(move);
    s.insertBefore(move);
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    if (op1.isRegister()) {
      OPT_DefUse.removeUse(op1.asRegister());
    }
    BinaryAcc.mutate(s,opCode,result,op2);
  }
}","private void noncommutative(OPT_Instruction s,OPT_Operator opCode,OPT_IR ir){
  OPT_RegisterOperand result=Binary.getClearResult(s);
  OPT_Operand op1=Binary.getClearVal1(s);
  OPT_Operand op2=Binary.getClearVal2(s);
  if (result.similar(op1)) {
    OPT_DefUse.removeUse(op1.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    BinaryAcc.mutate(s,opCode,result,op2);
    return;
  }
  if (OPTIMIZE) {
    if (op1.isRegister()) {
      OPT_RegisterOperand rop1=op1.asRegister();
      if (!rop1.register.spansBasicBlock() && isDead(rop1.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock() && rop1.register.isSSA()) {
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.removeDef(result);
          OPT_DefUse.recordDefUse(rop1);
          OPT_DefUse.mergeRegisters(ir,rop1.register,result.register);
          rop1.register.putSSA(false);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop1.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
  }
  if (result.similar(op2)) {
    OPT_RegisterOperand tmp=ir.regpool.makeTemp(op1);
    OPT_Instruction move=Move.create(getMoveOp(tmp.type),tmp.copyRO(),op1.copy());
    s.insertBefore(move);
    OPT_DefUse.updateDUForNewInstruction(move);
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(tmp);
    if (op1.isRegister()) {
      OPT_DefUse.removeUse(op1.asRegister());
    }
    BinaryAcc.mutate(s,opCode,tmp,op2);
    move=Move.create(getMoveOp(tmp.type),result.copyRO(),tmp.copyRO());
    s.insertAfter(move);
    OPT_DefUse.updateDUForNewInstruction(move);
  }
 else {
    OPT_Instruction move=Move.create(getMoveOp(result.type),result.copyRO(),op1.copy());
    OPT_DefUse.updateDUForNewInstruction(move);
    s.insertBefore(move);
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    if (op1.isRegister()) {
      OPT_DefUse.removeUse(op1.asRegister());
    }
    BinaryAcc.mutate(s,opCode,result,op2);
  }
}",0.8992883329739055
150217,"private void unary(OPT_Instruction s,OPT_Operator opCode,OPT_IR ir){
  OPT_RegisterOperand result=Unary.getClearResult(s);
  OPT_Operand op1=Unary.getClearVal(s);
  if (result.similar(op1)) {
    OPT_DefUse.removeUse(op1.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    UnaryAcc.mutate(s,opCode,result);
    return;
  }
  if (OPTIMIZE) {
    if (op1.isRegister()) {
      OPT_RegisterOperand rop1=op1.asRegister();
      if (!rop1.register.spansBasicBlock() && isDead(rop1.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock()) {
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.removeDef(result);
          OPT_DefUse.recordDefUse(rop1);
          OPT_DefUse.mergeRegisters(ir,rop1.register,result.register);
          rop1.register.putSSA(false);
          UnaryAcc.mutate(s,opCode,rop1);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          UnaryAcc.mutate(s,opCode,rop1);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop1.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
  }
  OPT_Instruction move=Move.create(getMoveOp(result.type),result.copyRO(),op1.copy());
  OPT_DefUse.updateDUForNewInstruction(move);
  s.insertBefore(move);
  OPT_DefUse.removeDef(result);
  OPT_DefUse.recordDefUse(result);
  if (op1.isRegister()) {
    OPT_DefUse.removeUse(op1.asRegister());
  }
  UnaryAcc.mutate(s,opCode,result);
}","private void unary(OPT_Instruction s,OPT_Operator opCode,OPT_IR ir){
  OPT_RegisterOperand result=Unary.getClearResult(s);
  OPT_Operand op1=Unary.getClearVal(s);
  if (result.similar(op1)) {
    OPT_DefUse.removeUse(op1.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    UnaryAcc.mutate(s,opCode,result);
    return;
  }
  if (OPTIMIZE) {
    if (op1.isRegister()) {
      OPT_RegisterOperand rop1=op1.asRegister();
      if (!rop1.register.spansBasicBlock() && isDead(rop1.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock() && rop1.register.isSSA()) {
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.removeDef(result);
          OPT_DefUse.recordDefUse(rop1);
          OPT_DefUse.mergeRegisters(ir,rop1.register,result.register);
          rop1.register.putSSA(false);
          UnaryAcc.mutate(s,opCode,rop1);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          UnaryAcc.mutate(s,opCode,rop1);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop1.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
  }
  OPT_Instruction move=Move.create(getMoveOp(result.type),result.copyRO(),op1.copy());
  OPT_DefUse.updateDUForNewInstruction(move);
  s.insertBefore(move);
  OPT_DefUse.removeDef(result);
  OPT_DefUse.recordDefUse(result);
  if (op1.isRegister()) {
    OPT_DefUse.removeUse(op1.asRegister());
  }
  UnaryAcc.mutate(s,opCode,result);
}",0.8574045801526717
150218,"private void commutative(OPT_Instruction s,OPT_Operator opCode,OPT_IR ir){
  OPT_RegisterOperand result=Binary.getClearResult(s);
  OPT_Operand op1=Binary.getClearVal1(s);
  OPT_Operand op2=Binary.getClearVal2(s);
  if (result.similar(op1)) {
    OPT_DefUse.removeUse(op1.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    BinaryAcc.mutate(s,opCode,result,op2);
    return;
  }
  if (result.similar(op2)) {
    OPT_DefUse.removeUse(op2.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    BinaryAcc.mutate(s,opCode,result,op1);
    return;
  }
  if (OPTIMIZE) {
    if (op1.isRegister()) {
      OPT_RegisterOperand rop1=op1.asRegister();
      if (!rop1.register.spansBasicBlock() && isDead(rop1.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock()) {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          OPT_DefUse.mergeRegisters(ir,rop1.register,result.register);
          rop1.register.putSSA(false);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop1.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
    if (op2.isRegister()) {
      OPT_RegisterOperand rop2=op2.asRegister();
      if (!rop2.register.spansBasicBlock() && isDead(rop2.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock()) {
          OPT_DefUse.removeUse(rop2);
          OPT_DefUse.removeDef(result);
          OPT_DefUse.recordDefUse(rop2);
          OPT_DefUse.mergeRegisters(ir,rop2.register,result.register);
          rop2.register.putSSA(false);
          BinaryAcc.mutate(s,opCode,rop2,op1);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop2);
          OPT_DefUse.recordDefUse(rop2);
          BinaryAcc.mutate(s,opCode,rop2,op1);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop2.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
  }
  OPT_Instruction move=Move.create(getMoveOp(result.type),result.copyRO(),op1.copy());
  OPT_DefUse.updateDUForNewInstruction(move);
  s.insertBefore(move);
  OPT_DefUse.removeDef(result);
  OPT_DefUse.recordDefUse(result);
  if (op1.isRegister()) {
    OPT_DefUse.removeUse(op1.asRegister());
  }
  BinaryAcc.mutate(s,opCode,result,op2);
}","private void commutative(OPT_Instruction s,OPT_Operator opCode,OPT_IR ir){
  OPT_RegisterOperand result=Binary.getClearResult(s);
  OPT_Operand op1=Binary.getClearVal1(s);
  OPT_Operand op2=Binary.getClearVal2(s);
  if (result.similar(op1)) {
    OPT_DefUse.removeUse(op1.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    BinaryAcc.mutate(s,opCode,result,op2);
    return;
  }
  if (result.similar(op2)) {
    OPT_DefUse.removeUse(op2.asRegister());
    OPT_DefUse.removeDef(result);
    OPT_DefUse.recordDefUse(result);
    BinaryAcc.mutate(s,opCode,result,op1);
    return;
  }
  if (OPTIMIZE) {
    if (op1.isRegister()) {
      OPT_RegisterOperand rop1=op1.asRegister();
      if (!rop1.register.spansBasicBlock() && isDead(rop1.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock() && rop1.register.isSSA()) {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          OPT_DefUse.mergeRegisters(ir,rop1.register,result.register);
          rop1.register.putSSA(false);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop1);
          OPT_DefUse.recordDefUse(rop1);
          BinaryAcc.mutate(s,opCode,rop1,op2);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop1.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
    if (op2.isRegister()) {
      OPT_RegisterOperand rop2=op2.asRegister();
      if (!rop2.register.spansBasicBlock() && isDead(rop2.register)) {
        if (result.register.isSSA() && !result.register.spansBasicBlock() && rop2.register.isSSA()) {
          OPT_DefUse.removeUse(rop2);
          OPT_DefUse.removeDef(result);
          OPT_DefUse.recordDefUse(rop2);
          OPT_DefUse.mergeRegisters(ir,rop2.register,result.register);
          rop2.register.putSSA(false);
          BinaryAcc.mutate(s,opCode,rop2,op1);
          return;
        }
 else {
          OPT_DefUse.removeDef(result);
          OPT_DefUse.removeUse(rop2);
          OPT_DefUse.recordDefUse(rop2);
          BinaryAcc.mutate(s,opCode,rop2,op1);
          OPT_Instruction move=Move.create(getMoveOp(result.type),result,rop2.copy());
          OPT_DefUse.updateDUForNewInstruction(move);
          s.insertAfter(move);
          return;
        }
      }
    }
  }
  OPT_Instruction move=Move.create(getMoveOp(result.type),result.copyRO(),op1.copy());
  OPT_DefUse.updateDUForNewInstruction(move);
  s.insertBefore(move);
  OPT_DefUse.removeDef(result);
  OPT_DefUse.recordDefUse(result);
  if (op1.isRegister()) {
    OPT_DefUse.removeUse(op1.asRegister());
  }
  BinaryAcc.mutate(s,opCode,result,op2);
}",0.6057726152763112
150219,"/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param tib The TIB of the newly allocated object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(VM_Address ref,Object[] tib,int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
  int linkSite=((allocator == DEFAULT_SPACE && bytes > LOS_SIZE_THRESHOLD) ? LOS_SPACE : allocator);
  TraceGenerator.addTraceObject(ref,linkSite);
  if (allocator == DEFAULT_SPACE && bytes > LOS_SIZE_THRESHOLD) {
    Header.initializeLOSHeader(ref,tib,bytes,isScalar);
  }
 else {
switch (allocator) {
case DEFAULT_SPACE:
      break;
case IMMORTAL_SPACE:
    ImmortalSpace.postAlloc(ref);
  break;
case LOS_SPACE:
Header.initializeLOSHeader(ref,tib,bytes,isScalar);
break;
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
}
}
traceInducedGC=TraceGenerator.MERLIN_ANALYSIS;
TraceGenerator.traceAlloc(allocator == IMMORTAL_SPACE,ref,tib,bytes);
}","/** 
 * Perform post-allocation actions.  For many allocators none are required.
 * @param ref The newly allocated object
 * @param tib The TIB of the newly allocated object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 */
public final void postAlloc(VM_Address ref,Object[] tib,int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
  TraceGenerator.addTraceObject(ref,allocator);
switch (allocator) {
case DEFAULT_SPACE:
    break;
case IMMORTAL_SPACE:
  ImmortalSpace.postAlloc(ref);
break;
case LOS_SPACE:
Header.initializeLOSHeader(ref,tib,bytes,isScalar);
break;
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
}
traceInducedGC=TraceGenerator.MERLIN_ANALYSIS;
TraceGenerator.traceAlloc(allocator == IMMORTAL_SPACE,ref,tib,bytes);
}",0.8308550185873605
150220,"/** 
 * A new reference is about to be created.  Take appropriate write barrier actions.<p>  In this case, we remember the address of the source of the pointer if the new reference points into the nursery from non-nursery space.
 * @param src The object into which the new reference will be stored
 * @param slot The address into which the new reference will bestored.
 * @param tgt The target of the new reference
 * @param locationMetadata an int that encodes the source location being modified
 * @param mode The mode of the store (eg putfield, putstatic etc)
 */
public final void writeBarrier(VM_Address src,VM_Address slot,VM_Address tgt,int locationMetadata,int mode) throws VM_PragmaInline {
  TraceGenerator.processPointerUpdate(mode == PUTFIELD_WRITE_BARRIER,src,slot,tgt);
  VM_Magic.setMemoryAddress(slot,tgt,locationMetadata);
}","/** 
 * A number of references are about to be copied from object <code>src</code> to object <code>dst</code> (as in an array copy).  Thus, <code>dst</code> is the mutated object.  Take appropriate write barrier actions.<p>
 * @param src The source of the values to be copied
 * @param srcOffset The offset of the first source address, inbytes, relative to <code>src</code> (in principle, this could be negative).
 * @param dst The mutated object, i.e. the destination of the copy.
 * @param dstOffset The offset of the first destination address, inbytes relative to <code>tgt</code> (in principle, this could be negative).
 * @param bytes The size of the region being copied, in bytes.
 * @return True if the update was performed by the barrier, false ifleft to the caller (always false in this case).
 */
public boolean writeBarrier(VM_Address src,int srcOffset,VM_Address dst,int dstOffset,int bytes){
  VM_Address slot=dst.add(dstOffset);
  VM_Address tgtLoc=src.add(srcOffset);
  for (int i=0; i < bytes; i+=BYTES_IN_ADDRESS) {
    VM_Address tgt=VM_Magic.getMemoryAddress(tgtLoc);
    TraceGenerator.processPointerUpdate(false,dst,slot,tgt);
    slot=slot.add(BYTES_IN_ADDRESS);
    tgtLoc=tgtLoc.add(BYTES_IN_ADDRESS);
  }
  return false;
}",0.1293103448275862
150221,"/** 
 * Perform any post-copy actions.  In this case nothing is required.
 * @param ref The newly allocated object
 * @param tib The TIB of the newly allocated object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 */
public final void postCopy(VM_Address ref,Object[] tib,int bytes,boolean isScalar){
}","/** 
 * Perform any post-copy actions.  In this case nothing is required.
 * @param ref The newly allocated object
 * @param tib The TIB of the newly allocated object
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 */
public final void postCopy(VM_Address ref,Object[] tib,int bytes,boolean isScalar){
  CopyingHeader.clearGCBits(ref);
}",0.9589371980676328
150222,"/** 
 * Forward the object referred to by a given address and update the address if necessary.  This <i>does not</i> enqueue the referent for processing; the referent must be explicitly enqueued if it is to be processed.
 * @param location The location whose referent is to be forwarded ifnecessary.  The location will be updated if the referent is forwarded.
 */
public static void forwardObjectLocation(VM_Address location) throws VM_PragmaInline {
  VM_Address obj=VM_Magic.getMemoryAddress(location);
  if (!obj.isZero()) {
    VM_Address addr=VM_Interface.refToAddress(obj);
    byte space=VMResource.getSpace(addr);
    if ((hi && space == LOW_SS_SPACE) || (!hi && space == HIGH_SS_SPACE))     VM_Magic.setMemoryAddress(location,CopySpace.forwardObject(obj));
  }
}","/** 
 * Forward the object referred to by a given address and update the address if necessary.  This <i>does not</i> enqueue the referent for processing; the referent must be explicitly enqueued if it is to be processed.
 * @param location The location whose referent is to be forwarded ifnecessary.  The location will be updated if the referent is forwarded.
 */
public static void forwardObjectLocation(VM_Address location) throws VM_PragmaInline {
  if (traceInducedGC) {
    VM_Address obj=VM_Magic.getMemoryAddress(location);
    if (!obj.isZero()) {
      TraceGenerator.rootEnumerate(obj);
    }
  }
 else {
    VM_Address obj=VM_Magic.getMemoryAddress(location);
    if (!obj.isZero()) {
      VM_Address addr=VM_Interface.refToAddress(obj);
      byte space=VMResource.getSpace(addr);
      if ((hi && space == LOW_SS_SPACE) || (!hi && space == HIGH_SS_SPACE))       VM_Magic.setMemoryAddress(location,CopySpace.forwardObject(obj));
    }
  }
}",0.8526682134570766
150223,"/** 
 * Allocate space (for an object)
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 * @param advice Statically-generated allocation advice for this allocation
 * @return The address of the first byte of the allocated region
 */
public final VM_Address alloc(int bytes,boolean isScalar,int allocator,AllocAdvice advice) throws VM_PragmaInline {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(bytes == (bytes & (~(BYTES_IN_ADDRESS - 1))));
  if (allocator == DEFAULT_SPACE && bytes > LOS_SIZE_THRESHOLD) {
    return los.alloc(isScalar,bytes);
  }
 else {
switch (allocator) {
case DEFAULT_SPACE:
      return ss.alloc(isScalar,bytes);
case IMMORTAL_SPACE:
    return immortal.alloc(isScalar,bytes);
case LOS_SPACE:
  return los.alloc(isScalar,bytes);
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
return VM_Address.zero();
}
}
}","/** 
 * Allocate space (for an object)
 * @param bytes The size of the space to be allocated (in bytes)
 * @param isScalar True if the object occupying this space will be a scalar
 * @param allocator The allocator number to be used for this allocation
 * @param advice Statically-generated allocation advice for this allocation
 * @return The address of the first byte of the allocated region
 */
public final VM_Address alloc(int bytes,boolean isScalar,int allocator) throws VM_PragmaInline {
switch (allocator) {
case DEFAULT_SPACE:
    return ss.alloc(isScalar,bytes);
case IMMORTAL_SPACE:
  return immortal.alloc(isScalar,bytes);
case LOS_SPACE:
return los.alloc(isScalar,bytes);
default :
if (VM_Interface.VerifyAssertions) VM_Interface.sysFail(""String_Node_Str"");
return VM_Address.zero();
}
}",0.8376623376623377
150224,"public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM.sysWrite(""String_Node_Str"",ticket);
        VM.sysWrite(""String_Node_Str"",id);
        VM.sysWrite(""String_Node_Str"",name);
        VM.sysWrite(""String_Node_Str"",serving);
        VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(waitTime),""String_Node_Str"");
        VM_Thread t=thread;
        if (t == null)         VM.sysWriteln(""String_Node_Str"");
 else {
          VM.sysWrite(""String_Node_Str"");
          t.dump(1);
          VM.sysWriteln(""String_Node_Str"",where);
        }
        VM.sysWriteln(""String_Node_Str"",localStart);
        for (int i=(serving + 90) % 100; i <= (serving % 100); i++) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          VM.sysWrite(i,""String_Node_Str"",servingHistory[i]);
          VM.sysWrite(""String_Node_Str"",tidHistory[i]);
          VM.sysWrite(""String_Node_Str"",startHistory[i]);
          VM.sysWrite(""String_Node_Str"",endHistory[i]);
          VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(startHistory[i] - localStart));
        }
      }
      if (waitTime > TIME_OUT) {
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM_Scheduler.dumpStack();
        VM_Interface.sysFail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWriteln(""String_Node_Str"",name);
  }
  VM_Magic.isync();
}","public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM.sysWrite(""String_Node_Str"",ticket);
        VM.sysWrite(""String_Node_Str"",id);
        VM.sysWrite(""String_Node_Str"",name);
        VM.sysWrite(""String_Node_Str"",serving);
        VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(waitTime),""String_Node_Str"");
        VM_Thread t=thread;
        if (t == null)         VM.sysWriteln(""String_Node_Str"");
 else {
          VM.sysWrite(""String_Node_Str"");
          t.dump(1);
          VM.sysWriteln(""String_Node_Str"",where);
        }
        VM.sysWriteln(""String_Node_Str"",localStart);
        for (int i=(serving + 90) % 100; i != serving; i=(i + 1) % 100) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          VM.sysWrite(""String_Node_Str"");
          VM.sysWrite(i,""String_Node_Str"",servingHistory[i]);
          VM.sysWrite(""String_Node_Str"",tidHistory[i]);
          VM.sysWrite(""String_Node_Str"",startHistory[i]);
          VM.sysWrite(""String_Node_Str"",endHistory[i]);
          VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(startHistory[i] - localStart));
        }
      }
      if (waitTime > TIME_OUT) {
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM_Scheduler.dumpStack();
        VM_Interface.sysFail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWriteln(""String_Node_Str"",name);
  }
  VM_Magic.isync();
}",0.9865361077111384
150225,"/** 
 * Process GC parameters.
 */
public static void processCommandLineArg(String arg) throws VM_PragmaInterruptible {
  Options.process(arg);
}","/** 
 * Process GC parameters.
 */
public static void processCommandLineArg(String arg) throws VM_PragmaInterruptible {
  if (!Options.process(arg)) {
    VM.sysWriteln(""String_Node_Str"" + p.value + arg);
    VM.sysExit(VM.exitStatusBogusCommandLineArg);
  }
}",0.7160493827160493
150226,"/** 
 * Common code shared by the JNI functions NewObjectA, NewObjectV, NewObject (object creation)
 * @param methodID the method ID for a constructor
 * @return a new object created by the specified constructor
 */
public static Object invokeInitializer(Class cls,int methodID,VM_Address argAddress,boolean isJvalue,boolean isDotDotStyle) throws Exception {
  VM_Method mth=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference[] argTypes=mth.getParameterTypes();
  Class[] argClasses=new Class[argTypes.length];
  for (int i=0; i < argClasses.length; i++) {
    argClasses[i]=argTypes[i].resolve().getClassForType();
  }
  Constructor constMethod=cls.getConstructor(argClasses);
  if (constMethod == null)   throw new Exception(""String_Node_Str"");
  Object argObjs[];
  if (isJvalue) {
    argObjs=packageParameterFromJValue(mth,argAddress);
  }
 else {
    if (isDotDotStyle) {
      VM_Address varargAddress=pushVarArgToSpillArea(methodID,false);
      argObjs=packageParameterFromVarArg(mth,varargAddress);
      VM_Address gluefp=VM_Magic.getCallerFramePointer(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
      argObjs=packageParameterFromDotArgSVR4(mth,gluefp,false);
    }
 else {
      argObjs=packageParameterFromVarArg(mth,argAddress);
      argObjs=packageParameterFromVarArgSVR4(mth,argAddress);
    }
  }
  return constMethod.newInstance(argObjs);
}","/** 
 * Common code shared by the JNI functions NewObjectA, NewObjectV, NewObject (object creation)
 * @param methodID the method ID for a constructor
 * @return a new object created by the specified constructor
 */
public static Object invokeInitializer(Class cls,int methodID,VM_Address argAddress,boolean isJvalue,boolean isDotDotStyle) throws Exception {
  VM_Method mth=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  Constructor constMethod=java.lang.reflect.JikesRVMSupport.createConstructor(mth);
  if (!mth.isPublic()) {
    constMethod.setAccessible(true);
  }
  Object argObjs[];
  if (isJvalue) {
    argObjs=packageParameterFromJValue(mth,argAddress);
  }
 else {
    if (isDotDotStyle) {
      VM_Address varargAddress=pushVarArgToSpillArea(methodID,false);
      argObjs=packageParameterFromVarArg(mth,varargAddress);
      VM_Address gluefp=VM_Magic.getCallerFramePointer(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
      argObjs=packageParameterFromDotArgSVR4(mth,gluefp,false);
    }
 else {
      argObjs=packageParameterFromVarArg(mth,argAddress);
      argObjs=packageParameterFromVarArgSVR4(mth,argAddress);
    }
  }
  return constMethod.newInstance(argObjs);
}",0.8238851095993953
150227,"/** 
 * Common code shared by the JNI functions Call<type>Method (virtual method invocation)
 * @param obj the object instance 
 * @param methodID the method ID
 * @param expectReturnType the return type for checking purpose
 * @param skip4Args  true if the calling JNI Function takes 4 args before the varargfalse if the calling JNI Function takes 3 args before the vararg
 * @return an object that may be the return object or a wrapper for the primitive return value 
 */
public static Object invokeWithDotDotVarArg(Object obj,int methodID,VM_TypeReference expectReturnType,boolean skip4Args) throws Exception {
  VM_Address varargAddress=pushVarArgToSpillArea(methodID,skip4Args);
  return packageAndInvoke(obj,methodID,varargAddress,expectReturnType,skip4Args,AIX_VARARG);
  VM_Address glueFP=VM_Magic.getCallerFramePointer(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
  return packageAndInvoke(obj,methodID,glueFP,expectReturnType,skip4Args,SVR4_DOTARG);
}","/** 
 * Common code shared by the JNI functions Call<type>Method (virtual method invocation)
 * @param obj the object instance 
 * @param methodID the method ID
 * @param expectReturnType the return type for checking purpose
 * @param skip4Args  true if the calling JNI Function takes 4 args before the varargfalse if the calling JNI Function takes 3 args before the vararg
 * @return an object that may be the return object or a wrapper for the primitive return value 
 */
public static Object invokeWithDotDotVarArg(Object obj,int methodID,VM_TypeReference expectReturnType,boolean skip4Args) throws Exception, VM_PragmaNoInline {
  VM_Address varargAddress=pushVarArgToSpillArea(methodID,skip4Args);
  return packageAndInvoke(obj,methodID,varargAddress,expectReturnType,skip4Args,AIX_VARARG);
  VM_Address glueFP=VM_Magic.getCallerFramePointer(VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer()));
  return packageAndInvoke(obj,methodID,glueFP,expectReturnType,skip4Args,SVR4_DOTARG);
}",0.9903699949315764
150228,"/** 
 * This method supports var args passed from C In the AIX C convention, the caller keeps the first 8 words in registers and  the rest in the spill area in the caller frame.  The callee will push the values in registers out to the spill area of the caller frame and use the beginning  address of this spill area as the var arg address For the JNI functions that takes var args, their prolog code will save the var arg in the glue frame because the values in the register may be lost by  subsequent calls. This method copies the var arg values that were saved earlier in glue frame into the spill area of the original caller, thereby doing the work that the callee normally performs in the AIX C convention. NOTE:  this method assumes that it is immediately above the  invokeWithDotDotVarArg frame, the JNI frame, the glue frame and  the C caller frame in the respective order.   Therefore, this method will not work if called from anywhere else |  fp  | <- VM_JNIEnvironment.pushVarArgToSpillArea | mid  | | xxx  | |      | |      | |------|    |  fp  | <- VM_JNIEnvironment.invokeWithDotDotVarArg frame | mid  | | xxx  | |      | |      | |      | |------|    |  fp  | <- JNI method frame | mid  | | xxx  | |      | |      | |      | |------| |  fp  | <- glue frame | mid  | + xxx  + | r3   |   volatile save area | r4   | | r5   | | r6   |   vararg GPR[6-10]save area   <- VARARG_AREA_OFFSET | r7   | | r8   | | r9   | | r10  | | fpr1 |   vararg FPR[1-3] save area (also used as volatile FPR[1-6] save area) | fpr2 | | fpr3 | | fpr4 | | fpr5 | + fpr6 + | r13  |   nonvolatile GPR[13-31] save area | ...  | + r31  + | fpr14|   nonvolatile FPR[14-31] save area | ...  | | fpr31| |topjav|   offset to preceding Java to C glue frame |------|   | fp   | <- Native C caller frame | cr   | | lr   | | resv | | resv | + toc  + |   0  |    spill area initially not filled |   1  |    to be filled by this method |   2  | |   3  | |   4  | |   5  | |   6  | |   7  | |   8  |    spill area already filled by caller |   9  | |      | |      | |      |
 * @param methodID a VM_MemberReference id
 * @param skip4Args if true, the calling JNI function has 4 args before the varargif false, the calling JNI function has 3 args before the vararg
 * @return the starting address of the vararg in the caller stack frame
 */
private static VM_Address pushVarArgToSpillArea(int methodID,boolean skip4Args) throws Exception {
  int glueFrameSize=JNI_GLUE_FRAME_SIZE;
  VM_Address gluefp=VM_Magic.getMemoryAddress(VM_Magic.getFramePointer().add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  int varargGPROffset=VARARG_AREA_OFFSET + (skip4Args ? BYTES_IN_ADDRESS : 0);
  int varargFPROffset=varargGPROffset + 5 * BYTES_IN_ADDRESS;
  int spillAreaLimit=glueFrameSize + NATIVE_FRAME_HEADER_SIZE + 8 * BYTES_IN_ADDRESS;
  int spillAreaOffset=glueFrameSize + NATIVE_FRAME_HEADER_SIZE + (skip4Args ? 4 * BYTES_IN_ADDRESS : 3 * BYTES_IN_ADDRESS);
  VM_Address varargAddress=gluefp.add(spillAreaOffset);
  VM_Method targetMethod=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference[] argTypes=targetMethod.getParameterTypes();
  int argCount=argTypes.length;
  for (int i=0; i < argCount && spillAreaOffset < spillAreaLimit; i++) {
    VM_Word hiword, loword;
    if (argTypes[i].isFloatType() || argTypes[i].isDoubleType()) {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargFPROffset));
      varargFPROffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr) {
        loword=VM_Magic.getMemoryWord(gluefp.add(varargFPROffset));
        varargFPROffset+=BYTES_IN_ADDRESS;
      }
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr) {
        VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),loword);
        spillAreaOffset+=BYTES_IN_ADDRESS;
      }
    }
 else     if (argTypes[i].isLongType()) {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
      varargGPROffset+=BYTES_IN_ADDRESS;
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr && spillAreaOffset < spillAreaLimit) {
        loword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
        varargGPROffset+=BYTES_IN_ADDRESS;
        VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),loword);
        spillAreaOffset+=BYTES_IN_ADDRESS;
      }
    }
 else {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
      varargGPROffset+=BYTES_IN_ADDRESS;
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
    }
  }
  return varargAddress;
}","/** 
 * This method supports var args passed from C In the AIX C convention, the caller keeps the first 8 words in registers and  the rest in the spill area in the caller frame.  The callee will push the values in registers out to the spill area of the caller frame and use the beginning  address of this spill area as the var arg address For the JNI functions that takes var args, their prolog code will save the var arg in the glue frame because the values in the register may be lost by  subsequent calls. This method copies the var arg values that were saved earlier in glue frame into the spill area of the original caller, thereby doing the work that the callee normally performs in the AIX C convention. NOTE:  this method assumes that it is immediately above the  invokeWithDotDotVarArg frame, the JNI frame, the glue frame and  the C caller frame in the respective order.   Therefore, this method will not work if called from anywhere else |  fp  | <- VM_JNIEnvironment.pushVarArgToSpillArea | mid  | | xxx  | |      | |      | |------|    |  fp  | <- VM_JNIEnvironment.invokeWithDotDotVarArg frame | mid  | | xxx  | |      | |      | |      | |------|    |  fp  | <- JNI method frame | mid  | | xxx  | |      | |      | |      | |------| |  fp  | <- glue frame | mid  | + xxx  + | r3   |   volatile save area | r4   | | r5   | | r6   |   vararg GPR[6-10]save area   <- VARARG_AREA_OFFSET | r7   | | r8   | | r9   | | r10  | | fpr1 |   vararg FPR[1-3] save area (also used as volatile FPR[1-6] save area) | fpr2 | | fpr3 | | fpr4 | | fpr5 | + fpr6 + | r13  |   nonvolatile GPR[13-31] save area | ...  | + r31  + | fpr14|   nonvolatile FPR[14-31] save area | ...  | | fpr31| |topjav|   offset to preceding Java to C glue frame |------|   | fp   | <- Native C caller frame | cr   | | lr   | | resv | | resv | + toc  + |   0  |    spill area initially not filled |   1  |    to be filled by this method |   2  | |   3  | |   4  | |   5  | |   6  | |   7  | |   8  |    spill area already filled by caller |   9  | |      | |      | |      |
 * @param methodID a VM_MemberReference id
 * @param skip4Args if true, the calling JNI function has 4 args before the varargif false, the calling JNI function has 3 args before the vararg
 * @return the starting address of the vararg in the caller stack frame
 */
private static VM_Address pushVarArgToSpillArea(int methodID,boolean skip4Args) throws Exception, VM_PragmaNoInline {
  int glueFrameSize=JNI_GLUE_FRAME_SIZE;
  VM_Address gluefp=VM_Magic.getMemoryAddress(VM_Magic.getFramePointer().add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  gluefp=VM_Magic.getMemoryAddress(gluefp.add(VM_Constants.STACKFRAME_FRAME_POINTER_OFFSET));
  int varargGPROffset=VARARG_AREA_OFFSET + (skip4Args ? BYTES_IN_ADDRESS : 0);
  int varargFPROffset=varargGPROffset + 5 * BYTES_IN_ADDRESS;
  int spillAreaLimit=glueFrameSize + NATIVE_FRAME_HEADER_SIZE + 8 * BYTES_IN_ADDRESS;
  int spillAreaOffset=glueFrameSize + NATIVE_FRAME_HEADER_SIZE + (skip4Args ? 4 * BYTES_IN_ADDRESS : 3 * BYTES_IN_ADDRESS);
  VM_Address varargAddress=gluefp.add(spillAreaOffset);
  VM_Method targetMethod=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference[] argTypes=targetMethod.getParameterTypes();
  int argCount=argTypes.length;
  for (int i=0; i < argCount && spillAreaOffset < spillAreaLimit; i++) {
    VM_Word hiword, loword;
    if (argTypes[i].isFloatType() || argTypes[i].isDoubleType()) {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargFPROffset));
      varargFPROffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr) {
        loword=VM_Magic.getMemoryWord(gluefp.add(varargFPROffset));
        varargFPROffset+=BYTES_IN_ADDRESS;
      }
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr) {
        VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),loword);
        spillAreaOffset+=BYTES_IN_ADDRESS;
      }
    }
 else     if (argTypes[i].isLongType()) {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
      varargGPROffset+=BYTES_IN_ADDRESS;
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
      if (VM.BuildFor32Addr && spillAreaOffset < spillAreaLimit) {
        loword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
        varargGPROffset+=BYTES_IN_ADDRESS;
        VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),loword);
        spillAreaOffset+=BYTES_IN_ADDRESS;
      }
    }
 else {
      hiword=VM_Magic.getMemoryWord(gluefp.add(varargGPROffset));
      varargGPROffset+=BYTES_IN_ADDRESS;
      VM_Magic.setMemoryWord(gluefp.add(spillAreaOffset),hiword);
      spillAreaOffset+=BYTES_IN_ADDRESS;
    }
  }
  return varargAddress;
}",0.9980530792089354
150229,"public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM.sysWrite(""String_Node_Str"",ticket);
        VM.sysWrite(""String_Node_Str"",id);
        VM.sysWrite(""String_Node_Str"",name);
        VM.sysWriteln(""String_Node_Str"",serving);
        VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(waitTime),""String_Node_Str"");
        VM_Thread t=thread;
        if (t == null)         VM.sysWriteln(""String_Node_Str"");
 else {
          VM.sysWrite(""String_Node_Str"");
          t.dump(1);
          VM.sysWriteln(""String_Node_Str"",where);
        }
        VM.sysWriteln(""String_Node_Str"",localStart);
        for (int i=(serving - 10) % 100; i <= (serving % 100); i++) {
          VM.sysWrite(i,""String_Node_Str"",servingHistory[i]);
          VM.sysWrite(""String_Node_Str"",tidHistory[i]);
          VM.sysWrite(""String_Node_Str"",startHistory[i]);
          VM.sysWrite(""String_Node_Str"",endHistory[i]);
          VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(startHistory[i] - localStart));
        }
      }
      if (waitTime > TIME_OUT) {
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM_Scheduler.dumpStack();
        VM_Interface.sysFail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWriteln(""String_Node_Str"",name);
  }
  VM_Magic.isync();
}","public void acquire(){
  int ticket=VM_Synchronization.fetchAndAdd(this,dispenserFieldOffset,1);
  int retryCountdown=TIMEOUT_CHECK_FREQ;
  long localStart=0;
  long lastSlowReport=0;
  while (ticket != serving) {
    if (localStart == 0)     lastSlowReport=localStart=VM_Time.cycles();
    if (--retryCountdown == 0) {
      retryCountdown=TIMEOUT_CHECK_FREQ;
      long now=VM_Time.cycles();
      long lastReportDuration=now - lastSlowReport;
      long waitTime=now - localStart;
      if (lastReportDuration > SLOW_THRESHOLD + VM_Time.millisToCycles(200 * (VM_Thread.getCurrentThread().getIndex() % 5))) {
        lastSlowReport=now;
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM.sysWrite(""String_Node_Str"",ticket);
        VM.sysWrite(""String_Node_Str"",id);
        VM.sysWrite(""String_Node_Str"",name);
        VM.sysWriteln(""String_Node_Str"",serving);
        VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(waitTime),""String_Node_Str"");
        VM_Thread t=thread;
        if (t == null)         VM.sysWriteln(""String_Node_Str"");
 else {
          VM.sysWrite(""String_Node_Str"");
          t.dump(1);
          VM.sysWriteln(""String_Node_Str"",where);
        }
        VM.sysWriteln(""String_Node_Str"",localStart);
        for (int i=(serving + 90) % 100; i <= (serving % 100); i++) {
          if (VM.VerifyAssertions)           VM._assert(i >= 0 && i < 100);
          VM.sysWrite(i,""String_Node_Str"",servingHistory[i]);
          VM.sysWrite(""String_Node_Str"",tidHistory[i]);
          VM.sysWrite(""String_Node_Str"",startHistory[i]);
          VM.sysWrite(""String_Node_Str"",endHistory[i]);
          VM.sysWriteln(""String_Node_Str"",VM_Time.cyclesToMillis(startHistory[i] - localStart));
        }
      }
      if (waitTime > TIME_OUT) {
        VM.sysWrite(""String_Node_Str"");
        VM_Thread.getCurrentThread().dump(1);
        VM_Scheduler.dumpStack();
        VM_Interface.sysFail(""String_Node_Str"");
      }
    }
  }
  if (REPORT_SLOW) {
    servingHistory[serving % 100]=serving;
    tidHistory[serving % 100]=VM_Thread.getCurrentThread().getIndex();
    startHistory[serving % 100]=VM_Time.cycles();
    setLocker(VM_Time.cycles(),VM_Thread.getCurrentThread(),-1);
  }
  if (verbose > 1) {
    VM.sysWrite(""String_Node_Str"");
    thread.dump();
    VM.sysWrite(""String_Node_Str"",id);
    VM.sysWriteln(""String_Node_Str"",name);
  }
  VM_Magic.isync();
}",0.9828595317725752
150230,"/** 
 * Begin vm execution. The following machine registers are set by ""C"" bootstrap program  before calling this method: JTOC_POINTER        - required for accessing globals FRAME_POINTER       - required for accessing locals THREAD_ID_REGISTER  - required for method prolog (stack overflow check)
 * @exception Exception
 */
public static void boot() throws Exception, VM_PragmaLogicallyUninterruptible {
  writingBootImage=false;
  runningVM=true;
  runningAsSubsystem=false;
  verboseBoot=VM_BootRecord.the_boot_record.verboseBoot;
  sysWriteLockOffset=VM_Entrypoints.sysWriteLockField.getOffset();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_ProcessorLocalState.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread currentThread=VM_Processor.getCurrentProcessor().activeThread;
  currentThread.stackLimit=VM_Magic.objectAsAddress(currentThread.stack).add(STACK_SIZE_GUARD);
  VM_Processor.getCurrentProcessor().activeThreadStackLimit=currentThread.stackLimit;
  if (!BuildForSingleVirtualProcessor)   VM_Processor.getCurrentProcessor().pthread_id=VM_SysCall.sysPthreadSelf();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.setupProcessor(VM_Processor.getCurrentProcessor());
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"",VM_Magic.objectAsAddress(VM_BootRecord.the_boot_record));
  MM_Interface.boot(VM_BootRecord.the_boot_record);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageOne();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_BaselineCompiler.initOptions();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  createClassObjects();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.fetchCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.earlyProcessCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.postBoot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String vmClasses=VM_CommandLineArgs.getVMClasses();
  VM_ClassLoader.boot(vmClasses);
  VM_SystemClassLoader.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageTwo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Lock.boot();
  if (BuildForHPM) {
    if (VM_HardwarePerformanceMonitors.enabled()) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWriteln(""String_Node_Str"");
      VM_HardwarePerformanceMonitors.boot();
    }
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Scheduler.boot();
  com.ibm.JikesRVM.jni.VM_JNIEnvironment.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread.getCurrentThread().initializeJNIEnv();
  runClassInitializer(""String_Node_Str"");
  VM_HardwarePerformanceMonitors.setUpHPMinfo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  VM_FileSystem.initializeStandardStreams();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM.fullyBooted=true;
  MM_Interface.fullyBootedVM();
  VM_BaselineCompiler.fullyBootedVM();
  VM_EdgeCounts.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_RuntimeCompiler.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String[] applicationArguments=VM_CommandLineArgs.lateProcessCommandLineArguments();
  if (VM.verboseClassLoading || verboseBoot >= 1)   VM.sysWrite(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  JikesRVMSocketImpl.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  com.ibm.JikesRVM.adaptive.VM_Controller.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  if (applicationArguments.length == 0) {
    pleaseSpecifyAClass();
  }
  if (applicationArguments.length > 0 && !VM_TypeDescriptorParsing.isJavaClassName(applicationArguments[0])) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(applicationArguments[0]);
    VM.sysWrite(""String_Node_Str"");
    pleaseSpecifyAClass();
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  Thread xx=new MainThread(applicationArguments);
  VM_Address yy=VM_Magic.objectAsAddress(xx);
  VM_Thread mainThread=(VM_Thread)VM_Magic.addressAsObject(yy);
  VM_Callbacks.notifyAppRunStart(""String_Node_Str"",0);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  mainThread.start();
  VM_Thread t=new DebuggerThread();
  t.start(VM_Scheduler.debuggerQueue);
  if (VM_HardwarePerformanceMonitors.enabled()) {
    if (!VM_HardwarePerformanceMonitors.thread_group) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWrite(""String_Node_Str"");
      VM_SysCall.sysHPMresetMyThread();
    }
  }
  if (VM.TraceThreads)   VM_Scheduler.trace(""String_Node_Str"",""String_Node_Str"");
  VM_Thread.terminate();
  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);
}","/** 
 * Begin vm execution. The following machine registers are set by ""C"" bootstrap program  before calling this method: JTOC_POINTER        - required for accessing globals FRAME_POINTER       - required for accessing locals THREAD_ID_REGISTER  - required for method prolog (stack overflow check)
 * @exception Exception
 */
public static void boot() throws Exception, VM_PragmaLogicallyUninterruptible {
  writingBootImage=false;
  runningVM=true;
  runningAsSubsystem=false;
  verboseBoot=VM_BootRecord.the_boot_record.verboseBoot;
  sysWriteLockOffset=VM_Entrypoints.sysWriteLockField.getOffset();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_ProcessorLocalState.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread currentThread=VM_Processor.getCurrentProcessor().activeThread;
  currentThread.stackLimit=VM_Magic.objectAsAddress(currentThread.stack).add(STACK_SIZE_GUARD);
  VM_Processor.getCurrentProcessor().activeThreadStackLimit=currentThread.stackLimit;
  currentThread.startQuantum(VM_Time.cycles());
  if (!BuildForSingleVirtualProcessor)   VM_Processor.getCurrentProcessor().pthread_id=VM_SysCall.sysPthreadSelf();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.setupProcessor(VM_Processor.getCurrentProcessor());
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"",VM_Magic.objectAsAddress(VM_BootRecord.the_boot_record));
  MM_Interface.boot(VM_BootRecord.the_boot_record);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageOne();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_BaselineCompiler.initOptions();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  createClassObjects();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.fetchCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_CommandLineArgs.earlyProcessCommandLineArguments();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  MM_Interface.postBoot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String vmClasses=VM_CommandLineArgs.getVMClasses();
  VM_ClassLoader.boot(vmClasses);
  VM_SystemClassLoader.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Time.bootStageTwo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Lock.boot();
  if (BuildForHPM) {
    if (VM_HardwarePerformanceMonitors.enabled()) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWriteln(""String_Node_Str"");
      VM_HardwarePerformanceMonitors.boot();
    }
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Scheduler.boot();
  com.ibm.JikesRVM.jni.VM_JNIEnvironment.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_Thread.getCurrentThread().initializeJNIEnv();
  runClassInitializer(""String_Node_Str"");
  VM_HardwarePerformanceMonitors.setUpHPMinfo();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  runClassInitializer(""String_Node_Str"");
  VM_FileSystem.initializeStandardStreams();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM.fullyBooted=true;
  MM_Interface.fullyBootedVM();
  VM_BaselineCompiler.fullyBootedVM();
  VM_EdgeCounts.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  VM_RuntimeCompiler.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  String[] applicationArguments=VM_CommandLineArgs.lateProcessCommandLineArguments();
  if (VM.verboseClassLoading || verboseBoot >= 1)   VM.sysWrite(""String_Node_Str"");
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  JikesRVMSocketImpl.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  com.ibm.JikesRVM.adaptive.VM_Controller.boot();
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  if (applicationArguments.length == 0) {
    pleaseSpecifyAClass();
  }
  if (applicationArguments.length > 0 && !VM_TypeDescriptorParsing.isJavaClassName(applicationArguments[0])) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(applicationArguments[0]);
    VM.sysWrite(""String_Node_Str"");
    pleaseSpecifyAClass();
  }
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  Thread xx=new MainThread(applicationArguments);
  VM_Address yy=VM_Magic.objectAsAddress(xx);
  VM_Thread mainThread=(VM_Thread)VM_Magic.addressAsObject(yy);
  VM_Callbacks.notifyAppRunStart(""String_Node_Str"",0);
  if (verboseBoot >= 1)   VM.sysWriteln(""String_Node_Str"");
  mainThread.start();
  VM_Thread t=new DebuggerThread();
  t.start(VM_Scheduler.debuggerQueue);
  if (VM_HardwarePerformanceMonitors.enabled()) {
    if (!VM_HardwarePerformanceMonitors.thread_group) {
      if (VM_HardwarePerformanceMonitors.verbose >= 2)       VM.sysWrite(""String_Node_Str"");
      VM_SysCall.sysHPMresetMyThread();
    }
  }
  if (VM.TraceThreads)   VM_Scheduler.trace(""String_Node_Str"",""String_Node_Str"");
  VM_Thread.terminate();
  if (VM.VerifyAssertions)   VM._assert(VM.NOT_REACHED);
}",0.9964958388085852
150231,"/** 
 * Called from VM_Processor.dispatch when a thread is about to stop executing.
 */
void endQuantum(long now){
  if (startCycle != -1) {
    totalCycles+=now - startCycle;
  }
  startCycle=0;
}","/** 
 * Called from VM_Processor.dispatch when a thread is about to stop executing.
 */
void endQuantum(long now){
  totalCycles+=now - startCycle;
  startCycle=0;
}",0.9116022099447514
150232,"/** 
 * Common code shared by the JNI functions NewObjectA, NewObjectV, NewObject (object creation)
 * @param methodID the method ID for a constructor
 * @return a new object created by the specified constructor
 */
static Object invokeInitializer(Class cls,int methodID,VM_Address argAddress,boolean isJvalue,boolean isDotDotStyle) throws Exception {
  VM_Method mth=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  VM_TypeReference[] argTypes=mth.getParameterTypes();
  Class[] argClasses=new Class[argTypes.length];
  for (int i=0; i < argClasses.length; i++) {
    argClasses[i]=argTypes[i].resolve().getClassForType();
  }
  Constructor constMethod=java.lang.reflect.JikesRVMSupport.createConstructor(mth);
  if (!mth.isPublic()) {
    constMethod.setAccessible(true);
  }
  VM_Address varargAddress;
  if (isDotDotStyle)   varargAddress=getVarArgAddress(false);
 else   varargAddress=argAddress;
  Object argObjs[];
  if (isJvalue)   argObjs=packageParameterFromJValue(mth,argAddress);
 else   argObjs=packageParameterFromVarArg(mth,varargAddress);
  return constMethod.newInstance(argObjs);
}","/** 
 * Common code shared by the JNI functions NewObjectA, NewObjectV, NewObject (object creation)
 * @param methodID the method ID for a constructor
 * @return a new object created by the specified constructor
 */
static Object invokeInitializer(Class cls,int methodID,VM_Address argAddress,boolean isJvalue,boolean isDotDotStyle) throws Exception {
  VM_Method mth=VM_MemberReference.getMemberRef(methodID).asMethodReference().resolve();
  Constructor constMethod=java.lang.reflect.JikesRVMSupport.createConstructor(mth);
  if (!mth.isPublic()) {
    constMethod.setAccessible(true);
  }
  VM_Address varargAddress;
  if (isDotDotStyle)   varargAddress=getVarArgAddress(false);
 else   varargAddress=argAddress;
  Object argObjs[];
  if (isJvalue)   argObjs=packageParameterFromJValue(mth,argAddress);
 else   argObjs=packageParameterFromVarArg(mth,varargAddress);
  return constMethod.newInstance(argObjs);
}",0.8954344624447718
150233,"/** 
 * This method supports var args passed from C. In the Linux Intel C convention, the caller places the args immediately above the saved return address, starting with the first arg. <br> For the JNI functions that takes var args, their prolog code will save the var arg in the glue frame because the values in the register may be lost by  subsequent calls. <br> This method copies the var arg values that were saved earlier in glue frame into the spill area of the original caller, thereby doing the work that the callee normally performs in the AIX C convention. <br> NOTE: This method contains internal stack pointer. For now we assume that the stack will not be relocatable while native code is running because native code can hold an address into the stack, so this code is OK, but this is an issue to be resolved later. <br> NOTE:  this method assumes that it is immediately above the  invokeWithDotDotVarArg frame, the JNI frame, the glue frame and  the C caller frame in the respective order.   Therefore, this method will not work if called from anywhere else. <pre> low address |  fp  | <- VM_JNIEnvironment.getVarArgAddress | mid  | |      | |      | |------|    |  fp  | <- VM_JNIEnvironment.invokeWithDotDotVarArg frame | mid  | | ...  | |      | |      | |------|    |  fp  | <- JNI method frame | mid  | | ...  | | arg 0|    args copied by JNI prolog (3 for static, nonvirtual,  | arg 1|    or 4 for virtual) | arg 2| |      | |      | |------| | fp   | <- Native C caller frame |return| | arg 0|     | arg 1|     | arg 2| | arg 3| | arg 4| | arg 5| | arg 6| | arg 7| | arg 8|     | arg 9| |      | |      | |      | high address </pre>
 * @param skip4Args if true, the calling JNI function has 4 args before the varargif false, the calling JNI function has 3 args before the vararg
 * @return the starting address of the vararg in the caller stack frame
 */
private static VM_Address getVarArgAddress(boolean skip4Args){
  VM_Address fp=VM_Magic.getFramePointer();
  fp=VM_Magic.getMemoryAddress(fp);
  fp=VM_Magic.getMemoryAddress(fp);
  return (fp.add(2 * 4 + (skip4Args ? 4 * 4 : 3 * 4)));
}","/** 
 * This method supports var args passed from C. In the Linux Intel C convention, the caller places the args immediately above the saved return address, starting with the first arg. <br> For the JNI functions that takes var args, their prolog code will save the var arg in the glue frame because the values in the register may be lost by  subsequent calls. <br> This method copies the var arg values that were saved earlier in glue frame into the spill area of the original caller, thereby doing the work that the callee normally performs in the AIX C convention. <br> NOTE: This method contains internal stack pointer. For now we assume that the stack will not be relocatable while native code is running because native code can hold an address into the stack, so this code is OK, but this is an issue to be resolved later. <br> NOTE:  this method assumes that it is immediately above the  invokeWithDotDotVarArg frame, the JNI frame, the glue frame and  the C caller frame in the respective order.   Therefore, this method will not work if called from anywhere else. <pre> low address |  fp  | <- VM_JNIEnvironment.getVarArgAddress | mid  | |      | |      | |------|    |  fp  | <- VM_JNIEnvironment.invokeWithDotDotVarArg frame | mid  | | ...  | |      | |      | |------|    |  fp  | <- JNI method frame | mid  | | ...  | | arg 0|    args copied by JNI prolog (3 for static, nonvirtual,  | arg 1|    or 4 for virtual) | arg 2| |      | |      | |------| | fp   | <- Native C caller frame |return| | arg 0|     | arg 1|     | arg 2| | arg 3| | arg 4| | arg 5| | arg 6| | arg 7| | arg 8|     | arg 9| |      | |      | |      | high address </pre>
 * @param skip4Args if true, the calling JNI function has 4 args before the varargif false, the calling JNI function has 3 args before the vararg
 * @return the starting address of the vararg in the caller stack frame
 */
private static VM_Address getVarArgAddress(boolean skip4Args) throws VM_PragmaNoInline {
  VM_Address fp=VM_Magic.getFramePointer();
  fp=VM_Magic.getMemoryAddress(fp);
  fp=VM_Magic.getMemoryAddress(fp);
  return (fp.add(2 * 4 + (skip4Args ? 4 * 4 : 3 * 4)));
}",0.9938852304797742
150234,"/** 
 * Run <clinit> method of specified class, if that class appears  in bootimage and actually has a clinit method (we are flexible to allow one list of classes to work with different bootimages and  different version of classpath (eg 0.05 vs. cvs head). This method is called only while the VM boots.
 * @param className
 */
static void runClassInitializer(String className) throws VM_PragmaInterruptible {
  if (verboseBoot >= 2) {
    sysWrite(""String_Node_Str"");
    sysWriteln(className);
  }
  VM_Atom classDescriptor=VM_Atom.findOrCreateAsciiAtom(className.replace('.','/')).descriptorFromClassName();
  VM_TypeReference tRef=VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),classDescriptor);
  VM_Class cls=(VM_Class)tRef.peekResolvedType();
  if (cls != null && cls.isInBootImage()) {
    VM_Method clinit=cls.getClassInitializerMethod();
    if (clinit != null) {
      clinit.compile();
      if (verboseBoot >= 10)       VM.sysWriteln(""String_Node_Str"" + clinit);
      try {
        VM_Magic.invokeClassInitializer(clinit.getCurrentInstructions());
      }
 catch (      Error e) {
        throw e;
      }
catch (      Throwable t) {
        ExceptionInInitializerError eieio=new ExceptionInInitializerError(""String_Node_Str"" + className);
        eieio.initCause(t);
        throw eieio;
      }
    }
 else {
      if (verboseBoot >= 10)       VM.sysWriteln(""String_Node_Str"");
    }
    cls.setAllFinalStaticJTOCEntries();
  }
}","/** 
 * Run <clinit> method of specified class, if that class appears  in bootimage and actually has a clinit method (we are flexible to allow one list of classes to work with different bootimages and  different version of classpath (eg 0.05 vs. cvs head). This method is called only while the VM boots.
 * @param className
 */
static void runClassInitializer(String className) throws VM_PragmaInterruptible {
  if (verboseBoot >= 2) {
    sysWrite(""String_Node_Str"");
    sysWriteln(className);
  }
  VM_Atom classDescriptor=VM_Atom.findOrCreateAsciiAtom(className.replace('.','/')).descriptorFromClassName();
  VM_TypeReference tRef=VM_TypeReference.findOrCreate(VM_SystemClassLoader.getVMClassLoader(),classDescriptor);
  VM_Class cls=(VM_Class)tRef.peekResolvedType();
  if (cls != null && cls.isInBootImage()) {
    VM_Method clinit=cls.getClassInitializerMethod();
    if (clinit != null) {
      clinit.compile();
      if (verboseBoot >= 10)       VM.sysWriteln(""String_Node_Str"" + clinit);
      try {
        VM_Magic.invokeClassInitializer(clinit.getCurrentInstructions());
      }
 catch (      Error e) {
        throw e;
      }
catch (      Throwable t) {
        ExceptionInInitializerError eieio=new ExceptionInInitializerError(""String_Node_Str"" + className);
        eieio.initCause(t);
        throw eieio;
      }
      clinit.invalidateCompiledMethod(clinit.getCurrentCompiledMethod());
    }
 else {
      if (verboseBoot >= 10)       VM.sysWriteln(""String_Node_Str"");
    }
    cls.setAllFinalStaticJTOCEntries();
  }
}",0.9754152823920266
150235,"/** 
 * Generate inline code sequence for specified method.
 * @param methodToBeCalled: method whose name indicates semantics of code to be generated
 * @return true if there was magic defined for the method
 */
private boolean generateInlineCode(VM_MethodReference methodToBeCalled){
  VM_Atom methodName=methodToBeCalled.getName();
  if (methodToBeCalled.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=methodToBeCalled.getParameterTypes();
    int paramWords=methodToBeCalled.getParameterWords();
    int gp=FIRST_OS_PARAMETER_GPR;
    int fp=FIRST_OS_PARAMETER_FPR;
    int stackIndex=paramWords;
    int paramBytes=(VM.BuildFor64Addr ? args.length : paramWords) * BYTES_IN_STACKSLOT;
    int callee_param_index=-BYTES_IN_STACKSLOT - paramBytes;
    for (int i=0; i < args.length; i++) {
      VM_TypeReference t=args[i];
      if (t.isLongType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_LONG;
        if (VM.BuildFor64Addr) {
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekLong(gp,gp,stackIndex);
            gp++;
          }
 else {
            peekLong(S0,S0,stackIndex);
            asm.emitSTD(S0,callee_param_index - BYTES_IN_LONG,FP);
          }
        }
 else {
          gp+=(gp + 1) & 0x01;
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex);
          }
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex + 1);
          }
 else {
            peekLong(S0,S1,stackIndex);
            asm.emitSTW(S0,callee_param_index - BYTES_IN_LONG,FP);
            asm.emitSTW(S1,callee_param_index - BYTES_IN_INT,FP);
          }
        }
      }
 else       if (t.isFloatType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekFloat(fp++,stackIndex);
        }
 else {
          peekFloat(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFS(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_FLOAT,FP);
        }
      }
 else       if (t.isDoubleType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_DOUBLE;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekDouble(fp++,stackIndex);
        }
 else {
          peekDouble(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFD(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_DOUBLE,FP);
        }
      }
 else       if (t.isIntLikeType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekInt(gp++,stackIndex);
        }
 else {
          peekInt(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
 else {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekAddr(gp++,stackIndex);
        }
 else {
          peekAddr(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
    }
    if (VM.VerifyAssertions) {
      VM._assert(stackIndex == 0);
    }
    VM_Field ip=VM_Entrypoints.getSysCallField(methodName.toString());
    generateSysCall(paramBytes,ip);
    discardSlots(paramWords);
    VM_TypeReference rtype=methodToBeCalled.getReturnType();
    if (rtype.isIntLikeType()) {
      pushInt(T0);
    }
 else     if (rtype.isWordType() || rtype.isReferenceType()) {
      pushAddr(T0);
    }
 else     if (rtype.isDoubleType()) {
      pushDouble(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isFloatType()) {
      pushFloat(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isLongType()) {
      pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
    }
  }
 else   if (methodName == VM_MagicNames.getFramePointer) {
    pushAddr(FP);
  }
 else   if (methodName == VM_MagicNames.getCallerFramePointer) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setCallerFramePointer) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getCompiledMethodID) {
    popAddr(T0);
    asm.emitLInt(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
    pushInt(T1);
  }
 else   if (methodName == VM_MagicNames.setCompiledMethodID) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getNextInstructionAddress) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setNextInstructionAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getReturnAddressLocation) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    asm.emitADDI(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.getTocPointer || methodName == VM_MagicNames.getJTOC) {
    pushAddr(JTOC);
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    pushAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    popAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    if (VM.BuildFor64Addr) {
      asm.emitMFTB(T1);
    }
 else {
      int label=asm.getMachineCodeIndex();
      asm.emitMFTBU(T0);
      asm.emitMFTB(T1);
      asm.emitMFTBU(T2);
      asm.emitCMP(T0,T2);
      asm.emitBC(NE,label);
    }
    pushLong(T0,T1);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    peekAddr(T0,0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    asm.emitBCCTRL();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningVoid) {
    generateMethodInvocation();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningInt) {
    generateMethodInvocation();
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningLong) {
    generateMethodInvocation();
    pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
    generateMethodInvocation();
    pushFloat(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
    generateMethodInvocation();
    pushDouble(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningObject) {
    generateMethodInvocation();
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    VM_Array type=methodToBeCalled.getType().resolve().asArray();
    emit_resolved_newarray(type);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    emit_arraylength();
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iaload();
    }
 else {
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitLAddrX(T2,T0,T1);
      pushAddr(T2);
    }
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iastore();
    }
 else {
      popAddr(T2);
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitSTAddrX(T2,T0,T1);
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLIntX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset || methodName == VM_MagicNames.getWordAtOffset || methodName == VM_MagicNames.getObjectArrayAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLAddrX(T0,T1,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLBZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLHZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTWX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset || methodName == VM_MagicNames.setWordAtOffset) {
    popAddr(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTAddrX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTBX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTHX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset || methodName == VM_MagicNames.getDoubleAtOffset) {
    popInt(T2);
    popAddr(T1);
    asm.emitLFDX(F0,T1,T2);
    pushDouble(F0);
  }
 else   if ((methodName == VM_MagicNames.setLongAtOffset) || (methodName == VM_MagicNames.setDoubleAtOffset)) {
    popLong(T3,T2);
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWX(T3,T1,T0);
      asm.emitADDI(T1,BYTES_IN_INT,T1);
      asm.emitSTWX(T2,T1,T0);
    }
 else {
      asm.emitSTDX(T2,T1,T0);
    }
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    popAddr(T0);
    asm.emitLInt(T0,0,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getMemoryWord || methodName == VM_MagicNames.getMemoryAddress) {
    popAddr(T0);
    asm.emitLAddr(T0,0,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryWord || methodName == VM_MagicNames.setMemoryAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLWZX(T0,T1,T0);
    }
 else {
      asm.emitLWARX(T0,T1,T0);
    }
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.prepareObject || methodName == VM_MagicNames.prepareAddress || methodName == VM_MagicNames.prepareWord) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLAddrX(T0,T1,T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitLWARX(T0,T1,T0);
      }
 else {
        asm.emitLDARX(T0,T1,T0);
      }
    }
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    popInt(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTWX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushAddr(T0);
    }
 else {
      asm.emitSTWCXr(T2,T1,T0);
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.attemptObject || methodName == VM_MagicNames.attemptAddress || methodName == VM_MagicNames.attemptWord) {
    popAddr(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTAddrX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushAddr(T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitSTWCXr(T2,T1,T0);
      }
 else {
        asm.emitSTDCXr(T2,T1,T0);
      }
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushInt(T0);
    }
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.saveThreadStateInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    peekAddr(T1,0);
    peekAddr(T0,1);
    asm.emitLAddrToc(S0,VM_Entrypoints.threadSwitchInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlots(2);
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.restoreHardwareExceptionStateInstructionsField.getOffset());
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.returnToNewStack) {
    peekAddr(FP,0);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.dynamicBridgeTo) {
    if (VM.VerifyAssertions)     VM._assert(klass.isDynamicBridge());
    peekAddr(T0,0);
    asm.emitMTCTR(T0);
    int offset=frameSize;
    for (int i=LAST_NONVOLATILE_FPR; i >= FIRST_VOLATILE_FPR; --i)     asm.emitLFD(i,offset-=BYTES_IN_DOUBLE,FP);
    for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_NONVOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    offset-=(FIRST_NONVOLATILE_GPR - LAST_VOLATILE_GPR - 1) * BYTES_IN_ADDRESS;
    for (int i=LAST_VOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    asm.emitLAddr(FP,0,FP);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCCTR();
  }
 else   if (methodName == VM_MagicNames.objectAsAddress || methodName == VM_MagicNames.addressAsByteArray || methodName == VM_MagicNames.addressAsIntArray || methodName == VM_MagicNames.addressAsObject || methodName == VM_MagicNames.addressAsObjectArray || methodName == VM_MagicNames.addressAsType || methodName == VM_MagicNames.objectAsType || methodName == VM_MagicNames.objectAsByteArray || methodName == VM_MagicNames.objectAsShortArray || methodName == VM_MagicNames.objectAsIntArray || methodName == VM_MagicNames.addressAsThread || methodName == VM_MagicNames.objectAsThread || methodName == VM_MagicNames.objectAsProcessor || methodName == VM_MagicNames.threadAsCollectorThread || methodName == VM_MagicNames.addressAsRegisters || methodName == VM_MagicNames.addressAsStack || methodName == VM_MagicNames.floatAsIntBits || methodName == VM_MagicNames.intBitsAsFloat || methodName == VM_MagicNames.doubleAsLongBits || methodName == VM_MagicNames.longBitsAsDouble) {
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    popAddr(T0);
    VM_ObjectModel.baselineEmitLoadTIB(asm,T0,T0);
    asm.emitLAddr(T0,TIB_TYPE_INDEX << LOG_BYTES_IN_ADDRESS,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    popAddr(T0);
    asm.emitLInt(T0,VM_ObjectModel.getArrayLengthOffset(),T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.sync) {
    asm.emitSYNC();
  }
 else   if (methodName == VM_MagicNames.isync) {
    asm.emitISYNC();
  }
 else   if (methodName == VM_MagicNames.dcbst) {
    popAddr(T0);
    asm.emitDCBST(0,T0);
  }
 else   if (methodName == VM_MagicNames.icbi) {
    popAddr(T0);
    asm.emitICBI(0,T0);
  }
 else   if (methodName == VM_MagicNames.wordToInt || methodName == VM_MagicNames.wordToAddress || methodName == VM_MagicNames.wordToOffset || methodName == VM_MagicNames.wordToExtent || methodName == VM_MagicNames.wordToWord) {
  }
 else   if (methodName == VM_MagicNames.wordToLong) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordFromInt || methodName == VM_MagicNames.wordFromIntSignExtend) {
    if (VM.BuildFor64Addr) {
      popInt(T0);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromIntZeroExtend) {
    if (VM.BuildFor64Addr) {
      asm.emitLWZ(T0,spTopOffset + BYTES_IN_STACKSLOT - BYTES_IN_INT,FP);
      pokeAddr(T0,0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromLong) {
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.wordAdd) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitADD(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordSub || methodName == VM_MagicNames.wordDiff) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitSUBFC(T2,T0,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordEQ) {
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordNE) {
    generateAddrComparison(false,NE);
  }
 else   if (methodName == VM_MagicNames.wordLT) {
    generateAddrComparison(false,LT);
  }
 else   if (methodName == VM_MagicNames.wordLE) {
    generateAddrComparison(false,LE);
  }
 else   if (methodName == VM_MagicNames.wordGT) {
    generateAddrComparison(false,GT);
  }
 else   if (methodName == VM_MagicNames.wordGE) {
    generateAddrComparison(false,GE);
  }
 else   if (methodName == VM_MagicNames.wordsLT) {
    generateAddrComparison(true,LT);
  }
 else   if (methodName == VM_MagicNames.wordsLE) {
    generateAddrComparison(true,LE);
  }
 else   if (methodName == VM_MagicNames.wordsGT) {
    generateAddrComparison(true,GT);
  }
 else   if (methodName == VM_MagicNames.wordsGE) {
    generateAddrComparison(true,GE);
  }
 else   if (methodName == VM_MagicNames.wordIsZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordIsMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordOne) {
    asm.emitLVAL(T0,1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordAnd) {
    popAddr(T0);
    popAddr(T1);
    asm.emitAND(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordOr) {
    popAddr(T0);
    popAddr(T1);
    asm.emitOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordNot) {
    popAddr(T0);
    asm.emitLVAL(T1,-1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordXor) {
    popAddr(T0);
    popAddr(T1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordLsh) {
    popInt(T0);
    popAddr(T1);
    asm.emitSLAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRshl) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRsha) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRA_Addr(T2,T1,T0);
    pushAddr(T2);
  }
 else {
    return false;
  }
  return true;
}","/** 
 * Generate inline code sequence for specified method.
 * @param methodToBeCalled: method whose name indicates semantics of code to be generated
 * @return true if there was magic defined for the method
 */
private boolean generateInlineCode(VM_MethodReference methodToBeCalled){
  VM_Atom methodName=methodToBeCalled.getName();
  if (methodToBeCalled.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=methodToBeCalled.getParameterTypes();
    int paramWords=methodToBeCalled.getParameterWords();
    int gp=FIRST_OS_PARAMETER_GPR;
    int fp=FIRST_OS_PARAMETER_FPR;
    int stackIndex=paramWords;
    int paramBytes=(VM.BuildFor64Addr ? args.length : paramWords) * BYTES_IN_STACKSLOT;
    int callee_param_index=-BYTES_IN_STACKSLOT - paramBytes;
    for (int i=0; i < args.length; i++) {
      VM_TypeReference t=args[i];
      if (t.isLongType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_LONG;
        if (VM.BuildFor64Addr) {
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekLong(gp,gp,stackIndex);
            gp++;
          }
 else {
            peekLong(S0,S0,stackIndex);
            asm.emitSTD(S0,callee_param_index - BYTES_IN_LONG,FP);
          }
        }
 else {
          gp+=(gp + 1) & 0x01;
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex);
          }
          if (gp <= LAST_OS_PARAMETER_GPR) {
            peekInt(gp++,stackIndex + 1);
          }
 else {
            peekLong(S0,S1,stackIndex);
            asm.emitSTW(S0,callee_param_index - BYTES_IN_LONG,FP);
            asm.emitSTW(S1,callee_param_index - BYTES_IN_INT,FP);
          }
        }
      }
 else       if (t.isFloatType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekFloat(fp++,stackIndex);
        }
 else {
          peekFloat(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFS(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_FLOAT,FP);
        }
      }
 else       if (t.isDoubleType()) {
        stackIndex-=2;
        callee_param_index+=BYTES_IN_DOUBLE;
        if (fp <= LAST_OS_PARAMETER_FPR) {
          peekDouble(fp++,stackIndex);
        }
 else {
          peekDouble(FIRST_SCRATCH_FPR,stackIndex);
          asm.emitSTFD(FIRST_SCRATCH_FPR,callee_param_index - BYTES_IN_DOUBLE,FP);
        }
      }
 else       if (t.isIntLikeType()) {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekInt(gp++,stackIndex);
        }
 else {
          peekInt(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
 else {
        stackIndex-=1;
        callee_param_index+=BYTES_IN_STACKSLOT;
        if (gp <= LAST_OS_PARAMETER_GPR) {
          peekAddr(gp++,stackIndex);
        }
 else {
          peekAddr(S0,stackIndex);
          asm.emitSTAddr(S0,callee_param_index - BYTES_IN_ADDRESS,FP);
        }
      }
    }
    if (VM.VerifyAssertions) {
      VM._assert(stackIndex == 0);
    }
    VM_Field ip=VM_Entrypoints.getSysCallField(methodName.toString());
    generateSysCall(paramBytes,ip);
    discardSlots(paramWords);
    VM_TypeReference rtype=methodToBeCalled.getReturnType();
    if (rtype.isIntLikeType()) {
      pushInt(T0);
    }
 else     if (rtype.isWordType() || rtype.isReferenceType()) {
      pushAddr(T0);
    }
 else     if (rtype.isDoubleType()) {
      pushDouble(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isFloatType()) {
      pushFloat(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isLongType()) {
      pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
    }
  }
 else   if (methodName == VM_MagicNames.getFramePointer) {
    pushAddr(FP);
  }
 else   if (methodName == VM_MagicNames.getCallerFramePointer) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setCallerFramePointer) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getCompiledMethodID) {
    popAddr(T0);
    asm.emitLInt(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
    pushInt(T1);
  }
 else   if (methodName == VM_MagicNames.setCompiledMethodID) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getNextInstructionAddress) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setNextInstructionAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getReturnAddressLocation) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    asm.emitADDI(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.getTocPointer || methodName == VM_MagicNames.getJTOC) {
    pushAddr(JTOC);
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    pushAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    popAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    if (VM.BuildFor64Addr) {
      asm.emitMFTB(T1);
    }
 else {
      int label=asm.getMachineCodeIndex();
      asm.emitMFTBU(T0);
      asm.emitMFTB(T1);
      asm.emitMFTBU(T2);
      asm.emitCMP(T0,T2);
      asm.emitBC(NE,label);
    }
    pushLong(T0,T1);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    peekAddr(T0,0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    asm.emitBCCTRL();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningVoid) {
    generateMethodInvocation();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningInt) {
    generateMethodInvocation();
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningLong) {
    generateMethodInvocation();
    pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
    generateMethodInvocation();
    pushFloat(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
    generateMethodInvocation();
    pushDouble(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningObject) {
    generateMethodInvocation();
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    VM_Array type=methodToBeCalled.getType().resolve().asArray();
    emit_resolved_newarray(type);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    emit_arraylength();
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iaload();
    }
 else {
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitLAddrX(T2,T0,T1);
      pushAddr(T2);
    }
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iastore();
    }
 else {
      popAddr(T2);
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitSTAddrX(T2,T0,T1);
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLIntX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset || methodName == VM_MagicNames.getWordAtOffset || methodName == VM_MagicNames.getObjectArrayAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLAddrX(T0,T1,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLBZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLHZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTWX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset || methodName == VM_MagicNames.setWordAtOffset) {
    popAddr(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTAddrX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTBX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTHX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset || methodName == VM_MagicNames.getDoubleAtOffset) {
    popInt(T2);
    popAddr(T1);
    asm.emitLFDX(F0,T1,T2);
    pushDouble(F0);
  }
 else   if ((methodName == VM_MagicNames.setLongAtOffset) || (methodName == VM_MagicNames.setDoubleAtOffset)) {
    popLong(T3,T2);
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWX(T3,T1,T0);
      asm.emitADDI(T1,BYTES_IN_INT,T1);
      asm.emitSTWX(T2,T1,T0);
    }
 else {
      asm.emitSTDX(T2,T1,T0);
    }
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    popAddr(T0);
    asm.emitLInt(T0,0,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getMemoryWord || methodName == VM_MagicNames.getMemoryAddress) {
    popAddr(T0);
    asm.emitLAddr(T0,0,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryWord || methodName == VM_MagicNames.setMemoryAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLWZX(T0,T1,T0);
    }
 else {
      asm.emitLWARX(T0,T1,T0);
    }
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.prepareObject || methodName == VM_MagicNames.prepareAddress || methodName == VM_MagicNames.prepareWord) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLAddrX(T0,T1,T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitLWARX(T0,T1,T0);
      }
 else {
        asm.emitLDARX(T0,T1,T0);
      }
    }
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    popInt(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTWX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushInt(T0);
    }
 else {
      asm.emitSTWCXr(T2,T1,T0);
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushInt(T0);
    }
  }
 else   if (methodName == VM_MagicNames.attemptObject || methodName == VM_MagicNames.attemptAddress || methodName == VM_MagicNames.attemptWord) {
    popAddr(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTAddrX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushInt(T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitSTWCXr(T2,T1,T0);
      }
 else {
        asm.emitSTDCXr(T2,T1,T0);
      }
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushInt(T0);
    }
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.saveThreadStateInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    peekAddr(T1,0);
    peekAddr(T0,1);
    asm.emitLAddrToc(S0,VM_Entrypoints.threadSwitchInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlots(2);
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.restoreHardwareExceptionStateInstructionsField.getOffset());
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.returnToNewStack) {
    peekAddr(FP,0);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.dynamicBridgeTo) {
    if (VM.VerifyAssertions)     VM._assert(klass.isDynamicBridge());
    peekAddr(T0,0);
    asm.emitMTCTR(T0);
    int offset=frameSize;
    for (int i=LAST_NONVOLATILE_FPR; i >= FIRST_VOLATILE_FPR; --i)     asm.emitLFD(i,offset-=BYTES_IN_DOUBLE,FP);
    for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_NONVOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    offset-=(FIRST_NONVOLATILE_GPR - LAST_VOLATILE_GPR - 1) * BYTES_IN_ADDRESS;
    for (int i=LAST_VOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    asm.emitLAddr(FP,0,FP);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCCTR();
  }
 else   if (methodName == VM_MagicNames.objectAsAddress || methodName == VM_MagicNames.addressAsByteArray || methodName == VM_MagicNames.addressAsIntArray || methodName == VM_MagicNames.addressAsObject || methodName == VM_MagicNames.addressAsObjectArray || methodName == VM_MagicNames.addressAsType || methodName == VM_MagicNames.objectAsType || methodName == VM_MagicNames.objectAsByteArray || methodName == VM_MagicNames.objectAsShortArray || methodName == VM_MagicNames.objectAsIntArray || methodName == VM_MagicNames.addressAsThread || methodName == VM_MagicNames.objectAsThread || methodName == VM_MagicNames.objectAsProcessor || methodName == VM_MagicNames.threadAsCollectorThread || methodName == VM_MagicNames.addressAsRegisters || methodName == VM_MagicNames.addressAsStack || methodName == VM_MagicNames.floatAsIntBits || methodName == VM_MagicNames.intBitsAsFloat || methodName == VM_MagicNames.doubleAsLongBits || methodName == VM_MagicNames.longBitsAsDouble) {
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    popAddr(T0);
    VM_ObjectModel.baselineEmitLoadTIB(asm,T0,T0);
    asm.emitLAddr(T0,TIB_TYPE_INDEX << LOG_BYTES_IN_ADDRESS,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    popAddr(T0);
    asm.emitLInt(T0,VM_ObjectModel.getArrayLengthOffset(),T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.sync) {
    asm.emitSYNC();
  }
 else   if (methodName == VM_MagicNames.isync) {
    asm.emitISYNC();
  }
 else   if (methodName == VM_MagicNames.dcbst) {
    popAddr(T0);
    asm.emitDCBST(0,T0);
  }
 else   if (methodName == VM_MagicNames.icbi) {
    popAddr(T0);
    asm.emitICBI(0,T0);
  }
 else   if (methodName == VM_MagicNames.wordToInt || methodName == VM_MagicNames.wordToAddress || methodName == VM_MagicNames.wordToOffset || methodName == VM_MagicNames.wordToExtent || methodName == VM_MagicNames.wordToWord) {
  }
 else   if (methodName == VM_MagicNames.wordToLong) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordFromInt || methodName == VM_MagicNames.wordFromIntSignExtend) {
    if (VM.BuildFor64Addr) {
      popInt(T0);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromIntZeroExtend) {
    if (VM.BuildFor64Addr) {
      asm.emitLWZ(T0,spTopOffset + BYTES_IN_STACKSLOT - BYTES_IN_INT,FP);
      pokeAddr(T0,0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromLong) {
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.wordAdd) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitADD(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordSub || methodName == VM_MagicNames.wordDiff) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitSUBFC(T2,T0,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordEQ) {
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordNE) {
    generateAddrComparison(false,NE);
  }
 else   if (methodName == VM_MagicNames.wordLT) {
    generateAddrComparison(false,LT);
  }
 else   if (methodName == VM_MagicNames.wordLE) {
    generateAddrComparison(false,LE);
  }
 else   if (methodName == VM_MagicNames.wordGT) {
    generateAddrComparison(false,GT);
  }
 else   if (methodName == VM_MagicNames.wordGE) {
    generateAddrComparison(false,GE);
  }
 else   if (methodName == VM_MagicNames.wordsLT) {
    generateAddrComparison(true,LT);
  }
 else   if (methodName == VM_MagicNames.wordsLE) {
    generateAddrComparison(true,LE);
  }
 else   if (methodName == VM_MagicNames.wordsGT) {
    generateAddrComparison(true,GT);
  }
 else   if (methodName == VM_MagicNames.wordsGE) {
    generateAddrComparison(true,GE);
  }
 else   if (methodName == VM_MagicNames.wordIsZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordIsMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordOne) {
    asm.emitLVAL(T0,1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordAnd) {
    popAddr(T0);
    popAddr(T1);
    asm.emitAND(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordOr) {
    popAddr(T0);
    popAddr(T1);
    asm.emitOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordNot) {
    popAddr(T0);
    asm.emitLVAL(T1,-1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordXor) {
    popAddr(T0);
    popAddr(T1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordLsh) {
    popInt(T0);
    popAddr(T1);
    asm.emitSLAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRshl) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRsha) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRA_Addr(T2,T1,T0);
    pushAddr(T2);
  }
 else {
    return false;
  }
  return true;
}",0.9994449290302118
150236,"/** 
 * Given an HIR, expand operators that are implemented as calls to runtime service methods. This method should be called as one of the first steps in lowering HIR into LIR.
 * @param OPT_IR HIR to expand
 */
public void perform(OPT_IR ir){
  ir.gc.resync();
  OPT_Instruction next;
  for (OPT_Instruction inst=ir.firstInstructionInCodeOrder(); inst != null; inst=next) {
    next=inst.nextInstructionInCodeOrder();
    int opcode=inst.getOpcode();
switch (opcode) {
case NEW_opcode:
{
        OPT_TypeOperand Type=New.getClearType(inst);
        VM_Class cls=(VM_Class)Type.getVMType();
        OPT_IntConstantOperand hasFinalizer=I(cls.hasFinalizer() ? 1 : 0);
        VM_Method callSite=inst.position.getMethod();
        OPT_IntConstantOperand allocator=I(MM_Interface.pickAllocator(cls,callSite));
        OPT_IntConstantOperand align=I(VM_ObjectModel.getAlignment(cls));
        OPT_IntConstantOperand offset=I(VM_ObjectModel.getOffsetForAlignment(cls));
        VM_Method target=VM_Entrypoints.resolvedNewScalarMethod;
        Call.mutate6(inst,CALL,New.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),I(cls.getInstanceSize()),OPT_ConvertToLowLevelIR.getTIB(inst,ir,Type),hasFinalizer,allocator,align,offset);
        if (ir.options.INLINE_NEW) {
          if (inst.getBasicBlock().getInfrequent())           container.counter1++;
          container.counter2++;
          if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
            inline(inst,ir);
          }
        }
      }
    break;
case NEW_UNRESOLVED_opcode:
{
    int typeRefId=New.getType(inst).getTypeRef().getId();
    VM_Method target=VM_Entrypoints.unresolvedNewScalarMethod;
    Call.mutate1(inst,CALL,New.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),I(typeRefId));
  }
break;
case NEWARRAY_opcode:
{
OPT_TypeOperand Array=NewArray.getClearType(inst);
VM_Array array=(VM_Array)Array.getVMType();
OPT_Operand numberElements=NewArray.getClearSize(inst);
boolean inline=numberElements instanceof OPT_IntConstantOperand;
OPT_Operand width=I(array.getLogElementSize());
OPT_Operand headerSize=I(VM_ObjectModel.computeArrayHeaderSize(array));
VM_Method callSite=inst.position.getMethod();
OPT_IntConstantOperand allocator=I(MM_Interface.pickAllocator(array,callSite));
OPT_IntConstantOperand align=I(VM_ObjectModel.getAlignment(array));
OPT_IntConstantOperand offset=I(VM_ObjectModel.getOffsetForAlignment(array));
VM_Method target=VM_Entrypoints.resolvedNewArrayMethod;
Call.mutate7(inst,CALL,NewArray.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),numberElements,width,headerSize,OPT_ConvertToLowLevelIR.getTIB(inst,ir,Array),allocator,align,offset);
if (inline && ir.options.INLINE_NEW) {
  if (inst.getBasicBlock().getInfrequent())   container.counter1++;
  container.counter2++;
  if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
    inline(inst,ir);
  }
}
}
break;
case NEWARRAY_UNRESOLVED_opcode:
{
int typeRefId=NewArray.getType(inst).getTypeRef().getId();
OPT_Operand numberElements=NewArray.getClearSize(inst);
VM_Method target=VM_Entrypoints.unresolvedNewArrayMethod;
Call.mutate2(inst,CALL,NewArray.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),numberElements,I(typeRefId));
}
break;
case NEWOBJMULTIARRAY_opcode:
{
int typeRefId=NewArray.getType(inst).getTypeRef().getId();
VM_Method target=VM_Entrypoints.optNewArrayArrayMethod;
VM_Method callSite=inst.position.getMethod();
Call.mutate3(inst,CALL,NewArray.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),I(callSite.getId()),NewArray.getClearSize(inst),I(typeRefId));
}
break;
case ATHROW_opcode:
{
VM_Method target=VM_Entrypoints.athrowMethod;
OPT_MethodOperand methodOp=OPT_MethodOperand.STATIC(target);
methodOp.setIsNonReturningCall(true);
Call.mutate1(inst,CALL,null,I(target.getOffset()),methodOp,Athrow.getClearValue(inst));
}
break;
case MONITORENTER_opcode:
{
if (ir.options.NO_SYNCHRO) {
inst.remove();
}
 else {
OPT_Operand ref=MonitorOp.getClearRef(inst);
VM_Type refType=ref.getType().peekResolvedType();
if (refType != null && refType.getThinLockOffset() != -1) {
VM_Method target=VM_Entrypoints.inlineLockMethod;
Call.mutate2(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref,I(refType.getThinLockOffset()));
if (inst.getBasicBlock().getInfrequent()) container.counter1++;
container.counter2++;
if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
inline(inst,ir);
}
}
 else {
VM_Method target=VM_Entrypoints.lockMethod;
Call.mutate1(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref);
}
}
break;
}
case MONITOREXIT_opcode:
{
if (ir.options.NO_SYNCHRO) {
inst.remove();
}
 else {
OPT_Operand ref=MonitorOp.getClearRef(inst);
VM_Type refType=ref.getType().peekResolvedType();
if (refType != null && refType.getThinLockOffset() != -1) {
VM_Method target=VM_Entrypoints.inlineUnlockMethod;
Call.mutate2(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref,I(refType.getThinLockOffset()));
if (inst.getBasicBlock().getInfrequent()) container.counter1++;
container.counter2++;
if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
inline(inst,ir);
}
}
 else {
VM_Method target=VM_Entrypoints.unlockMethod;
Call.mutate1(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref);
}
}
}
break;
case REF_ASTORE_opcode:
{
if (MM_Interface.NEEDS_WRITE_BARRIER) {
VM_Method target=VM_Entrypoints.arrayStoreWriteBarrierMethod;
OPT_Instruction wb=Call.create3(CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),AStore.getArray(inst).copy(),AStore.getIndex(inst).copy(),AStore.getValue(inst).copy());
wb.bcIndex=RUNTIME_SERVICES_BCI;
wb.position=inst.position;
inst.replace(wb);
next=wb.nextInstructionInCodeOrder();
if (ir.options.INLINE_WRITE_BARRIER) inline(wb,ir,true);
}
}
break;
case PUTFIELD_opcode:
{
if (MM_Interface.NEEDS_WRITE_BARRIER) {
OPT_LocationOperand loc=PutField.getClearLocation(inst);
VM_FieldReference field=loc.getFieldRef();
if (!field.getFieldContentsType().isPrimitiveType()) {
VM_Method target=VM_Entrypoints.putfieldWriteBarrierMethod;
OPT_Instruction wb=Call.create3(CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),PutField.getRef(inst).copy(),PutField.getOffset(inst).copy(),PutField.getValue(inst).copy());
wb.bcIndex=RUNTIME_SERVICES_BCI;
wb.position=inst.position;
inst.replace(wb);
next=wb.nextInstructionInCodeOrder();
if (ir.options.INLINE_WRITE_BARRIER) inline(wb,ir);
}
}
}
break;
default :
break;
}
}
if (didSomething) {
branchOpts.perform(ir,true);
_os.perform(ir);
}
ir.gc.close();
}","/** 
 * Given an HIR, expand operators that are implemented as calls to runtime service methods. This method should be called as one of the first steps in lowering HIR into LIR.
 * @param OPT_IR HIR to expand
 */
public void perform(OPT_IR ir){
  ir.gc.resync();
  OPT_Instruction next;
  for (OPT_Instruction inst=ir.firstInstructionInCodeOrder(); inst != null; inst=next) {
    next=inst.nextInstructionInCodeOrder();
    int opcode=inst.getOpcode();
switch (opcode) {
case NEW_opcode:
{
        OPT_TypeOperand Type=New.getClearType(inst);
        VM_Class cls=(VM_Class)Type.getVMType();
        OPT_IntConstantOperand hasFinalizer=I(cls.hasFinalizer() ? 1 : 0);
        VM_Method callSite=inst.position.getMethod();
        OPT_IntConstantOperand allocator=I(MM_Interface.pickAllocator(cls,callSite));
        OPT_IntConstantOperand align=I(VM_ObjectModel.getAlignment(cls));
        OPT_IntConstantOperand offset=I(VM_ObjectModel.getOffsetForAlignment(cls));
        OPT_Operand tib=OPT_ConvertToLowLevelIR.getTIB(inst,ir,Type);
        if (VM.BuildForIA32 && VM.runningVM) {
          OPT_RegisterOperand tmp=ir.regpool.makeTemp(VM_TypeReference.JavaLangObjectArray);
          inst.insertBefore(Move.create(REF_MOVE,tmp,tib));
          tib=tmp;
        }
        VM_Method target=VM_Entrypoints.resolvedNewScalarMethod;
        Call.mutate6(inst,CALL,New.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),I(cls.getInstanceSize()),tib,hasFinalizer,allocator,align,offset);
        if (ir.options.INLINE_NEW) {
          if (inst.getBasicBlock().getInfrequent())           container.counter1++;
          container.counter2++;
          if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
            inline(inst,ir);
          }
        }
      }
    break;
case NEW_UNRESOLVED_opcode:
{
    int typeRefId=New.getType(inst).getTypeRef().getId();
    VM_Method target=VM_Entrypoints.unresolvedNewScalarMethod;
    Call.mutate1(inst,CALL,New.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),I(typeRefId));
  }
break;
case NEWARRAY_opcode:
{
OPT_TypeOperand Array=NewArray.getClearType(inst);
VM_Array array=(VM_Array)Array.getVMType();
OPT_Operand numberElements=NewArray.getClearSize(inst);
boolean inline=numberElements instanceof OPT_IntConstantOperand;
OPT_Operand width=I(array.getLogElementSize());
OPT_Operand headerSize=I(VM_ObjectModel.computeArrayHeaderSize(array));
VM_Method callSite=inst.position.getMethod();
OPT_IntConstantOperand allocator=I(MM_Interface.pickAllocator(array,callSite));
OPT_IntConstantOperand align=I(VM_ObjectModel.getAlignment(array));
OPT_IntConstantOperand offset=I(VM_ObjectModel.getOffsetForAlignment(array));
OPT_Operand tib=OPT_ConvertToLowLevelIR.getTIB(inst,ir,Array);
if (VM.BuildForIA32 && VM.runningVM) {
  OPT_RegisterOperand tmp=ir.regpool.makeTemp(VM_TypeReference.JavaLangObjectArray);
  inst.insertBefore(Move.create(REF_MOVE,tmp,tib));
  tib=tmp;
}
VM_Method target=VM_Entrypoints.resolvedNewArrayMethod;
Call.mutate7(inst,CALL,NewArray.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),numberElements,width,headerSize,tib,allocator,align,offset);
if (inline && ir.options.INLINE_NEW) {
  if (inst.getBasicBlock().getInfrequent())   container.counter1++;
  container.counter2++;
  if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
    inline(inst,ir);
  }
}
}
break;
case NEWARRAY_UNRESOLVED_opcode:
{
int typeRefId=NewArray.getType(inst).getTypeRef().getId();
OPT_Operand numberElements=NewArray.getClearSize(inst);
VM_Method target=VM_Entrypoints.unresolvedNewArrayMethod;
Call.mutate2(inst,CALL,NewArray.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),numberElements,I(typeRefId));
}
break;
case NEWOBJMULTIARRAY_opcode:
{
int typeRefId=NewArray.getType(inst).getTypeRef().getId();
VM_Method target=VM_Entrypoints.optNewArrayArrayMethod;
VM_Method callSite=inst.position.getMethod();
Call.mutate3(inst,CALL,NewArray.getClearResult(inst),I(target.getOffset()),OPT_MethodOperand.STATIC(target),I(callSite.getId()),NewArray.getClearSize(inst),I(typeRefId));
}
break;
case ATHROW_opcode:
{
VM_Method target=VM_Entrypoints.athrowMethod;
OPT_MethodOperand methodOp=OPT_MethodOperand.STATIC(target);
methodOp.setIsNonReturningCall(true);
Call.mutate1(inst,CALL,null,I(target.getOffset()),methodOp,Athrow.getClearValue(inst));
}
break;
case MONITORENTER_opcode:
{
if (ir.options.NO_SYNCHRO) {
inst.remove();
}
 else {
OPT_Operand ref=MonitorOp.getClearRef(inst);
VM_Type refType=ref.getType().peekResolvedType();
if (refType != null && refType.getThinLockOffset() != -1) {
VM_Method target=VM_Entrypoints.inlineLockMethod;
Call.mutate2(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref,I(refType.getThinLockOffset()));
if (inst.getBasicBlock().getInfrequent()) container.counter1++;
container.counter2++;
if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
inline(inst,ir);
}
}
 else {
VM_Method target=VM_Entrypoints.lockMethod;
Call.mutate1(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref);
}
}
break;
}
case MONITOREXIT_opcode:
{
if (ir.options.NO_SYNCHRO) {
inst.remove();
}
 else {
OPT_Operand ref=MonitorOp.getClearRef(inst);
VM_Type refType=ref.getType().peekResolvedType();
if (refType != null && refType.getThinLockOffset() != -1) {
VM_Method target=VM_Entrypoints.inlineUnlockMethod;
Call.mutate2(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref,I(refType.getThinLockOffset()));
if (inst.getBasicBlock().getInfrequent()) container.counter1++;
container.counter2++;
if (!ir.options.FREQ_FOCUS_EFFORT || !inst.getBasicBlock().getInfrequent()) {
inline(inst,ir);
}
}
 else {
VM_Method target=VM_Entrypoints.unlockMethod;
Call.mutate1(inst,CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),MonitorOp.getClearGuard(inst),ref);
}
}
}
break;
case REF_ASTORE_opcode:
{
if (MM_Interface.NEEDS_WRITE_BARRIER) {
VM_Method target=VM_Entrypoints.arrayStoreWriteBarrierMethod;
OPT_Instruction wb=Call.create3(CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),AStore.getArray(inst).copy(),AStore.getIndex(inst).copy(),AStore.getValue(inst).copy());
wb.bcIndex=RUNTIME_SERVICES_BCI;
wb.position=inst.position;
inst.replace(wb);
next=wb.nextInstructionInCodeOrder();
if (ir.options.INLINE_WRITE_BARRIER) inline(wb,ir,true);
}
}
break;
case PUTFIELD_opcode:
{
if (MM_Interface.NEEDS_WRITE_BARRIER) {
OPT_LocationOperand loc=PutField.getClearLocation(inst);
VM_FieldReference field=loc.getFieldRef();
if (!field.getFieldContentsType().isPrimitiveType()) {
VM_Method target=VM_Entrypoints.putfieldWriteBarrierMethod;
OPT_Instruction wb=Call.create3(CALL,null,I(target.getOffset()),OPT_MethodOperand.STATIC(target),PutField.getRef(inst).copy(),PutField.getOffset(inst).copy(),PutField.getValue(inst).copy());
wb.bcIndex=RUNTIME_SERVICES_BCI;
wb.position=inst.position;
inst.replace(wb);
next=wb.nextInstructionInCodeOrder();
if (ir.options.INLINE_WRITE_BARRIER) inline(wb,ir);
}
}
}
break;
default :
break;
}
}
if (didSomething) {
branchOpts.perform(ir,true);
_os.perform(ir);
}
ir.gc.close();
}",0.9544107268877912
150237,"/** 
 * Perform operations with <i>thread-local</i> scope to release resources after a collection.  This is called by <code>release()</code> which will ensure that <i>all threads</i> execute this.
 */
private final void baseThreadLocalRelease(int order){
  values.reset();
  remset.reset();
  forwardPool.reset();
  rootLocations.reset();
  interiorRootLocations.reset();
  threadLocalRelease(order);
}","/** 
 * Perform operations with <i>thread-local</i> scope to release resources after a collection.  This is called by <code>release()</code> which will ensure that <i>all threads</i> execute this.
 */
private final void baseThreadLocalRelease(int order){
  values.reset();
  remset.reset();
  forwardedObjects.reset();
  rootLocations.reset();
  interiorRootLocations.reset();
  threadLocalRelease(order);
}",0.9839307787391842
150238,"/** 
 * Perform operations with <i>thread-local</i> scope to release resources after a collection.  This is called by <code>release()</code> which will ensure that <i>all threads</i> execute this.
 */
private final void baseThreadLocalRelease(int order){
  values.reset();
  remset.reset();
  forwardPool.reset();
  rootLocations.reset();
  interiorRootLocations.reset();
  threadLocalRelease(order);
}","/** 
 * Perform operations with <i>thread-local</i> scope to release resources after a collection.  This is called by <code>release()</code> which will ensure that <i>all threads</i> execute this.
 */
private final void baseThreadLocalRelease(int order){
  values.reset();
  remset.reset();
  forwardedObjects.reset();
  rootLocations.reset();
  interiorRootLocations.reset();
  threadLocalRelease(order);
}",0.9839307787391842
150239,"public VM_Address getNextReferenceAddress(){
  if (mapId < 0)   mapOffset=maps.getNextJSRRef(mapOffset);
 else   mapOffset=maps.getNextRef(mapOffset,mapId);
  if (VM.TraceStkMaps) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(mapOffset);
    VM.sysWrite(""String_Node_Str"");
    if (mapId < 0)     VM.sysWrite(""String_Node_Str"");
  }
  if (mapOffset != 0) {
    return (framePtr.add(mapOffset));
  }
 else   if (bridgeParameterMappingRequired) {
    if (VM.TraceStkMaps) {
      VM.sysWrite(""String_Node_Str"");
      VM.sysWrite(bridgeTarget);
      VM.sysWrite(""String_Node_Str"");
    }
    if (!bridgeRegistersLocationUpdated) {
      VM_Address location=framePtr.add(VM_Compiler.getFrameSize(currentMethod));
      location=location.sub((LAST_NONVOLATILE_FPR - FIRST_VOLATILE_FPR + 1) * BYTES_IN_DOUBLE);
      for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i) {
        location=location.sub(BYTES_IN_ADDRESS);
        registerLocations.set(i,location);
      }
      bridgeRegistersLocationUpdated=true;
    }
    if (bridgeParameterIndex == -1) {
      bridgeParameterIndex+=1;
      bridgeRegisterIndex+=1;
      bridgeRegisterLocation=bridgeRegisterLocation.add(4);
      return bridgeRegisterLocation.sub(4);
    }
    while (true) {
      if (bridgeParameterIndex == bridgeParameterTypes.length || bridgeRegisterIndex > LAST_VOLATILE_GPR) {
        bridgeParameterMappingRequired=false;
        break;
      }
      VM_TypeReference bridgeParameterType=bridgeParameterTypes[bridgeParameterIndex++];
      if (bridgeParameterType.isReferenceType()) {
        bridgeRegisterIndex+=1;
        bridgeRegisterLocation=bridgeRegisterLocation.add(4);
        return bridgeRegisterLocation.sub(4);
      }
 else       if (bridgeParameterType.isLongType()) {
        bridgeRegisterIndex+=2;
        bridgeRegisterLocation=bridgeRegisterLocation.add(8);
      }
 else       if (bridgeParameterType.isDoubleType() || bridgeParameterType.isFloatType()) {
      }
 else {
        bridgeRegisterIndex+=1;
        bridgeRegisterLocation=bridgeRegisterLocation.add(4);
      }
    }
  }
  return VM_Address.zero();
}","public VM_Address getNextReferenceAddress(){
  if (mapId < 0)   mapOffset=maps.getNextJSRRef(mapOffset);
 else   mapOffset=maps.getNextRef(mapOffset,mapId);
  if (VM.TraceStkMaps) {
    VM.sysWrite(""String_Node_Str"");
    VM.sysWrite(mapOffset);
    VM.sysWrite(""String_Node_Str"");
    if (mapId < 0)     VM.sysWrite(""String_Node_Str"");
  }
  if (mapOffset != 0) {
    return (framePtr.add(mapOffset));
  }
 else   if (bridgeParameterMappingRequired) {
    if (VM.TraceStkMaps) {
      VM.sysWrite(""String_Node_Str"");
      VM.sysWrite(bridgeTarget);
      VM.sysWrite(""String_Node_Str"");
    }
    if (!bridgeRegistersLocationUpdated) {
      VM_Address location=framePtr.add(VM_Compiler.getFrameSize(currentMethod));
      location=location.sub((LAST_NONVOLATILE_FPR - FIRST_VOLATILE_FPR + 1) * BYTES_IN_DOUBLE);
      for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i) {
        location=location.sub(BYTES_IN_ADDRESS);
        registerLocations.set(i,location);
      }
      bridgeRegistersLocationUpdated=true;
    }
    if (bridgeParameterIndex == -1) {
      bridgeParameterIndex+=1;
      bridgeRegisterIndex+=1;
      bridgeRegisterLocation=bridgeRegisterLocation.add(BYTES_IN_ADDRESS);
      return bridgeRegisterLocation.sub(BYTES_IN_ADDRESS);
    }
    while (true) {
      if (bridgeParameterIndex == bridgeParameterTypes.length || bridgeRegisterIndex > LAST_VOLATILE_GPR) {
        bridgeParameterMappingRequired=false;
        break;
      }
      VM_TypeReference bridgeParameterType=bridgeParameterTypes[bridgeParameterIndex++];
      if (bridgeParameterType.isReferenceType()) {
        bridgeRegisterIndex+=1;
        bridgeRegisterLocation=bridgeRegisterLocation.add(BYTES_IN_ADDRESS);
        return bridgeRegisterLocation.sub(BYTES_IN_ADDRESS);
      }
 else       if (bridgeParameterType.isLongType()) {
        bridgeRegisterIndex+=VM.BuildFor64Addr ? 1 : 2;
        bridgeRegisterLocation=bridgeRegisterLocation.add(BYTES_IN_LONG);
      }
 else       if (bridgeParameterType.isDoubleType() || bridgeParameterType.isFloatType()) {
      }
 else {
        bridgeRegisterIndex+=1;
        bridgeRegisterLocation=bridgeRegisterLocation.add(BYTES_IN_ADDRESS);
      }
    }
  }
  return VM_Address.zero();
}",0.971859986273164
150240,"public void reset(){
  mapOffset=0;
  if (bridgeTarget != null) {
    bridgeParameterMappingRequired=true;
    bridgeParameterIndex=bridgeParameterInitialIndex;
    bridgeRegisterIndex=FIRST_VOLATILE_GPR;
    bridgeRegisterLocation=VM_Magic.getMemoryAddress(framePtr);
    bridgeRegisterLocation=bridgeRegisterLocation.sub(8 * (LAST_NONVOLATILE_FPR - FIRST_VOLATILE_FPR + 1) + 4 * (LAST_NONVOLATILE_GPR - FIRST_VOLATILE_GPR + 1));
  }
}","public void reset(){
  mapOffset=0;
  if (bridgeTarget != null) {
    bridgeParameterMappingRequired=true;
    bridgeParameterIndex=bridgeParameterInitialIndex;
    bridgeRegisterIndex=FIRST_VOLATILE_GPR;
    bridgeRegisterLocation=VM_Magic.getMemoryAddress(framePtr);
    bridgeRegisterLocation=bridgeRegisterLocation.sub(BYTES_IN_DOUBLE * (LAST_NONVOLATILE_FPR - FIRST_VOLATILE_FPR + 1) + BYTES_IN_ADDRESS * (LAST_NONVOLATILE_GPR - FIRST_VOLATILE_GPR + 1));
  }
}",0.9633740288568258
150241,"/** 
 * Increment the event counter by <code>value</code>
 * @param value The amount by which the counter should be incremented.
 */
public void inc(int value){
  totalCount+=value;
}","/** 
 * Increment the event counter by <code>value</code>
 * @param value The amount by which the counter should be incremented.
 */
public void inc(int value){
  if (running)   totalCount+=value;
}",0.9606299212598424
150242,"/** 
 * Increment the event counter by <code>value</code>
 * @param value The amount by which the counter should be incremented.
 */
public void inc(int value){
  totalCount+=value;
}","/** 
 * Increment the event counter by <code>value</code>
 * @param value The amount by which the counter should be incremented.
 */
public void inc(int value){
  if (running)   totalCount+=value;
}",0.9606299212598424
150243,"/** 
 * Sort the address on the shared stack.
 */
public final void sort(){
  ((SortSharedDeque)queue).sort();
}","/** 
 * Sort the address on the shared stack.
 */
public final void sort(){
  flushLocal();
  ((SortSharedDeque)queue).sort();
}",0.9333333333333332
150244,"/** 
 * Emit code to allocate an array
 * @param array the VM_Array to instantiate
 */
protected final void emit_resolved_newarray(VM_Array array){
  int width=array.getLogElementSize();
  int tibOffset=array.getTibOffset();
  int headerSize=VM_ObjectModel.computeArrayHeaderSize(array);
  int whichAllocator=MM_Interface.pickAllocator(array,method);
  int align=VM_ObjectModel.getAlignment(array);
  int offset=VM_ObjectModel.getOffsetForAlignment(array);
  asm.emitLAddrToc(T0,VM_Entrypoints.resolvedNewArrayMethod.getOffset());
  asm.emitMTCTR(T0);
  peekInt(T0,0);
  asm.emitLVAL(T1,width);
  asm.emitLVAL(T2,headerSize);
  asm.emitLAddrToc(T3,tibOffset);
  asm.emitLVAL(T4,whichAllocator);
  asm.emitLVAL(T5,align);
  asm.emitLVAL(T6,align);
  asm.emitBCCTRL();
  pokeAddr(T0,0);
}","/** 
 * Emit code to allocate an array
 * @param array the VM_Array to instantiate
 */
protected final void emit_resolved_newarray(VM_Array array){
  int width=array.getLogElementSize();
  int tibOffset=array.getTibOffset();
  int headerSize=VM_ObjectModel.computeArrayHeaderSize(array);
  int whichAllocator=MM_Interface.pickAllocator(array,method);
  int align=VM_ObjectModel.getAlignment(array);
  int offset=VM_ObjectModel.getOffsetForAlignment(array);
  asm.emitLAddrToc(T0,VM_Entrypoints.resolvedNewArrayMethod.getOffset());
  asm.emitMTCTR(T0);
  peekInt(T0,0);
  asm.emitLVAL(T1,width);
  asm.emitLVAL(T2,headerSize);
  asm.emitLAddrToc(T3,tibOffset);
  asm.emitLVAL(T4,whichAllocator);
  asm.emitLVAL(T5,align);
  asm.emitLVAL(T6,offset);
  asm.emitBCCTRL();
  pokeAddr(T0,0);
}",0.993006993006993
150245,"/** 
 * Generate inline code sequence for specified method.
 * @param methodToBeCalled: method whose name indicates semantics of code to be generated
 * @return true if there was magic defined for the method
 */
private boolean generateInlineCode(VM_MethodReference methodToBeCalled){
  VM_Atom methodName=methodToBeCalled.getName();
  if (methodToBeCalled.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=methodToBeCalled.getParameterTypes();
    int paramWords=methodToBeCalled.getParameterWords();
    int gp=FIRST_OS_PARAMETER_GPR;
    int fp=FIRST_OS_PARAMETER_FPR;
    int stackIndex=paramWords;
    for (int i=0; i < args.length; i++) {
      VM_TypeReference t=args[i];
      if (t.isLongType()) {
        stackIndex-=2;
        if (VM.BuildFor64Addr) {
          peekLong(gp,gp,stackIndex);
          gp++;
        }
 else {
          gp+=(gp + 1) & 0x01;
          peekInt(gp++,stackIndex);
          peekInt(gp++,stackIndex + 1);
        }
      }
 else       if (t.isFloatType()) {
        stackIndex-=1;
        peekFloat(fp++,stackIndex);
      }
 else       if (t.isDoubleType()) {
        stackIndex-=2;
        peekDouble(fp++,stackIndex);
      }
 else       if (t.isIntLikeType()) {
        stackIndex-=1;
        peekInt(gp++,stackIndex);
      }
 else {
        stackIndex-=1;
        peekAddr(gp++,stackIndex);
      }
    }
    if (VM.VerifyAssertions) {
      VM._assert(stackIndex == 0);
      VM._assert(gp - 1 <= LAST_OS_PARAMETER_GPR);
      VM._assert(fp - 1 <= LAST_OS_PARAMETER_FPR);
    }
    int paramBytes=(VM.BuildFor64Addr ? args.length : paramWords) * BYTES_IN_STACKSLOT;
    VM_Field ip=VM_Entrypoints.getSysCallField(methodName.toString());
    generateSysCall(paramBytes,ip);
    discardSlots(paramWords);
    VM_TypeReference rtype=methodToBeCalled.getReturnType();
    if (rtype.isIntLikeType()) {
      pushInt(T0);
    }
 else     if (rtype.isWordType() || rtype.isReferenceType()) {
      pushAddr(T0);
    }
 else     if (rtype.isDoubleType()) {
      pushDouble(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isFloatType()) {
      pushFloat(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isLongType()) {
      pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
    }
  }
 else   if (methodName == VM_MagicNames.getFramePointer) {
    pushAddr(FP);
  }
 else   if (methodName == VM_MagicNames.getCallerFramePointer) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setCallerFramePointer) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getCompiledMethodID) {
    popAddr(T0);
    asm.emitLInt(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
    pushInt(T1);
  }
 else   if (methodName == VM_MagicNames.setCompiledMethodID) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getNextInstructionAddress) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setNextInstructionAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getReturnAddressLocation) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    asm.emitADDI(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.getTocPointer || methodName == VM_MagicNames.getJTOC) {
    pushAddr(JTOC);
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    pushAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    popAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    if (VM.BuildFor64Addr) {
      asm.emitMFTB(T1);
    }
 else {
      int label=asm.getMachineCodeIndex();
      asm.emitMFTBU(T0);
      asm.emitMFTB(T1);
      asm.emitMFTBU(T2);
      asm.emitCMP(T0,T2);
      asm.emitBC(NE,label);
    }
    pushLong(T0,T1);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    peekAddr(T0,0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    asm.emitBCCTRL();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningVoid) {
    generateMethodInvocation();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningInt) {
    generateMethodInvocation();
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningLong) {
    generateMethodInvocation();
    pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
    generateMethodInvocation();
    pushFloat(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
    generateMethodInvocation();
    pushDouble(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningObject) {
    generateMethodInvocation();
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    VM_Array type=methodToBeCalled.getType().resolve().asArray();
    emit_resolved_newarray(type);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    emit_arraylength();
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iaload();
    }
 else {
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitLAddrX(T2,T0,T1);
      pushAddr(T2);
    }
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iastore();
    }
 else {
      popAddr(T2);
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitSTAddrX(T2,T0,T1);
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLIntX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset || methodName == VM_MagicNames.getWordAtOffset || methodName == VM_MagicNames.getObjectArrayAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLAddrX(T0,T1,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLBZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLHZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTWX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset || methodName == VM_MagicNames.setWordAtOffset) {
    popAddr(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTAddrX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTBX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTHX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset) {
    popInt(T2);
    popAddr(T1);
    if (VM.BuildFor32Addr) {
      asm.emitLWZX(T0,T1,T2);
      asm.emitADDI(T2,BYTES_IN_INT,T2);
      asm.emitLWZX(T1,T1,T2);
    }
 else {
      asm.emitLDX(T1,T1,T2);
    }
    pushLong(T0,T1);
  }
 else   if ((methodName == VM_MagicNames.setLongAtOffset) || (methodName == VM_MagicNames.setDoubleAtOffset)) {
    popLong(T3,T2);
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWX(T3,T1,T0);
      asm.emitADDI(T1,BYTES_IN_INT,T1);
      asm.emitSTWX(T2,T1,T0);
    }
 else {
      asm.emitSTDX(T2,T1,T0);
    }
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    popAddr(T0);
    asm.emitLInt(T0,0,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getMemoryWord || methodName == VM_MagicNames.getMemoryAddress) {
    popAddr(T0);
    asm.emitLAddr(T0,0,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryWord || methodName == VM_MagicNames.setMemoryAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLWZX(T0,T1,T0);
    }
 else {
      asm.emitLWARX(T0,T1,T0);
    }
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.prepareObject || methodName == VM_MagicNames.prepareAddress || methodName == VM_MagicNames.prepareWord) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLAddrX(T0,T1,T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitLWARX(T0,T1,T0);
      }
 else {
        asm.emitLDARX(T0,T1,T0);
      }
    }
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    popInt(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTWX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushInt(T0);
    }
 else {
      asm.emitSTWCXr(T2,T1,T0);
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushInt(T0);
    }
  }
 else   if (methodName == VM_MagicNames.attemptObject || methodName == VM_MagicNames.attemptAddress || methodName == VM_MagicNames.attemptWord) {
    popAddr(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTAddrX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushAddr(T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitSTWCXr(T2,T1,T0);
      }
 else {
        asm.emitSTDCXr(T2,T1,T0);
      }
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushInt(T0);
    }
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.saveThreadStateInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    peekAddr(T1,0);
    peekAddr(T0,1);
    asm.emitLAddrToc(S0,VM_Entrypoints.threadSwitchInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlots(2);
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.restoreHardwareExceptionStateInstructionsField.getOffset());
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.returnToNewStack) {
    peekAddr(FP,0);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.dynamicBridgeTo) {
    if (VM.VerifyAssertions)     VM._assert(klass.isDynamicBridge());
    peekAddr(T0,0);
    asm.emitMTCTR(T0);
    int offset=frameSize;
    for (int i=LAST_NONVOLATILE_FPR; i >= FIRST_VOLATILE_FPR; --i)     asm.emitLFD(i,offset-=BYTES_IN_DOUBLE,FP);
    for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_NONVOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    offset-=(FIRST_NONVOLATILE_GPR - LAST_VOLATILE_GPR - 1) * BYTES_IN_ADDRESS;
    for (int i=LAST_VOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    asm.emitLAddr(FP,0,FP);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCCTR();
  }
 else   if (methodName == VM_MagicNames.objectAsAddress || methodName == VM_MagicNames.addressAsByteArray || methodName == VM_MagicNames.addressAsIntArray || methodName == VM_MagicNames.addressAsObject || methodName == VM_MagicNames.addressAsObjectArray || methodName == VM_MagicNames.addressAsType || methodName == VM_MagicNames.objectAsType || methodName == VM_MagicNames.objectAsByteArray || methodName == VM_MagicNames.objectAsShortArray || methodName == VM_MagicNames.objectAsIntArray || methodName == VM_MagicNames.addressAsThread || methodName == VM_MagicNames.objectAsThread || methodName == VM_MagicNames.objectAsProcessor || methodName == VM_MagicNames.threadAsCollectorThread || methodName == VM_MagicNames.addressAsRegisters || methodName == VM_MagicNames.addressAsStack || methodName == VM_MagicNames.floatAsIntBits || methodName == VM_MagicNames.intBitsAsFloat || methodName == VM_MagicNames.doubleAsLongBits || methodName == VM_MagicNames.longBitsAsDouble) {
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    popAddr(T0);
    VM_ObjectModel.baselineEmitLoadTIB(asm,T0,T0);
    asm.emitLAddr(T0,TIB_TYPE_INDEX << LOG_BYTES_IN_ADDRESS,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    popAddr(T0);
    asm.emitLInt(T0,VM_ObjectModel.getArrayLengthOffset(),T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.sync) {
    asm.emitSYNC();
  }
 else   if (methodName == VM_MagicNames.isync) {
    asm.emitISYNC();
  }
 else   if (methodName == VM_MagicNames.dcbst) {
    popAddr(T0);
    asm.emitDCBST(0,T0);
  }
 else   if (methodName == VM_MagicNames.icbi) {
    popAddr(T0);
    asm.emitICBI(0,T0);
  }
 else   if (methodName == VM_MagicNames.wordToInt || methodName == VM_MagicNames.wordToAddress || methodName == VM_MagicNames.wordToOffset || methodName == VM_MagicNames.wordToExtent || methodName == VM_MagicNames.wordToWord) {
  }
 else   if (methodName == VM_MagicNames.wordToLong) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordFromInt || methodName == VM_MagicNames.wordFromIntSignExtend) {
    if (VM.BuildFor64Addr) {
      popInt(T0);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromIntZeroExtend) {
    if (VM.BuildFor64Addr) {
      asm.emitLWZ(T0,spTopOffset + BYTES_IN_STACKSLOT - BYTES_IN_INT,FP);
      pokeAddr(T0,0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromLong) {
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.wordAdd) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitADD(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordSub || methodName == VM_MagicNames.wordDiff) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitSUBFC(T2,T0,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordEQ) {
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordNE) {
    generateAddrComparison(false,NE);
  }
 else   if (methodName == VM_MagicNames.wordLT) {
    generateAddrComparison(false,LT);
  }
 else   if (methodName == VM_MagicNames.wordLE) {
    generateAddrComparison(false,LE);
  }
 else   if (methodName == VM_MagicNames.wordGT) {
    generateAddrComparison(false,GT);
  }
 else   if (methodName == VM_MagicNames.wordGE) {
    generateAddrComparison(false,GE);
  }
 else   if (methodName == VM_MagicNames.wordsLT) {
    generateAddrComparison(true,LT);
  }
 else   if (methodName == VM_MagicNames.wordsLE) {
    generateAddrComparison(true,LE);
  }
 else   if (methodName == VM_MagicNames.wordsGT) {
    generateAddrComparison(true,GT);
  }
 else   if (methodName == VM_MagicNames.wordsGE) {
    generateAddrComparison(true,GE);
  }
 else   if (methodName == VM_MagicNames.wordIsZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordIsMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordOne) {
    asm.emitLVAL(T0,1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordAnd) {
    popAddr(T0);
    popAddr(T1);
    asm.emitAND(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordOr) {
    popAddr(T0);
    popAddr(T1);
    asm.emitOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordNot) {
    popAddr(T0);
    asm.emitLVAL(T1,-1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordXor) {
    popAddr(T0);
    popAddr(T1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordLsh) {
    popInt(T0);
    popAddr(T1);
    asm.emitSLAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRshl) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRsha) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRA_Addr(T2,T1,T0);
    pushAddr(T2);
  }
 else {
    return false;
  }
  return true;
}","/** 
 * Generate inline code sequence for specified method.
 * @param methodToBeCalled: method whose name indicates semantics of code to be generated
 * @return true if there was magic defined for the method
 */
private boolean generateInlineCode(VM_MethodReference methodToBeCalled){
  VM_Atom methodName=methodToBeCalled.getName();
  if (methodToBeCalled.getType() == VM_TypeReference.SysCall) {
    VM_TypeReference[] args=methodToBeCalled.getParameterTypes();
    int paramWords=methodToBeCalled.getParameterWords();
    int gp=FIRST_OS_PARAMETER_GPR;
    int fp=FIRST_OS_PARAMETER_FPR;
    int stackIndex=paramWords;
    for (int i=0; i < args.length; i++) {
      VM_TypeReference t=args[i];
      if (t.isLongType()) {
        stackIndex-=2;
        if (VM.BuildFor64Addr) {
          peekLong(gp,gp,stackIndex);
          gp++;
        }
 else {
          gp+=(gp + 1) & 0x01;
          peekInt(gp++,stackIndex);
          peekInt(gp++,stackIndex + 1);
        }
      }
 else       if (t.isFloatType()) {
        stackIndex-=1;
        peekFloat(fp++,stackIndex);
      }
 else       if (t.isDoubleType()) {
        stackIndex-=2;
        peekDouble(fp++,stackIndex);
      }
 else       if (t.isIntLikeType()) {
        stackIndex-=1;
        peekInt(gp++,stackIndex);
      }
 else {
        stackIndex-=1;
        peekAddr(gp++,stackIndex);
      }
    }
    if (VM.VerifyAssertions) {
      VM._assert(stackIndex == 0);
      VM._assert(gp - 1 <= LAST_OS_PARAMETER_GPR);
      VM._assert(fp - 1 <= LAST_OS_PARAMETER_FPR);
    }
    int paramBytes=(VM.BuildFor64Addr ? args.length : paramWords) * BYTES_IN_STACKSLOT;
    VM_Field ip=VM_Entrypoints.getSysCallField(methodName.toString());
    generateSysCall(paramBytes,ip);
    discardSlots(paramWords);
    VM_TypeReference rtype=methodToBeCalled.getReturnType();
    if (rtype.isIntLikeType()) {
      pushInt(T0);
    }
 else     if (rtype.isWordType() || rtype.isReferenceType()) {
      pushAddr(T0);
    }
 else     if (rtype.isDoubleType()) {
      pushDouble(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isFloatType()) {
      pushFloat(FIRST_OS_PARAMETER_FPR);
    }
 else     if (rtype.isLongType()) {
      pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
    }
  }
 else   if (methodName == VM_MagicNames.getFramePointer) {
    pushAddr(FP);
  }
 else   if (methodName == VM_MagicNames.getCallerFramePointer) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setCallerFramePointer) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getCompiledMethodID) {
    popAddr(T0);
    asm.emitLInt(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
    pushInt(T1);
  }
 else   if (methodName == VM_MagicNames.setCompiledMethodID) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,STACKFRAME_METHOD_ID_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getNextInstructionAddress) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
    pushAddr(T1);
  }
 else   if (methodName == VM_MagicNames.setNextInstructionAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T0);
  }
 else   if (methodName == VM_MagicNames.getReturnAddressLocation) {
    popAddr(T0);
    asm.emitLAddr(T1,STACKFRAME_FRAME_POINTER_OFFSET,T0);
    asm.emitADDI(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.getTocPointer || methodName == VM_MagicNames.getJTOC) {
    pushAddr(JTOC);
  }
 else   if (methodName == VM_MagicNames.getProcessorRegister) {
    pushAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.setProcessorRegister) {
    popAddr(PROCESSOR_REGISTER);
  }
 else   if (methodName == VM_MagicNames.getTimeBase) {
    if (VM.BuildFor64Addr) {
      asm.emitMFTB(T1);
    }
 else {
      int label=asm.getMachineCodeIndex();
      asm.emitMFTBU(T0);
      asm.emitMFTB(T1);
      asm.emitMFTBU(T2);
      asm.emitCMP(T0,T2);
      asm.emitBC(NE,label);
    }
    pushLong(T0,T1);
  }
 else   if (methodName == VM_MagicNames.invokeMain) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    peekAddr(T0,0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.invokeClassInitializer) {
    popAddr(T0);
    asm.emitMTCTR(T0);
    asm.emitBCCTRL();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningVoid) {
    generateMethodInvocation();
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningInt) {
    generateMethodInvocation();
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningLong) {
    generateMethodInvocation();
    pushLong(T0,VM.BuildFor64Addr ? T0 : T1);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningFloat) {
    generateMethodInvocation();
    pushFloat(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningDouble) {
    generateMethodInvocation();
    pushDouble(F0);
  }
 else   if (methodName == VM_MagicNames.invokeMethodReturningObject) {
    generateMethodInvocation();
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.addressArrayCreate) {
    VM_Array type=methodToBeCalled.getType().resolve().asArray();
    emit_resolved_newarray(type);
  }
 else   if (methodName == VM_MagicNames.addressArrayLength) {
    emit_arraylength();
  }
 else   if (methodName == VM_MagicNames.addressArrayGet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iaload();
    }
 else {
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitLAddrX(T2,T0,T1);
      pushAddr(T2);
    }
  }
 else   if (methodName == VM_MagicNames.addressArraySet) {
    if (VM.BuildFor32Addr || methodToBeCalled.getType() == VM_TypeReference.CodeArray) {
      emit_iastore();
    }
 else {
      popAddr(T2);
      genBoundsCheck();
      asm.emitSLDI(T1,T1,LOG_BYTES_IN_ADDRESS);
      asm.emitSTAddrX(T2,T0,T1);
    }
  }
 else   if (methodName == VM_MagicNames.getIntAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLIntX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getObjectAtOffset || methodName == VM_MagicNames.getWordAtOffset || methodName == VM_MagicNames.getObjectArrayAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLAddrX(T0,T1,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getByteAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLBZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getCharAtOffset) {
    popInt(T1);
    popAddr(T0);
    asm.emitLHZX(T0,T1,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.setIntAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTWX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setObjectAtOffset || methodName == VM_MagicNames.setWordAtOffset) {
    popAddr(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTAddrX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setByteAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTBX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.setCharAtOffset) {
    popInt(T2);
    popInt(T1);
    popAddr(T0);
    asm.emitSTHX(T2,T1,T0);
  }
 else   if (methodName == VM_MagicNames.getLongAtOffset) {
    popInt(T2);
    popAddr(T1);
    if (VM.BuildFor32Addr) {
      asm.emitLWZX(T0,T1,T2);
      asm.emitADDI(T2,BYTES_IN_INT,T2);
      asm.emitLWZX(T1,T1,T2);
    }
 else {
      asm.emitLDX(T1,T1,T2);
    }
    pushLong(T0,T1);
  }
 else   if ((methodName == VM_MagicNames.setLongAtOffset) || (methodName == VM_MagicNames.setDoubleAtOffset)) {
    popLong(T3,T2);
    popInt(T1);
    popAddr(T0);
    if (VM.BuildFor32Addr) {
      asm.emitSTWX(T3,T1,T0);
      asm.emitADDI(T1,BYTES_IN_INT,T1);
      asm.emitSTWX(T2,T1,T0);
    }
 else {
      asm.emitSTDX(T2,T1,T0);
    }
  }
 else   if (methodName == VM_MagicNames.getMemoryInt) {
    popAddr(T0);
    asm.emitLInt(T0,0,T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.getMemoryWord || methodName == VM_MagicNames.getMemoryAddress) {
    popAddr(T0);
    asm.emitLAddr(T0,0,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryInt) {
    popInt(T1);
    popAddr(T0);
    asm.emitSTW(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.setMemoryWord || methodName == VM_MagicNames.setMemoryAddress) {
    popAddr(T1);
    popAddr(T0);
    asm.emitSTAddr(T1,0,T0);
  }
 else   if (methodName == VM_MagicNames.prepareInt) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLWZX(T0,T1,T0);
    }
 else {
      asm.emitLWARX(T0,T1,T0);
    }
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.prepareObject || methodName == VM_MagicNames.prepareAddress || methodName == VM_MagicNames.prepareWord) {
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitLAddrX(T0,T1,T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitLWARX(T0,T1,T0);
      }
 else {
        asm.emitLDARX(T0,T1,T0);
      }
    }
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.attemptInt) {
    popInt(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTWX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushAddr(T0);
    }
 else {
      asm.emitSTWCXr(T2,T1,T0);
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.attemptObject || methodName == VM_MagicNames.attemptAddress || methodName == VM_MagicNames.attemptWord) {
    popAddr(T2);
    discardSlot();
    popInt(T1);
    popAddr(T0);
    if (VM.BuildForSingleVirtualProcessor) {
      asm.emitSTAddrX(T2,T1,T0);
      asm.emitLVAL(T0,1);
      pushAddr(T0);
    }
 else {
      if (VM.BuildFor32Addr) {
        asm.emitSTWCXr(T2,T1,T0);
      }
 else {
        asm.emitSTDCXr(T2,T1,T0);
      }
      asm.emitLVAL(T0,0);
      VM_ForwardReference fr=asm.emitForwardBC(NE);
      asm.emitLVAL(T0,1);
      fr.resolve(asm);
      pushInt(T0);
    }
  }
 else   if (methodName == VM_MagicNames.saveThreadState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.saveThreadStateInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.threadSwitch) {
    peekAddr(T1,0);
    peekAddr(T0,1);
    asm.emitLAddrToc(S0,VM_Entrypoints.threadSwitchInstructionsField.getOffset());
    asm.emitMTCTR(S0);
    asm.emitBCCTRL();
    discardSlots(2);
  }
 else   if (methodName == VM_MagicNames.restoreHardwareExceptionState) {
    peekAddr(T0,0);
    asm.emitLAddrToc(S0,VM_Entrypoints.restoreHardwareExceptionStateInstructionsField.getOffset());
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.returnToNewStack) {
    peekAddr(FP,0);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCLR();
  }
 else   if (methodName == VM_MagicNames.dynamicBridgeTo) {
    if (VM.VerifyAssertions)     VM._assert(klass.isDynamicBridge());
    peekAddr(T0,0);
    asm.emitMTCTR(T0);
    int offset=frameSize;
    for (int i=LAST_NONVOLATILE_FPR; i >= FIRST_VOLATILE_FPR; --i)     asm.emitLFD(i,offset-=BYTES_IN_DOUBLE,FP);
    for (int i=LAST_NONVOLATILE_GPR; i >= FIRST_NONVOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    offset-=(FIRST_NONVOLATILE_GPR - LAST_VOLATILE_GPR - 1) * BYTES_IN_ADDRESS;
    for (int i=LAST_VOLATILE_GPR; i >= FIRST_VOLATILE_GPR; --i)     asm.emitLAddr(i,offset-=BYTES_IN_ADDRESS,FP);
    asm.emitLAddr(FP,0,FP);
    asm.emitLAddr(S0,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
    asm.emitMTLR(S0);
    asm.emitBCCTR();
  }
 else   if (methodName == VM_MagicNames.objectAsAddress || methodName == VM_MagicNames.addressAsByteArray || methodName == VM_MagicNames.addressAsIntArray || methodName == VM_MagicNames.addressAsObject || methodName == VM_MagicNames.addressAsObjectArray || methodName == VM_MagicNames.addressAsType || methodName == VM_MagicNames.objectAsType || methodName == VM_MagicNames.objectAsByteArray || methodName == VM_MagicNames.objectAsShortArray || methodName == VM_MagicNames.objectAsIntArray || methodName == VM_MagicNames.addressAsThread || methodName == VM_MagicNames.objectAsThread || methodName == VM_MagicNames.objectAsProcessor || methodName == VM_MagicNames.threadAsCollectorThread || methodName == VM_MagicNames.addressAsRegisters || methodName == VM_MagicNames.addressAsStack || methodName == VM_MagicNames.floatAsIntBits || methodName == VM_MagicNames.intBitsAsFloat || methodName == VM_MagicNames.doubleAsLongBits || methodName == VM_MagicNames.longBitsAsDouble) {
  }
 else   if (methodName == VM_MagicNames.getObjectType) {
    popAddr(T0);
    VM_ObjectModel.baselineEmitLoadTIB(asm,T0,T0);
    asm.emitLAddr(T0,TIB_TYPE_INDEX << LOG_BYTES_IN_ADDRESS,T0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.getArrayLength) {
    popAddr(T0);
    asm.emitLInt(T0,VM_ObjectModel.getArrayLengthOffset(),T0);
    pushInt(T0);
  }
 else   if (methodName == VM_MagicNames.sync) {
    asm.emitSYNC();
  }
 else   if (methodName == VM_MagicNames.isync) {
    asm.emitISYNC();
  }
 else   if (methodName == VM_MagicNames.dcbst) {
    popAddr(T0);
    asm.emitDCBST(0,T0);
  }
 else   if (methodName == VM_MagicNames.icbi) {
    popAddr(T0);
    asm.emitICBI(0,T0);
  }
 else   if (methodName == VM_MagicNames.wordToInt || methodName == VM_MagicNames.wordToAddress || methodName == VM_MagicNames.wordToOffset || methodName == VM_MagicNames.wordToExtent || methodName == VM_MagicNames.wordToWord) {
  }
 else   if (methodName == VM_MagicNames.wordToLong) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordFromInt || methodName == VM_MagicNames.wordFromIntSignExtend) {
    if (VM.BuildFor64Addr) {
      popInt(T0);
      pushAddr(T0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromIntZeroExtend) {
    if (VM.BuildFor64Addr) {
      asm.emitLWZ(T0,spTopOffset + BYTES_IN_STACKSLOT - BYTES_IN_INT,FP);
      pokeAddr(T0,0);
    }
  }
 else   if (methodName == VM_MagicNames.wordFromLong) {
    discardSlot();
  }
 else   if (methodName == VM_MagicNames.wordAdd) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitADD(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordSub || methodName == VM_MagicNames.wordDiff) {
    if (VM.BuildFor64Addr && (methodToBeCalled.getParameterTypes()[0] == VM_TypeReference.Int)) {
      popInt(T0);
    }
 else {
      popAddr(T0);
    }
    popAddr(T1);
    asm.emitSUBFC(T2,T0,T1);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordEQ) {
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordNE) {
    generateAddrComparison(false,NE);
  }
 else   if (methodName == VM_MagicNames.wordLT) {
    generateAddrComparison(false,LT);
  }
 else   if (methodName == VM_MagicNames.wordLE) {
    generateAddrComparison(false,LE);
  }
 else   if (methodName == VM_MagicNames.wordGT) {
    generateAddrComparison(false,GT);
  }
 else   if (methodName == VM_MagicNames.wordGE) {
    generateAddrComparison(false,GE);
  }
 else   if (methodName == VM_MagicNames.wordsLT) {
    generateAddrComparison(true,LT);
  }
 else   if (methodName == VM_MagicNames.wordsLE) {
    generateAddrComparison(true,LE);
  }
 else   if (methodName == VM_MagicNames.wordsGT) {
    generateAddrComparison(true,GT);
  }
 else   if (methodName == VM_MagicNames.wordsGE) {
    generateAddrComparison(true,GE);
  }
 else   if (methodName == VM_MagicNames.wordIsZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordIsMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
    generateAddrComparison(false,EQ);
  }
 else   if (methodName == VM_MagicNames.wordZero) {
    asm.emitLVAL(T0,0);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordOne) {
    asm.emitLVAL(T0,1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordMax) {
    asm.emitLVAL(T0,-1);
    pushAddr(T0);
  }
 else   if (methodName == VM_MagicNames.wordAnd) {
    popAddr(T0);
    popAddr(T1);
    asm.emitAND(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordOr) {
    popAddr(T0);
    popAddr(T1);
    asm.emitOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordNot) {
    popAddr(T0);
    asm.emitLVAL(T1,-1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordXor) {
    popAddr(T0);
    popAddr(T1);
    asm.emitXOR(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordLsh) {
    popInt(T0);
    popAddr(T1);
    asm.emitSLAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRshl) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRAddr(T2,T1,T0);
    pushAddr(T2);
  }
 else   if (methodName == VM_MagicNames.wordRsha) {
    popInt(T0);
    popAddr(T1);
    asm.emitSRA_Addr(T2,T1,T0);
    pushAddr(T2);
  }
 else {
    return false;
  }
  return true;
}",0.999601321335004
150246,"/** 
 * Allocate a scalar object.
 * @param size Size in bytes of the object, including any headersthat need space.
 * @param tib  Type of the object (pointer to TIB).
 * @param allocator Specify which allocation scheme/area JMTk shouldallocate the memory from.
 * @param align the alignment requested; must be a power of 2.
 * @param offset the offset at which the alignment is desired.
 * @return the initialized Object
 */
public static Object allocateScalar(int size,Object[] tib,int allocator,int align,int offset) throws VM_PragmaUninterruptible, VM_PragmaInline {
  Plan plan=VM_Interface.getPlan();
  if (BYTES_IN_ADDRESS != BYTES_IN_INT)   size=VM_Memory.alignUp(size,BYTES_IN_ADDRESS);
  int rawSize=(align != BYTES_IN_ADDRESS) ? (size + align) : size;
  AllocAdvice advice=plan.getAllocAdvice(null,rawSize,null,null);
  VM_Address region=plan.alloc(rawSize,true,allocator,advice);
  if (CHECK_MEMORY_IS_ZEROED)   Memory.assertIsZeroed(region,rawSize);
  if (align != BYTES_IN_ADDRESS) {
    VM_Word mask=VM_Word.fromIntSignExtend(align - 1);
    VM_Word negOff=VM_Word.fromIntSignExtend(-offset);
    VM_Offset delta=negOff.sub(region.toWord()).and(mask).toOffset();
    region=region.add(delta);
  }
  Object result=VM_ObjectModel.initializeScalar(region,tib,size);
  plan.postAlloc(VM_Magic.objectAsAddress(result),tib,rawSize,true,allocator);
  return result;
}","/** 
 * Allocate a scalar object.
 * @param size Size in bytes of the object, including any headersthat need space.
 * @param tib  Type of the object (pointer to TIB).
 * @param allocator Specify which allocation scheme/area JMTk shouldallocate the memory from.
 * @param align the alignment requested; must be a power of 2.
 * @param offset the offset at which the alignment is desired.
 * @return the initialized Object
 */
public static Object allocateScalar(int size,Object[] tib,int allocator,int align,int offset) throws VM_PragmaUninterruptible, VM_PragmaInline {
  Plan plan=VM_Interface.getPlan();
  int alignedSize=size;
  if (BYTES_IN_ADDRESS != BYTES_IN_INT)   alignedSize=VM_Memory.alignUp(size,BYTES_IN_ADDRESS);
  int rawSize=(align != BYTES_IN_ADDRESS) ? (alignedSize + align) : alignedSize;
  AllocAdvice advice=plan.getAllocAdvice(null,rawSize,null,null);
  VM_Address region=plan.alloc(rawSize,true,allocator,advice);
  if (CHECK_MEMORY_IS_ZEROED)   Memory.assertIsZeroed(region,rawSize);
  if (align != BYTES_IN_ADDRESS) {
    VM_Word mask=VM_Word.fromIntSignExtend(align - 1);
    VM_Word negOff=VM_Word.fromIntSignExtend(-offset);
    VM_Offset delta=negOff.sub(region.toWord()).and(mask).toOffset();
    region=region.add(delta);
  }
  Object result=VM_ObjectModel.initializeScalar(region,tib,size);
  plan.postAlloc(VM_Magic.objectAsAddress(result),tib,rawSize,true,allocator);
  return result;
}",0.98175313059034
150247,"/** 
 * Generate instructions for a basic block. May discover other basic blocks that need to be generated along the way.
 * @param fromIndex bytecode index to start from
 */
private void generateFrom(int fromIndex){
  if (DBG_BB || DBG_SELECTED) {
    db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
  }
  currentBBLE.setGenerated();
  endOfBasicBlock=fallThrough=false;
  lastInstr=null;
  bcodes.reset(fromIndex);
  while (true) {
    currentBBLE.high=instrIndex=bcodes.index();
    int code=bcodes.nextInstruction();
    if (DBG_BCPARSE) {
      db(""String_Node_Str"" + instrIndex + ""String_Node_Str""+ code+ ""String_Node_Str""+ Integer.toHexString(code));
    }
    OPT_Instruction s=null;
    lastOsrBarrier=null;
switch (code) {
case JBC_nop:
      break;
case JBC_aconst_null:
    push(new OPT_NullConstantOperand());
  break;
case JBC_iconst_m1:
case JBC_iconst_0:
case JBC_iconst_1:
case JBC_iconst_2:
case JBC_iconst_3:
case JBC_iconst_4:
case JBC_iconst_5:
push(new OPT_IntConstantOperand(code - JBC_iconst_0));
break;
case JBC_lconst_0:
case JBC_lconst_1:
pushDual(new OPT_LongConstantOperand(code - JBC_lconst_0));
break;
case JBC_fconst_0:
push(new OPT_FloatConstantOperand(0.f));
break;
case JBC_fconst_1:
push(new OPT_FloatConstantOperand(1.f));
break;
case JBC_fconst_2:
push(new OPT_FloatConstantOperand(2.f));
break;
case JBC_dconst_0:
pushDual(new OPT_DoubleConstantOperand(0.));
break;
case JBC_dconst_1:
pushDual(new OPT_DoubleConstantOperand(1.));
break;
case JBC_bipush:
push(new OPT_IntConstantOperand(bcodes.getByteValue()));
break;
case JBC_sipush:
push(new OPT_IntConstantOperand(bcodes.getShortValue()));
break;
case JBC_ldc:
push(getConstantOperand(bcodes.getConstantIndex()));
break;
case JBC_ldc_w:
push(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_ldc2_w:
pushDual(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_iload:
s=do_iload(bcodes.getLocalNumber());
break;
case JBC_lload:
s=do_lload(bcodes.getLocalNumber());
break;
case JBC_fload:
s=do_fload(bcodes.getLocalNumber());
break;
case JBC_dload:
s=do_dload(bcodes.getLocalNumber());
break;
case JBC_aload:
s=do_aload(bcodes.getLocalNumber());
break;
case JBC_iload_0:
case JBC_iload_1:
case JBC_iload_2:
case JBC_iload_3:
s=do_iload(code - JBC_iload_0);
break;
case JBC_lload_0:
case JBC_lload_1:
case JBC_lload_2:
case JBC_lload_3:
s=do_lload(code - JBC_lload_0);
break;
case JBC_fload_0:
case JBC_fload_1:
case JBC_fload_2:
case JBC_fload_3:
s=do_fload(code - JBC_fload_0);
break;
case JBC_dload_0:
case JBC_dload_1:
case JBC_dload_2:
case JBC_dload_3:
s=do_dload(code - JBC_dload_0);
break;
case JBC_aload_0:
case JBC_aload_1:
case JBC_aload_2:
case JBC_aload_3:
s=do_aload(code - JBC_aload_0);
break;
case JBC_iaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=_aloadHelper(INT_ALOAD,ref,index,VM_TypeReference.Int);
}
break;
case JBC_laload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=_aloadHelper(LONG_ALOAD,ref,index,VM_TypeReference.Long);
}
break;
case JBC_faload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=_aloadHelper(FLOAT_ALOAD,ref,index,VM_TypeReference.Float);
}
break;
case JBC_daload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=_aloadHelper(DOUBLE_ALOAD,ref,index,VM_TypeReference.Double);
}
break;
case JBC_aaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
s=_aloadHelper(REF_ALOAD,ref,index,type);
}
break;
case JBC_baload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) s=_aloadHelper(BYTE_ALOAD,ref,index,VM_TypeReference.Byte);
 else s=_aloadHelper(UBYTE_ALOAD,ref,index,VM_TypeReference.Boolean);
}
break;
case JBC_caload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=_aloadHelper(USHORT_ALOAD,ref,index,VM_TypeReference.Char);
}
break;
case JBC_saload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=_aloadHelper(SHORT_ALOAD,ref,index,VM_TypeReference.Short);
}
break;
case JBC_istore:
s=do_store(bcodes.getLocalNumber(),popInt());
break;
case JBC_lstore:
s=do_store(bcodes.getLocalNumber(),popLong());
break;
case JBC_fstore:
s=do_store(bcodes.getLocalNumber(),popFloat());
break;
case JBC_dstore:
s=do_store(bcodes.getLocalNumber(),popDouble());
break;
case JBC_astore:
s=do_astore(bcodes.getLocalNumber());
break;
case JBC_istore_0:
case JBC_istore_1:
case JBC_istore_2:
case JBC_istore_3:
s=do_store(code - JBC_istore_0,popInt());
break;
case JBC_lstore_0:
case JBC_lstore_1:
case JBC_lstore_2:
case JBC_lstore_3:
s=do_store(code - JBC_lstore_0,popLong());
break;
case JBC_fstore_0:
case JBC_fstore_1:
case JBC_fstore_2:
case JBC_fstore_3:
s=do_store(code - JBC_fstore_0,popFloat());
break;
case JBC_dstore_0:
case JBC_dstore_1:
case JBC_dstore_2:
case JBC_dstore_3:
s=do_store(code - JBC_dstore_0,popDouble());
break;
case JBC_astore_0:
case JBC_astore_1:
case JBC_astore_2:
case JBC_astore_3:
s=do_astore(code - JBC_astore_0);
break;
case JBC_iastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=AStore.create(INT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Int),getCurrentGuard());
}
break;
case JBC_lastore:
{
OPT_Operand val=popLong();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=AStore.create(LONG_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Long),getCurrentGuard());
}
break;
case JBC_fastore:
{
OPT_Operand val=popFloat();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=AStore.create(FLOAT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Float),getCurrentGuard());
}
break;
case JBC_dastore:
{
OPT_Operand val=popDouble();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=AStore.create(DOUBLE_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Double),getCurrentGuard());
}
break;
case JBC_aastore:
{
OPT_Operand val=pop();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
if (do_CheckStore(ref,val,type)) break;
s=AStore.create(REF_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_bastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) type=VM_TypeReference.Byte;
 else type=VM_TypeReference.Boolean;
s=AStore.create(BYTE_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_castore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Char),getCurrentGuard());
}
break;
case JBC_sastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Short),getCurrentGuard());
}
break;
case JBC_pop:
stack.pop();
break;
case JBC_pop2:
stack.pop2();
break;
case JBC_dup:
{
OPT_Operand op1=stack.pop();
stack.push(op1);
s=pushCopy(op1);
}
break;
case JBC_dup_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op1);
stack.push(op3);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op2);
stack.push(op1);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
OPT_Operand op4=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op4);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_swap:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
}
break;
case JBC_iadd:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_ADD,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ladd:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_ADD,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fadd:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_ADD,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dadd:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_ADD,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_isub:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SUB,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lsub:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SUB,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fsub:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_SUB,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dsub:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_SUB,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_imul:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_MUL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lmul:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_MUL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fmul:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_MUL,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dmul:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_MUL,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_idiv:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_ldiv:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_fdiv:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_DIV,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_ddiv:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_DIV,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_irem:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_lrem:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_frem:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_REM,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_drem:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_REM,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_ineg:
s=_unaryHelper(INT_NEG,popInt(),VM_TypeReference.Int);
break;
case JBC_lneg:
s=_unaryDualHelper(LONG_NEG,popLong(),VM_TypeReference.Long);
break;
case JBC_fneg:
s=_unaryHelper(FLOAT_NEG,popFloat(),VM_TypeReference.Float);
break;
case JBC_dneg:
s=_unaryDualHelper(DOUBLE_NEG,popDouble(),VM_TypeReference.Double);
break;
case JBC_ishl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ishr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_USHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_USHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iand:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_AND,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_land:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_AND,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ior:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_OR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_OR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ixor:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_XOR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lxor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_XOR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iinc:
{
int index=bcodes.getLocalNumber();
s=do_iinc(index,bcodes.getIncrement());
}
break;
case JBC_i2l:
s=_unaryDualHelper(INT_2LONG,popInt(),VM_TypeReference.Long);
break;
case JBC_i2f:
s=_unaryHelper(INT_2FLOAT,popInt(),VM_TypeReference.Float);
break;
case JBC_i2d:
s=_unaryDualHelper(INT_2DOUBLE,popInt(),VM_TypeReference.Double);
break;
case JBC_l2i:
s=_unaryHelper(LONG_2INT,popLong(),VM_TypeReference.Int);
break;
case JBC_l2f:
s=_unaryHelper(LONG_2FLOAT,popLong(),VM_TypeReference.Float);
break;
case JBC_l2d:
s=_unaryDualHelper(LONG_2DOUBLE,popLong(),VM_TypeReference.Double);
break;
case JBC_f2i:
s=_unaryHelper(FLOAT_2INT,popFloat(),VM_TypeReference.Int);
break;
case JBC_f2l:
s=_unaryDualHelper(FLOAT_2LONG,popFloat(),VM_TypeReference.Long);
break;
case JBC_f2d:
s=_unaryDualHelper(FLOAT_2DOUBLE,popFloat(),VM_TypeReference.Double);
break;
case JBC_d2i:
s=_unaryHelper(DOUBLE_2INT,popDouble(),VM_TypeReference.Int);
break;
case JBC_d2l:
s=_unaryDualHelper(DOUBLE_2LONG,popDouble(),VM_TypeReference.Long);
break;
case JBC_d2f:
s=_unaryHelper(DOUBLE_2FLOAT,popDouble(),VM_TypeReference.Float);
break;
case JBC_int2byte:
s=_unaryHelper(INT_2BYTE,popInt(),VM_TypeReference.Byte);
break;
case JBC_int2char:
s=_unaryHelper(INT_2USHORT,popInt(),VM_TypeReference.Char);
break;
case JBC_int2short:
s=_unaryHelper(INT_2SHORT,popInt(),VM_TypeReference.Short);
break;
case JBC_lcmp:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryHelper(LONG_CMP,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpl:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpg:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpl:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpg:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ifeq:
s=_intIfHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifne:
s=_intIfHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_iflt:
s=_intIfHelper(OPT_ConditionOperand.LESS());
break;
case JBC_ifge:
s=_intIfHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_ifgt:
s=_intIfHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_ifle:
s=_intIfHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_icmpeq:
s=_intIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_icmpne:
s=_intIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_if_icmplt:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS());
break;
case JBC_if_icmpge:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_if_icmpgt:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_if_icmple:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_acmpeq:
s=_refIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_acmpne:
s=_refIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto:
{
int offset=bcodes.getBranchOffset();
if (offset != 3) s=_gotoHelper(offset);
}
break;
case JBC_jsr:
s=_jsrHelper(bcodes.getBranchOffset());
break;
case JBC_ret:
s=_retHelper(bcodes.getLocalNumber());
break;
case JBC_tableswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int low=bcodes.getLowSwitchValue();
int high=bcodes.getHighSwitchValue();
int number=high - low + 1;
if (CF_TABLESWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeTableSwitchOffset(v1,low,high);
int offset=match == 0 ? defaultoff : match;
bcodes.skipTableSwitchOffsets(number);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=TableSwitch.create(TABLESWITCH,op0,null,null,new OPT_IntConstantOperand(low),new OPT_IntConstantOperand(high),generateTarget(defaultoff),null,number * 2);
for (int i=0; i < number; ++i) {
TableSwitch.setTarget(s,i,generateTarget(bcodes.getTableSwitchOffset(i)));
}
bcodes.skipTableSwitchOffsets(number);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(number + 1);
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_lookupswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int numpairs=bcodes.getSwitchLength();
if (numpairs == 0) {
s=_gotoHelper(defaultoff);
break;
}
if (CF_LOOKUPSWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeLookupSwitchOffset(v1,numpairs);
int offset=match == 0 ? defaultoff : match;
bcodes.skipLookupSwitchPairs(numpairs);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=LookupSwitch.create(LOOKUPSWITCH,op0,null,null,generateTarget(defaultoff),null,numpairs * 3);
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setMatch(s,i,new OPT_IntConstantOperand(bcodes.getLookupSwitchValue(i)));
LookupSwitch.setTarget(s,i,generateTarget(bcodes.getLookupSwitchOffset(i)));
}
bcodes.skipLookupSwitchPairs(numpairs);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(numpairs + 1);
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_ireturn:
_returnHelper(INT_MOVE,popInt());
break;
case JBC_lreturn:
_returnHelper(LONG_MOVE,popLong());
break;
case JBC_freturn:
_returnHelper(FLOAT_MOVE,popFloat());
break;
case JBC_dreturn:
_returnHelper(DOUBLE_MOVE,popDouble());
break;
case JBC_areturn:
{
OPT_Operand op0=popRef();
if (VM.VerifyAssertions && !op0.isDefinitelyNull()) {
VM_TypeReference retType=getRefTypeOf(op0);
if (retType != VM_TypeReference.JavaLangObject) assertIsAssignable(gc.method.getReturnType(),getRefTypeOf(op0));
}
_returnHelper(REF_MOVE,op0);
}
break;
case JBC_return:
_returnHelper(null,null);
break;
case JBC_getstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
if (!fieldType.isDoubleType() && !fieldType.isFloatType()) {
if (field.isFinal()) {
VM_Class declaringClass=field.getDeclaringClass();
if (declaringClass.isInitialized() || (VM.writingBootImage && declaringClass.isInBootImage())) {
try {
if (fieldType.isPrimitiveType()) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
if (OPT_StaticFieldReader.isStaticFieldNull(field)) {
push(new OPT_NullConstantOperand(),fieldType);
break;
}
 else {
VM_TypeReference rtType=OPT_StaticFieldReader.getTypeFromStaticField(field);
if (rtType == VM_TypeReference.JavaLangString) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
t.type=rtType;
if (rtType != fieldType) t.clearDeclaredType();
t.setPreciseType();
markGuardlessNonNull(t);
}
}
}
}
 catch (NoSuchFieldException e) {
}
}
}
}
}
s=GetStatic.create(GETSTATIC,t,offsetOp,fieldOp);
push(t.copyD2U(),fieldType);
}
break;
case JBC_putstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand r=pop(fieldType);
s=PutStatic.create(PUTSTATIC,r,offsetOp,fieldOp);
}
break;
case JBC_getfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
}
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
s=GetField.create(GETFIELD,t,op1,offsetOp,fieldOp,getCurrentGuard());
push(t.copyD2U(),fieldType);
}
break;
case JBC_putfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
OPT_Operand val=pop(fieldType);
OPT_Operand obj=popRef();
clearCurrentGuard();
if (do_NullCheck(obj)) break;
s=PutField.create(PUTFIELD,val,obj,offsetOp,fieldOp,getCurrentGuard());
}
break;
case JBC_invokevirtual:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
OPT_MethodOperand methOp=OPT_MethodOperand.VIRTUAL(ref,target);
if (this.osrGuardedInline) {
lastOsrBarrier=_createOsrBarrier();
}
s=_callHelper(ref,methOp);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
if (VM.VerifyAssertions) VM._assert(target != null);
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean isExtant=false;
boolean isPreciseType=false;
VM_TypeReference tr=null;
if (receiver.isRegister()) {
OPT_RegisterOperand rop=receiver.asRegister();
isExtant=rop.isExtant();
isPreciseType=rop.isPreciseType();
tr=rop.type;
}
 else if (receiver.isStringConstant()) {
isExtant=true;
isPreciseType=true;
tr=VM_TypeReference.JavaLangString;
}
 else if (VM.VerifyAssertions) {
VM._assert(false,""String_Node_Str"");
}
VM_Type type=tr.peekResolvedType();
if (type != null && type.isResolved() && type.isClassType() && target != null && type != target.getDeclaringClass()) {
VM_Method vmeth=OPT_ClassLoaderProxy.lookupMethod(type.asClass(),ref);
if (vmeth != null && vmeth != target) {
methOp.refine(vmeth,isPreciseType);
}
}
if (maybeInlineMethod(shouldInline(s,isExtant),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokespecial:
{
VM_MethodReference ref=bcodes.getMethodReference();
VM_Method target=ref.resolveInvokeSpecial();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.SPECIAL(ref,target));
if (target == null) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokestatic:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.STATIC(ref,target));
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokeinterface:
{
VM_MethodReference ref=bcodes.getMethodReference();
bcodes.alignInvokeInterface();
VM_Method resolvedMethod=null;
resolvedMethod=ref.peekInterfaceMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.INTERFACE(ref,resolvedMethod));
OPT_RegisterOperand receiver=Call.getParam(s,0).asRegister();
VM_Class receiverType=(VM_Class)receiver.type.peekResolvedType();
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean requiresImplementsTest=VM.BuildForIMTInterfaceInvocation || (VM.BuildForITableInterfaceInvocation && VM.DirectlyIndexedITables);
if (requiresImplementsTest) {
if (resolvedMethod == null) {
OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
OPT_Instruction getTib=GuardedUnary.create(GET_OBJ_TIB,tibPtr,receiver.copyU2U(),getCurrentGuard());
appendInstruction(getTib);
getTib.bcIndex=RUNTIME_SERVICES_BCI;
VM_Method target=VM_Entrypoints.unresolvedInvokeinterfaceImplementsTestMethod;
OPT_Instruction callCheck=Call.create2(CALL,null,new OPT_IntConstantOperand(target.getOffset()),OPT_MethodOperand.STATIC(target),new OPT_IntConstantOperand(ref.getId()),tibPtr.copyD2U());
if (gc.options.NO_CALLEE_EXCEPTIONS) {
callCheck.markAsNonPEI();
}
appendInstruction(callCheck);
callCheck.bcIndex=RUNTIME_SERVICES_BCI;
requiresImplementsTest=false;
rectifyStateWithErrorHandler();
}
 else {
VM_Type interfaceType=resolvedMethod.getDeclaringClass();
if (receiverType != null && receiverType.isResolved() && !receiverType.isInterface()) {
byte doesImplement=OPT_ClassLoaderProxy.includesType(interfaceType.getTypeRef(),receiverType.getTypeRef());
requiresImplementsTest=doesImplement != YES;
}
}
}
if (receiverType != null && receiverType.isInitialized() && !receiverType.isInterface()) {
VM_Method vmeth=OPT_ClassLoaderProxy.lookupMethod(receiverType,ref);
if (vmeth != null) {
VM_MethodReference vmethRef=vmeth.getMemberRef().asMethodReference();
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
rectifyStateWithErrorHandler();
}
OPT_MethodOperand mop=OPT_MethodOperand.VIRTUAL(vmethRef,vmeth);
if (receiver.isPreciseType()) {
mop.refine(vmeth,true);
}
Call.setMethod(s,mop);
boolean unresolved=vmethRef.needsDynamicLink(bcodes.method());
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(vmeth.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,receiver.isExtant()),s)) {
return;
}
}
}
 else {
if (resolvedMethod != null && maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
 else {
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
}
}
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_xxxunusedxxx:
OPT_OptimizingCompilerException.UNREACHABLE();
break;
case JBC_new:
{
VM_TypeReference klass=bcodes.getTypeReference();
OPT_RegisterOperand t=gc.temps.makeTemp(klass);
t.setPreciseType();
markGuardlessNonNull(t);
OPT_Operator operator;
OPT_TypeOperand klassOp;
VM_Class klassType=(VM_Class)klass.peekResolvedType();
if (klassType != null && (klassType.isInitialized() || klassType.isInBootImage())) {
klassOp=makeTypeOperand(klassType);
operator=NEW;
}
 else {
operator=NEW_UNRESOLVED;
klassOp=makeTypeOperand(klass);
}
s=New.create(operator,t,klassOp);
push(t.copyD2U());
rectifyStateWithErrorHandler();
}
break;
case JBC_newarray:
{
VM_Type array=bcodes.getPrimitiveArrayType();
OPT_TypeOperand arrayOp=makeTypeOperand(array);
OPT_RegisterOperand t=gc.temps.makeTemp(array.getTypeRef());
t.setPreciseType();
markGuardlessNonNull(t);
s=NewArray.create(NEWARRAY,t,arrayOp,popInt());
push(t.copyD2U());
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_anewarray:
{
VM_TypeReference elementTypeRef=bcodes.getTypeReference();
s=generateAnewarray(elementTypeRef);
}
break;
case JBC_arraylength:
{
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
if (VM.VerifyAssertions) VM._assert(getArrayTypeOf(op1).isArrayType());
OPT_RegisterOperand t=gc.temps.makeTempInt();
s=GuardedUnary.create(ARRAYLENGTH,t,op1,getCurrentGuard());
push(t.copyD2U());
}
break;
case JBC_athrow:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
VM_TypeReference type=getRefTypeOf(op0);
if (VM.VerifyAssertions) {
if (type != VM_TypeReference.JavaLangObject) assertIsAssignable(VM_TypeReference.JavaLangThrowable,type);
}
if (!gc.method.isInterruptible()) {
appendInstruction(Empty.create(UNINT_END));
}
endOfBasicBlock=true;
OPT_BasicBlock definiteTarget=rectifyStateWithExceptionHandler(type,true);
if (definiteTarget != null) {
appendInstruction(CacheOp.create(SET_CAUGHT_EXCEPTION,op0));
s=Goto.create(GOTO,definiteTarget.makeJumpTarget());
}
 else {
s=Athrow.create(ATHROW,(OPT_RegisterOperand)op0);
}
}
break;
case JBC_checkcast:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (typeRef.isWordType()) {
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
if (DBG_CF) db(""String_Node_Str"" + typeRef);
break;
}
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_CHECKCAST && !classLoading) {
if (op2.isDefinitelyNull()) {
push(op2);
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
if (OPT_ClassLoaderProxy.includesType(typeRef,type) == YES) {
push(op2);
if (DBG_CF) db(""String_Node_Str"" + op2 + ""String_Node_Str""+ typeRef+ ""String_Node_Str""+ type);
break;
}
}
if (!gc.options.NO_CHECKCAST) {
if (classLoading) {
s=TypeCheck.create(CHECKCAST_UNRESOLVED,op2,makeTypeOperand(typeRef));
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=TypeCheck.create(CHECKCAST_NOTNULL,op2,typeOp,getGuard(op2));
}
 else {
s=TypeCheck.create(CHECKCAST,op2,typeOp);
}
}
}
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangClassCastException);
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_instanceof:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_INSTANCEOF && !classLoading) {
if (op2.isDefinitelyNull()) {
push(new OPT_IntConstantOperand(0));
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
int answer=OPT_ClassLoaderProxy.includesType(typeRef,type);
if (answer == YES && isNonNull(op2)) {
push(new OPT_IntConstantOperand(1));
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
break;
}
 else if (answer == NO) {
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
push(new OPT_IntConstantOperand(0));
break;
}
}
OPT_RegisterOperand t=gc.temps.makeTempInt();
if (classLoading) {
s=InstanceOf.create(INSTANCEOF_UNRESOLVED,t,makeTypeOperand(typeRef),op2);
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=InstanceOf.create(INSTANCEOF_NOTNULL,t,typeOp,op2,getGuard(op2));
}
 else {
s=InstanceOf.create(INSTANCEOF,t,typeOp,op2);
}
}
push(t.copyD2U());
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_monitorenter:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (VM.VerifyAssertions) VM._assert(op0.isRef());
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITORENTER,op0,getCurrentGuard());
}
}
break;
case JBC_monitorexit:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITOREXIT,op0,getCurrentGuard());
}
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangIllegalMonitorStateException);
}
break;
case JBC_wide:
{
int widecode=bcodes.getWideOpcode();
int index=bcodes.getWideLocalNumber();
switch (widecode) {
case JBC_iload:
s=do_iload(index);
break;
case JBC_lload:
s=do_lload(index);
break;
case JBC_fload:
s=do_fload(index);
break;
case JBC_dload:
s=do_dload(index);
break;
case JBC_aload:
s=do_aload(index);
break;
case JBC_istore:
s=do_store(index,popInt());
break;
case JBC_lstore:
s=do_store(index,popLong());
break;
case JBC_fstore:
s=do_store(index,popFloat());
break;
case JBC_dstore:
s=do_store(index,popDouble());
break;
case JBC_astore:
s=do_astore(index);
break;
case JBC_iinc:
s=do_iinc(index,bcodes.getWideIncrement());
break;
case JBC_ret:
s=_retHelper(index);
break;
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
}
break;
case JBC_multianewarray:
{
VM_TypeReference arrayType=bcodes.getTypeReference();
OPT_TypeOperand typeOp=makeTypeOperand(arrayType);
int dimensions=bcodes.getArrayDimension();
OPT_TypeOperand dimArrayType=makeTypeOperand(VM_Array.IntArray);
OPT_RegisterOperand dimArray=gc.temps.makeTemp(VM_TypeReference.IntArray);
markGuardlessNonNull(dimArray);
dimArray.setPreciseType();
appendInstruction(NewArray.create(NEWARRAY,dimArray,dimArrayType,new OPT_IntConstantOperand(dimensions)));
for (int i=dimensions; i > 0; i--) {
OPT_LocationOperand loc=new OPT_LocationOperand(VM_TypeReference.Int);
appendInstruction(AStore.create(INT_ASTORE,popInt(),dimArray.copyD2U(),new OPT_IntConstantOperand(i - 1),loc,new OPT_TrueGuardOperand()));
}
OPT_RegisterOperand result=gc.temps.makeTemp(arrayType);
markGuardlessNonNull(result);
result.setPreciseType();
appendInstruction(NewArray.create(NEWOBJMULTIARRAY,result,typeOp,dimArray.copyD2U()));
push(result.copyD2U());
rectifyStateWithErrorHandler();
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_ifnull:
s=_refIfNullHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifnonnull:
s=_refIfNullHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto_w:
{
int offset=bcodes.getWideBranchOffset();
if (offset != 5) s=_gotoHelper(offset);
}
break;
case JBC_jsr_w:
s=_jsrHelper(bcodes.getWideBranchOffset());
break;
case JBC_impdep1:
{
int pseudo_opcode=bcodes.nextPseudoInstruction();
switch (pseudo_opcode) {
case PSEUDO_LoadIntConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new OPT_IntConstantOperand(value));
param1=param2;
param2=value;
break;
}
case PSEUDO_LoadLongConst:
{
long value=bcodes.readLongConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateLongLiteral(value);
pushDual(new OPT_LongConstantOperand(value,offset));
break;
}
case PSEUDO_LoadFloatConst:
{
int ibits=bcodes.readIntConst();
float value=Float.intBitsToFloat(ibits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateFloatLiteral(ibits);
push(new OPT_FloatConstantOperand(value,offset));
break;
}
case PSEUDO_LoadDoubleConst:
{
long lbits=bcodes.readLongConst();
double value=VM_Magic.longBitsAsDouble(lbits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + lbits);
int offset=VM_Statics.findOrCreateDoubleLiteral(lbits);
pushDual(new OPT_DoubleConstantOperand(value,offset));
break;
}
case PSEUDO_LoadAddrConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new ReturnAddressOperand(value));
break;
}
case PSEUDO_InvokeStatic:
{
VM_Method meth=null;
int targetidx=bcodes.readIntConst();
switch (targetidx) {
case GETREFAT:
meth=VM_Entrypoints.osrGetRefAtMethod;
break;
case CLEANREFS:
meth=VM_Entrypoints.osrCleanRefsMethod;
break;
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + targetidx);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.STATIC(meth));
Call.setAddress(s,new OPT_IntConstantOperand(meth.getOffset()));
if (targetidx == GETREFAT) {
Object realObj=OSR_ObjectHolder.getRefAt(param1,param2);
if (VM.VerifyAssertions) VM._assert(realObj != null);
VM_TypeReference klass=VM_Magic.getObjectType(realObj).getTypeRef();
OPT_RegisterOperand op0=gc.temps.makeTemp(klass);
Call.setResult(s,op0);
pop();
push(op0.copyD2U(),klass);
}
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_InvokeCompiledMethod:
{
int cmid=bcodes.readIntConst();
int origBCIdx=bcodes.readIntConst();
VM_CompiledMethod cm=VM_CompiledMethods.getCompiledMethod(cmid);
VM_Method meth=cm.getMethod();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.COMPILED(meth,cm.getOsrJTOCoffset()));
s.bcIndex=origBCIdx + bciAdjustment;
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_ParamInitEnd:
{
break;
}
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + pseudo_opcode);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
break;
}
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (s != null && !currentBBLE.isSelfRegen()) {
appendInstruction(s);
}
if (VM.VerifyAssertions) VM._assert(bcodes.index() <= runoff);
if (!endOfBasicBlock && bcodes.index() == runoff) {
if (DBG_BB || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
endOfBasicBlock=fallThrough=true;
}
if (endOfBasicBlock) {
if (currentBBLE.isSelfRegen()) {
currentBBLE.block.deleteOut();
if (DBG_CFG || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE.block);
return;
}
if (fallThrough) {
if (VM.VerifyAssertions) VM._assert(bcodes.index() < bcodes.length());
currentBBLE.fallThrough=getOrCreateBlock(bcodes.index());
currentBBLE.block.insertOut(currentBBLE.fallThrough.block);
}
return;
}
}
}","/** 
 * Generate instructions for a basic block. May discover other basic blocks that need to be generated along the way.
 * @param fromIndex bytecode index to start from
 */
private void generateFrom(int fromIndex){
  if (DBG_BB || DBG_SELECTED) {
    db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
  }
  currentBBLE.setGenerated();
  endOfBasicBlock=fallThrough=false;
  lastInstr=null;
  bcodes.reset(fromIndex);
  while (true) {
    currentBBLE.high=instrIndex=bcodes.index();
    int code=bcodes.nextInstruction();
    if (DBG_BCPARSE) {
      db(""String_Node_Str"" + instrIndex + ""String_Node_Str""+ code+ ""String_Node_Str""+ Integer.toHexString(code));
    }
    OPT_Instruction s=null;
    lastOsrBarrier=null;
switch (code) {
case JBC_nop:
      break;
case JBC_aconst_null:
    push(new OPT_NullConstantOperand());
  break;
case JBC_iconst_m1:
case JBC_iconst_0:
case JBC_iconst_1:
case JBC_iconst_2:
case JBC_iconst_3:
case JBC_iconst_4:
case JBC_iconst_5:
push(new OPT_IntConstantOperand(code - JBC_iconst_0));
break;
case JBC_lconst_0:
case JBC_lconst_1:
pushDual(new OPT_LongConstantOperand(code - JBC_lconst_0));
break;
case JBC_fconst_0:
push(new OPT_FloatConstantOperand(0.f));
break;
case JBC_fconst_1:
push(new OPT_FloatConstantOperand(1.f));
break;
case JBC_fconst_2:
push(new OPT_FloatConstantOperand(2.f));
break;
case JBC_dconst_0:
pushDual(new OPT_DoubleConstantOperand(0.));
break;
case JBC_dconst_1:
pushDual(new OPT_DoubleConstantOperand(1.));
break;
case JBC_bipush:
push(new OPT_IntConstantOperand(bcodes.getByteValue()));
break;
case JBC_sipush:
push(new OPT_IntConstantOperand(bcodes.getShortValue()));
break;
case JBC_ldc:
push(getConstantOperand(bcodes.getConstantIndex()));
break;
case JBC_ldc_w:
push(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_ldc2_w:
pushDual(getConstantOperand(bcodes.getWideConstantIndex()));
break;
case JBC_iload:
s=do_iload(bcodes.getLocalNumber());
break;
case JBC_lload:
s=do_lload(bcodes.getLocalNumber());
break;
case JBC_fload:
s=do_fload(bcodes.getLocalNumber());
break;
case JBC_dload:
s=do_dload(bcodes.getLocalNumber());
break;
case JBC_aload:
s=do_aload(bcodes.getLocalNumber());
break;
case JBC_iload_0:
case JBC_iload_1:
case JBC_iload_2:
case JBC_iload_3:
s=do_iload(code - JBC_iload_0);
break;
case JBC_lload_0:
case JBC_lload_1:
case JBC_lload_2:
case JBC_lload_3:
s=do_lload(code - JBC_lload_0);
break;
case JBC_fload_0:
case JBC_fload_1:
case JBC_fload_2:
case JBC_fload_3:
s=do_fload(code - JBC_fload_0);
break;
case JBC_dload_0:
case JBC_dload_1:
case JBC_dload_2:
case JBC_dload_3:
s=do_dload(code - JBC_dload_0);
break;
case JBC_aload_0:
case JBC_aload_1:
case JBC_aload_2:
case JBC_aload_3:
s=do_aload(code - JBC_aload_0);
break;
case JBC_iaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=_aloadHelper(INT_ALOAD,ref,index,VM_TypeReference.Int);
}
break;
case JBC_laload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=_aloadHelper(LONG_ALOAD,ref,index,VM_TypeReference.Long);
}
break;
case JBC_faload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=_aloadHelper(FLOAT_ALOAD,ref,index,VM_TypeReference.Float);
}
break;
case JBC_daload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=_aloadHelper(DOUBLE_ALOAD,ref,index,VM_TypeReference.Double);
}
break;
case JBC_aaload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
s=_aloadHelper(REF_ALOAD,ref,index,type);
}
break;
case JBC_baload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) s=_aloadHelper(BYTE_ALOAD,ref,index,VM_TypeReference.Byte);
 else s=_aloadHelper(UBYTE_ALOAD,ref,index,VM_TypeReference.Boolean);
}
break;
case JBC_caload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=_aloadHelper(USHORT_ALOAD,ref,index,VM_TypeReference.Char);
}
break;
case JBC_saload:
{
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=_aloadHelper(SHORT_ALOAD,ref,index,VM_TypeReference.Short);
}
break;
case JBC_istore:
s=do_store(bcodes.getLocalNumber(),popInt());
break;
case JBC_lstore:
s=do_store(bcodes.getLocalNumber(),popLong());
break;
case JBC_fstore:
s=do_store(bcodes.getLocalNumber(),popFloat());
break;
case JBC_dstore:
s=do_store(bcodes.getLocalNumber(),popDouble());
break;
case JBC_astore:
s=do_astore(bcodes.getLocalNumber());
break;
case JBC_istore_0:
case JBC_istore_1:
case JBC_istore_2:
case JBC_istore_3:
s=do_store(code - JBC_istore_0,popInt());
break;
case JBC_lstore_0:
case JBC_lstore_1:
case JBC_lstore_2:
case JBC_lstore_3:
s=do_store(code - JBC_lstore_0,popLong());
break;
case JBC_fstore_0:
case JBC_fstore_1:
case JBC_fstore_2:
case JBC_fstore_3:
s=do_store(code - JBC_fstore_0,popFloat());
break;
case JBC_dstore_0:
case JBC_dstore_1:
case JBC_dstore_2:
case JBC_dstore_3:
s=do_store(code - JBC_dstore_0,popDouble());
break;
case JBC_astore_0:
case JBC_astore_1:
case JBC_astore_2:
case JBC_astore_3:
s=do_astore(code - JBC_astore_0);
break;
case JBC_iastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.IntArray);
s=AStore.create(INT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Int),getCurrentGuard());
}
break;
case JBC_lastore:
{
OPT_Operand val=popLong();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.LongArray);
s=AStore.create(LONG_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Long),getCurrentGuard());
}
break;
case JBC_fastore:
{
OPT_Operand val=popFloat();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.FloatArray);
s=AStore.create(FLOAT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Float),getCurrentGuard());
}
break;
case JBC_dastore:
{
OPT_Operand val=popDouble();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.DoubleArray);
s=AStore.create(DOUBLE_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Double),getCurrentGuard());
}
break;
case JBC_aastore:
{
OPT_Operand val=pop();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getRefTypeOf(ref).getArrayElementType();
if (VM.VerifyAssertions) VM._assert(type.isReferenceType());
if (do_CheckStore(ref,val,type)) break;
s=AStore.create(REF_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_bastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
VM_TypeReference type=getArrayTypeOf(ref);
if (VM.VerifyAssertions) {
VM._assert(type == VM_TypeReference.ByteArray || type == VM_TypeReference.BooleanArray);
}
if (type == VM_TypeReference.ByteArray) type=VM_TypeReference.Byte;
 else type=VM_TypeReference.Boolean;
s=AStore.create(BYTE_ASTORE,val,ref,index,new OPT_LocationOperand(type),getCurrentGuard());
}
break;
case JBC_castore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.CharArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Char),getCurrentGuard());
}
break;
case JBC_sastore:
{
OPT_Operand val=popInt();
OPT_Operand index=popInt();
OPT_Operand ref=pop();
clearCurrentGuard();
if (do_NullCheck(ref) || do_BoundsCheck(ref,index)) break;
if (VM.VerifyAssertions) assertIsType(ref,VM_TypeReference.ShortArray);
s=AStore.create(SHORT_ASTORE,val,ref,index,new OPT_LocationOperand(VM_TypeReference.Short),getCurrentGuard());
}
break;
case JBC_pop:
stack.pop();
break;
case JBC_pop2:
stack.pop2();
break;
case JBC_dup:
{
OPT_Operand op1=stack.pop();
stack.push(op1);
s=pushCopy(op1);
}
break;
case JBC_dup_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op1);
stack.push(op3);
stack.push(op2);
s=pushCopy(op1);
}
break;
case JBC_dup2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op2);
stack.push(op1);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x1:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_dup2_x2:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
OPT_Operand op3=stack.pop();
OPT_Operand op4=stack.pop();
stack.push(op2);
stack.push(op1);
stack.push(op4);
stack.push(op3);
s=pushCopy(op2);
if (s != null) {
appendInstruction(s);
s=null;
}
s=pushCopy(op1);
}
break;
case JBC_swap:
{
OPT_Operand op1=stack.pop();
OPT_Operand op2=stack.pop();
stack.push(op1);
stack.push(op2);
}
break;
case JBC_iadd:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_ADD,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ladd:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_ADD,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fadd:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_ADD,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dadd:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_ADD,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_isub:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SUB,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lsub:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SUB,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fsub:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_SUB,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dsub:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_SUB,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_imul:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_MUL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lmul:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_MUL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_fmul:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_MUL,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_dmul:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_MUL,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_idiv:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_ldiv:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_DIV,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_fdiv:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_DIV,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_ddiv:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_DIV,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_irem:
{
clearCurrentGuard();
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
if (do_IntZeroCheck(op2)) break;
s=_guardedBinaryHelper(INT_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Int);
}
break;
case JBC_lrem:
{
clearCurrentGuard();
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
if (do_LongZeroCheck(op2)) break;
s=_guardedBinaryDualHelper(LONG_REM,op1,op2,getCurrentGuard(),VM_TypeReference.Long);
}
break;
case JBC_frem:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_REM,op1,op2,VM_TypeReference.Float);
}
break;
case JBC_drem:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryDualHelper(DOUBLE_REM,op1,op2,VM_TypeReference.Double);
}
break;
case JBC_ineg:
s=_unaryHelper(INT_NEG,popInt(),VM_TypeReference.Int);
break;
case JBC_lneg:
s=_unaryDualHelper(LONG_NEG,popLong(),VM_TypeReference.Long);
break;
case JBC_fneg:
s=_unaryHelper(FLOAT_NEG,popFloat(),VM_TypeReference.Float);
break;
case JBC_dneg:
s=_unaryDualHelper(DOUBLE_NEG,popDouble(),VM_TypeReference.Double);
break;
case JBC_ishl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshl:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHL,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ishr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_SHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lshr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_SHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_USHR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lushr:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_USHR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iand:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_AND,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_land:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_AND,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ior:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_OR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_OR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_ixor:
{
OPT_Operand op2=popInt();
OPT_Operand op1=popInt();
s=_binaryHelper(INT_XOR,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_lxor:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryDualHelper(LONG_XOR,op1,op2,VM_TypeReference.Long);
}
break;
case JBC_iinc:
{
int index=bcodes.getLocalNumber();
s=do_iinc(index,bcodes.getIncrement());
}
break;
case JBC_i2l:
s=_unaryDualHelper(INT_2LONG,popInt(),VM_TypeReference.Long);
break;
case JBC_i2f:
s=_unaryHelper(INT_2FLOAT,popInt(),VM_TypeReference.Float);
break;
case JBC_i2d:
s=_unaryDualHelper(INT_2DOUBLE,popInt(),VM_TypeReference.Double);
break;
case JBC_l2i:
s=_unaryHelper(LONG_2INT,popLong(),VM_TypeReference.Int);
break;
case JBC_l2f:
s=_unaryHelper(LONG_2FLOAT,popLong(),VM_TypeReference.Float);
break;
case JBC_l2d:
s=_unaryDualHelper(LONG_2DOUBLE,popLong(),VM_TypeReference.Double);
break;
case JBC_f2i:
s=_unaryHelper(FLOAT_2INT,popFloat(),VM_TypeReference.Int);
break;
case JBC_f2l:
s=_unaryDualHelper(FLOAT_2LONG,popFloat(),VM_TypeReference.Long);
break;
case JBC_f2d:
s=_unaryDualHelper(FLOAT_2DOUBLE,popFloat(),VM_TypeReference.Double);
break;
case JBC_d2i:
s=_unaryHelper(DOUBLE_2INT,popDouble(),VM_TypeReference.Int);
break;
case JBC_d2l:
s=_unaryDualHelper(DOUBLE_2LONG,popDouble(),VM_TypeReference.Long);
break;
case JBC_d2f:
s=_unaryHelper(DOUBLE_2FLOAT,popDouble(),VM_TypeReference.Float);
break;
case JBC_int2byte:
s=_unaryHelper(INT_2BYTE,popInt(),VM_TypeReference.Byte);
break;
case JBC_int2char:
s=_unaryHelper(INT_2USHORT,popInt(),VM_TypeReference.Char);
break;
case JBC_int2short:
s=_unaryHelper(INT_2SHORT,popInt(),VM_TypeReference.Short);
break;
case JBC_lcmp:
{
OPT_Operand op2=popLong();
OPT_Operand op1=popLong();
s=_binaryHelper(LONG_CMP,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpl:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_fcmpg:
{
OPT_Operand op2=popFloat();
OPT_Operand op1=popFloat();
s=_binaryHelper(FLOAT_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpl:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPL,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_dcmpg:
{
OPT_Operand op2=popDouble();
OPT_Operand op1=popDouble();
s=_binaryHelper(DOUBLE_CMPG,op1,op2,VM_TypeReference.Int);
}
break;
case JBC_ifeq:
s=_intIfHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifne:
s=_intIfHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_iflt:
s=_intIfHelper(OPT_ConditionOperand.LESS());
break;
case JBC_ifge:
s=_intIfHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_ifgt:
s=_intIfHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_ifle:
s=_intIfHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_icmpeq:
s=_intIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_icmpne:
s=_intIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_if_icmplt:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS());
break;
case JBC_if_icmpge:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER_EQUAL());
break;
case JBC_if_icmpgt:
s=_intIfCmpHelper(OPT_ConditionOperand.GREATER());
break;
case JBC_if_icmple:
s=_intIfCmpHelper(OPT_ConditionOperand.LESS_EQUAL());
break;
case JBC_if_acmpeq:
s=_refIfCmpHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_if_acmpne:
s=_refIfCmpHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto:
{
int offset=bcodes.getBranchOffset();
if (offset != 3) s=_gotoHelper(offset);
}
break;
case JBC_jsr:
s=_jsrHelper(bcodes.getBranchOffset());
break;
case JBC_ret:
s=_retHelper(bcodes.getLocalNumber());
break;
case JBC_tableswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int low=bcodes.getLowSwitchValue();
int high=bcodes.getHighSwitchValue();
int number=high - low + 1;
if (CF_TABLESWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeTableSwitchOffset(v1,low,high);
int offset=match == 0 ? defaultoff : match;
bcodes.skipTableSwitchOffsets(number);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=TableSwitch.create(TABLESWITCH,op0,null,null,new OPT_IntConstantOperand(low),new OPT_IntConstantOperand(high),generateTarget(defaultoff),null,number * 2);
for (int i=0; i < number; ++i) {
TableSwitch.setTarget(s,i,generateTarget(bcodes.getTableSwitchOffset(i)));
}
bcodes.skipTableSwitchOffsets(number);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(number + 1);
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
TableSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < number; ++i) {
TableSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_lookupswitch:
{
bcodes.alignSwitch();
OPT_Operand op0=popInt();
int defaultoff=bcodes.getDefaultSwitchOffset();
int numpairs=bcodes.getSwitchLength();
if (numpairs == 0) {
s=_gotoHelper(defaultoff);
break;
}
if (CF_LOOKUPSWITCH && op0 instanceof OPT_IntConstantOperand) {
int v1=((OPT_IntConstantOperand)op0).value;
int match=bcodes.computeLookupSwitchOffset(v1,numpairs);
int offset=match == 0 ? defaultoff : match;
bcodes.skipLookupSwitchPairs(numpairs);
if (DBG_CF) {
db(""String_Node_Str"" + v1 + ""String_Node_Str"");
}
s=_gotoHelper(offset);
break;
}
s=LookupSwitch.create(LOOKUPSWITCH,op0,null,null,generateTarget(defaultoff),null,numpairs * 3);
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setMatch(s,i,new OPT_IntConstantOperand(bcodes.getLookupSwitchValue(i)));
LookupSwitch.setTarget(s,i,generateTarget(bcodes.getLookupSwitchOffset(i)));
}
bcodes.skipLookupSwitchPairs(numpairs);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex - bciAdjustment);
VM_SwitchBranchProfile sp=gc.getSwitchProfile(instrIndex);
if (sp == null) {
float approxProb=1.0f / (float)(numpairs + 1);
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(approxProb));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(approxProb));
}
}
 else {
LookupSwitch.setDefaultBranchProfile(s,new OPT_BranchProfileOperand(sp.getDefaultProbability()));
for (int i=0; i < numpairs; ++i) {
LookupSwitch.setBranchProfile(s,i,new OPT_BranchProfileOperand(sp.getCaseProbability(i)));
}
}
}
break;
case JBC_ireturn:
_returnHelper(INT_MOVE,popInt());
break;
case JBC_lreturn:
_returnHelper(LONG_MOVE,popLong());
break;
case JBC_freturn:
_returnHelper(FLOAT_MOVE,popFloat());
break;
case JBC_dreturn:
_returnHelper(DOUBLE_MOVE,popDouble());
break;
case JBC_areturn:
{
OPT_Operand op0=popRef();
if (VM.VerifyAssertions && !op0.isDefinitelyNull()) {
VM_TypeReference retType=getRefTypeOf(op0);
if (retType != VM_TypeReference.JavaLangObject) assertIsAssignable(gc.method.getReturnType(),getRefTypeOf(op0));
}
_returnHelper(REF_MOVE,op0);
}
break;
case JBC_return:
_returnHelper(null,null);
break;
case JBC_getstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
if (!fieldType.isDoubleType() && !fieldType.isFloatType()) {
if (field.isFinal()) {
VM_Class declaringClass=field.getDeclaringClass();
if (declaringClass.isInitialized() || (VM.writingBootImage && declaringClass.isInBootImage())) {
try {
if (fieldType.isPrimitiveType()) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
if (OPT_StaticFieldReader.isStaticFieldNull(field)) {
push(new OPT_NullConstantOperand(),fieldType);
break;
}
 else {
VM_TypeReference rtType=OPT_StaticFieldReader.getTypeFromStaticField(field);
if (rtType == VM_TypeReference.JavaLangString) {
OPT_ConstantOperand rhs=OPT_StaticFieldReader.getStaticFieldValue(field);
push(rhs,fieldType);
break;
}
 else {
t.type=rtType;
if (rtType != fieldType) t.clearDeclaredType();
t.setPreciseType();
markGuardlessNonNull(t);
}
}
}
}
 catch (NoSuchFieldException e) {
}
}
}
}
}
s=GetStatic.create(GETSTATIC,t,offsetOp,fieldOp);
push(t.copyD2U(),fieldType);
}
break;
case JBC_putstatic:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeStaticFieldRef(ref);
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand r=pop(fieldType);
s=PutStatic.create(PUTSTATIC,r,offsetOp,fieldOp);
}
break;
case JBC_getfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
OPT_Operand offsetOp;
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_RegisterOperand t=gc.temps.makeTemp(fieldType);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
VM_Type ft=fieldType.peekResolvedType();
if (ft != null && ft.isClassType()) {
VM_TypeReference concreteType=OPT_FieldAnalysis.getConcreteType(field);
if (concreteType != null) {
t.setPreciseType();
if (concreteType == fieldType) {
t.setDeclaredType();
}
 else {
fieldType=concreteType;
t.type=concreteType;
}
}
}
}
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
s=GetField.create(GETFIELD,t,op1,offsetOp,fieldOp,getCurrentGuard());
push(t.copyD2U(),fieldType);
}
break;
case JBC_putfield:
{
VM_FieldReference ref=bcodes.getFieldReference();
boolean unresolved=ref.needsDynamicLink(bcodes.method());
OPT_LocationOperand fieldOp=makeInstanceFieldRef(ref);
VM_TypeReference fieldType=ref.getFieldContentsType();
OPT_Operand offsetOp;
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),fieldOp.copy()));
offsetOp=offsetrop;
rectifyStateWithErrorHandler();
}
 else {
VM_Field field=ref.peekResolvedField();
offsetOp=new OPT_IntConstantOperand(field.getOffset());
}
OPT_Operand val=pop(fieldType);
OPT_Operand obj=popRef();
clearCurrentGuard();
if (do_NullCheck(obj)) break;
s=PutField.create(PUTFIELD,val,obj,offsetOp,fieldOp,getCurrentGuard());
}
break;
case JBC_invokevirtual:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
OPT_MethodOperand methOp=OPT_MethodOperand.VIRTUAL(ref,target);
if (this.osrGuardedInline) {
lastOsrBarrier=_createOsrBarrier();
}
s=_callHelper(ref,methOp);
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
if (VM.VerifyAssertions) VM._assert(target != null);
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean isExtant=false;
boolean isPreciseType=false;
VM_TypeReference tr=null;
if (receiver.isRegister()) {
OPT_RegisterOperand rop=receiver.asRegister();
isExtant=rop.isExtant();
isPreciseType=rop.isPreciseType();
tr=rop.type;
}
 else if (receiver.isStringConstant()) {
isExtant=true;
isPreciseType=true;
tr=VM_TypeReference.JavaLangString;
}
 else if (VM.VerifyAssertions) {
VM._assert(false,""String_Node_Str"");
}
VM_Type type=tr.peekResolvedType();
if (type != null && type.isResolved() && type.isClassType() && target != null && type != target.getDeclaringClass()) {
VM_Method vmeth=OPT_ClassLoaderProxy.lookupMethod(type.asClass(),ref);
if (vmeth != null && vmeth != target) {
methOp.refine(vmeth,isPreciseType);
}
}
if (maybeInlineMethod(shouldInline(s,isExtant),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokespecial:
{
VM_MethodReference ref=bcodes.getMethodReference();
VM_Method target=ref.resolveInvokeSpecial();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.SPECIAL(ref,target));
if (target == null) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
OPT_Operand receiver=Call.getParam(s,0);
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokestatic:
{
VM_MethodReference ref=bcodes.getMethodReference();
if (ref.getType().isMagicType()) {
boolean generated=OPT_GenerateMagic.generateMagic(this,gc,ref);
if (generated) break;
}
boolean unresolved=ref.needsDynamicLink(bcodes.method());
VM_Method target=ref.peekResolvedMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.STATIC(ref,target));
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(target.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_invokeinterface:
{
VM_MethodReference ref=bcodes.getMethodReference();
bcodes.alignInvokeInterface();
VM_Method resolvedMethod=null;
resolvedMethod=ref.peekInterfaceMethod();
if (this.osrGuardedInline) lastOsrBarrier=_createOsrBarrier();
s=_callHelper(ref,OPT_MethodOperand.INTERFACE(ref,resolvedMethod));
OPT_RegisterOperand receiver=Call.getParam(s,0).asRegister();
VM_Class receiverType=(VM_Class)receiver.type.peekResolvedType();
clearCurrentGuard();
if (do_NullCheck(receiver)) {
s=null;
break;
}
Call.setGuard(s,getCurrentGuard());
boolean requiresImplementsTest=VM.BuildForIMTInterfaceInvocation || (VM.BuildForITableInterfaceInvocation && VM.DirectlyIndexedITables);
if (requiresImplementsTest) {
if (resolvedMethod == null) {
OPT_RegisterOperand tibPtr=gc.temps.makeTemp(VM_TypeReference.JavaLangObjectArray);
OPT_Instruction getTib=GuardedUnary.create(GET_OBJ_TIB,tibPtr,receiver.copyU2U(),getCurrentGuard());
appendInstruction(getTib);
getTib.bcIndex=RUNTIME_SERVICES_BCI;
VM_Method target=VM_Entrypoints.unresolvedInvokeinterfaceImplementsTestMethod;
OPT_Instruction callCheck=Call.create2(CALL,null,new OPT_IntConstantOperand(target.getOffset()),OPT_MethodOperand.STATIC(target),new OPT_IntConstantOperand(ref.getId()),tibPtr.copyD2U());
if (gc.options.NO_CALLEE_EXCEPTIONS) {
callCheck.markAsNonPEI();
}
appendInstruction(callCheck);
callCheck.bcIndex=RUNTIME_SERVICES_BCI;
requiresImplementsTest=false;
rectifyStateWithErrorHandler();
}
 else {
VM_Type interfaceType=resolvedMethod.getDeclaringClass();
if (receiverType != null && receiverType.isResolved() && !receiverType.isInterface()) {
byte doesImplement=OPT_ClassLoaderProxy.includesType(interfaceType.getTypeRef(),receiverType.getTypeRef());
requiresImplementsTest=doesImplement != YES;
}
}
}
VM_Method vmeth=null;
if (receiverType != null && receiverType.isInitialized() && !receiverType.isInterface()) {
vmeth=OPT_ClassLoaderProxy.lookupMethod(receiverType,ref);
}
if (vmeth != null) {
VM_MethodReference vmethRef=vmeth.getMemberRef().asMethodReference();
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
rectifyStateWithErrorHandler();
}
OPT_MethodOperand mop=OPT_MethodOperand.VIRTUAL(vmethRef,vmeth);
if (receiver.isPreciseType()) {
mop.refine(vmeth,true);
}
Call.setMethod(s,mop);
boolean unresolved=vmethRef.needsDynamicLink(bcodes.method());
if (unresolved) {
OPT_RegisterOperand offsetrop=gc.temps.makeTempInt();
appendInstruction(Unary.create(RESOLVE_MEMBER,offsetrop.copyRO(),Call.getMethod(s).copy()));
Call.setAddress(s,offsetrop);
rectifyStateWithErrorHandler();
}
 else {
Call.setAddress(s,new OPT_IntConstantOperand(vmeth.getOffset()));
}
if (maybeInlineMethod(shouldInline(s,receiver.isExtant()),s)) {
return;
}
}
 else {
if (resolvedMethod != null && maybeInlineMethod(shouldInline(s,false),s)) {
return;
}
 else {
if (requiresImplementsTest) {
appendInstruction(TypeCheck.create(MUST_IMPLEMENT_INTERFACE,receiver.copyU2U(),makeTypeOperand(resolvedMethod.getDeclaringClass()),getCurrentGuard()));
}
}
}
rectifyStateWithExceptionHandlers();
}
break;
case JBC_xxxunusedxxx:
OPT_OptimizingCompilerException.UNREACHABLE();
break;
case JBC_new:
{
VM_TypeReference klass=bcodes.getTypeReference();
OPT_RegisterOperand t=gc.temps.makeTemp(klass);
t.setPreciseType();
markGuardlessNonNull(t);
OPT_Operator operator;
OPT_TypeOperand klassOp;
VM_Class klassType=(VM_Class)klass.peekResolvedType();
if (klassType != null && (klassType.isInitialized() || klassType.isInBootImage())) {
klassOp=makeTypeOperand(klassType);
operator=NEW;
}
 else {
operator=NEW_UNRESOLVED;
klassOp=makeTypeOperand(klass);
}
s=New.create(operator,t,klassOp);
push(t.copyD2U());
rectifyStateWithErrorHandler();
}
break;
case JBC_newarray:
{
VM_Type array=bcodes.getPrimitiveArrayType();
OPT_TypeOperand arrayOp=makeTypeOperand(array);
OPT_RegisterOperand t=gc.temps.makeTemp(array.getTypeRef());
t.setPreciseType();
markGuardlessNonNull(t);
s=NewArray.create(NEWARRAY,t,arrayOp,popInt());
push(t.copyD2U());
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_anewarray:
{
VM_TypeReference elementTypeRef=bcodes.getTypeReference();
s=generateAnewarray(elementTypeRef);
}
break;
case JBC_arraylength:
{
OPT_Operand op1=pop();
clearCurrentGuard();
if (do_NullCheck(op1)) break;
if (VM.VerifyAssertions) VM._assert(getArrayTypeOf(op1).isArrayType());
OPT_RegisterOperand t=gc.temps.makeTempInt();
s=GuardedUnary.create(ARRAYLENGTH,t,op1,getCurrentGuard());
push(t.copyD2U());
}
break;
case JBC_athrow:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
VM_TypeReference type=getRefTypeOf(op0);
if (VM.VerifyAssertions) {
if (type != VM_TypeReference.JavaLangObject) assertIsAssignable(VM_TypeReference.JavaLangThrowable,type);
}
if (!gc.method.isInterruptible()) {
appendInstruction(Empty.create(UNINT_END));
}
endOfBasicBlock=true;
OPT_BasicBlock definiteTarget=rectifyStateWithExceptionHandler(type,true);
if (definiteTarget != null) {
appendInstruction(CacheOp.create(SET_CAUGHT_EXCEPTION,op0));
s=Goto.create(GOTO,definiteTarget.makeJumpTarget());
}
 else {
s=Athrow.create(ATHROW,(OPT_RegisterOperand)op0);
}
}
break;
case JBC_checkcast:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (typeRef.isWordType()) {
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
if (DBG_CF) db(""String_Node_Str"" + typeRef);
break;
}
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_CHECKCAST && !classLoading) {
if (op2.isDefinitelyNull()) {
push(op2);
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
if (OPT_ClassLoaderProxy.includesType(typeRef,type) == YES) {
push(op2);
if (DBG_CF) db(""String_Node_Str"" + op2 + ""String_Node_Str""+ typeRef+ ""String_Node_Str""+ type);
break;
}
}
if (!gc.options.NO_CHECKCAST) {
if (classLoading) {
s=TypeCheck.create(CHECKCAST_UNRESOLVED,op2,makeTypeOperand(typeRef));
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=TypeCheck.create(CHECKCAST_NOTNULL,op2,typeOp,getGuard(op2));
}
 else {
s=TypeCheck.create(CHECKCAST,op2,typeOp);
}
}
}
op2=op2.copy();
if (op2 instanceof OPT_RegisterOperand) {
((OPT_RegisterOperand)op2).type=typeRef;
}
push(op2);
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangClassCastException);
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_instanceof:
{
VM_TypeReference typeRef=bcodes.getTypeReference();
boolean classLoading=couldCauseClassLoading(typeRef);
OPT_Operand op2=pop();
if (VM.VerifyAssertions) VM._assert(op2.isRef());
if (CF_INSTANCEOF && !classLoading) {
if (op2.isDefinitelyNull()) {
push(new OPT_IntConstantOperand(0));
if (DBG_CF) db(""String_Node_Str"");
break;
}
VM_TypeReference type=getRefTypeOf(op2);
int answer=OPT_ClassLoaderProxy.includesType(typeRef,type);
if (answer == YES && isNonNull(op2)) {
push(new OPT_IntConstantOperand(1));
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
break;
}
 else if (answer == NO) {
if (DBG_CF) db(op2 + ""String_Node_Str"" + typeRef+ ""String_Node_Str"");
push(new OPT_IntConstantOperand(0));
break;
}
}
OPT_RegisterOperand t=gc.temps.makeTempInt();
if (classLoading) {
s=InstanceOf.create(INSTANCEOF_UNRESOLVED,t,makeTypeOperand(typeRef),op2);
}
 else {
OPT_TypeOperand typeOp=makeTypeOperand(typeRef.peekResolvedType());
if (isNonNull(op2)) {
s=InstanceOf.create(INSTANCEOF_NOTNULL,t,typeOp,op2,getGuard(op2));
}
 else {
s=InstanceOf.create(INSTANCEOF,t,typeOp,op2);
}
}
push(t.copyD2U());
if (classLoading) rectifyStateWithErrorHandler();
}
break;
case JBC_monitorenter:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (VM.VerifyAssertions) VM._assert(op0.isRef());
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITORENTER,op0,getCurrentGuard());
}
}
break;
case JBC_monitorexit:
{
OPT_Operand op0=pop();
clearCurrentGuard();
if (do_NullCheck(op0)) break;
if (gc.options.MONITOR_NOP) {
s=null;
}
 else {
s=MonitorOp.create(MONITOREXIT,op0,getCurrentGuard());
}
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangIllegalMonitorStateException);
}
break;
case JBC_wide:
{
int widecode=bcodes.getWideOpcode();
int index=bcodes.getWideLocalNumber();
switch (widecode) {
case JBC_iload:
s=do_iload(index);
break;
case JBC_lload:
s=do_lload(index);
break;
case JBC_fload:
s=do_fload(index);
break;
case JBC_dload:
s=do_dload(index);
break;
case JBC_aload:
s=do_aload(index);
break;
case JBC_istore:
s=do_store(index,popInt());
break;
case JBC_lstore:
s=do_store(index,popLong());
break;
case JBC_fstore:
s=do_store(index,popFloat());
break;
case JBC_dstore:
s=do_store(index,popDouble());
break;
case JBC_astore:
s=do_astore(index);
break;
case JBC_iinc:
s=do_iinc(index,bcodes.getWideIncrement());
break;
case JBC_ret:
s=_retHelper(index);
break;
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
}
break;
case JBC_multianewarray:
{
VM_TypeReference arrayType=bcodes.getTypeReference();
OPT_TypeOperand typeOp=makeTypeOperand(arrayType);
int dimensions=bcodes.getArrayDimension();
OPT_TypeOperand dimArrayType=makeTypeOperand(VM_Array.IntArray);
OPT_RegisterOperand dimArray=gc.temps.makeTemp(VM_TypeReference.IntArray);
markGuardlessNonNull(dimArray);
dimArray.setPreciseType();
appendInstruction(NewArray.create(NEWARRAY,dimArray,dimArrayType,new OPT_IntConstantOperand(dimensions)));
for (int i=dimensions; i > 0; i--) {
OPT_LocationOperand loc=new OPT_LocationOperand(VM_TypeReference.Int);
appendInstruction(AStore.create(INT_ASTORE,popInt(),dimArray.copyD2U(),new OPT_IntConstantOperand(i - 1),loc,new OPT_TrueGuardOperand()));
}
OPT_RegisterOperand result=gc.temps.makeTemp(arrayType);
markGuardlessNonNull(result);
result.setPreciseType();
appendInstruction(NewArray.create(NEWOBJMULTIARRAY,result,typeOp,dimArray.copyD2U()));
push(result.copyD2U());
rectifyStateWithErrorHandler();
rectifyStateWithExceptionHandler(VM_TypeReference.JavaLangNegativeArraySizeException);
}
break;
case JBC_ifnull:
s=_refIfNullHelper(OPT_ConditionOperand.EQUAL());
break;
case JBC_ifnonnull:
s=_refIfNullHelper(OPT_ConditionOperand.NOT_EQUAL());
break;
case JBC_goto_w:
{
int offset=bcodes.getWideBranchOffset();
if (offset != 5) s=_gotoHelper(offset);
}
break;
case JBC_jsr_w:
s=_jsrHelper(bcodes.getWideBranchOffset());
break;
case JBC_impdep1:
{
int pseudo_opcode=bcodes.nextPseudoInstruction();
switch (pseudo_opcode) {
case PSEUDO_LoadIntConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new OPT_IntConstantOperand(value));
param1=param2;
param2=value;
break;
}
case PSEUDO_LoadLongConst:
{
long value=bcodes.readLongConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateLongLiteral(value);
pushDual(new OPT_LongConstantOperand(value,offset));
break;
}
case PSEUDO_LoadFloatConst:
{
int ibits=bcodes.readIntConst();
float value=Float.intBitsToFloat(ibits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
int offset=VM_Statics.findOrCreateFloatLiteral(ibits);
push(new OPT_FloatConstantOperand(value,offset));
break;
}
case PSEUDO_LoadDoubleConst:
{
long lbits=bcodes.readLongConst();
double value=VM_Magic.longBitsAsDouble(lbits);
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + lbits);
int offset=VM_Statics.findOrCreateDoubleLiteral(lbits);
pushDual(new OPT_DoubleConstantOperand(value,offset));
break;
}
case PSEUDO_LoadAddrConst:
{
int value=bcodes.readIntConst();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + value);
push(new ReturnAddressOperand(value));
break;
}
case PSEUDO_InvokeStatic:
{
VM_Method meth=null;
int targetidx=bcodes.readIntConst();
switch (targetidx) {
case GETREFAT:
meth=VM_Entrypoints.osrGetRefAtMethod;
break;
case CLEANREFS:
meth=VM_Entrypoints.osrCleanRefsMethod;
break;
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + targetidx);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.STATIC(meth));
Call.setAddress(s,new OPT_IntConstantOperand(meth.getOffset()));
if (targetidx == GETREFAT) {
Object realObj=OSR_ObjectHolder.getRefAt(param1,param2);
if (VM.VerifyAssertions) VM._assert(realObj != null);
VM_TypeReference klass=VM_Magic.getObjectType(realObj).getTypeRef();
OPT_RegisterOperand op0=gc.temps.makeTemp(klass);
Call.setResult(s,op0);
pop();
push(op0.copyD2U(),klass);
}
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_InvokeCompiledMethod:
{
int cmid=bcodes.readIntConst();
int origBCIdx=bcodes.readIntConst();
VM_CompiledMethod cm=VM_CompiledMethods.getCompiledMethod(cmid);
VM_Method meth=cm.getMethod();
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + meth + ""String_Node_Str"");
s=_callHelper(meth.getMemberRef().asMethodReference(),OPT_MethodOperand.COMPILED(meth,cm.getOsrJTOCoffset()));
s.bcIndex=origBCIdx + bciAdjustment;
rectifyStateWithExceptionHandlers();
break;
}
case PSEUDO_ParamInitEnd:
{
break;
}
default :
if (VM.TraceOnStackReplacement) VM.sysWriteln(""String_Node_Str"" + pseudo_opcode);
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
break;
}
default :
OPT_OptimizingCompilerException.UNREACHABLE();
break;
}
if (s != null && !currentBBLE.isSelfRegen()) {
appendInstruction(s);
}
if (VM.VerifyAssertions) VM._assert(bcodes.index() <= runoff);
if (!endOfBasicBlock && bcodes.index() == runoff) {
if (DBG_BB || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE + ""String_Node_Str""+ runoff);
endOfBasicBlock=fallThrough=true;
}
if (endOfBasicBlock) {
if (currentBBLE.isSelfRegen()) {
currentBBLE.block.deleteOut();
if (DBG_CFG || DBG_SELECTED) db(""String_Node_Str"" + currentBBLE.block);
return;
}
if (fallThrough) {
if (VM.VerifyAssertions) VM._assert(bcodes.index() < bcodes.length());
currentBBLE.fallThrough=getOrCreateBlock(bcodes.index());
currentBBLE.block.insertOut(currentBBLE.fallThrough.block);
}
return;
}
}
}",0.9996017611009091
150248,"/** 
 * A collection has fully completed.  Decrement the collectionInitiated state variable appropriately.
 */
public static void collectionComplete() throws VM_PragmaUninterruptible {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  collectionsInitiated--;
}","/** 
 * A collection has fully completed.  Decrement the collectionInitiated state variable appropriately.
 */
public static void collectionComplete() throws VM_PragmaUninterruptible {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  collectionsInitiated=0;
}",0.9933110367892976
150249,"/** 
 * A collection has fully completed.  Decrement the collectionInitiated state variable appropriately.
 */
public static void collectionComplete() throws VM_PragmaUninterruptible {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  collectionsInitiated--;
}","/** 
 * A collection has fully completed.  Decrement the collectionInitiated state variable appropriately.
 */
public static void collectionComplete() throws VM_PragmaUninterruptible {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  collectionsInitiated=0;
}",0.9933110367892976
150250,"protected final int getEdgeCounterOffset(){
  return method.getId() << 2;
}","protected final int getEdgeCounterOffset(){
  return method.getId() << LOG_BYTES_IN_ADDRESS;
}",0.8757396449704142
150251,"/** 
 * Forward an object.  If the object has not already been forwarded, then conditionally enqueue it for scanning.
 * @param object The object to be forwarded.
 * @param scan If <code>true</code>, then enqueue the object forscanning if the object was previously unforwarded.
 * @return The forwarded object.
 */
private static VM_Address forwardObject(VM_Address object,boolean scan) throws VM_PragmaInline {
  int forwardingPtr=CopyingHeader.attemptToForward(object);
  VM_Magic.isync();
  if (CopyingHeader.stateIsForwardedOrBeingForwarded(forwardingPtr)) {
    while (CopyingHeader.stateIsBeingForwarded(forwardingPtr))     forwardingPtr=CopyingHeader.getForwardingWord(object);
    VM_Magic.isync();
    VM_Address newObject=VM_Address.fromInt(forwardingPtr & ~CopyingHeader.GC_FORWARDING_MASK);
    return newObject;
  }
  VM_Address newObject=VM_Interface.copy(object,forwardingPtr);
  CopyingHeader.setForwardingPointer(object,newObject);
  if (scan) {
    Plan.enqueue(newObject);
  }
 else {
    Plan.enqueueForwardedUnscannedObject(newObject);
  }
  return newObject;
}","/** 
 * Forward an object.  If the object has not already been forwarded, then conditionally enqueue it for scanning.
 * @param object The object to be forwarded.
 * @param scan If <code>true</code>, then enqueue the object forscanning if the object was previously unforwarded.
 * @return The forwarded object.
 */
private static VM_Address forwardObject(VM_Address object,boolean scan) throws VM_PragmaInline {
  VM_Word forwardingPtr=CopyingHeader.attemptToForward(object);
  VM_Magic.isync();
  if (CopyingHeader.stateIsForwardedOrBeingForwarded(forwardingPtr)) {
    while (CopyingHeader.stateIsBeingForwarded(forwardingPtr))     forwardingPtr=CopyingHeader.getForwardingWord(object);
    VM_Magic.isync();
    VM_Address newObject=forwardingPtr.and(CopyingHeader.GC_FORWARDING_MASK.not()).toAddress();
    return newObject;
  }
  VM_Address newObject=VM_Interface.copy(object,forwardingPtr);
  CopyingHeader.setForwardingPointer(object,newObject);
  if (scan) {
    Plan.enqueue(newObject);
  }
 else {
    Plan.enqueueForwardedUnscannedObject(newObject);
  }
  return newObject;
}",0.974169741697417
150252,"/** 
 * test to see if the mark bit has the given value
 */
private static boolean testMarkBit(VM_Address ref,int value){
  return (VM_Interface.readAvailableBitsWord(ref) & value) != 0;
}","/** 
 * test to see if the mark bit has the given value
 */
private static boolean testMarkBit(VM_Address ref,VM_Word value){
  return !(VM_Interface.readAvailableBitsWord(ref).and(value).isZero());
}",0.8814432989690721
150253,"/** 
 * write the given value in the mark bit.
 */
private static void writeMarkBit(VM_Address ref,int value){
  int oldValue=VM_Interface.readAvailableBitsWord(ref);
  int newValue=(oldValue & ~GC_MARK_BIT_MASK) | value;
  VM_Interface.writeAvailableBitsWord(ref,newValue);
}","/** 
 * write the given value in the mark bit.
 */
private static void writeMarkBit(VM_Address ref,VM_Word value){
  VM_Word oldValue=VM_Interface.readAvailableBitsWord(ref);
  VM_Word newValue=oldValue.and(GC_MARK_BIT_MASK.not()).or(value);
  VM_Interface.writeAvailableBitsWord(ref,newValue);
}",0.8566433566433567
150254,"/** 
 * Prepare for a new collection increment.  For the immortal collector we must flip the state of the mark bit between collections.
 */
public static void prepare(VMResource vm,MemoryResource mr){
  immortalMarkState=GC_MARK_BIT_MASK - immortalMarkState;
}","/** 
 * Prepare for a new collection increment.  For the immortal collector we must flip the state of the mark bit between collections.
 */
public static void prepare(VMResource vm,MemoryResource mr){
  immortalMarkState=GC_MARK_BIT_MASK.sub(immortalMarkState);
}",0.982791586998088
150255,"/** 
 * Used to mark boot image objects during a parallel scan of objects during GC Returns true if marking was done.
 */
private static boolean testAndMark(VM_Address ref,int value) throws VM_PragmaInline {
  int oldValue;
  do {
    oldValue=VM_Interface.prepareAvailableBits(ref);
    int markBit=oldValue & GC_MARK_BIT_MASK;
    if (markBit == value)     return false;
  }
 while (!VM_Interface.attemptAvailableBits(ref,oldValue,oldValue ^ GC_MARK_BIT_MASK));
  return true;
}","/** 
 * Used to mark boot image objects during a parallel scan of objects during GC Returns true if marking was done.
 */
private static boolean testAndMark(VM_Address ref,VM_Word value) throws VM_PragmaInline {
  VM_Word oldValue;
  do {
    oldValue=VM_Interface.prepareAvailableBits(ref);
    VM_Word markBit=oldValue.and(GC_MARK_BIT_MASK);
    if (markBit.EQ(value))     return false;
  }
 while (!VM_Interface.attemptAvailableBits(ref,oldValue,oldValue.xor(GC_MARK_BIT_MASK)));
  return true;
}",0.9417773237997956
150256,"/** 
 * atomically write the given value in the mark bit.
 */
private static void atomicWriteMarkBit(VM_Address ref,int value){
  while (true) {
    int oldValue=VM_Interface.prepareAvailableBits(ref);
    int newValue=(oldValue & ~GC_MARK_BIT_MASK) | value;
    if (VM_Interface.attemptAvailableBits(ref,oldValue,newValue))     break;
  }
}","/** 
 * atomically write the given value in the mark bit.
 */
private static void atomicWriteMarkBit(VM_Address ref,VM_Word value){
  while (true) {
    VM_Word oldValue=VM_Interface.prepareAvailableBits(ref);
    VM_Word newValue=oldValue.and(GC_MARK_BIT_MASK.not()).or(value);
    if (VM_Interface.attemptAvailableBits(ref,oldValue,newValue))     break;
  }
}",0.8831908831908832
150257,"/** 
 * Initialize any header information for a new block.  In this case, this just means zeroing the header bits.
 * @param block The new block whose header is to be zeroed
 * @param sizeClass The sizeClass of the new block
 */
protected final void postExpandSizeClass(VM_Address block,int sizeClass){
  Memory.zeroSmall(block.add(MARK_BITMAP_BASE),VM_Extent.fromInt(bitmaps[sizeClass] << LOG_BYTES_IN_BITMAP));
}","/** 
 * Initialize any header information for a new block.  In this case, this just means zeroing the header bits.
 * @param block The new block whose header is to be zeroed
 * @param sizeClass The sizeClass of the new block
 */
protected final void postExpandSizeClass(VM_Address block,int sizeClass){
  Memory.zeroSmall(block.add(MARK_BITMAP_BASE),VM_Word.fromInt(bitmaps[sizeClass]).lsh(LOG_BYTES_IN_BITMAP).toExtent());
}",0.9630512514898688
150258,"/** 
 * Prepare for a new collection increment.  For the mark-sweep collector we must flip the state of the mark bit between collections.
 * @param vm (unused)
 * @param mr (unused)
 */
public void prepare(VMResource vm,MemoryResource mr){
  markState=MarkSweepHeader.MARK_BIT_MASK - markState;
  inMSCollection=true;
}","/** 
 * Prepare for a new collection increment.  For the mark-sweep collector we must flip the state of the mark bit between collections.
 * @param vm (unused)
 * @param mr (unused)
 */
public void prepare(VMResource vm,MemoryResource mr){
  markState=MarkSweepHeader.MARK_BIT_MASK.sub(markState);
  inMSCollection=true;
}",0.9578783151326054
150259,"/** 
 * Return the initial value for the header of a new object instance. The header for this collector includes a mark bit.
 */
public final int getInitialHeaderValue() throws VM_PragmaInline {
  return markState;
}","/** 
 * Return the initial value for the header of a new object instance. The header for this collector includes a mark bit.
 */
public final VM_Word getInitialHeaderValue() throws VM_PragmaInline {
  return markState;
}",0.9770642201834864
150260,"/** 
 * Return the initial value for the header of a new object instance. The header for this collector includes a mark bit and a small object flag.
 * @param size The size of the newly allocated object
 */
public final int getInitialHeaderValue(int size) throws VM_PragmaInline {
  return 0;
}","/** 
 * Return the initial value for the header of a new object instance. The header for this collector includes a mark bit and a small object flag.
 * @param size The size of the newly allocated object
 */
public final VM_Word getInitialHeaderValue(int size) throws VM_PragmaInline {
  return VM_Word.zero();
}",0.9586776859504132
150261,"/** 
 * Prepare for a new collection increment.  For the mark-sweep collector we must flip the state of the mark bit between collections.
 * @param vm (unused)
 * @param mr (unused)
 */
public void prepare(VMResource vm,MemoryResource mr){
  markState=MarkSweepHeader.MARK_BIT_MASK - markState;
  inTreadmillCollection=true;
}","/** 
 * Prepare for a new collection increment.  For the mark-sweep collector we must flip the state of the mark bit between collections.
 * @param vm (unused)
 * @param mr (unused)
 */
public void prepare(VMResource vm,MemoryResource mr){
  markState=MarkSweepHeader.MARK_BIT_MASK.sub(markState);
  inTreadmillCollection=true;
}",0.9862595419847328
150262,"/** 
 * Return the initial value for the header of a new object instance. The header for this collector includes a mark bit and a small object flag.
 * @param size The size of the newly allocated object
 */
public final int getInitialHeaderValue(int size) throws VM_PragmaInline {
  return markState;
}","/** 
 * Return the initial value for the header of a new object instance. The header for this collector includes a mark bit and a small object flag.
 * @param size The size of the newly allocated object
 */
public final VM_Word getInitialHeaderValue(int size) throws VM_PragmaInline {
  return markState;
}",0.9835526315789472
150263,"public static int addressToMmapChunksUp(VM_Address addr){
  return ((addr.toInt()) + (LazyMmapper.MMAP_CHUNK_SIZE - 1)) >>> LazyMmapper.LOG_MMAP_CHUNK_SIZE;
}","public static int addressToMmapChunksUp(VM_Address addr){
  VM_Word chunk=addr.add(LazyMmapper.MMAP_CHUNK_SIZE - 1).toWord().rshl(LazyMmapper.LOG_MMAP_CHUNK_SIZE);
  return chunk.toInt();
}",0.7838616714697406
150264,"public static int bytesToPages(int bytes){
  int pages=bytesToPagesUp(bytes);
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(pagesToBytes(pages) == bytes);
  return pages;
}","public static int bytesToPages(VM_Extent bytes){
  int pages=bytesToPagesUp(bytes);
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(pagesToAddress(pages).toWord().toExtent().EQ(bytes));
  return pages;
}",0.8179551122194514
150265,"public static int bytesToPagesUp(int bytes){
  return (bytes + BYTES_IN_PAGE - 1) >>> LOG_BYTES_IN_PAGE;
}","public static int bytesToPagesUp(VM_Extent bytes){
  return bytes.add(BYTES_IN_PAGE - 1).toWord().rshl(LOG_BYTES_IN_PAGE).toInt();
}",0.8067226890756303
150266,"public final boolean isNode(VM_Address node){
  VM_Word n=node.toWord();
  return (n.toInt() / granularity * granularity) == n.toInt();
}","public final boolean isNode(VM_Address node){
  if (BITS_IN_ADDRESS == 64)   return (node.toLong() / granularity * granularity) == node.toLong();
 else   return (node.toInt() / granularity * granularity) == node.toInt();
}",0.596100278551532
150267,"public static void set(VM_Address start,int len,int v) throws VM_PragmaInline {
  for (int i=0; i < len; i+=4)   VM_Magic.setMemoryInt(start.add(i),v);
}","public static void set(VM_Address start,int len,int v) throws VM_PragmaInline {
  for (int i=0; i < len; i+=BYTES_IN_INT)   VM_Magic.setMemoryInt(start.add(i),v);
}",0.9589905362776026
150268,"private static boolean isSetHelper(VM_Address start,int size,boolean verbose,int v) throws VM_PragmaNoInline {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(size == (size & (~3)));
  for (int i=0; i < size; i+=4)   if (VM_Magic.getMemoryInt(start.add(i)) != v) {
    if (verbose) {
      Log.prependThreadId();
      Log.write(""String_Node_Str"");
      Log.writeln(v);
      Log.write(""String_Node_Str"");
      Log.write(start);
      Log.write(""String_Node_Str"");
      Log.writeln(start.add(size));
      Log.write(""String_Node_Str"");
      Log.writeln(start.add(i));
      dumpMemory(start,0,size);
    }
    return false;
  }
  return true;
}","private static boolean isSetHelper(VM_Address start,int size,boolean verbose,int v) throws VM_PragmaNoInline {
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert((size & (BYTES_IN_INT - 1)) == 0);
  for (int i=0; i < size; i+=BYTES_IN_INT)   if (VM_Magic.getMemoryInt(start.add(i)) != v) {
    if (verbose) {
      Log.prependThreadId();
      Log.write(""String_Node_Str"");
      Log.writeln(v);
      Log.write(""String_Node_Str"");
      Log.write(start);
      Log.write(""String_Node_Str"");
      Log.writeln(start.add(size));
      Log.write(""String_Node_Str"");
      Log.writeln(start.add(i));
      dumpMemory(start,0,size);
    }
    return false;
  }
  return true;
}",0.96274217585693
150269,"public static void zeroSmall(VM_Address start,VM_Extent len) throws VM_PragmaInline {
  for (int i=0; VM_Extent.fromIntZeroExtend(i).LT(len); i+=4)   VM_Magic.setMemoryInt(start.add(i),0);
}","public static void zeroSmall(VM_Address start,VM_Extent len) throws VM_PragmaInline {
  VM_Address end=start.add(len);
  for (VM_Address i=start; i.LT(end); i=i.add(BYTES_IN_INT))   VM_Magic.setMemoryInt(i,0);
}",0.6633416458852868
150270,"/** 
 * Allocate a large object.  Large objects are directly allocted and freed in page-grained units via the vm resource.  This routine returned zeroed memory.
 * @param isScalar True if the object to occupy this space will be a scalar.
 * @param bytes The required size of this space in bytes.
 * @param inGC If true, this allocation is occuring with respect toa space that is currently being collected.
 * @return The address of the start of the newly allocated region atleast <code>bytes</code> bytes in size.
 */
final protected VM_Address allocSlowOnce(boolean isScalar,int bytes,boolean inGC){
  int header=superPageHeaderSize() + cellHeaderSize();
  int pages=(bytes + header + BYTES_IN_PAGE - 1) >> LOG_BYTES_IN_PAGE;
  VM_Address sp=allocSuperPage(pages);
  if (sp.isZero())   return sp;
  VM_Address cell=sp.add(header);
  Memory.zero(cell,VM_Extent.fromInt(bytes));
  return cell;
}","/** 
 * Allocate a large object.  Large objects are directly allocted and freed in page-grained units via the vm resource.  This routine returned zeroed memory.
 * @param isScalar True if the object to occupy this space will be a scalar.
 * @param bytes The required size of this space in bytes.
 * @param inGC If true, this allocation is occuring with respect toa space that is currently being collected.
 * @return The address of the start of the newly allocated region atleast <code>bytes</code> bytes in size.
 */
final protected VM_Address allocSlowOnce(boolean isScalar,int bytes,boolean inGC){
  int header=superPageHeaderSize() + cellHeaderSize();
  int pages=(bytes + header + BYTES_IN_PAGE - 1) >> LOG_BYTES_IN_PAGE;
  VM_Address sp=allocSuperPage(pages);
  if (sp.isZero())   return sp;
  VM_Address cell=sp.add(header);
  Memory.zero(cell,VM_Extent.fromIntZeroExtend(bytes));
  return cell;
}",0.9944382647385984
150271,"/** 
 * Create (in host jdk address space) the rvm objects that will be needed at run time to execute enough of the virtual machine to dynamically load and compile the remainder of itself. Side effect: rvm objects are created in host jdk address space VM_Statics is populated ""bootImageTypes"" dictionary is populated with name/type pairs
 * @param typeNames names of rvm classes whose static fields will containthe objects comprising the virtual machine bootimage
 */
public static void createBootImageObjects(Vector typeNames,String bootImageTypeNamesFile) throws IllegalAccessException, ClassNotFoundException {
  VM_Callbacks.notifyBootImage(typeNames.elements());
  if (verbose >= 1)   say(""String_Node_Str"");
  for (Enumeration e=typeNames.elements(); e.hasMoreElements(); ) {
    String typeName=(String)e.nextElement();
    if (verbose >= 4)     say(""String_Node_Str"",typeName);
    VM_Type type;
    try {
      VM_TypeReference tRef=VM_TypeReference.findOrCreate(typeName);
      type=tRef.resolve();
    }
 catch (    NoClassDefFoundError ncdf) {
      ncdf.printStackTrace();
      fail(bootImageTypeNamesFile + ""String_Node_Str"" + typeName+ ""String_Node_Str""+ ncdf);
      return;
    }
catch (    IllegalArgumentException ila) {
      ila.printStackTrace();
      fail(bootImageTypeNamesFile + ""String_Node_Str"" + typeName+ ""String_Node_Str""+ ila);
      return;
    }
    type.markAsBootImageClass();
    typeName=typeName.replace('/','.');
    if (typeName.startsWith(""String_Node_Str""))     typeName=typeName.substring(1,typeName.length() - 1);
    bootImageTypes.put(typeName,type);
  }
  if (verbose >= 1)   say(String.valueOf(bootImageTypes.size()),""String_Node_Str"");
  if (verbose >= 1)   say(""String_Node_Str"");
  for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
    VM_Type type=(VM_Type)e.nextElement();
    if (verbose >= 2)     say(""String_Node_Str"" + type);
    type.resolve();
  }
  VM_BootRecord bootRecord=VM_BootRecord.the_boot_record;
  VM_Class rvmBRType=getRvmType(bootRecord.getClass()).asClass();
  VM_Array intArrayType=VM_Array.getPrimitiveArrayType(10);
  int bp=bootImageAddress;
  bp+=rvmBRType.getInstanceSize();
  int align=VM_ObjectModel.getAlignment(intArrayType);
  int offset=VM_ObjectModel.getOffsetForAlignment(intArrayType);
  int mod=(bp + offset) & (align - 1);
  int delta=(align - mod) & (align - 1);
  bp+=delta;
  bp+=intArrayType.getInstanceSize(0);
  bootRecord.tocRegister=VM_Address.fromIntZeroExtend(bp);
  if (verbose >= 1)   say(""String_Node_Str"");
  if (PARALLELIZE < 1) {
    int count=0;
    for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
      VM_Type type=(VM_Type)e.nextElement();
      count++;
      if (verbose >= 1)       say(count + ""String_Node_Str"" + type);
      type.instantiate();
    }
  }
 else {
    if (verbose >= 1)     say(""String_Node_Str"" + PARALLELIZE + ""String_Node_Str"");
    BootImageWorker.startup(bootImageTypes.elements());
    BootImageWorker[] workers=new BootImageWorker[PARALLELIZE];
    for (int i=0; i < workers.length; i++) {
      workers[i].id=i;
      workers[i].start();
    }
    try {
      for (int i=0; i < workers.length; i++)       workers[i].join();
    }
 catch (    InterruptedException ie) {
      say(""String_Node_Str"");
    }
  }
  VM_CodeArray[] functionTable=BuildJNIFunctionTable.buildTable();
  VM_JNIEnvironment.initFunctionTable(functionTable);
  if (verbose >= 1)   say(""String_Node_Str"");
  bootImageTypeFields=new HashMap(bootImageTypes.size());
  for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
    VM_Type rvmType=(VM_Type)e.nextElement();
    FieldInfo fieldInfo;
    if (!rvmType.isClassType())     continue;
    Class jdkType=getJdkType(rvmType);
    if (jdkType == null)     continue;
    Key key=new Key(jdkType);
    fieldInfo=(FieldInfo)bootImageTypeFields.get(key);
    if (fieldInfo != null) {
      fieldInfo.rvmType=rvmType;
    }
 else {
      if (verbose >= 1)       say(""String_Node_Str"" + rvmType);
      fieldInfo=new FieldInfo();
      fieldInfo.jdkFields=jdkType.getDeclaredFields();
      fieldInfo.jdkType=jdkType;
      fieldInfo.rvmType=rvmType;
      bootImageTypeFields.put(key,fieldInfo);
      for (Class cls=jdkType.getSuperclass(); cls != null; cls=cls.getSuperclass()) {
        key=new Key(cls);
        fieldInfo=(FieldInfo)bootImageTypeFields.get(key);
        if (fieldInfo != null) {
          break;
        }
 else {
          if (verbose >= 1)           say(""String_Node_Str"" + jdkType);
          fieldInfo=new FieldInfo();
          fieldInfo.jdkFields=cls.getDeclaredFields();
          fieldInfo.jdkType=cls;
          fieldInfo.rvmType=null;
          bootImageTypeFields.put(key,fieldInfo);
        }
      }
    }
  }
  for (Iterator iter=bootImageTypeFields.values().iterator(); iter.hasNext(); ) {
    FieldInfo fieldInfo=(FieldInfo)iter.next();
    VM_Type rvmType=fieldInfo.rvmType;
    if (rvmType == null) {
      if (verbose >= 1)       say(""String_Node_Str"" + fieldInfo.jdkType);
      continue;
    }
    Class jdkType=fieldInfo.jdkType;
    if (verbose >= 1)     say(""String_Node_Str"" + rvmType);
    VM_Field rvmFields[]=rvmType.getStaticFields();
    fieldInfo.jdkStaticFields=new Field[rvmFields.length];
    for (int j=0; j < rvmFields.length; j++) {
      String rvmName=rvmFields[j].getName().toString();
      for (int k=0; k < fieldInfo.jdkFields.length; k++) {
        Field f=fieldInfo.jdkFields[k];
        if (f.getName().equals(rvmName)) {
          fieldInfo.jdkStaticFields[j]=f;
          f.setAccessible(true);
          break;
        }
      }
    }
    rvmFields=rvmType.getInstanceFields();
    fieldInfo.jdkInstanceFields=new Field[rvmFields.length];
    for (int j=0; j < rvmFields.length; j++) {
      String rvmName=rvmFields[j].getName().toString();
      jdkType=getJdkType(rvmFields[j].getDeclaringClass());
      if (jdkType == null)       continue;
      FieldInfo jdkFieldInfo=(FieldInfo)bootImageTypeFields.get(new Key(jdkType));
      if (jdkFieldInfo == null)       continue;
      Field[] jdkFields=jdkFieldInfo.jdkFields;
      for (int k=0; k < jdkFields.length; k++) {
        Field f=jdkFields[k];
        if (f.getName().equals(rvmName)) {
          fieldInfo.jdkInstanceFields[j]=f;
          f.setAccessible(true);
          break;
        }
      }
    }
  }
  int initProc=VM_Scheduler.PRIMORDIAL_PROCESSOR_ID;
  VM_Thread startupThread=new VM_Thread(new byte[STACK_SIZE_BOOT]);
  VM_Scheduler.processors[initProc].activeThread=startupThread;
  int idx=startupThread.stack.length - 1;
  if (VM.LittleEndian) {
    startupThread.stack[idx--]=(byte)0xde;
    startupThread.stack[idx--]=(byte)0xad;
    startupThread.stack[idx--]=(byte)0xba;
    startupThread.stack[idx--]=(byte)0xbe;
  }
 else {
    startupThread.stack[idx--]=(byte)0xbe;
    startupThread.stack[idx--]=(byte)0xba;
    startupThread.stack[idx--]=(byte)0xad;
    startupThread.stack[idx--]=(byte)0xde;
  }
  VM_ClassLoader.setVmRepositories(bootImageRepositoriesAtExecutionTime);
  if (verbose >= 1)   say(""String_Node_Str"");
  for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
    VM_Type rvmType=(VM_Type)e.nextElement();
    if (verbose >= 1)     say(""String_Node_Str"",rvmType.toString());
    if (!rvmType.isClassType())     continue;
    Class jdkType=getJdkType(rvmType);
    if (jdkType == null && verbose >= 1) {
      say(""String_Node_Str"" + rvmType + ""String_Node_Str"");
    }
    VM_Field rvmFields[]=rvmType.getStaticFields();
    for (int j=0; j < rvmFields.length; ++j) {
      VM_Field rvmField=rvmFields[j];
      VM_TypeReference rvmFieldType=rvmField.getType();
      int rvmFieldSlot=(rvmField.getOffset() >>> 2);
      String rvmFieldName=rvmField.getName().toString();
      Field jdkFieldAcc=null;
      if (jdkType != null)       jdkFieldAcc=getJdkFieldAccessor(jdkType,j,STATIC_FIELD);
      if (jdkFieldAcc == null) {
        if (jdkType != null) {
          if (verbose >= 2)           traceContext.push(rvmFieldType.toString(),jdkType.getName(),rvmFieldName);
          if (verbose >= 2)           traceContext.traceFieldNotInHostJdk();
          if (verbose >= 2)           traceContext.pop();
        }
        VM_Statics.setSlotContents(rvmFieldSlot,0);
        if (!VM.runningTool)         bootImage.countNulledReference();
        continue;
      }
      if (verbose >= 2)       say(""String_Node_Str"",String.valueOf(rvmFieldSlot),""String_Node_Str"",rvmField.toString());
      if (rvmFieldType.isPrimitiveType()) {
        if (rvmFieldType.isBooleanType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getBoolean(null) ? 1 : 0);
        }
 else         if (rvmFieldType.isByteType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getByte(null));
        }
 else         if (rvmFieldType.isCharType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getChar(null));
        }
 else         if (rvmFieldType.isShortType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getShort(null));
        }
 else         if (rvmFieldType.isIntType()) {
          try {
            VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getInt(null));
          }
 catch (          IllegalArgumentException ex) {
            System.err.println(""String_Node_Str"" + rvmType + ""String_Node_Str""+ rvmField);
            throw ex;
          }
        }
 else         if (rvmFieldType.isLongType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getLong(null));
        }
 else         if (rvmFieldType.isFloatType()) {
          float f=jdkFieldAcc.getFloat(null);
          VM_Statics.setSlotContents(rvmFieldSlot,Float.floatToIntBits(f));
        }
 else         if (rvmFieldType.isDoubleType()) {
          double d=jdkFieldAcc.getDouble(null);
          VM_Statics.setSlotContents(rvmFieldSlot,Double.doubleToLongBits(d));
        }
 else         if (rvmFieldType.equals(VM_TypeReference.Address)) {
          Object o=jdkFieldAcc.get(null);
          VM_Address addr=(VM_Address)o;
          String msg=""String_Node_Str"" + rvmField.toString();
          VM_Statics.setSlotContents(rvmFieldSlot,getAddressValue(addr,msg,true));
        }
 else         if (rvmFieldType.equals(VM_TypeReference.Word)) {
          VM_Word w=(VM_Word)jdkFieldAcc.get(null);
          int val=w == null ? 0 : w.toInt();
          VM_Statics.setSlotContents(rvmFieldSlot,val);
        }
 else         if (rvmFieldType.equals(VM_TypeReference.Offset)) {
          VM_Offset o=(VM_Offset)jdkFieldAcc.get(null);
          int val=o == null ? 0 : o.toInt();
          VM_Statics.setSlotContents(rvmFieldSlot,val);
        }
 else         if (rvmFieldType.equals(VM_TypeReference.Extent)) {
          VM_Extent ex=(VM_Extent)jdkFieldAcc.get(null);
          int val=ex == null ? 0 : ex.toInt();
          VM_Statics.setSlotContents(rvmFieldSlot,val);
        }
 else {
          fail(""String_Node_Str"" + rvmFieldType);
        }
      }
 else {
        Object o=jdkFieldAcc.get(null);
        if (verbose >= 3)         say(""String_Node_Str"",String.valueOf(VM_Magic.objectAsAddress(o).toInt()));
        VM_Statics.setSlotContents(rvmFieldSlot,VM_Magic.objectAsAddress(o).toInt());
        VM_Statics.setSlotContents(rvmFieldSlot,VM_Magic.objectAsAddress(o).toLong());
      }
    }
  }
}","/** 
 * Create (in host jdk address space) the rvm objects that will be needed at run time to execute enough of the virtual machine to dynamically load and compile the remainder of itself. Side effect: rvm objects are created in host jdk address space VM_Statics is populated ""bootImageTypes"" dictionary is populated with name/type pairs
 * @param typeNames names of rvm classes whose static fields will containthe objects comprising the virtual machine bootimage
 */
public static void createBootImageObjects(Vector typeNames,String bootImageTypeNamesFile) throws IllegalAccessException, ClassNotFoundException {
  VM_Callbacks.notifyBootImage(typeNames.elements());
  if (verbose >= 1)   say(""String_Node_Str"");
  for (Enumeration e=typeNames.elements(); e.hasMoreElements(); ) {
    String typeName=(String)e.nextElement();
    if (verbose >= 4)     say(""String_Node_Str"",typeName);
    VM_Type type;
    try {
      VM_TypeReference tRef=VM_TypeReference.findOrCreate(typeName);
      type=tRef.resolve();
    }
 catch (    NoClassDefFoundError ncdf) {
      ncdf.printStackTrace();
      fail(bootImageTypeNamesFile + ""String_Node_Str"" + typeName+ ""String_Node_Str""+ ncdf);
      return;
    }
catch (    IllegalArgumentException ila) {
      ila.printStackTrace();
      fail(bootImageTypeNamesFile + ""String_Node_Str"" + typeName+ ""String_Node_Str""+ ila);
      return;
    }
    type.markAsBootImageClass();
    typeName=typeName.replace('/','.');
    if (typeName.startsWith(""String_Node_Str""))     typeName=typeName.substring(1,typeName.length() - 1);
    bootImageTypes.put(typeName,type);
  }
  if (verbose >= 1)   say(String.valueOf(bootImageTypes.size()),""String_Node_Str"");
  if (verbose >= 1)   say(""String_Node_Str"");
  for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
    VM_Type type=(VM_Type)e.nextElement();
    if (verbose >= 2)     say(""String_Node_Str"" + type);
    type.resolve();
  }
  VM_BootRecord bootRecord=VM_BootRecord.the_boot_record;
  VM_Class rvmBRType=getRvmType(bootRecord.getClass()).asClass();
  VM_Array intArrayType=VM_Array.getPrimitiveArrayType(10);
  int bp=bootImageAddress;
  bp+=rvmBRType.getInstanceSize();
  int align=VM_ObjectModel.getAlignment(intArrayType);
  int offset=VM_ObjectModel.getOffsetForAlignment(intArrayType);
  int mod=(bp + offset) & (align - 1);
  int delta=(align - mod) & (align - 1);
  bp+=delta;
  bp+=intArrayType.getInstanceSize(0);
  bootRecord.tocRegister=VM_Address.fromIntZeroExtend(bp);
  if (verbose >= 1)   say(""String_Node_Str"");
  if (PARALLELIZE < 1) {
    int count=0;
    for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
      VM_Type type=(VM_Type)e.nextElement();
      count++;
      if (verbose >= 1)       say(count + ""String_Node_Str"" + type);
      type.instantiate();
    }
  }
 else {
    if (verbose >= 1)     say(""String_Node_Str"" + PARALLELIZE + ""String_Node_Str"");
    BootImageWorker.startup(bootImageTypes.elements());
    BootImageWorker[] workers=new BootImageWorker[PARALLELIZE];
    for (int i=0; i < workers.length; i++) {
      workers[i].id=i;
      workers[i].start();
    }
    try {
      for (int i=0; i < workers.length; i++)       workers[i].join();
    }
 catch (    InterruptedException ie) {
      say(""String_Node_Str"");
    }
  }
  VM_CodeArray[] functionTable=BuildJNIFunctionTable.buildTable();
  VM_JNIEnvironment.initFunctionTable(functionTable);
  if (verbose >= 1)   say(""String_Node_Str"");
  bootImageTypeFields=new HashMap(bootImageTypes.size());
  for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
    VM_Type rvmType=(VM_Type)e.nextElement();
    FieldInfo fieldInfo;
    if (!rvmType.isClassType())     continue;
    Class jdkType=getJdkType(rvmType);
    if (jdkType == null)     continue;
    Key key=new Key(jdkType);
    fieldInfo=(FieldInfo)bootImageTypeFields.get(key);
    if (fieldInfo != null) {
      fieldInfo.rvmType=rvmType;
    }
 else {
      if (verbose >= 1)       say(""String_Node_Str"" + rvmType);
      fieldInfo=new FieldInfo();
      fieldInfo.jdkFields=jdkType.getDeclaredFields();
      fieldInfo.jdkType=jdkType;
      fieldInfo.rvmType=rvmType;
      bootImageTypeFields.put(key,fieldInfo);
      for (Class cls=jdkType.getSuperclass(); cls != null; cls=cls.getSuperclass()) {
        key=new Key(cls);
        fieldInfo=(FieldInfo)bootImageTypeFields.get(key);
        if (fieldInfo != null) {
          break;
        }
 else {
          if (verbose >= 1)           say(""String_Node_Str"" + jdkType);
          fieldInfo=new FieldInfo();
          fieldInfo.jdkFields=cls.getDeclaredFields();
          fieldInfo.jdkType=cls;
          fieldInfo.rvmType=null;
          bootImageTypeFields.put(key,fieldInfo);
        }
      }
    }
  }
  for (Iterator iter=bootImageTypeFields.values().iterator(); iter.hasNext(); ) {
    FieldInfo fieldInfo=(FieldInfo)iter.next();
    VM_Type rvmType=fieldInfo.rvmType;
    if (rvmType == null) {
      if (verbose >= 1)       say(""String_Node_Str"" + fieldInfo.jdkType);
      continue;
    }
    Class jdkType=fieldInfo.jdkType;
    if (verbose >= 1)     say(""String_Node_Str"" + rvmType);
    VM_Field rvmFields[]=rvmType.getStaticFields();
    fieldInfo.jdkStaticFields=new Field[rvmFields.length];
    for (int j=0; j < rvmFields.length; j++) {
      String rvmName=rvmFields[j].getName().toString();
      for (int k=0; k < fieldInfo.jdkFields.length; k++) {
        Field f=fieldInfo.jdkFields[k];
        if (f.getName().equals(rvmName)) {
          fieldInfo.jdkStaticFields[j]=f;
          f.setAccessible(true);
          break;
        }
      }
    }
    rvmFields=rvmType.getInstanceFields();
    fieldInfo.jdkInstanceFields=new Field[rvmFields.length];
    for (int j=0; j < rvmFields.length; j++) {
      String rvmName=rvmFields[j].getName().toString();
      jdkType=getJdkType(rvmFields[j].getDeclaringClass());
      if (jdkType == null)       continue;
      FieldInfo jdkFieldInfo=(FieldInfo)bootImageTypeFields.get(new Key(jdkType));
      if (jdkFieldInfo == null)       continue;
      Field[] jdkFields=jdkFieldInfo.jdkFields;
      for (int k=0; k < jdkFields.length; k++) {
        Field f=jdkFields[k];
        if (f.getName().equals(rvmName)) {
          fieldInfo.jdkInstanceFields[j]=f;
          f.setAccessible(true);
          break;
        }
      }
    }
  }
  int initProc=VM_Scheduler.PRIMORDIAL_PROCESSOR_ID;
  VM_Thread startupThread=new VM_Thread(new byte[STACK_SIZE_BOOT]);
  VM_Scheduler.processors[initProc].activeThread=startupThread;
  int idx=startupThread.stack.length - 1;
  if (VM.LittleEndian) {
    startupThread.stack[idx--]=(byte)0xde;
    startupThread.stack[idx--]=(byte)0xad;
    startupThread.stack[idx--]=(byte)0xba;
    startupThread.stack[idx--]=(byte)0xbe;
  }
 else {
    startupThread.stack[idx--]=(byte)0xbe;
    startupThread.stack[idx--]=(byte)0xba;
    startupThread.stack[idx--]=(byte)0xad;
    startupThread.stack[idx--]=(byte)0xde;
  }
  VM_ClassLoader.setVmRepositories(bootImageRepositoriesAtExecutionTime);
  if (verbose >= 1)   say(""String_Node_Str"");
  for (Enumeration e=bootImageTypes.elements(); e.hasMoreElements(); ) {
    VM_Type rvmType=(VM_Type)e.nextElement();
    if (verbose >= 1)     say(""String_Node_Str"",rvmType.toString());
    if (!rvmType.isClassType())     continue;
    Class jdkType=getJdkType(rvmType);
    if (jdkType == null && verbose >= 1) {
      say(""String_Node_Str"" + rvmType + ""String_Node_Str"");
    }
    VM_Field rvmFields[]=rvmType.getStaticFields();
    for (int j=0; j < rvmFields.length; ++j) {
      VM_Field rvmField=rvmFields[j];
      VM_TypeReference rvmFieldType=rvmField.getType();
      int rvmFieldSlot=(rvmField.getOffset() >>> 2);
      String rvmFieldName=rvmField.getName().toString();
      Field jdkFieldAcc=null;
      if (jdkType != null)       jdkFieldAcc=getJdkFieldAccessor(jdkType,j,STATIC_FIELD);
      if (jdkFieldAcc == null) {
        if (jdkType != null) {
          if (verbose >= 2)           traceContext.push(rvmFieldType.toString(),jdkType.getName(),rvmFieldName);
          if (verbose >= 2)           traceContext.traceFieldNotInHostJdk();
          if (verbose >= 2)           traceContext.pop();
        }
        VM_Statics.setSlotContents(rvmFieldSlot,0);
        if (!VM.runningTool)         bootImage.countNulledReference();
        continue;
      }
      if (verbose >= 2)       say(""String_Node_Str"",String.valueOf(rvmFieldSlot),""String_Node_Str"",rvmField.toString());
      if (rvmFieldType.isPrimitiveType()) {
        if (rvmFieldType.isBooleanType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getBoolean(null) ? 1 : 0);
        }
 else         if (rvmFieldType.isByteType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getByte(null));
        }
 else         if (rvmFieldType.isCharType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getChar(null));
        }
 else         if (rvmFieldType.isShortType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getShort(null));
        }
 else         if (rvmFieldType.isIntType()) {
          try {
            VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getInt(null));
          }
 catch (          IllegalArgumentException ex) {
            System.err.println(""String_Node_Str"" + rvmType + ""String_Node_Str""+ rvmField);
            throw ex;
          }
        }
 else         if (rvmFieldType.isLongType()) {
          VM_Statics.setSlotContents(rvmFieldSlot,jdkFieldAcc.getLong(null));
        }
 else         if (rvmFieldType.isFloatType()) {
          float f=jdkFieldAcc.getFloat(null);
          VM_Statics.setSlotContents(rvmFieldSlot,Float.floatToIntBits(f));
        }
 else         if (rvmFieldType.isDoubleType()) {
          double d=jdkFieldAcc.getDouble(null);
          VM_Statics.setSlotContents(rvmFieldSlot,Double.doubleToLongBits(d));
        }
 else         if (rvmFieldType.equals(VM_TypeReference.Address) || rvmFieldType.equals(VM_TypeReference.Word) || rvmFieldType.equals(VM_TypeReference.Extent)|| rvmFieldType.equals(VM_TypeReference.Offset)) {
          Object o=jdkFieldAcc.get(null);
          String msg=""String_Node_Str"" + rvmField.toString();
          boolean warn=rvmFieldType.equals(VM_TypeReference.Address);
          VM_Statics.setSlotContents(rvmFieldSlot,getAddressValue(o,msg,warn));
        }
 else {
          fail(""String_Node_Str"" + rvmFieldType);
        }
      }
 else {
        Object o=jdkFieldAcc.get(null);
        if (verbose >= 3)         say(""String_Node_Str"",String.valueOf(VM_Magic.objectAsAddress(o).toInt()));
        VM_Statics.setSlotContents(rvmFieldSlot,VM_Magic.objectAsAddress(o).toInt());
        VM_Statics.setSlotContents(rvmFieldSlot,VM_Magic.objectAsAddress(o).toLong());
      }
    }
  }
}",0.9475917482959418
150272,"/** 
 * Copy an object (and, recursively, any of its fields or elements that are references) from host jdk address space into image.
 * @param jdkObject object to be copied
 * @param if allocOnly is true, the TIB and other reference fields are not recursively copied
 * @param if overwriteOffset is > 0, then copy object to given address
 * @return offset of copied object within image, in bytes(OBJECT_NOT_PRESENT --> object not copied: it's not part of bootimage)
 */
private static int copyToBootImage(Object jdkObject,boolean allocOnly,int overwriteOffset,Object parentObject) throws IllegalAccessException {
  BootImageMap.Entry mapEntry=BootImageMap.findOrCreateEntry(jdkObject);
  if (mapEntry.imageOffset != OBJECT_NOT_ALLOCATED && overwriteOffset == -1)   return mapEntry.imageOffset;
  if (verbose >= 2)   depth++;
  Class jdkType=jdkObject.getClass();
  VM_Type rvmType=getRvmType(jdkType);
  if (rvmType == null) {
    if (verbose >= 2)     traverseObject(jdkObject);
    if (verbose >= 2)     depth--;
    return OBJECT_NOT_PRESENT;
  }
  if (jdkType.isArray()) {
    VM_Array rvmArrayType=rvmType.asArray();
    int arrayCount=Array.getLength(jdkObject);
    int arrayImageOffset=(overwriteOffset == -1) ? bootImage.allocateArray(rvmArrayType,arrayCount) : overwriteOffset;
    mapEntry.imageOffset=arrayImageOffset;
    if (verbose >= 2) {
      if (depth == depthCutoff)       say(SPACES.substring(0,depth + 1),""String_Node_Str"");
 else       if (depth < depthCutoff) {
        String tab=SPACES.substring(0,depth + 1);
        if (depth == 0 && jtocCount >= 0)         tab=tab + ""String_Node_Str"" + String.valueOf(jtocCount)+ ""String_Node_Str"";
        int arraySize=rvmArrayType.getInstanceSize(arrayCount);
        say(tab,""String_Node_Str"",jdkType.getName(),""String_Node_Str"",String.valueOf(arrayCount),(arraySize >= LARGE_ARRAY_SIZE) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
    VM_Type rvmElementType=rvmArrayType.getElementType();
    if (false && rvmElementType.equals(VM_Type.IntType)) {
      if (parentObject != null) {
        Class parentObjectType=parentObject.getClass();
        VM.sysWrite(""String_Node_Str"",4 * ((int[])jdkObject).length);
        VM.sysWriteln(""String_Node_Str"",parentObjectType.toString());
      }
 else {
        VM.sysWriteln(""String_Node_Str"");
      }
    }
    if (rvmElementType.isPrimitiveType()) {
      if (rvmElementType.equals(VM_Type.BooleanType)) {
        boolean values[]=(boolean[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setByte(arrayImageOffset + i,values[i] ? 1 : 0);
      }
 else       if (rvmElementType.equals(VM_Type.ByteType)) {
        byte values[]=(byte[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setByte(arrayImageOffset + i,values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.CharType)) {
        char values[]=(char[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setHalfWord(arrayImageOffset + (i << LOG_BYTES_IN_CHAR),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.ShortType)) {
        short values[]=(short[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setHalfWord(arrayImageOffset + (i << LOG_BYTES_IN_SHORT),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.IntType)) {
        int values[]=(int[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setFullWord(arrayImageOffset + (i << LOG_BYTES_IN_INT),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.LongType)) {
        long values[]=(long[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setDoubleWord(arrayImageOffset + (i << LOG_BYTES_IN_LONG),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.FloatType)) {
        float values[]=(float[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setFullWord(arrayImageOffset + (i << LOG_BYTES_IN_FLOAT),Float.floatToIntBits(values[i]));
      }
 else       if (rvmElementType.equals(VM_Type.DoubleType)) {
        double values[]=(double[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setDoubleWord(arrayImageOffset + (i << LOG_BYTES_IN_DOUBLE),Double.doubleToLongBits(values[i]));
      }
 else       fail(""String_Node_Str"" + rvmArrayType);
    }
 else {
      Object values[]=(Object[])jdkObject;
      Class jdkClass=jdkObject.getClass();
      if (!allocOnly) {
        for (int i=0; i < arrayCount; ++i) {
          if (values[i] != null) {
            if (verbose >= 2)             traceContext.push(values[i].getClass().getName(),jdkClass.getName(),i);
            int imageOffset=copyToBootImage(values[i],allocOnly,-1,jdkObject);
            if (imageOffset == OBJECT_NOT_PRESENT) {
              if (verbose >= 2)               traceContext.traceObjectNotInBootImage();
              bootImage.setNullAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS));
            }
 else {
              bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),bootImageAddress + imageOffset);
            }
            if (verbose >= 2)             traceContext.pop();
          }
        }
      }
    }
  }
 else {
    if (rvmType == VM_Type.AddressArrayType) {
      if (verbose >= 2)       depth--;
      VM_AddressArray addrArray=(VM_AddressArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.OffsetArrayType) {
      if (verbose >= 2)       depth--;
      VM_OffsetArray addrArray=(VM_OffsetArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.WordArrayType) {
      if (verbose >= 2)       depth--;
      VM_WordArray addrArray=(VM_WordArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.ExtentArrayType) {
      if (verbose >= 2)       depth--;
      VM_ExtentArray addrArray=(VM_ExtentArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.CodeArrayType) {
      if (verbose >= 2)       depth--;
      VM_CodeArray codeArray=(VM_CodeArray)jdkObject;
      Object backing=codeArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType.isMagicType()) {
      VM.sysWriteln(""String_Node_Str"" + rvmType.getDescriptor().toString());
      VM.sysFail(""String_Node_Str"");
    }
    VM_Class rvmScalarType=rvmType.asClass();
    int scalarImageOffset=(overwriteOffset == -1) ? bootImage.allocateScalar(rvmScalarType) : overwriteOffset;
    mapEntry.imageOffset=scalarImageOffset;
    if (verbose >= 2) {
      if (depth == depthCutoff)       say(SPACES.substring(0,depth + 1),""String_Node_Str"");
 else       if (depth < depthCutoff) {
        String tab=SPACES.substring(0,depth + 1);
        if (depth == 0 && jtocCount >= 0)         tab=tab + ""String_Node_Str"" + String.valueOf(jtocCount)+ ""String_Node_Str"";
        int scalarSize=rvmScalarType.getInstanceSize();
        say(tab,""String_Node_Str"",jdkType.getName(),""String_Node_Str"",String.valueOf(scalarSize),(scalarSize >= LARGE_SCALAR_SIZE) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
    VM_Field[] rvmFields=rvmScalarType.getInstanceFields();
    for (int i=0, n=rvmFields.length; i < n; ++i) {
      VM_Field rvmField=rvmFields[i];
      VM_TypeReference rvmFieldType=rvmField.getType();
      int rvmFieldOffset=scalarImageOffset + rvmField.getOffset();
      String rvmFieldName=rvmField.getName().toString();
      Field jdkFieldAcc=getJdkFieldAccessor(jdkType,i,INSTANCE_FIELD);
      if (jdkFieldAcc == null) {
        if (verbose >= 2)         traceContext.push(rvmFieldType.toString(),jdkType.getName(),rvmFieldName);
        if (verbose >= 2)         traceContext.traceFieldNotInHostJdk();
        if (verbose >= 2)         traceContext.pop();
        if (rvmFieldType.isPrimitiveType()) switch (rvmField.getType().getSize()) {
case 4:
          bootImage.setFullWord(rvmFieldOffset,0);
        break;
case 8:
      bootImage.setDoubleWord(rvmFieldOffset,0L);
    break;
default :
  fail(""String_Node_Str"" + rvmFieldType);
break;
}
 else bootImage.setNullAddressWord(rvmFieldOffset);
continue;
}
if (rvmFieldType.isPrimitiveType()) {
if (rvmFieldType.isBooleanType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getBoolean(jdkObject) ? 1 : 0);
}
 else if (rvmFieldType.isByteType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getByte(jdkObject));
}
 else if (rvmFieldType.isCharType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getChar(jdkObject));
}
 else if (rvmFieldType.isShortType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getShort(jdkObject));
}
 else if (rvmFieldType.isIntType()) {
try {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getInt(jdkObject));
}
 catch (IllegalArgumentException ex) {
System.err.println(""String_Node_Str"" + rvmScalarType + ""String_Node_Str""+ rvmField);
throw ex;
}
}
 else if (rvmFieldType.isLongType()) {
bootImage.setDoubleWord(rvmFieldOffset,jdkFieldAcc.getLong(jdkObject));
}
 else if (rvmFieldType.isFloatType()) {
float f=jdkFieldAcc.getFloat(jdkObject);
bootImage.setFullWord(rvmFieldOffset,Float.floatToIntBits(f));
}
 else if (rvmFieldType.isDoubleType()) {
double d=jdkFieldAcc.getDouble(jdkObject);
bootImage.setDoubleWord(rvmFieldOffset,Double.doubleToLongBits(d));
}
 else if (rvmFieldType.equals(VM_TypeReference.Address)) {
Object o=jdkFieldAcc.get(jdkObject);
VM_Address addr=(VM_Address)o;
String msg=""String_Node_Str"" + rvmField.toString();
bootImage.setAddressWord(rvmFieldOffset,getAddressValue(addr,msg,true));
}
 else if (rvmFieldType.equals(VM_TypeReference.Word)) {
VM_Word w=(VM_Word)jdkFieldAcc.get(jdkObject);
int val=w == null ? 0 : w.toInt();
VM_Statics.setSlotContents(rvmFieldOffset,val);
}
 else if (rvmFieldType.equals(VM_TypeReference.Offset)) {
VM_Offset o=(VM_Offset)jdkFieldAcc.get(jdkObject);
int val=o == null ? 0 : o.toInt();
VM_Statics.setSlotContents(rvmFieldOffset,val);
}
 else if (rvmFieldType.equals(VM_TypeReference.Extent)) {
VM_Extent e=(VM_Extent)jdkFieldAcc.get(jdkObject);
int val=e == null ? 0 : e.toInt();
VM_Statics.setSlotContents(rvmFieldOffset,val);
}
 else {
fail(""String_Node_Str"" + rvmFieldType);
}
}
 else {
Object value=jdkFieldAcc.get(jdkObject);
if (!allocOnly && value != null) {
Class jdkClass=jdkFieldAcc.getDeclaringClass();
if (verbose >= 2) traceContext.push(value.getClass().getName(),jdkClass.getName(),jdkFieldAcc.getName());
int imageOffset=copyToBootImage(value,allocOnly,-1,jdkObject);
if (imageOffset == OBJECT_NOT_PRESENT) {
if (verbose >= 2) traceContext.traceObjectNotInBootImage();
bootImage.setNullAddressWord(rvmFieldOffset);
}
 else bootImage.setAddressWord(rvmFieldOffset,bootImageAddress + imageOffset);
if (verbose >= 2) traceContext.pop();
}
}
}
}
if (!allocOnly) {
if (verbose >= 2) traceContext.push(""String_Node_Str"",jdkObject.getClass().getName(),""String_Node_Str"");
int tibImageOffset=copyToBootImage(rvmType.getTypeInformationBlock(),allocOnly,-1,jdkObject);
if (verbose >= 2) traceContext.pop();
if (tibImageOffset == OBJECT_NOT_ALLOCATED) fail(""String_Node_Str"" + jdkObject);
int tibAddress=bootImageAddress + tibImageOffset;
VM_ObjectModel.setTIB(bootImage,mapEntry.imageOffset,VM_Address.fromIntZeroExtend(tibAddress),rvmType);
}
if (verbose >= 2) depth--;
return mapEntry.imageOffset;
}","/** 
 * Copy an object (and, recursively, any of its fields or elements that are references) from host jdk address space into image.
 * @param jdkObject object to be copied
 * @param if allocOnly is true, the TIB and other reference fields are not recursively copied
 * @param if overwriteOffset is > 0, then copy object to given address
 * @return offset of copied object within image, in bytes(OBJECT_NOT_PRESENT --> object not copied: it's not part of bootimage)
 */
private static int copyToBootImage(Object jdkObject,boolean allocOnly,int overwriteOffset,Object parentObject) throws IllegalAccessException {
  BootImageMap.Entry mapEntry=BootImageMap.findOrCreateEntry(jdkObject);
  if (mapEntry.imageOffset != OBJECT_NOT_ALLOCATED && overwriteOffset == -1)   return mapEntry.imageOffset;
  if (verbose >= 2)   depth++;
  Class jdkType=jdkObject.getClass();
  VM_Type rvmType=getRvmType(jdkType);
  if (rvmType == null) {
    if (verbose >= 2)     traverseObject(jdkObject);
    if (verbose >= 2)     depth--;
    return OBJECT_NOT_PRESENT;
  }
  if (jdkType.isArray()) {
    VM_Array rvmArrayType=rvmType.asArray();
    int arrayCount=Array.getLength(jdkObject);
    int arrayImageOffset=(overwriteOffset == -1) ? bootImage.allocateArray(rvmArrayType,arrayCount) : overwriteOffset;
    mapEntry.imageOffset=arrayImageOffset;
    if (verbose >= 2) {
      if (depth == depthCutoff)       say(SPACES.substring(0,depth + 1),""String_Node_Str"");
 else       if (depth < depthCutoff) {
        String tab=SPACES.substring(0,depth + 1);
        if (depth == 0 && jtocCount >= 0)         tab=tab + ""String_Node_Str"" + String.valueOf(jtocCount)+ ""String_Node_Str"";
        int arraySize=rvmArrayType.getInstanceSize(arrayCount);
        say(tab,""String_Node_Str"",jdkType.getName(),""String_Node_Str"",String.valueOf(arrayCount),(arraySize >= LARGE_ARRAY_SIZE) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
    VM_Type rvmElementType=rvmArrayType.getElementType();
    if (false && rvmElementType.equals(VM_Type.IntType)) {
      if (parentObject != null) {
        Class parentObjectType=parentObject.getClass();
        VM.sysWrite(""String_Node_Str"",4 * ((int[])jdkObject).length);
        VM.sysWriteln(""String_Node_Str"",parentObjectType.toString());
      }
 else {
        VM.sysWriteln(""String_Node_Str"");
      }
    }
    if (rvmElementType.isPrimitiveType()) {
      if (rvmElementType.equals(VM_Type.BooleanType)) {
        boolean values[]=(boolean[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setByte(arrayImageOffset + i,values[i] ? 1 : 0);
      }
 else       if (rvmElementType.equals(VM_Type.ByteType)) {
        byte values[]=(byte[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setByte(arrayImageOffset + i,values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.CharType)) {
        char values[]=(char[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setHalfWord(arrayImageOffset + (i << LOG_BYTES_IN_CHAR),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.ShortType)) {
        short values[]=(short[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setHalfWord(arrayImageOffset + (i << LOG_BYTES_IN_SHORT),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.IntType)) {
        int values[]=(int[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setFullWord(arrayImageOffset + (i << LOG_BYTES_IN_INT),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.LongType)) {
        long values[]=(long[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setDoubleWord(arrayImageOffset + (i << LOG_BYTES_IN_LONG),values[i]);
      }
 else       if (rvmElementType.equals(VM_Type.FloatType)) {
        float values[]=(float[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setFullWord(arrayImageOffset + (i << LOG_BYTES_IN_FLOAT),Float.floatToIntBits(values[i]));
      }
 else       if (rvmElementType.equals(VM_Type.DoubleType)) {
        double values[]=(double[])jdkObject;
        for (int i=0; i < arrayCount; ++i)         bootImage.setDoubleWord(arrayImageOffset + (i << LOG_BYTES_IN_DOUBLE),Double.doubleToLongBits(values[i]));
      }
 else       fail(""String_Node_Str"" + rvmArrayType);
    }
 else {
      Object values[]=(Object[])jdkObject;
      Class jdkClass=jdkObject.getClass();
      if (!allocOnly) {
        for (int i=0; i < arrayCount; ++i) {
          if (values[i] != null) {
            if (verbose >= 2)             traceContext.push(values[i].getClass().getName(),jdkClass.getName(),i);
            int imageOffset=copyToBootImage(values[i],allocOnly,-1,jdkObject);
            if (imageOffset == OBJECT_NOT_PRESENT) {
              if (verbose >= 2)               traceContext.traceObjectNotInBootImage();
              bootImage.setNullAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS));
            }
 else {
              bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),bootImageAddress + imageOffset);
            }
            if (verbose >= 2)             traceContext.pop();
          }
        }
      }
    }
  }
 else {
    if (rvmType == VM_Type.AddressArrayType) {
      if (verbose >= 2)       depth--;
      VM_AddressArray addrArray=(VM_AddressArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.OffsetArrayType) {
      if (verbose >= 2)       depth--;
      VM_OffsetArray addrArray=(VM_OffsetArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.WordArrayType) {
      if (verbose >= 2)       depth--;
      VM_WordArray addrArray=(VM_WordArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.ExtentArrayType) {
      if (verbose >= 2)       depth--;
      VM_ExtentArray addrArray=(VM_ExtentArray)jdkObject;
      Object backing=addrArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType == VM_Type.CodeArrayType) {
      if (verbose >= 2)       depth--;
      VM_CodeArray codeArray=(VM_CodeArray)jdkObject;
      Object backing=codeArray.getBacking();
      return copyMagicArrayToBootImage(backing,rvmType.asArray(),allocOnly,overwriteOffset,parentObject);
    }
    if (rvmType.isMagicType()) {
      VM.sysWriteln(""String_Node_Str"" + rvmType.getDescriptor().toString());
      VM.sysFail(""String_Node_Str"");
    }
    VM_Class rvmScalarType=rvmType.asClass();
    int scalarImageOffset=(overwriteOffset == -1) ? bootImage.allocateScalar(rvmScalarType) : overwriteOffset;
    mapEntry.imageOffset=scalarImageOffset;
    if (verbose >= 2) {
      if (depth == depthCutoff)       say(SPACES.substring(0,depth + 1),""String_Node_Str"");
 else       if (depth < depthCutoff) {
        String tab=SPACES.substring(0,depth + 1);
        if (depth == 0 && jtocCount >= 0)         tab=tab + ""String_Node_Str"" + String.valueOf(jtocCount)+ ""String_Node_Str"";
        int scalarSize=rvmScalarType.getInstanceSize();
        say(tab,""String_Node_Str"",jdkType.getName(),""String_Node_Str"",String.valueOf(scalarSize),(scalarSize >= LARGE_SCALAR_SIZE) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
    }
    VM_Field[] rvmFields=rvmScalarType.getInstanceFields();
    for (int i=0, n=rvmFields.length; i < n; ++i) {
      VM_Field rvmField=rvmFields[i];
      VM_TypeReference rvmFieldType=rvmField.getType();
      int rvmFieldOffset=scalarImageOffset + rvmField.getOffset();
      String rvmFieldName=rvmField.getName().toString();
      Field jdkFieldAcc=getJdkFieldAccessor(jdkType,i,INSTANCE_FIELD);
      if (jdkFieldAcc == null) {
        if (verbose >= 2)         traceContext.push(rvmFieldType.toString(),jdkType.getName(),rvmFieldName);
        if (verbose >= 2)         traceContext.traceFieldNotInHostJdk();
        if (verbose >= 2)         traceContext.pop();
        if (rvmFieldType.isPrimitiveType()) switch (rvmField.getType().getSize()) {
case 4:
          bootImage.setFullWord(rvmFieldOffset,0);
        break;
case 8:
      bootImage.setDoubleWord(rvmFieldOffset,0L);
    break;
default :
  fail(""String_Node_Str"" + rvmFieldType);
break;
}
 else bootImage.setNullAddressWord(rvmFieldOffset);
continue;
}
if (rvmFieldType.isPrimitiveType()) {
if (rvmFieldType.isBooleanType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getBoolean(jdkObject) ? 1 : 0);
}
 else if (rvmFieldType.isByteType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getByte(jdkObject));
}
 else if (rvmFieldType.isCharType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getChar(jdkObject));
}
 else if (rvmFieldType.isShortType()) {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getShort(jdkObject));
}
 else if (rvmFieldType.isIntType()) {
try {
bootImage.setFullWord(rvmFieldOffset,jdkFieldAcc.getInt(jdkObject));
}
 catch (IllegalArgumentException ex) {
System.err.println(""String_Node_Str"" + rvmScalarType + ""String_Node_Str""+ rvmField);
throw ex;
}
}
 else if (rvmFieldType.isLongType()) {
bootImage.setDoubleWord(rvmFieldOffset,jdkFieldAcc.getLong(jdkObject));
}
 else if (rvmFieldType.isFloatType()) {
float f=jdkFieldAcc.getFloat(jdkObject);
bootImage.setFullWord(rvmFieldOffset,Float.floatToIntBits(f));
}
 else if (rvmFieldType.isDoubleType()) {
double d=jdkFieldAcc.getDouble(jdkObject);
bootImage.setDoubleWord(rvmFieldOffset,Double.doubleToLongBits(d));
}
 else if (rvmFieldType.equals(VM_TypeReference.Address) || rvmFieldType.equals(VM_TypeReference.Word) || rvmFieldType.equals(VM_TypeReference.Extent)|| rvmFieldType.equals(VM_TypeReference.Offset)) {
Object o=jdkFieldAcc.get(jdkObject);
String msg=""String_Node_Str"" + rvmField.toString();
boolean warn=rvmFieldType.equals(VM_TypeReference.Address);
bootImage.setAddressWord(rvmFieldOffset,getAddressValue(o,msg,warn));
}
 else {
fail(""String_Node_Str"" + rvmFieldType);
}
}
 else {
Object value=jdkFieldAcc.get(jdkObject);
if (!allocOnly && value != null) {
Class jdkClass=jdkFieldAcc.getDeclaringClass();
if (verbose >= 2) traceContext.push(value.getClass().getName(),jdkClass.getName(),jdkFieldAcc.getName());
int imageOffset=copyToBootImage(value,allocOnly,-1,jdkObject);
if (imageOffset == OBJECT_NOT_PRESENT) {
if (verbose >= 2) traceContext.traceObjectNotInBootImage();
bootImage.setNullAddressWord(rvmFieldOffset);
}
 else bootImage.setAddressWord(rvmFieldOffset,bootImageAddress + imageOffset);
if (verbose >= 2) traceContext.pop();
}
}
}
}
if (!allocOnly) {
if (verbose >= 2) traceContext.push(""String_Node_Str"",jdkObject.getClass().getName(),""String_Node_Str"");
int tibImageOffset=copyToBootImage(rvmType.getTypeInformationBlock(),allocOnly,-1,jdkObject);
if (verbose >= 2) traceContext.pop();
if (tibImageOffset == OBJECT_NOT_ALLOCATED) fail(""String_Node_Str"" + jdkObject);
int tibAddress=bootImageAddress + tibImageOffset;
VM_ObjectModel.setTIB(bootImage,mapEntry.imageOffset,VM_Address.fromIntZeroExtend(tibAddress),rvmType);
}
if (verbose >= 2) depth--;
return mapEntry.imageOffset;
}",0.9561331901181526
150273,"private static long getAddressValue(VM_Address addr,String msg,boolean warn){
  if (addr == null)   return 0L;
  long value=addr.toLong();
  if (warn)   check((int)value,msg);
  return value;
}","private static long getAddressValue(Object addr,String msg,boolean warn){
  if (addr == null)   return 0L;
  long value=0L;
  if (addr instanceof VM_Address) {
    value=((VM_Address)addr).toLong();
  }
 else   if (addr instanceof VM_Word) {
    value=((VM_Word)addr).toLong();
  }
 else   if (addr instanceof VM_Extent) {
    value=((VM_Extent)addr).toLong();
  }
 else   if (addr instanceof VM_Offset) {
    value=((VM_Offset)addr).toLong();
  }
 else {
    VM.sysWriteln(""String_Node_Str"" + addr);
    VM.sysFail(""String_Node_Str"");
  }
  if (warn)   check((int)value,msg);
  return value;
}",0.4548919949174079
150274,"private static int copyMagicArrayToBootImage(Object jdkObject,VM_Array rvmArrayType,boolean allocOnly,int overwriteOffset,Object parentObject) throws IllegalAccessException {
  BootImageMap.Entry mapEntry=BootImageMap.findOrCreateEntry(jdkObject);
  if (mapEntry.imageOffset != OBJECT_NOT_ALLOCATED && overwriteOffset == -1)   return mapEntry.imageOffset;
  if (verbose >= 2)   depth++;
  int arrayCount=Array.getLength(jdkObject);
  int arrayImageOffset=(overwriteOffset == -1) ? bootImage.allocateArray(rvmArrayType,arrayCount) : overwriteOffset;
  mapEntry.imageOffset=arrayImageOffset;
  if (verbose >= 2) {
    if (depth == depthCutoff)     say(SPACES.substring(0,depth + 1),""String_Node_Str"");
 else     if (depth < depthCutoff) {
      String tab=SPACES.substring(0,depth + 1);
      if (depth == 0 && jtocCount >= 0)       tab=tab + ""String_Node_Str"" + String.valueOf(jtocCount)+ ""String_Node_Str"";
      int arraySize=rvmArrayType.getInstanceSize(arrayCount);
      say(tab,""String_Node_Str"",rvmArrayType.toString(),""String_Node_Str"",String.valueOf(arrayCount),(arraySize >= LARGE_ARRAY_SIZE) ? ""String_Node_Str"" : ""String_Node_Str"");
    }
  }
  VM_Type rvmElementType=rvmArrayType.getElementType();
  if (rvmElementType.equals(VM_Type.CodeType)) {
    if (VM.BuildForIA32) {
      byte values[]=(byte[])jdkObject;
      for (int i=0; i < arrayCount; ++i)       bootImage.setByte(arrayImageOffset + i,values[i]);
    }
 else {
      int values[]=(int[])jdkObject;
      for (int i=0; i < arrayCount; ++i)       bootImage.setFullWord(arrayImageOffset + (i << LOG_BYTES_IN_INT),values[i]);
    }
  }
 else   if (rvmElementType.equals(VM_Type.AddressType)) {
    VM_Address values[]=(VM_Address[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      VM_Address addr=values[i];
      String msg=""String_Node_Str"";
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,true));
    }
  }
 else   if (rvmElementType.equals(VM_Type.WordType)) {
    VM_Word values[]=(VM_Word[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      String msg=""String_Node_Str"";
      VM_Address addr=values[i].toAddress();
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,true));
    }
  }
 else   if (rvmElementType.equals(VM_Type.OffsetType)) {
    VM_Offset values[]=(VM_Offset[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      String msg=""String_Node_Str"" + i;
      VM_Address addr=values[i].toWord().toAddress();
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,true));
    }
  }
 else   if (rvmElementType.equals(VM_Type.ExtentType)) {
    VM_Extent values[]=(VM_Extent[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      String msg=""String_Node_Str"";
      VM_Address addr=values[i].toWord().toAddress();
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,true));
    }
  }
 else {
    fail(""String_Node_Str"" + rvmArrayType);
  }
  if (!allocOnly) {
    if (verbose >= 2)     traceContext.push(""String_Node_Str"",jdkObject.getClass().getName(),""String_Node_Str"");
    int tibImageOffset=copyToBootImage(rvmArrayType.getTypeInformationBlock(),allocOnly,-1,jdkObject);
    if (verbose >= 2)     traceContext.pop();
    if (tibImageOffset == OBJECT_NOT_ALLOCATED)     fail(""String_Node_Str"" + jdkObject);
    int tibAddress=bootImageAddress + tibImageOffset;
    VM_ObjectModel.setTIB(bootImage,mapEntry.imageOffset,VM_Address.fromIntZeroExtend(tibAddress),rvmArrayType);
  }
  if (verbose >= 2)   depth--;
  return mapEntry.imageOffset;
}","private static int copyMagicArrayToBootImage(Object jdkObject,VM_Array rvmArrayType,boolean allocOnly,int overwriteOffset,Object parentObject) throws IllegalAccessException {
  BootImageMap.Entry mapEntry=BootImageMap.findOrCreateEntry(jdkObject);
  if (mapEntry.imageOffset != OBJECT_NOT_ALLOCATED && overwriteOffset == -1)   return mapEntry.imageOffset;
  if (verbose >= 2)   depth++;
  int arrayCount=Array.getLength(jdkObject);
  int arrayImageOffset=(overwriteOffset == -1) ? bootImage.allocateArray(rvmArrayType,arrayCount) : overwriteOffset;
  mapEntry.imageOffset=arrayImageOffset;
  if (verbose >= 2) {
    if (depth == depthCutoff)     say(SPACES.substring(0,depth + 1),""String_Node_Str"");
 else     if (depth < depthCutoff) {
      String tab=SPACES.substring(0,depth + 1);
      if (depth == 0 && jtocCount >= 0)       tab=tab + ""String_Node_Str"" + String.valueOf(jtocCount)+ ""String_Node_Str"";
      int arraySize=rvmArrayType.getInstanceSize(arrayCount);
      say(tab,""String_Node_Str"",rvmArrayType.toString(),""String_Node_Str"",String.valueOf(arrayCount),(arraySize >= LARGE_ARRAY_SIZE) ? ""String_Node_Str"" : ""String_Node_Str"");
    }
  }
  VM_Type rvmElementType=rvmArrayType.getElementType();
  if (rvmElementType.equals(VM_Type.CodeType)) {
    if (VM.BuildForIA32) {
      byte values[]=(byte[])jdkObject;
      for (int i=0; i < arrayCount; ++i)       bootImage.setByte(arrayImageOffset + i,values[i]);
    }
 else {
      int values[]=(int[])jdkObject;
      for (int i=0; i < arrayCount; ++i)       bootImage.setFullWord(arrayImageOffset + (i << LOG_BYTES_IN_INT),values[i]);
    }
  }
 else   if (rvmElementType.equals(VM_Type.AddressType)) {
    VM_Address values[]=(VM_Address[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      VM_Address addr=values[i];
      String msg=""String_Node_Str"";
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,true));
    }
  }
 else   if (rvmElementType.equals(VM_Type.WordType)) {
    VM_Word values[]=(VM_Word[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      String msg=""String_Node_Str"";
      VM_Word addr=values[i];
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,false));
    }
  }
 else   if (rvmElementType.equals(VM_Type.OffsetType)) {
    VM_Offset values[]=(VM_Offset[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      String msg=""String_Node_Str"" + i;
      VM_Offset addr=values[i];
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,false));
    }
  }
 else   if (rvmElementType.equals(VM_Type.ExtentType)) {
    VM_Extent values[]=(VM_Extent[])jdkObject;
    for (int i=0; i < arrayCount; i++) {
      String msg=""String_Node_Str"";
      VM_Extent addr=values[i];
      bootImage.setAddressWord(arrayImageOffset + (i << LOG_BYTES_IN_ADDRESS),getAddressValue(addr,msg,false));
    }
  }
 else {
    fail(""String_Node_Str"" + rvmArrayType);
  }
  if (!allocOnly) {
    if (verbose >= 2)     traceContext.push(""String_Node_Str"",jdkObject.getClass().getName(),""String_Node_Str"");
    int tibImageOffset=copyToBootImage(rvmArrayType.getTypeInformationBlock(),allocOnly,-1,jdkObject);
    if (verbose >= 2)     traceContext.pop();
    if (tibImageOffset == OBJECT_NOT_ALLOCATED)     fail(""String_Node_Str"" + jdkObject);
    int tibAddress=bootImageAddress + tibImageOffset;
    VM_ObjectModel.setTIB(bootImage,mapEntry.imageOffset,VM_Address.fromIntZeroExtend(tibAddress),rvmArrayType);
  }
  if (verbose >= 2)   depth--;
  return mapEntry.imageOffset;
}",0.9845984598459846
150275,"private static void storeParametersForAIX(VM_Assembler asm,int frameSize,VM_Method method,VM_Class klass){
  int nextAIXArgReg, nextAIXArgFloatReg, nextVMArgReg, nextVMArgFloatReg;
  int spillOffsetAIX=NATIVE_FRAME_HEADER_SIZE + 2 * BYTES_IN_STACKSLOT;
  int spillOffsetVM=frameSize + STACKFRAME_HEADER_SIZE;
  VM_TypeReference[] types=method.getParameterTypes();
  int numArguments=types.length;
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIRefsField.getOffset(),S0);
  asm.emitLInt(KLUDGE_TI_REG,VM_Entrypoints.JNIRefsTopField.getOffset(),S0);
  asm.emitADD(KLUDGE_TI_REG,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  asm.emitLInt(S1,VM_Entrypoints.JNIRefsSavedFPField.getOffset(),S0);
  asm.emitSTWU(S1,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
  asm.emitSUBFC(S1,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  asm.emitSTW(S1,VM_Entrypoints.JNIRefsSavedFPField.getOffset(),S0);
  nextAIXArgFloatReg=FIRST_OS_PARAMETER_FPR;
  nextVMArgFloatReg=FIRST_VOLATILE_FPR;
  nextAIXArgReg=FIRST_OS_PARAMETER_GPR + 2;
  if (method.isStatic()) {
    nextVMArgReg=FIRST_VOLATILE_GPR;
  }
 else {
    nextVMArgReg=FIRST_VOLATILE_GPR + 1;
  }
  if (VM.VerifyAssertions)   VM._assert(FIRST_OS_PARAMETER_FPR == FIRST_VOLATILE_FPR);
  if (VM.VerifyAssertions)   VM._assert(LAST_OS_PARAMETER_FPR <= LAST_VOLATILE_FPR);
  if (VM.VerifyAssertions)   VM._assert(FIRST_OS_PARAMETER_GPR == FIRST_VOLATILE_GPR);
  if (VM.VerifyAssertions)   VM._assert(LAST_OS_PARAMETER_GPR <= LAST_VOLATILE_GPR);
  VM_Assembler[] asmForArgs=new VM_Assembler[numArguments];
  for (int arg=0; arg < numArguments; arg++) {
    boolean mustSaveFloatToSpill;
    asmForArgs[arg]=new VM_Assembler(0);
    VM_Assembler asmArg=asmForArgs[arg];
    if (types[arg].isFloatType()) {
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        nextAIXArgReg++;
        mustSaveFloatToSpill=false;
      }
 else {
        mustSaveFloatToSpill=true;
      }
      if (nextVMArgFloatReg <= LAST_OS_PARAMETER_FPR) {
        if (mustSaveFloatToSpill) {
          asmArg.emitSTFS(nextVMArgFloatReg,spillOffsetAIX,FP);
        }
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        nextAIXArgFloatReg++;
        nextVMArgFloatReg++;
      }
 else       if (nextVMArgFloatReg <= LAST_VOLATILE_FPR) {
        asmArg.emitSTFS(nextVMArgFloatReg,spillOffsetAIX,FP);
        nextVMArgFloatReg++;
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
 else {
        spillOffsetVM+=BYTES_IN_STACKSLOT;
        asmArg.emitLFS(FIRST_SCRATCH_FPR,spillOffsetVM - BYTES_IN_FLOAT,FP);
        asmArg.emitSTFS(FIRST_SCRATCH_FPR,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
    }
 else     if (types[arg].isDoubleType()) {
      if (VM.BuildFor64Addr) {
        if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
          nextAIXArgReg++;
          mustSaveFloatToSpill=false;
        }
 else {
          mustSaveFloatToSpill=true;
        }
      }
 else {
        if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR - 1) {
          nextAIXArgReg+=2;
          mustSaveFloatToSpill=false;
        }
 else {
          if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR)           nextAIXArgReg++;
          mustSaveFloatToSpill=true;
        }
      }
      if (nextVMArgFloatReg <= LAST_OS_PARAMETER_FPR) {
        if (mustSaveFloatToSpill) {
          asmArg.emitSTFD(nextVMArgFloatReg,spillOffsetAIX,FP);
        }
        spillOffsetAIX+=BYTES_IN_DOUBLE;
        nextAIXArgFloatReg++;
        nextVMArgFloatReg++;
      }
 else       if (nextVMArgFloatReg <= LAST_VOLATILE_FPR) {
        asmArg.emitSTFD(nextVMArgFloatReg,spillOffsetAIX,FP);
        nextVMArgFloatReg++;
        spillOffsetAIX+=BYTES_IN_DOUBLE;
      }
 else {
        asmArg.emitLFD(FIRST_SCRATCH_FPR,spillOffsetVM,FP);
        asmArg.emitSTFD(FIRST_SCRATCH_FPR,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_DOUBLE;
        spillOffsetVM+=BYTES_IN_DOUBLE;
      }
    }
 else     if (VM.BuildFor32Addr && types[arg].isLongType()) {
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR - 1) {
        asmArg.emitMR(nextAIXArgReg + 1,nextVMArgReg + 1);
        asmArg.emitMR(nextAIXArgReg,nextVMArgReg);
        nextAIXArgReg+=2;
        nextVMArgReg+=2;
        spillOffsetAIX+=2 * BYTES_IN_STACKSLOT;
      }
 else       if (nextAIXArgReg == LAST_OS_PARAMETER_GPR && nextVMArgReg <= LAST_VOLATILE_GPR - 1) {
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        asmArg.emitSTW(nextVMArgReg + 1,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        asmArg.emitMR(nextAIXArgReg,nextVMArgReg);
        nextAIXArgReg+=2;
        nextVMArgReg+=2;
      }
 else       if (nextAIXArgReg > LAST_OS_PARAMETER_GPR && nextVMArgReg <= LAST_VOLATILE_GPR - 1) {
        asmArg.emitSTW(nextVMArgReg++,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        asmArg.emitSTW(nextVMArgReg++,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
 else       if (nextVMArgReg == LAST_VOLATILE_GPR) {
        asmArg.emitSTW(nextVMArgReg++,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        asmArg.emitLWZ(REGISTER_ZERO,spillOffsetVM,FP);
        asmArg.emitSTW(REGISTER_ZERO,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        spillOffsetVM+=BYTES_IN_STACKSLOT;
      }
 else {
        asmArg.emitLFD(FIRST_SCRATCH_FPR,spillOffsetVM,FP);
        asmArg.emitSTFD(FIRST_SCRATCH_FPR,spillOffsetAIX,FP);
        spillOffsetAIX+=2 * BYTES_IN_STACKSLOT;
        spillOffsetVM+=2 * BYTES_IN_STACKSLOT;
      }
    }
 else     if (types[arg].isReferenceType()) {
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        asmArg.emitSTAddrU(nextVMArgReg++,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
        asmArg.emitSUBFC(nextAIXArgReg++,PROCESSOR_REGISTER,KLUDGE_TI_REG);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
 else       if (nextVMArgReg <= LAST_VOLATILE_GPR) {
        asmArg.emitSTAddrU(nextVMArgReg++,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
        asmArg.emitSUBFC(REGISTER_ZERO,PROCESSOR_REGISTER,KLUDGE_TI_REG);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
 else {
        asmArg.emitLAddr(REGISTER_ZERO,spillOffsetVM,FP);
        asmArg.emitSTAddrU(REGISTER_ZERO,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
        asmArg.emitSUBFC(REGISTER_ZERO,PROCESSOR_REGISTER,KLUDGE_TI_REG);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        spillOffsetVM+=BYTES_IN_STACKSLOT;
      }
    }
 else {
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        asmArg.emitMR(nextAIXArgReg++,nextVMArgReg++);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
 else       if (nextVMArgReg <= LAST_VOLATILE_GPR) {
        asmArg.emitSTAddr(nextVMArgReg++,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
      }
 else {
        asmArg.emitLAddr(REGISTER_ZERO,spillOffsetVM,FP);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX,FP);
        spillOffsetAIX+=BYTES_IN_STACKSLOT;
        spillOffsetVM+=BYTES_IN_STACKSLOT;
      }
    }
  }
  for (int arg=numArguments - 1; arg >= 0; arg--) {
    VM_MachineCode codeForArg=asmForArgs[arg].makeMachineCode();
    asm.appendInstructions(codeForArg.getInstructions());
  }
  if (method.isStatic()) {
    klass.getClassForType();
    asm.emitLAddrToc(4,klass.getTibOffset());
    asm.emitLAddr(4,0,4);
    asm.emitLAddr(4,VM_Entrypoints.classForTypeField.getOffset(),4);
    asm.emitSTAddrU(4,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
    asm.emitSUBFC(4,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  }
 else {
    asm.emitSTAddrU(3,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
    asm.emitSUBFC(4,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  }
  asm.emitSUBFC(KLUDGE_TI_REG,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  asm.emitSTW(KLUDGE_TI_REG,VM_Entrypoints.JNIRefsTopField.getOffset(),S0);
}","private static void storeParametersForAIX(VM_Assembler asm,int frameSize,VM_Method method,VM_Class klass){
  int nextAIXArgReg, nextAIXArgFloatReg, nextVMArgReg, nextVMArgFloatReg;
  int spillOffsetAIX=NATIVE_FRAME_HEADER_SIZE + 2 * BYTES_IN_STACKSLOT;
  int spillOffsetVM=frameSize + STACKFRAME_HEADER_SIZE;
  VM_TypeReference[] types=method.getParameterTypes();
  int numArguments=types.length;
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIRefsField.getOffset(),S0);
  asm.emitLInt(KLUDGE_TI_REG,VM_Entrypoints.JNIRefsTopField.getOffset(),S0);
  asm.emitADD(KLUDGE_TI_REG,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  asm.emitLInt(S1,VM_Entrypoints.JNIRefsSavedFPField.getOffset(),S0);
  asm.emitSTWU(S1,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
  asm.emitSUBFC(S1,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  asm.emitSTW(S1,VM_Entrypoints.JNIRefsSavedFPField.getOffset(),S0);
  nextAIXArgFloatReg=FIRST_OS_PARAMETER_FPR;
  nextVMArgFloatReg=FIRST_VOLATILE_FPR;
  nextAIXArgReg=FIRST_OS_PARAMETER_GPR + 2;
  if (method.isStatic()) {
    nextVMArgReg=FIRST_VOLATILE_GPR;
  }
 else {
    nextVMArgReg=FIRST_VOLATILE_GPR + 1;
  }
  if (VM.VerifyAssertions)   VM._assert(FIRST_OS_PARAMETER_FPR == FIRST_VOLATILE_FPR);
  if (VM.VerifyAssertions)   VM._assert(LAST_OS_PARAMETER_FPR <= LAST_VOLATILE_FPR);
  if (VM.VerifyAssertions)   VM._assert(FIRST_OS_PARAMETER_GPR == FIRST_VOLATILE_GPR);
  if (VM.VerifyAssertions)   VM._assert(LAST_OS_PARAMETER_GPR <= LAST_VOLATILE_GPR);
  VM_Assembler[] asmForArgs=new VM_Assembler[numArguments];
  for (int arg=0; arg < numArguments; arg++) {
    boolean mustSaveFloatToSpill;
    asmForArgs[arg]=new VM_Assembler(0);
    VM_Assembler asmArg=asmForArgs[arg];
    if (types[arg].isFloatType()) {
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        nextAIXArgReg++;
        mustSaveFloatToSpill=false;
      }
 else {
        mustSaveFloatToSpill=true;
      }
      spillOffsetAIX+=BYTES_IN_STACKSLOT;
      if (nextVMArgFloatReg <= LAST_OS_PARAMETER_FPR) {
        if (mustSaveFloatToSpill) {
          asmArg.emitSTFS(nextVMArgFloatReg,spillOffsetAIX - BYTES_IN_FLOAT,FP);
        }
        nextAIXArgFloatReg++;
        nextVMArgFloatReg++;
      }
 else       if (nextVMArgFloatReg <= LAST_VOLATILE_FPR) {
        asmArg.emitSTFS(nextVMArgFloatReg,spillOffsetAIX - BYTES_IN_FLOAT,FP);
        nextVMArgFloatReg++;
      }
 else {
        spillOffsetVM+=BYTES_IN_STACKSLOT;
        asmArg.emitLFS(FIRST_SCRATCH_FPR,spillOffsetVM - BYTES_IN_FLOAT,FP);
        asmArg.emitSTFS(FIRST_SCRATCH_FPR,spillOffsetAIX - BYTES_IN_FLOAT,FP);
      }
    }
 else     if (types[arg].isDoubleType()) {
      if (VM.BuildFor64Addr) {
        if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
          nextAIXArgReg++;
          mustSaveFloatToSpill=false;
        }
 else {
          mustSaveFloatToSpill=true;
        }
      }
 else {
        if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR - 1) {
          nextAIXArgReg+=2;
          mustSaveFloatToSpill=false;
        }
 else {
          if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR)           nextAIXArgReg++;
          mustSaveFloatToSpill=true;
        }
      }
      spillOffsetAIX+=BYTES_IN_DOUBLE;
      if (nextVMArgFloatReg <= LAST_OS_PARAMETER_FPR) {
        if (mustSaveFloatToSpill) {
          asmArg.emitSTFD(nextVMArgFloatReg,spillOffsetAIX - BYTES_IN_DOUBLE,FP);
        }
        nextAIXArgFloatReg++;
        nextVMArgFloatReg++;
      }
 else       if (nextVMArgFloatReg <= LAST_VOLATILE_FPR) {
        asmArg.emitSTFD(nextVMArgFloatReg,spillOffsetAIX - BYTES_IN_DOUBLE,FP);
        nextVMArgFloatReg++;
      }
 else {
        spillOffsetVM+=BYTES_IN_DOUBLE;
        asmArg.emitLFD(FIRST_SCRATCH_FPR,spillOffsetVM - BYTES_IN_DOUBLE,FP);
        asmArg.emitSTFD(FIRST_SCRATCH_FPR,spillOffsetAIX - BYTES_IN_DOUBLE,FP);
      }
    }
 else     if (VM.BuildFor32Addr && types[arg].isLongType()) {
      spillOffsetAIX+=BYTES_IN_LONG;
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR - 1) {
        asmArg.emitMR(nextAIXArgReg + 1,nextVMArgReg + 1);
        asmArg.emitMR(nextAIXArgReg,nextVMArgReg);
        nextAIXArgReg+=2;
        nextVMArgReg+=2;
      }
 else       if (nextAIXArgReg == LAST_OS_PARAMETER_GPR && nextVMArgReg <= LAST_VOLATILE_GPR - 1) {
        asmArg.emitSTW(nextVMArgReg + 1,spillOffsetAIX - BYTES_IN_STACKSLOT,FP);
        asmArg.emitMR(nextAIXArgReg,nextVMArgReg);
        nextAIXArgReg+=2;
        nextVMArgReg+=2;
      }
 else       if (nextAIXArgReg > LAST_OS_PARAMETER_GPR && nextVMArgReg <= LAST_VOLATILE_GPR - 1) {
        asmArg.emitSTW(nextVMArgReg++,spillOffsetAIX - 2 * BYTES_IN_STACKSLOT,FP);
        asmArg.emitSTW(nextVMArgReg++,spillOffsetAIX - BYTES_IN_STACKSLOT,FP);
      }
 else       if (nextVMArgReg == LAST_VOLATILE_GPR) {
        spillOffsetVM+=BYTES_IN_STACKSLOT;
        asmArg.emitSTW(nextVMArgReg++,spillOffsetAIX - 2 * BYTES_IN_STACKSLOT,FP);
        asmArg.emitLWZ(REGISTER_ZERO,spillOffsetVM - BYTES_IN_STACKSLOT,FP);
        asmArg.emitSTW(REGISTER_ZERO,spillOffsetAIX - BYTES_IN_STACKSLOT,FP);
      }
 else {
        spillOffsetVM+=BYTES_IN_LONG;
        asmArg.emitLFD(FIRST_SCRATCH_FPR,spillOffsetVM - BYTES_IN_LONG,FP);
        asmArg.emitSTFD(FIRST_SCRATCH_FPR,spillOffsetAIX - BYTES_IN_LONG,FP);
      }
    }
 else     if (VM.BuildFor64Addr && types[arg].isLongType()) {
      spillOffsetAIX+=BYTES_IN_LONG;
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        asmArg.emitMR(nextAIXArgReg++,nextVMArgReg++);
      }
 else       if (nextVMArgReg <= LAST_VOLATILE_GPR) {
        asmArg.emitSTAddr(nextVMArgReg++,spillOffsetAIX - BYTES_IN_LONG,FP);
      }
 else {
        spillOffsetVM+=BYTES_IN_LONG;
        asmArg.emitLAddr(REGISTER_ZERO,spillOffsetVM - BYTES_IN_LONG,FP);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX - BYTES_IN_LONG,FP);
      }
    }
 else     if (types[arg].isReferenceType()) {
      spillOffsetAIX+=BYTES_IN_ADDRESS;
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        asmArg.emitSTAddrU(nextVMArgReg++,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
        asmArg.emitSUBFC(nextAIXArgReg++,PROCESSOR_REGISTER,KLUDGE_TI_REG);
      }
 else       if (nextVMArgReg <= LAST_VOLATILE_GPR) {
        asmArg.emitSTAddrU(nextVMArgReg++,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
        asmArg.emitSUBFC(REGISTER_ZERO,PROCESSOR_REGISTER,KLUDGE_TI_REG);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX - BYTES_IN_ADDRESS,FP);
      }
 else {
        spillOffsetVM+=BYTES_IN_STACKSLOT;
        asmArg.emitLAddr(REGISTER_ZERO,spillOffsetVM - BYTES_IN_ADDRESS,FP);
        asmArg.emitSTAddrU(REGISTER_ZERO,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
        asmArg.emitSUBFC(REGISTER_ZERO,PROCESSOR_REGISTER,KLUDGE_TI_REG);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX - BYTES_IN_ADDRESS,FP);
      }
    }
 else {
      spillOffsetAIX+=BYTES_IN_STACKSLOT;
      if (nextAIXArgReg <= LAST_OS_PARAMETER_GPR) {
        asmArg.emitMR(nextAIXArgReg++,nextVMArgReg++);
      }
 else       if (nextVMArgReg <= LAST_VOLATILE_GPR) {
        asmArg.emitSTAddr(nextVMArgReg++,spillOffsetAIX - BYTES_IN_ADDRESS,FP);
      }
 else {
        spillOffsetVM+=BYTES_IN_STACKSLOT;
        asmArg.emitLInt(REGISTER_ZERO,spillOffsetVM - BYTES_IN_INT,FP);
        asmArg.emitSTAddr(REGISTER_ZERO,spillOffsetAIX - BYTES_IN_ADDRESS,FP);
      }
    }
  }
  for (int arg=numArguments - 1; arg >= 0; arg--) {
    VM_MachineCode codeForArg=asmForArgs[arg].makeMachineCode();
    asm.appendInstructions(codeForArg.getInstructions());
  }
  if (method.isStatic()) {
    klass.getClassForType();
    asm.emitLAddrToc(4,klass.getTibOffset());
    asm.emitLAddr(4,0,4);
    asm.emitLAddr(4,VM_Entrypoints.classForTypeField.getOffset(),4);
    asm.emitSTAddrU(4,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
    asm.emitSUBFC(4,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  }
 else {
    asm.emitSTAddrU(3,BYTES_IN_ADDRESS,KLUDGE_TI_REG);
    asm.emitSUBFC(4,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  }
  asm.emitSUBFC(KLUDGE_TI_REG,PROCESSOR_REGISTER,KLUDGE_TI_REG);
  asm.emitSTW(KLUDGE_TI_REG,VM_Entrypoints.JNIRefsTopField.getOffset(),S0);
}",0.3675559489189531
150276,"/** 
 * Repackage the arguments passed as an array of jvalue into an array of Object, used by the JNI functions CallStatic<type>MethodA
 * @param mth the target VM_Method
 * @param argAddress an address into the C space for the array of jvalue unions;  each element is 2-word and holds the argument of the appropriate type
 * @return an Object array holding the arguments wrapped at Objects
 */
static Object[] packageParameterFromJValue(VM_Method targetMethod,VM_Address argAddress){
  VM_TypeReference[] argTypes=targetMethod.getParameterTypes();
  int argCount=argTypes.length;
  Object[] argObjectArray=new Object[argCount];
  VM_JNIEnvironment env=VM_Thread.getCurrentThread().getJNIEnv();
  for (int i=0; i < argCount; i++) {
    VM_Address addr=argAddress.add(BYTES_IN_DOUBLE * i);
    VM_Word hiword=VM_Magic.getMemoryWord(addr);
    VM_Word loword;
    if (VM.BuildFor32Addr) {
      loword=VM_Magic.getMemoryWord(addr.add(BYTES_IN_ADDRESS));
    }
    if (argTypes[i].isFloatType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapFloat(Float.intBitsToFloat(hiword.toInt()));
      }
 else {
        VM._assert(false);
      }
    }
 else     if (argTypes[i].isDoubleType()) {
      if (VM.BuildFor32Addr) {
        long doubleBits=(((long)hiword.toInt()) << BITS_IN_INT) | (loword.toInt() & 0xFFFFFFFFL);
        argObjectArray[i]=VM_Reflection.wrapDouble(Double.longBitsToDouble(doubleBits));
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapDouble(Double.longBitsToDouble(hiword.toLong()));
      }
    }
 else     if (argTypes[i].isLongType()) {
      if (VM.BuildFor32Addr) {
        long longValue=(((long)hiword.toInt()) << BITS_IN_INT) | (loword.toInt() & 0xFFFFFFFFL);
        argObjectArray[i]=VM_Reflection.wrapLong(longValue);
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapLong(hiword.toLong());
      }
    }
 else     if (argTypes[i].isBooleanType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapBoolean((hiword.toInt() & 0xFF000000) >>> 24);
      }
 else {
        VM._assert(false);
      }
    }
 else     if (argTypes[i].isByteType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapByte((byte)((hiword.toInt() & 0xFF000000) >>> 24));
      }
 else {
        VM._assert(false);
      }
    }
 else     if (argTypes[i].isCharType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapChar((char)((hiword.toInt() & 0xFFFF0000) >>> 16));
      }
 else {
        VM._assert(false);
      }
    }
 else     if (argTypes[i].isShortType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapShort((short)((hiword.toInt() & 0xFFFF0000) >>> 16));
      }
 else {
        VM._assert(false);
      }
    }
 else     if (argTypes[i].isReferenceType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=env.getJNIRef(hiword.toInt());
      }
 else {
        VM._assert(false);
      }
    }
 else     if (argTypes[i].isIntType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapInt(hiword.toInt());
      }
 else {
        VM._assert(false);
      }
    }
 else {
      return null;
    }
  }
  return argObjectArray;
}","/** 
 * Repackage the arguments passed as an array of jvalue into an array of Object, used by the JNI functions CallStatic<type>MethodA
 * @param mth the target VM_Method
 * @param argAddress an address into the C space for the array of jvalue unions;  each element is 2-word and holds the argument of the appropriate type
 * @return an Object array holding the arguments wrapped at Objects
 */
static Object[] packageParameterFromJValue(VM_Method targetMethod,VM_Address argAddress){
  VM_TypeReference[] argTypes=targetMethod.getParameterTypes();
  int argCount=argTypes.length;
  Object[] argObjectArray=new Object[argCount];
  VM_JNIEnvironment env=VM_Thread.getCurrentThread().getJNIEnv();
  for (int i=0; i < argCount; i++) {
    VM_Address addr=argAddress.add(BYTES_IN_DOUBLE * i);
    VM_Word hiword=VM_Magic.getMemoryWord(addr);
    VM_Word loword;
    if (VM.BuildFor32Addr) {
      loword=VM_Magic.getMemoryWord(addr.add(BYTES_IN_ADDRESS));
    }
    if (argTypes[i].isFloatType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapFloat(Float.intBitsToFloat(hiword.toInt()));
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapFloat(Float.intBitsToFloat((int)((hiword.toLong() & 0xFFFFFFFF00000000L) >>> 32)));
      }
    }
 else     if (argTypes[i].isDoubleType()) {
      if (VM.BuildFor32Addr) {
        long doubleBits=(((long)hiword.toInt()) << BITS_IN_INT) | (loword.toInt() & 0xFFFFFFFFL);
        argObjectArray[i]=VM_Reflection.wrapDouble(Double.longBitsToDouble(doubleBits));
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapDouble(Double.longBitsToDouble(hiword.toLong()));
      }
    }
 else     if (argTypes[i].isLongType()) {
      if (VM.BuildFor32Addr) {
        long longValue=(((long)hiword.toInt()) << BITS_IN_INT) | (loword.toInt() & 0xFFFFFFFFL);
        argObjectArray[i]=VM_Reflection.wrapLong(longValue);
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapLong(hiword.toLong());
      }
    }
 else     if (argTypes[i].isBooleanType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapBoolean((hiword.toInt() & 0xFF000000) >>> 24);
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapBoolean((int)((hiword.toLong() & 0xFF00000000000000L) >>> 56));
      }
    }
 else     if (argTypes[i].isByteType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapByte((byte)((hiword.toInt() & 0xFF000000) >>> 24));
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapByte((byte)((hiword.toLong() & 0xFF00000000000000L) >>> 56));
      }
    }
 else     if (argTypes[i].isCharType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapChar((char)((hiword.toInt() & 0xFFFF0000) >>> 16));
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapChar((char)((hiword.toLong() & 0xFFFF000000000000L) >>> 48));
      }
    }
 else     if (argTypes[i].isShortType()) {
      if (VM.BuildFor32Addr) {
        argObjectArray[i]=VM_Reflection.wrapShort((short)((hiword.toInt() & 0xFFFF0000) >>> 16));
      }
 else {
        argObjectArray[i]=VM_Reflection.wrapShort((short)((hiword.toLong() & 0xFFFF000000000000L) >>> 48));
      }
    }
 else     if (argTypes[i].isReferenceType()) {
      argObjectArray[i]=env.getJNIRef(hiword.toInt());
    }
 else     if (argTypes[i].isIntType()) {
      argObjectArray[i]=VM_Reflection.wrapInt(hiword.toInt());
    }
 else {
      return null;
    }
  }
  return argObjectArray;
}",0.8706371602554582
150277,"/** 
 * Emit code to do the C to Java transition:  JNI methods in VM_JNIFunctions.java
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_Method mth){
  int offset;
  asm.emitSTAddrU(FP,-JNI_GLUE_FRAME_SIZE,FP);
  String mthName=mth.getName().toString();
  if ((mthName.startsWith(""String_Node_Str"") && mthName.endsWith(""String_Node_Str"")) || mthName.equals(""String_Node_Str"")) {
    offset=STACKFRAME_HEADER_SIZE + 3 * BYTES_IN_STACKSLOT;
    for (int i=6; i <= 10; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=1; i <= 3; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_PARAMETER_FPR; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
  }
 else {
    convertParameterFromSVR4ToJava(asm,mth);
  }
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_OS_NONVOLATILE_GPR; i < FIRST_NONVOLATILE_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitLVAL(S0,INVISIBLE_METHOD_ID);
  asm.emitMFLR(REGISTER_ZERO);
  asm.emitSTW(S0,STACKFRAME_METHOD_ID_OFFSET,FP);
  asm.emitSTAddr(REGISTER_ZERO,JNI_GLUE_FRAME_SIZE + STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitADDI(T0,-VM_Entrypoints.JNIExternalFunctionsField.getOffset(),T0);
  int retryLoop=asm.getMachineCodeIndex();
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T0);
  asm.emitLAddr(JTOC,VM_Entrypoints.JNIEnvSavedJTOCField.getOffset(),T0);
  asm.emitLVAL(S1,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitLWARX(S0,S1,PROCESSOR_REGISTER);
  asm.emitCMPI(S0,VM_Processor.BLOCKED_IN_NATIVE);
  VM_ForwardReference frBlocked=asm.emitForwardBC(EQ);
  asm.emitLVAL(S0,VM_Processor.IN_JAVA);
  asm.emitSTWCXr(S0,S1,PROCESSOR_REGISTER);
  asm.emitBC(NE,retryLoop);
  VM_ForwardReference frInJava=asm.emitForwardB();
  frBlocked.resolve(asm);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLAddr(S1,VM_Entrypoints.the_boot_recordField.getOffset(),JTOC);
  asm.emitMR(PROCESSOR_REGISTER,JTOC);
  asm.emitLAddr(JTOC,VM_Entrypoints.sysTOCField.getOffset(),S1);
  asm.emitLAddr(KLUDGE_TI_REG,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset(),S1);
  asm.emitMTLR(KLUDGE_TI_REG);
  asm.emitBCLRL();
  asm.emitMR(JTOC,PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitB(retryLoop);
  frInJava.resolve(asm);
  asm.emitLAddr(S0,VM_Entrypoints.JNITopJavaFPField.getOffset(),T0);
  asm.emitSUBFC(S0,FP,S0);
  asm.emitSTW(S0,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  VM_ForwardReference frNormalPrologue=asm.emitForwardBL();
  asm.emitLAddr(T2,VM_Entrypoints.activeThreadField.getOffset(),PROCESSOR_REGISTER);
  asm.emitLAddr(T2,VM_Entrypoints.jniEnvField.getOffset(),T2);
  asm.emitLInt(T3,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  asm.emitADD(T3,FP,T3);
  asm.emitSTAddr(T3,VM_Entrypoints.JNITopJavaFPField.getOffset(),T2);
  asm.emitCMPAddrI(T3,VM_Constants.STACKFRAME_SENTINEL_FP.toInt());
  VM_ForwardReference fr4=asm.emitForwardBC(EQ);
  asm.emitLAddr(S0,0,T3);
  fr4.resolve(asm);
  asm.emitSTAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T2);
  asm.emitLVAL(S0,VM_Processor.IN_NATIVE);
  asm.emitSTW(S0,VM_Entrypoints.vpStatusField.getOffset(),PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_OS_NONVOLATILE_GPR; i < FIRST_NONVOLATILE_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitADDI(FP,JNI_GLUE_FRAME_SIZE,FP);
  asm.emitLAddr(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitMTLR(T2);
  asm.emitBCLR();
  frNormalPrologue.resolve(asm);
}","/** 
 * Emit code to do the C to Java transition:  JNI methods in VM_JNIFunctions.java
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_Method mth){
  int offset;
  asm.emitSTAddrU(FP,-JNI_GLUE_FRAME_SIZE,FP);
  String mthName=mth.getName().toString();
  if ((mthName.startsWith(""String_Node_Str"") && mthName.endsWith(""String_Node_Str"")) || mthName.equals(""String_Node_Str"")) {
    offset=STACKFRAME_HEADER_SIZE + 3 * BYTES_IN_STACKSLOT;
    for (int i=6; i <= 10; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=1; i <= 3; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_PARAMETER_FPR; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
  }
 else {
    convertParameterFromSVR4ToJava(asm,mth);
  }
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_RVM_RESERVED_NV_GPR; i <= LAST_RVM_RESERVED_NV_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitLVAL(S0,INVISIBLE_METHOD_ID);
  asm.emitMFLR(REGISTER_ZERO);
  asm.emitSTW(S0,STACKFRAME_METHOD_ID_OFFSET,FP);
  asm.emitSTAddr(REGISTER_ZERO,JNI_GLUE_FRAME_SIZE + STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitADDI(T0,-VM_Entrypoints.JNIExternalFunctionsField.getOffset(),T0);
  int retryLoop=asm.getMachineCodeIndex();
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T0);
  asm.emitLAddr(JTOC,VM_Entrypoints.JNIEnvSavedJTOCField.getOffset(),T0);
  asm.emitLVAL(S1,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitLWARX(S0,S1,PROCESSOR_REGISTER);
  asm.emitCMPI(S0,VM_Processor.BLOCKED_IN_NATIVE);
  VM_ForwardReference frBlocked=asm.emitForwardBC(EQ);
  asm.emitLVAL(S0,VM_Processor.IN_JAVA);
  asm.emitSTWCXr(S0,S1,PROCESSOR_REGISTER);
  asm.emitBC(NE,retryLoop);
  VM_ForwardReference frInJava=asm.emitForwardB();
  frBlocked.resolve(asm);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLAddr(S1,VM_Entrypoints.the_boot_recordField.getOffset(),JTOC);
  asm.emitMR(PROCESSOR_REGISTER,JTOC);
  asm.emitLAddr(JTOC,VM_Entrypoints.sysTOCField.getOffset(),S1);
  asm.emitLAddr(KLUDGE_TI_REG,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset(),S1);
  asm.emitMTLR(KLUDGE_TI_REG);
  asm.emitBCLRL();
  asm.emitMR(JTOC,PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitB(retryLoop);
  frInJava.resolve(asm);
  asm.emitLAddr(S0,VM_Entrypoints.JNITopJavaFPField.getOffset(),T0);
  asm.emitSUBFC(S0,FP,S0);
  asm.emitSTW(S0,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  VM_ForwardReference frNormalPrologue=asm.emitForwardBL();
  asm.emitLAddr(T2,VM_Entrypoints.activeThreadField.getOffset(),PROCESSOR_REGISTER);
  asm.emitLAddr(T2,VM_Entrypoints.jniEnvField.getOffset(),T2);
  asm.emitLInt(T3,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  asm.emitADD(T3,FP,T3);
  asm.emitSTAddr(T3,VM_Entrypoints.JNITopJavaFPField.getOffset(),T2);
  asm.emitCMPAddrI(T3,VM_Constants.STACKFRAME_SENTINEL_FP.toInt());
  VM_ForwardReference fr4=asm.emitForwardBC(EQ);
  asm.emitLAddr(S0,0,T3);
  fr4.resolve(asm);
  asm.emitSTAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T2);
  asm.emitLVAL(S0,VM_Processor.IN_NATIVE);
  asm.emitSTW(S0,VM_Entrypoints.vpStatusField.getOffset(),PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_RVM_RESERVED_NV_GPR; i <= LAST_RVM_RESERVED_NV_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  asm.emitADDI(FP,JNI_GLUE_FRAME_SIZE,FP);
  asm.emitLAddr(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitMTLR(T2);
  asm.emitBCLR();
  frNormalPrologue.resolve(asm);
}",0.984639358860196
150278,"/** 
 * Prepare for a collection.
 */
protected final void prepare(){
  long start=VM_Interface.cycles();
  int order=VM_Interface.rendezvous(4230);
  if (order == 1) {
    setGcStatus(GC_PREPARE);
    baseGlobalPrepare(start);
  }
  VM_Interface.rendezvous(4240);
  if (order == 1)   for (int i=0; i < planCount; i++) {
    Plan p=plans[i];
    if (VM_Interface.isNonParticipating(p))     p.baseThreadLocalPrepare(NON_PARTICIPANT);
  }
  baseThreadLocalPrepare(order);
  if (order == 1) {
    VM_Interface.resetThreadCounter();
    setGcStatus(GC_PROPER);
  }
  VM_Interface.rendezvous(4250);
  if (Plan.MOVES_OBJECTS) {
    VM_Interface.preCopyGCInstances();
    VM_Interface.rendezvous(4260);
    if (order == 1)     VM_Interface.resetThreadCounter();
    VM_Interface.rendezvous(4270);
  }
}","/** 
 * Prepare for a collection.
 */
protected final void prepare(){
  long start=VM_Interface.cycles();
  int order=VM_Interface.rendezvous(4230);
  if (order == 1) {
    setGcStatus(GC_PREPARE);
    baseGlobalPrepare(start);
  }
  VM_Interface.rendezvous(4240);
  if (order == 1)   for (int i=0; i < planCount; i++) {
    Plan p=plans[i];
    if (VM_Interface.isNonParticipating(p))     p.baseThreadLocalPrepare(NON_PARTICIPANT);
  }
  baseThreadLocalPrepare(order);
  VM_Interface.rendezvous(4250);
  if (Plan.MOVES_OBJECTS) {
    VM_Interface.preCopyGCInstances();
    VM_Interface.rendezvous(4260);
    if (order == 1)     VM_Interface.resetThreadCounter();
    VM_Interface.rendezvous(4270);
  }
}",0.9392928619079386
150279,"/** 
 * Perform a collection. Important notes: . Global actions are executed by only one thread . Thread-local actions are executed by all threads . The following order is guaranteed by BasePlan, with each separated by a synchronization barrier.: 1. globalPrepare() 2. threadLocalPrepare() 3. threadLocalRelease() 4. globalRelease()
 */
public void collect(){
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  boolean designated=(VM_Interface.rendezvous(4210) == 1);
  if (designated)   Statistics.initTime.start();
  prepare();
  if (designated)   Statistics.initTime.stop();
  if (designated)   Statistics.rootTime.start();
  VM_Interface.computeAllRoots(rootLocations,interiorRootLocations);
  if (designated)   Statistics.rootTime.stop();
  if (designated)   Statistics.scanTime.start();
  processAllWork();
  if (designated)   Statistics.scanTime.pause();
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.moveSoftReferencesToReadyList();
    if (designated)     ReferenceProcessor.moveWeakReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (Options.noFinalizer) {
    if (designated)     Finalizer.kill();
  }
 else {
    if (designated)     Statistics.finalizeTime.start();
    if (designated)     Finalizer.moveToFinalizable();
    VM_Interface.rendezvous(4220);
    if (designated)     Statistics.finalizeTime.stop();
  }
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.movePhantomReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (!Options.noReferenceTypes || !Options.noFinalizer) {
    if (designated)     Statistics.scanTime.start();
    processAllWork();
    if (designated)     Statistics.scanTime.stop();
  }
 else {
    if (designated)     Statistics.scanTime.stop();
  }
  if (designated)   Statistics.finishTime.start();
  release();
  if (designated)   Statistics.finishTime.stop();
  if (designated)   printStats();
}","/** 
 * Perform a collection. Important notes: . Global actions are executed by only one thread . Thread-local actions are executed by all threads . The following order is guaranteed by BasePlan, with each separated by a synchronization barrier.: 1. globalPrepare() 2. threadLocalPrepare() 3. threadLocalRelease() 4. globalRelease()
 */
public void collect(){
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  boolean designated=(VM_Interface.rendezvous(4210) == 1);
  if (designated)   Statistics.initTime.start();
  prepare();
  if (designated)   Statistics.initTime.stop();
  if (designated)   Statistics.rootTime.start();
  VM_Interface.computeAllRoots(rootLocations,interiorRootLocations);
  if (designated)   Statistics.rootTime.stop();
  int order=VM_Interface.rendezvous(4900);
  if (order == 1) {
    VM_Interface.resetThreadCounter();
    setGcStatus(GC_PROPER);
  }
  VM_Interface.rendezvous(4901);
  if (designated)   Statistics.scanTime.start();
  processAllWork();
  if (designated)   Statistics.scanTime.pause();
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.moveSoftReferencesToReadyList();
    if (designated)     ReferenceProcessor.moveWeakReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (Options.noFinalizer) {
    if (designated)     Finalizer.kill();
  }
 else {
    if (designated)     Statistics.finalizeTime.start();
    if (designated)     Finalizer.moveToFinalizable();
    VM_Interface.rendezvous(4220);
    if (designated)     Statistics.finalizeTime.stop();
  }
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.movePhantomReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (!Options.noReferenceTypes || !Options.noFinalizer) {
    if (designated)     Statistics.scanTime.start();
    processAllWork();
    if (designated)     Statistics.scanTime.stop();
  }
 else {
    if (designated)     Statistics.scanTime.stop();
  }
  if (designated)   Statistics.finishTime.start();
  release();
  if (designated)   Statistics.finishTime.stop();
  if (designated)   printStats();
}",0.6831257078142695
150280,"/** 
 * Emit code to allocate a scalar object
 * @param method  the method this bytecode is compiled in
 * @param typeRef the VM_Class to instantiate
 */
protected final void emit_resolved_new(VM_Class typeRef){
  int instanceSize=typeRef.getInstanceSize();
  int tibOffset=typeRef.getTibOffset();
  int whichAllocator=MM_Interface.pickAllocator(typeRef);
  int align=VM_ObjectModel.getAlignment(typeRef);
  int offset=VM_ObjectModel.getOffsetForAlignment(typeRef);
  asm.emitPUSH_Imm(instanceSize);
  asm.emitPUSH_RegDisp(JTOC,tibOffset);
  asm.emitPUSH_Imm(typeRef.hasFinalizer() ? 1 : 0);
  asm.emitPUSH_Imm(whichAllocator);
  asm.emitPUSH_Imm(align);
  asm.emitPUSH_Imm(offset);
  genParameterRegisterLoad(6);
  asm.emitCALL_RegDisp(JTOC,VM_Entrypoints.resolvedNewScalarMethod.getOffset());
  asm.emitPUSH_Reg(T0);
}","/** 
 * Emit code to allocate a scalar object
 * @param method  the method this bytecode is compiled in
 * @param typeRef the VM_Class to instantiate
 */
protected final void emit_resolved_new(VM_Class typeRef){
  int instanceSize=typeRef.getInstanceSize();
  int tibOffset=typeRef.getTibOffset();
  int whichAllocator=MM_Interface.pickAllocator(typeRef,method);
  int align=VM_ObjectModel.getAlignment(typeRef);
  int offset=VM_ObjectModel.getOffsetForAlignment(typeRef);
  asm.emitPUSH_Imm(instanceSize);
  asm.emitPUSH_RegDisp(JTOC,tibOffset);
  asm.emitPUSH_Imm(typeRef.hasFinalizer() ? 1 : 0);
  asm.emitPUSH_Imm(whichAllocator);
  asm.emitPUSH_Imm(align);
  asm.emitPUSH_Imm(offset);
  genParameterRegisterLoad(6);
  asm.emitCALL_RegDisp(JTOC,VM_Entrypoints.resolvedNewScalarMethod.getOffset());
  asm.emitPUSH_Reg(T0);
}",0.9957498482088646
150281,"/** 
 * Prepare for a collection.
 */
protected final void prepare(){
  long start=VM_Interface.cycles();
  int order=VM_Interface.rendezvous(4230);
  if (order == 1) {
    setGcStatus(GC_PREPARE);
    baseGlobalPrepare(start);
  }
  VM_Interface.rendezvous(4240);
  if (order == 1)   for (int i=0; i < planCount; i++) {
    Plan p=plans[i];
    if (VM_Interface.isNonParticipating(p))     p.baseThreadLocalPrepare(NON_PARTICIPANT);
  }
  baseThreadLocalPrepare(order);
  if (order == 1) {
    VM_Interface.resetThreadCounter();
    setGcStatus(GC_PROPER);
  }
  VM_Interface.rendezvous(4250);
  if (Plan.MOVES_OBJECTS) {
    VM_Interface.preCopyGCInstances();
    VM_Interface.rendezvous(4260);
    if (order == 1)     VM_Interface.resetThreadCounter();
    VM_Interface.rendezvous(4270);
  }
}","/** 
 * Prepare for a collection.
 */
protected final void prepare(){
  long start=VM_Interface.cycles();
  int order=VM_Interface.rendezvous(4230);
  if (order == 1) {
    setGcStatus(GC_PREPARE);
    baseGlobalPrepare(start);
  }
  VM_Interface.rendezvous(4240);
  if (order == 1)   for (int i=0; i < planCount; i++) {
    Plan p=plans[i];
    if (VM_Interface.isNonParticipating(p))     p.baseThreadLocalPrepare(NON_PARTICIPANT);
  }
  baseThreadLocalPrepare(order);
  VM_Interface.rendezvous(4250);
  if (Plan.MOVES_OBJECTS) {
    VM_Interface.preCopyGCInstances();
    VM_Interface.rendezvous(4260);
    if (order == 1)     VM_Interface.resetThreadCounter();
    VM_Interface.rendezvous(4270);
  }
}",0.9392928619079386
150282,"/** 
 * Perform a collection. Important notes: . Global actions are executed by only one thread . Thread-local actions are executed by all threads . The following order is guaranteed by BasePlan, with each separated by a synchronization barrier.: 1. globalPrepare() 2. threadLocalPrepare() 3. threadLocalRelease() 4. globalRelease()
 */
public void collect(){
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  boolean designated=(VM_Interface.rendezvous(4210) == 1);
  if (designated)   Statistics.initTime.start();
  prepare();
  if (designated)   Statistics.initTime.stop();
  if (designated)   Statistics.rootTime.start();
  VM_Interface.computeAllRoots(rootLocations,interiorRootLocations);
  if (designated)   Statistics.rootTime.stop();
  if (designated)   Statistics.scanTime.start();
  processAllWork();
  if (designated)   Statistics.scanTime.pause();
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.moveSoftReferencesToReadyList();
    if (designated)     ReferenceProcessor.moveWeakReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (Options.noFinalizer) {
    if (designated)     Finalizer.kill();
  }
 else {
    if (designated)     Statistics.finalizeTime.start();
    if (designated)     Finalizer.moveToFinalizable();
    VM_Interface.rendezvous(4220);
    if (designated)     Statistics.finalizeTime.stop();
  }
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.movePhantomReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (!Options.noReferenceTypes || !Options.noFinalizer) {
    if (designated)     Statistics.scanTime.start();
    processAllWork();
    if (designated)     Statistics.scanTime.stop();
  }
 else {
    if (designated)     Statistics.scanTime.stop();
  }
  if (designated)   Statistics.finishTime.start();
  release();
  if (designated)   Statistics.finishTime.stop();
  if (designated)   printStats();
}","/** 
 * Perform a collection. Important notes: . Global actions are executed by only one thread . Thread-local actions are executed by all threads . The following order is guaranteed by BasePlan, with each separated by a synchronization barrier.: 1. globalPrepare() 2. threadLocalPrepare() 3. threadLocalRelease() 4. globalRelease()
 */
public void collect(){
  if (VM_Interface.VerifyAssertions)   VM_Interface._assert(collectionsInitiated > 0);
  boolean designated=(VM_Interface.rendezvous(4210) == 1);
  if (designated)   Statistics.initTime.start();
  prepare();
  if (designated)   Statistics.initTime.stop();
  if (designated)   Statistics.rootTime.start();
  VM_Interface.computeAllRoots(rootLocations,interiorRootLocations);
  if (designated)   Statistics.rootTime.stop();
  int order=VM_Interface.rendezvous(4900);
  if (order == 1) {
    VM_Interface.resetThreadCounter();
    setGcStatus(GC_PROPER);
  }
  VM_Interface.rendezvous(4901);
  if (designated)   Statistics.scanTime.start();
  processAllWork();
  if (designated)   Statistics.scanTime.pause();
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.moveSoftReferencesToReadyList();
    if (designated)     ReferenceProcessor.moveWeakReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (Options.noFinalizer) {
    if (designated)     Finalizer.kill();
  }
 else {
    if (designated)     Statistics.finalizeTime.start();
    if (designated)     Finalizer.moveToFinalizable();
    VM_Interface.rendezvous(4220);
    if (designated)     Statistics.finalizeTime.stop();
  }
  if (!Options.noReferenceTypes) {
    if (designated)     Statistics.refTypeTime.start();
    if (designated)     ReferenceProcessor.movePhantomReferencesToReadyList();
    if (designated)     Statistics.refTypeTime.stop();
  }
  if (!Options.noReferenceTypes || !Options.noFinalizer) {
    if (designated)     Statistics.scanTime.start();
    processAllWork();
    if (designated)     Statistics.scanTime.stop();
  }
 else {
    if (designated)     Statistics.scanTime.stop();
  }
  if (designated)   Statistics.finishTime.start();
  release();
  if (designated)   Statistics.finishTime.stop();
  if (designated)   printStats();
}",0.6831257078142695
150283,"/** 
 * Returns the appropriate allocation scheme/area for the given type and given method requesting the allocation.
 * @param type the type of the object to be allocated
 * @param method the method requesting the allocation
 * @return the identifier of the appropriate allocator
 */
public static int pickAllocator(VM_Type type,VM_Method method) throws VM_PragmaInterruptible {
  if (method != null) {
    VM_Class cls=method.getDeclaringClass();
    byte[] clsBA=cls.getDescriptor().toByteArray();
    if (isPrefix(""String_Node_Str"",clsBA)) {
      return Plan.IMMORTAL_SPACE;
    }
  }
  Type t=type.JMTKtype;
  if (t.initialized)   return t.allocator;
  int allocator=Plan.DEFAULT_SPACE;
  byte[] typeBA=type.getDescriptor().toByteArray();
  if (isPrefix(""String_Node_Str"",typeBA) || isPrefix(""String_Node_Str"",typeBA) || isPrefix(""String_Node_Str"",typeBA))   allocator=Plan.IMMORTAL_SPACE;
  t.initialized=true;
  t.allocator=allocator;
  return allocator;
}","/** 
 * Returns the appropriate allocation scheme/area for the given type and given method requesting the allocation.
 * @param type the type of the object to be allocated
 * @param method the method requesting the allocation
 * @return the identifier of the appropriate allocator
 */
public static int pickAllocator(VM_Type type,VM_Method method) throws VM_PragmaInterruptible {
  if (method != null) {
    VM_Class cls=method.getDeclaringClass();
    byte[] clsBA=cls.getDescriptor().toByteArray();
    if (isPrefix(""String_Node_Str"",clsBA) || isPrefix(""String_Node_Str"",clsBA)) {
      return Plan.IMMORTAL_SPACE;
    }
  }
  Type t=type.JMTKtype;
  if (t.initialized)   return t.allocator;
  int allocator=Plan.DEFAULT_SPACE;
  byte[] typeBA=type.getDescriptor().toByteArray();
  if (isPrefix(""String_Node_Str"",typeBA) || isPrefix(""String_Node_Str"",typeBA) || isPrefix(""String_Node_Str"",typeBA))   allocator=Plan.IMMORTAL_SPACE;
  t.initialized=true;
  t.allocator=allocator;
  return allocator;
}",0.9811704834605598
150284,"/** 
 * Emit code to do the C to Java transition:  JNI methods in VM_JNIFunctions.java
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_Method mth){
  int offset;
  asm.emitSTAddrU(FP,-JNI_GLUE_FRAME_SIZE,FP);
  String mthName=mth.getName().toString();
  if ((mthName.startsWith(""String_Node_Str"") && mthName.endsWith(""String_Node_Str"")) || mthName.equals(""String_Node_Str"")) {
    offset=STACKFRAME_HEADER_SIZE + 3 * BYTES_IN_STACKSLOT;
    for (int i=6; i <= 10; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=1; i <= 3; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_PARAMETER_FPR; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
  }
 else {
    convertParameterFromSVR4ToJava(asm,mth);
  }
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_OS_NONVOLATILE_GPR; i < FIRST_NONVOLATILE_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_NONVOLATILE_FPR; i < FIRST_NONVOLATILE_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLVAL(S0,INVISIBLE_METHOD_ID);
  asm.emitMFLR(0);
  asm.emitSTW(S0,STACKFRAME_METHOD_ID_OFFSET,FP);
  asm.emitSTAddr(0,JNI_GLUE_FRAME_SIZE + STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitADDI(T0,-VM_Entrypoints.JNIExternalFunctionsField.getOffset(),T0);
  int retryLoop=asm.getMachineCodeIndex();
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T0);
  asm.emitLAddr(JTOC,VM_Entrypoints.JNIEnvSavedJTOCField.getOffset(),T0);
  asm.emitLVAL(S1,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitLWARX(S0,S1,PROCESSOR_REGISTER);
  asm.emitCMPI(S0,VM_Processor.BLOCKED_IN_NATIVE);
  VM_ForwardReference frBlocked=asm.emitForwardBC(EQ);
  asm.emitLVAL(S0,VM_Processor.IN_JAVA);
  asm.emitSTWCXr(S0,S1,PROCESSOR_REGISTER);
  asm.emitBC(NE,retryLoop);
  VM_ForwardReference frInJava=asm.emitForwardB();
  frBlocked.resolve(asm);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLAddr(S1,VM_Entrypoints.the_boot_recordField.getOffset(),JTOC);
  asm.emitMR(PROCESSOR_REGISTER,JTOC);
  asm.emitLAddr(JTOC,VM_Entrypoints.sysTOCField.getOffset(),S1);
  asm.emitLAddr(KLUDGE_TI_REG,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset(),S1);
  asm.emitMTLR(KLUDGE_TI_REG);
  asm.emitBCLRL();
  asm.emitMR(JTOC,PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitB(retryLoop);
  frInJava.resolve(asm);
  asm.emitLAddr(S0,VM_Entrypoints.JNITopJavaFPField.getOffset(),T0);
  asm.emitSUBFC(S0,FP,S0);
  asm.emitSTW(S0,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  VM_ForwardReference frNormalPrologue=asm.emitForwardBL();
  asm.emitLAddr(T2,VM_Entrypoints.activeThreadField.getOffset(),PROCESSOR_REGISTER);
  asm.emitLAddr(T2,VM_Entrypoints.jniEnvField.getOffset(),T2);
  asm.emitLInt(T3,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  asm.emitADD(T3,FP,T3);
  asm.emitSTAddr(T3,VM_Entrypoints.JNITopJavaFPField.getOffset(),T2);
  asm.emitCMPAddr(T3,VM_Constants.STACKFRAME_SENTINEL_FP.toInt());
  VM_ForwardReference fr4=asm.emitForwardBC(EQ);
  asm.emitLAddr(S0,0,T3);
  fr4.resolve(asm);
  asm.emitSTAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T2);
  asm.emitLVAL(S0,VM_Processor.IN_NATIVE);
  asm.emitSTW(S0,VM_Entrypoints.vpStatusField.getOffset(),PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_OS_NONVOLATILE_GPR; i < FIRST_NONVOLATILE_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_NONVOLATILE_FPR; i < FIRST_NONVOLATILE_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitADDI(FP,JNI_GLUE_FRAME_SIZE,FP);
  asm.emitLAddr(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitMTLR(T2);
  asm.emitBCLR();
  frNormalPrologue.resolve(asm);
}","/** 
 * Emit code to do the C to Java transition:  JNI methods in VM_JNIFunctions.java
 */
public static void generateGlueCodeForJNIMethod(VM_Assembler asm,VM_Method mth){
  int offset;
  asm.emitSTAddrU(FP,-JNI_GLUE_FRAME_SIZE,FP);
  String mthName=mth.getName().toString();
  if ((mthName.startsWith(""String_Node_Str"") && mthName.endsWith(""String_Node_Str"")) || mthName.equals(""String_Node_Str"")) {
    offset=STACKFRAME_HEADER_SIZE + 3 * BYTES_IN_STACKSLOT;
    for (int i=6; i <= 10; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=1; i <= 3; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
    offset=STACKFRAME_HEADER_SIZE + 0;
    for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
      asm.emitSTAddr(i,offset,FP);
      offset+=BYTES_IN_ADDRESS;
    }
    for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_PARAMETER_FPR; i++) {
      asm.emitSTFD(i,offset,FP);
      offset+=BYTES_IN_DOUBLE;
    }
  }
 else {
    convertParameterFromSVR4ToJava(asm,mth);
  }
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_OS_NONVOLATILE_GPR; i < FIRST_NONVOLATILE_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_NONVOLATILE_FPR; i < FIRST_NONVOLATILE_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLVAL(S0,INVISIBLE_METHOD_ID);
  asm.emitMFLR(0);
  asm.emitSTW(S0,STACKFRAME_METHOD_ID_OFFSET,FP);
  asm.emitSTAddr(0,JNI_GLUE_FRAME_SIZE + STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitADDI(T0,-VM_Entrypoints.JNIExternalFunctionsField.getOffset(),T0);
  int retryLoop=asm.getMachineCodeIndex();
  asm.emitLAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T0);
  asm.emitLAddr(JTOC,VM_Entrypoints.JNIEnvSavedJTOCField.getOffset(),T0);
  asm.emitLVAL(S1,VM_Entrypoints.vpStatusField.getOffset());
  asm.emitLWARX(S0,S1,PROCESSOR_REGISTER);
  asm.emitCMPI(S0,VM_Processor.BLOCKED_IN_NATIVE);
  VM_ForwardReference frBlocked=asm.emitForwardBC(EQ);
  asm.emitLVAL(S0,VM_Processor.IN_JAVA);
  asm.emitSTWCXr(S0,S1,PROCESSOR_REGISTER);
  asm.emitBC(NE,retryLoop);
  VM_ForwardReference frInJava=asm.emitForwardB();
  frBlocked.resolve(asm);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitSTAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitSTFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitLAddr(S1,VM_Entrypoints.the_boot_recordField.getOffset(),JTOC);
  asm.emitMR(PROCESSOR_REGISTER,JTOC);
  asm.emitLAddr(JTOC,VM_Entrypoints.sysTOCField.getOffset(),S1);
  asm.emitLAddr(KLUDGE_TI_REG,VM_Entrypoints.sysVirtualProcessorYieldIPField.getOffset(),S1);
  asm.emitMTLR(KLUDGE_TI_REG);
  asm.emitBCLRL();
  asm.emitMR(JTOC,PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE;
  for (int i=FIRST_OS_PARAMETER_GPR; i <= LAST_OS_PARAMETER_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_PARAMETER_FPR; i <= LAST_OS_VARARG_PARAMETER_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitB(retryLoop);
  frInJava.resolve(asm);
  asm.emitLAddr(S0,VM_Entrypoints.JNITopJavaFPField.getOffset(),T0);
  asm.emitSUBFC(S0,FP,S0);
  asm.emitSTW(S0,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  VM_ForwardReference frNormalPrologue=asm.emitForwardBL();
  asm.emitLAddr(T2,VM_Entrypoints.activeThreadField.getOffset(),PROCESSOR_REGISTER);
  asm.emitLAddr(T2,VM_Entrypoints.jniEnvField.getOffset(),T2);
  asm.emitLInt(T3,JNI_GLUE_FRAME_SIZE + JNI_GLUE_OFFSET_TO_PREV_JFRAME,FP);
  asm.emitADD(T3,FP,T3);
  asm.emitSTAddr(T3,VM_Entrypoints.JNITopJavaFPField.getOffset(),T2);
  asm.emitCMPAddrI(T3,VM_Constants.STACKFRAME_SENTINEL_FP.toInt());
  VM_ForwardReference fr4=asm.emitForwardBC(EQ);
  asm.emitLAddr(S0,0,T3);
  fr4.resolve(asm);
  asm.emitSTAddr(PROCESSOR_REGISTER,VM_Entrypoints.JNIEnvSavedPRField.getOffset(),T2);
  asm.emitLVAL(S0,VM_Processor.IN_NATIVE);
  asm.emitSTW(S0,VM_Entrypoints.vpStatusField.getOffset(),PROCESSOR_REGISTER);
  offset=STACKFRAME_HEADER_SIZE + JNI_GLUE_SAVED_VOL_SIZE;
  for (int i=FIRST_OS_NONVOLATILE_GPR; i < FIRST_NONVOLATILE_GPR; i++) {
    asm.emitLAddr(i,offset,FP);
    offset+=BYTES_IN_ADDRESS;
  }
  for (int i=FIRST_OS_NONVOLATILE_FPR; i < FIRST_NONVOLATILE_FPR; i++) {
    asm.emitLFD(i,offset,FP);
    offset+=BYTES_IN_DOUBLE;
  }
  asm.emitADDI(FP,JNI_GLUE_FRAME_SIZE,FP);
  asm.emitLAddr(T2,STACKFRAME_NEXT_INSTRUCTION_OFFSET,FP);
  asm.emitMTLR(T2);
  asm.emitBCLR();
  frNormalPrologue.resolve(asm);
}",0.9998944145285608
150285,"/** 
 * Reach up two stack frames into a frame that is compiled with the DynamicBridge register protocol and grap  the receiver object of the invoke (ie the first param). NOTE: assumes that caller has disabled GC.
 */
static Object getReceiverObject() throws VM_PragmaNoInline {
  VM_Address callingFrame=VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer());
  callingFrame=VM_Magic.getCallerFramePointer(callingFrame);
  callingFrame=VM_Magic.getCallerFramePointer(callingFrame);
  VM_Address location=callingFrame.sub((LAST_NONVOLATILE_FPR - FIRST_VOLATILE_FPR + 1) * 8 + (LAST_NONVOLATILE_GPR - FIRST_VOLATILE_GPR + 1) * 4);
  return VM_Magic.addressAsObject(VM_Magic.getMemoryAddress(location));
}","/** 
 * Reach up two stack frames into a frame that is compiled with the DynamicBridge register protocol and grap  the receiver object of the invoke (ie the first param). NOTE: assumes that caller has disabled GC.
 */
static Object getReceiverObject() throws VM_PragmaNoInline {
  VM_Address callingFrame=VM_Magic.getCallerFramePointer(VM_Magic.getFramePointer());
  callingFrame=VM_Magic.getCallerFramePointer(callingFrame);
  callingFrame=VM_Magic.getCallerFramePointer(callingFrame);
  VM_Address location=callingFrame.sub((LAST_NONVOLATILE_FPR - FIRST_VOLATILE_FPR + 1) * BYTES_IN_DOUBLE + (LAST_NONVOLATILE_GPR - FIRST_VOLATILE_GPR + 1) * BYTES_IN_ADDRESS);
  return VM_Magic.addressAsObject(VM_Magic.getMemoryAddress(location));
}",0.9771309771309772
150286,"/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC) {
    threadLocalMaturePrepare(count);
    if (Plan.usesLOS)     los.prepare();
    remset.resetLocal();
  }
}","/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC) {
    threadLocalMaturePrepare(count);
    if (Plan.usesLOS)     los.prepare();
    remset.resetLocal();
  }
 else {
    if (count == NON_PARTICIPANT)     flushRememberedSets();
  }
}",0.9366869037294016
150287,"/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>prepare()</code> which will ensure that <i>all threads</i> execute this.<p> After performing generic operations, <code>threadLocalPrepare()</code> is called to perform subclass-specific operations.
 * @param order A unique ordering placed on the threads by thecaller's use of <code>rendezvous</code>.
 */
public final void baseThreadLocalPrepare(int order){
  if (order == NON_PARTICIPANT)   VM_Interface.prepareNonParticipating((Plan)this);
 else {
    VM_Interface.prepareParticipating((Plan)this);
    VM_Interface.rendezvous(4260);
  }
  if (Options.verbose >= 4)   Log.writeln(""String_Node_Str"");
  threadLocalPrepare(order);
}","/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>prepare()</code> which will ensure that <i>all threads</i> execute this.<p> After performing generic operations, <code>threadLocalPrepare()</code> is called to perform subclass-specific operations.
 * @param order A unique ordering placed on the threads by thecaller's use of <code>rendezvous</code>.
 */
public final void baseThreadLocalPrepare(int order){
  if (order == NON_PARTICIPANT) {
    VM_Interface.prepareNonParticipating((Plan)this);
  }
 else {
    VM_Interface.prepareParticipating((Plan)this);
    VM_Interface.rendezvous(4260);
  }
  if (Options.verbose >= 4)   Log.writeln(""String_Node_Str"");
  threadLocalPrepare(order);
}",0.9946808510638298
150288,"/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC) {
    threadLocalMaturePrepare(count);
    if (Plan.usesLOS)     los.prepare();
    remset.resetLocal();
  }
}","/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>BasePlan</code>, which will ensure that <i>all threads</i> execute this.<p> In this case, it means flushing the remsets, rebinding the nursery, and if a full heap collection, preparing the mature space and LOS.
 */
protected final void threadLocalPrepare(int count){
  nursery.rebind(nurseryVM);
  if (fullHeapGC) {
    threadLocalMaturePrepare(count);
    if (Plan.usesLOS)     los.prepare();
    remset.resetLocal();
  }
 else {
    if (count == NON_PARTICIPANT)     flushRememberedSets();
  }
}",0.9366869037294016
150289,"/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>prepare()</code> which will ensure that <i>all threads</i> execute this.<p> After performing generic operations, <code>threadLocalPrepare()</code> is called to perform subclass-specific operations.
 * @param order A unique ordering placed on the threads by thecaller's use of <code>rendezvous</code>.
 */
public final void baseThreadLocalPrepare(int order){
  if (order == NON_PARTICIPANT)   VM_Interface.prepareNonParticipating((Plan)this);
 else {
    VM_Interface.prepareParticipating((Plan)this);
    VM_Interface.rendezvous(4260);
  }
  if (Options.verbose >= 4)   Log.writeln(""String_Node_Str"");
  threadLocalPrepare(order);
}","/** 
 * Perform operations with <i>thread-local</i> scope in preparation for a collection.  This is called by <code>prepare()</code> which will ensure that <i>all threads</i> execute this.<p> After performing generic operations, <code>threadLocalPrepare()</code> is called to perform subclass-specific operations.
 * @param order A unique ordering placed on the threads by thecaller's use of <code>rendezvous</code>.
 */
public final void baseThreadLocalPrepare(int order){
  if (order == NON_PARTICIPANT) {
    VM_Interface.prepareNonParticipating((Plan)this);
  }
 else {
    VM_Interface.prepareParticipating((Plan)this);
    VM_Interface.rendezvous(4260);
  }
  if (Options.verbose >= 4)   Log.writeln(""String_Node_Str"");
  threadLocalPrepare(order);
}",0.9946808510638298
150290,"@Override public Void call(){
  try {
    for (    MessageAndMetadata<Message> mam : stream) {
      BagheeraMessage bmsg=BagheeraMessage.parseFrom(ByteString.copyFrom(mam.message().payload()));
      KeyValueSink sink=sinkFactory.getSink(bmsg.getNamespace());
      if (sink == null) {
        LOG.error(""String_Node_Str"" + bmsg.getNamespace());
        break;
      }
      if (bmsg.getOperation() == Operation.CREATE_UPDATE && bmsg.hasId() && bmsg.hasPayload()) {
        if (validationPipeline == null || validationPipeline.isValid(bmsg.getPayload().toByteArray())) {
          if (bmsg.hasTimestamp()) {
            sink.store(bmsg.getId(),bmsg.getPayload().toByteArray(),bmsg.getTimestamp());
          }
 else {
            sink.store(bmsg.getId(),bmsg.getPayload().toByteArray());
          }
        }
 else {
          LOG.warn(""String_Node_Str"" + bmsg.getNamespace());
        }
      }
 else       if (bmsg.getOperation() == Operation.DELETE && bmsg.hasId()) {
        sink.delete(bmsg.getId());
      }
      consumed.mark();
    }
  }
 catch (  InvalidProtocolBufferException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  UnsupportedEncodingException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    latch.countDown();
  }
  return null;
}","@Override public Void call(){
  try {
    for (    MessageAndMetadata<Message> mam : stream) {
      BagheeraMessage bmsg=BagheeraMessage.parseFrom(ByteString.copyFrom(mam.message().payload()));
      KeyValueSink sink=sinkFactory.getSink(bmsg.getNamespace());
      if (sink == null) {
        LOG.error(""String_Node_Str"" + bmsg.getNamespace());
        break;
      }
      if (bmsg.getOperation() == Operation.CREATE_UPDATE && bmsg.hasId() && bmsg.hasPayload()) {
        if (validationPipeline == null || validationPipeline.isValid(bmsg.getPayload().toByteArray())) {
          if (bmsg.hasTimestamp()) {
            sink.store(bmsg.getId(),bmsg.getPayload().toByteArray(),bmsg.getTimestamp());
          }
 else {
            sink.store(bmsg.getId(),bmsg.getPayload().toByteArray());
          }
        }
 else {
          invalidMessageMeter.mark();
          LOG.warn(""String_Node_Str"" + bmsg.getNamespace());
        }
      }
 else       if (bmsg.getOperation() == Operation.DELETE && bmsg.hasId()) {
        sink.delete(bmsg.getId());
      }
      consumed.mark();
    }
  }
 catch (  InvalidProtocolBufferException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  UnsupportedEncodingException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    latch.countDown();
  }
  return null;
}",0.9859985261606484
150291,"public KafkaConsumer(String topic,Properties props,int numThreads){
  LOG.info(""String_Node_Str"" + numThreads);
  executor=Executors.newFixedThreadPool(numThreads);
  workers=new ArrayList<Future<Void>>(numThreads);
  ConsumerConfig consumerConfig=new ConsumerConfig(props);
  consumerConnector=kafka.consumer.Consumer.createJavaConsumerConnector(consumerConfig);
  streams=consumerConnector.createMessageStreamsByFilter(new Whitelist(topic),numThreads);
  consumed=Metrics.newMeter(new MetricName(""String_Node_Str"",""String_Node_Str"",topic + ""String_Node_Str""),""String_Node_Str"",TimeUnit.SECONDS);
}","public KafkaConsumer(String topic,Properties props,int numThreads){
  LOG.info(""String_Node_Str"" + numThreads);
  executor=Executors.newFixedThreadPool(numThreads);
  workers=new ArrayList<Future<Void>>(numThreads);
  ConsumerConfig consumerConfig=new ConsumerConfig(props);
  consumerConnector=kafka.consumer.Consumer.createJavaConsumerConnector(consumerConfig);
  streams=consumerConnector.createMessageStreamsByFilter(new Whitelist(topic),numThreads);
  consumed=Metrics.newMeter(new MetricName(""String_Node_Str"",""String_Node_Str"",topic + ""String_Node_Str""),""String_Node_Str"",TimeUnit.SECONDS);
  invalidMessageMeter=Metrics.newMeter(new MetricName(""String_Node_Str"",""String_Node_Str"",topic + ""String_Node_Str""),""String_Node_Str"",TimeUnit.SECONDS);
}",0.886094674556213
150292,"public void poll(){
  final CountDownLatch latch=new CountDownLatch(streams.size());
  for (  final KafkaStream<Message> stream : streams) {
    workers.add(executor.submit(new Callable<Void>(){
      @Override public Void call(){
        try {
          for (          MessageAndMetadata<Message> mam : stream) {
            BagheeraMessage bmsg=BagheeraMessage.parseFrom(ByteString.copyFrom(mam.message().payload()));
            KeyValueSink sink=sinkFactory.getSink(bmsg.getNamespace());
            if (sink == null) {
              LOG.error(""String_Node_Str"" + bmsg.getNamespace());
              break;
            }
            if (bmsg.getOperation() == Operation.CREATE_UPDATE && bmsg.hasId() && bmsg.hasPayload()) {
              if (validationPipeline == null || validationPipeline.isValid(bmsg.getPayload().toByteArray())) {
                if (bmsg.hasTimestamp()) {
                  sink.store(bmsg.getId(),bmsg.getPayload().toByteArray(),bmsg.getTimestamp());
                }
 else {
                  sink.store(bmsg.getId(),bmsg.getPayload().toByteArray());
                }
              }
 else {
                LOG.warn(""String_Node_Str"" + bmsg.getNamespace());
              }
            }
 else             if (bmsg.getOperation() == Operation.DELETE && bmsg.hasId()) {
              sink.delete(bmsg.getId());
            }
            consumed.mark();
          }
        }
 catch (        InvalidProtocolBufferException e) {
          LOG.error(""String_Node_Str"",e);
        }
catch (        UnsupportedEncodingException e) {
          LOG.error(""String_Node_Str"",e);
        }
catch (        IOException e) {
          LOG.error(""String_Node_Str"",e);
        }
 finally {
          latch.countDown();
        }
        return null;
      }
    }
));
  }
  try {
    while (true) {
      latch.await(10,TimeUnit.SECONDS);
      if (latch.getCount() != streams.size()) {
        break;
      }
    }
  }
 catch (  InterruptedException e) {
    LOG.info(""String_Node_Str"",e);
  }
  for (  Future<Void> worker : workers) {
    try {
      if (worker.isDone() && !worker.isCancelled()) {
        worker.get(1,TimeUnit.SECONDS);
      }
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    ExecutionException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    TimeoutException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    CancellationException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}","public void poll(){
  final CountDownLatch latch=new CountDownLatch(streams.size());
  for (  final KafkaStream<Message> stream : streams) {
    workers.add(executor.submit(new Callable<Void>(){
      @Override public Void call(){
        try {
          for (          MessageAndMetadata<Message> mam : stream) {
            BagheeraMessage bmsg=BagheeraMessage.parseFrom(ByteString.copyFrom(mam.message().payload()));
            KeyValueSink sink=sinkFactory.getSink(bmsg.getNamespace());
            if (sink == null) {
              LOG.error(""String_Node_Str"" + bmsg.getNamespace());
              break;
            }
            if (bmsg.getOperation() == Operation.CREATE_UPDATE && bmsg.hasId() && bmsg.hasPayload()) {
              if (validationPipeline == null || validationPipeline.isValid(bmsg.getPayload().toByteArray())) {
                if (bmsg.hasTimestamp()) {
                  sink.store(bmsg.getId(),bmsg.getPayload().toByteArray(),bmsg.getTimestamp());
                }
 else {
                  sink.store(bmsg.getId(),bmsg.getPayload().toByteArray());
                }
              }
 else {
                invalidMessageMeter.mark();
                LOG.warn(""String_Node_Str"" + bmsg.getNamespace());
              }
            }
 else             if (bmsg.getOperation() == Operation.DELETE && bmsg.hasId()) {
              sink.delete(bmsg.getId());
            }
            consumed.mark();
          }
        }
 catch (        InvalidProtocolBufferException e) {
          LOG.error(""String_Node_Str"",e);
        }
catch (        UnsupportedEncodingException e) {
          LOG.error(""String_Node_Str"",e);
        }
catch (        IOException e) {
          LOG.error(""String_Node_Str"",e);
        }
 finally {
          latch.countDown();
        }
        return null;
      }
    }
));
  }
  try {
    while (true) {
      latch.await(10,TimeUnit.SECONDS);
      if (latch.getCount() != streams.size()) {
        break;
      }
    }
  }
 catch (  InterruptedException e) {
    LOG.info(""String_Node_Str"",e);
  }
  for (  Future<Void> worker : workers) {
    try {
      if (worker.isDone() && !worker.isCancelled()) {
        worker.get(1,TimeUnit.SECONDS);
      }
    }
 catch (    InterruptedException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    ExecutionException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    TimeoutException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    CancellationException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}",0.9912629070691024
150293,"public static void main(String[] args){
  OptionFactory optFactory=OptionFactory.getInstance();
  Options options=KafkaConsumer.getOptions();
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"").required());
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str""));
  CommandLineParser parser=new GnuParser();
  ShutdownHook sh=ShutdownHook.getInstance();
  try {
    CommandLine cmd=parser.parse(options,args);
    final KafkaConsumer consumer=KafkaConsumer.fromOptions(cmd);
    sh.addFirst(consumer);
    SinkConfiguration sinkConfig=new SinkConfiguration();
    if (cmd.hasOption(""String_Node_Str"")) {
      sinkConfig.setInt(""String_Node_Str"",Integer.parseInt(cmd.getOptionValue(""String_Node_Str"")));
    }
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str""));
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setBoolean(""String_Node_Str"",Boolean.parseBoolean(cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"")));
    KeyValueSinkFactory sinkFactory=KeyValueSinkFactory.getInstance(HBaseSink.class,sinkConfig);
    sh.addLast(sinkFactory);
    consumer.setSinkFactory(sinkFactory);
    MetricsManager.getInstance();
    consumer.poll();
  }
 catch (  ParseException e) {
    LOG.error(""String_Node_Str"",e);
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(KafkaHBaseConsumer.class.getName(),options);
  }
}","public static void main(String[] args){
  OptionFactory optFactory=OptionFactory.getInstance();
  Options options=KafkaConsumer.getOptions();
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"").required());
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str""));
  CommandLineParser parser=new GnuParser();
  ShutdownHook sh=ShutdownHook.getInstance();
  try {
    CommandLine cmd=parser.parse(options,args);
    final KafkaConsumer consumer=KafkaConsumer.fromOptions(cmd);
    sh.addFirst(consumer);
    SinkConfiguration sinkConfig=new SinkConfiguration();
    if (cmd.hasOption(""String_Node_Str"")) {
      sinkConfig.setInt(""String_Node_Str"",Integer.parseInt(cmd.getOptionValue(""String_Node_Str"")));
    }
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str""));
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setBoolean(""String_Node_Str"",cmd.hasOption(""String_Node_Str""));
    KeyValueSinkFactory sinkFactory=KeyValueSinkFactory.getInstance(HBaseSink.class,sinkConfig);
    sh.addLast(sinkFactory);
    consumer.setSinkFactory(sinkFactory);
    MetricsManager.getInstance();
    consumer.poll();
  }
 catch (  ParseException e) {
    LOG.error(""String_Node_Str"",e);
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(KafkaHBaseConsumer.class.getName(),options);
  }
}",0.9736477115117892
150294,"public static void main(String[] args){
  OptionFactory optFactory=OptionFactory.getInstance();
  Options options=KafkaConsumer.getOptions();
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str""));
  CommandLineParser parser=new GnuParser();
  ShutdownHook sh=ShutdownHook.getInstance();
  try {
    CommandLine cmd=parser.parse(options,args);
    final KafkaConsumer consumer=KafkaConsumer.fromOptions(cmd);
    sh.addFirst(consumer);
    SinkConfiguration sinkConfig=new SinkConfiguration();
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setLong(""String_Node_Str"",Long.parseLong(cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"")));
    sinkConfig.setBoolean(""String_Node_Str"",Boolean.parseBoolean(cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"")));
    KeyValueSinkFactory sinkFactory=KeyValueSinkFactory.getInstance(SequenceFileSink.class,sinkConfig);
    sh.addLast(sinkFactory);
    consumer.setSinkFactory(sinkFactory);
    MetricsManager.getInstance();
    consumer.poll();
  }
 catch (  ParseException e) {
    LOG.error(""String_Node_Str"",e);
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(KafkaSequenceFileConsumer.class.getName(),options);
  }
catch (  NumberFormatException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","public static void main(String[] args){
  OptionFactory optFactory=OptionFactory.getInstance();
  Options options=KafkaConsumer.getOptions();
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str""));
  options.addOption(optFactory.create(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str""));
  CommandLineParser parser=new GnuParser();
  ShutdownHook sh=ShutdownHook.getInstance();
  try {
    CommandLine cmd=parser.parse(options,args);
    final KafkaConsumer consumer=KafkaConsumer.fromOptions(cmd);
    sh.addFirst(consumer);
    SinkConfiguration sinkConfig=new SinkConfiguration();
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setString(""String_Node_Str"",cmd.getOptionValue(""String_Node_Str"",""String_Node_Str""));
    sinkConfig.setLong(""String_Node_Str"",Long.parseLong(cmd.getOptionValue(""String_Node_Str"",""String_Node_Str"")));
    sinkConfig.setBoolean(""String_Node_Str"",cmd.hasOption(""String_Node_Str""));
    KeyValueSinkFactory sinkFactory=KeyValueSinkFactory.getInstance(SequenceFileSink.class,sinkConfig);
    sh.addLast(sinkFactory);
    consumer.setSinkFactory(sinkFactory);
    MetricsManager.getInstance();
    consumer.poll();
  }
 catch (  ParseException e) {
    LOG.error(""String_Node_Str"",e);
    HelpFormatter formatter=new HelpFormatter();
    formatter.printHelp(KafkaSequenceFileConsumer.class.getName(),options);
  }
catch (  NumberFormatException e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.9730649277005954
150295,"/** 
 * Takes a given id and gives you an hbase shell compatible string that you can use for get command.
 * @param id
 * @param d
 * @return
 * @throws IOException
 */
public static String hbaseShellId(String id,Date d) throws IOException {
  byte[] idBytes=IdUtil.nonRandByteBucketizeId(id,d);
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(String.format(""String_Node_Str"",idBytes[0]));
  sb.append((new String(idBytes)).substring(1));
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public static String hbaseShellId(byte[] idBytes) throws IOException {
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(String.format(""String_Node_Str"",idBytes[0]));
  sb.append((new String(idBytes)).substring(1));
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.622991347342398
150296,"public void run() throws Exception {
  this.configureHealthChecks();
  this.configureWebServer();
  this.configureReporters();
}","public void run() throws Exception {
  this.configureHealthChecks();
  this.configureWebServer();
  this.configureReporters();
  this.configureHttpMetrics();
}",0.89198606271777
150297,"private void updateFailed(HttpMetrics metric,Integer size){
  HttpMetrics global_metric=getHttpMetrics(""String_Node_Str"");
  metric.failedReqsCount.inc();
  metric.failedReqsSize.inc(size);
  metric.totalReqsCount.inc();
  metric.totalReqsSize.inc(size);
  global_metric.failedReqsCount.inc();
  global_metric.failedReqsSize.inc(size);
  global_metric.totalReqsCount.inc();
  global_metric.totalReqsSize.inc(size);
}","private void updateFailed(String namespace,int size){
  MetricsManager.getInstance().getHttpMetricForNamespace(namespace).updateFailed(size);
  MetricsManager.getInstance().getGlobalHttpMetric().updateFailed(size);
}",0.2341772151898734
150298,"@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  HttpMetrics metric=this.getHttpMetrics(""String_Node_Str"");
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)e.getMessage();
    PathDecoder pd=new PathDecoder(request.getUri());
    String endpoint=pd.getPathElement(ENDPOINT_PATH_IDX);
    if (endpoint != null && ENDPOINT_SUBMIT.equals(endpoint)) {
      String namespace=pd.getPathElement(NAMESPACE_PATH_IDX);
      String id=pd.getPathElement(ID_PATH_IDX);
      if (id == null) {
        id=UUID.randomUUID().toString();
      }
      IMap<String,String> m=Hazelcast.getMap(namespace);
      if (request.getMethod() == HttpMethod.POST || request.getMethod() == HttpMethod.PUT) {
        handlePost(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.GET) {
        handleGet(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        handleDelete(e,request,namespace,id,m);
      }
 else {
        writeResponse(NOT_FOUND,e,null);
      }
    }
 else {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=e.getChannel().getRemoteAddress().toString();
      LOG.warn(String.format(""String_Node_Str"",remoteIpAddress,userAgent));
      writeResponse(NOT_ACCEPTABLE,e,null);
    }
  }
 else {
    writeResponse(INTERNAL_SERVER_ERROR,e,null);
  }
}","@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)e.getMessage();
    PathDecoder pd=new PathDecoder(request.getUri());
    String endpoint=pd.getPathElement(ENDPOINT_PATH_IDX);
    if (endpoint != null && ENDPOINT_SUBMIT.equals(endpoint)) {
      String namespace=pd.getPathElement(NAMESPACE_PATH_IDX);
      String id=pd.getPathElement(ID_PATH_IDX);
      if (id == null) {
        id=UUID.randomUUID().toString();
      }
      IMap<String,String> m=Hazelcast.getMap(namespace);
      if (request.getMethod() == HttpMethod.POST || request.getMethod() == HttpMethod.PUT) {
        handlePost(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.GET) {
        handleGet(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        handleDelete(e,request,namespace,id,m);
      }
 else {
        writeResponse(NOT_FOUND,e,null);
      }
    }
 else {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=e.getChannel().getRemoteAddress().toString();
      LOG.warn(String.format(""String_Node_Str"",remoteIpAddress,userAgent));
      writeResponse(NOT_ACCEPTABLE,e,null);
    }
  }
 else {
    writeResponse(INTERNAL_SERVER_ERROR,e,null);
  }
}",0.978753047718565
150299,"private void handlePost(MessageEvent e,HttpRequest request,String namespace,String id,IMap<String,String> m){
  HttpResponseStatus status=NOT_ACCEPTABLE;
  ChannelBuffer content=request.getContent();
  HttpMetrics ns_metric=getHttpMetrics(namespace);
  if (content.readable() && content.readableBytes() > 0) {
    if (NS_METRICS.equals(namespace)) {
      status=metricsProcessor.process(m,id,content.toString(CharsetUtil.UTF_8),e.getChannel().getRemoteAddress().toString(),request.getHeader(""String_Node_Str""));
    }
 else {
      m.put(id,content.toString(CharsetUtil.UTF_8));
      status=CREATED;
    }
  }
  if (status != CREATED) {
    updateFailed(ns_metric,content.readableBytes());
  }
 else {
    updateSuccessful(ns_metric,content.readableBytes());
  }
  writeResponse(status,e,URI.create(id).toString());
}","private void handlePost(MessageEvent e,HttpRequest request,String namespace,String id,IMap<String,String> m){
  HttpResponseStatus status=NOT_ACCEPTABLE;
  ChannelBuffer content=request.getContent();
  if (content.readable() && content.readableBytes() > 0) {
    if (NS_METRICS.equals(namespace)) {
      status=metricsProcessor.process(m,id,content.toString(CharsetUtil.UTF_8),e.getChannel().getRemoteAddress().toString(),request.getHeader(""String_Node_Str""));
    }
 else {
      m.put(id,content.toString(CharsetUtil.UTF_8));
      status=CREATED;
    }
  }
  if (status != CREATED) {
    updateFailed(namespace,content.readableBytes());
  }
 else {
    updateSuccesssful(namespace,content.readableBytes());
  }
  writeResponse(status,e,URI.create(id).toString());
}",0.947103274559194
150300,"public HttpResponseStatus process(IMap<String,String> hcMap,String id,String newDocument,String remoteAddr,String obsoleteDocId){
  HttpResponseStatus status=NOT_ACCEPTABLE;
  try {
    ObjectNode aggregate=objectMapper.readValue(newDocument,ObjectNode.class);
    if (isValidDocument(aggregate)) {
      setGeoLocation(aggregate,remoteAddr);
      hcMap.put(id,objectMapper.writeValueAsString(aggregate));
      if (obsoleteDocId != null) {
        hcMap.remove(id);
      }
      status=HttpResponseStatus.CREATED;
    }
 else {
      LOG.error(""String_Node_Str"");
    }
  }
 catch (  JsonParseException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  JsonMappingException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
  return status;
}","public HttpResponseStatus process(IMap<String,String> hcMap,String id,String newDocument,String remoteAddr,String obsoleteDocId){
  HttpResponseStatus status=NOT_ACCEPTABLE;
  try {
    ObjectNode aggregate=objectMapper.readValue(newDocument,ObjectNode.class);
    if (isValidDocument(aggregate)) {
      setGeoLocation(aggregate,remoteAddr);
      hcMap.put(id,objectMapper.writeValueAsString(aggregate));
      if (obsoleteDocId != null) {
        hcMap.remove(obsoleteDocId);
      }
      status=HttpResponseStatus.CREATED;
    }
 else {
      LOG.error(""String_Node_Str"");
    }
  }
 catch (  JsonParseException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  JsonMappingException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
  return status;
}",0.9920294297976702
150301,"public void poll() throws InterruptedException {
  while (true) {
    if (!nsMap.isEmpty()) {
      try {
        List<Put> puts=new ArrayList<Put>();
        for (        String k : nsMap.keySet()) {
          String v=nsMap.remove(k);
          if (v != null) {
            byte[] rowId=prefixDate ? IdUtil.bucketizeId(k) : Bytes.toBytes(k);
            Put p=new Put(rowId);
            p.add(family,qualifier,Bytes.toBytes(v));
            puts.add(p);
            if (puts.size() >= batchSize)             break;
          }
        }
        if (puts.size() > 0) {
          workerPool.submit(new HBaseWorkerThread((HTable)hbasePool.getTable(tableName),puts));
        }
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
 else {
      Thread.sleep(sleepTime);
    }
  }
}","public void poll() throws InterruptedException {
  while (true) {
    if (!nsMap.isEmpty()) {
      try {
        List<Put> puts=new ArrayList<Put>();
        for (        String k : nsMap.keySet()) {
          String v=nsMap.remove(k);
          if (v != null) {
            try {
              byte[] rowId=prefixDate ? IdUtil.bucketizeId(k) : Bytes.toBytes(k);
              Put p=new Put(rowId);
              p.add(family,qualifier,Bytes.toBytes(v));
              puts.add(p);
            }
 catch (            NumberFormatException e) {
              LOG.error(""String_Node_Str"" + k,e);
            }
            if (puts.size() >= batchSize)             break;
          }
        }
        if (puts.size() > 0) {
          workerPool.submit(new HBaseWorkerThread((HTable)hbasePool.getTable(tableName),puts));
        }
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
 else {
      Thread.sleep(sleepTime);
    }
  }
}",0.906367041198502
150302,"@Override public void storeAll(Map<String,String> pairs){
  HTable table=null;
  try {
    List<Put> puts=new ArrayList<Put>(pairs.size());
    for (    Map.Entry<String,String> pair : pairs.entrySet()) {
      byte[] rowId=prefixDate ? IdUtil.bucketizeId(pair.getKey()) : Bytes.toBytes(pair.getKey());
      Put p=new Put(rowId);
      if (outputFormatType == StoreFormatType.SMILE) {
        p.add(family,qualifier,jsonSmileConverter.convertToSmile(pair.getValue()));
      }
 else {
        p.add(family,qualifier,Bytes.toBytes(pair.getValue()));
      }
      puts.add(p);
    }
    table=(HTable)pool.getTable(tableName);
    table.setAutoFlush(false);
    table.put(puts);
    table.flushCommits();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (table != null) {
      pool.putTable(table);
    }
  }
}","@Override public void storeAll(Map<String,String> pairs){
  HTable table=null;
  try {
    List<Put> puts=new ArrayList<Put>(pairs.size());
    for (    Map.Entry<String,String> pair : pairs.entrySet()) {
      try {
        byte[] rowId=prefixDate ? IdUtil.bucketizeId(pair.getKey()) : Bytes.toBytes(pair.getKey());
        Put p=new Put(rowId);
        if (outputFormatType == StoreFormatType.SMILE) {
          p.add(family,qualifier,jsonSmileConverter.convertToSmile(pair.getValue()));
        }
 else {
          p.add(family,qualifier,Bytes.toBytes(pair.getValue()));
        }
        puts.add(p);
      }
 catch (      NumberFormatException nfe) {
        LOG.error(""String_Node_Str"" + pair.getKey(),nfe);
      }
    }
    table=(HTable)pool.getTable(tableName);
    table.setAutoFlush(false);
    table.put(puts);
    table.flushCommits();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (table != null) {
      pool.putTable(table);
    }
  }
}",0.9085002707092582
150303,"@Override public void store(String key,String value){
  HTableInterface table=null;
  try {
    table=pool.getTable(tableName);
    byte[] rowId=prefixDate ? IdUtil.bucketizeId(key) : Bytes.toBytes(key);
    Put p=new Put(rowId);
    if (outputFormatType == StoreFormatType.SMILE) {
      p.add(family,qualifier,jsonSmileConverter.convertToSmile(value));
    }
 else {
      p.add(family,qualifier,Bytes.toBytes(value));
    }
    table.put(p);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (table != null) {
      pool.putTable(table);
    }
  }
}","@Override public void store(String key,String value){
  HTableInterface table=null;
  try {
    table=pool.getTable(tableName);
    try {
      byte[] rowId=prefixDate ? IdUtil.bucketizeId(key) : Bytes.toBytes(key);
      Put p=new Put(rowId);
      if (outputFormatType == StoreFormatType.SMILE) {
        p.add(family,qualifier,jsonSmileConverter.convertToSmile(value));
      }
 else {
        p.add(family,qualifier,Bytes.toBytes(value));
      }
      table.put(p);
    }
 catch (    NumberFormatException nfe) {
      LOG.error(""String_Node_Str"" + key,nfe);
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (table != null) {
      pool.putTable(table);
    }
  }
}",0.8752869166029075
150304,"public static void main(String[] args){
  int port=Integer.parseInt(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  Hazelcast.getDefaultInstance();
  Config config=Hazelcast.getConfig();
  for (  Map.Entry<String,MapConfig> entry : config.getMapConfigs().entrySet()) {
    String mapName=entry.getKey();
    if (!mapName.contains(""String_Node_Str"")) {
      Hazelcast.getMap(entry.getKey());
    }
  }
  NioServerSocketChannelFactory channelFactory=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool());
  ServerBootstrap sb=new ServerBootstrap(channelFactory);
  HttpServerPipelineFactory pipeFactory;
  try {
    pipeFactory=new HttpServerPipelineFactory(config.getMapConfigs().keySet());
    sb.setPipelineFactory(pipeFactory);
    sb.bind(new InetSocketAddress(port));
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","public static void main(String[] args){
  int port=Integer.parseInt(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  Hazelcast.getDefaultInstance();
  Config config=Hazelcast.getConfig();
  for (  Map.Entry<String,MapConfig> entry : config.getMapConfigs().entrySet()) {
    String mapName=entry.getKey();
    if (!mapName.contains(""String_Node_Str"")) {
      Hazelcast.getMap(entry.getKey());
    }
  }
  NioServerSocketChannelFactory channelFactory=new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newFixedThreadPool(DEFAULT_IO_THREADS));
  ServerBootstrap sb=new ServerBootstrap(channelFactory);
  HttpServerPipelineFactory pipeFactory;
  try {
    pipeFactory=new HttpServerPipelineFactory(config.getMapConfigs().keySet());
    sb.setPipelineFactory(pipeFactory);
    sb.setOption(""String_Node_Str"",true);
    sb.setOption(""String_Node_Str"",false);
    sb.bind(new InetSocketAddress(port));
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}",0.9422875131164744
150305,"@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)e.getMessage();
    PathDecoder pd=new PathDecoder(request.getUri());
    String endpoint=pd.getPathElement(ENDPOINT_PATH_IDX);
    if (endpoint != null && ENDPOINT_SUBMIT.equals(endpoint)) {
      String namespace=pd.getPathElement(NAMESPACE_PATH_IDX);
      String id=pd.getPathElement(ID_PATH_IDX);
      if (id == null) {
        id=UUID.randomUUID().toString();
      }
      IMap<String,String> m=Hazelcast.getMap(namespace);
      if (request.getMethod() == HttpMethod.POST || request.getMethod() == HttpMethod.PUT) {
        handlePost(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.GET) {
        handleGet(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        handleDelete(e,request,namespace,id,m);
      }
 else {
        writeResponse(NOT_FOUND,e,null);
      }
    }
 else     if (endpoint != null && ENDPOINT_STATS.equals(""String_Node_Str"")) {
      writeResponse(OK,e,null);
    }
 else {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=e.getChannel().getRemoteAddress().toString();
      LOG.warn(String.format(""String_Node_Str"",remoteIpAddress,userAgent));
      writeResponse(NOT_ACCEPTABLE,e,null);
    }
  }
 else {
    writeResponse(INTERNAL_SERVER_ERROR,e,null);
  }
}","@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)e.getMessage();
    PathDecoder pd=new PathDecoder(request.getUri());
    String endpoint=pd.getPathElement(ENDPOINT_PATH_IDX);
    if (endpoint != null && ENDPOINT_SUBMIT.equals(endpoint)) {
      String namespace=pd.getPathElement(NAMESPACE_PATH_IDX);
      String id=pd.getPathElement(ID_PATH_IDX);
      if (id == null) {
        id=UUID.randomUUID().toString();
      }
      IMap<String,String> m=Hazelcast.getMap(namespace);
      if (request.getMethod() == HttpMethod.POST || request.getMethod() == HttpMethod.PUT) {
        handlePost(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.GET) {
        handleGet(e,request,namespace,id,m);
      }
 else       if (request.getMethod() == HttpMethod.DELETE) {
        handleDelete(e,request,namespace,id,m);
      }
 else {
        writeResponse(NOT_FOUND,e,null);
      }
    }
 else {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=e.getChannel().getRemoteAddress().toString();
      LOG.warn(String.format(""String_Node_Str"",remoteIpAddress,userAgent));
      writeResponse(NOT_ACCEPTABLE,e,null);
    }
  }
 else {
    writeResponse(INTERNAL_SERVER_ERROR,e,null);
  }
}",0.9603554340396444
150306,"@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  Throwable cause=e.getCause();
  HttpResponse response=null;
  if (cause instanceof InvalidJsonException) {
    LOG.error(cause.getMessage());
    response=new DefaultHttpResponse(HTTP_1_1,NOT_ACCEPTABLE);
  }
 else   if (cause instanceof TooLongFrameException) {
    response=new DefaultHttpResponse(HTTP_1_1,REQUEST_ENTITY_TOO_LARGE);
  }
 else   if (cause instanceof InvalidPathException) {
    response=new DefaultHttpResponse(HTTP_1_1,NOT_FOUND);
  }
 else   if (cause instanceof SecurityException) {
    LOG.error(cause.getMessage());
    response=new DefaultHttpResponse(HTTP_1_1,FORBIDDEN);
  }
 else {
    LOG.error(cause.getMessage());
    response=new DefaultHttpResponse(HTTP_1_1,INTERNAL_SERVER_ERROR);
  }
  response.addHeader(CONTENT_TYPE,""String_Node_Str"");
  ChannelFuture future=e.getChannel().write(response);
  future.addListener(ChannelFutureListener.CLOSE);
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,ExceptionEvent e) throws Exception {
  Throwable cause=e.getCause();
  HttpResponse response=null;
  if (cause instanceof InvalidJsonException) {
    LOG.error(cause.getMessage());
    response=new DefaultHttpResponse(HTTP_1_1,NOT_ACCEPTABLE);
  }
 else   if (cause instanceof TooLongFrameException) {
    response=new DefaultHttpResponse(HTTP_1_1,REQUEST_ENTITY_TOO_LARGE);
  }
 else   if (cause instanceof InvalidPathException) {
    response=new DefaultHttpResponse(HTTP_1_1,NOT_FOUND);
  }
 else   if (cause instanceof HttpSecurityException) {
    LOG.error(cause.getMessage());
    response=new DefaultHttpResponse(HTTP_1_1,FORBIDDEN);
  }
 else {
    LOG.error(cause.getMessage());
    response=new DefaultHttpResponse(HTTP_1_1,INTERNAL_SERVER_ERROR);
  }
  response.addHeader(CONTENT_TYPE,""String_Node_Str"");
  ChannelFuture future=e.getChannel().write(response);
  future.addListener(ChannelFutureListener.CLOSE);
}",0.997969543147208
150307,"private void handlePost(MessageEvent e,HttpRequest request,String namespace,String id,IMap<String,String> m){
  HttpResponseStatus status=NOT_FOUND;
  ChannelBuffer content=request.getContent();
  if (content.readable()) {
    if (NS_METRICS.equals(namespace)) {
      status=metricsProcessor.process(m,id,content.toString(CharsetUtil.UTF_8),e.getChannel().getRemoteAddress().toString(),request.getHeader(""String_Node_Str""));
    }
 else {
      m.put(id,content.toString(CharsetUtil.UTF_8));
      status=CREATED;
    }
  }
  writeResponse(status,e,URI.create(id).toString());
}","private void handlePost(MessageEvent e,HttpRequest request,String namespace,String id,IMap<String,String> m){
  HttpResponseStatus status=NOT_ACCEPTABLE;
  ChannelBuffer content=request.getContent();
  if (content.readable() && content.readableBytes() > 0) {
    if (NS_METRICS.equals(namespace)) {
      status=metricsProcessor.process(m,id,content.toString(CharsetUtil.UTF_8),e.getChannel().getRemoteAddress().toString(),request.getHeader(""String_Node_Str""));
    }
 else {
      m.put(id,content.toString(CharsetUtil.UTF_8));
      status=CREATED;
    }
  }
  writeResponse(status,e,URI.create(id).toString());
}",0.9614740368509213
150308,"public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpChunkAggregator(maxContentLength));
  pipeline.addLast(""String_Node_Str"",new ContentLengthFilter(maxContentLength));
  pipeline.addLast(""String_Node_Str"",new HttpContentDecompressor());
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new UriPatternFilter(validator));
  pipeline.addLast(""String_Node_Str"",new AccessFilter(validator,HazelcastMapHandler.NAMESPACE_PATH_IDX,props));
  pipeline.addLast(""String_Node_Str"",new JsonFilter(validator));
  pipeline.addLast(""String_Node_Str"",new HazelcastMapHandler(metricsProcessor));
  return pipeline;
}","public ChannelPipeline getPipeline() throws Exception {
  ChannelPipeline pipeline=Channels.pipeline();
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new RootResponse());
  pipeline.addLast(""String_Node_Str"",new StatsHandler());
  pipeline.addLast(""String_Node_Str"",new HttpChunkAggregator(maxContentLength));
  pipeline.addLast(""String_Node_Str"",new ContentLengthFilter(maxContentLength));
  pipeline.addLast(""String_Node_Str"",new AccessFilter(validator,HazelcastMapHandler.NAMESPACE_PATH_IDX,props));
  pipeline.addLast(""String_Node_Str"",new HttpContentDecompressor());
  pipeline.addLast(""String_Node_Str"",new JsonFilter(validator));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HazelcastMapHandler(metricsProcessor));
  return pipeline;
}",0.7277079593058049
150309,"public AccessFilter(NamespaceValidator nsValidator,int nsPathIdx,WildcardProperties props){
  this.nsValidator=nsValidator;
  this.nsPathIdx=nsPathIdx;
  this.props=props;
}","public AccessFilter(Validator validator,int nsPathIdx,WildcardProperties props){
  this.validator=validator;
  this.nsPathIdx=nsPathIdx;
  this.props=props;
}",0.9365558912386708
150310,"@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)msg;
    PathDecoder rpd=new PathDecoder(request.getUri());
    String ns=rpd.getPathElement(nsPathIdx);
    if (ns == null || !nsValidator.isValidNamespace(ns)) {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
      throw new SecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
    }
    if (request.getMethod() == HttpMethod.POST) {
    }
 else     if (request.getMethod() == HttpMethod.GET) {
      boolean allowGetAccess=Boolean.parseBoolean(props.getWildcardProperty(ns + ALLOW_GET_ACCESS,""String_Node_Str""));
      if (!allowGetAccess) {
        String userAgent=request.getHeader(""String_Node_Str"");
        String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
        throw new SecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
      }
    }
 else     if (request.getMethod() == HttpMethod.DELETE) {
      boolean allowDelAccess=Boolean.parseBoolean(props.getWildcardProperty(ns + ALLOW_DELETE_ACCESS,""String_Node_Str""));
      if (!allowDelAccess) {
        String userAgent=request.getHeader(""String_Node_Str"");
        String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
        throw new SecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
      }
    }
 else {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
      throw new SecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
    }
    Channels.fireMessageReceived(ctx,request,e.getRemoteAddress());
  }
 else {
    ctx.sendUpstream(e);
  }
}","@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)msg;
    if (!validator.isValidUri(request.getUri())) {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
      throw new InvalidPathException(String.format(""String_Node_Str"",request.getUri(),remoteIpAddress,userAgent));
    }
    PathDecoder rpd=new PathDecoder(request.getUri());
    String ns=rpd.getPathElement(nsPathIdx);
    if (ns == null) {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
      throw new InvalidPathException(String.format(""String_Node_Str"",remoteIpAddress,userAgent));
    }
    if (request.getMethod() == HttpMethod.POST) {
    }
 else     if (request.getMethod() == HttpMethod.GET) {
      boolean allowGetAccess=Boolean.parseBoolean(props.getWildcardProperty(ns + ALLOW_GET_ACCESS,""String_Node_Str""));
      if (!allowGetAccess) {
        String userAgent=request.getHeader(""String_Node_Str"");
        String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
        throw new HttpSecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
      }
    }
 else     if (request.getMethod() == HttpMethod.DELETE) {
      boolean allowDelAccess=Boolean.parseBoolean(props.getWildcardProperty(ns + ALLOW_DELETE_ACCESS,""String_Node_Str""));
      if (!allowDelAccess) {
        String userAgent=request.getHeader(""String_Node_Str"");
        String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
        throw new HttpSecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
      }
    }
 else {
      String userAgent=request.getHeader(""String_Node_Str"");
      String remoteIpAddress=((InetSocketAddress)e.getChannel().getRemoteAddress()).getAddress().getHostAddress();
      throw new HttpSecurityException(String.format(""String_Node_Str"",ns,remoteIpAddress,userAgent));
    }
    Channels.fireMessageReceived(ctx,request,e.getRemoteAddress());
  }
 else {
    ctx.sendUpstream(e);
  }
}",0.907321389073214
150311,"@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)e.getMessage();
    ChannelBuffer content=request.getContent();
    if (content.readable()) {
      if (!jsonValidator.isValidJson(content.toString(CharsetUtil.UTF_8))) {
        throw new InvalidJsonException(""String_Node_Str"");
      }
 else {
        Channels.fireMessageReceived(ctx,request,e.getRemoteAddress());
      }
    }
  }
 else {
    ctx.sendUpstream(e);
  }
}","@Override public void messageReceived(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  Object msg=e.getMessage();
  if (msg instanceof HttpRequest) {
    HttpRequest request=(HttpRequest)e.getMessage();
    ChannelBuffer content=request.getContent();
    if (content.readable()) {
      if (!jsonValidator.isValidJson(content.toString(CharsetUtil.UTF_8))) {
        throw new InvalidJsonException(""String_Node_Str"");
      }
    }
    Channels.fireMessageReceived(ctx,request,e.getRemoteAddress());
  }
 else {
    ctx.sendUpstream(e);
  }
}",0.9168141592920354
150312,"@GET @Produces(MediaType.TEXT_PLAIN) public Response getStats(){
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<String,Stats> entry : rs.getStatsMap().entrySet()) {
    Stats stats=entry.getValue();
    sb.append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numValidRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numInvalidRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numForbiddenRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numPuts.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numGets.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numDels.get());
  }
  return Response.ok(sb.toString(),MediaType.APPLICATION_JSON).build();
}","@GET @Produces(MediaType.TEXT_PLAIN) public Response getStats(){
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<String,Stats> entry : rs.getStatsMap().entrySet()) {
    Stats stats=entry.getValue();
    sb.append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numValidRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numInvalidRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numForbiddenRequests.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numPuts.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numGets.get()).append(""String_Node_Str"");
    sb.append(""String_Node_Str"").append(stats.numDels.get()).append(""String_Node_Str"");
  }
  return Response.ok(sb.toString(),MediaType.APPLICATION_JSON).build();
}",0.987141444114738
150313,"/** 
 * Add a collection of rules to the Gnip stream
 * @param account The account name for the power track API. (For example: acme)
 * @param streamName the streamName
 * @param rule The Rules object to add to the tracker
 */
void addRules(String account,String streamName,Rules rules);","/** 
 * Add a collection of rules to the Gnip stream
 * @param account The account name for the power track API. (For example: acme)
 * @param streamName the streamName
 * @param rules The Rules object to add to the tracker
 */
void addRules(String account,String streamName,Rules rules);",0.9982608695652174
150314,"public void formatGrid(Grid grid){
  grid.setCellStyleGenerator(cellReference -> {
    if (cellReference.getValue() instanceof BigDecimal)     return ""String_Node_Str"";
    return null;
  }
);
  DecimalFormat nf=new DecimalFormat();
  nf.setGroupingUsed(false);
  if (grid.getColumn(""String_Node_Str"") != null && !String.class.equals(grid.getContainerDataSource().getType(""String_Node_Str"")))   grid.getColumn(""String_Node_Str"").setRenderer(new NumberRenderer(nf));
  for (  Grid.Column c : grid.getColumns()) {
    c.setHidable(true);
    ViewConfig.FieldConfig config=viewConfig.getFields().get(c.getPropertyId());
    if (""String_Node_Str"".equals(c.getPropertyId())) {
      c.setExpandRatio(0);
    }
 else     if (isBooleanColumn(c)) {
      c.setExpandRatio(0);
      c.setConverter(new StringToBooleanConverter(""String_Node_Str"",""String_Node_Str""));
    }
 else     if (isDateColumn(c)) {
      c.setRenderer(new DateRenderer(getDateFormat()));
    }
 else {
      c.setExpandRatio(1);
    }
    if (config != null) {
      if (config.getExpandRatio() != -1)       c.setExpandRatio(config.getExpandRatio());
    }
  }
  grid.setSizeFull();
}","public void formatGrid(Grid grid){
  grid.setCellStyleGenerator(cellReference -> {
    if (cellReference.getValue() instanceof BigDecimal)     return ""String_Node_Str"";
    return null;
  }
);
  DecimalFormat nf=new DecimalFormat();
  nf.setGroupingUsed(false);
  grid.addColumnResizeListener((Grid.ColumnResizeListener)event -> {
    int lastColumnIndex=grid.getColumns().size() - 1;
    grid.getColumns().get(lastColumnIndex).setWidth(1500);
  }
);
  if (grid.getColumn(""String_Node_Str"") != null && !String.class.equals(grid.getContainerDataSource().getType(""String_Node_Str"")))   grid.getColumn(""String_Node_Str"").setRenderer(new NumberRenderer(nf));
  for (  Grid.Column c : grid.getColumns()) {
    c.setHidable(true);
    if (""String_Node_Str"".equals(c.getPropertyId())) {
      c.setExpandRatio(0);
    }
 else     if (isBooleanColumn(c)) {
      c.setExpandRatio(0);
      c.setConverter(new StringToBooleanConverter(""String_Node_Str"",""String_Node_Str""));
    }
 else     if (isDateColumn(c)) {
      c.setRenderer(new DateRenderer(getDateFormat()));
    }
 else {
      c.setExpandRatio(1);
    }
    ViewConfig.FieldConfig config=viewConfig.getFields().get(c.getPropertyId());
    if (config != null) {
      if (config.getExpandRatio() != -1)       c.setExpandRatio(config.getExpandRatio());
    }
  }
  grid.setSizeFull();
}",0.8587525150905433
150315,"@Override public void enter(ViewChangeListener.ViewChangeEvent event){
  super.enter(event);
  setHelper(createHelper());
  showSpecificView(getGeneralRoute() + ""String_Node_Str"" + QI.getQI().getUser().getId());
}","@Override public void enter(ViewChangeListener.ViewChangeEvent event){
  setHelper(createHelper());
  getHelper().setConfiguration(getConfiguration());
  showSpecificView(getGeneralRoute() + ""String_Node_Str"" + QI.getQI().getUser().getId());
}",0.8070175438596491
150316,"private BigDecimal createBalanceCache(Journal journal,Account acct,short[] layers,long maxId) throws HibernateException, GLException {
  BigDecimal balance=null;
  if (acct instanceof CompositeAccount) {
    balance=ZERO;
    Iterator iter=((CompositeAccount)acct).getChildren().iterator();
    while (iter.hasNext()) {
      Account a=(Account)iter.next();
      balance=balance.add(createBalanceCache(journal,a,layers,maxId));
    }
  }
 else   if (acct instanceof FinalAccount) {
    lock(journal,acct);
    balance=getBalances(journal,acct,null,true,layers,maxId)[0];
    BalanceCache c=getBalanceCache(journal,acct,layers);
    if (c == null) {
      c=new BalanceCache();
      c.setJournal(journal);
      c.setAccount(acct);
      c.setLayers(layersToString(layers));
    }
    if (maxId != c.getRef()) {
      c.setRef(maxId);
      c.setBalance(balance);
      session.saveOrUpdate(c);
    }
  }
  return balance;
}","private BigDecimal createBalanceCache(Journal journal,Account acct,short[] layers,long maxId) throws HibernateException, GLException {
  BigDecimal balance=null;
  if (acct instanceof CompositeAccount) {
    balance=ZERO;
    Iterator iter=((CompositeAccount)acct).getChildren().iterator();
    while (iter.hasNext()) {
      Account a=(Account)iter.next();
      balance=balance.add(createBalanceCache(journal,a,layers,maxId));
    }
  }
 else   if (acct instanceof FinalAccount) {
    lock(journal,acct);
    balance=getBalances(journal,acct,null,true,layers,maxId)[0];
    BalanceCache c=getBalanceCache(journal,acct,layers);
    if (c == null) {
      c=new BalanceCache();
      c.setJournal(journal);
      c.setAccount(acct);
      c.setLayers(layersToString(layers));
    }
    if (maxId != c.getRef()) {
      c.setRef(maxId);
      c.setBalance(balance);
      session.saveOrUpdate(c);
    }
  }
  return getBalance(journal,acct,layers);
}",0.9797225186766276
150317,"/** 
 * Creates DB Object using default Hibernate instance
 * @param log Log object
 */
public DB(Log log,String configModifier){
  this(configModifier);
  setLog(log);
}","/** 
 * Creates DB Object using default Hibernate instance
 * @param log Log object
 * @param configModifier modifier
 */
public DB(Log log,String configModifier){
  this(configModifier);
  setLog(log);
}",0.9090909090909092
150318,"/** 
 * Constructs a GLTransaction out of a JDOM Element as defined in <a href=""http://jpos.org/minigl.dtd"">minigl.dtd</a>
 * @param elem '<entry>...</entry>' element.
 */
public GLTransaction(Element elem) throws ParseException {
  super();
  fromXML(elem);
}","/** 
 * Constructs a GLTransaction out of a JDOM Element as defined in <a href=""http://jpos.org/minigl.dtd"">minigl.dtd</a>
 * @param elem {@code '<entry>...</entry>}' element.
 */
public GLTransaction(Element elem) throws ParseException {
  super();
  fromXML(elem);
}",0.9848484848484848
150319,"/** 
 * Transactions should not be posted to this journal using a postDate <= the lockDate.
 * @lockDate lockDate the lock date.
 */
public void setLockDate(Date lockDate){
  this.lockDate=lockDate;
}","/** 
 * Transactions should not be posted to this journal using a postDate &lt;= the lockDate.
 * @param lockDate the lock date.
 */
public void setLockDate(Date lockDate){
  this.lockDate=lockDate;
}",0.955
150320,"/** 
 * Called <em>after</em> the FLUSH protocol has unblocked previously blocked senders, and messages can be sent again. This callback only needs to be implemented if we require a notification of that. <p/> <p/> Note that during new view installation we provide guarantee that unblock invocation strictly follows view installation at some node A belonging to that view . However, some other message M may squeeze in between view and unblock callbacks. <p/> For more details see https://jira.jboss.org/jira/browse/JGRP-986
 */
@Override public void unblock(){
}","/** 
 * Called <em>after</em> the FLUSH protocol has unblocked previously blocked senders, and messages can be sent again. This callback only needs to be implemented if we require a notification of that. <p> Note that during new view installation we provide guarantee that unblock invocation strictly follows view installation at some node A belonging to that view . However, some other message M may squeeze in between view and unblock callbacks. <p> For more details see https://jira.jboss.org/jira/browse/JGRP-986
 */
@Override public void unblock(){
}",0.5640107430617726
150321,"/** 
 * Computes expiration based on last tick + timeout
 * @return true if lasttick+timeout < current-time
 */
public boolean hasExpired(){
  long now=System.currentTimeMillis();
  Date lastTick=getLastTick();
  long timeout=getTimeout();
  if (lastTick == null || timeout == 0)   return false;
  long exp=lastTick.getTime() + timeout;
  return now > exp;
}","/** 
 * Computes expiration based on last tick + timeout
 * @return true if lasttick+timeout &lt; current-time
 */
public boolean hasExpired(){
  long now=System.currentTimeMillis();
  Date lastTick=getLastTick();
  long timeout=getTimeout();
  if (lastTick == null || timeout == 0)   return false;
  long exp=lastTick.getTime() + timeout;
  return now > exp;
}",0.9930458970792768
150322,"/** 
 * factory method used to create a RevisionEntry associated with this user.
 * @param summary information
 * @param detail detailed information
 * @param author change author
 */
public StatusRevision logRevision(String info,User author){
  StatusRevision re=new StatusRevision();
  re.setDate(new Date());
  re.setInfo(info);
  re.setStatus((Status)this);
  re.setAuthor(author);
  getRevisions().add(re);
  return re;
}","/** 
 * factory method used to create a RevisionEntry associated with this user.
 * @param info information<!-- @param detail detailed information -->
 * @param author change author
 */
public StatusRevision logRevision(String info,User author){
  StatusRevision re=new StatusRevision();
  re.setDate(new Date());
  re.setInfo(info);
  re.setStatus((Status)this);
  re.setAuthor(author);
  getRevisions().add(re);
  return re;
}",0.9461358313817332
150323,"/** 
 * @param key status name
 * @param state Status.OK, Status.WARN, Status.ERROR or user defined
 * @param info optional information
 */
public void touch(String key,String state) throws HibernateException, SQLException {
  touch(key,state,null);
}","/** 
 * @param key status name
 * @param state Status.OK, Status.WARN, Status.ERROR or user defined<!-- @param info optional information -->
 */
public void touch(String key,String state) throws HibernateException, SQLException {
  touch(key,state,null);
}",0.9783037475345168
150324,"/** 
 * check if unexpired status entries became expired, and create  appropriate syslog event.
 * @param id status id
 */
public void check() throws HibernateException, SQLException {
  Iterator iter=findByExpired(false).iterator();
  while (iter.hasNext()) {
    check((Status)iter.next());
  }
}","/** 
 * check if unexpired status entries became expired, and create  appropriate syslog event.
 */
public void check() throws HibernateException, SQLException {
  Iterator iter=findByExpired(false).iterator();
  while (iter.hasNext()) {
    check((Status)iter.next());
  }
}",0.9598603839441536
150325,"/** 
 * Hook method to let a subclass change the way the values are compared
 * @param i index of the property being compared in de ordergiven by the <code>properties<code> attribute.
 */
protected boolean equals(int i,Object v1,Object v2){
  if (v1 instanceof Comparable && v2 != null)   return ((Comparable)v1).compareTo(v2) == 0;
 else   if (v1 != null)   return v1.equals(v2);
 else   return v2 == null;
}","/** 
 * Hook method to let a subclass change the way the values are compared
 * @param i index of the property being compared in de ordergiven by the <code>properties</code> attribute.
 */
protected boolean equals(int i,Object v1,Object v2){
  if (v1 instanceof Comparable && v2 != null)   return ((Comparable)v1).compareTo(v2) == 0;
 else   if (v1 != null)   return v1.equals(v2);
 else   return v2 == null;
}",0.9987789987789988
150326,"/** 
 * Creates a JDOM Element as defined in <a href=""http://jpos.org/minigl.dtd"">minigl.dtd</a>
 */
public Element toXML(boolean deep){
  Element elem=new Element(""String_Node_Str"");
  elem.setAttribute(""String_Node_Str"",Long.toString(getId()));
  Util.setDateTimeAttribute(elem,""String_Node_Str"",getTimestamp());
  Util.setDateAttribute(elem,""String_Node_Str"",getPostDate());
  if (getDetail() != null) {
    Element detail=new Element(""String_Node_Str"").setText(getDetail());
    elem.addContent(detail);
  }
  if (getTags() != null) {
    Element tags=new Element(""String_Node_Str"").setText(getDetail());
    elem.addContent(tags);
  }
  elem.setAttribute(""String_Node_Str"",getJournal().getName());
  Iterator iter=getEntries().iterator();
  while (iter.hasNext()) {
    GLEntry entry=(GLEntry)iter.next();
    elem.addContent(entry.toXML(deep));
  }
  return elem;
}","/** 
 * Creates a JDOM Element as defined in <a href=""http://jpos.org/minigl.dtd"">minigl.dtd</a>
 */
public Element toXML(boolean deep){
  Element elem=new Element(""String_Node_Str"");
  elem.setAttribute(""String_Node_Str"",Long.toString(getId()));
  Util.setDateTimeAttribute(elem,""String_Node_Str"",getTimestamp());
  Util.setDateAttribute(elem,""String_Node_Str"",getPostDate());
  if (getDetail() != null) {
    Element detail=new Element(""String_Node_Str"").setText(getDetail());
    elem.addContent(detail);
  }
  if (getTags() != null) {
    Element tags=new Element(""String_Node_Str"").setText(getTags());
    elem.addContent(tags);
  }
  elem.setAttribute(""String_Node_Str"",getJournal().getName());
  Iterator iter=getEntries().iterator();
  while (iter.hasNext()) {
    GLEntry entry=(GLEntry)iter.next();
    elem.addContent(entry.toXML(deep));
  }
  return elem;
}",0.9942528735632185
150327,"public String toString(){
  return new ToStringBuilder(this).append(""String_Node_Str"",getId()).append(""String_Node_Str"",getId()).toString();
}","public String toString(){
  return new ToStringBuilder(this).append(""String_Node_Str"",getId()).append(""String_Node_Str"",getDetail()).toString();
}",0.9722222222222222
150328,"@Override public void start(final Environment env) throws IOException {
  TtyFilterOutputStream out=new TtyFilterOutputStream(this.out);
  TtyFilterOutputStream err=new TtyFilterOutputStream(this.err);
  final Groovysh shell=new Groovysh(createBinding(bindings,out,err),new IO(in,out,err));
  loadDefaultScripts(shell);
  String threadName=""String_Node_Str"";
  wrapper=new Thread(new Runnable(){
    @Override public void run(){
      try {
        SshTerminal.registerEnvironment(env);
        shell.run();
        callback.onExit(0);
      }
 catch (      RuntimeException e) {
        callback.onExit(-1,e.getMessage());
      }
catch (      Error e) {
        callback.onExit(-1,e.getMessage());
      }
    }
  }
,threadName);
  wrapper.start();
}","@Override public void start(final Environment env) throws IOException {
  TtyFilterOutputStream out=new TtyFilterOutputStream(this.out);
  TtyFilterOutputStream err=new TtyFilterOutputStream(this.err);
  final Groovysh shell=new Groovysh(createBinding(bindings,out,err),new IO(in,out,err));
  try {
    loadDefaultScripts(shell);
  }
 catch (  Exception e) {
    createPrintStream(err).println(""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
  }
  String threadName=""String_Node_Str"";
  wrapper=new Thread(new Runnable(){
    @Override public void run(){
      try {
        SshTerminal.registerEnvironment(env);
        shell.run();
        callback.onExit(0);
      }
 catch (      RuntimeException e) {
        callback.onExit(-1,e.getMessage());
      }
catch (      Error e) {
        callback.onExit(-1,e.getMessage());
      }
    }
  }
,threadName);
  wrapper.start();
}",0.9043896572459412
150329,"private Binding createBinding(Map<String,Object> objects,OutputStream out,OutputStream err) throws UnsupportedEncodingException {
  Binding binding=new Binding();
  if (objects != null)   for (  Map.Entry<String,Object> row : objects.entrySet())   binding.setVariable(row.getKey(),row.getValue());
  binding.setVariable(""String_Node_Str"",new PrintStream(out,true,""String_Node_Str""));
  binding.setVariable(""String_Node_Str"",new PrintStream(err,true,""String_Node_Str""));
  binding.setVariable(""String_Node_Str"",new Closure<List<AbstractSession>>(this){
    @Override public List<AbstractSession> call(){
      return sshd.getActiveSessions();
    }
  }
);
  return binding;
}","private Binding createBinding(Map<String,Object> objects,OutputStream out,OutputStream err) throws UnsupportedEncodingException {
  Binding binding=new Binding();
  if (objects != null)   for (  Map.Entry<String,Object> row : objects.entrySet())   binding.setVariable(row.getKey(),row.getValue());
  binding.setVariable(""String_Node_Str"",createPrintStream(out));
  binding.setVariable(""String_Node_Str"",createPrintStream(err));
  binding.setVariable(""String_Node_Str"",new Closure<List<AbstractSession>>(this){
    @Override public List<AbstractSession> call(){
      return sshd.getActiveSessions();
    }
  }
);
  return binding;
}",0.9081163859111792
150330,"/** 
 * Set the comma delimited list of default scripts
 * @param scriptNames script names
 */
public void setDefaultScriptNames(String scriptNames){
  service.setDefaultScripts(asList(scriptNames.split(""String_Node_Str"")));
}","/** 
 * Set the comma delimited list of default scripts
 * @param scriptNames script names
 */
public void setDefaultScriptNames(String scriptNames){
  if (!scriptNames.trim().isEmpty())   service.setDefaultScripts(asList(scriptNames.split(""String_Node_Str"")));
}",0.9243353783231084
150331,"@Override public void start(final Environment env) throws IOException {
  TtyFilterOutputStream out=new TtyFilterOutputStream(this.out);
  TtyFilterOutputStream err=new TtyFilterOutputStream(this.err);
  final Groovysh shell=new Groovysh(createBinding(bindings,out,err),new IO(in,out,err));
  try {
    loadDefaultScripts(shell);
  }
 catch (  Exception e) {
    createPrintStream(err).println(""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
  }
  String threadName=""String_Node_Str"";
  wrapper=new Thread(new Runnable(){
    @Override public void run(){
      try {
        SshTerminal.registerEnvironment(env);
        shell.run();
        callback.onExit(0);
      }
 catch (      RuntimeException e) {
        callback.onExit(-1,e.getMessage());
      }
catch (      Error e) {
        callback.onExit(-1,e.getMessage());
      }
    }
  }
,threadName);
  wrapper.start();
}","@Override public void start(final Environment env) throws IOException {
  TtyFilterOutputStream out=new TtyFilterOutputStream(this.out);
  TtyFilterOutputStream err=new TtyFilterOutputStream(this.err);
  IO io=new IO(in,out,err);
  io.setVerbosity(IO.Verbosity.DEBUG);
  final Groovysh shell=new Groovysh(createBinding(bindings,out,err),io);
  shell.setErrorHook(new Closure(this){
    @Override public Object call(    Object... args){
      if (args[0] instanceof InterruptedIOException || args[0] instanceof SshException) {
        shell.getRunner().setRunning(false);
      }
      return shell.getDefaultErrorHook().call(args);
    }
  }
);
  try {
    loadDefaultScripts(shell);
  }
 catch (  Exception e) {
    createPrintStream(err).println(""String_Node_Str"" + e.getClass().getName() + ""String_Node_Str""+ e.getMessage());
  }
  session.setAttribute(SHELL_KEY,shell);
  String threadName=""String_Node_Str"" + session.getIoSession().getRemoteAddress().toString();
  wrapper=new Thread(new Runnable(){
    @Override public void run(){
      try {
        SshTerminal.registerEnvironment(env);
        shell.run();
        callback.onExit(0);
      }
 catch (      RuntimeException e) {
        callback.onExit(-1,e.getMessage());
      }
catch (      Error e) {
        callback.onExit(-1,e.getMessage());
      }
    }
  }
,threadName);
  wrapper.start();
}",0.5589788732394366
150332,"/** 
 * Starts Groovysh
 * @throws IOException thrown if socket cannot be opened
 */
public synchronized void start() throws IOException {
  sshd=SshServer.setUpDefaultServer();
  sshd.setPort(port);
  sshd.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(""String_Node_Str""));
  NamedFactory<UserAuth> a=new UserAuthNone.Factory();
  sshd.setUserAuthFactories(asList(a));
  sshd.setShellFactory(new GroovyShellFactory());
  sshd.start();
}","/** 
 * Starts Groovysh
 * @throws IOException thrown if socket cannot be opened
 */
public synchronized void start() throws IOException {
  sshd=SshServer.setUpDefaultServer();
  sshd.setPort(port);
  Map<String,String> properties=new HashMap<String,String>();
  properties.put(ServerFactoryManager.IDLE_TIMEOUT,""String_Node_Str"");
  sshd.setProperties(properties);
  SessionFactory sessionFactory=new SessionFactory();
  sessionFactory.addListener(new SessionListener(){
    @Override public void sessionCreated(    Session session){
    }
    @Override public void sessionEvent(    Session sesssion,    Event event){
    }
    @Override public void sessionClosed(    Session session){
      Groovysh shell=session.getAttribute(SHELL_KEY);
      if (shell != null)       shell.getRunner().setRunning(false);
    }
  }
);
  sshd.setSessionFactory(sessionFactory);
  sshd.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(""String_Node_Str""));
  NamedFactory<UserAuth> a=new UserAuthNone.Factory();
  sshd.setUserAuthFactories(asList(a));
  sshd.setShellFactory(new GroovyShellFactory());
  sshd.start();
}",0.5022537025112686
150333,"@Override protected void executeWithTarget(Server server,String message,String target,CommandFeedback feedback){
  mute(server,name);
  server.adminLog(""String_Node_Str"" + name);
  feedback.send(""String_Node_Str"",target);
}","@Override protected void executeWithTarget(Server server,String message,String target,CommandFeedback feedback){
  unmute(server,target);
  server.adminLog(""String_Node_Str"" + target);
  feedback.send(""String_Node_Str"",target);
}",0.9026548672566372
150334,"protected void handlePacket(byte packetId) throws IOException {
switch (packetId) {
case 0x2:
    readUTF16();
  login();
break;
case 0x1:
in.readInt();
readUTF16();
in.readLong();
in.readInt();
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readByte();
break;
case 0x0d:
double x=in.readDouble();
double stance=in.readDouble();
double y=in.readDouble();
double z=in.readDouble();
float yaw=in.readFloat();
float pitch=in.readFloat();
boolean onGround=in.readBoolean();
position.updatePosition(x,y,z,stance);
position.updateLook(yaw,pitch);
position.updateGround(onGround);
if (!ready) {
sendPosition();
ready();
}
 else if (dead) {
sendPosition();
dead=false;
}
positionUpdate();
break;
case 0x0b:
double x2=in.readDouble();
double stance2=in.readDouble();
double y2=in.readDouble();
double z2=in.readDouble();
boolean onGround2=in.readBoolean();
position.updatePosition(x2,y2,z2,stance2);
position.updateGround(onGround2);
positionUpdate();
break;
case (byte)0xff:
String reason=readUTF16();
error(reason);
break;
case 0x00:
keepAlive(in.readInt());
break;
case 0x03:
readUTF16();
break;
case 0x04:
in.readLong();
break;
case 0x05:
in.readInt();
in.readShort();
in.readShort();
in.readShort();
break;
case 0x06:
readNBytes(12);
break;
case 0x07:
in.readInt();
in.readInt();
in.readBoolean();
in.readBoolean();
break;
case 0x08:
health=in.readShort();
in.readShort();
in.readFloat();
if (health <= 0) {
dead=true;
respawn();
}
break;
case 0x09:
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readShort();
in.readLong();
break;
case 0x0a:
in.readByte();
break;
case 0x0c:
readNBytes(9);
break;
case 0x0e:
in.readByte();
in.readInt();
in.readByte();
in.readInt();
in.readByte();
break;
case 0x0f:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
readItem();
break;
case 0x10:
readNBytes(2);
break;
case 0x11:
readNBytes(14);
break;
case 0x12:
readNBytes(5);
break;
case 0x13:
in.readInt();
in.readByte();
break;
case 0x14:
in.readInt();
readUTF16();
readNBytes(16);
break;
case 0x15:
readNBytes(24);
break;
case 0x16:
readNBytes(8);
break;
case 0x17:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
int flag=in.readInt();
if (flag > 0) {
in.readShort();
in.readShort();
in.readShort();
}
break;
case 0x18:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
in.readByte();
in.readByte();
readUnknownBlob();
break;
case 0x19:
in.readInt();
readUTF16();
in.readInt();
in.readInt();
in.readInt();
in.readInt();
break;
case 0x1a:
in.readInt();
in.readInt();
in.readInt();
in.readInt();
in.readShort();
break;
case 0x1c:
readNBytes(10);
break;
case 0x1d:
readNBytes(4);
break;
case 0x1e:
readNBytes(4);
break;
case 0x1f:
readNBytes(7);
break;
case 0x20:
readNBytes(6);
break;
case 0x21:
readNBytes(9);
break;
case 0x22:
readNBytes(18);
break;
case 0x26:
readNBytes(5);
break;
case 0x27:
readNBytes(8);
break;
case 0x28:
in.readInt();
readUnknownBlob();
break;
case 0x29:
in.readInt();
in.readByte();
in.readByte();
in.readShort();
break;
case 0x2a:
in.readInt();
in.readByte();
break;
case 0x2b:
in.readFloat();
in.readShort();
in.readShort();
break;
case 0x32:
readNBytes(9);
break;
case 0x33:
readNBytes(13);
int chunkSize=in.readInt();
readNBytes(chunkSize);
break;
case 0x34:
readNBytes(8);
short arraySize=in.readShort();
readNBytes(arraySize * 4);
break;
case 0x35:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
in.readByte();
break;
case 0x36:
readNBytes(12);
break;
case 0x3c:
readNBytes(28);
int recordCount=in.readInt();
readNBytes(recordCount * 3);
break;
case 0x3d:
in.readInt();
in.readInt();
in.readByte();
in.readInt();
in.readInt();
break;
case 0x46:
readNBytes(2);
break;
case 0x47:
readNBytes(17);
break;
case 0x64:
in.readByte();
in.readByte();
readUTF16();
in.readByte();
break;
case 0x65:
in.readByte();
break;
case 0x66:
in.readByte();
in.readShort();
in.readByte();
in.readShort();
in.readBoolean();
readItem();
break;
case 0x67:
in.readByte();
in.readShort();
readItem();
break;
case 0x68:
in.readByte();
short count=in.readShort();
for (int c=0; c < count; ++c) {
readItem();
}
break;
case 0x69:
in.readByte();
in.readShort();
in.readShort();
break;
case 0x6a:
in.readByte();
in.readShort();
in.readByte();
break;
case 0x6b:
in.readShort();
readItem();
break;
case (byte)0x6c:
readNBytes(2);
break;
case (byte)0x82:
in.readInt();
in.readShort();
in.readInt();
readUTF16();
readUTF16();
readUTF16();
readUTF16();
break;
case (byte)0x83:
in.readShort();
in.readShort();
byte length=in.readByte();
readNBytes(0xff & length);
break;
case (byte)0xc8:
readNBytes(5);
break;
case (byte)0xc9:
readUTF16();
in.readBoolean();
in.readShort();
break;
case (byte)0xe6:
in.readInt();
in.readInt();
readNBytes(in.readInt() * 4);
readNBytes(in.readInt() * 4);
int sizeString=in.readInt();
for (int i=0; i < sizeString; i++) {
readNBytes(in.readInt());
}
break;
case (byte)0xfa:
readUTF16();
short arrayLength=in.readShort();
readNBytes(0xff & arrayLength);
break;
case (byte)0xfe:
break;
default :
error(""String_Node_Str"" + Integer.toHexString(packetId) + ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
lastPacket=packetId;
}","protected void handlePacket(byte packetId) throws IOException {
switch (packetId) {
case 0x2:
    readUTF16();
  login();
break;
case 0x1:
in.readInt();
readUTF16();
in.readLong();
readUTF16();
in.readInt();
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readByte();
break;
case 0x0d:
double x=in.readDouble();
double stance=in.readDouble();
double y=in.readDouble();
double z=in.readDouble();
float yaw=in.readFloat();
float pitch=in.readFloat();
boolean onGround=in.readBoolean();
position.updatePosition(x,y,z,stance);
position.updateLook(yaw,pitch);
position.updateGround(onGround);
if (!ready) {
sendPosition();
ready();
}
 else if (dead) {
sendPosition();
dead=false;
}
positionUpdate();
break;
case 0x0b:
double x2=in.readDouble();
double stance2=in.readDouble();
double y2=in.readDouble();
double z2=in.readDouble();
boolean onGround2=in.readBoolean();
position.updatePosition(x2,y2,z2,stance2);
position.updateGround(onGround2);
positionUpdate();
break;
case (byte)0xff:
String reason=readUTF16();
error(reason);
break;
case 0x00:
keepAlive(in.readInt());
break;
case 0x03:
readUTF16();
break;
case 0x04:
in.readLong();
break;
case 0x05:
in.readInt();
in.readShort();
in.readShort();
in.readShort();
break;
case 0x06:
readNBytes(12);
break;
case 0x07:
in.readInt();
in.readInt();
in.readBoolean();
in.readBoolean();
break;
case 0x08:
health=in.readShort();
in.readShort();
in.readFloat();
if (health <= 0) {
dead=true;
respawn();
}
break;
case 0x09:
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readShort();
in.readLong();
readUTF16();
break;
case 0x0a:
in.readByte();
break;
case 0x0c:
readNBytes(9);
break;
case 0x0e:
in.readByte();
in.readInt();
in.readByte();
in.readInt();
in.readByte();
break;
case 0x0f:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
readItem();
break;
case 0x10:
readNBytes(2);
break;
case 0x11:
readNBytes(14);
break;
case 0x12:
readNBytes(5);
break;
case 0x13:
in.readInt();
in.readByte();
break;
case 0x14:
in.readInt();
readUTF16();
readNBytes(16);
break;
case 0x15:
readNBytes(24);
break;
case 0x16:
readNBytes(8);
break;
case 0x17:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
int flag=in.readInt();
if (flag > 0) {
in.readShort();
in.readShort();
in.readShort();
}
break;
case 0x18:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
in.readByte();
in.readByte();
readUnknownBlob();
break;
case 0x19:
in.readInt();
readUTF16();
in.readInt();
in.readInt();
in.readInt();
in.readInt();
break;
case 0x1a:
in.readInt();
in.readInt();
in.readInt();
in.readInt();
in.readShort();
break;
case 0x1c:
readNBytes(10);
break;
case 0x1d:
readNBytes(4);
break;
case 0x1e:
readNBytes(4);
break;
case 0x1f:
readNBytes(7);
break;
case 0x20:
readNBytes(6);
break;
case 0x21:
readNBytes(9);
break;
case 0x22:
readNBytes(18);
break;
case 0x26:
readNBytes(5);
break;
case 0x27:
readNBytes(8);
break;
case 0x28:
in.readInt();
readUnknownBlob();
break;
case 0x29:
in.readInt();
in.readByte();
in.readByte();
in.readShort();
break;
case 0x2a:
in.readInt();
in.readByte();
break;
case 0x2b:
in.readFloat();
in.readShort();
in.readShort();
break;
case 0x32:
readNBytes(9);
break;
case 0x33:
readNBytes(13);
int chunkSize=in.readInt();
readNBytes(chunkSize);
break;
case 0x34:
readNBytes(8);
short arraySize=in.readShort();
readNBytes(arraySize * 4);
break;
case 0x35:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
in.readByte();
break;
case 0x36:
readNBytes(12);
break;
case 0x3c:
readNBytes(28);
int recordCount=in.readInt();
readNBytes(recordCount * 3);
break;
case 0x3d:
in.readInt();
in.readInt();
in.readByte();
in.readInt();
in.readInt();
break;
case 0x46:
readNBytes(2);
break;
case 0x47:
readNBytes(17);
break;
case 0x64:
in.readByte();
in.readByte();
readUTF16();
in.readByte();
break;
case 0x65:
in.readByte();
break;
case 0x66:
in.readByte();
in.readShort();
in.readByte();
in.readShort();
in.readBoolean();
readItem();
break;
case 0x67:
in.readByte();
in.readShort();
readItem();
break;
case 0x68:
in.readByte();
short count=in.readShort();
for (int c=0; c < count; ++c) {
readItem();
}
break;
case 0x69:
in.readByte();
in.readShort();
in.readShort();
break;
case 0x6a:
in.readByte();
in.readShort();
in.readByte();
break;
case 0x6b:
in.readShort();
readItem();
break;
case (byte)0x6c:
readNBytes(2);
break;
case (byte)0x82:
in.readInt();
in.readShort();
in.readInt();
readUTF16();
readUTF16();
readUTF16();
readUTF16();
break;
case (byte)0x83:
in.readShort();
in.readShort();
byte length=in.readByte();
readNBytes(0xff & length);
break;
case (byte)0xc8:
readNBytes(5);
break;
case (byte)0xc9:
readUTF16();
in.readBoolean();
in.readShort();
break;
case (byte)0xe6:
in.readInt();
in.readInt();
readNBytes(in.readInt() * 4);
readNBytes(in.readInt() * 4);
int sizeString=in.readInt();
for (int i=0; i < sizeString; i++) {
readNBytes(in.readInt());
}
break;
case (byte)0xfa:
readUTF16();
short arrayLength=in.readShort();
readNBytes(0xff & arrayLength);
break;
case (byte)0xfe:
break;
default :
error(""String_Node_Str"" + Integer.toHexString(packetId) + ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
lastPacket=packetId;
}",0.4326514859127749
150335,"@Override void setAttribute(String name,String value) throws SAXException {
  if (name.equals(""String_Node_Str"")) {
    allow=new Permission(value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    argument=value;
  }
}","@Override void setAttribute(String name,String value) throws SAXException {
  if (name.equals(""String_Node_Str"")) {
    allow=new Permission(value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    content(value);
  }
}",0.9375
150336,"public void execute(Player player,String message){
  int[] maxSize=getAreaMax(player);
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTCaptionedMessage(""String_Node_Str"",commandPrefix() + ""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    if (!areaSizeOk(player,maxSize)) {
      player.addTMessage(Color.RED,""String_Node_Str"" + maxSize[0] + ""String_Node_Str""+ maxSize[1]+ ""String_Node_Str"");
      return;
    }
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"") || arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.getServer().saveConfig();
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      player.getServer().saveConfig();
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}","public void execute(Player player,String message){
  int[] maxSize=getAreaMax(player);
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTCaptionedMessage(""String_Node_Str"",commandPrefix() + ""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player,maxSize)) {
      player.addTMessage(Color.RED,""String_Node_Str"" + maxSize[0] + ""String_Node_Str""+ maxSize[1]+ ""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"") || arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.getServer().saveConfig();
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      player.getServer().saveConfig();
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}",0.9347746427262732
150337,"private void respawn() throws IOException {
  writeLock.lock();
  out.writeByte(9);
  out.writeByte(position.dimension.index());
  out.writeByte(0);
  out.writeShort(128);
  out.writeLong(0);
  writeLock.unlock();
}","private void respawn() throws IOException {
  writeLock.lock();
  out.writeByte(9);
  out.writeByte(position.dimension.index());
  out.writeByte(0);
  out.writeShort(128);
  out.writeLong(0);
  write(readUTF16());
  writeLock.unlock();
}",0.9513274336283186
150338,"protected void handlePacket(byte packetId) throws IOException {
switch (packetId) {
case 0x2:
    readUTF16();
  login();
break;
case 0x1:
in.readInt();
readUTF16();
in.readLong();
in.readInt();
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readByte();
break;
case 0x0d:
double x=in.readDouble();
double stance=in.readDouble();
double y=in.readDouble();
double z=in.readDouble();
float yaw=in.readFloat();
float pitch=in.readFloat();
boolean onGround=in.readBoolean();
position.updatePosition(x,y,z,stance);
position.updateLook(yaw,pitch);
position.updateGround(onGround);
if (!ready) {
sendPosition();
ready();
}
 else if (dead) {
sendPosition();
dead=false;
}
positionUpdate();
break;
case 0x0b:
double x2=in.readDouble();
double stance2=in.readDouble();
double y2=in.readDouble();
double z2=in.readDouble();
boolean onGround2=in.readBoolean();
position.updatePosition(x2,y2,z2,stance2);
position.updateGround(onGround2);
positionUpdate();
break;
case (byte)0xff:
String reason=readUTF16();
error(reason);
break;
case 0x00:
keepAlive(in.readInt());
break;
case 0x03:
readUTF16();
break;
case 0x04:
in.readLong();
break;
case 0x05:
in.readInt();
in.readShort();
in.readShort();
in.readShort();
break;
case 0x06:
readNBytes(12);
break;
case 0x07:
in.readInt();
in.readInt();
in.readBoolean();
in.readBoolean();
break;
case 0x08:
health=in.readShort();
in.readShort();
in.readFloat();
if (health <= 0) {
dead=true;
respawn();
}
break;
case 0x09:
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readShort();
in.readLong();
break;
case 0x0a:
in.readByte();
break;
case 0x0c:
readNBytes(9);
break;
case 0x0e:
in.readByte();
in.readInt();
in.readByte();
in.readInt();
in.readByte();
break;
case 0x0f:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
readItem();
break;
case 0x10:
readNBytes(2);
break;
case 0x11:
readNBytes(14);
break;
case 0x12:
readNBytes(5);
break;
case 0x13:
in.readInt();
in.readByte();
break;
case 0x14:
in.readInt();
readUTF16();
readNBytes(16);
break;
case 0x15:
readNBytes(24);
break;
case 0x16:
readNBytes(8);
break;
case 0x17:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
int flag=in.readInt();
if (flag > 0) {
in.readShort();
in.readShort();
in.readShort();
}
break;
case 0x18:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
in.readByte();
in.readByte();
readUnknownBlob();
break;
case 0x19:
in.readInt();
readUTF16();
in.readInt();
in.readInt();
in.readInt();
in.readInt();
break;
case 0x1a:
in.readInt();
in.readInt();
in.readInt();
in.readInt();
in.readShort();
break;
case 0x1b:
readNBytes(18);
break;
case 0x1c:
readNBytes(10);
break;
case 0x1d:
readNBytes(4);
break;
case 0x1e:
readNBytes(4);
break;
case 0x1f:
readNBytes(7);
break;
case 0x20:
readNBytes(6);
break;
case 0x21:
readNBytes(9);
break;
case 0x22:
readNBytes(18);
break;
case 0x26:
readNBytes(5);
break;
case 0x27:
readNBytes(8);
break;
case 0x28:
in.readInt();
readUnknownBlob();
break;
case 0x29:
in.readInt();
in.readByte();
in.readByte();
in.readShort();
break;
case 0x2a:
in.readInt();
in.readByte();
break;
case 0x2b:
in.readFloat();
in.readShort();
in.readShort();
break;
case 0x32:
readNBytes(9);
break;
case 0x33:
readNBytes(13);
int chunkSize=in.readInt();
readNBytes(chunkSize);
break;
case 0x34:
readNBytes(8);
short arraySize=in.readShort();
readNBytes(arraySize * 4);
break;
case 0x35:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
in.readByte();
break;
case 0x36:
readNBytes(12);
break;
case 0x3c:
readNBytes(28);
int recordCount=in.readInt();
readNBytes(recordCount * 3);
break;
case 0x3d:
in.readInt();
in.readInt();
in.readByte();
in.readInt();
in.readInt();
break;
case 0x46:
readNBytes(2);
break;
case 0x47:
readNBytes(17);
break;
case 0x64:
in.readByte();
in.readByte();
readUTF16();
in.readByte();
break;
case 0x65:
in.readByte();
break;
case 0x66:
in.readByte();
in.readShort();
in.readByte();
in.readShort();
in.readBoolean();
readItem();
break;
case 0x67:
in.readByte();
in.readShort();
readItem();
break;
case 0x68:
in.readByte();
short count=in.readShort();
for (int c=0; c < count; ++c) {
readItem();
}
break;
case 0x69:
in.readByte();
in.readShort();
in.readShort();
break;
case 0x6a:
in.readByte();
in.readShort();
in.readByte();
break;
case 0x6b:
in.readShort();
readItem();
break;
case (byte)0x6c:
readNBytes(2);
break;
case (byte)0x82:
in.readInt();
in.readShort();
in.readInt();
readUTF16();
readUTF16();
readUTF16();
readUTF16();
break;
case (byte)0x83:
in.readShort();
in.readShort();
byte length=in.readByte();
readNBytes(0xff & length);
break;
case (byte)0xc8:
readNBytes(5);
break;
case (byte)0xc9:
readUTF16();
in.readBoolean();
in.readShort();
break;
case (byte)0xe6:
in.readInt();
in.readInt();
readNBytes(in.readInt() * 4);
readNBytes(in.readInt() * 4);
int sizeString=in.readInt();
for (int i=0; i < sizeString; i++) {
readNBytes(in.readInt());
}
break;
case (byte)0xfe:
break;
default :
error(""String_Node_Str"" + Integer.toHexString(packetId) + ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
lastPacket=packetId;
}","protected void handlePacket(byte packetId) throws IOException {
switch (packetId) {
case 0x2:
    readUTF16();
  login();
break;
case 0x1:
in.readInt();
readUTF16();
in.readLong();
in.readInt();
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readByte();
break;
case 0x0d:
double x=in.readDouble();
double stance=in.readDouble();
double y=in.readDouble();
double z=in.readDouble();
float yaw=in.readFloat();
float pitch=in.readFloat();
boolean onGround=in.readBoolean();
position.updatePosition(x,y,z,stance);
position.updateLook(yaw,pitch);
position.updateGround(onGround);
if (!ready) {
sendPosition();
ready();
}
 else if (dead) {
sendPosition();
dead=false;
}
positionUpdate();
break;
case 0x0b:
double x2=in.readDouble();
double stance2=in.readDouble();
double y2=in.readDouble();
double z2=in.readDouble();
boolean onGround2=in.readBoolean();
position.updatePosition(x2,y2,z2,stance2);
position.updateGround(onGround2);
positionUpdate();
break;
case (byte)0xff:
String reason=readUTF16();
error(reason);
break;
case 0x00:
keepAlive(in.readInt());
break;
case 0x03:
readUTF16();
break;
case 0x04:
in.readLong();
break;
case 0x05:
in.readInt();
in.readShort();
in.readShort();
in.readShort();
break;
case 0x06:
readNBytes(12);
break;
case 0x07:
in.readInt();
in.readInt();
in.readBoolean();
in.readBoolean();
break;
case 0x08:
health=in.readShort();
in.readShort();
in.readFloat();
if (health <= 0) {
dead=true;
respawn();
}
break;
case 0x09:
position.dimension=Dimension.get(in.readByte());
in.readByte();
in.readByte();
in.readShort();
in.readLong();
break;
case 0x0a:
in.readByte();
break;
case 0x0c:
readNBytes(9);
break;
case 0x0e:
in.readByte();
in.readInt();
in.readByte();
in.readInt();
in.readByte();
break;
case 0x0f:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
readItem();
break;
case 0x10:
readNBytes(2);
break;
case 0x11:
readNBytes(14);
break;
case 0x12:
readNBytes(5);
break;
case 0x13:
in.readInt();
in.readByte();
break;
case 0x14:
in.readInt();
readUTF16();
readNBytes(16);
break;
case 0x15:
readNBytes(24);
break;
case 0x16:
readNBytes(8);
break;
case 0x17:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
int flag=in.readInt();
if (flag > 0) {
in.readShort();
in.readShort();
in.readShort();
}
break;
case 0x18:
in.readInt();
in.readByte();
in.readInt();
in.readInt();
in.readInt();
in.readByte();
in.readByte();
readUnknownBlob();
break;
case 0x19:
in.readInt();
readUTF16();
in.readInt();
in.readInt();
in.readInt();
in.readInt();
break;
case 0x1a:
in.readInt();
in.readInt();
in.readInt();
in.readInt();
in.readShort();
break;
case 0x1c:
readNBytes(10);
break;
case 0x1d:
readNBytes(4);
break;
case 0x1e:
readNBytes(4);
break;
case 0x1f:
readNBytes(7);
break;
case 0x20:
readNBytes(6);
break;
case 0x21:
readNBytes(9);
break;
case 0x22:
readNBytes(18);
break;
case 0x26:
readNBytes(5);
break;
case 0x27:
readNBytes(8);
break;
case 0x28:
in.readInt();
readUnknownBlob();
break;
case 0x29:
in.readInt();
in.readByte();
in.readByte();
in.readShort();
break;
case 0x2a:
in.readInt();
in.readByte();
break;
case 0x2b:
in.readFloat();
in.readShort();
in.readShort();
break;
case 0x32:
readNBytes(9);
break;
case 0x33:
readNBytes(13);
int chunkSize=in.readInt();
readNBytes(chunkSize);
break;
case 0x34:
readNBytes(8);
short arraySize=in.readShort();
readNBytes(arraySize * 4);
break;
case 0x35:
in.readInt();
in.readByte();
in.readInt();
in.readByte();
in.readByte();
break;
case 0x36:
readNBytes(12);
break;
case 0x3c:
readNBytes(28);
int recordCount=in.readInt();
readNBytes(recordCount * 3);
break;
case 0x3d:
in.readInt();
in.readInt();
in.readByte();
in.readInt();
in.readInt();
break;
case 0x46:
readNBytes(2);
break;
case 0x47:
readNBytes(17);
break;
case 0x64:
in.readByte();
in.readByte();
readUTF16();
in.readByte();
break;
case 0x65:
in.readByte();
break;
case 0x66:
in.readByte();
in.readShort();
in.readByte();
in.readShort();
in.readBoolean();
readItem();
break;
case 0x67:
in.readByte();
in.readShort();
readItem();
break;
case 0x68:
in.readByte();
short count=in.readShort();
for (int c=0; c < count; ++c) {
readItem();
}
break;
case 0x69:
in.readByte();
in.readShort();
in.readShort();
break;
case 0x6a:
in.readByte();
in.readShort();
in.readByte();
break;
case 0x6b:
in.readShort();
readItem();
break;
case (byte)0x6c:
readNBytes(2);
break;
case (byte)0x82:
in.readInt();
in.readShort();
in.readInt();
readUTF16();
readUTF16();
readUTF16();
readUTF16();
break;
case (byte)0x83:
in.readShort();
in.readShort();
byte length=in.readByte();
readNBytes(0xff & length);
break;
case (byte)0xc8:
readNBytes(5);
break;
case (byte)0xc9:
readUTF16();
in.readBoolean();
in.readShort();
break;
case (byte)0xe6:
in.readInt();
in.readInt();
readNBytes(in.readInt() * 4);
readNBytes(in.readInt() * 4);
int sizeString=in.readInt();
for (int i=0; i < sizeString; i++) {
readNBytes(in.readInt());
}
break;
case (byte)0xfa:
readUTF16();
short arrayLength=in.readShort();
readNBytes(0xff & arrayLength);
break;
case (byte)0xfe:
break;
default :
error(""String_Node_Str"" + Integer.toHexString(packetId) + ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
lastPacket=packetId;
}",0.9866588762294284
150339,"protected void login() throws IOException {
  writeLock.lock();
  out.writeByte(1);
  out.writeInt(VERSION);
  write(name);
  out.writeLong(0);
  out.writeInt(0);
  out.writeByte(0);
  out.writeByte(0);
  out.writeByte(0);
  out.writeByte(0);
  writeLock.unlock();
}","protected void login() throws IOException {
  writeLock.lock();
  out.writeByte(1);
  out.writeInt(VERSION);
  write(name);
  out.writeLong(0);
  write(readUTF16());
  out.writeInt(0);
  out.writeByte(0);
  out.writeByte(0);
  out.writeByte(0);
  out.writeByte(0);
  writeLock.unlock();
}",0.96028880866426
150340,"@Override public void save(){
  load();
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  super.save();
}","@Override public void save(){
  load();
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  super.save();
}",0.9681528662420382
150341,"public Area(String name,Coordinate start,Coordinate end){
  this();
  this.name=name;
  this.start=start;
  this.end=end;
  position=Integer.MAX_VALUE;
  level=0;
  init();
  finish();
}","public Area(String name,Coordinate start,Coordinate end){
  this();
  this.name=name;
  this.start=start;
  this.end=end;
  position=Integer.MAX_VALUE;
  level=0;
  init();
  super.finish();
}",0.984126984126984
150342,"public void execute(Player player,String message){
  String name=extractArgument(message);
  if (name == null) {
    if (player.isAttemptLock()) {
      player.setAttemptedAction(null);
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
  }
  if (name != null && name.equals(""String_Node_Str"")) {
    Map<String,Integer> list=player.getServer().data.chests.chestList(player);
    if (list.size() == 0) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      for (      String current : list.keySet()) {
        player.addMessage(Color.GRAY,list.get(current) + ""String_Node_Str"" + current);
      }
    }
  }
 else {
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.setAttemptedAction(Action.Lock);
    player.setChestName(name);
  }
}","public void execute(Player player,String message){
  String name=extractArgument(message);
  if (name == null) {
    if (player.isAttemptLock()) {
      player.setAttemptedAction(null);
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
  }
  if (name != null && name.equals(""String_Node_Str"")) {
    Map<String,Integer> list=player.getServer().data.chests.chestList(player);
    if (list.size() == 0) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      for (      String current : list.keySet()) {
        player.addMessage(Color.GRAY,list.get(current) + ""String_Node_Str"" + current);
      }
    }
  }
 else {
    if (name != null && name.length() > 16) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.setAttemptedAction(Action.Lock);
    player.setChestName(name);
  }
}",0.9337712096332786
150343,"public void execute(Player player,String message){
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTCaptionedMessage(""String_Node_Str"",commandPrefix() + ""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}","public void execute(Player player,String message){
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTCaptionedMessage(""String_Node_Str"",commandPrefix() + ""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"") || arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.getServer().saveConfig();
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      player.getServer().saveConfig();
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}",0.9769711163153786
150344,"public void add(Area area){
  topAreas.add(area);
  areas.add(area);
}","public void add(Area area){
  topAreas.add(area);
}",0.8429752066115702
150345,"public boolean parseCommand(String message){
  if (closed) {
    return true;
  }
  if (message.equals(server.getCommandParser().commandPrefix() + ""String_Node_Str"")) {
    message=lastCommand;
  }
 else {
    lastCommand=message;
  }
  String commandName=message.split(""String_Node_Str"")[0];
  String args=message.substring(commandName.length() + 1);
  CommandConfig config=server.config.commands.getTopConfig(commandName);
  String originalName=config == null ? commandName : config.originalName;
  PlayerCommand command;
  if (config == null) {
    command=server.getCommandParser().getPlayerCommand(commandName);
    if (command != null && !command.hidden()) {
      command=null;
    }
  }
 else {
    command=server.getCommandParser().getPlayerCommand(originalName);
  }
  if (command == null) {
    if (groupObject.forwardUnknownCommands) {
      command=new ExternalCommand(commandName);
    }
 else {
      command=server.getCommandParser().getPlayerCommand((String)null);
    }
  }
  if (config != null) {
    Permission permission=server.config.getCommandPermission(config.name,args,position.coordinate());
    if (!permission.contains(this)) {
      addTMessage(Color.RED,""String_Node_Str"");
      return true;
    }
  }
  if (config != null && !(command instanceof ExternalCommand) && config.forwarding != Forwarding.ONLY) {
    command.execute(this,message);
  }
  return !((command instanceof ExternalCommand) || config == null || config.forwarding != Forwarding.NONE || server.options.getBoolean(""String_Node_Str""));
}","public boolean parseCommand(String message){
  if (closed) {
    return true;
  }
  if (message.equals(server.getCommandParser().commandPrefix() + ""String_Node_Str"")) {
    message=lastCommand;
  }
 else {
    lastCommand=message;
  }
  String commandName=message.split(""String_Node_Str"")[0].substring(1);
  String args=commandName.length() == message.length() ? ""String_Node_Str"" : message.substring(commandName.length() + 1);
  CommandConfig config=server.config.commands.getTopConfig(commandName);
  String originalName=config == null ? commandName : config.originalName;
  PlayerCommand command;
  if (config == null) {
    command=server.getCommandParser().getPlayerCommand(commandName);
    if (command != null && !command.hidden()) {
      command=null;
    }
  }
 else {
    command=server.getCommandParser().getPlayerCommand(originalName);
  }
  if (command == null) {
    if (groupObject.forwardUnknownCommands) {
      command=new ExternalCommand(commandName);
    }
 else {
      command=server.getCommandParser().getPlayerCommand((String)null);
    }
  }
  if (config != null) {
    Permission permission=server.config.getCommandPermission(config.name,args,position.coordinate());
    if (!permission.contains(this)) {
      addTMessage(Color.RED,""String_Node_Str"");
      return true;
    }
  }
  if (config != null && !(command instanceof ExternalCommand) && config.forwarding != Forwarding.ONLY) {
    command.execute(this,message);
  }
  return !((command instanceof ExternalCommand) || config == null || config.forwarding != Forwarding.NONE || server.options.getBoolean(""String_Node_Str""));
}",0.975826972010178
150346,"public boolean setName(String name){
  renameName=server.data.players.getRenameName(name);
  name=name.trim();
  if (name.length() == 0 || this.name != null) {
    kick(t(""String_Node_Str""));
    return false;
  }
  if (name == ""String_Node_Str"") {
    kick(t(""String_Node_Str""));
    return false;
  }
  if (!guest && server.options.getBoolean(""String_Node_Str"") && !server.whitelist.isWhitelisted(name)) {
    kick(t(""String_Node_Str""));
    return false;
  }
  if (server.playerList.findPlayerExact(name) != null) {
    kick(t(""String_Node_Str""));
    return false;
  }
  this.name=name;
  updateGroup();
  watchdog.setName(""String_Node_Str"" + name);
  server.connectionLog(""String_Node_Str"",extsocket,name);
  if (server.numPlayers() == 0) {
    server.time.set();
  }
  server.playerList.addPlayer(this);
  return true;
}","public boolean setName(String name){
  renameName=server.data.players.getRenameName(name);
  name=name.trim();
  if (name.length() == 0 || this.name != null) {
    kick(t(""String_Node_Str""));
    return false;
  }
  if (name == ""String_Node_Str"") {
    kick(t(""String_Node_Str""));
    return false;
  }
  if (!guest && server.options.getBoolean(""String_Node_Str"") && !server.whitelist.isWhitelisted(name)) {
    kick(t(""String_Node_Str""));
    return false;
  }
  if (server.playerList.findPlayerExact(name) != null) {
    kick(t(""String_Node_Str""));
    return false;
  }
  this.name=name;
  updateGroup();
  addMessage(Integer.toString(group));
  watchdog.setName(""String_Node_Str"" + name);
  server.connectionLog(""String_Node_Str"",extsocket,name);
  if (server.numPlayers() == 0) {
    server.time.set();
  }
  server.playerList.addPlayer(this);
  return true;
}",0.976936723832052
150347,"public void execute(Player player,String message){
  List<Area> areas=player.getServer().config.dimensions.areas(player.position());
  StringBuilder str=new StringBuilder();
  for (  Area area : areas) {
    str.append(area.name);
    str.append(""String_Node_Str"");
  }
  if (!areas.isEmpty()) {
    str.delete(0,str.length() - 2);
  }
  player.addTMessage(Color.GRAY,""String_Node_Str"",Color.WHITE,str.toString());
}","public void execute(Player player,String message){
  List<Area> areas=player.getServer().config.dimensions.areas(player.position());
  StringBuilder str=new StringBuilder();
  for (  Area area : areas) {
    str.append(area.name);
    str.append(""String_Node_Str"");
  }
  if (!areas.isEmpty()) {
    str.delete(str.length() - 2,str.length() - 1);
  }
  player.addTMessage(Color.GRAY,""String_Node_Str"",Color.WHITE,str.toString());
}",0.9775678866587958
150348,"public void execute(Player player,String message){
  String[] arguments=extractArguments(message);
  if (arguments.length > 0) {
    String prefix=commandPrefix();
    String commandName=arguments[0];
    if (!commandName.startsWith(prefix)) {
      commandName=prefix + commandName;
    }
    PlayerCommand command=parser.getPlayerCommand(commandName);
    player.addMessage(command.getHelpText(prefix));
    List<String> aliases=player.getServer().config.commands.get(command.getName()).aliases;
    if (!aliases.isEmpty()) {
      StringBuffer line=new StringBuffer();
      for (      String alias : aliases) {
        line.append(commandPrefix());
        line.append(alias);
        line.append(""String_Node_Str"");
      }
      player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    }
  }
 else {
    List<PermissionContainer> containers=player.getServer().config.containers(player.position());
    Set<CommandConfig> commands=new TreeSet<CommandConfig>();
    for (    PermissionContainer container : containers) {
      for (      CommandConfig command : container.commands) {
        if (command.allow.contains(player)) {
          commands.add(command);
        }
      }
    }
    StringBuffer line=new StringBuffer();
    String prefix=commandPrefix();
    for (    CommandConfig cmd : commands) {
      Command command=parser.getPlayerCommand(cmd.originalName);
      if (cmd.hidden || command.hidden()) {
        continue;
      }
      line.append(prefix);
      line.append(cmd.name);
      line.append(""String_Node_Str"");
    }
    player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    player.addTMessage(Color.GRAY,""String_Node_Str"",prefix + ""String_Node_Str"");
    String[] helplines=player.getServer().helptext.getHelpText().split(""String_Node_Str"");
    if (helplines.length > 0) {
      player.addMessage(""String_Node_Str"");
      for (      String l : helplines) {
        player.addMessage(Color.WHITE,l);
      }
    }
  }
}","public void execute(Player player,String message){
  String[] arguments=extractArguments(message);
  if (arguments.length > 0) {
    String prefix=commandPrefix();
    String commandName=arguments[0];
    if (!commandName.startsWith(prefix)) {
      commandName=prefix + commandName;
    }
    PlayerCommand command=parser.getPlayerCommand(commandName);
    player.addMessage(command.getHelpText(prefix));
    List<String> aliases=player.getServer().config.commands.get(command.getName()).aliases;
    if (aliases != null) {
      StringBuffer line=new StringBuffer();
      for (      String alias : aliases) {
        line.append(commandPrefix());
        line.append(alias);
        line.append(""String_Node_Str"");
      }
      player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    }
  }
 else {
    List<PermissionContainer> containers=player.getServer().config.containers(player.position());
    Set<CommandConfig> commands=new TreeSet<CommandConfig>();
    for (    PermissionContainer container : containers) {
      for (      CommandConfig command : container.commands) {
        if (command.allow.contains(player)) {
          commands.add(command);
        }
      }
    }
    StringBuffer line=new StringBuffer();
    String prefix=commandPrefix();
    for (    CommandConfig cmd : commands) {
      Command command=parser.getPlayerCommand(cmd.originalName);
      System.out.println(cmd.name);
      if (cmd.hidden || (command != null && command.hidden())) {
        continue;
      }
      line.append(prefix);
      line.append(cmd.name);
      line.append(""String_Node_Str"");
    }
    player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    player.addTMessage(Color.GRAY,""String_Node_Str"",prefix + ""String_Node_Str"");
    String[] helplines=player.getServer().helptext.getHelpText().split(""String_Node_Str"");
    if (helplines.length > 0) {
      player.addMessage(""String_Node_Str"");
      for (      String l : helplines) {
        player.addMessage(Color.WHITE,l);
      }
    }
  }
}",0.9780439121756488
150349,"private boolean areaSizeOk(Player player){
  return (Math.abs(player.areastart.x() - player.areaend.x()) <= 50) && (Math.abs(player.areastart.y() - player.areaend.y()) <= 50) && player.areaend.dimension() == player.areastart.dimension();
}","private boolean areaSizeOk(Player player){
  return (Math.abs(player.areastart.x() - player.areaend.x()) < 50) && (Math.abs(player.areastart.z() - player.areaend.z()) < 50) && player.areaend.dimension() == player.areastart.dimension();
}",0.9873949579831932
150350,"public void execute(Player player,String message){
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTMessage(Color.RED,""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (overlaps != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}","public void execute(Player player,String message){
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTMessage(Color.RED,""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}",0.9953356317177044
150351,"protected AbstractConfig(String filename){
  this.filename=filename;
}","protected AbstractConfig(String filename){
  this.filename=filename;
  loadHeader();
}",0.8974358974358975
150352,"public Area(String name,Coordinate start,Coordinate end){
  this();
  this.name=name;
  this.start=start;
  this.end=end;
  position=Integer.MAX_VALUE;
  level=0;
}","public Area(String name,Coordinate start,Coordinate end){
  this();
  this.name=name;
  this.start=start;
  this.end=end;
  position=Integer.MAX_VALUE;
  level=0;
  init();
}",0.970414201183432
150353,"@Override void setAttribute(String name,String value) throws SAXException {
  if (name.equals(NAME)) {
    this.name=value;
  }
 else   if (name.equals(START)) {
    start=getCoord(value,0);
  }
 else   if (name.equals(END)) {
    end=getCoord(value,128);
  }
 else   if (name.equals(OWNER)) {
    owner=value;
  }
 else   if (name.equals(PRIORITY)) {
    priority=getInt(value);
  }
}","@Override void setAttribute(String name,String value) throws SAXException {
  if (name.equals(NAME)) {
    this.name=value;
  }
 else   if (name.equals(START)) {
    start=getCoord(value,0);
  }
 else   if (name.equals(END)) {
    end=getCoord(value,127);
  }
 else   if (name.equals(OWNER)) {
    owner=value;
  }
 else   if (name.equals(PRIORITY)) {
    priority=getInt(value);
  }
}",0.9974025974025974
150354,"Permission permission(String args){
  for (  Argument arg : arguments) {
    if (args.startsWith(arg.argument)) {
      return arg.allow;
    }
  }
  return null;
}","Permission permission(String args){
  if (arguments == null) {
    return null;
  }
  for (  Argument arg : arguments) {
    if (args.startsWith(arg.argument)) {
      return arg.allow;
    }
  }
  return null;
}",0.8723404255319149
150355,"public CommandConfig getTopConfig(String name){
  if (commands.containsKey(name)) {
    return commands.get(name);
  }
  for (  CommandConfig command : commands.values()) {
    if (command.aliases.contains(name)) {
      return command;
    }
  }
  return null;
}","public CommandConfig getTopConfig(String name){
  if (commands.containsKey(name)) {
    return commands.get(name);
  }
  for (  CommandConfig command : commands.values()) {
    if (command.alias(name)) {
      return command;
    }
  }
  return null;
}",0.9786407766990292
150356,"public Iterator<CommandConfig> iterator(){
  return commands.values().iterator();
}","@Override public Iterator<CommandConfig> iterator(){
  return commands.values().iterator();
}",0.9431818181818182
150357,"public AreaStoragePair playerArea(Player player){
  String name=player.getName().toLowerCase();
  for (  DimensionConfig dim : dimensions) {
    Stack<AreaStorage> stack=new Stack<AreaStorage>();
    stack.add(dim.topAreas);
    while (!stack.isEmpty()) {
      for (      Area area : stack.peek()) {
        if (area.owner == name) {
          return new AreaStoragePair(stack.peek(),area);
        }
        stack.add(area.areas);
      }
      stack.pop();
    }
  }
  return null;
}","public AreaStoragePair playerArea(Player player){
  String name=player.getName().toLowerCase();
  for (  DimensionConfig dim : dimensions) {
    Stack<AreaStorage> stack=new Stack<AreaStorage>();
    stack.add(dim.topAreas);
    while (!stack.isEmpty()) {
      AreaStorage storage=stack.pop();
      for (      Area area : storage) {
        if (area.owner == name) {
          return new AreaStoragePair(storage,area);
        }
        stack.add(area.areas);
      }
    }
  }
  return null;
}",0.910386965376782
150358,"public DimensionConfig add(Dimension dimension){
  DimensionConfig newDimension=new DimensionConfig();
  newDimension.dimension=dimension;
  dimensions.put(dimension,newDimension);
  return newDimension;
}","public DimensionConfig add(Dimension dimension){
  DimensionConfig newDimension=new DimensionConfig();
  newDimension.dimension=dimension;
  newDimension.init();
  dimensions.put(dimension,newDimension);
  return newDimension;
}",0.9468822170900691
150359,"public Set<Area> overlaps(Area area){
  DimensionConfig dim=get(area.start.dimension());
  if (dim != null) {
    return dim.areas.overlaps(area);
  }
  return null;
}","public Set<Area> overlaps(Area area){
  DimensionConfig dim=get(area.start.dimension());
  if (dim != null) {
    return dim.areas.overlaps(area);
  }
  return new HashSet<Area>(0);
}",0.9371428571428572
150360,"@Override public void save(){
  lock.lock();
  FileOutputStream fos;
  try {
    fos=new FileOutputStream(new File(""String_Node_Str""));
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  OutputFormat of=new OutputFormat(""String_Node_Str"",""String_Node_Str"",true);
  of.setIndent(1);
  of.setIndenting(true);
  of.setDoctype(null,""String_Node_Str"");
  XMLSerializer serializer=new XMLSerializer(fos,of);
  ContentHandler hd;
  try {
    hd=serializer.asContentHandler();
    hd.startDocument();
    config.save(hd,serializer);
    hd.endDocument();
    fos.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    lock.unlock();
  }
}","@Override public void save(){
  lock.lock();
  FileOutputStream fos;
  try {
    fos=new FileOutputStream(getFile());
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  OutputFormat of=new OutputFormat(""String_Node_Str"",""String_Node_Str"",true);
  of.setIndent(1);
  of.setIndenting(true);
  of.setDoctype(null,""String_Node_Str"");
  XMLSerializer serializer=new XMLSerializer(fos,of);
  ContentHandler hd;
  try {
    hd=serializer.asContentHandler();
    hd.startDocument();
    config.save(hd,serializer);
    hd.endDocument();
    fos.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    lock.unlock();
  }
}",0.68
150361,"public Integer get(Player player){
  return get(player.getInetAddress()).group;
}","public Integer get(Player player){
  return contains(player.getInetAddress()) ? get(player.getInetAddress()).group : null;
}",0.7902439024390244
150362,"private static boolean contains(TreeMap<Integer,Integer> ranges,int value){
  Entry<Integer,Integer> entry=ranges.lowerEntry(value + 1);
  return entry != null && entry.getValue() <= value;
}","private static boolean contains(TreeMap<Integer,Integer> ranges,int value){
  Entry<Integer,Integer> entry=ranges.lowerEntry(value + 1);
  return entry != null && entry.getValue() >= value;
}",0.9947643979057592
150363,"private Area createPlayerArea(Player player){
  Area area=new Area(t(""String_Node_Str"",player.getName()),player.areastart,player.areaend);
  area.owner=player.getName().toLowerCase();
  return area;
}","private Area createPlayerArea(Player player){
  Area area=new Area(t(""String_Node_Str"",player.getName()),player.areastart,player.areaend);
  area.owner=player.getName().toLowerCase();
  Permission perm=new Permission(player);
  AllBlocks blocks=new AllBlocks();
  blocks.destroy=perm;
  blocks.place=perm;
  blocks.use=perm;
  area.allblocks.blocks=blocks;
  area.chests.chests=new Chests(perm);
  return area;
}",0.6437908496732027
150364,"@Override void add(XMLTag child){
  AllBlocks blocks=(AllBlocks)child;
  if (this.blocks == null) {
    this.blocks=blocks;
  }
 else {
    if (blocks.place != null) {
      this.blocks.place=blocks.place;
    }
    if (blocks.destroy != null) {
      this.blocks.destroy=blocks.destroy;
    }
    if (blocks.use != null) {
      this.blocks.use=blocks.use;
    }
    if (blocks.take != null) {
      this.blocks.take=blocks.take;
    }
    if (blocks.give != null) {
      this.blocks.give=blocks.give;
    }
  }
}","@Override public void add(XMLTag child){
  AllBlocks blocks=(AllBlocks)child;
  if (this.blocks == null) {
    this.blocks=blocks;
  }
 else {
    if (blocks.place != null) {
      this.blocks.place=blocks.place;
    }
    if (blocks.destroy != null) {
      this.blocks.destroy=blocks.destroy;
    }
    if (blocks.use != null) {
      this.blocks.use=blocks.use;
    }
    if (blocks.give != null) {
      this.blocks.give=blocks.give;
    }
  }
}",0.8817427385892116
150365,"public Area(String name,Coordinate start,Coordinate end){
  this();
  this.name=name;
  this.start=start;
  this.end=end;
  position=Integer.MAX_VALUE;
  level=0;
  init();
}","public Area(String name,Coordinate start,Coordinate end){
  this();
  this.name=name;
  this.start=start;
  this.end=end;
  position=Integer.MAX_VALUE;
  level=0;
  init();
  finish();
}",0.9666666666666668
150366,"@Override public void finish(){
  DimensionAreaStorage.getInstance().decreaseLevel();
}","@Override public void finish(){
  DimensionAreaStorage.getInstance().decreaseLevel();
  super.finish();
}",0.90625
150367,"Chests(){
  super(""String_Node_Str"");
}","public Chests(Permission permission){
  this();
  allow=permission;
}",0.3888888888888889
150368,"public Group getGroup(Player player) throws SAXException {
  Integer playerGroup=players.get(player);
  Integer ipGroup=ips.get(player);
  int groupid;
  if (playerGroup == null && ipGroup == null) {
    groupid=properties.getInt(""String_Node_Str"");
  }
 else   if (playerGroup == null || playerGroup < ipGroup) {
    groupid=ipGroup;
  }
 else {
    groupid=playerGroup;
  }
  Group group=groups.get(groupid);
  if (group == null) {
    throw new SAXException(""String_Node_Str"" + groupid + ""String_Node_Str"");
  }
  return group;
}","public Group getGroup(Player player) throws SAXException {
  Integer playerGroup=players.get(player);
  Integer ipGroup=ips.get(player);
  int groupid;
  if (playerGroup == null && ipGroup == null) {
    groupid=properties.getInt(""String_Node_Str"");
  }
 else   if (playerGroup == null || (ipGroup != null && playerGroup < ipGroup)) {
    groupid=ipGroup;
  }
 else {
    groupid=playerGroup;
  }
  Group group=groups.get(groupid);
  if (group == null) {
    throw new SAXException(""String_Node_Str"" + groupid + ""String_Node_Str"");
  }
  return group;
}",0.9806451612903224
150369,"public AreaStoragePair playerArea(Player player){
  String name=player.getName().toLowerCase();
  for (  DimensionConfig dim : dimensions) {
    Stack<AreaStorage> stack=new Stack<AreaStorage>();
    stack.add(dim.topAreas);
    while (!stack.isEmpty()) {
      AreaStorage storage=stack.pop();
      for (      Area area : storage) {
        if (area.owner.equals(name)) {
          return new AreaStoragePair(storage,area);
        }
        stack.add(area.areas);
      }
    }
  }
  return null;
}","public AreaStoragePair playerArea(Player player){
  String name=player.getName().toLowerCase();
  for (  DimensionConfig dim : dimensions) {
    Stack<AreaStorage> stack=new Stack<AreaStorage>();
    stack.add(dim.topAreas);
    while (!stack.isEmpty()) {
      AreaStorage storage=stack.pop();
      for (      Area area : storage) {
        if (name.equals(area.owner)) {
          return new AreaStoragePair(storage,area);
        }
        stack.add(area.areas);
      }
    }
  }
  return null;
}",0.9720558882235528
150370,"void decreaseLevel(){
  positions.pop();
}","void decreaseLevel(){
  if (positions != null && !positions.isEmpty()) {
    positions.pop();
  }
}",0.5957446808510638
150371,"@Override public void load(){
  lock.lock();
  loadsuccess=false;
  InputStream stream;
  if (!getFile().exists()) {
    Config config;
    if ((config=LegacyPermissionConfig.load()) != null) {
      this.config=config;
      loadsuccess=true;
      return;
    }
 else {
      stream=getClass().getResourceAsStream(filename);
    }
  }
 else {
    try {
      stream=new FileInputStream(getFile());
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
      lock.unlock();
      return;
    }
  }
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  XMLTagResolver handler;
  try {
    handler=new XMLTagResolver();
  }
 catch (  SAXException e1) {
    e1.printStackTrace();
    return;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",true);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new InputStreamReader(stream)));
  }
 catch (  Exception e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  processTags(handler.root());
  loadsuccess=true;
  lock.unlock();
}","@Override public void load(){
  lock.lock();
  loadsuccess=false;
  InputStream stream;
  if (!getFile().exists()) {
    Config config;
    if ((config=LegacyPermissionConfig.load()) != null) {
      this.config=config;
      loadsuccess=true;
      return;
    }
 else {
      stream=getClass().getResourceAsStream(filename);
    }
  }
 else {
    try {
      stream=new FileInputStream(getFile());
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
      lock.unlock();
      return;
    }
  }
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  XMLTagResolver handler;
  try {
    handler=new XMLTagResolver();
  }
 catch (  SAXException e1) {
    e1.printStackTrace();
    return;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",true);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new InputStreamReader(stream)));
  }
 catch (  Exception e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  processTags(handler.root());
  loadsuccess=true;
  save();
  lock.unlock();
}",0.9958368026644464
150372,"public Permission(String allow,String disallow) throws SAXException {
  if (disallow == null) {
    disallow=""String_Node_Str"";
  }
  if (allow == null) {
    allow=""String_Node_Str"";
  }
  String[] allowParts=allow.split(""String_Node_Str"");
  String[] disallowParts=disallow.split(""String_Node_Str"");
  StringBuilder perm=new StringBuilder(allowParts[0]);
  for (  String part : disallowParts[0].split(""String_Node_Str"")) {
    if (part.length() == 0) {
      continue;
    }
    perm.append(',');
    perm.append('!');
    perm.append(part);
  }
  if (allowParts[0].length() == 0) {
    perm.deleteCharAt(0);
  }
  if (allowParts.length >= 2 || disallowParts.length >= 2) {
    perm.append(';');
    if (allowParts.length >= 2) {
      perm.append(allowParts[1]);
    }
    if (disallowParts.length >= 2) {
      for (      String part : disallowParts[1].split(""String_Node_Str"")) {
        if (perm.charAt(perm.length() - 1) != ';') {
          perm.append(',');
        }
        perm.append('!');
        perm.append(part);
      }
    }
  }
  set(perm.toString());
}","public Permission(Player player){
  allowedPlayers.add(player.getName().toLowerCase());
}",0.1033591731266149
150373,"@Override void convert(Attributes attributes,Stack<PermissionContainer> stack) throws SAXException {
  PermissionContainer container=stack.peek();
  String[] parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  String[] coords=parts[0].split(""String_Node_Str"");
  Coordinate start;
  if (coords.length == 2) {
    start=new Coordinate(getInt(coords[0]),0,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    start=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  Dimension dimension=(parts.length >= 2) ? Dimension.get(parts[1]) : Dimension.EARTH;
  parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  coords=parts[0].split(""String_Node_Str"");
  Coordinate end;
  if (coords.length == 2) {
    end=new Coordinate(getInt(coords[0]),127,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    end=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  if (!((Config)stack.firstElement()).dimensions.contains(dimension)) {
    ((Config)stack.firstElement()).dimensions.add(dimension);
  }
  DimensionAreaStorage.setInstance(((Config)stack.firstElement()).dimensions.get(dimension).areas);
  Area area=new Area(attributes.getValue(""String_Node_Str""),start,end);
  if (attributes.getIndex(""String_Node_Str"") >= 0) {
    area.owner=attributes.getValue(""String_Node_Str"").toLowerCase();
  }
  area.fullInit();
  if (container instanceof Config) {
    ((Config)container).dimensions.get(dimension).add(area);
  }
 else {
    ((Area)container).areas.add(area);
  }
  stack.push(area);
}","@Override void convert(Attributes attributes,Stack<PermissionContainer> stack) throws SAXException {
  PermissionContainer container=stack.peek();
  String[] parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  String[] coords=parts[0].split(""String_Node_Str"");
  Coordinate start;
  if (coords.length == 2) {
    start=new Coordinate(getInt(coords[0]),0,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    start=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  Dimension dimension=(parts.length >= 2) ? Dimension.get(parts[1]) : Dimension.EARTH;
  parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  coords=parts[0].split(""String_Node_Str"");
  Coordinate end;
  if (coords.length == 2) {
    end=new Coordinate(getInt(coords[0]),127,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    end=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  if (!((Config)stack.firstElement()).dimensions.contains(dimension)) {
    ((Config)stack.firstElement()).dimensions.add(dimension);
  }
  DimensionAreaStorage.setInstance(((Config)stack.firstElement()).dimensions.get(dimension).areas);
  Area area=new Area(attributes.getValue(""String_Node_Str""),start,end);
  if (attributes.getIndex(""String_Node_Str"") >= 0) {
    area.owner=attributes.getValue(""String_Node_Str"").toLowerCase();
  }
  area.init();
  area.finish();
  if (container instanceof Config) {
    ((Config)container).dimensions.get(dimension).add(area);
  }
 else {
    ((Area)container).areas.add(area);
  }
  stack.push(area);
}",0.9921942758022548
150374,"@Override void convert(Attributes attributes,Stack<PermissionContainer> stack) throws SAXException {
  PermissionContainer container=stack.peek();
  Block block=new Block(attributes.getValue(""String_Node_Str""));
  block.place=new Permission(attributes.getValue(""String_Node_Str""));
  block.fullInit();
  container.blocks.add(block);
}","@Override void convert(Attributes attributes,Stack<PermissionContainer> stack) throws SAXException {
  PermissionContainer container=stack.peek();
  Block block=new Block(attributes.getValue(""String_Node_Str""));
  block.place=new Permission(attributes.getValue(""String_Node_Str""),attributes.getValue(""String_Node_Str""));
  block.fullInit();
  container.blocks.add(block);
}",0.9448373408769448
150375,"public boolean parseCommand(String line){
  ServerCommand command=server.getCommandParser().getServerCommand(line);
  if ((command != null) && (command.getClass() != InvalidCommand.class)) {
    command.execute(server,line);
    return !command.shouldPassThroughToConsole(server);
  }
  return false;
}","public boolean parseCommand(String line){
  ServerCommand command=server.getCommandParser().getServerCommand(line.split(""String_Node_Str"")[0]);
  if ((command != null) && !(command instanceof InvalidCommand)) {
    command.execute(server,line);
    return !command.shouldPassThroughToConsole(server);
  }
  return false;
}",0.8814102564102564
150376,"@Override public void load(){
  lock.lock();
  loadsuccess=false;
  InputStream stream;
  if (!getFile().exists()) {
    Config config;
    if ((config=LegacyPermissionConfig.load()) != null) {
      this.config=config;
      return;
    }
 else {
      stream=getClass().getResourceAsStream(filename);
    }
  }
 else {
    try {
      stream=new FileInputStream(getFile());
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
      lock.unlock();
      return;
    }
  }
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  XMLTagResolver handler;
  try {
    handler=new XMLTagResolver();
  }
 catch (  SAXException e1) {
    e1.printStackTrace();
    return;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",true);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new InputStreamReader(stream)));
  }
 catch (  Exception e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  processTags(handler.root());
  loadsuccess=true;
  lock.unlock();
}","@Override public void load(){
  lock.lock();
  loadsuccess=false;
  InputStream stream;
  if (!getFile().exists()) {
    Config config;
    if ((config=LegacyPermissionConfig.load()) != null) {
      this.config=config;
      loadsuccess=true;
      return;
    }
 else {
      stream=getClass().getResourceAsStream(filename);
    }
  }
 else {
    try {
      stream=new FileInputStream(getFile());
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
      lock.unlock();
      return;
    }
  }
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  XMLTagResolver handler;
  try {
    handler=new XMLTagResolver();
  }
 catch (  SAXException e1) {
    e1.printStackTrace();
    return;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",true);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new InputStreamReader(stream)));
  }
 catch (  Exception e) {
    e.printStackTrace();
    lock.unlock();
    return;
  }
  processTags(handler.root());
  loadsuccess=true;
  lock.unlock();
}",0.9898648648648648
150377,"public static Config load(){
  File file=new File(""String_Node_Str"",""String_Node_Str"");
  if (!file.exists()) {
    return null;
  }
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    return null;
  }
  LegacyTagResolver handler;
  try {
    handler=new LegacyTagResolver();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    return null;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",false);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new FileReader(file)));
  }
 catch (  FileNotFoundException e) {
    return null;
  }
catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  return handler.config();
}","public static Config load(){
  File file=new File(""String_Node_Str"",""String_Node_Str"");
  if (!file.exists()) {
    return null;
  }
  System.out.println(""String_Node_Str"");
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    return null;
  }
  LegacyTagResolver handler;
  try {
    handler=new LegacyTagResolver();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    return null;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",false);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new FileReader(file)));
  }
 catch (  FileNotFoundException e) {
    return null;
  }
catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  return handler.config();
}",0.975045648204504
150378,"public boolean loadResources(){
  for (  Resource resource : resources) {
    resource.load();
  }
  if (playerList != null) {
    playerList.updatePlayerGroups();
  }
  if (globalConfig.loadsuccess) {
    config=globalConfig.config;
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  if (!Translations.getInstance().setLanguage(options.get(""String_Node_Str""))) {
    options.set(""String_Node_Str"",""String_Node_Str"");
    options.save();
  }
  addressFactory.toggle(!options.getBoolean(""String_Node_Str""));
  return globalConfig.loadsuccess;
}","public boolean loadResources(){
  for (  Resource resource : resources) {
    resource.load();
  }
  if (globalConfig.loadsuccess) {
    config=globalConfig.config;
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  if (playerList != null) {
    playerList.updatePlayerGroups();
  }
  if (!Translations.getInstance().setLanguage(options.get(""String_Node_Str""))) {
    options.set(""String_Node_Str"",""String_Node_Str"");
    options.save();
  }
  addressFactory.toggle(!options.getBoolean(""String_Node_Str""));
  return globalConfig.loadsuccess;
}",0.7739602169981917
150379,"public void execute(Player player,String message){
  List<Area> areas=player.getServer().config.dimensions.areas(player.position());
  StringBuilder str=new StringBuilder();
  for (  Area area : areas) {
    str.append(area.name);
    str.append(""String_Node_Str"");
  }
  if (!areas.isEmpty()) {
    str.delete(str.length() - 2,str.length() - 1);
  }
  player.addTMessage(Color.GRAY,""String_Node_Str"",Color.WHITE,str.toString());
}","public void execute(Player player,String message){
  List<Area> areas=player.getServer().config.dimensions.areas(player.position());
  StringBuilder str=new StringBuilder();
  if (areas == null || areas.isEmpty()) {
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    return;
  }
  for (  Area area : areas) {
    str.append(area.name);
    str.append(""String_Node_Str"");
  }
  if (!areas.isEmpty()) {
    str.delete(str.length() - 2,str.length() - 1);
  }
  player.addTCaptionedMessage(""String_Node_Str"",str.toString());
}",0.5583333333333333
150380,"public void execute(Player player,String message){
  String[] arguments=extractArguments(message);
  if (arguments.length > 0) {
    String prefix=commandPrefix();
    String commandName=arguments[0];
    if (!commandName.startsWith(prefix)) {
      commandName=prefix + commandName;
    }
    PlayerCommand command=parser.getPlayerCommand(commandName);
    player.addMessage(command.getHelpText(prefix));
    List<String> aliases=player.getServer().config.commands.get(command.getName()).aliases;
    if (aliases != null) {
      StringBuffer line=new StringBuffer();
      for (      String alias : aliases) {
        line.append(commandPrefix());
        line.append(alias);
        line.append(""String_Node_Str"");
      }
      player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    }
  }
 else {
    List<PermissionContainer> containers=player.getServer().config.containers(player.position());
    Set<CommandConfig> commands=new TreeSet<CommandConfig>();
    for (    PermissionContainer container : containers) {
      for (      CommandConfig command : container.commands) {
        if (command.allow.contains(player)) {
          commands.add(command);
        }
      }
    }
    StringBuffer line=new StringBuffer();
    String prefix=commandPrefix();
    for (    CommandConfig cmd : commands) {
      Command command=parser.getPlayerCommand(cmd.originalName);
      System.out.println(cmd.name);
      if (cmd.hidden || (command != null && command.hidden())) {
        continue;
      }
      line.append(prefix);
      line.append(cmd.name);
      line.append(""String_Node_Str"");
    }
    player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    player.addTMessage(Color.GRAY,""String_Node_Str"",prefix + ""String_Node_Str"");
    String[] helplines=player.getServer().helptext.getHelpText().split(""String_Node_Str"");
    if (helplines.length > 0) {
      player.addMessage(""String_Node_Str"");
      for (      String l : helplines) {
        player.addMessage(Color.WHITE,l);
      }
    }
  }
}","public void execute(Player player,String message){
  String[] arguments=extractArguments(message);
  if (arguments.length > 0) {
    String prefix=commandPrefix();
    String commandName=arguments[0];
    if (commandName.startsWith(prefix)) {
      commandName=commandName.substring(1);
    }
    PlayerCommand command=parser.getPlayerCommand(commandName);
    if (command == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    player.addMessage(command.getHelpText(prefix));
    List<String> aliases=player.getServer().config.commands.get(command.getName()).aliases;
    if (aliases != null) {
      StringBuffer line=new StringBuffer();
      for (      String alias : aliases) {
        line.append(commandPrefix());
        line.append(alias);
        line.append(""String_Node_Str"");
      }
      player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    }
  }
 else {
    List<PermissionContainer> containers=player.getServer().config.containers(player.position());
    Set<CommandConfig> commands=new TreeSet<CommandConfig>();
    for (    PermissionContainer container : containers) {
      for (      CommandConfig command : container.commands) {
        if (command.allow.contains(player)) {
          commands.add(command);
        }
      }
    }
    StringBuffer line=new StringBuffer();
    String prefix=commandPrefix();
    for (    CommandConfig cmd : commands) {
      Command command=parser.getPlayerCommand(cmd.originalName);
      System.out.println(cmd.name);
      if (cmd.hidden || (command != null && command.hidden())) {
        continue;
      }
      line.append(prefix);
      line.append(cmd.name);
      line.append(""String_Node_Str"");
    }
    player.addTCaptionedMessage(""String_Node_Str"",line.toString());
    player.addTMessage(Color.GRAY,""String_Node_Str"",prefix + ""String_Node_Str"");
    String[] helplines=player.getServer().helptext.getHelpText().split(""String_Node_Str"");
    if (helplines.length > 0) {
      player.addMessage(""String_Node_Str"");
      for (      String l : helplines) {
        player.addMessage(Color.WHITE,l);
      }
    }
  }
}",0.9700023998080154
150381,"public void execute(Player player,String message){
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTMessage(Color.RED,""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}","public void execute(Player player,String message){
  Config config=player.getServer().config;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addTCaptionedMessage(""String_Node_Str"",commandPrefix() + ""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=player.position();
    player.areastart=player.areastart.setY((byte)0);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=player.position();
    player.areaend=player.areaend.setY((byte)127);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (player.areastart == null || player.areaend == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (player.getServer().config.playerArea(player) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    Area area=createPlayerArea(player);
    Set<Area> overlaps=config.dimensions.overlaps(area);
    if (!overlaps.isEmpty()) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      StringBuilder str=new StringBuilder();
      for (      Area overlap : overlaps) {
        str.append(overlap.name);
        str.append(""String_Node_Str"");
      }
      str.delete(str.length() - 2,str.length() - 1);
      player.addTCaptionedMessage(""String_Node_Str"",""String_Node_Str"",str);
      return;
    }
    saveArea(area,player);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    area.storage.remove(area.area);
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    AreaStoragePair area=config.playerArea(player);
    if (area == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      area.area.name=label;
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"");
    }
  }
 else {
    player.addTMessage(Color.RED,""String_Node_Str"");
  }
}",0.9893381613357474
150382,"public AreaStoragePair playerArea(Player player){
  String name=player.getName().toLowerCase();
  for (  DimensionConfig dim : dimensions) {
    Stack<AreaStorage> stack=new Stack<AreaStorage>();
    stack.add(dim.topAreas);
    while (!stack.isEmpty()) {
      AreaStorage storage=stack.pop();
      for (      Area area : storage) {
        if (area.owner == name) {
          return new AreaStoragePair(storage,area);
        }
        stack.add(area.areas);
      }
    }
  }
  return null;
}","public AreaStoragePair playerArea(Player player){
  String name=player.getName().toLowerCase();
  for (  DimensionConfig dim : dimensions) {
    Stack<AreaStorage> stack=new Stack<AreaStorage>();
    stack.add(dim.topAreas);
    while (!stack.isEmpty()) {
      AreaStorage storage=stack.pop();
      for (      Area area : storage) {
        if (area.owner.equals(name)) {
          return new AreaStoragePair(storage,area);
        }
        stack.add(area.areas);
      }
    }
  }
  return null;
}",0.978936810431294
150383,"public DimensionConfig add(Dimension dimension){
  DimensionConfig newDimension=new DimensionConfig();
  newDimension.dimension=dimension;
  newDimension.init();
  dimensions.put(dimension,newDimension);
  return newDimension;
}","public DimensionConfig add(Dimension dimension){
  DimensionConfig newDimension=new DimensionConfig();
  newDimension.dimension=dimension;
  newDimension.init();
  newDimension.finish();
  dimensions.put(dimension,newDimension);
  return newDimension;
}",0.948024948024948
150384,"protected void processBOM() throws IOException {
  byte[] bom=new byte[BOM_SIZE];
  int read=pushbackReader.read(bom,0,BOM_SIZE);
  int unread=0;
  if (read > 0) {
    Set<String> encodings=BOMS.keySet();
    Iterator<String> itr=encodings.iterator();
    while (itr.hasNext()) {
      String currentEncoding=itr.next();
      byte[] currentBOM=BOMS.get(currentEncoding);
      if (arrayStartsWith(bom,currentBOM)) {
        encoding=currentEncoding;
        unread=currentBOM.length;
        break;
      }
    }
    if (unread <= BOM_SIZE && unread > 0) {
      pushbackReader.unread(bom,unread,read - unread);
    }
  }
  if (encoding == null) {
    reader=new InputStreamReader(pushbackReader);
  }
 else {
    reader=new InputStreamReader(pushbackReader,encoding);
  }
}","protected void processBOM() throws IOException {
  byte[] bom=new byte[BOM_SIZE];
  int read=pushbackReader.read(bom,0,BOM_SIZE);
  int unread=0;
  if (read > 0) {
    Set<String> encodings=BOMS.keySet();
    Iterator<String> itr=encodings.iterator();
    while (itr.hasNext()) {
      String currentEncoding=itr.next();
      byte[] currentBOM=BOMS.get(currentEncoding);
      if (arrayStartsWith(bom,currentBOM)) {
        encoding=currentEncoding;
        unread=currentBOM.length;
        break;
      }
    }
    if (unread <= BOM_SIZE) {
      pushbackReader.unread(bom,unread,read - unread);
    }
  }
  if (encoding == null) {
    reader=new InputStreamReader(pushbackReader);
  }
 else {
    reader=new InputStreamReader(pushbackReader,encoding);
  }
}",0.9908854166666666
150385,"private void set(String permission) throws SAXException {
  if (permission.equals(""String_Node_Str"")) {
    return;
  }
  String[] parts=permission.split(""String_Node_Str"");
  for (  String group : parts[0].split(""String_Node_Str"")) {
    boolean allow=true;
    if (group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"")) {
      allow=false;
      group=group.substring(1);
    }
    int start;
    int end;
    Matcher matcher;
    try {
      if (group.endsWith(""String_Node_Str"")) {
        start=getInt(group.substring(0,group.length() - 1));
        end=Integer.MAX_VALUE;
      }
 else       if (group.equals(""String_Node_Str"")) {
        start=Integer.MIN_VALUE;
        end=Integer.MAX_VALUE;
      }
 else       if ((matcher=GROUP_PATTERN.matcher(group)).matches()) {
        start=getInt(matcher.group(1));
        end=getInt(matcher.group(2));
      }
 else {
        start=end=getInt(group);
      }
    }
 catch (    SAXException e) {
      throw new SAXException(""String_Node_Str"" + permission + ""String_Node_Str"");
    }
    if (allow) {
      allowedGroups.put(start,end);
    }
 else {
      disallowedGroups.put(start,end);
    }
  }
  if (parts.length >= 2) {
    for (    String player : parts[1].split(""String_Node_Str"")) {
      if (player.startsWith(""String_Node_Str"") || player.startsWith(""String_Node_Str"") || player.startsWith(""String_Node_Str"")) {
        disallowedPlayers.add(player.substring(1).toLowerCase());
      }
 else {
        allowedPlayers.add(player.toLowerCase());
      }
    }
  }
  if (allowedGroups.isEmpty() && allowedPlayers.isEmpty()) {
    allowedGroups.put(Integer.MIN_VALUE,Integer.MAX_VALUE);
  }
}","private void set(String permission) throws SAXException {
  if (permission.equals(""String_Node_Str"")) {
    return;
  }
  String[] parts=permission.split(""String_Node_Str"");
  for (  String group : parts[0].split(""String_Node_Str"")) {
    if (group.length() == 0) {
      continue;
    }
    boolean allow=true;
    if (group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"")) {
      allow=false;
      group=group.substring(1);
    }
    int start;
    int end;
    Matcher matcher;
    try {
      if (group.endsWith(""String_Node_Str"")) {
        start=getInt(group.substring(0,group.length() - 1));
        end=Integer.MAX_VALUE;
      }
 else       if (group.equals(""String_Node_Str"")) {
        start=Integer.MIN_VALUE;
        end=Integer.MAX_VALUE;
      }
 else       if ((matcher=GROUP_PATTERN.matcher(group)).matches()) {
        start=getInt(matcher.group(1));
        end=getInt(matcher.group(2));
      }
 else {
        start=end=getInt(group);
      }
    }
 catch (    SAXException e) {
      throw new SAXException(""String_Node_Str"" + permission + ""String_Node_Str"");
    }
    if (allow) {
      allowedGroups.put(start,end);
    }
 else {
      disallowedGroups.put(start,end);
    }
  }
  if (parts.length >= 2) {
    for (    String player : parts[1].split(""String_Node_Str"")) {
      if (player.startsWith(""String_Node_Str"") || player.startsWith(""String_Node_Str"") || player.startsWith(""String_Node_Str"")) {
        disallowedPlayers.add(player.substring(1).toLowerCase());
      }
 else {
        allowedPlayers.add(player.toLowerCase());
      }
    }
  }
  if (allowedGroups.isEmpty() && allowedPlayers.isEmpty()) {
    allowedGroups.put(Integer.MIN_VALUE,Integer.MAX_VALUE);
  }
}",0.9847569744032212
150386,"@Override void convert(Attributes attributes,Stack<PermissionContainer> stack) throws SAXException {
  PermissionContainer container=stack.peek();
  String[] parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  String[] coords=parts[0].split(""String_Node_Str"");
  Coordinate start;
  if (coords.length == 2) {
    start=new Coordinate(getInt(coords[0]),0,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    start=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  Dimension dimension=(parts.length >= 2) ? Dimension.get(parts[1]) : Dimension.EARTH;
  parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  coords=parts[0].split(""String_Node_Str"");
  Coordinate end;
  if (coords.length == 2) {
    end=new Coordinate(getInt(coords[0]),0,getInt(coords[1]));
  }
 else {
    end=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
  if (!((Config)stack.firstElement()).dimensions.contains(dimension)) {
    ((Config)stack.firstElement()).dimensions.add(dimension);
  }
  DimensionAreaStorage.setInstance(((Config)stack.firstElement()).dimensions.get(dimension).areas);
  Area area=new Area(attributes.getValue(""String_Node_Str""),start,end);
  if (attributes.getIndex(""String_Node_Str"") >= 0) {
    area.owner=attributes.getValue(""String_Node_Str"").toLowerCase();
  }
  area.fullInit();
  if (container instanceof Config) {
    ((Config)container).dimensions.get(dimension).add(area);
  }
 else {
    ((Area)container).areas.add(area);
  }
  stack.push(area);
}","@Override void convert(Attributes attributes,Stack<PermissionContainer> stack) throws SAXException {
  PermissionContainer container=stack.peek();
  String[] parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  String[] coords=parts[0].split(""String_Node_Str"");
  Coordinate start;
  if (coords.length == 2) {
    start=new Coordinate(getInt(coords[0]),0,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    start=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  Dimension dimension=(parts.length >= 2) ? Dimension.get(parts[1]) : Dimension.EARTH;
  parts=attributes.getValue(""String_Node_Str"").split(""String_Node_Str"");
  coords=parts[0].split(""String_Node_Str"");
  Coordinate end;
  if (coords.length == 2) {
    end=new Coordinate(getInt(coords[0]),127,getInt(coords[1]));
  }
 else   if (coords.length >= 3) {
    end=new Coordinate(getInt(coords[0]),getInt(coords[1]),getInt(coords[2]));
  }
 else {
    throw new SAXException(""String_Node_Str"" + parts[0]);
  }
  if (!((Config)stack.firstElement()).dimensions.contains(dimension)) {
    ((Config)stack.firstElement()).dimensions.add(dimension);
  }
  DimensionAreaStorage.setInstance(((Config)stack.firstElement()).dimensions.get(dimension).areas);
  Area area=new Area(attributes.getValue(""String_Node_Str""),start,end);
  if (attributes.getIndex(""String_Node_Str"") >= 0) {
    area.owner=attributes.getValue(""String_Node_Str"").toLowerCase();
  }
  area.fullInit();
  if (container instanceof Config) {
    ((Config)container).dimensions.get(dimension).add(area);
  }
 else {
    ((Area)container).areas.add(area);
  }
  stack.push(area);
}",0.970131421744325
150387,"public static Config load(){
  File file=new File(""String_Node_Str"",""String_Node_Str"");
  if (!file.exists()) {
    return null;
  }
  System.out.println(""String_Node_Str"");
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    return null;
  }
  LegacyTagResolver handler;
  try {
    handler=new LegacyTagResolver();
  }
 catch (  SAXException e) {
    e.printStackTrace();
    return null;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",false);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new FileReader(file)));
  }
 catch (  FileNotFoundException e) {
    return null;
  }
catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  return handler.config();
}","public static Config load(){
  File file=new File(""String_Node_Str"",""String_Node_Str"");
  if (!file.exists()) {
    return null;
  }
  System.out.println(""String_Node_Str"");
  XMLReader xml;
  try {
    xml=XMLReaderFactory.createXMLReader();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  LegacyTagResolver handler;
  try {
    handler=new LegacyTagResolver();
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  xml.setContentHandler(handler);
  xml.setErrorHandler(handler);
  try {
    xml.setFeature(""String_Node_Str"",false);
    xml.setEntityResolver(handler);
    xml.parse(new InputSource(new FileReader(file)));
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
    return null;
  }
catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  return handler.config();
}",0.9289489136817382
150388,"@Override void setAttribute(String name,String value) throws SAXException {
  if (name.equals(ID)) {
    id=getInt(value);
  }
 else   if (name.equals(NAME)) {
    this.name=value.toLowerCase();
  }
 else   if (name.equals(COLOR)) {
    color=value.charAt(0);
  }
 else   if (name.equals(IGNORE_CHESTS)) {
    ignoreChestLocks=true;
  }
 else   if (name.equals(IGNORE_AREAS)) {
    ignoreAreas=true;
  }
 else   if (name.equals(FORWARD_UNKNOWN)) {
    forwardUnknownCommands=true;
  }
 else   if (name.equals(SHOW_TITLE)) {
    showTitle=true;
  }
 else   if (name.equals(COOLDOWN)) {
    cooldown=getInt(value);
  }
 else   if (name.equals(WARMUP)) {
    warmup=getInt(value);
  }
}","@Override void setAttribute(String name,String value) throws SAXException {
  if (name.equals(ID)) {
    id=getInt(value);
  }
 else   if (name.equals(NAME)) {
    this.name=value;
  }
 else   if (name.equals(COLOR)) {
    color=value.charAt(0);
  }
 else   if (name.equals(IGNORE_CHESTS)) {
    ignoreChestLocks=true;
  }
 else   if (name.equals(IGNORE_AREAS)) {
    ignoreAreas=true;
  }
 else   if (name.equals(FORWARD_UNKNOWN)) {
    forwardUnknownCommands=true;
  }
 else   if (name.equals(SHOW_TITLE)) {
    showTitle=true;
  }
 else   if (name.equals(COOLDOWN)) {
    cooldown=getInt(value);
  }
 else   if (name.equals(WARMUP)) {
    warmup=getInt(value);
  }
}",0.9896449704142012
150389,"private long lastBackupAge(){
  return age(newestBackup());
}","private long lastBackupAge(){
  long age=age(newestBackup());
  return (age >= 0) ? age : Long.MAX_VALUE;
}",0.6547619047619048
150390,"private static long age(File file){
  try {
    if (file == null) {
      return 0;
    }
 else {
      return System.currentTimeMillis() - date(file);
    }
  }
 catch (  ParseException e) {
    return System.currentTimeMillis() - file.lastModified();
  }
}","private static long age(File file){
  try {
    if (file == null) {
      return -1;
    }
 else {
      return System.currentTimeMillis() - date(file);
    }
  }
 catch (  ParseException e) {
    return System.currentTimeMillis() - file.lastModified();
  }
}",0.9941972920696324
150391,"public boolean allowGuestJoin(){
  return server.options.getBoolean(""String_Node_Str"");
}","public boolean allowGuestJoin(){
  return server.options.getBoolean(""String_Node_Str"") || !server.options.getBoolean(""String_Node_Str"");
}",0.7841409691629956
150392,"private void startup(){
  restart=false;
  loadResources();
  if (permissions.loadsuccess == false) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  authenticator=new Authenticator(this);
  playerList=new PlayerList(options);
  requestTracker=new RequestTracker(this);
  messager=new Messager(this);
  minecraft=new MinecraftWrapper(this,options,systemInput);
  if (!minecraft.prepareServerJar()) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  try {
    minecraft.start();
  }
 catch (  InterruptedException e) {
  }
  if (options.getBoolean(""String_Node_Str"")) {
    telnetServer=new TelnetServer(this);
  }
  if (options.getBoolean(""String_Node_Str"")) {
    rconServer=new RconServer(this);
  }
  world=new WorldFile(options.get(""String_Node_Str""));
  autoSpaceCheck=new AutoFreeSpaceChecker(this);
  autoBackup=new AutoBackup(this);
  autosave=new AutoSave(this);
  autoRestart=new AutoRestart(this);
  c10t=new AutoRun(this,options.get(""String_Node_Str""));
  if (options.contains(""String_Node_Str"")) {
    try {
      time.freeze(time.parse(options.get(""String_Node_Str"")));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
    }
  }
  bots.ready();
}","private void startup(){
  restart=false;
  loadResources();
  if (permissions.loadsuccess == false) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  authenticator=new Authenticator(this);
  playerList=new PlayerList(options);
  requestTracker=new RequestTracker(this);
  messager=new Messager(this);
  messageLog=new MessageLog(options.get(""String_Node_Str""),options.getBoolean(""String_Node_Str""));
  minecraft=new MinecraftWrapper(this,options,systemInput);
  if (!minecraft.prepareServerJar()) {
    System.out.println(""String_Node_Str"");
    System.exit(1);
  }
  try {
    minecraft.start();
  }
 catch (  InterruptedException e) {
  }
  if (options.getBoolean(""String_Node_Str"")) {
    telnetServer=new TelnetServer(this);
  }
  if (options.getBoolean(""String_Node_Str"")) {
    rconServer=new RconServer(this);
  }
  world=new WorldFile(options.get(""String_Node_Str""));
  autoSpaceCheck=new AutoFreeSpaceChecker(this);
  autoBackup=new AutoBackup(this);
  autosave=new AutoSave(this);
  autoRestart=new AutoRestart(this);
  c10t=new AutoRun(this,options.get(""String_Node_Str""));
  if (options.contains(""String_Node_Str"")) {
    try {
      time.freeze(time.parse(options.get(""String_Node_Str"")));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
    }
  }
  bots.ready();
}",0.9613130128956624
150393,"private void initialize(){
  resources=new LinkedList<Resource>();
  resources.add(permissions=new PermissionConfig(this));
  resources.add(options=new Options());
  resources.add(robots=new RobotList());
  resources.add(motd=new MOTD());
  resources.add(rules=new Rules());
  resources.add(helptext=new HelpText());
  resources.add(kits=new KitList(this));
  resources.add(ipBans=new IPBanList());
  resources.add(whitelist=new WhiteList());
  resources.add(mutelist=new MuteList());
  resources.add(giveAliasList=new GiveAliasList());
  resources.add(data=new GlobalData());
  resources.add(docs=new ReadFiles());
  time=new Time(this);
  bots=new BotController(this);
  systemInput=new SystemInputQueue();
  adminLog=new AdminLog();
  errorLog=new ErrorLog();
  connectionLog=new ConnectionLog();
  messageLog=new MessageLog(options.get(""String_Node_Str""),options.getBoolean(""String_Node_Str""));
  commandParser=new CommandParser(options,permissions);
}","private void initialize(){
  resources=new LinkedList<Resource>();
  resources.add(permissions=new PermissionConfig(this));
  resources.add(options=new Options());
  resources.add(robots=new RobotList());
  resources.add(motd=new MOTD());
  resources.add(rules=new Rules());
  resources.add(helptext=new HelpText());
  resources.add(kits=new KitList(this));
  resources.add(ipBans=new IPBanList());
  resources.add(whitelist=new WhiteList());
  resources.add(mutelist=new MuteList());
  resources.add(giveAliasList=new GiveAliasList());
  resources.add(data=new GlobalData());
  resources.add(docs=new ReadFiles());
  time=new Time(this);
  bots=new BotController(this);
  systemInput=new SystemInputQueue();
  adminLog=new AdminLog();
  errorLog=new ErrorLog();
  connectionLog=new ConnectionLog();
  commandParser=new CommandParser(options,permissions);
}",0.9023717595146168
150394,"@Override public void run(){
  while (run) {
    if (needsBackup()) {
      try {
        server.saveLock.acquire();
      }
 catch (      InterruptedException e) {
        continue;
      }
      forceBackup=false;
      server.autoSpaceCheck.check(true);
      if (server.options.getBoolean(""String_Node_Str"")) {
        server.runCommand(""String_Node_Str"",t(""String_Node_Str""));
      }
      server.setSaving(true);
      server.runCommand(""String_Node_Str"",null);
      while (server.isSaving()) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
        }
      }
      try {
        backup();
      }
 catch (      IOException e) {
        server.errorLog(e,""String_Node_Str"");
        System.out.println(""String_Node_Str"" + e);
        System.out.println(""String_Node_Str"");
      }
      server.saveLock.release();
      pauseBackup=(server.numPlayers() == 0);
    }
    try {
      Thread.sleep(60000);
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void run(){
  while (run) {
    if (needsBackup()) {
      try {
        server.saveLock.acquire();
      }
 catch (      InterruptedException e) {
        continue;
      }
      forceBackup=false;
      server.autoSpaceCheck.check(true);
      if (server.options.getBoolean(""String_Node_Str"")) {
        server.runCommand(""String_Node_Str"",t(""String_Node_Str""));
      }
      server.setSaving(true);
      server.runCommand(""String_Node_Str"",null);
      while (server.isSaving()) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
        }
      }
      try {
        backup();
      }
 catch (      IOException e) {
        server.errorLog(e,""String_Node_Str"");
        System.out.println(""String_Node_Str"" + e);
        System.out.println(""String_Node_Str"");
      }
      server.saveLock.release();
      if (server.numPlayers() == 0) {
        pauseBackup=true;
      }
    }
    if (pauseBackup && server.numPlayers() > 0) {
      pauseBackup=false;
    }
    try {
      Thread.sleep(60000);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9386416861826696
150395,"@Override public void save(){
  load();
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  super.save();
}","@Override public void save(){
  load();
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  super.save();
}",0.9716177861873226
150396,"public void teleportSelf(Position position){
  try {
    teleport(position);
  }
 catch (  Exception e) {
    addTMessage(Color.RED,""String_Node_Str"");
    return;
  }
  lastTeleport=new Date().getTime();
}","public void teleportSelf(Position position){
  try {
    teleport(position);
  }
 catch (  Exception e) {
    addTMessage(Color.RED,""String_Node_Str"");
    return;
  }
  lastTeleport=System.currentTimeMillis();
}",0.9282296650717704
150397,"private int cooldownLeft(){
  int cooldown=getGroup().getCooldownMillis();
  if (lastTeleport > new Date().getTime() - cooldown) {
    return (int)(cooldown - new Date().getTime() + lastTeleport);
  }
 else {
    return 0;
  }
}","private int cooldownLeft(){
  int cooldown=getGroup().getCooldownMillis();
  if (lastTeleport > System.currentTimeMillis() - cooldown) {
    return (int)(cooldown - System.currentTimeMillis() + lastTeleport);
  }
 else {
    return 0;
  }
}",0.8290598290598291
150398,"public void execute(Player player,String message){
  Homes homes=player.getServer().data.players.homes;
  String playerName=player.getName();
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    teleportHome(player);
    return;
  }
  String command=arguments[0];
  if (command.equals(""String_Node_Str"")) {
    usage(player);
  }
 else   if (command.equals(""String_Node_Str"")) {
    if (homes.get(playerName) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    homes.set(playerName,homes.makeHomePoint(player.position));
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    if (homes.get(playerName) == null) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    homes.remove(playerName);
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (home.isPublic == true) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    home.isPublic=true;
    homes.set(playerName,home);
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (home.isPublic == false) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    home.isPublic=false;
    homes.set(playerName,home);
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    List<String> list=homes.getHomesPlayerInvitedTo(playerName);
    if (list.isEmpty()) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    player.addTMessage(Color.GRAY,""String_Node_Str"",join(list).trim());
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (home.isPublic) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    List<String> list=home.getPlayersInvited();
    if (list.isEmpty()) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    player.addTMessage(Color.GRAY,""String_Node_Str"",join(list).trim());
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (arguments.length == 1) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      usage(player);
      return;
    }
    String iPlayer=arguments[1];
    Player onlineTarget=player.getServer().findPlayer(iPlayer);
    if (onlineTarget != null) {
      iPlayer=onlineTarget.getName();
    }
    if (!home.invites.contains(new NBTString(iPlayer))) {
      home.invites.add(new NBTString(iPlayer));
      player.addTMessage(Color.GRAY,""String_Node_Str"",iPlayer);
      if (onlineTarget != null) {
        onlineTarget.addTMessage(Color.GRAY,""String_Node_Str"",getName());
      }
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (arguments.length == 1) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      usage(player);
      return;
    }
    String uiPlayer=home.getInvitedPlayer(arguments[1]);
    if (home.invites.contains(new NBTString(uiPlayer))) {
      home.invites.remove(new NBTString(uiPlayer));
      player.addTMessage(Color.GRAY,""String_Node_Str"",uiPlayer);
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
  }
 else {
    if (command == playerName) {
      teleportHome(player);
      return;
    }
    String target=command;
    String onlinePlayer=player.getServer().findName(target);
    if (onlinePlayer != null) {
      target=onlinePlayer;
    }
 else {
      List<String> list=homes.getHomesPlayerInvitedTo(playerName);
      for (      String p : list) {
        if (p.startsWith(target)) {
          target=p;
          break;
        }
      }
    }
    HomePoint home=homes.get(target);
    if (home == null) {
      usage(player);
      return;
    }
    if ((home.isPublic && player.getServer().findPlayer(target) != null) || home.invites.contains(new NBTString(playerName))) {
      player.teleportWithWarmup(home.position);
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"",command);
    }
  }
}","public void execute(Player player,String message){
  Homes homes=player.getServer().data.players.homes;
  String playerName=player.getName();
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    teleportHome(player);
    return;
  }
  String command=arguments[0];
  if (command.equals(""String_Node_Str"")) {
    usage(player);
  }
 else   if (command.equals(""String_Node_Str"")) {
    if (homes.get(playerName) != null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    homes.set(playerName,homes.makeHomePoint(player.position));
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    if (homes.get(playerName) == null) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    homes.remove(playerName);
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (home.isPublic == true) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    home.isPublic=true;
    homes.set(playerName,home);
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (home.isPublic == false) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    home.isPublic=false;
    homes.set(playerName,home);
    player.getServer().data.save();
    player.addTMessage(Color.GRAY,""String_Node_Str"");
  }
 else   if (command.equals(""String_Node_Str"")) {
    List<String> inviteList=new LinkedList<String>();
    List<String> publicList=new LinkedList<String>();
    homes.getVisitableHomes(playerName,inviteList,publicList);
    if (inviteList.isEmpty() && publicList.isEmpty()) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    player.addTMessage(Color.GRAY,""String_Node_Str"",join(publicList).trim());
    player.addTMessage(Color.GRAY,""String_Node_Str"",join(inviteList).trim());
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (home.isPublic) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    List<String> list=home.getPlayersInvited();
    if (list.isEmpty()) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
    player.addTMessage(Color.GRAY,""String_Node_Str"",join(list).trim());
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (arguments.length == 1) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      usage(player);
      return;
    }
    String iPlayer=arguments[1];
    Player onlineTarget=player.getServer().findPlayer(iPlayer);
    if (onlineTarget != null) {
      iPlayer=onlineTarget.getName();
    }
    if (!home.invites.contains(new NBTString(iPlayer))) {
      home.invites.add(new NBTString(iPlayer));
      player.addTMessage(Color.GRAY,""String_Node_Str"",iPlayer);
      if (onlineTarget != null) {
        onlineTarget.addTMessage(Color.GRAY,""String_Node_Str"",player.getName());
      }
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
  }
 else   if (command.equals(""String_Node_Str"")) {
    HomePoint home=homes.get(playerName);
    if (home == null) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      return;
    }
    if (arguments.length == 1) {
      player.addTMessage(Color.RED,""String_Node_Str"");
      usage(player);
      return;
    }
    String uiPlayer=home.getInvitedPlayer(arguments[1]);
    if (home.invites.contains(new NBTString(uiPlayer))) {
      home.invites.remove(new NBTString(uiPlayer));
      player.addTMessage(Color.GRAY,""String_Node_Str"",uiPlayer);
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
  }
 else {
    if (command.toLowerCase().equals(playerName.toLowerCase())) {
      teleportHome(player);
      return;
    }
    String target=command;
    String onlinePlayer=player.getServer().findName(target);
    if (onlinePlayer != null) {
      target=onlinePlayer;
    }
 else {
      List<String> list=homes.getHomesPlayerInvitedTo(playerName);
      for (      String p : list) {
        if (p.startsWith(target)) {
          target=p;
          break;
        }
      }
    }
    HomePoint home=homes.get(target);
    if (home == null) {
      usage(player);
      return;
    }
    if ((home.isPublic && player.getServer().findPlayer(target) != null) || home.invites.contains(new NBTString(playerName)) || target.toLowerCase().equals(playerName.toLowerCase())) {
      player.teleportWithWarmup(home.position);
    }
 else {
      player.addTMessage(Color.RED,""String_Node_Str"",command);
    }
  }
}",0.5722335567861654
150399,"public List<String> getHomesPlayerInvitedTo(String playerName){
  List<String> invitedTo=new LinkedList<String>();
  for (  String name : playerData.names()) {
    NBTCompound player=playerData.get(name);
    if (player.containsKey(HOME)) {
      HomePoint home=new HomePoint(player.getCompound(HOME));
      if (home.invites.contains(new NBTString(playerName))) {
        invitedTo.add(name);
      }
    }
  }
  return invitedTo;
}","public List<String> getHomesPlayerInvitedTo(String playerName){
  List<String> invitedHomes=new LinkedList<String>();
  for (  String name : playerData.names()) {
    NBTCompound player=playerData.get(name);
    if (player.containsKey(HOME)) {
      HomePoint home=new HomePoint(player.getCompound(HOME));
      if (home.invites.contains(new NBTString(playerName))) {
        invitedHomes.add(name);
      }
    }
  }
  return invitedHomes;
}",0.976
150400,"public void loadResources(){
  for (  Resource resource : resources) {
    resource.load();
  }
  if (playerList != null) {
    playerList.updatePlayerGroups();
  }
  if (!Translations.getInstance().setLanguage(options.get(""String_Node_Str""))) {
    options.set(""String_Node_Str"",""String_Node_Str"");
    options.save();
  }
  addressFactory.toggle(!options.getBoolean(""String_Node_Str""));
  commandParser.reload();
}","public void loadResources(){
  for (  Resource resource : resources) {
    resource.load();
  }
  if (playerList != null) {
    playerList.updatePlayerGroups();
  }
  if (!Translations.getInstance().setLanguage(options.get(""String_Node_Str""))) {
    options.set(""String_Node_Str"",""String_Node_Str"");
    options.save();
  }
  addressFactory.toggle(!options.getBoolean(""String_Node_Str""));
}",0.967741935483871
150401,"public String getHelpText(String prefix){
  if (name != null) {
    return Color.DARK_GREEN + prefix + helpText;
  }
 else {
    return helpText;
  }
}","public String getHelpText(String prefix){
  if (help != null) {
    return Color.DARK_GREEN + prefix + help+ ""String_Node_Str""+ Color.WHITE+ t(commandCode);
  }
 else {
    return t(commandCode);
  }
}",0.7727272727272727
150402,"protected AbstractCommand(String name,String commandCode){
  if (name != null) {
    helpText=name + Color.WHITE + ""String_Node_Str""+ t(commandCode);
    int splitIndex=name.indexOf(""String_Node_Str"");
    if (splitIndex != -1) {
      name=name.substring(0,splitIndex);
    }
  }
 else {
    helpText=t(commandCode);
  }
  this.name=name;
  this.commandCode=commandCode;
}","protected AbstractCommand(String name,String commandCode){
  help=name;
  if (name != null) {
    int splitIndex=name.indexOf(""String_Node_Str"");
    if (splitIndex != -1) {
      name=name.substring(0,splitIndex);
    }
  }
  this.name=name;
  this.commandCode=commandCode;
}",0.5793528505392912
150403,"public void giveLock(Player player,Coordinate coordinate,String name){
  giveLock(player.getName(),coordinate,name);
}","public void giveLock(Player player,Coordinate coordinate,String name){
  giveLock(player.getName().toLowerCase(),coordinate,name);
}",0.944
150404,"public String getInvitedPlayer(String prefix){
  for (  String playerName : getPlayersInvited()) {
    if (playerName.startsWith(prefix)) {
      return playerName;
    }
  }
  return prefix;
}","public String getInvitedPlayer(String prefix){
  if (getPlayersInvited().contains(prefix)) {
    return prefix;
  }
  for (  String playerName : getPlayersInvited()) {
    if (playerName.startsWith(prefix)) {
      return playerName;
    }
  }
  return prefix;
}",0.843956043956044
150405,"public void close(){
  if (serverToClient != null) {
    serverToClient.stop();
  }
  if (clientToServer != null) {
    clientToServer.stop();
  }
  if (name != null) {
    server.authenticator.unbanLogin(this);
    if (usedAuthenticator) {
      if (guest) {
        server.authenticator.releaseGuestName(name);
      }
 else {
        server.authenticator.rememberAuthentication(name,getIPAddress());
      }
    }
 else     if (guest) {
      server.authenticator.rememberGuest(name,getIPAddress());
    }
    server.data.players.stats.add(this,StatField.PLAY_TIME,(int)(System.currentTimeMillis() - connected) / 1000 / 60);
    server.data.players.stats.add(this,StatField.BLOCKS_DESTROYED,blocksDestroyed);
    server.data.players.stats.add(this,StatField.BLOCKS_PLACED,blocksPlaced);
    server.data.save();
    server.playerList.removePlayer(this);
    name=null;
  }
}","public void close(){
  if (serverToClient != null) {
    serverToClient.stop();
  }
  if (clientToServer != null) {
    clientToServer.stop();
  }
  if (name != null) {
    server.authenticator.unbanLogin(this);
    if (usedAuthenticator) {
      if (guest) {
        server.authenticator.releaseGuestName(name);
      }
 else {
        server.authenticator.rememberAuthentication(name,getIPAddress());
      }
    }
 else     if (guest) {
      if (isKicked) {
        server.authenticator.releaseGuestName(name);
      }
 else {
        server.authenticator.rememberGuest(name,getIPAddress());
      }
    }
    server.data.players.stats.add(this,StatField.PLAY_TIME,(int)(System.currentTimeMillis() - connected) / 1000 / 60);
    server.data.players.stats.add(this,StatField.BLOCKS_DESTROYED,blocksDestroyed);
    server.data.players.stats.add(this,StatField.BLOCKS_PLACED,blocksPlaced);
    server.data.save();
    server.playerList.removePlayer(this);
    name=null;
  }
}",0.9454937938478144
150406,"private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
  byte dimension;
  Coordinate coordinate;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
if (server.authenticator.useCustAuth(player) && !server.authenticator.onlineAuthenticate(player)) {
  player.kick(t(""String_Node_Str"",""String_Node_Str""));
  break;
}
player.setEntityId(write(in.readInt()));
write(readUTF16());
server.setMapSeed(write(in.readLong()));
}
 else {
write(in.readInt());
readUTF16();
write(player.getName());
write(in.readLong());
}
dimension=in.readByte();
if (isServerTunnel) {
player.setDimension(Dimension.get(dimension));
}
write(dimension);
break;
case 0x02:
String name=readUTF16();
boolean nameSet=false;
if (isServerTunnel) {
if (!server.authenticator.useCustAuth(player)) {
name=""String_Node_Str"";
}
 else if (!server.authenticator.vanillaOnlineMode()) {
name=player.getConnectionHash();
}
}
 else {
if (name.equals(""String_Node_Str"") || !server.authenticator.isMinecraftUp) {
AuthRequest req=server.authenticator.getAuthRequest(player.getIPAddress());
if (req != null) {
name=req.playerName;
nameSet=server.authenticator.completeLogin(req,player);
}
if (req == null || !nameSet) {
if (!name.equals(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
player.addTMessage(Color.RED,""String_Node_Str"");
}
name=server.authenticator.getFreeGuestName();
nameSet=player.setName(name);
player.setGuest(true);
}
}
 else {
nameSet=player.setName(name);
if (nameSet) {
player.updateRealName(name);
}
}
}
if (isServerTunnel || nameSet) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
Matcher joinMatcher=JOIN_PATTERN.matcher(message);
if (isServerTunnel && joinMatcher.find()) {
if (server.bots.ninja(joinMatcher.group(1))) {
break;
}
if (message.contains(""String_Node_Str"")) {
player.addTMessage(Color.YELLOW,""String_Node_Str"",joinMatcher.group(1));
}
 else {
player.addTMessage(Color.YELLOW,""String_Node_Str"",joinMatcher.group(1));
}
break;
}
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
 else if (cleanMessage.matches(CONSOLE_CHAT_PATTERN) && !server.options.getBoolean(""String_Node_Str"")) {
break;
}
if (server.options.getBoolean(""String_Node_Str"")) {
sendMessage(message);
}
 else {
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
}
 else if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
break;
case 0x04:
write(packetId);
long time=in.readLong();
server.setTime(time);
write(time);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
dimension=in.readByte();
write(dimension);
player.setDimension(Dimension.get(dimension));
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
copyNBytes(1);
break;
case 0x0c:
write(packetId);
copyPlayerLook();
copyNBytes(1);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyPlayerLook();
copyNBytes(1);
break;
case 0x0e:
if (!isServerTunnel) {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
coordinate=new Coordinate(x,y,z,player);
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,0);
if (!perms[2] && status == 0) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (!perms[1] && status == 2) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
boolean locked=server.data.chests.isLocked(coordinate);
if (!locked || player.isAdmin()) {
if (locked && status == BLOCK_DESTROYED_STATUS) {
server.data.chests.releaseLock(coordinate);
server.data.save();
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
coordinate=new Coordinate(x,y,z,player);
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,dropItem);
if (isServerTunnel || server.data.chests.isChest(coordinate)) {
}
 else if ((dropItem != -1 && !perms[0]) || (dropItem == -1 && !perms[2])) {
if (dropItem == -1) {
player.addTMessage(Color.RED,""String_Node_Str"");
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
}
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Coordinate targetBlock=new Coordinate(xPosition,yPosition,zPosition,player);
Chest adjacentChest=server.data.chests.adjacentChest(targetBlock);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addTMessage(Color.RED,""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(targetBlock);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(coordinate);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
int eid=in.readInt();
name=readUTF16();
if (!server.bots.ninja(name)) {
write(packetId);
write(eid);
write(name);
copyNBytes(16);
}
 else {
skipNBytes(16);
}
break;
case 0x15:
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
int flag=in.readInt();
write(flag);
if (flag > 0) {
write(in.readShort());
write(in.readShort());
write(in.readShort());
}
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
coordinate=new Coordinate(x,y,z,player);
if (blockType == 54 && player.placedChest(coordinate)) {
lockChest(coordinate);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x3d:
write(packetId);
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
byte unknownByte=in.readByte();
if (invtype == 0) {
Chest adjacent=server.data.chests.adjacentChest(player.openedChest());
if (!server.data.chests.isChest(player.openedChest())) {
if (adjacent == null) {
server.data.chests.addOpenChest(player.openedChest());
}
 else {
server.data.chests.giveLock(adjacent.owner,player.openedChest(),adjacent.name);
}
server.data.save();
}
if (!server.permissions.canOpenChests(player,player.openedChest()) || (adjacent != null && !server.permissions.canOpenChests(player,adjacent.coordinate))) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
 else if (server.data.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.data.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.data.chests.unlock(player.openedChest());
server.data.save();
player.setAttemptedAction(null);
player.addTMessage(Color.RED,""String_Node_Str"");
typeString=t(""String_Node_Str"");
}
 else {
typeString=server.data.chests.chestName(player.openedChest());
}
}
 else {
typeString=t(""String_Node_Str"");
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=(player.nextChestName() == null) ? t(""String_Node_Str"") : player.nextChestName();
}
}
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(unknownByte);
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x67:
byte type67=in.readByte();
short slot=in.readShort();
short setItem=in.readShort();
write(packetId);
write(type67);
write(slot);
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x68:
byte type=in.readByte();
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0x83:
write(packetId);
write(in.readShort());
write(in.readShort());
byte length=in.readByte();
write(length);
copyNBytes(0xff & length);
break;
case (byte)0xc8:
write(packetId);
copyNBytes(5);
break;
case (byte)0xe6:
write(packetId);
write(in.readInt());
write(in.readInt());
copyNBytes(write(in.readInt()) * 4);
copyNBytes(write(in.readInt()) * 4);
int sizeString=write(in.readInt());
for (int i=0; i < sizeString; i++) {
copyNBytes(write(in.readInt()));
}
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName()+ ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
}
packetFinished();
lastPacket=packetId;
}","private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
  byte dimension;
  Coordinate coordinate;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
if (server.authenticator.useCustAuth(player) && !server.authenticator.onlineAuthenticate(player)) {
  player.kick(t(""String_Node_Str"",""String_Node_Str""));
  break;
}
player.setEntityId(write(in.readInt()));
write(readUTF16());
server.setMapSeed(write(in.readLong()));
}
 else {
write(in.readInt());
readUTF16();
write(player.getName());
write(in.readLong());
}
dimension=in.readByte();
if (isServerTunnel) {
player.setDimension(Dimension.get(dimension));
}
write(dimension);
break;
case 0x02:
String name=readUTF16();
boolean nameSet=false;
if (isServerTunnel) {
if (!server.authenticator.useCustAuth(player)) {
name=""String_Node_Str"";
}
 else if (!server.authenticator.vanillaOnlineMode()) {
name=player.getConnectionHash();
}
}
 else {
if (name.equals(""String_Node_Str"") || !server.authenticator.isMinecraftUp) {
AuthRequest req=server.authenticator.getAuthRequest(player.getIPAddress());
if (req != null) {
name=req.playerName;
nameSet=server.authenticator.completeLogin(req,player);
}
if (req == null || !nameSet) {
if (!name.equals(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
player.addTMessage(Color.RED,""String_Node_Str"");
}
name=server.authenticator.getFreeGuestName();
nameSet=player.setName(name);
player.setGuest(true);
}
}
 else {
nameSet=player.setName(name);
if (nameSet) {
player.updateRealName(name);
}
}
}
if (player.isGuest() && !server.authenticator.allowGuestJoin()) {
player.kick(t(""String_Node_Str""));
nameSet=false;
}
if (isServerTunnel || nameSet) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
Matcher joinMatcher=JOIN_PATTERN.matcher(message);
if (isServerTunnel && joinMatcher.find()) {
if (server.bots.ninja(joinMatcher.group(1))) {
break;
}
if (message.contains(""String_Node_Str"")) {
player.addTMessage(Color.YELLOW,""String_Node_Str"",joinMatcher.group(1));
}
 else {
player.addTMessage(Color.YELLOW,""String_Node_Str"",joinMatcher.group(1));
}
break;
}
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
 else if (cleanMessage.matches(CONSOLE_CHAT_PATTERN) && !server.options.getBoolean(""String_Node_Str"")) {
break;
}
if (server.options.getBoolean(""String_Node_Str"")) {
sendMessage(message);
}
 else {
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
}
 else if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
break;
case 0x04:
write(packetId);
long time=in.readLong();
server.setTime(time);
write(time);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
dimension=in.readByte();
write(dimension);
player.setDimension(Dimension.get(dimension));
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
copyNBytes(1);
break;
case 0x0c:
write(packetId);
copyPlayerLook();
copyNBytes(1);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyPlayerLook();
copyNBytes(1);
break;
case 0x0e:
if (!isServerTunnel) {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
coordinate=new Coordinate(x,y,z,player);
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,0);
if (!perms[2] && status == 0) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (!perms[1] && status == 2) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
boolean locked=server.data.chests.isLocked(coordinate);
if (!locked || player.isAdmin()) {
if (locked && status == BLOCK_DESTROYED_STATUS) {
server.data.chests.releaseLock(coordinate);
server.data.save();
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
coordinate=new Coordinate(x,y,z,player);
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,dropItem);
if (isServerTunnel || server.data.chests.isChest(coordinate)) {
}
 else if ((dropItem != -1 && !perms[0]) || (dropItem == -1 && !perms[2])) {
if (dropItem == -1) {
player.addTMessage(Color.RED,""String_Node_Str"");
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
}
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Coordinate targetBlock=new Coordinate(xPosition,yPosition,zPosition,player);
Chest adjacentChest=server.data.chests.adjacentChest(targetBlock);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addTMessage(Color.RED,""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(targetBlock);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(coordinate);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
int eid=in.readInt();
name=readUTF16();
if (!server.bots.ninja(name)) {
write(packetId);
write(eid);
write(name);
copyNBytes(16);
}
 else {
skipNBytes(16);
}
break;
case 0x15:
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
int flag=in.readInt();
write(flag);
if (flag > 0) {
write(in.readShort());
write(in.readShort());
write(in.readShort());
}
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
coordinate=new Coordinate(x,y,z,player);
if (blockType == 54 && player.placedChest(coordinate)) {
lockChest(coordinate);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x3d:
write(packetId);
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
byte unknownByte=in.readByte();
if (invtype == 0) {
Chest adjacent=server.data.chests.adjacentChest(player.openedChest());
if (!server.data.chests.isChest(player.openedChest())) {
if (adjacent == null) {
server.data.chests.addOpenChest(player.openedChest());
}
 else {
server.data.chests.giveLock(adjacent.owner,player.openedChest(),adjacent.name);
}
server.data.save();
}
if (!server.permissions.canOpenChests(player,player.openedChest()) || (adjacent != null && !server.permissions.canOpenChests(player,adjacent.coordinate))) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
 else if (server.data.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.data.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.data.chests.unlock(player.openedChest());
server.data.save();
player.setAttemptedAction(null);
player.addTMessage(Color.RED,""String_Node_Str"");
typeString=t(""String_Node_Str"");
}
 else {
typeString=server.data.chests.chestName(player.openedChest());
}
}
 else {
typeString=t(""String_Node_Str"");
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=(player.nextChestName() == null) ? t(""String_Node_Str"") : player.nextChestName();
}
}
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(unknownByte);
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x67:
byte type67=in.readByte();
short slot=in.readShort();
short setItem=in.readShort();
write(packetId);
write(type67);
write(slot);
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x68:
byte type=in.readByte();
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0x83:
write(packetId);
write(in.readShort());
write(in.readShort());
byte length=in.readByte();
write(length);
copyNBytes(0xff & length);
break;
case (byte)0xc8:
write(packetId);
copyNBytes(5);
break;
case (byte)0xe6:
write(packetId);
write(in.readInt());
write(in.readInt());
copyNBytes(write(in.readInt()) * 4);
copyNBytes(write(in.readInt()) * 4);
int sizeString=write(in.readInt());
for (int i=0; i < sizeString; i++) {
copyNBytes(write(in.readInt()));
}
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName()+ ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
}
packetFinished();
lastPacket=packetId;
}",0.9958905063731978
150407,"public synchronized String getNextAddress(){
  if (!canCycle()) {
    return ""String_Node_Str"";
  }
  if (octets[2] >= 255) {
    if (octets[1] >= 255) {
      if (octets[0] >= 255) {
        octets[0]=0;
      }
 else {
        ++octets[0];
      }
      octets[1]=0;
    }
 else {
      ++octets[1];
    }
    octets[2]=2;
  }
 else {
    ++octets[2];
  }
  return ""String_Node_Str"" + octets[0] + ""String_Node_Str""+ octets[1]+ ""String_Node_Str""+ octets[2];
}","public synchronized String getNextAddress(){
  if (!enabled || !canCycle()) {
    return ""String_Node_Str"";
  }
  if (octets[2] >= 255) {
    if (octets[1] >= 255) {
      if (octets[0] >= 255) {
        octets[0]=0;
      }
 else {
        ++octets[0];
      }
      octets[1]=0;
    }
 else {
      ++octets[1];
    }
    octets[2]=2;
  }
 else {
    ++octets[2];
  }
  return ""String_Node_Str"" + octets[0] + ""String_Node_Str""+ octets[1]+ ""String_Node_Str""+ octets[2];
}",0.9871244635193132
150408,"private void toggle(boolean enabled){
  canCycle=enabled ? null : false;
}","private void toggle(boolean enabled){
  LocalAddressFactory.enabled=enabled;
}",0.7368421052631579
150409,"private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
  byte dimension;
  Coordinate coordinate;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(readUTF16());
write(in.readLong());
dimension=in.readByte();
if (isServerTunnel) {
player.setDimension(Dimension.get(dimension));
}
write(dimension);
break;
case 0x02:
String name=readUTF16();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
Matcher joinMatcher=JOIN_PATTERN.matcher(message);
if (isServerTunnel && joinMatcher.find()) {
if (server.bots.ninja(joinMatcher.group(1))) {
break;
}
}
 else if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
 else if (cleanMessage.matches(CONSOLE_CHAT_PATTERN) && !server.options.getBoolean(""String_Node_Str"")) {
break;
}
if (server.options.getBoolean(""String_Node_Str"")) {
sendMessage(message);
}
 else {
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
}
 else if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
break;
case 0x04:
write(packetId);
long time=in.readLong();
server.setTime(time);
write(time);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
dimension=in.readByte();
write(dimension);
player.setDimension(Dimension.get(dimension));
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
copyNBytes(1);
break;
case 0x0c:
write(packetId);
copyPlayerLook();
copyNBytes(1);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyPlayerLook();
copyNBytes(1);
break;
case 0x0e:
if (!isServerTunnel) {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
coordinate=new Coordinate(x,y,z,player);
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,0);
if (!perms[2] && status == 0) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (!perms[1] && status == 2) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
boolean locked=server.data.chests.isLocked(coordinate);
if (!locked || player.isAdmin()) {
if (locked && status == BLOCK_DESTROYED_STATUS) {
server.data.chests.releaseLock(coordinate);
server.data.save();
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
coordinate=new Coordinate(x,y,z,player);
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,dropItem);
if (isServerTunnel || server.data.chests.isChest(coordinate)) {
}
 else if ((dropItem != -1 && !perms[0]) || (dropItem == -1 && !perms[2])) {
if (dropItem == -1) {
player.addTMessage(Color.RED,""String_Node_Str"");
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
}
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Coordinate targetBlock=new Coordinate(xPosition,yPosition,zPosition,player);
Chest adjacentChest=server.data.chests.adjacentChest(targetBlock);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addTMessage(Color.RED,""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(targetBlock);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(coordinate);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
int eid=in.readInt();
name=readUTF16();
if (!server.bots.ninja(name)) {
write(packetId);
write(eid);
write(name);
copyNBytes(16);
}
 else {
skipNBytes(16);
}
break;
case 0x15:
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
int flag=in.readInt();
write(flag);
if (flag > 0) {
write(in.readShort());
write(in.readShort());
write(in.readShort());
}
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
coordinate=new Coordinate(x,y,z,player);
if (blockType == 54 && player.placedChest(coordinate)) {
lockChest(coordinate);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x3d:
write(packetId);
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
byte unknownByte=in.readByte();
if (invtype == 0) {
if (!server.permissions.canOpenChests(player,player.openedChest())) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
 else if (server.data.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.data.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.data.chests.unlock(player.openedChest());
server.data.save();
player.setAttemptedAction(null);
player.addTMessage(Color.RED,""String_Node_Str"");
typeString=t(""String_Node_Str"");
}
 else {
typeString=server.data.chests.chestName(player.openedChest());
}
}
 else {
typeString=t(""String_Node_Str"");
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=player.nextChestName();
}
}
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(unknownByte);
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x67:
byte type67=in.readByte();
short slot=in.readShort();
short setItem=in.readShort();
write(packetId);
write(type67);
write(slot);
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x68:
byte type=in.readByte();
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0x83:
write(packetId);
write(in.readShort());
write(in.readShort());
byte length=in.readByte();
write(length);
copyNBytes(0xff & length);
break;
case (byte)0xc8:
write(packetId);
copyNBytes(5);
break;
case (byte)0xe6:
write(packetId);
write(in.readInt());
write(in.readInt());
copyNBytes(write(in.readInt()) * 4);
copyNBytes(write(in.readInt()) * 4);
int sizeString=write(in.readInt());
for (int i=0; i < sizeString; i++) {
copyNBytes(write(in.readInt()));
}
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName()+ ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
}
packetFinished();
lastPacket=packetId;
}","private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
  byte dimension;
  Coordinate coordinate;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(readUTF16());
write(in.readLong());
dimension=in.readByte();
if (isServerTunnel) {
player.setDimension(Dimension.get(dimension));
}
write(dimension);
break;
case 0x02:
String name=readUTF16();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
Matcher joinMatcher=JOIN_PATTERN.matcher(message);
if (isServerTunnel && joinMatcher.find()) {
if (server.bots.ninja(joinMatcher.group(1))) {
break;
}
}
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
 else if (cleanMessage.matches(CONSOLE_CHAT_PATTERN) && !server.options.getBoolean(""String_Node_Str"")) {
break;
}
if (server.options.getBoolean(""String_Node_Str"")) {
sendMessage(message);
}
 else {
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
}
 else if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
break;
case 0x04:
write(packetId);
long time=in.readLong();
server.setTime(time);
write(time);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
dimension=in.readByte();
write(dimension);
player.setDimension(Dimension.get(dimension));
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
copyNBytes(1);
break;
case 0x0c:
write(packetId);
copyPlayerLook();
copyNBytes(1);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyPlayerLook();
copyNBytes(1);
break;
case 0x0e:
if (!isServerTunnel) {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
coordinate=new Coordinate(x,y,z,player);
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,0);
if (!perms[2] && status == 0) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (!perms[1] && status == 2) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
boolean locked=server.data.chests.isLocked(coordinate);
if (!locked || player.isAdmin()) {
if (locked && status == BLOCK_DESTROYED_STATUS) {
server.data.chests.releaseLock(coordinate);
server.data.save();
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
coordinate=new Coordinate(x,y,z,player);
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,dropItem);
if (isServerTunnel || server.data.chests.isChest(coordinate)) {
}
 else if ((dropItem != -1 && !perms[0]) || (dropItem == -1 && !perms[2])) {
if (dropItem == -1) {
player.addTMessage(Color.RED,""String_Node_Str"");
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
}
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Coordinate targetBlock=new Coordinate(xPosition,yPosition,zPosition,player);
Chest adjacentChest=server.data.chests.adjacentChest(targetBlock);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addTMessage(Color.RED,""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(targetBlock);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(coordinate);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
int eid=in.readInt();
name=readUTF16();
if (!server.bots.ninja(name)) {
write(packetId);
write(eid);
write(name);
copyNBytes(16);
}
 else {
skipNBytes(16);
}
break;
case 0x15:
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
int flag=in.readInt();
write(flag);
if (flag > 0) {
write(in.readShort());
write(in.readShort());
write(in.readShort());
}
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
coordinate=new Coordinate(x,y,z,player);
if (blockType == 54 && player.placedChest(coordinate)) {
lockChest(coordinate);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x3d:
write(packetId);
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
byte unknownByte=in.readByte();
if (invtype == 0) {
if (!server.permissions.canOpenChests(player,player.openedChest())) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
 else if (server.data.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.data.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.data.chests.unlock(player.openedChest());
server.data.save();
player.setAttemptedAction(null);
player.addTMessage(Color.RED,""String_Node_Str"");
typeString=t(""String_Node_Str"");
}
 else {
typeString=server.data.chests.chestName(player.openedChest());
}
}
 else {
typeString=t(""String_Node_Str"");
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=player.nextChestName();
}
}
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(unknownByte);
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x67:
byte type67=in.readByte();
short slot=in.readShort();
short setItem=in.readShort();
write(packetId);
write(type67);
write(slot);
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x68:
byte type=in.readByte();
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0x83:
write(packetId);
write(in.readShort());
write(in.readShort());
byte length=in.readByte();
write(length);
copyNBytes(0xff & length);
break;
case (byte)0xc8:
write(packetId);
copyNBytes(5);
break;
case (byte)0xe6:
write(packetId);
write(in.readInt());
write(in.readInt());
copyNBytes(write(in.readInt()) * 4);
copyNBytes(write(in.readInt()) * 4);
int sizeString=write(in.readInt());
for (int i=0; i < sizeString; i++) {
copyNBytes(write(in.readInt()));
}
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName()+ ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
}
packetFinished();
lastPacket=packetId;
}",0.999761620977354
150410,"/** 
 * PERMISSIONS 
 */
public boolean vanillaOnlineMode(){
  return !server.options.getBoolean(""String_Node_Str"") && server.options.getBoolean(""String_Node_Str"");
}","/** 
 * PERMISSIONS 
 */
public boolean vanillaOnlineMode(){
  return false;
}",0.6147540983606558
150411,"@Override public void finalize(){
  timer.cancel();
  cleanLoginRequests();
}","@Override public void finalize(){
  try {
    timer.cancel();
  }
 catch (  Exception e) {
  }
  cleanLoginRequests();
}",0.7817258883248731
150412,"@Override public void save(){
  load();
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  if (simpleServerOptions.getBoolean(""String_Node_Str"")) {
    options.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  }
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  super.save();
}","@Override public void save(){
  load();
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  super.save();
}",0.1145175834084761
150413,"public void handleOutput(String line){
  if (!server.options.getBoolean(""String_Node_Str"") && line.contains(""String_Node_Str"")) {
    return;
  }
  Integer[] ports=server.getRobotPorts();
  if (ports != null) {
    for (    Integer port : ports) {
      if (port != null) {
        if (line.contains(port.toString())) {
          server.removeRobotPort(port);
          return;
        }
      }
    }
  }
  if (line.contains(""String_Node_Str"")) {
synchronized (this) {
      loaded=true;
      notifyAll();
    }
  }
 else   if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
    server.setSaving(false);
    if (server.options.getBoolean(""String_Node_Str"")) {
      server.runCommand(""String_Node_Str"",t(""String_Node_Str""));
    }
  }
 else   if (line.contains(""String_Node_Str"")) {
    handleError(new Exception(line));
  }
 else   if (line.matches(""String_Node_Str"")) {
    return;
  }
 else   if (line.contains(""String_Node_Str"") && server.options.getBoolean(""String_Node_Str"")) {
    return;
  }
 else {
    Matcher connect=CONNECT.matcher(line);
    if (connect.find()) {
      if (server.bots.ninja(connect.group(1))) {
        return;
      }
    }
 else {
      Matcher disconnect=DISCONNECT.matcher(line);
      if (disconnect.find()) {
        if (server.bots.ninja(disconnect.group(1))) {
          return;
        }
      }
    }
  }
  server.addOutputLine(line);
  System.out.println(line);
}","public void handleOutput(String line){
  if (!server.options.getBoolean(""String_Node_Str"") && line.contains(""String_Node_Str"")) {
    return;
  }
  Integer[] ports=server.getRobotPorts();
  if (ports != null) {
    for (    Integer port : ports) {
      if (port != null) {
        if (line.contains(port.toString())) {
          server.removeRobotPort(port);
          return;
        }
      }
    }
  }
  if (ignoreLine()) {
    return;
  }
  if (line.contains(""String_Node_Str"")) {
synchronized (this) {
      loaded=true;
      notifyAll();
    }
  }
 else   if (line.contains(""String_Node_Str"") || line.contains(""String_Node_Str"")) {
    server.setSaving(false);
    if (server.options.getBoolean(""String_Node_Str"")) {
      server.runCommand(""String_Node_Str"",t(""String_Node_Str""));
    }
  }
 else   if (line.contains(""String_Node_Str"")) {
    handleError(new Exception(line));
  }
 else   if (line.matches(""String_Node_Str"")) {
    return;
  }
 else   if (line.contains(""String_Node_Str"") && server.options.getBoolean(""String_Node_Str"")) {
    ignoreNextLines(3);
    return;
  }
 else {
    Matcher connect=CONNECT.matcher(line);
    if (connect.find()) {
      if (server.bots.ninja(connect.group(1))) {
        return;
      }
    }
 else {
      Matcher disconnect=DISCONNECT.matcher(line);
      if (disconnect.find()) {
        if (server.bots.ninja(disconnect.group(1))) {
          return;
        }
      }
    }
  }
  server.addOutputLine(line);
  System.out.println(line);
}",0.9788106630211894
150414,"private void sendMessagePacket(String message) throws IOException {
  if (message.length() > MESSAGE_SIZE) {
    System.out.println(""String_Node_Str"" + message);
    return;
  }
  write(0x03);
  write(message);
  packetFinished();
}","private void sendMessagePacket(String message) throws IOException {
  if (message.length() > MESSAGE_SIZE) {
    System.out.println(""String_Node_Str"" + message);
    return;
  }
  if (message.length() > 0) {
    write(0x03);
    write(message);
    packetFinished();
  }
}",0.9206349206349206
150415,"private void sendMessage(String message) throws IOException {
  if (message.length() > MESSAGE_SIZE) {
    int end=MESSAGE_SIZE - 1;
    while (end > 0 && message.charAt(end) != ' ') {
      end--;
    }
    if (end == 0) {
      end=MESSAGE_SIZE;
    }
 else {
      end++;
    }
    if (message.charAt(end) == '\u00a7') {
      end--;
    }
    String firstPart=message.substring(0,end);
    sendMessagePacket(firstPart);
    sendMessage(getLastColorCode(firstPart) + message.substring(end));
  }
 else {
    int end=message.length();
    if (message.charAt(end - 1) == '\u00a7') {
      end--;
    }
    sendMessagePacket(message.substring(0,end));
  }
}","private void sendMessage(String message) throws IOException {
  if (message.length() > 0) {
    if (message.length() > MESSAGE_SIZE) {
      int end=MESSAGE_SIZE - 1;
      while (end > 0 && message.charAt(end) != ' ') {
        end--;
      }
      if (end == 0) {
        end=MESSAGE_SIZE;
      }
 else {
        end++;
      }
      if (end > 0 && message.charAt(end) == '\u00a7') {
        end--;
      }
      String firstPart=message.substring(0,end);
      sendMessagePacket(firstPart);
      sendMessage(getLastColorCode(firstPart) + message.substring(end));
    }
 else {
      int end=message.length();
      if (message.charAt(end - 1) == '\u00a7') {
        end--;
      }
      sendMessagePacket(message.substring(0,end));
    }
  }
}",0.9195729537366548
150416,"public void execute(Player player,String message){
  String name=extractArgument(message);
  if (name == null) {
    if (player.isAttemptLock()) {
      player.setAttemptedAction(null);
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
 else {
      name=""String_Node_Str"";
    }
  }
  if (name.equals(""String_Node_Str"")) {
    Map<String,Integer> list=player.getServer().data.chests.chestList(player);
    if (list.size() == 0) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      for (      String current : list.keySet()) {
        player.addMessage(Color.GRAY,list.get(current) + ""String_Node_Str"" + current);
      }
    }
  }
 else {
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.setAttemptedAction(Action.Lock);
    player.setChestName(name);
  }
}","public void execute(Player player,String message){
  String name=extractArgument(message);
  if (name == null) {
    if (player.isAttemptLock()) {
      player.setAttemptedAction(null);
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      return;
    }
  }
  if (name != null && name.equals(""String_Node_Str"")) {
    Map<String,Integer> list=player.getServer().data.chests.chestList(player);
    if (list.size() == 0) {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
    }
 else {
      player.addTMessage(Color.GRAY,""String_Node_Str"");
      for (      String current : list.keySet()) {
        player.addMessage(Color.GRAY,list.get(current) + ""String_Node_Str"" + current);
      }
    }
  }
 else {
    player.addTMessage(Color.GRAY,""String_Node_Str"");
    player.setAttemptedAction(Action.Lock);
    player.setChestName(name);
  }
}",0.956170703575548
150417,"@Override public void load(){
  boolean success=false;
  File inFile=getFile();
  try {
    BufferedReader reader=new BufferedReader(new FileReader(inFile));
    try {
      String line;
      while ((line=reader.readLine()) != null) {
        if (!line.startsWith(""String_Node_Str"")) {
          loadLine(line);
        }
      }
      success=true;
    }
  finally {
      reader.close();
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(getFilename() + ""String_Node_Str"");
    loadDefaults();
    save();
    success=true;
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  if (!success) {
    System.out.println(""String_Node_Str"" + getFilename() + ""String_Node_Str"");
  }
}","@Override public void load(){
  boolean success=false;
  File inFile=getFile();
  try {
    BufferedReader reader=new BufferedReader(new FileReader(inFile));
    try {
      String line;
      while ((line=reader.readLine()) != null) {
        if (!line.startsWith(""String_Node_Str"")) {
          loadLine(line);
        }
      }
      success=true;
    }
  finally {
      reader.close();
    }
  }
 catch (  FileNotFoundException e) {
    missingFile();
    loadDefaults();
    save();
    success=true;
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  if (!success) {
    System.out.println(""String_Node_Str"" + getFilename() + ""String_Node_Str"");
  }
}",0.9563953488372092
150418,"@Override public void load(){
  if (layered) {
    properties=(SortedProperties)defaultProperties.clone();
  }
 else {
    properties=new SortedProperties();
  }
  try {
    InputStream stream=new FileInputStream(getFile());
    try {
      properties.load(stream);
    }
  finally {
      stream.close();
    }
  }
 catch (  FileNotFoundException e) {
    System.out.println(getFilename() + ""String_Node_Str"");
    properties=(SortedProperties)defaultProperties.clone();
    save();
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + getFilename());
  }
}","@Override public void load(){
  if (layered) {
    properties=(SortedProperties)defaultProperties.clone();
  }
 else {
    properties=new SortedProperties();
  }
  try {
    InputStream stream=new FileInputStream(getFile());
    try {
      properties.load(stream);
    }
  finally {
      stream.close();
    }
  }
 catch (  FileNotFoundException e) {
    missingFile();
    properties=(SortedProperties)defaultProperties.clone();
    save();
  }
catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + getFilename());
  }
}",0.9553719008264464
150419,"private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
  byte dimension;
  Coordinate coordinate;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(readUTF16());
write(in.readLong());
dimension=in.readByte();
if (isServerTunnel) {
player.setDimension(Dimension.get(dimension));
}
write(dimension);
break;
case 0x02:
String name=readUTF16();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
Matcher joinMatcher=JOIN_PATTERN.matcher(message);
if (isServerTunnel && joinMatcher.find()) {
if (server.bots.ninja(joinMatcher.group(1))) {
break;
}
}
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
 else if (cleanMessage.matches(CONSOLE_CHAT_PATTERN) && !server.options.getBoolean(""String_Node_Str"")) {
break;
}
if (server.options.getBoolean(""String_Node_Str"")) {
sendMessage(message);
}
 else {
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
}
 else if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
break;
case 0x04:
write(packetId);
long time=in.readLong();
server.setTime(time);
write(time);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
dimension=in.readByte();
write(dimension);
player.setDimension(Dimension.get(dimension));
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
copyNBytes(1);
break;
case 0x0c:
write(packetId);
copyPlayerLook();
copyNBytes(1);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyPlayerLook();
copyNBytes(1);
break;
case 0x0e:
if (!isServerTunnel) {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
coordinate=new Coordinate(x,y,z,player);
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,0);
if (!perms[2] && status == 0) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (!perms[1] && status == 2) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
boolean locked=server.data.chests.isLocked(coordinate);
if (!locked || player.isAdmin()) {
if (locked && status == BLOCK_DESTROYED_STATUS) {
server.data.chests.releaseLock(coordinate);
server.data.save();
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
coordinate=new Coordinate(x,y,z,player);
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,dropItem);
if (isServerTunnel || server.data.chests.isChest(coordinate)) {
}
 else if ((dropItem != -1 && !perms[0]) || (dropItem == -1 && !perms[2])) {
if (dropItem == -1) {
player.addTMessage(Color.RED,""String_Node_Str"");
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
}
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Coordinate targetBlock=new Coordinate(xPosition,yPosition,zPosition,player);
Chest adjacentChest=server.data.chests.adjacentChest(targetBlock);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addTMessage(Color.RED,""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(targetBlock);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(coordinate);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
int eid=in.readInt();
name=readUTF16();
if (!server.bots.ninja(name)) {
write(packetId);
write(eid);
write(name);
copyNBytes(16);
}
 else {
skipNBytes(16);
}
break;
case 0x15:
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
int flag=in.readInt();
write(flag);
if (flag > 0) {
write(in.readShort());
write(in.readShort());
write(in.readShort());
}
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
coordinate=new Coordinate(x,y,z,player);
if (blockType == 54 && player.placedChest(coordinate)) {
lockChest(coordinate);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x3d:
write(packetId);
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
byte unknownByte=in.readByte();
if (invtype == 0) {
if (!server.permissions.canOpenChests(player,player.openedChest())) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
 else if (server.data.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.data.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.data.chests.unlock(player.openedChest());
server.data.save();
player.setAttemptedAction(null);
player.addTMessage(Color.RED,""String_Node_Str"");
typeString=t(""String_Node_Str"");
}
 else {
typeString=server.data.chests.chestName(player.openedChest());
}
}
 else {
typeString=t(""String_Node_Str"");
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=player.nextChestName();
}
}
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(unknownByte);
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x67:
byte type67=in.readByte();
short slot=in.readShort();
short setItem=in.readShort();
write(packetId);
write(type67);
write(slot);
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x68:
byte type=in.readByte();
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0x83:
write(packetId);
write(in.readShort());
write(in.readShort());
byte length=in.readByte();
write(length);
copyNBytes(0xff & length);
break;
case (byte)0xc8:
write(packetId);
copyNBytes(5);
break;
case (byte)0xe6:
write(packetId);
write(in.readInt());
write(in.readInt());
copyNBytes(write(in.readInt()) * 4);
copyNBytes(write(in.readInt()) * 4);
int sizeString=write(in.readInt());
for (int i=0; i < sizeString; i++) {
copyNBytes(write(in.readInt()));
}
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName()+ ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
}
packetFinished();
lastPacket=packetId;
}","private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
  byte dimension;
  Coordinate coordinate;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(readUTF16());
write(in.readLong());
dimension=in.readByte();
if (isServerTunnel) {
player.setDimension(Dimension.get(dimension));
}
write(dimension);
break;
case 0x02:
String name=readUTF16();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
Matcher joinMatcher=JOIN_PATTERN.matcher(message);
if (isServerTunnel && joinMatcher.find()) {
if (server.bots.ninja(joinMatcher.group(1))) {
break;
}
}
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
 else if (cleanMessage.matches(CONSOLE_CHAT_PATTERN) && !server.options.getBoolean(""String_Node_Str"")) {
break;
}
if (server.options.getBoolean(""String_Node_Str"")) {
sendMessage(message);
}
 else {
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
}
 else if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
if (message.length() > MAXIMUM_MESSAGE_SIZE) {
message=message.substring(0,MAXIMUM_MESSAGE_SIZE);
}
write(packetId);
write(message);
}
break;
case 0x04:
write(packetId);
long time=in.readLong();
server.setTime(time);
write(time);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
dimension=in.readByte();
write(dimension);
player.setDimension(Dimension.get(dimension));
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
copyNBytes(1);
break;
case 0x0c:
write(packetId);
copyPlayerLook();
copyNBytes(1);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyPlayerLook();
copyNBytes(1);
break;
case 0x0e:
if (!isServerTunnel) {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
coordinate=new Coordinate(x,y,z,player);
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,0);
if (!perms[2] && status == 0) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
if (!perms[1] && status == 2) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
boolean locked=server.data.chests.isLocked(coordinate);
if (!locked || player.isAdmin()) {
if (locked && status == BLOCK_DESTROYED_STATUS) {
server.data.chests.releaseLock(coordinate);
server.data.save();
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
coordinate=new Coordinate(x,y,z,player);
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
boolean[] perms=server.permissions.getPlayerBlockPermissions(player,coordinate,dropItem);
if (isServerTunnel || server.data.chests.isChest(coordinate)) {
}
 else if ((dropItem != -1 && !perms[0]) || (dropItem == -1 && !perms[2])) {
if (dropItem == -1) {
player.addTMessage(Color.RED,""String_Node_Str"");
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
}
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Coordinate targetBlock=new Coordinate(xPosition,yPosition,zPosition,player);
Chest adjacentChest=server.data.chests.adjacentChest(targetBlock);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addTMessage(Color.RED,""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(targetBlock);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(coordinate);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
int eid=in.readInt();
name=readUTF16();
if (!server.bots.ninja(name)) {
write(packetId);
write(eid);
write(name);
copyNBytes(16);
}
 else {
skipNBytes(16);
}
break;
case 0x15:
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
int flag=in.readInt();
write(flag);
if (flag > 0) {
write(in.readShort());
write(in.readShort());
write(in.readShort());
}
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
coordinate=new Coordinate(x,y,z,player);
if (blockType == 54 && player.placedChest(coordinate)) {
lockChest(coordinate);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x3d:
write(packetId);
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
byte unknownByte=in.readByte();
if (invtype == 0) {
Chest adjacent=server.data.chests.adjacentChest(player.openedChest());
if (!server.data.chests.isChest(player.openedChest())) {
if (adjacent == null) {
server.data.chests.addOpenChest(player.openedChest());
}
 else {
server.data.chests.giveLock(adjacent.owner,player.openedChest(),adjacent.name);
}
server.data.save();
}
if (!server.permissions.canOpenChests(player,player.openedChest()) || (adjacent != null && !server.permissions.canOpenChests(player,adjacent.coordinate))) {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
 else if (server.data.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.data.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.data.chests.unlock(player.openedChest());
server.data.save();
player.setAttemptedAction(null);
player.addTMessage(Color.RED,""String_Node_Str"");
typeString=t(""String_Node_Str"");
}
 else {
typeString=server.data.chests.chestName(player.openedChest());
}
}
 else {
typeString=t(""String_Node_Str"");
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=(player.nextChestName() == null) ? t(""String_Node_Str"") : player.nextChestName();
}
}
}
 else {
player.addTMessage(Color.RED,""String_Node_Str"");
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(unknownByte);
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x67:
byte type67=in.readByte();
short slot=in.readShort();
short setItem=in.readShort();
write(packetId);
write(type67);
write(slot);
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
break;
case 0x68:
byte type=in.readByte();
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0x83:
write(packetId);
write(in.readShort());
write(in.readShort());
byte length=in.readByte();
write(length);
copyNBytes(0xff & length);
break;
case (byte)0xc8:
write(packetId);
copyNBytes(5);
break;
case (byte)0xe6:
write(packetId);
write(in.readInt());
write(in.readInt());
copyNBytes(write(in.readInt()) * 4);
copyNBytes(write(in.readInt()) * 4);
int sizeString=write(in.readInt());
for (int i=0; i < sizeString; i++) {
copyNBytes(write(in.readInt()));
}
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName()+ ""String_Node_Str""+ Integer.toHexString(lastPacket));
}
}
packetFinished();
lastPacket=packetId;
}",0.9776824034334765
150420,"public void execute(Player player,String message){
  PermissionConfig perm=player.getServer().permissions;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addMessage(""String_Node_Str"");
    return;
  }
  if (player.getDimension() != Dimension.EARTH && (arguments[0].equals(""String_Node_Str"") || arguments[0].equals(""String_Node_Str""))) {
    player.addMessage(""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=perm.coordinateFromPlayer(player);
    player.areastart=player.areastart.setY((byte)0);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=perm.coordinateFromPlayer(player);
    player.areaend=player.areaend.setY((byte)0);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (perm.playerHasArea(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    if (!perm.getCurrentArea(player).equals(""String_Node_Str"")) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    if (player.areastart == null || player.areaend == null) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    perm.createPlayerArea(player);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (!perm.playerHasArea(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    perm.removePlayerArea(player);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (!perm.playerHasArea(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      if (perm.hasAreaWithName(label)) {
        player.addMessage(""String_Node_Str"");
      }
 else {
        perm.renamePlayerArea(player,label);
        player.addMessage(""String_Node_Str"");
      }
    }
 else {
      player.addMessage(""String_Node_Str"");
    }
  }
}","public void execute(Player player,String message){
  PermissionConfig perm=player.getServer().permissions;
  String arguments[]=extractArguments(message);
  if (arguments.length == 0) {
    player.addMessage(""String_Node_Str"");
    return;
  }
  if (player.getDimension() != Dimension.EARTH && (arguments[0].equals(""String_Node_Str"") || arguments[0].equals(""String_Node_Str""))) {
    player.addMessage(""String_Node_Str"");
    return;
  }
  if (arguments[0].equals(""String_Node_Str"")) {
    player.areastart=perm.coordinateFromPlayer(player);
    player.areastart=player.areastart.setY((byte)0);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    player.areaend=perm.coordinateFromPlayer(player);
    player.areaend=player.areaend.setY((byte)0);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (perm.playerHasArea(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    if (!perm.getCurrentArea(player).equals(""String_Node_Str"")) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    if (player.areastart == null || player.areaend == null) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    if (!areaSizeOk(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    perm.createPlayerArea(player);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (!perm.playerHasArea(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    perm.removePlayerArea(player);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments[0].equals(""String_Node_Str"")) {
    if (!perm.playerHasArea(player)) {
      player.addMessage(""String_Node_Str"");
      return;
    }
    String label=extractArgument(message,1);
    if (label != null) {
      if (perm.hasAreaWithName(label)) {
        player.addMessage(""String_Node_Str"");
      }
 else {
        perm.renamePlayerArea(player,label);
        player.addMessage(""String_Node_Str"");
      }
    }
 else {
      player.addMessage(""String_Node_Str"");
    }
  }
 else {
    player.addMessage(""String_Node_Str"");
  }
}",0.9876993166287016
150421,"public void removePlayerArea(Player player){
  String name=player.getName().toLowerCase();
  if (!playerHasArea(player)) {
    return;
  }
  String path=""String_Node_Str"" + escape(name) + ""String_Node_Str"";
  config.clearTree(path);
  if (config.getList(""String_Node_Str"").size() == 0) {
    config.addProperty(""String_Node_Str"",""String_Node_Str"");
  }
}","public void removePlayerArea(Player player){
  String name=player.getName().toLowerCase();
  if (!playerHasArea(player)) {
    return;
  }
  String path=""String_Node_Str"" + escape(name) + ""String_Node_Str"";
  config.clearTree(path);
  if (config.getList(""String_Node_Str"").size() == 0) {
    config.addProperty(""String_Node_Str"",""String_Node_Str"");
  }
  save();
}",0.9860724233983288
150422,"public Chest adjacentChest(Coordinate coordinate){
  Chest chest=chestAt(coordinate);
  if (chest == null) {
    chest=chestAt(coordinate.add(1,0,0));
  }
  if (chest == null) {
    chest=chestAt(coordinate.add(-1,0,0));
  }
  if (chest == null) {
    chest=chestAt(coordinate.add(0,0,1));
  }
  if (chest == null) {
    chest=chestAt(coordinate.add(0,0,-1));
  }
  return chest;
}","public Chest adjacentChest(Coordinate coordinate){
  Chest chest=chestAt(coordinate.add(1,0,0));
  if (chest == null) {
    chest=chestAt(coordinate.add(-1,0,0));
  }
  if (chest == null) {
    chest=chestAt(coordinate.add(0,0,1));
  }
  if (chest == null) {
    chest=chestAt(coordinate.add(0,0,-1));
  }
  return chest;
}",0.9176136363636364
150423,"public Chest adjacentChest(Coordinate coordinate){
  Chest chest=chestAt(coordinate);
  if (chest == null)   chest=chestAt(coordinate.add(1,0,0));
  if (chest == null)   chest=chestAt(coordinate.add(1,0,0));
  if (chest == null)   chest=chestAt(coordinate.add(1,0,0));
  return chest;
}","public Chest adjacentChest(Coordinate coordinate){
  Chest chest=chestAt(coordinate);
  if (chest == null)   chest=chestAt(coordinate.add(1,0,0));
  if (chest == null)   chest=chestAt(coordinate.add(-1,0,0));
  if (chest == null)   chest=chestAt(coordinate.add(0,0,1));
  if (chest == null)   chest=chestAt(coordinate.add(0,0,-1));
  return chest;
}",0.8881889763779528
150424,"public boolean parseCommand(String message){
  if (closed) {
    return true;
  }
  if (message.equals(server.getCommandParser().commandPrefix() + ""String_Node_Str""))   message=lastCommand;
  PlayerCommand command=server.getCommandParser().getPlayerCommand(message);
  if (command == null) {
    return false;
  }
  boolean invalidCommand=command.getName() == null;
  if (!invalidCommand && !commandAllowed(command.getName())) {
    addMessage(""String_Node_Str"");
    return true;
  }
  command.execute(this,message);
  lastCommand=message;
  return !((server.permissions.commandShouldPassThroughToMod(command.getName()) || server.options.getBoolean(""String_Node_Str"") || invalidCommand) && server.options.contains(""String_Node_Str""));
}","public boolean parseCommand(String message){
  if (closed) {
    return true;
  }
  if (message.equals(server.getCommandParser().commandPrefix() + ""String_Node_Str""))   message=lastCommand;
  PlayerCommand command=server.getCommandParser().getPlayerCommand(message);
  if (command == null) {
    return false;
  }
  boolean invalidCommand=command.getName() == null;
  if (!invalidCommand && !commandAllowed(command.getName())) {
    addMessage(""String_Node_Str"");
    return true;
  }
  command.execute(this,message);
  lastCommand=message;
  return !((server.permissions.commandShouldPassThroughToMod(command.getName()) || server.options.getBoolean(""String_Node_Str"") || invalidCommand|| command instanceof ExternalCommand) && server.options.contains(""String_Node_Str""));
}",0.9755129053606882
150425,"public boolean parseCommand(String message){
  if (closed) {
    return true;
  }
  if (message.equals(server.getCommandParser().commandPrefix() + ""String_Node_Str""))   message=lastCommand;
  PlayerCommand command=server.getCommandParser().getPlayerCommand(message);
  if (command == null) {
    return false;
  }
  boolean invalidCommand=command.getName() == null;
  if (invalidCommand && !commandAllowed(command.getName())) {
    addMessage(""String_Node_Str"");
    return true;
  }
  command.execute(this,message);
  lastCommand=message;
  return !((server.permissions.commandShouldPassThroughToMod(command.getName()) || server.options.getBoolean(""String_Node_Str"") || invalidCommand) && server.options.contains(""String_Node_Str""));
}","public boolean parseCommand(String message){
  if (closed) {
    return true;
  }
  if (message.equals(server.getCommandParser().commandPrefix() + ""String_Node_Str""))   message=lastCommand;
  PlayerCommand command=server.getCommandParser().getPlayerCommand(message);
  if (command == null) {
    return false;
  }
  boolean invalidCommand=command.getName() == null;
  if (!invalidCommand && !commandAllowed(command.getName())) {
    addMessage(""String_Node_Str"");
    return true;
  }
  command.execute(this,message);
  lastCommand=message;
  return !((server.permissions.commandShouldPassThroughToMod(command.getName()) || server.options.getBoolean(""String_Node_Str"") || invalidCommand) && server.options.contains(""String_Node_Str""));
}",0.9993211133740664
150426,"private void copyUnknownBlob() throws IOException {
  byte unknown=in.readByte();
  write(unknown);
  while (unknown != 0x7f) {
    int type=(unknown & 0xE0) >> 5;
switch (type) {
case 0:
      write(in.readByte());
    break;
case 1:
  write(in.readShort());
break;
case 2:
write(in.readInt());
break;
case 3:
write(in.readFloat());
break;
case 4:
write(in.readUTF());
break;
case 5:
write(in.readShort());
write(in.readByte());
write(in.readShort());
}
unknown=in.readByte();
write(unknown);
}
}","private void copyUnknownBlob() throws IOException {
  byte unknown=in.readByte();
  write(unknown);
  while (unknown != 0x7f) {
    int type=(unknown & 0xE0) >> 5;
switch (type) {
case 0:
      write(in.readByte());
    break;
case 1:
  write(in.readShort());
break;
case 2:
write(in.readInt());
break;
case 3:
write(in.readFloat());
break;
case 4:
write(readUTF16());
break;
case 5:
write(in.readShort());
write(in.readByte());
write(in.readShort());
}
unknown=in.readByte();
write(unknown);
}
}",0.9949647532729105
150427,"private void sendMessage(String message) throws IOException {
  write(0x03);
  write(message);
  packetFinished();
}","private void sendMessage(String message) throws IOException {
}",0.7039106145251397
150428,"private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(in.readUTF());
write(in.readUTF());
write(in.readLong());
write(in.readByte());
break;
case 0x02:
String name=in.readUTF();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=in.readUTF();
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
}
if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addMessage(""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
}
write(packetId);
write(message);
break;
case 0x04:
write(packetId);
copyNBytes(8);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
break;
case 0x0c:
write(packetId);
copyNBytes(9);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyNBytes(8);
break;
case 0x0e:
if (!isServerTunnel) {
if (player.getGroupId() < 0) {
skipNBytes(11);
}
 else {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
if (!server.chests.isLocked(x,y,z) || player.isAdmin()) {
if (server.chests.isLocked(x,y,z) && status == BLOCK_DESTROYED_STATUS) {
server.chests.releaseLock(x,y,z);
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
if (isServerTunnel || server.chests.isChest(x,y,z)) {
}
 else if ((player.getGroupId() < 0) || !server.blockFirewall.playerAllowed(player,dropItem)) {
String badBlock=String.format(server.l.get(""String_Node_Str""),player.getName(),Short.toString(dropItem));
server.runCommand(""String_Node_Str"",badBlock);
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Chest adjacentChest=server.chests.adjacentChest(xPosition,yPosition,zPosition);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addMessage(""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(new Coordinate(xPosition,yPosition,zPosition));
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(x,y,z);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
write(packetId);
write(in.readInt());
write(in.readUTF());
copyNBytes(16);
break;
case 0x15:
if (player.getGroupId() < 0) {
skipNBytes(24);
break;
}
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
copyNBytes(17);
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(in.readUTF());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
if (blockType == 54 && player.placedChest(x,y,z)) {
lockChest(x,y,z);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
if (invtype == 0) {
if (server.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.chests.unlock(player.openedChest());
player.setAttemptedAction(null);
player.addMessage(""String_Node_Str"");
typeString=""String_Node_Str"";
}
 else {
typeString=server.chests.chestName(player.openedChest());
}
}
 else {
typeString=""String_Node_Str"";
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=player.nextChestName();
}
}
}
 else {
player.addMessage(""String_Node_Str"");
in.readByte();
break;
}
}
write(packetId);
write(id);
write(invtype);
write(typeString);
write(in.readByte());
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
if ((typeFrom < 0 && typeTo < 0) || player.getGroupId() >= 0) {
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
}
 else {
short moveItem=in.readShort();
if (moveItem != -1) {
in.readByte();
in.readShort();
}
}
break;
case 0x67:
byte type67=in.readByte();
if (type67 < 0 || player.getGroupId() >= 0) {
write(packetId);
short slot=in.readShort();
write(type67);
write(slot);
short setItem=in.readShort();
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
}
 else {
in.readShort();
short setItem=in.readShort();
if (setItem != -1) {
in.readByte();
in.readShort();
}
}
break;
case 0x68:
byte type=in.readByte();
if (type < 0 || player.getGroupId() >= 0) {
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
}
 else {
short count=in.readShort();
for (int c=0; c < count; ++c) {
short item=in.readShort();
if (item != -1) {
in.readByte();
in.readShort();
}
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(in.readUTF());
write(in.readUTF());
write(in.readUTF());
write(in.readUTF());
break;
case (byte)0xff:
write(packetId);
String reason=in.readUTF();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName());
}
}
packetFinished();
}","private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
  int x;
  byte y;
  int z;
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(readUTF16());
write(in.readLong());
write(in.readByte());
break;
case 0x02:
String name=readUTF16();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=readUTF16();
System.out.println(message);
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher colorMatcher=COLOR_PATTERN.matcher(message);
String cleanMessage=colorMatcher.replaceAll(""String_Node_Str"");
Matcher messageMatcher=MESSAGE_PATTERN.matcher(cleanMessage);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
}
if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addMessage(""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
if (player.localChat() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.execute(LocalSayCommand.class,message);
break;
}
}
write(packetId);
write(message);
break;
case 0x04:
write(packetId);
copyNBytes(8);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
if (server.options.getBoolean(""String_Node_Str"")) {
player.execute(PlayerListCommand.class);
}
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
break;
case 0x0c:
write(packetId);
copyNBytes(9);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyNBytes(8);
break;
case 0x0e:
if (!isServerTunnel) {
if (player.getGroupId() < 0) {
skipNBytes(11);
}
 else {
byte status=in.readByte();
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte face=in.readByte();
if (!server.chests.isLocked(x,y,z) || player.isAdmin()) {
if (server.chests.isLocked(x,y,z) && status == BLOCK_DESTROYED_STATUS) {
server.chests.releaseLock(x,y,z);
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
if (status == BLOCK_DESTROYED_STATUS) {
player.destroyedBlock();
}
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
x=in.readInt();
y=in.readByte();
z=in.readInt();
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
short uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readShort();
}
boolean writePacket=true;
boolean drop=false;
if (isServerTunnel || server.chests.isChest(x,y,z)) {
}
 else if ((player.getGroupId() < 0) || !server.blockFirewall.playerAllowed(player,dropItem)) {
String badBlock=String.format(server.l.get(""String_Node_Str""),player.getName(),Short.toString(dropItem));
server.runCommand(""String_Node_Str"",badBlock);
writePacket=false;
drop=true;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
Chest adjacentChest=server.chests.adjacentChest(xPosition,yPosition,zPosition);
if (adjacentChest != null && !adjacentChest.isOpen() && !adjacentChest.ownedBy(player)) {
player.addMessage(""String_Node_Str"");
writePacket=false;
drop=true;
}
 else {
player.placingChest(new Coordinate(xPosition,yPosition,zPosition));
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
if (dropItem <= 94 && direction >= 0) {
player.placedBlock();
}
}
player.openingChest(x,y,z);
}
 else if (drop) {
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x11:
write(packetId);
copyNBytes(14);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x13:
write(packetId);
write(in.readInt());
write(in.readByte());
break;
case 0x14:
write(packetId);
write(in.readInt());
write(readUTF16());
copyNBytes(16);
break;
case 0x15:
if (player.getGroupId() < 0) {
skipNBytes(24);
break;
}
write(packetId);
copyNBytes(24);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
copyNBytes(17);
break;
case 0x18:
write(packetId);
write(in.readInt());
write(in.readByte());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readByte());
write(in.readByte());
copyUnknownBlob();
break;
case 0x19:
write(packetId);
write(in.readInt());
write(readUTF16());
write(in.readInt());
write(in.readInt());
write(in.readInt());
write(in.readInt());
break;
case 0x1b:
write(packetId);
copyNBytes(18);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1d:
write(packetId);
copyNBytes(4);
break;
case 0x1e:
write(packetId);
copyNBytes(4);
break;
case 0x1f:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x28:
write(packetId);
write(in.readInt());
copyUnknownBlob();
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
x=in.readInt();
y=in.readByte();
z=in.readInt();
byte blockType=in.readByte();
byte metadata=in.readByte();
if (blockType == 54 && player.placedChest(x,y,z)) {
lockChest(x,y,z);
player.placingChest(null);
}
write(x);
write(y);
write(z);
write(blockType);
write(metadata);
break;
case 0x36:
write(packetId);
copyNBytes(12);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x46:
write(packetId);
copyNBytes(1);
break;
case 0x47:
write(packetId);
copyNBytes(17);
break;
case 0x64:
byte id=in.readByte();
byte invtype=in.readByte();
String typeString=in.readUTF();
if (invtype == 0) {
if (server.chests.canOpen(player,player.openedChest()) || player.isAdmin()) {
if (server.chests.isLocked(player.openedChest())) {
if (player.isAttemptingUnlock()) {
server.chests.unlock(player.openedChest());
player.setAttemptedAction(null);
player.addMessage(""String_Node_Str"");
typeString=""String_Node_Str"";
}
 else {
typeString=server.chests.chestName(player.openedChest());
}
}
 else {
typeString=""String_Node_Str"";
if (player.isAttemptLock()) {
lockChest(player.openedChest());
typeString=player.nextChestName();
}
}
}
 else {
player.addMessage(""String_Node_Str"");
in.readByte();
break;
}
}
write(packetId);
write(id);
write(invtype);
write8(typeString);
write(in.readByte());
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
if ((typeFrom < 0 && typeTo < 0) || player.getGroupId() >= 0) {
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
write(in.readBoolean());
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readShort());
}
}
 else {
short moveItem=in.readShort();
if (moveItem != -1) {
in.readByte();
in.readShort();
}
}
break;
case 0x67:
byte type67=in.readByte();
if (type67 < 0 || player.getGroupId() >= 0) {
write(packetId);
short slot=in.readShort();
write(type67);
write(slot);
short setItem=in.readShort();
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readShort());
}
}
 else {
in.readShort();
short setItem=in.readShort();
if (setItem != -1) {
in.readByte();
in.readShort();
}
}
break;
case 0x68:
byte type=in.readByte();
if (type < 0 || player.getGroupId() >= 0) {
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
}
 else {
short count=in.readShort();
for (int c=0; c < count; ++c) {
short item=in.readShort();
if (item != -1) {
in.readByte();
in.readShort();
}
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(readUTF16());
write(readUTF16());
write(readUTF16());
write(readUTF16());
break;
case (byte)0xc6:
write(packetId);
copyNBytes(5);
break;
case (byte)0xff:
write(packetId);
String reason=readUTF16();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName());
}
}
packetFinished();
}",0.9855607631491738
150429,"@Override public void run(){
  try {
    while (run) {
      lastRead=System.currentTimeMillis();
      try {
        handlePacket();
        if (isServerTunnel) {
          while (player.hasMessages()) {
            sendMessage(player.getMessage());
          }
        }
        flushAll();
      }
 catch (      IOException e) {
        if (run && !player.isRobot()) {
          System.out.println(""String_Node_Str"" + e);
          System.out.println(""String_Node_Str"" + streamType + ""String_Node_Str""+ player.getIPAddress());
        }
        break;
      }
    }
    try {
      if (player.isKicked()) {
        kick(player.getKickMsg());
      }
      flushAll();
    }
 catch (    IOException e) {
    }
  }
  finally {
    if (EXPENSIVE_DEBUG_LOGGING) {
      inputDumper.cleanup();
      outputDumper.cleanup();
    }
  }
}","@Override public void run(){
  try {
    while (run) {
      lastRead=System.currentTimeMillis();
      try {
        handlePacket();
        if (isServerTunnel) {
          while (player.hasMessages()) {
            sendMessage(player.getMessage());
          }
        }
        flushAll();
      }
 catch (      IOException e) {
        if (run && !player.isRobot()) {
          System.out.println(""String_Node_Str"" + e);
          System.out.println(""String_Node_Str"" + streamType + ""String_Node_Str""+ player.getIPAddress());
          e.printStackTrace();
        }
        break;
      }
    }
    try {
      if (player.isKicked()) {
        kick(player.getKickMsg());
      }
      flushAll();
    }
 catch (    IOException e) {
    }
  }
  finally {
    if (EXPENSIVE_DEBUG_LOGGING) {
      inputDumper.cleanup();
      outputDumper.cleanup();
    }
  }
}",0.9817324690630524
150430,"public boolean ownsLock(Player player,int x,byte y,int z){
  Coordinate coordinate=new Coordinate(x,y,z);
  Chest chest=locations.get(coordinate);
  return (chest != null) && (chest.owner == player.getName() || chest.isOpen());
}","public boolean ownsLock(Player player,int x,byte y,int z){
  Coordinate coordinate=new Coordinate(x,y,z);
  Chest chest=locations.get(coordinate);
  return (chest != null) && (chest.owner.toLowerCase().equals(player.getName().toLowerCase()) || chest.isOpen());
}",0.9164969450101832
150431,"@Override public void execute(Player player,String message){
  player.handleVisitRequests();
}","public void execute(Player player,String message){
  player.handleVisitRequests();
}",0.9438202247191012
150432,"private void freeze(int time){
  if (!frozen) {
    frozen=true;
    timer=new Timer();
    timer.schedule(new TimeFreezer(this,time),0,DELAY);
    player.addMessage(""String_Node_Str"");
  }
}","private void freeze(int time){
  if (!frozen) {
    frozen=true;
    timer=new Timer();
    int delay=DELAY;
    if (time == DAY) {
      delay=DELAY_DAY;
    }
 else     if (time == NIGHT) {
      delay=DELAY_NIGHT;
    }
    timer.schedule(new TimeFreezer(this,time),0,delay);
    player.addMessage(""String_Node_Str"");
  }
}",0.7195357833655706
150433,"public void execute(Player player,String message){
  server=player.getServer();
  this.player=player;
  String[] arguments=extractArguments(message);
  if (arguments.length == 0) {
    setTime(0);
    player.addMessage(""String_Node_Str"");
  }
 else   if (arguments.length >= 1) {
    String argument=arguments[0];
    int time=0;
    if (argument.equals(""String_Node_Str""))     time=DAY;
 else     if (argument.equals(""String_Node_Str""))     time=NIGHT;
 else {
      try {
        time=Integer.parseInt(argument);
      }
 catch (      NumberFormatException e) {
        player.addMessage(""String_Node_Str"");
        return;
      }
      if (time < 0 || time > 23999) {
        player.addMessage(""String_Node_Str"");
        return;
      }
    }
    if (arguments.length < 2)     setTime(time);
    if (arguments.length >= 2) {
      argument=arguments[1];
      if (argument.equals(""String_Node_Str"")) {
        freeze(time);
      }
 else       if (argument.equals(""String_Node_Str"")) {
        unfreeze();
      }
 else {
        player.addMessage(""String_Node_Str"");
      }
    }
  }
}","public void execute(Player player,String message){
  server=player.getServer();
  this.player=player;
  String[] arguments=extractArguments(message);
  if (arguments.length == 0) {
    usage();
  }
 else   if (arguments.length >= 1) {
    String argument=arguments[0];
    int time=0;
    if (argument.equals(""String_Node_Str"")) {
      time=DAY;
    }
 else     if (argument.equals(""String_Node_Str"")) {
      time=NIGHT;
    }
 else     if (argument.equals(""String_Node_Str"") || argument.equals(""String_Node_Str"")) {
      player.addMessage(""String_Node_Str"");
      usage();
      return;
    }
 else     if (argument.equals(""String_Node_Str"")) {
      unfreeze();
      return;
    }
 else {
      try {
        time=Integer.parseInt(argument);
      }
 catch (      NumberFormatException e) {
        player.addMessage(""String_Node_Str"");
        usage();
        return;
      }
      if (time < 0 || time > 23999) {
        player.addMessage(""String_Node_Str"");
        return;
      }
    }
    unfreeze();
    if (arguments.length < 2)     setTime(time);
    if (arguments.length >= 2) {
      argument=arguments[1];
      if (argument.equals(""String_Node_Str"")) {
        freeze(time);
      }
 else {
        player.addMessage(""String_Node_Str"");
      }
    }
  }
}",0.7691008864499789
150434,"private void kickAllPlayers(){
  String message=""String_Node_Str"";
  if (restart) {
    message=""String_Node_Str"";
  }
  for (  Player p : playerList.getArray()) {
    p.kick(message);
  }
}","private void kickAllPlayers(){
  String message=""String_Node_Str"";
  if (restart) {
    message=""String_Node_Str"";
  }
  for (  Player player : playerList.getArray()) {
    player.kick(message);
  }
}",0.9743589743589745
150435,"private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(in.readUTF());
write(in.readUTF());
write(in.readLong());
write(in.readByte());
break;
case 0x02:
String name=in.readUTF();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=in.readUTF();
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher messageMatcher=MESSAGE_PATTERN.matcher(message);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
}
if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addMessage(""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
}
write(packetId);
write(message);
break;
case 0x04:
write(packetId);
copyNBytes(8);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
break;
case 0x0c:
write(packetId);
copyNBytes(9);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyNBytes(8);
break;
case 0x0e:
if (!isServerTunnel) {
if (player.getGroupId() < 0) {
skipNBytes(11);
}
 else {
byte status=in.readByte();
int x=in.readInt();
byte y=in.readByte();
int z=in.readInt();
byte face=in.readByte();
if (!server.chests.hasLock(x,y,z) || player.isAdmin()) {
if (server.chests.hasLock(x,y,z) && status == BLOCK_DESTROYED_STATUS) {
server.chests.releaseLock(x,y,z);
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
for (int c=1; c < DESTROY_HITS; ++c) {
packetFinished();
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
}
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
final int x=in.readInt();
final byte y=in.readByte();
final int z=in.readInt();
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
byte uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readByte();
}
boolean writePacket=true;
if (isServerTunnel) {
}
 else if (server.chests.hasLock(x,y,z) && !player.isAdmin() && !server.chests.ownsLock(player.getName(),x,y,z)) {
player.addMessage(""String_Node_Str"");
writePacket=false;
}
 else if ((player.getGroupId() < 0) || !server.blockFirewall.playerAllowed(player,dropItem)) {
String badBlock=String.format(server.l.get(""String_Node_Str""),player.getName(),Short.toString(dropItem));
server.runCommand(""String_Node_Str"",badBlock);
writePacket=false;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
if (server.chests.hasAdjacentLock(xPosition,yPosition,zPosition)) {
player.addMessage(""String_Node_Str"");
writePacket=false;
}
 else if (player.isAttemptLock()) {
if (server.chests.hasLock(xPosition,yPosition,zPosition)) {
player.addMessage(""String_Node_Str"");
}
 else if (server.chests.giveLock(player.getName(),xPosition,yPosition,zPosition,false)) {
player.addMessage(""String_Node_Str"");
}
 else {
player.addMessage(""String_Node_Str"");
}
player.setAttemptLock(false);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
}
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x14:
write(packetId);
write(in.readInt());
write(in.readUTF());
copyNBytes(16);
break;
case 0x15:
if (player.getGroupId() < 0) {
skipNBytes(22);
break;
}
write(packetId);
copyNBytes(22);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
copyNBytes(17);
break;
case 0x18:
write(packetId);
copyNBytes(19);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1D:
write(packetId);
copyNBytes(4);
break;
case 0x1E:
write(packetId);
copyNBytes(4);
break;
case 0x1F:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
copyNBytes(11);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x64:
write(packetId);
write(in.readByte());
write(in.readByte());
write(in.readUTF());
write(in.readByte());
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
if ((typeFrom < 0 && typeTo < 0) || player.getGroupId() >= 0) {
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readByte());
}
}
 else {
short moveItem=in.readShort();
if (moveItem != -1) {
in.readByte();
in.readByte();
}
}
break;
case 0x67:
byte type67=in.readByte();
if (type67 < 0 || player.getGroupId() >= 0) {
write(packetId);
short slot=in.readShort();
write(type67);
write(slot);
short setItem=in.readShort();
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readByte());
}
}
 else {
in.readShort();
short setItem=in.readShort();
if (setItem != -1) {
in.readByte();
in.readByte();
}
}
break;
case 0x68:
byte type=in.readByte();
if (type < 0 || player.getGroupId() >= 0) {
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
}
 else {
short count=in.readShort();
for (int c=0; c < count; ++c) {
short item=in.readShort();
if (item != -1) {
in.readByte();
in.readShort();
}
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(in.readUTF());
write(in.readUTF());
write(in.readUTF());
write(in.readUTF());
break;
case (byte)0xff:
write(packetId);
String reason=in.readUTF();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName());
}
}
packetFinished();
}","private void handlePacket() throws IOException {
  Byte packetId=in.readByte();
switch (packetId) {
case 0x00:
    write(packetId);
  break;
case 0x01:
write(packetId);
if (isServerTunnel) {
player.setEntityId(in.readInt());
write(player.getEntityId());
}
 else {
write(in.readInt());
}
write(in.readUTF());
write(in.readUTF());
write(in.readLong());
write(in.readByte());
break;
case 0x02:
String name=in.readUTF();
if (isServerTunnel || player.setName(name)) {
tunneler.setName(streamType + ""String_Node_Str"" + player.getName());
write(packetId);
write(name);
}
break;
case 0x03:
String message=in.readUTF();
if (isServerTunnel && server.options.getBoolean(""String_Node_Str"")) {
Matcher messageMatcher=MESSAGE_PATTERN.matcher(message);
if (messageMatcher.find()) {
Player friend=server.findPlayerExact(messageMatcher.group(1));
if (friend != null) {
String color=""String_Node_Str"";
String title=""String_Node_Str"";
String format=server.options.get(""String_Node_Str"");
Group group=friend.getGroup();
if (group != null) {
color=group.getColor();
if (group.showTitle()) {
title=group.getName();
format=server.options.get(""String_Node_Str"");
}
}
try {
message=String.format(format,friend.getName(),title,color) + messageMatcher.group(2);
}
 catch (IllegalFormatException e) {
System.out.println(""String_Node_Str"");
}
}
}
}
if (!isServerTunnel) {
if (player.isMuted() && !message.startsWith(""String_Node_Str"") && !message.startsWith(""String_Node_Str"")) {
player.addMessage(""String_Node_Str"");
break;
}
if (player.parseCommand(message)) {
break;
}
}
write(packetId);
write(message);
break;
case 0x04:
write(packetId);
copyNBytes(8);
break;
case 0x05:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readShort());
break;
case 0x06:
write(packetId);
copyNBytes(12);
break;
case 0x07:
int user=in.readInt();
int target=in.readInt();
Player targetPlayer=server.playerList.findPlayer(target);
if (targetPlayer != null) {
if (targetPlayer.godModeEnabled()) {
in.readBoolean();
break;
}
}
write(packetId);
write(user);
write(target);
write(in.readBoolean());
break;
case 0x08:
write(packetId);
copyNBytes(2);
break;
case 0x09:
write(packetId);
break;
case 0x0a:
write(packetId);
copyNBytes(1);
if (!inGame && !isServerTunnel) {
player.sendMOTD();
inGame=true;
}
break;
case 0x0b:
write(packetId);
copyPlayerLocation();
break;
case 0x0c:
write(packetId);
copyNBytes(9);
break;
case 0x0d:
write(packetId);
copyPlayerLocation();
copyNBytes(8);
break;
case 0x0e:
if (!isServerTunnel) {
if (player.getGroupId() < 0) {
skipNBytes(11);
}
 else {
byte status=in.readByte();
int x=in.readInt();
byte y=in.readByte();
int z=in.readInt();
byte face=in.readByte();
if (!server.chests.hasLock(x,y,z) || player.isAdmin()) {
if (server.chests.hasLock(x,y,z) && status == BLOCK_DESTROYED_STATUS) {
server.chests.releaseLock(x,y,z);
}
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
if (player.instantDestroyEnabled()) {
for (int c=1; c < DESTROY_HITS; ++c) {
packetFinished();
write(packetId);
write(status);
write(x);
write(y);
write(z);
write(face);
}
packetFinished();
write(packetId);
write(BLOCK_DESTROYED_STATUS);
write(x);
write(y);
write(z);
write(face);
}
}
}
}
 else {
write(packetId);
copyNBytes(11);
}
break;
case 0x0f:
final int x=in.readInt();
final byte y=in.readByte();
final int z=in.readInt();
final byte direction=in.readByte();
final short dropItem=in.readShort();
byte itemCount=0;
byte uses=0;
if (dropItem != -1) {
itemCount=in.readByte();
uses=in.readByte();
}
boolean writePacket=true;
if (isServerTunnel) {
}
 else if (server.chests.hasLock(x,y,z) && !player.isAdmin() && !server.chests.ownsLock(player.getName(),x,y,z)) {
player.addMessage(""String_Node_Str"");
writePacket=false;
}
 else if ((player.getGroupId() < 0) || !server.blockFirewall.playerAllowed(player,dropItem)) {
String badBlock=String.format(server.l.get(""String_Node_Str""),player.getName(),Short.toString(dropItem));
server.runCommand(""String_Node_Str"",badBlock);
write((byte)0x0e);
write((byte)0x04);
write(x);
write(y);
write(z);
write(direction);
writePacket=false;
}
 else if (dropItem == 54) {
int xPosition=x;
byte yPosition=y;
int zPosition=z;
switch (direction) {
case 0:
--yPosition;
break;
case 1:
++yPosition;
break;
case 2:
--zPosition;
break;
case 3:
++zPosition;
break;
case 4:
--xPosition;
break;
case 5:
++xPosition;
break;
}
if (server.chests.hasAdjacentLock(xPosition,yPosition,zPosition)) {
player.addMessage(""String_Node_Str"");
writePacket=false;
}
 else if (player.isAttemptLock()) {
if (server.chests.hasLock(xPosition,yPosition,zPosition)) {
player.addMessage(""String_Node_Str"");
}
 else if (server.chests.giveLock(player.getName(),xPosition,yPosition,zPosition,false)) {
player.addMessage(""String_Node_Str"");
}
 else {
player.addMessage(""String_Node_Str"");
}
player.setAttemptLock(false);
}
}
if (writePacket) {
write(packetId);
write(x);
write(y);
write(z);
write(direction);
write(dropItem);
if (dropItem != -1) {
write(itemCount);
write(uses);
}
}
break;
case 0x10:
write(packetId);
copyNBytes(2);
break;
case 0x12:
write(packetId);
copyNBytes(5);
break;
case 0x14:
write(packetId);
write(in.readInt());
write(in.readUTF());
copyNBytes(16);
break;
case 0x15:
if (player.getGroupId() < 0) {
skipNBytes(22);
break;
}
write(packetId);
copyNBytes(22);
break;
case 0x16:
write(packetId);
copyNBytes(8);
break;
case 0x17:
write(packetId);
copyNBytes(17);
break;
case 0x18:
write(packetId);
copyNBytes(19);
break;
case 0x1c:
write(packetId);
copyNBytes(10);
break;
case 0x1D:
write(packetId);
copyNBytes(4);
break;
case 0x1E:
write(packetId);
copyNBytes(4);
break;
case 0x1F:
write(packetId);
copyNBytes(7);
break;
case 0x20:
write(packetId);
copyNBytes(6);
break;
case 0x21:
write(packetId);
copyNBytes(9);
break;
case 0x22:
write(packetId);
copyNBytes(18);
break;
case 0x26:
write(packetId);
copyNBytes(5);
break;
case 0x27:
write(packetId);
copyNBytes(8);
break;
case 0x32:
write(packetId);
copyNBytes(9);
break;
case 0x33:
write(packetId);
copyNBytes(13);
int chunkSize=in.readInt();
write(chunkSize);
copyNBytes(chunkSize);
break;
case 0x34:
write(packetId);
copyNBytes(8);
short arraySize=in.readShort();
write(arraySize);
copyNBytes(arraySize * 4);
break;
case 0x35:
write(packetId);
copyNBytes(11);
break;
case 0x3c:
write(packetId);
copyNBytes(28);
int recordCount=in.readInt();
write(recordCount);
copyNBytes(recordCount * 3);
break;
case 0x64:
write(packetId);
write(in.readByte());
write(in.readByte());
write(in.readUTF());
write(in.readByte());
break;
case 0x65:
write(packetId);
write(in.readByte());
break;
case 0x66:
byte typeFrom=in.readByte();
short slotFrom=in.readShort();
byte typeTo=in.readByte();
short slotTo=in.readShort();
if ((typeFrom < 0 && typeTo < 0) || player.getGroupId() >= 0) {
write(packetId);
write(typeFrom);
write(slotFrom);
write(typeTo);
write(slotTo);
short moveItem=in.readShort();
write(moveItem);
if (moveItem != -1) {
write(in.readByte());
write(in.readByte());
}
}
 else {
short moveItem=in.readShort();
if (moveItem != -1) {
in.readByte();
in.readByte();
}
}
break;
case 0x67:
byte type67=in.readByte();
if (type67 < 0 || player.getGroupId() >= 0) {
write(packetId);
short slot=in.readShort();
write(type67);
write(slot);
short setItem=in.readShort();
write(setItem);
if (setItem != -1) {
write(in.readByte());
write(in.readByte());
}
}
 else {
in.readShort();
short setItem=in.readShort();
if (setItem != -1) {
in.readByte();
in.readByte();
}
}
break;
case 0x68:
byte type=in.readByte();
if (type < 0 || player.getGroupId() >= 0) {
write(packetId);
write(type);
short count=in.readShort();
write(count);
for (int c=0; c < count; ++c) {
short item=in.readShort();
write(item);
if (item != -1) {
write(in.readByte());
write(in.readShort());
}
}
}
 else {
short count=in.readShort();
for (int c=0; c < count; ++c) {
short item=in.readShort();
if (item != -1) {
in.readByte();
in.readShort();
}
}
}
break;
case 0x69:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readShort());
break;
case 0x6a:
write(packetId);
write(in.readByte());
write(in.readShort());
write(in.readByte());
break;
case (byte)0x82:
write(packetId);
write(in.readInt());
write(in.readShort());
write(in.readInt());
write(in.readUTF());
write(in.readUTF());
write(in.readUTF());
write(in.readUTF());
break;
case (byte)0xff:
write(packetId);
String reason=in.readUTF();
write(reason);
if (reason.startsWith(""String_Node_Str"")) {
server.addRobot(player);
}
player.close();
break;
default :
if (EXPENSIVE_DEBUG_LOGGING) {
while (true) {
skipNBytes(1);
flushAll();
}
}
 else {
throw new IOException(""String_Node_Str"" + streamType + ""String_Node_Str""+ Integer.toHexString(packetId)+ ""String_Node_Str""+ player.getName());
}
}
packetFinished();
}",0.9950397969777368
150436,"public boolean setName(String name){
  name=name.trim();
  if (name.length() == 0 || this.name != null) {
    kick(""String_Node_Str"");
    return false;
  }
  if (server.options.getBoolean(""String_Node_Str"") && !server.whitelist.isWhitelisted(name)) {
    kick(""String_Node_Str"");
    return false;
  }
  this.name=name;
  updateGroup();
  watchdog.setName(""String_Node_Str"" + name);
  server.connectionLog(""String_Node_Str"",extsocket,name);
  server.playerList.addPlayer(this);
  return true;
}","public boolean setName(String name){
  name=name.trim();
  if (name.length() == 0 || this.name != null) {
    kick(""String_Node_Str"");
    return false;
  }
  if (server.options.getBoolean(""String_Node_Str"") && !server.whitelist.isWhitelisted(name)) {
    kick(""String_Node_Str"");
    return false;
  }
  if (server.playerList.findPlayerExact(name) != null) {
    kick(""String_Node_Str"");
    return false;
  }
  this.name=name;
  updateGroup();
  watchdog.setName(""String_Node_Str"" + name);
  server.connectionLog(""String_Node_Str"",extsocket,name);
  server.playerList.addPlayer(this);
  return true;
}",0.9016393442622952
150437,"public void close(){
  serverToClient.stop();
  clientToServer.stop();
}","public void close(){
  if (serverToClient != null) {
    serverToClient.stop();
  }
  if (clientToServer != null) {
    clientToServer.stop();
  }
  if (name != null) {
    server.playerList.removePlayer(this);
    name=null;
  }
}",0.3366336633663366
150438,"private void cleanup(){
  if (!closed) {
    closed=true;
    entityId=0;
    if (serverToClient != null) {
      serverToClient.stop();
    }
    if (clientToServer != null) {
      clientToServer.stop();
    }
    if (name != null) {
      server.playerList.removePlayer(this);
    }
    try {
      extsocket.close();
    }
 catch (    IOException e) {
    }
    try {
      intsocket.close();
    }
 catch (    IOException e) {
    }
    if (!isRobot) {
      System.out.println(""String_Node_Str"" + extsocket.getInetAddress().getHostAddress());
    }
  }
}","private void cleanup(){
  if (!closed) {
    closed=true;
    entityId=0;
    close();
    try {
      extsocket.close();
    }
 catch (    IOException e) {
    }
    try {
      intsocket.close();
    }
 catch (    IOException e) {
    }
    if (!isRobot) {
      System.out.println(""String_Node_Str"" + extsocket.getInetAddress().getHostAddress());
    }
  }
}",0.7665580890336591
150439,"@Override public void run(){
  try {
    while (run) {
      lastRead=System.currentTimeMillis();
      try {
        handlePacket();
        if (isServerTunnel) {
          while (player.hasMessages()) {
            sendMessage(player.getMessage());
          }
        }
        flushAll();
      }
 catch (      IOException e) {
        if (run) {
          e.printStackTrace();
          System.out.println(streamType + ""String_Node_Str"" + player.getName());
        }
        break;
      }
    }
    try {
      if (player.isKicked()) {
        kick(player.getKickMsg());
      }
      flushAll();
    }
 catch (    IOException e) {
    }
  }
  finally {
    if (EXPENSIVE_DEBUG_LOGGING) {
      inputDumper.cleanup();
      outputDumper.cleanup();
    }
  }
}","@Override public void run(){
  try {
    while (run) {
      lastRead=System.currentTimeMillis();
      try {
        handlePacket();
        if (isServerTunnel) {
          while (player.hasMessages()) {
            sendMessage(player.getMessage());
          }
        }
        flushAll();
      }
 catch (      IOException e) {
        if (run) {
          e.printStackTrace();
          System.out.println(streamType + ""String_Node_Str"" + player.getIPAddress());
        }
        break;
      }
    }
    try {
      if (player.isKicked()) {
        kick(player.getKickMsg());
      }
      flushAll();
    }
 catch (    IOException e) {
    }
  }
  finally {
    if (EXPENSIVE_DEBUG_LOGGING) {
      inputDumper.cleanup();
      outputDumper.cleanup();
    }
  }
}",0.9915419648666232
150440,"protected void loadDefaults(){
  defaultOptions=new Properties();
  InputStream stream=getClass().getResourceAsStream(resourceLocation + ""String_Node_Str"" + filename);
  try {
    try {
      defaultOptions.load(stream);
    }
  finally {
      stream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"" + filename);
  }
  options=new Properties(defaultOptions);
}","protected void loadDefaults(){
  defaultOptions=new Properties();
  InputStream stream=getClass().getResourceAsStream(resourceLocation + ""String_Node_Str"" + filename);
  try {
    try {
      defaultOptions.load(stream);
    }
  finally {
      stream.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"" + filename);
  }
  options=(Properties)defaultOptions.clone();
}",0.9835680751173708
150441,"public void load(){
  options=new Properties(defaultOptions);
  File file=new File(filename);
  try {
    InputStream stream=new FileInputStream(file);
    try {
      options.load(stream);
    }
  finally {
      stream.close();
    }
  }
 catch (  FileNotFoundException e) {
    missingFile();
  }
catch (  IOException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"" + filename);
  }
}","public void load(){
  options=(Properties)defaultOptions.clone();
  File file=new File(filename);
  try {
    InputStream stream=new FileInputStream(file);
    try {
      options.load(stream);
    }
  finally {
      stream.close();
    }
  }
 catch (  FileNotFoundException e) {
    missingFile();
  }
catch (  IOException e) {
    e.printStackTrace();
    System.out.println(""String_Node_Str"" + filename);
  }
}",0.983009708737864
150442,"@Override protected void loadDefaults(){
}","@Override protected void loadDefaults(){
  defaultOptions=new Properties();
}",0.7058823529411765
150443,"@Override public void save(){
  options=new Properties();
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  super.save();
}","@Override public void save(){
  load();
  options=new Properties();
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",""String_Node_Str"");
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  options.setProperty(""String_Node_Str"",simpleServerOptions.get(""String_Node_Str""));
  super.save();
}",0.9895833333333334
150444,"public static void main(String[] args){
  Serial4JArduino device=null;
  try {
    String serialPort=""String_Node_Str"";
    if (args.length == 1) {
      serialPort=args[0];
    }
 else {
      serialPort=Serial4JArduino.selectSerialPort();
    }
    device=new Serial4JArduino(serialPort);
    InteractiveJArduinoDataControllerClientAdvanced controller=new InteractiveJArduinoDataControllerClientAdvanced();
    device.register(controller);
    controller.register(device);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    device.close();
  }
}","public static void main(String[] args){
  Serial4JArduino device=null;
  String serialPort=null;
  try {
    if (args.length == 1) {
      serialPort=args[0];
    }
 else {
      serialPort=Serial4JArduino.selectSerialPort();
    }
    InteractiveJArduinoDataControllerClientAdvanced controller=new InteractiveJArduinoDataControllerClientAdvanced();
    if (serialPort != null) {
      device=new Serial4JArduino(serialPort);
      device.register(controller);
      controller.register(device);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (device != null) {
      device.close();
    }
  }
}",0.6822351959966639
150445,"public void serialEvent(SerialPortEvent arg0){
  int data;
  try {
    while ((data=in.read()) > -1) {
      if (state == RCV_WAIT) {
        if (data == START_BYTE) {
          state=RCV_MSG;
          buffer_idx=0;
        }
      }
 else       if (state == RCV_MSG) {
        if (data == ESCAPE_BYTE) {
          state=RCV_ESC;
        }
 else         if (data == STOP_BYTE) {
          byte[] packet=new byte[buffer_idx];
          for (int i=0; i < buffer_idx; i++)           packet[i]=buffer[i];
          for (          JArduinoObserver o : observers) {
            o.receiveMsg(packet);
          }
          state=RCV_WAIT;
        }
 else         if (data == START_BYTE) {
          state=RCV_MSG;
          buffer_idx=0;
        }
 else {
          buffer[buffer_idx]=(byte)data;
          buffer_idx++;
        }
      }
 else       if (state == RCV_ESC) {
        buffer[buffer_idx]=(byte)data;
        buffer_idx++;
        state=RCV_MSG;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void serialEvent(SerialPortEvent arg0){
  int data;
  try {
    while ((data=in.read()) > -1) {
      if (state == RCV_WAIT) {
        if (data == START_BYTE) {
          state=RCV_MSG;
          buffer_idx=0;
        }
      }
 else       if (state == RCV_MSG) {
        if (data == ESCAPE_BYTE) {
          state=RCV_ESC;
        }
 else         if (data == STOP_BYTE) {
          byte[] packet=new byte[buffer_idx];
          for (int i=0; i < buffer_idx; i++) {
            packet[i]=buffer[i];
          }
          for (          JArduinoObserver o : observers) {
            o.receiveMsg(packet);
          }
          state=RCV_WAIT;
        }
 else         if (data == START_BYTE) {
          state=RCV_MSG;
          buffer_idx=0;
        }
 else {
          buffer[buffer_idx]=(byte)data;
          buffer_idx++;
        }
      }
 else       if (state == RCV_ESC) {
        buffer[buffer_idx]=(byte)data;
        buffer_idx++;
        state=RCV_MSG;
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9922779922779924
150446,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new ToneKeyKeyboard(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new ToneKeyKeyboard(serialPort);
  arduino.runArduinoProcess();
}",0.8593155893536122
150447,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new AnalogInOutSerial(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new AnalogInOutSerial(serialPort);
  arduino.runArduinoProcess();
}",0.5547169811320755
150448,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new AnalogInput(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new AnalogInput(serialPort);
  arduino.runArduinoProcess();
}",0.5675675675675675
150449,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new Blink(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new Blink(serialPort);
  arduino.runArduinoProcess();
}",0.8537549407114624
150450,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new Ping(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new Ping(serialPort);
  arduino.runArduinoProcess();
}",0.8531746031746031
150451,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new SimpleInterrupt(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new SimpleInterrupt(serialPort);
  arduino.runArduinoProcess();
}",0.8593155893536122
150452,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new Button(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new Button(serialPort);
  arduino.runArduinoProcess();
}",0.8543307086614174
150453,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new StateChangeDetection(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new StateChangeDetection(serialPort);
  arduino.runArduinoProcess();
}",0.8619402985074627
150454,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new ToneKeyboard(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new ToneKeyboard(serialPort);
  arduino.runArduinoProcess();
}",0.8576923076923076
150455,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new ToneMelody(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new ToneMelody(serialPort);
  arduino.runArduinoProcess();
}",0.8565891472868217
150456,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new ToneMultiple(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new ToneMultiple(serialPort);
  arduino.runArduinoProcess();
}",0.8576923076923076
150457,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  JArduino arduino=new TonePitchFollower(serialPort);
  arduino.runArduinoProcess();
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  JArduino arduino=new TonePitchFollower(serialPort);
  arduino.runArduinoProcess();
}",0.8603773584905661
150458,"public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=SerialSelectorGUI.selectSerialPort();
  }
  Serial4JArduino device=null;
  try {
    device=new Serial4JArduino(serialPort);
    InteractiveJArduinoDataControllerClient controller2=new InteractiveJArduinoDataControllerClient();
    device.register(controller2);
    controller2.register(device);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    device.close();
  }
}","public static void main(String[] args){
  String serialPort;
  if (args.length == 1) {
    serialPort=args[0];
  }
 else {
    serialPort=Serial4JArduino.selectSerialPort();
  }
  Serial4JArduino device=null;
  try {
    device=new Serial4JArduino(serialPort);
    InteractiveJArduinoDataControllerClient controller2=new InteractiveJArduinoDataControllerClient();
    device.register(controller2);
    controller2.register(device);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    device.close();
  }
}",0.7267552182163188
150459,"/** 
 * Return a List of Objects from a single table column given a SQL Key using an SQL statement matching the sqlKey String in a properties file loaded via Yank.addSQLStatements(...).
 * @param sqlKey The SQL Key found in a properties file corresponding to the desired SQL statement value
 * @param params The replacement parameters
 * @param columnType The Class of the desired return Objects matching the table
 * @return The Column as a List
 * @throws SQLStatementNotFoundException if an SQL statement could not be found for the given sqlKey String
 */
public static <T>List<T> queryColumnSQLKey(String sqlKey,String columnName,Class<T> columnType,Object[] params){
  String sql=YANK_POOL_MANAGER.getMergedSqlProperties().getProperty(sqlKey);
  if (sql == null || sql.equalsIgnoreCase(""String_Node_Str"")) {
    throw new SQLStatementNotFoundException();
  }
 else {
    return queryBeanList(sql,columnType,params);
  }
}","/** 
 * Return a List of Objects from a single table column given a SQL Key using an SQL statement matching the sqlKey String in a properties file loaded via Yank.addSQLStatements(...).
 * @param sqlKey The SQL Key found in a properties file corresponding to the desired SQL statement value
 * @param params The replacement parameters
 * @param columnType The Class of the desired return Objects matching the table
 * @return The Column as a List
 * @throws SQLStatementNotFoundException if an SQL statement could not be found for the given sqlKey String
 */
public static <T>List<T> queryColumnSQLKey(String sqlKey,String columnName,Class<T> columnType,Object[] params){
  String sql=YANK_POOL_MANAGER.getMergedSqlProperties().getProperty(sqlKey);
  if (sql == null || sql.equalsIgnoreCase(""String_Node_Str"")) {
    throw new SQLStatementNotFoundException();
  }
 else {
    return queryColumn(sql,columnName,columnType,params);
  }
}",0.986566362170876
150460,"/** 
 * Return just one scalar given a SQL Key using an SQL statement matching the sqlKey String in a properties file loaded via Yank.addSQLStatements(...). If more than one row match the query, only the first row is returned.
 * @param sqlKey The SQL Key found in a properties file corresponding to the desired SQL statement value
 * @param scalarType The Class of the desired return scalar matching the table
 * @param params The replacement parameters
 * @return The Object
 * @throws SQLStatementNotFoundException if an SQL statement could not be found for the given sqlKey String
 */
public static <T>T queryScalarSQLKey(String sqlKey,Class<T> scalarType,Object[] params){
  String sql=YANK_POOL_MANAGER.getMergedSqlProperties().getProperty(sqlKey);
  if (sql == null || sql.equalsIgnoreCase(""String_Node_Str"")) {
    throw new SQLStatementNotFoundException();
  }
 else {
    return queryBean(sql,scalarType,params);
  }
}","/** 
 * Return just one scalar given a SQL Key using an SQL statement matching the sqlKey String in a properties file loaded via Yank.addSQLStatements(...). If more than one row match the query, only the first row is returned.
 * @param sqlKey The SQL Key found in a properties file corresponding to the desired SQL statement value
 * @param scalarType The Class of the desired return scalar matching the table
 * @param params The replacement parameters
 * @return The Object
 * @throws SQLStatementNotFoundException if an SQL statement could not be found for the given sqlKey String
 */
public static <T>T queryScalarSQLKey(String sqlKey,Class<T> scalarType,Object[] params){
  String sql=YANK_POOL_MANAGER.getMergedSqlProperties().getProperty(sqlKey);
  if (sql == null || sql.equalsIgnoreCase(""String_Node_Str"")) {
    throw new SQLStatementNotFoundException();
  }
 else {
    return queryScalar(sql,scalarType,params);
  }
}",0.9946178686759956
150461,"/** 
 * Init method without a MYSQL_SQL.properties file
 * @param dbProperties
 */
public void init(Properties dbProperties){
  logger.info(""String_Node_Str"");
  if (dbProperties == null) {
    logger.error(""String_Node_Str"");
  }
  sqlProperties=new Properties();
  loadDriver(dbProperties);
  createPools(dbProperties);
}","/** 
 * Init method without a MYSQL_SQL.properties file
 * @param dbProperties
 */
public void init(Properties dbProperties){
  logger.info(""String_Node_Str"");
  if (dbProperties == null) {
    logger.error(""String_Node_Str"");
  }
  this.sqlProperties=new Properties();
  createPools(dbProperties);
}",0.9149277688603532
150462,"/** 
 * Returns an open connection. If no one is available, and the max number of connections has not been reached, a new connection is created.
 * @param poolName The pool name as defined in the properties file
 * @return Connection, the connection or null
 */
public Connection getConnection(String poolName){
  DBConnectionPool pool=pools.get(poolName);
  if (pool != null) {
    return pool.getConnection();
  }
 else {
    logger.error(""String_Node_Str"" + poolName);
  }
  return null;
}","/** 
 * Returns an open connection. If no one is available, and the max number of connections has not been reached, a new connection is created.
 * @param poolName The pool name as defined in the properties file
 * @return Connection, the connection or null if the number of connections in use exceeds the max allowed connections
 */
public Connection getConnection(String poolName){
  DBConnectionPool pool=pools.get(poolName);
  if (pool != null) {
    return pool.getConnection();
  }
 else {
    logger.error(""String_Node_Str"" + poolName);
    return null;
  }
}",0.9017013232514176
150463,"/** 
 * Creates instances of DBConnectionPool objects based on the properties. A DBConnectionPool can be defined with the following properties: <PRE> poolname.url         The JDBC URL for the database poolname.user        A database user (optional) poolname.password    A database user password (if user specified) poolname.maxconn     The maximal number of connections (optional) </PRE>
 * @param props The connection pool properties
 */
private void createPools(Properties dbProperties){
  Enumeration propNames=dbProperties.propertyNames();
  while (propNames.hasMoreElements()) {
    String name=(String)propNames.nextElement();
    if (name.endsWith(""String_Node_Str"")) {
      String poolName=name.substring(0,name.lastIndexOf('.'));
      String url=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      if (url == null) {
        logger.warn(""String_Node_Str"" + poolName);
        continue;
      }
      String user=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      String password=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      String maxconn=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      int max;
      try {
        max=Integer.valueOf(maxconn).intValue();
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"" + maxconn + ""String_Node_Str""+ poolName);
        max=0;
      }
      DBConnectionPool pool=new DBConnectionPool(url,user,password,max);
      pools.put(poolName,pool);
      logger.info(""String_Node_Str"" + poolName + ""String_Node_Str"");
    }
  }
}","/** 
 * Creates instances of DBConnectionPool objects based on the properties. A DBConnectionPool can be defined with the following properties: <pre> poolname.url         The JDBC URL for the database poolname.user        A database user (optional) poolname.password    A database user password (if user specified) poolname.maxconn     The maximal number of connections (optional) </pre>
 * @param props The connection pool properties
 */
private void createPools(Properties dbProperties){
  Enumeration propNames=dbProperties.propertyNames();
  while (propNames.hasMoreElements()) {
    String name=(String)propNames.nextElement();
    if (name.endsWith(""String_Node_Str"")) {
      String poolName=name.substring(0,name.lastIndexOf('.'));
      String url=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      if (url == null) {
        logger.warn(""String_Node_Str"" + poolName);
        continue;
      }
      String user=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      String password=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      String maxconn=dbProperties.getProperty(poolName + ""String_Node_Str"").trim();
      int max;
      try {
        max=Integer.valueOf(maxconn).intValue();
      }
 catch (      NumberFormatException e) {
        logger.warn(""String_Node_Str"" + maxconn + ""String_Node_Str""+ poolName);
        max=0;
      }
      DBConnectionPool pool=new DBConnectionPool(url,user,password,max);
      pools.put(poolName,pool);
      logger.info(""String_Node_Str"" + poolName + ""String_Node_Str"");
    }
  }
}",0.9962145110410094
150464,"/** 
 * Closes all open connections and deregisters all drivers.
 */
public synchronized void release(){
  logger.info(""String_Node_Str"");
  Set<String> allPools=pools.keySet();
  for (Iterator<String> iterator=allPools.iterator(); iterator.hasNext(); ) {
    String poolName=iterator.next();
    logger.debug(""String_Node_Str"" + poolName + ""String_Node_Str"");
    pools.get(poolName).release();
  }
  try {
    DriverManager.deregisterDriver(jdbcDriver);
  }
 catch (  SQLException e) {
    logger.error(""String_Node_Str"" + jdbcDriver.getClass().getName(),e);
  }
  logger.info(""String_Node_Str"" + jdbcDriver.getClass().getName());
}","/** 
 * Closes all open connections
 */
public synchronized void release(){
  logger.info(""String_Node_Str"");
  Set<String> allPools=pools.keySet();
  for (Iterator<String> iterator=allPools.iterator(); iterator.hasNext(); ) {
    String poolName=iterator.next();
    logger.debug(""String_Node_Str"" + poolName + ""String_Node_Str"");
    pools.get(poolName).release();
  }
}",0.7395626242544732
150465,"/** 
 * Checks out a connection from the pool. If no free connection is available, a new connection is created unless the max number of connections has been reached. If a free connection has been closed by the database, it's removed from the pool and this method is called again recursively.
 */
public synchronized Connection getConnection(){
  Connection con=null;
  if (freeConnections.size() > 0) {
    con=freeConnections.firstElement();
    freeConnections.removeElementAt(0);
    try {
      if (con.isClosed()) {
        logger.debug(""String_Node_Str"");
        con=getConnection();
      }
    }
 catch (    SQLException e) {
      logger.debug(""String_Node_Str"",e);
      con=getConnection();
    }
  }
 else   if (maxConn == 0 || checkedOut < maxConn) {
    con=newConnection();
  }
  if (con != null) {
    checkedOut++;
  }
  logger.trace(""String_Node_Str"" + checkedOut);
  return con;
}","/** 
 * * Checks out a connection from the pool. If no free connection is available, a new connection is created unless the max number of connections has been reached. If a free connection has been closed by the database, it is removed from the pool and this method is called again recursively.
 * @return a Connection, null if pool size has been exceeded
 */
public synchronized Connection getConnection(){
  Connection connection=null;
  if (pool.size() > 0) {
    connection=pool.firstElement();
    pool.removeElementAt(0);
    try {
      if (connection.isClosed()) {
        logger.debug(""String_Node_Str"");
        connection=getConnection();
      }
    }
 catch (    SQLException e) {
      logger.debug(""String_Node_Str"",e);
      connection=getConnection();
    }
  }
 else   if (maxConn == 0 || checkedOut < maxConn) {
    connection=newConnection();
  }
  if (connection != null) {
    checkedOut++;
  }
  logger.trace(""String_Node_Str"" + checkedOut);
  return connection;
}",0.9051404345521992
150466,"/** 
 * Checks in a connection to the pool. Notify other Threads that may be waiting for a connection.
 * @param con The connection to check in
 */
public synchronized void freeConnection(Connection con){
  freeConnections.addElement(con);
  checkedOut--;
  notifyAll();
}","/** 
 * Checks in a connection to the pool. Notify other Threads that may be waiting for a connection.
 * @param con The connection to check in
 */
public synchronized void freeConnection(Connection con){
  if (con != null) {
    pool.addElement(con);
    checkedOut--;
    notifyAll();
  }
}",0.9113475177304964
150467,"/** 
 * Closes all available connections.
 */
public synchronized void release(){
  Enumeration<Connection> allConnections=freeConnections.elements();
  while (allConnections.hasMoreElements()) {
    logger.debug(""String_Node_Str"");
    Connection con=allConnections.nextElement();
    try {
      con.close();
      logger.debug(""String_Node_Str"");
    }
 catch (    SQLException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  freeConnections.removeAllElements();
}","/** 
 * Closes all available connections.
 */
public synchronized void release(){
  Enumeration<Connection> allConnections=pool.elements();
  while (allConnections.hasMoreElements()) {
    logger.debug(""String_Node_Str"");
    Connection con=allConnections.nextElement();
    try {
      con.close();
      logger.debug(""String_Node_Str"");
    }
 catch (    SQLException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  pool.removeAllElements();
  checkedOut=0;
}",0.9506398537477148
150468,"/** 
 * Loads a Properties file from the classpath matching the given file name
 * @param pFileName
 * @return
 */
public static Properties getPropertiesFromClasspath(String pFileName){
  Properties props=new Properties();
  try {
    props.load(ClassLoader.getSystemResourceAsStream(pFileName));
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
  return props;
}","/** 
 * Loads a Properties file from the classpath matching the given file name
 * @param fileName
 * @return
 */
public static Properties getPropertiesFromClasspath(String fileName){
  Properties props=new Properties();
  try {
    InputStream is=ClassLoader.getSystemResourceAsStream(fileName);
    if (is == null) {
      is=Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);
      logger.debug(""String_Node_Str"");
    }
    props.load(is);
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  NullPointerException e) {
    logger.error(""String_Node_Str"",e);
  }
  return props;
}",0.6750972762645915
150469,"/** 
 * Loads a Properties file from the given file name
 * @param pFileName
 * @return
 */
public static Properties getPropertiesFromPath(String pFileName){
  Properties props=new Properties();
  FileInputStream fis;
  try {
    fis=new FileInputStream(pFileName);
    props.load(fis);
    fis.close();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return props;
}","/** 
 * Loads a Properties file from the given file name
 * @param fileName
 * @return
 */
public static Properties getPropertiesFromPath(String fileName){
  Properties props=new Properties();
  FileInputStream fis;
  try {
    fis=new FileInputStream(fileName);
    props.load(fis);
    fis.close();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return props;
}",0.5823754789272031
150470,"public void compile() throws Exception {
  LifecycleManager.getDefault().saveAll();
  for (  CoffeeScriptDataObject dataObject : data) {
    ProgressHandle handle=handle=ProgressHandleFactory.createHandle(""String_Node_Str"" + dataObject.getPrimaryFile().getNameExt(),this);
    try {
      handle.start();
      CoffeeScriptCompiler.CompilerResult result=CoffeeScriptSettings.getCompiler().compile(dataObject.getPrimaryFile().asText(),bare);
      if (result == null) {
        return;
      }
      if (result.getJs() != null) {
        FileObject folder=dataObject.getFolder().getPrimaryFile();
        FileObject file=folder.getFileObject(dataObject.getName(),""String_Node_Str"");
        if (file != null) {
          file.delete();
        }
        file=folder.createData(dataObject.getName(),""String_Node_Str"");
        file.getOutputStream().write(result.getJs().getBytes());
      }
 else {
      }
      handleResult(result);
    }
  finally {
      handle.finish();
    }
  }
}","public void compile() throws Exception {
  LifecycleManager.getDefault().saveAll();
  for (  CoffeeScriptDataObject coffeeFile : data) {
    ProgressHandle handle=ProgressHandleFactory.createHandle(""String_Node_Str"" + coffeeFile.getPrimaryFile().getNameExt(),this);
    try {
      handle.start();
      CoffeeScriptCompiler.CompilerResult result=CoffeeScriptSettings.getCompiler().compile(coffeeFile.getPrimaryFile().asText(),bare);
      if (result == null) {
        return;
      }
      if (result.getJs() != null) {
        CoffeeScriptUtils.writeJSForCoffeeScriptFile(result.getJs(),coffeeFile.getPrimaryFile());
      }
      handleResult(result);
    }
  finally {
      handle.finish();
    }
  }
}",0.6564344746162928
150471,"public void run(final CoffeeScriptParser.ParsingResult result,SchedulerEvent event){
  if ((result != null) && !CoffeeScriptAutocompileContext.get().isEnabled(result.getSnapshot().getSource().getFileObject())) {
    return;
  }
  if ((result != null) && (result.getCompilerResult() != null) && (result.getCompilerResult().getJs() != null)) {
    final FileObject coffeeFile=result.getSnapshot().getSource().getFileObject();
    final String js=result.getCompilerResult().getJs();
    try {
      FileObject folder=coffeeFile.getParent();
      FileObject file=folder.getFileObject(coffeeFile.getName(),""String_Node_Str"");
      if (file == null) {
        file=folder.createData(coffeeFile.getName(),""String_Node_Str"");
      }
      if (!file.asText().equals(js)) {
        OutputStream out=file.getOutputStream();
        try {
          out.write(js.getBytes(FileEncodingQuery.getEncoding(coffeeFile)));
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    Exception e) {
      Exceptions.printStackTrace(e);
    }
  }
}","public void run(final CoffeeScriptParser.ParsingResult result,SchedulerEvent event){
  if ((result != null) && !CoffeeScriptAutocompileContext.get().isEnabled(result.getSnapshot().getSource().getFileObject())) {
    return;
  }
  if ((result != null) && (result.getCompilerResult() != null) && (result.getCompilerResult().getJs() != null)) {
    FileObject coffeeFile=result.getSnapshot().getSource().getFileObject();
    String js=result.getCompilerResult().getJs();
    CoffeeScriptUtils.writeJSForCoffeeScriptFile(js,coffeeFile);
  }
}",0.5812688821752265
150472,"@SuppressWarnings(""String_Node_Str"") public final Connection getConnection(){
  if (!connectionInitialised) {
    connectionInitialised=true;
    connection=getConnection0(null,null);
    final Connection c=connection;
    if (false)     connection=new MockConnection(new MockDataProvider(){
      @Override public MockResult[] execute(      MockExecuteContext context) throws SQLException {
        DSLContext executor=DSL.using(c,getDialect());
        if (context.batchSingle()) {
          Query query=executor.query(context.sql(),new Object[context.batchBindings()[0].length]);
          int[] result=executor.batch(query).bind(context.batchBindings()).execute();
          MockResult[] r=new MockResult[result.length];
          for (int i=0; i < r.length; i++) {
            r[i]=new MockResult(result[i],null);
          }
          return r;
        }
 else         if (context.batchMultiple()) {
          List<Query> queries=new ArrayList<Query>();
          for (          String sql : context.batchSQL()) {
            queries.add(executor.query(sql));
          }
          int[] result=executor.batch(queries).execute();
          MockResult[] r=new MockResult[result.length];
          for (int i=0; i < r.length; i++) {
            r[i]=new MockResult(result[i],null);
          }
          return r;
        }
 else         if (context.sql().toLowerCase().matches(""String_Node_Str"")) {
          List<Result<Record>> result=executor.fetchMany(context.sql(),context.bindings());
          MockResult[] r=new MockResult[result.size()];
          for (int i=0; i < result.size(); i++) {
            r[i]=new MockResult(result.get(i).size(),result.get(i));
          }
          return r;
        }
 else {
          int result=executor.execute(context.sql(),context.bindings());
          MockResult[] r=new MockResult[1];
          r[0]=new MockResult(result,null);
          return r;
        }
      }
    }
);
    if (RUN_CONSOLE_IN_PROCESS) {
      try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        Debugger debugger=DebuggerFactory.remoteDebugger(""String_Node_Str"",DEBUGGER_PORT);
        Console console=new Console(debugger,true,true);
        console.setLoggingActive(true);
        console.setVisible(true);
      }
 catch (      Exception ignore) {
      }
    }
  }
  return connection;
}","@SuppressWarnings(""String_Node_Str"") public final Connection getConnection(){
  if (!connectionInitialised) {
    connectionInitialised=true;
    connection=getConnection0(null,null);
    if (asList(MARIADB,MYSQL).contains(create().configuration().dialect().family())) {
      create().execute(""String_Node_Str"");
    }
    final Connection c=connection;
    if (false)     connection=new MockConnection(new MockDataProvider(){
      @Override public MockResult[] execute(      MockExecuteContext context) throws SQLException {
        DSLContext executor=DSL.using(c,getDialect());
        if (context.batchSingle()) {
          Query query=executor.query(context.sql(),new Object[context.batchBindings()[0].length]);
          int[] result=executor.batch(query).bind(context.batchBindings()).execute();
          MockResult[] r=new MockResult[result.length];
          for (int i=0; i < r.length; i++) {
            r[i]=new MockResult(result[i],null);
          }
          return r;
        }
 else         if (context.batchMultiple()) {
          List<Query> queries=new ArrayList<Query>();
          for (          String sql : context.batchSQL()) {
            queries.add(executor.query(sql));
          }
          int[] result=executor.batch(queries).execute();
          MockResult[] r=new MockResult[result.length];
          for (int i=0; i < r.length; i++) {
            r[i]=new MockResult(result[i],null);
          }
          return r;
        }
 else         if (context.sql().toLowerCase().matches(""String_Node_Str"")) {
          List<Result<Record>> result=executor.fetchMany(context.sql(),context.bindings());
          MockResult[] r=new MockResult[result.size()];
          for (int i=0; i < result.size(); i++) {
            r[i]=new MockResult(result.get(i).size(),result.get(i));
          }
          return r;
        }
 else {
          int result=executor.execute(context.sql(),context.bindings());
          MockResult[] r=new MockResult[1];
          r[0]=new MockResult(result,null);
          return r;
        }
      }
    }
);
    if (RUN_CONSOLE_IN_PROCESS) {
      try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        Debugger debugger=DebuggerFactory.remoteDebugger(""String_Node_Str"",DEBUGGER_PORT);
        Console console=new Console(debugger,true,true);
        console.setLoggingActive(true);
        console.setVisible(true);
      }
 catch (      Exception ignore) {
      }
    }
  }
  return connection;
}",0.971947194719472
150473,"@Override public void keyPressed(KeyEvent e){
  boolean isControlDown=e.isControlDown();
  boolean isShiftDown=e.isShiftDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_P:
    if (isControlDown && isShiftDown) {
      int position=RSyntaxUtilities.getMatchingBracketPosition(SqlTextArea.this);
      if (position >= 0) {
        setCaretPosition(position + 1);
      }
    }
  break;
case KeyEvent.VK_F:
if (isControlDown && isShiftDown) {
  formatSelection();
}
break;
}
}","@Override public void keyPressed(KeyEvent e){
  boolean isControlDown=e.isControlDown();
  boolean isShiftDown=e.isShiftDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_P:
    if (isControlDown && isShiftDown) {
      int position=RSyntaxUtilities.getMatchingBracketPosition(SqlTextArea.this,null).y;
      if (position >= 0) {
        setCaretPosition(position + 1);
      }
    }
  break;
case KeyEvent.VK_F:
if (isControlDown && isShiftDown) {
  formatSelection();
}
break;
}
}",0.9905956112852664
150474,"public SqlTextArea(){
  setTabSize(2);
  setTabsEmulated(true);
  setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_SQL);
  setMarkOccurrences(true);
  setAnimateBracketMatching(false);
  setAutoIndentEnabled(true);
  setCurrentLineHighlightColor(new Color(232,242,254));
  setMarkOccurrencesColor(new Color(220,220,220));
  setMatchedBracketBGColor(null);
  setMatchedBracketBorderColor(new Color(192,192,192));
  getActionMap().put(""String_Node_Str"",new RSyntaxTextAreaEditorKit.CopyAsRtfAction());
  Font editorFont=UIManager.getFont(""String_Node_Str"");
  editorFont=new Font(""String_Node_Str"",editorFont.getStyle(),editorFont.getSize());
  SyntaxScheme syntaxScheme=getSyntaxScheme();
  syntaxScheme.setStyle(Token.SEPARATOR,new Style(new Color(200,0,0),null));
  syntaxScheme.setStyle(Token.RESERVED_WORD,new Style(Color.BLUE,null,editorFont));
  setFont(editorFont);
  addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      boolean isControlDown=e.isControlDown();
      boolean isShiftDown=e.isShiftDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_P:
        if (isControlDown && isShiftDown) {
          int position=RSyntaxUtilities.getMatchingBracketPosition(SqlTextArea.this);
          if (position >= 0) {
            setCaretPosition(position + 1);
          }
        }
      break;
case KeyEvent.VK_F:
    if (isControlDown && isShiftDown) {
      formatSelection();
    }
  break;
}
}
}
);
}","public SqlTextArea(){
  setTabSize(2);
  setTabsEmulated(true);
  setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_SQL);
  setMarkOccurrences(true);
  setAnimateBracketMatching(false);
  setAutoIndentEnabled(true);
  setCurrentLineHighlightColor(new Color(232,242,254));
  setMarkOccurrencesColor(new Color(220,220,220));
  setMatchedBracketBGColor(null);
  setMatchedBracketBorderColor(new Color(192,192,192));
  getActionMap().put(""String_Node_Str"",new RSyntaxTextAreaEditorKit.CopyAsRtfAction());
  Font editorFont=UIManager.getFont(""String_Node_Str"");
  editorFont=new Font(""String_Node_Str"",editorFont.getStyle(),editorFont.getSize());
  SyntaxScheme syntaxScheme=getSyntaxScheme();
  syntaxScheme.setStyle(Token.SEPARATOR,new Style(new Color(200,0,0),null));
  syntaxScheme.setStyle(Token.RESERVED_WORD,new Style(Color.BLUE,null,editorFont));
  setFont(editorFont);
  addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      boolean isControlDown=e.isControlDown();
      boolean isShiftDown=e.isShiftDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_P:
        if (isControlDown && isShiftDown) {
          int position=RSyntaxUtilities.getMatchingBracketPosition(SqlTextArea.this,null).y;
          if (position >= 0) {
            setCaretPosition(position + 1);
          }
        }
      break;
case KeyEvent.VK_F:
    if (isControlDown && isShiftDown) {
      formatSelection();
    }
  break;
}
}
}
);
}",0.9969018932874356
150475,"@Override public final Map<String,Object> fetchOneMap(){
  return fetchOne().intoMap();
}","@Override public final Map<String,Object> fetchOneMap(){
  R record=fetchOne();
  return record == null ? null : record.intoMap();
}",0.7692307692307693
150476,"@Override protected final void prepare(ExecuteContext ctx) throws SQLException {
  if (resultSetConcurrency != 0 || resultSetType != 0 || resultSetHoldability != 0) {
    ctx.statement(ctx.connection().prepareStatement(ctx.sql(),resultSetType != 0 ? resultSetType : ResultSet.TYPE_FORWARD_ONLY,resultSetConcurrency != 0 ? resultSetConcurrency : ResultSet.CONCUR_READ_ONLY,resultSetHoldability != 0 ? resultSetHoldability : ctx.connection().getHoldability()));
  }
 else   if (isForUpdate() && asList(CUBRID,SQLSERVER).contains(ctx.configuration().dialect())) {
    ctx.data(DATA_LOCK_ROWS_FOR_UPDATE,true);
    ctx.statement(ctx.connection().prepareStatement(ctx.sql(),TYPE_SCROLL_SENSITIVE,CONCUR_UPDATABLE));
  }
 else {
    ctx.statement(ctx.connection().prepareStatement(ctx.sql()));
  }
  if (size != 0) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"",size);
    ctx.statement().setFetchSize(size);
  }
  if (maxRows != 0) {
    ctx.statement().setMaxRows(maxRows);
  }
}","@Override protected final void prepare(ExecuteContext ctx) throws SQLException {
  if (resultSetConcurrency != 0 || resultSetType != 0 || resultSetHoldability != 0) {
    int type=resultSetType != 0 ? resultSetType : ResultSet.TYPE_FORWARD_ONLY;
    int concurrency=resultSetConcurrency != 0 ? resultSetConcurrency : ResultSet.CONCUR_READ_ONLY;
    if (resultSetHoldability == 0) {
      ctx.statement(ctx.connection().prepareStatement(ctx.sql(),type,concurrency));
    }
 else {
      ctx.statement(ctx.connection().prepareStatement(ctx.sql(),type,concurrency,resultSetHoldability));
    }
  }
 else   if (isForUpdate() && asList(CUBRID,SQLSERVER).contains(ctx.configuration().dialect())) {
    ctx.data(DATA_LOCK_ROWS_FOR_UPDATE,true);
    ctx.statement(ctx.connection().prepareStatement(ctx.sql(),TYPE_SCROLL_SENSITIVE,CONCUR_UPDATABLE));
  }
 else {
    ctx.statement(ctx.connection().prepareStatement(ctx.sql()));
  }
  if (size != 0) {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"",size);
    ctx.statement().setFetchSize(size);
  }
  if (maxRows != 0) {
    ctx.statement().setMaxRows(maxRows);
  }
}",0.8217494089834515
150477,"@BeforeClass public static void start() throws Exception {
  Class.forName(""String_Node_Str"");
  connection=DriverManager.getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  create=new Executor(connection,SQLDialect.H2);
}","@BeforeClass public static void start() throws Exception {
  Class.forName(""String_Node_Str"");
  connection=DriverManager.getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  create=DSL.using(connection,SQLDialect.H2);
}",0.9604989604989606
150478,"@BeforeClass public static void start() throws Exception {
  Class.forName(""String_Node_Str"");
  connection=DriverManager.getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  create=new Executor(connection,SQLDialect.H2);
}","@BeforeClass public static void start() throws Exception {
  Class.forName(""String_Node_Str"");
  connection=DriverManager.getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  create=DSL.using(connection,SQLDialect.H2);
}",0.9604989604989606
150479,"public SqlTextArea(){
  setTabSize(2);
  setTabsEmulated(true);
  setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_SQL);
  setMarkOccurrences(true);
  setAnimateBracketMatching(false);
  setAutoIndentEnabled(true);
  setCurrentLineHighlightColor(new Color(232,242,254));
  setMarkOccurrencesColor(new Color(220,220,220));
  setMatchedBracketBGColor(null);
  setMatchedBracketBorderColor(new Color(192,192,192));
  getActionMap().put(""String_Node_Str"",new RSyntaxTextAreaEditorKit.CopyAsRtfAction());
  Font editorFont=getFont().deriveFont(UIManager.getFont(""String_Node_Str"").getSize2D());
  SyntaxScheme syntaxScheme=getSyntaxScheme();
  syntaxScheme.setStyle(Token.SEPARATOR,new Style(new Color(200,0,0),null));
  syntaxScheme.setStyle(Token.RESERVED_WORD,new Style(Color.BLUE,null,editorFont));
  setFont(new Font(""String_Node_Str"",editorFont.getStyle(),editorFont.getSize()));
  addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      boolean isControlDown=e.isControlDown();
      boolean isShiftDown=e.isShiftDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_P:
        if (isControlDown && isShiftDown) {
          int position=RSyntaxUtilities.getMatchingBracketPosition(SqlTextArea.this);
          if (position >= 0) {
            setCaretPosition(position + 1);
          }
        }
      break;
case KeyEvent.VK_F:
    if (isControlDown && isShiftDown) {
      formatSelection();
    }
  break;
}
}
}
);
}","public SqlTextArea(){
  setTabSize(2);
  setTabsEmulated(true);
  setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_SQL);
  setMarkOccurrences(true);
  setAnimateBracketMatching(false);
  setAutoIndentEnabled(true);
  setCurrentLineHighlightColor(new Color(232,242,254));
  setMarkOccurrencesColor(new Color(220,220,220));
  setMatchedBracketBGColor(null);
  setMatchedBracketBorderColor(new Color(192,192,192));
  getActionMap().put(""String_Node_Str"",new RSyntaxTextAreaEditorKit.CopyAsRtfAction());
  Font editorFont=UIManager.getFont(""String_Node_Str"");
  editorFont=new Font(""String_Node_Str"",editorFont.getStyle(),editorFont.getSize());
  SyntaxScheme syntaxScheme=getSyntaxScheme();
  syntaxScheme.setStyle(Token.SEPARATOR,new Style(new Color(200,0,0),null));
  syntaxScheme.setStyle(Token.RESERVED_WORD,new Style(Color.BLUE,null,editorFont));
  setFont(editorFont);
  addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      boolean isControlDown=e.isControlDown();
      boolean isShiftDown=e.isShiftDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_P:
        if (isControlDown && isShiftDown) {
          int position=RSyntaxUtilities.getMatchingBracketPosition(SqlTextArea.this);
          if (position >= 0) {
            setCaretPosition(position + 1);
          }
        }
      break;
case KeyEvent.VK_F:
    if (isControlDown && isShiftDown) {
      formatSelection();
    }
  break;
}
}
}
);
}",0.9418644650842792
150480,"/** 
 * Get the returning record in those dialects that do not support fetching arbitrary fields from JDBC's   {@link Statement#getGeneratedKeys()} method.
 */
@SuppressWarnings(""String_Node_Str"") private final void selectReturning(Configuration configuration,Object... values){
  if (values != null && values.length > 0) {
    if (into.getIdentity() != null) {
      Field<Number> field=(Field<Number>)into.getIdentity().getField();
      Number[] ids=new Number[values.length];
      for (int i=0; i < values.length; i++) {
        ids[i]=field.getDataType().convert(values[i]);
      }
      if (returning.size() == 1 && returning.get(0).equals(field)) {
        for (        Number id : ids) {
          R typed=Utils.newRecord(into,configuration);
          ((AbstractRecord)typed).setValue(field,new Value<Number>(id));
          getReturnedRecords().add(typed);
        }
      }
 else {
        returned=create(configuration).select(returning).from(into).where(field.in(ids)).fetchInto(into);
      }
    }
  }
}","/** 
 * Get the returning record in those dialects that do not support fetching arbitrary fields from JDBC's   {@link Statement#getGeneratedKeys()} method.
 */
@SuppressWarnings(""String_Node_Str"") private final void selectReturning(Configuration configuration,Object... values){
  if (values != null && values.length > 0) {
    if (into.getIdentity() != null) {
      Field<Number> field=(Field<Number>)into.getIdentity().getField();
      Number[] ids=new Number[values.length];
      for (int i=0; i < values.length; i++) {
        ids[i]=field.getDataType().convert(values[i]);
      }
      if (returning.size() == 1 && returning.get(0).equals(field)) {
        for (        Number id : ids) {
          R typed=Utils.newRecord(into,configuration);
          ((AbstractRecord)typed).setValue(field,new Value<Number>(id));
          getReturnedRecords().add(typed);
        }
      }
 else {
        returned=create(configuration).select(returning).from(into).where(field.in(ids)).fetchInto(into);
      }
    }
 else {
      final Field<Object> idField=field(null);
      final ResultImpl<R> result=new ResultImpl<R>(configuration,idField);
      for (      final Object value : values) {
        final Record record=Utils.newRecord(RecordImpl.class,new Field[]{idField});
        record.setValue(idField,value);
        result.addRecord((R)record);
      }
      returned=result;
    }
  }
}",0.8427152317880795
150481,"public void executeStart(ExecuteContext ctx){
  List<Debugger> debuggerList=DebuggerRegistry.get();
  boolean hasBreakpointHitHandler=false;
  if (!debuggerList.isEmpty()) {
    QueryInfo queryInfo=null;
    bp:     for (    Debugger debugger : debuggerList) {
      Breakpoint[] breakpoints=debugger.getBreakpoints();
      if (breakpoints != null) {
        for (        Breakpoint breakpoint : breakpoints) {
          String sql_=null;
          String parameterDescription=null;
          if (queryInfo == null) {
            String[] sql=ctx.batchSQL();
            QueryType queryType=QueryType.detectType(sql[0]);
            if (sql.length == 1) {
              sql_=sql[0];
              PreparedStatement statement=ctx.statement();
              if (statement instanceof TrackingPreparedStatement) {
                parameterDescription=((TrackingPreparedStatement)statement).getParameterDescription();
              }
            }
 else {
              StringBuilder sb=new StringBuilder();
              for (int i=0; i < sql.length; i++) {
                if (i > 0) {
                  sb.append('\n');
                }
                sb.append(sql[i]);
              }
              sql_=sb.toString();
            }
            queryInfo=new QueryInfo(queryType,sql,parameterDescription);
          }
          if (breakpoint.matches(queryInfo)) {
            matchingSQL=sql_;
            matchingParameterDescription=parameterDescription;
            matchingDebugger=debugger;
            matchingBreakpoint=breakpoint;
            if (breakpoint.isBreaking()) {
              hasBreakpointHitHandler=debugger.getBreakpointHitHandler() != null;
            }
            break bp;
          }
        }
      }
    }
  }
  if (matchingBreakpoint != null) {
    QueryProcessor beforeExecutionProcessor=matchingBreakpoint.getBeforeExecutionProcessor();
    if (beforeExecutionProcessor != null) {
      String sql=beforeExecutionProcessor.processSQL(matchingSQL);
      long subStartExecutionTime=System.currentTimeMillis();
      executeSQL(ctx,sql);
      long subEndExecutionTime=System.currentTimeMillis();
      for (      Debugger debugger : debuggerList) {
        LoggingListener listener=debugger.getLoggingListener();
        if (listener != null) {
          QueryType type=QueryType.detectType(sql);
          QueryInfo info=new QueryInfo(type,new String[]{sql},null);
          QueryLog log=new QueryLog(info,null,null,subEndExecutionTime - subStartExecutionTime);
          QueryMatcher[] matchers=listener.getMatchers();
          if (matchers == null) {
            listener.logQuery(log);
          }
 else {
            for (            QueryMatcher matcher : matchers) {
              if (matcher.matches(log.getQueryInfo())) {
                listener.logQuery(log);
                break;
              }
            }
          }
        }
      }
    }
    String mainSQL=null;
    QueryProcessor replacementExecutionProcessor=matchingBreakpoint.getReplacementExecutionProcessor();
    if (replacementExecutionProcessor != null) {
      mainSQL=replacementExecutionProcessor.processSQL(matchingSQL);
      matchingParameterDescription=null;
      try {
        ctx.statement().close();
        ctx.sql(mainSQL);
        ctx.statement(ctx.connection().prepareStatement(mainSQL));
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
    ExecutionType executionType=ExecutionType.RUN;
    if (hasBreakpointHitHandler) {
      effectiveSQL=mainSQL != null ? mainSQL : matchingSQL;
      Thread currentThread=Thread.currentThread();
      long threadID=currentThread.getId();
      String threadName=currentThread.getName();
      StackTraceElement[] callerStackTraceElements=currentThread.getStackTrace();
      callerStackTraceElements=Arrays.copyOfRange(callerStackTraceElements,2,callerStackTraceElements.length);
      BreakpointHit breakpointHit=new BreakpointHit(matchingBreakpoint.getID(),effectiveSQL,matchingParameterDescription,threadID,threadName,callerStackTraceElements,true);
      matchingDebugger.processBreakpointBeforeExecutionHit(ctx,breakpointHit);
      if (breakpointHit.getBreakpointID() == null) {
        executionType=breakpointHit.getExecutionType();
        String sql=breakpointHit.getSQL();
        if (sql != null) {
          effectiveSQL=sql;
          matchingParameterDescription=null;
          try {
            ctx.statement().close();
            ctx.sql(effectiveSQL);
            ctx.statement(ctx.connection().prepareStatement(effectiveSQL));
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
    if (executionType != ExecutionType.STEP) {
      matchingDebugger=null;
    }
switch (executionType) {
case FAIL:
{
        throw new DataAccessException(""String_Node_Str"");
      }
case SKIP:
{
      try {
        ctx.statement().close();
        String sql=new Executor(ctx.getDialect()).selectZero().where(""String_Node_Str"").getSQL();
        ctx.sql(sql);
        ctx.statement(ctx.connection().prepareStatement(sql));
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
      break;
    }
}
}
if (!hasDebuggers) {
return;
}
startExecutionTime=System.currentTimeMillis();
}","public void executeStart(ExecuteContext ctx){
  List<Debugger> debuggerList=DebuggerRegistry.get();
  boolean hasBreakpointHitHandler=false;
  if (!debuggerList.isEmpty()) {
    QueryInfo queryInfo=null;
    bp:     for (    Debugger debugger : debuggerList) {
      Breakpoint[] breakpoints=debugger.getBreakpoints();
      if (breakpoints != null) {
        for (        Breakpoint breakpoint : breakpoints) {
          String sql_=null;
          String parameterDescription=null;
          if (queryInfo == null) {
            String[] sql=ctx.batchSQL();
            QueryType queryType=QueryType.detectType(sql[0]);
            if (sql.length == 1) {
              sql_=sql[0];
              PreparedStatement statement=ctx.statement();
              if (statement instanceof TrackingPreparedStatement) {
                parameterDescription=((TrackingPreparedStatement)statement).getParameterDescription();
              }
            }
 else {
              StringBuilder sb=new StringBuilder();
              for (int i=0; i < sql.length; i++) {
                if (i > 0) {
                  sb.append('\n');
                }
                sb.append(sql[i]);
              }
              sql_=sb.toString();
            }
            queryInfo=new QueryInfo(queryType,sql,parameterDescription);
          }
          if (breakpoint.matches(queryInfo)) {
            matchingSQL=sql_;
            matchingParameterDescription=parameterDescription;
            matchingDebugger=debugger;
            matchingBreakpoint=breakpoint;
            if (breakpoint.isBreaking()) {
              hasBreakpointHitHandler=debugger.getBreakpointHitHandler() != null;
            }
            break bp;
          }
        }
      }
    }
  }
  if (matchingBreakpoint != null) {
    QueryProcessor beforeExecutionProcessor=matchingBreakpoint.getBeforeExecutionProcessor();
    if (beforeExecutionProcessor != null) {
      String sql=beforeExecutionProcessor.processSQL(matchingSQL);
      long subStartExecutionTime=System.currentTimeMillis();
      executeSQL(ctx,sql);
      long subEndExecutionTime=System.currentTimeMillis();
      for (      Debugger debugger : debuggerList) {
        LoggingListener listener=debugger.getLoggingListener();
        if (listener != null) {
          QueryType type=QueryType.detectType(sql);
          QueryInfo info=new QueryInfo(type,new String[]{sql},null);
          QueryLog log=new QueryLog(info,null,null,subEndExecutionTime - subStartExecutionTime);
          QueryMatcher[] matchers=listener.getMatchers();
          if (matchers == null) {
            listener.logQuery(log);
          }
 else {
            for (            QueryMatcher matcher : matchers) {
              if (matcher.matches(log.getQueryInfo())) {
                listener.logQuery(log);
                break;
              }
            }
          }
        }
      }
    }
    String mainSQL=null;
    QueryProcessor replacementExecutionProcessor=matchingBreakpoint.getReplacementExecutionProcessor();
    if (replacementExecutionProcessor != null) {
      mainSQL=replacementExecutionProcessor.processSQL(matchingSQL);
      matchingParameterDescription=null;
      try {
        ctx.statement().close();
        ctx.sql(mainSQL);
        ctx.statement(ctx.connection().prepareStatement(mainSQL));
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
    ExecutionType executionType=ExecutionType.RUN;
    if (hasBreakpointHitHandler) {
      effectiveSQL=mainSQL != null ? mainSQL : matchingSQL;
      Thread currentThread=Thread.currentThread();
      long threadID=currentThread.getId();
      String threadName=currentThread.getName();
      StackTraceElement[] callerStackTraceElements=currentThread.getStackTrace();
      callerStackTraceElements=Arrays.copyOfRange(callerStackTraceElements,2,callerStackTraceElements.length);
      BreakpointHit breakpointHit=new BreakpointHit(matchingBreakpoint.getID(),effectiveSQL,matchingParameterDescription,threadID,threadName,callerStackTraceElements,true);
      matchingDebugger.processBreakpointBeforeExecutionHit(ctx,breakpointHit);
      if (breakpointHit.getBreakpointID() == null) {
        executionType=breakpointHit.getExecutionType();
        String sql=breakpointHit.getSQL();
        if (sql != null) {
          effectiveSQL=sql;
          matchingParameterDescription=null;
          try {
            ctx.statement().close();
            ctx.sql(effectiveSQL);
            ctx.statement(ctx.connection().prepareStatement(effectiveSQL));
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
    if (executionType != ExecutionType.STEP) {
      matchingDebugger=null;
    }
switch (executionType) {
case FAIL:
{
        throw new DataAccessException(""String_Node_Str"");
      }
case SKIP:
{
      try {
        ctx.statement().close();
        String sql=new Executor(ctx.configuration().getDialect()).selectZero().where(""String_Node_Str"").getSQL();
        ctx.sql(sql);
        ctx.statement(ctx.connection().prepareStatement(sql));
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
      break;
    }
}
}
if (!hasDebuggers) {
return;
}
startExecutionTime=System.currentTimeMillis();
}",0.9984928409947248
150482,"@Override public SQLDialect getSQLDialect(){
  return ctx.getDialect();
}","@Override public SQLDialect getSQLDialect(){
  return ctx.configuration().getDialect();
}",0.9012345679012346
150483,"@Override public LocalStatementExecutor createBreakpointHitStatementExecutor(long threadID){
  final ExecuteContext ctx;
synchronized (threadIDToExecuteContextMap) {
    ctx=threadIDToExecuteContextMap.get(threadID);
    if (ctx == null) {
      return null;
    }
  }
  return new LocalStatementExecutor(new QueryExecutorContext(){
    @Override public boolean isReadOnly(){
      return false;
    }
    @Override public Connection getConnection(){
      return ctx.connection();
    }
    @Override public void releaseConnection(    Connection connection){
    }
    @Override public SQLDialect getSQLDialect(){
      return ctx.getDialect();
    }
    @Override public String[] getTableNames(){
      return LocalDebugger.this.getTableNames();
    }
    @Override public String[] getTableColumnNames(){
      return LocalDebugger.this.getTableColumnNames();
    }
  }
);
}","@Override public LocalStatementExecutor createBreakpointHitStatementExecutor(long threadID){
  final ExecuteContext ctx;
synchronized (threadIDToExecuteContextMap) {
    ctx=threadIDToExecuteContextMap.get(threadID);
    if (ctx == null) {
      return null;
    }
  }
  return new LocalStatementExecutor(new QueryExecutorContext(){
    @Override public boolean isReadOnly(){
      return false;
    }
    @Override public Connection getConnection(){
      return ctx.connection();
    }
    @Override public void releaseConnection(    Connection connection){
    }
    @Override public SQLDialect getSQLDialect(){
      return ctx.configuration().getDialect();
    }
    @Override public String[] getTableNames(){
      return LocalDebugger.this.getTableNames();
    }
    @Override public String[] getTableColumnNames(){
      return LocalDebugger.this.getTableColumnNames();
    }
  }
);
}",0.990950226244344
150484,"/** 
 * Specify a set of field names whose values should be interned. <p> See   {@link Result#intern(int)} for more details.
 * @param fields The field names whose values should be interned
 * @return The same result
 * @see Result#intern(Field)
 * @see String#intern()
 */
Result<R> intern(String... fieldNames);","/** 
 * Specify a set of field names whose values should be interned. <p> See   {@link Result#intern(int)} for more details.
 * @param fieldNames The field names whose values should be interned
 * @return The same result
 * @see Result#intern(Field)
 * @see String#intern()
 */
Result<R> intern(String... fieldNames);",0.9936507936507936
150485,"/** 
 * Specify a set of field names whose values should be interned. <p> Unlike   {@link Result}'s <code>intern()</code> methods, this already interns values right after fetching them from a JDBC result set. See  {@link Result#intern(int)} for more details.
 * @param fields The field names whose values should be interned
 * @return The same result query
 * @see Result#intern(String)
 * @see String#intern()
 */
ResultQuery<R> intern(String... fieldNames);","/** 
 * Specify a set of field names whose values should be interned. <p> Unlike   {@link Result}'s <code>intern()</code> methods, this already interns values right after fetching them from a JDBC result set. See  {@link Result#intern(int)} for more details.
 * @param fieldNames The field names whose values should be interned
 * @return The same result query
 * @see Result#intern(String)
 * @see String#intern()
 */
ResultQuery<R> intern(String... fieldNames);",0.9956616052060736
150486,"/** 
 * <p>Returns padding using the specified delimiter repeated to a given length.</p> <pre> StringUtils.padding(0, 'e')  = """" StringUtils.padding(3, 'e')  = ""eee"" StringUtils.padding(-2, 'e') = IndexOutOfBoundsException </pre> <p>Note: this method doesn't not support padding with <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a> as they require a pair of <code>char</code>s to be represented. If you are needing to support full I18N of your applications consider using   {@link #repeat(String,int)} instead.</p>
 * @param repeat  number of times to repeat delim
 * @param padChar  character to repeat
 * @return String with repeated character
 * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>
 * @see #repeat(String,int)
 */
private static String padding(int repeat,char padChar) throws IndexOutOfBoundsException {
  if (repeat < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + repeat);
  }
  final char[] buf=new char[repeat];
  for (int i=0; i < buf.length; i++) {
    buf[i]=padChar;
  }
  return new String(buf);
}","/** 
 * <p>Returns padding using the specified delimiter repeated to a given length.</p> <pre> StringUtils.padding(0, 'e')  = """" StringUtils.padding(3, 'e')  = ""eee"" StringUtils.padding(-2, 'e') = IndexOutOfBoundsException </pre> <p>Note: this method doesn't not support padding with <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a> as they require a pair of <code>char</code>s to be represented. If you are needing to support full I18N of your applications consider using   {@link #repeat(String,int)} instead.</p>
 * @param repeat  number of times to repeat delim
 * @param padChar  character to repeat
 * @return String with repeated character
 * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>
 */
private static String padding(int repeat,char padChar) throws IndexOutOfBoundsException {
  if (repeat < 0) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + repeat);
  }
  final char[] buf=new char[repeat];
  for (int i=0; i < buf.length; i++) {
    buf[i]=padChar;
  }
  return new String(buf);
}",0.9872379216043756
150487,"private final void init(){
  try {
    Result<Record> columns=executor.fetch(meta().getColumns(null,getSchema().getName(),getName(),""String_Node_Str""));
    for (    Record column : columns) {
      String columnName=column.getValue(""String_Node_Str"",String.class);
      String typeName=column.getValue(""String_Node_Str"",String.class);
      int precision=column.getValue(""String_Node_Str"",int.class);
      int scale=column.getValue(""String_Node_Str"",int.class);
      DataType<?> type=null;
      try {
        type=DefaultDataType.getDataType(executor.getDialect(),typeName,precision,scale);
        if (type.hasPrecision()) {
          type=type.precision(precision);
        }
        if (type.hasScale()) {
          type=type.scale(scale);
        }
        if (type.hasLength()) {
          type=type.length(precision);
        }
      }
 catch (      SQLDialectNotSupportedException e) {
        type=SQLDataType.OTHER;
      }
      createField(columnName,type,this);
    }
  }
 catch (  SQLException e) {
    throw new DataAccessException(""String_Node_Str"",e);
  }
}","private final void init(){
  try {
    String searchName=executor.getDialect() == ORACLE ? getName().replace(""String_Node_Str"",""String_Node_Str"") : getName();
    Result<Record> columns=executor.fetch(meta().getColumns(null,getSchema().getName(),searchName,""String_Node_Str""));
    for (    Record column : columns) {
      String columnName=column.getValue(""String_Node_Str"",String.class);
      String typeName=column.getValue(""String_Node_Str"",String.class);
      int precision=column.getValue(""String_Node_Str"",int.class);
      int scale=column.getValue(""String_Node_Str"",int.class);
      DataType<?> type=null;
      try {
        type=DefaultDataType.getDataType(executor.getDialect(),typeName,precision,scale);
        if (type.hasPrecision()) {
          type=type.precision(precision);
        }
        if (type.hasScale()) {
          type=type.scale(scale);
        }
        if (type.hasLength()) {
          type=type.length(precision);
        }
      }
 catch (      SQLDialectNotSupportedException e) {
        type=SQLDataType.OTHER;
      }
      createField(columnName,type,this);
    }
  }
 catch (  SQLException e) {
    throw new DataAccessException(""String_Node_Str"",e);
  }
}",0.9373081981587024
150488,"protected void execute(String script) throws Exception {
  Statement stmt=null;
  String allSQL=scripts.get(script);
  if (allSQL == null) {
    try {
      log.info(""String_Node_Str"",script);
      File file=new File(getClass().getResource(script).toURI());
      allSQL=FileUtils.readFileToString(file);
      testSQLWatch.splitDebug(""String_Node_Str"");
    }
 catch (    Exception ignore) {
      allSQL=""String_Node_Str"";
    }
    scripts.put(script,allSQL);
  }
  for (  String sql : allSQL.split(""String_Node_Str"")) {
    try {
      if (!StringUtils.isBlank(sql)) {
        sql=sql.replace(""String_Node_Str"" + JDBC_SCHEMA + ""String_Node_Str"",jdbcSchema);
        if (sql.toLowerCase().contains(""String_Node_Str"") && !sql.toLowerCase().contains(""String_Node_Str"")) {
          stmt=getConnectionMultiSchemaUnused().createStatement();
        }
 else         if (sql.toLowerCase().contains(""String_Node_Str"") && !sql.toLowerCase().contains(""String_Node_Str"")) {
          stmt=getConnectionMultiSchema().createStatement();
        }
 else {
          stmt=getConnection().createStatement();
        }
        stmt.execute(sql.trim());
        testSQLWatch.splitDebug(StringUtils.abbreviate(sql.trim().replaceAll(""String_Node_Str"",""String_Node_Str""),25));
      }
    }
 catch (    Exception e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"") && e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"") && e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getClass().getName().startsWith(""String_Node_Str"")) {
        if (""String_Node_Str"".equals(((PSQLException)e).getSQLState())) {
          continue;
        }
      }
 else       if (e.getCause() instanceof org.apache.derby.client.am.SqlException) {
        if (sql.contains(""String_Node_Str"") || sql.contains(""String_Node_Str"")) {
          continue;
        }
      }
 else       if (e.getClass().getName().startsWith(""String_Node_Str"")) {
switch (((SQLServerException)e).getErrorCode()) {
case 3701:
case 218:
          continue;
      }
    }
 else     if (e.getClass().getName().startsWith(""String_Node_Str"")) {
      if (sql.contains(""String_Node_Str"")) {
        continue;
      }
    }
 else     if (e instanceof SQLSyntaxErrorException) {
      if (sql.contains(""String_Node_Str"") || sql.contains(""String_Node_Str"")) {
        continue;
      }
    }
 else     if (e.getMessage().contains(""String_Node_Str"") && getDialect() == SQLDialect.ASE) {
      continue;
    }
 else     if (getDialect() == CUBRID && sql.trim().startsWith(""String_Node_Str"")) {
      continue;
    }
 else     if (getDialect() == FIREBIRD && sql.trim().startsWith(""String_Node_Str"")) {
      continue;
    }
    System.out.println(""String_Node_Str"" + sql.trim());
    System.out.println();
    System.out.println();
    e.printStackTrace();
    System.exit(-1);
  }
 finally {
    if (stmt != null) {
      try {
        stmt.close();
      }
 catch (      SQLException e) {
      }
    }
  }
}
}","protected void execute(String script) throws Exception {
  Statement stmt=null;
  String allSQL=scripts.get(script);
  if (allSQL == null) {
    try {
      log.info(""String_Node_Str"",script);
      File file=new File(getClass().getResource(script).toURI());
      allSQL=FileUtils.readFileToString(file);
      testSQLWatch.splitDebug(""String_Node_Str"");
    }
 catch (    Exception ignore) {
      allSQL=""String_Node_Str"";
    }
    scripts.put(script,allSQL);
  }
  for (  String sql : allSQL.split(""String_Node_Str"")) {
    try {
      if (!StringUtils.isBlank(sql)) {
        sql=sql.replace(""String_Node_Str"" + JDBC_SCHEMA + ""String_Node_Str"",jdbcSchema);
        if (sql.toLowerCase().contains(""String_Node_Str"") && !sql.toLowerCase().contains(""String_Node_Str"")) {
          stmt=getConnectionMultiSchemaUnused().createStatement();
        }
 else         if (sql.toLowerCase().contains(""String_Node_Str"") && !sql.toLowerCase().contains(""String_Node_Str"")) {
          stmt=getConnectionMultiSchema().createStatement();
        }
 else {
          stmt=getConnection().createStatement();
        }
        stmt.execute(sql.trim());
        testSQLWatch.splitDebug(StringUtils.abbreviate(sql.trim().replaceAll(""String_Node_Str"",""String_Node_Str""),25));
      }
    }
 catch (    Exception e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"") && e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getMessage().contains(""String_Node_Str"") && e.getMessage().contains(""String_Node_Str"")) {
        continue;
      }
 else       if (e.getClass().getName().startsWith(""String_Node_Str"")) {
        if (asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").contains(((PSQLException)e).getSQLState())) {
          continue;
        }
      }
 else       if (e.getCause() instanceof org.apache.derby.client.am.SqlException) {
        if (sql.contains(""String_Node_Str"") || sql.contains(""String_Node_Str"")) {
          continue;
        }
      }
 else       if (e.getClass().getName().startsWith(""String_Node_Str"")) {
switch (((SQLServerException)e).getErrorCode()) {
case 3701:
case 218:
          continue;
      }
    }
 else     if (e.getClass().getName().startsWith(""String_Node_Str"")) {
      if (sql.contains(""String_Node_Str"")) {
        continue;
      }
    }
 else     if (e instanceof SQLSyntaxErrorException) {
      if (sql.contains(""String_Node_Str"") || sql.contains(""String_Node_Str"")) {
        continue;
      }
    }
 else     if (e.getMessage().contains(""String_Node_Str"") && getDialect() == SQLDialect.ASE) {
      continue;
    }
 else     if (getDialect() == CUBRID && sql.trim().startsWith(""String_Node_Str"")) {
      continue;
    }
 else     if (getDialect() == FIREBIRD && sql.trim().startsWith(""String_Node_Str"")) {
      continue;
    }
    System.out.println(""String_Node_Str"" + sql.trim());
    System.out.println();
    System.out.println();
    e.printStackTrace();
    System.exit(-1);
  }
 finally {
    if (stmt != null) {
      try {
        stmt.close();
      }
 catch (      SQLException e) {
      }
    }
  }
}
}",0.986939239068711
150489,"public static <T>DataType<T> getDataType(SQLDialect dialect,Class<T> type){
switch (dialect) {
case ASE:
    return ASEDataType.getDataType(type);
case CUBRID:
  return CUBRIDDataType.getDataType(type);
case DB2:
return DB2DataType.getDataType(type);
case DERBY:
return DerbyDataType.getDataType(type);
case H2:
return H2DataType.getDataType(type);
case HSQLDB:
return HSQLDBDataType.getDataType(type);
case INGRES:
return IngresDataType.getDataType(type);
case MYSQL:
return MySQLDataType.getDataType(type);
case ORACLE:
return OracleDataType.getDataType(type);
case POSTGRES:
return PostgresDataType.getDataType(type);
case SQLITE:
return SQLiteDataType.getDataType(type);
case SQLSERVER:
return SQLServerDataType.getDataType(type);
case SYBASE:
return SybaseDataType.getDataType(type);
default :
return SQLDataType.getDataType(null,type);
}
}","public static <T>DataType<T> getDataType(SQLDialect dialect,Class<T> type){
switch (dialect) {
case ASE:
    return ASEDataType.getDataType(type);
case CUBRID:
  return CUBRIDDataType.getDataType(type);
case DB2:
return DB2DataType.getDataType(type);
case DERBY:
return DerbyDataType.getDataType(type);
case FIREBIRD:
return FirebirdDataType.getDataType(type);
case H2:
return H2DataType.getDataType(type);
case HSQLDB:
return HSQLDBDataType.getDataType(type);
case INGRES:
return IngresDataType.getDataType(type);
case MYSQL:
return MySQLDataType.getDataType(type);
case ORACLE:
return OracleDataType.getDataType(type);
case POSTGRES:
return PostgresDataType.getDataType(type);
case SQLITE:
return SQLiteDataType.getDataType(type);
case SQLSERVER:
return SQLServerDataType.getDataType(type);
case SYBASE:
return SybaseDataType.getDataType(type);
default :
return SQLDataType.getDataType(null,type);
}
}",0.9668192219679634
150490,"static String postgresArrayString(Object[] value){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  String separator=""String_Node_Str"";
  for (  Object o : value) {
    sb.append(separator);
    if (o == null) {
      sb.append(o);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(o.toString().replaceAll(""String_Node_Str"",""String_Node_Str""));
      sb.append(""String_Node_Str"");
    }
    separator=""String_Node_Str"";
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","static String postgresArrayString(Object[] value){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  String separator=""String_Node_Str"";
  for (  Object o : value) {
    sb.append(separator);
    if (o == null) {
      sb.append(o);
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(o.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      sb.append(""String_Node_Str"");
    }
    separator=""String_Node_Str"";
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9558011049723756
150491,"public void evaluateInternal(final String sql){
  southPanel.removeAll();
  southPanel.revalidate();
  southPanel.repaint();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      final int maxDisplayedRowCount=((Number)displayedRowCountField.getValue()).intValue();
      Thread evaluationThread=new Thread(""String_Node_Str""){
        @Override public void run(){
          evaluate_unrestricted_nothread(sql,maxDisplayedRowCount);
        }
      }
;
      evaluationThread.start();
    }
  }
);
}","public void evaluateInternal(final String sql){
  southPanel.removeAll();
  southPanel.revalidate();
  southPanel.repaint();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      final int maxDisplayedRowCount=((Number)displayedRowCountField.getValue()).intValue();
      final boolean isUpdatable=isUsingMaxRowCount;
      Thread evaluationThread=new Thread(""String_Node_Str""){
        @Override public void run(){
          evaluate_unrestricted_nothread(sql,maxDisplayedRowCount,isUpdatable);
        }
      }
;
      evaluationThread.start();
    }
  }
);
}",0.9428571428571428
150492,"private void evaluate_unrestricted_nothread(final String sql,final int maxDisplayedRowCount){
  closeLastExecution();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      startButton.setVisible(false);
      stopButton.setVisible(true);
      stopButton.setToolTipText(""String_Node_Str"" + Utils.formatDateTimeTZ(new Date()));
    }
  }
);
  QueryExecutor queryExecutor;
synchronized (STATEMENT_EXECUTOR_CREATOR_LOCK) {
    queryExecutor=queryExecutorCreator.createQueryExecutor();
    lastStatementExecutor=queryExecutor;
  }
  QueryExecution queryExecution;
  try {
    queryExecution=queryExecutor.execute(sql,isUsingMaxRowCount ? MAX_ROW_COUNT : Integer.MAX_VALUE,maxDisplayedRowCount);
  }
  finally {
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        startButton.setVisible(true);
        stopButton.setVisible(false);
        stopButton.setToolTipText(null);
      }
    }
);
  }
  final QueryExecutionResult[] results=queryExecution.getResults();
  final long executionDuration=queryExecution.getExecutionDuration();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      for (      QueryExecutionResult result : results) {
        if (result instanceof QueryExecutionMessageResult) {
          QueryExecutionMessageResult messageResult=(QueryExecutionMessageResult)result;
          setMessage(addResultPane(),messageResult.getMessage(),messageResult.isError());
        }
 else         if (result instanceof StatementExecutionResultSetResult) {
          addResultTable(sql,executionDuration,(StatementExecutionResultSetResult)result);
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + result.getClass().getName());
        }
      }
    }
  }
);
}","private void evaluate_unrestricted_nothread(final String sql,final int maxDisplayedRowCount,boolean isUpdatable){
  closeLastExecution();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      startButton.setVisible(false);
      stopButton.setVisible(true);
      stopButton.setToolTipText(""String_Node_Str"" + Utils.formatDateTimeTZ(new Date()));
    }
  }
);
  QueryExecutor queryExecutor;
synchronized (STATEMENT_EXECUTOR_CREATOR_LOCK) {
    queryExecutor=queryExecutorCreator.createQueryExecutor();
    lastStatementExecutor=queryExecutor;
  }
  QueryExecution queryExecution;
  try {
    queryExecution=queryExecutor.execute(sql,isUsingMaxRowCount ? MAX_ROW_COUNT : Integer.MAX_VALUE,maxDisplayedRowCount,isUpdatable);
  }
  finally {
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        startButton.setVisible(true);
        stopButton.setVisible(false);
        stopButton.setToolTipText(null);
      }
    }
);
  }
  final QueryExecutionResult[] results=queryExecution.getResults();
  final long executionDuration=queryExecution.getExecutionDuration();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      for (      QueryExecutionResult result : results) {
        if (result instanceof QueryExecutionMessageResult) {
          QueryExecutionMessageResult messageResult=(QueryExecutionMessageResult)result;
          setMessage(addResultPane(),messageResult.getMessage(),messageResult.isError());
        }
 else         if (result instanceof StatementExecutionResultSetResult) {
          addResultTable(sql,executionDuration,(StatementExecutionResultSetResult)result);
        }
 else {
          throw new IllegalStateException(""String_Node_Str"" + result.getClass().getName());
        }
      }
    }
  }
);
}",0.9911259012756516
150493,"@Override public void keyPressed(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
case KeyEvent.VK_ESCAPE:
    return;
case KeyEvent.VK_ENTER:
  editorTextArea.replaceRange(((CompletionCandidate)jList.getSelectedValue()).toString(),getWordStart(),editorTextArea.getCaretPosition());
w.setVisible(false);
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}","@Override public void keyPressed(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
    return;
case KeyEvent.VK_ESCAPE:
  w.setVisible(false);
return;
case KeyEvent.VK_ENTER:
editorTextArea.replaceRange(((CompletionCandidate)jList.getSelectedValue()).toString(),getWordStart(),editorTextArea.getCaretPosition());
w.setVisible(false);
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}",0.9756418696510862
150494,"private void showCompletion(){
  try {
    int caretPosition=editorTextArea.getCaretPosition();
    int wordStart=getWordStart();
    CompletionCandidate[] words=getFilteredWords(wordStart,editorTextArea.getText(wordStart,caretPosition - wordStart));
    if (words.length == 0) {
      return;
    }
    final JPopupMenu w=new JPopupMenu();
    final JList jList=new JList(words);
    jList.setCellRenderer(new DefaultListCellRenderer(){
      private ImageIcon tableIcon=new ImageIcon(getClass().getResource(""String_Node_Str""));
      private ImageIcon tableColumnIcon=new ImageIcon(getClass().getResource(""String_Node_Str""));
      private ImageIcon sqlIcon=new ImageIcon(getClass().getResource(""String_Node_Str""));
      @Override public Component getListCellRendererComponent(      JList list,      Object value,      int index,      boolean isSelected,      boolean cellHasFocus){
        Component c=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
        if (c instanceof JLabel) {
          Icon icon;
switch (((CompletionCandidate)value).getKeyWordType()) {
case TABLE:
            icon=tableIcon;
          break;
case TABLE_COlUMN:
        icon=tableColumnIcon;
      break;
default :
    icon=sqlIcon;
  break;
}
((JLabel)c).setIcon(icon);
}
return c;
}
}
);
jList.setSelectedIndex(0);
jList.addKeyListener(new KeyAdapter(){
@Override public void keyPressed(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
case KeyEvent.VK_ESCAPE:
return;
case KeyEvent.VK_ENTER:
editorTextArea.replaceRange(((CompletionCandidate)jList.getSelectedValue()).toString(),getWordStart(),editorTextArea.getCaretPosition());
w.setVisible(false);
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}
@Override public void keyReleased(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
case KeyEvent.VK_ESCAPE:
case KeyEvent.VK_ENTER:
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}
@Override public void keyTyped(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
case KeyEvent.VK_ESCAPE:
case KeyEvent.VK_ENTER:
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}
private void adjustListContent(){
try {
int wordStart=getWordStart();
CompletionCandidate[] words=getFilteredWords(wordStart,editorTextArea.getText(wordStart,editorTextArea.getCaretPosition() - wordStart));
if (words.length == 0) {
w.setVisible(false);
return;
}
jList.setListData(words);
jList.setSelectedIndex(0);
}
 catch (BadLocationException e) {
e.printStackTrace();
}
}
}
);
jList.addMouseListener(new MouseAdapter(){
@Override public void mousePressed(MouseEvent e){
if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 2) {
editorTextArea.replaceRange(((CompletionCandidate)jList.getSelectedValue()).toString(),getWordStart(),editorTextArea.getCaretPosition());
w.setVisible(false);
}
}
}
);
w.add(new JScrollPane(jList),BorderLayout.CENTER);
w.setPreferredSize(new Dimension(200,200));
Rectangle position=editorTextArea.modelToView(caretPosition);
w.show(editorTextArea,position.x + position.width,position.y + position.height);
jList.requestFocus();
}
 catch (BadLocationException e) {
e.printStackTrace();
}
}","private void showCompletion(){
  try {
    int caretPosition=editorTextArea.getCaretPosition();
    int wordStart=getWordStart();
    CompletionCandidate[] words=getFilteredWords(wordStart,editorTextArea.getText(wordStart,caretPosition - wordStart));
    if (words.length == 0) {
      return;
    }
    final JPopupMenu w=new JPopupMenu();
    final JList jList=new JList(words);
    jList.setCellRenderer(new DefaultListCellRenderer(){
      private ImageIcon tableIcon=new ImageIcon(getClass().getResource(""String_Node_Str""));
      private ImageIcon tableColumnIcon=new ImageIcon(getClass().getResource(""String_Node_Str""));
      private ImageIcon sqlIcon=new ImageIcon(getClass().getResource(""String_Node_Str""));
      @Override public Component getListCellRendererComponent(      JList list,      Object value,      int index,      boolean isSelected,      boolean cellHasFocus){
        Component c=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
        if (c instanceof JLabel) {
          Icon icon;
switch (((CompletionCandidate)value).getKeyWordType()) {
case TABLE:
            icon=tableIcon;
          break;
case TABLE_COlUMN:
        icon=tableColumnIcon;
      break;
default :
    icon=sqlIcon;
  break;
}
((JLabel)c).setIcon(icon);
}
return c;
}
}
);
jList.setSelectedIndex(0);
jList.addKeyListener(new KeyAdapter(){
@Override public void keyPressed(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
return;
case KeyEvent.VK_ESCAPE:
w.setVisible(false);
return;
case KeyEvent.VK_ENTER:
editorTextArea.replaceRange(((CompletionCandidate)jList.getSelectedValue()).toString(),getWordStart(),editorTextArea.getCaretPosition());
w.setVisible(false);
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}
@Override public void keyReleased(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
case KeyEvent.VK_ESCAPE:
case KeyEvent.VK_ENTER:
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}
@Override public void keyTyped(KeyEvent e){
switch (e.getKeyCode()) {
case KeyEvent.VK_PAGE_UP:
case KeyEvent.VK_PAGE_DOWN:
case KeyEvent.VK_UP:
case KeyEvent.VK_DOWN:
case KeyEvent.VK_HOME:
case KeyEvent.VK_END:
case KeyEvent.VK_ESCAPE:
case KeyEvent.VK_ENTER:
return;
}
editorTextArea.dispatchEvent(new KeyEvent(editorTextArea,e.getID(),e.getWhen(),e.getModifiers(),e.getKeyCode(),e.getKeyChar(),e.getKeyLocation()));
if (e.getKeyChar() != KeyEvent.CHAR_UNDEFINED || e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_RIGHT) {
adjustListContent();
}
}
private void adjustListContent(){
try {
int wordStart=getWordStart();
CompletionCandidate[] words=getFilteredWords(wordStart,editorTextArea.getText(wordStart,editorTextArea.getCaretPosition() - wordStart));
if (words.length == 0) {
w.setVisible(false);
return;
}
jList.setListData(words);
jList.setSelectedIndex(0);
}
 catch (BadLocationException e) {
e.printStackTrace();
}
}
}
);
jList.addMouseListener(new MouseAdapter(){
@Override public void mousePressed(MouseEvent e){
if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 2) {
editorTextArea.replaceRange(((CompletionCandidate)jList.getSelectedValue()).toString(),getWordStart(),editorTextArea.getCaretPosition());
w.setVisible(false);
}
}
}
);
w.add(new JScrollPane(jList),BorderLayout.CENTER);
w.setPreferredSize(new Dimension(200,200));
Rectangle position=editorTextArea.modelToView(caretPosition);
w.show(editorTextArea,position.x + position.width,position.y + position.height);
jList.requestFocus();
}
 catch (BadLocationException e) {
e.printStackTrace();
}
}",0.99662673025474
150495,"public QueryExecution execute(String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold);","public QueryExecution execute(String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold,boolean isUpdatable);",0.911504424778761
150496,"@Override public QueryExecution execute(String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold){
  return debugger.getCommunicationInterface().syncSend(new CMS_doStatementExecutorExecution(id,sql,maxRSRowsParsing,retainParsedRSDataRowCountThreshold));
}","@Override public QueryExecution execute(String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold,boolean isUpdatable){
  return debugger.getCommunicationInterface().syncSend(new CMS_doStatementExecutorExecution(id,sql,maxRSRowsParsing,retainParsedRSDataRowCountThreshold,isUpdatable));
}",0.944055944055944
150497,"@Override public QueryExecution execute(String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold){
  boolean isAllowed=true;
  if (executorContext.isReadOnly()) {
    String simplifiedSql=sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
switch (QueryType.detectType(simplifiedSql)) {
case SELECT:
      String[] forbiddenWords=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(simplifiedSql);
  while (matcher.find()) {
    String word=simplifiedSql.substring(matcher.start(),matcher.end()).toUpperCase(Locale.ENGLISH);
    for (    String keyword : forbiddenWords) {
      if (word.equals(keyword)) {
        isAllowed=false;
        break;
      }
    }
  }
break;
default :
isAllowed=false;
break;
}
}
if (!isAllowed) {
return new QueryExecution(0,new QueryExecutionMessageResult(""String_Node_Str"",true));
}
stopExecution();
evaluationThread=Thread.currentThread();
long start=System.currentTimeMillis();
try {
conn=executorContext.getConnection();
stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);
start=System.currentTimeMillis();
if (evaluationThread != Thread.currentThread()) {
long executionDuration=System.currentTimeMillis() - start;
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
boolean executeResult;
try {
executeResult=stmt.execute(sql);
}
 catch (SQLException e) {
long executionDuration=System.currentTimeMillis() - start;
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(e));
}
final long executionDuration=System.currentTimeMillis() - start;
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
List<QueryExecutionResult> statementExecutionResultList=new ArrayList<QueryExecutionResult>();
do {
QueryExecutionResult queryExecutionResult;
if (executeResult) {
final ResultSet rs=stmt.getResultSet();
ResultSetMetaData metaData=rs.getMetaData();
final String[] columnNames=new String[metaData.getColumnCount()];
final int[] columnTypes=new int[columnNames.length];
final TypeInfo[] typeInfos=new TypeInfo[columnNames.length];
final Class<?>[] columnClasses=new Class[columnNames.length];
for (int i=0; i < columnNames.length; i++) {
columnNames[i]=metaData.getColumnName(i + 1);
if (columnNames[i] == null || columnNames[i].length() == 0) {
columnNames[i]=""String_Node_Str"";
}
typeInfos[i]=new TypeInfo(metaData,i);
int type=metaData.getColumnType(i + 1);
columnTypes[i]=type;
switch (type) {
case Types.CLOB:
columnClasses[i]=String.class;
break;
case Types.BLOB:
columnClasses[i]=byte[].class;
break;
default :
String columnClassName=metaData.getColumnClassName(i + 1);
if (columnClassName == null) {
System.err.println(""String_Node_Str"" + columnNames[i] + ""String_Node_Str""+ getClass().getSimpleName()+ ""String_Node_Str""+ metaData.getColumnTypeName(i));
columnClasses[i]=Object.class;
}
 else {
if (columnClassName.indexOf('.') == -1) {
boolean isArray;
if (columnClassName.endsWith(""String_Node_Str"")) {
columnClassName=columnClassName.substring(0,columnClassName.length() - 2);
isArray=true;
}
 else {
isArray=false;
}
if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=boolean.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=byte.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=char.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=short.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=int.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=long.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=float.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=double.class;
}
 else {
isArray=false;
columnClasses[i]=Class.forName(columnClassName);
}
if (isArray) {
columnClasses[i]=Array.newInstance(columnClasses[i],0).getClass();
}
}
 else {
columnClasses[i]=Class.forName(columnClassName);
}
}
break;
}
}
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
final List<Object[]> rowDataList=new ArrayList<Object[]>();
int rowCount=0;
long rsStart=System.currentTimeMillis();
while (rs.next() && rowCount < maxRSRowsParsing) {
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
rowCount++;
Object[] rowData=new Object[columnNames.length];
for (int i=0; i < columnNames.length; i++) {
switch (columnTypes[i]) {
case Types.CLOB:
{
Clob clob=rs.getClob(i + 1);
if (clob != null) {
StringWriter stringWriter=new StringWriter();
char[] chars=new char[1024];
Reader reader=new BufferedReader(clob.getCharacterStream());
for (int count; (count=reader.read(chars)) >= 0; ) {
stringWriter.write(chars,0,count);
}
rowData[i]=stringWriter.toString();
}
 else {
rowData[i]=null;
}
break;
}
case Types.BLOB:
{
Blob blob=rs.getBlob(i + 1);
if (blob != null) {
ByteArrayOutputStream baos=new ByteArrayOutputStream();
byte[] bytes=new byte[1024];
InputStream in=new BufferedInputStream(blob.getBinaryStream());
for (int count; (count=in.read(bytes)) >= 0; ) {
baos.write(bytes,0,count);
}
rowData[i]=baos.toByteArray();
}
 else {
rowData[i]=null;
}
break;
}
default :
Object object=rs.getObject(i + 1);
if (object != null) {
String className=object.getClass().getName();
if (""String_Node_Str"".equals(className) || ""String_Node_Str"".equals(className)) {
object=rs.getTimestamp(i + 1);
}
}
rowData[i]=object;
break;
}
}
if (rowCount <= retainParsedRSDataRowCountThreshold) {
rowDataList.add(rowData);
}
 else if (rowCount == retainParsedRSDataRowCountThreshold + 1) {
rowDataList.clear();
}
}
final long resultSetParsingDuration=System.currentTimeMillis() - rsStart;
queryExecutionResult=new LocalStatementExecutionResultSetResult(rs,columnNames,typeInfos,columnClasses,rowDataList.toArray(new Object[0][]),rowCount,resultSetParsingDuration,retainParsedRSDataRowCountThreshold,executorContext.isReadOnly());
}
 else {
final int updateCount=stmt.getUpdateCount();
queryExecutionResult=new QueryExecutionMessageResult(Utils.formatDuration(executionDuration) + ""String_Node_Str"" + updateCount+ ""String_Node_Str"",false);
}
if (executorContext.getSQLDialect() == SQLDialect.SQLSERVER) {
try {
executeResult=stmt.getMoreResults(Statement.KEEP_CURRENT_RESULT);
}
 catch (Exception e) {
executeResult=stmt.getMoreResults();
}
}
 else {
executeResult=false;
}
statementExecutionResultList.add(queryExecutionResult);
}
 while (executeResult || stmt.getUpdateCount() != -1);
return new QueryExecution(executionDuration,statementExecutionResultList.toArray(new QueryExecutionResult[0]));
}
 catch (Exception e) {
long executionDuration=System.currentTimeMillis() - start;
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(e));
}
 finally {
if (executorContext.isReadOnly()) {
closeConnection();
}
}
}","@Override public QueryExecution execute(String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold,boolean isUpdatable){
  boolean isReadOnly=executorContext.isReadOnly();
  isUpdatable=!isReadOnly && isUpdatable;
  boolean isAllowed=true;
  if (isReadOnly) {
    String simplifiedSql=sql.replaceAll(""String_Node_Str"",""String_Node_Str"");
switch (QueryType.detectType(simplifiedSql)) {
case SELECT:
      String[] forbiddenWords=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    Matcher matcher=Pattern.compile(""String_Node_Str"").matcher(simplifiedSql);
  while (matcher.find()) {
    String word=simplifiedSql.substring(matcher.start(),matcher.end()).toUpperCase(Locale.ENGLISH);
    for (    String keyword : forbiddenWords) {
      if (word.equals(keyword)) {
        isAllowed=false;
        break;
      }
    }
  }
break;
default :
isAllowed=false;
break;
}
}
if (!isAllowed) {
return new QueryExecution(0,new QueryExecutionMessageResult(""String_Node_Str"",true));
}
stopExecution();
evaluationThread=Thread.currentThread();
long start=System.currentTimeMillis();
try {
conn=executorContext.getConnection();
if (isUpdatable) {
stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);
}
 else {
stmt=conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);
}
start=System.currentTimeMillis();
if (evaluationThread != Thread.currentThread()) {
long executionDuration=System.currentTimeMillis() - start;
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
boolean executeResult;
try {
executeResult=stmt.execute(sql);
}
 catch (SQLException e) {
long executionDuration=System.currentTimeMillis() - start;
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(e));
}
final long executionDuration=System.currentTimeMillis() - start;
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
List<QueryExecutionResult> statementExecutionResultList=new ArrayList<QueryExecutionResult>();
do {
QueryExecutionResult queryExecutionResult;
if (executeResult) {
final ResultSet rs=stmt.getResultSet();
ResultSetMetaData metaData=rs.getMetaData();
final String[] columnNames=new String[metaData.getColumnCount()];
final int[] columnTypes=new int[columnNames.length];
final TypeInfo[] typeInfos=new TypeInfo[columnNames.length];
final Class<?>[] columnClasses=new Class[columnNames.length];
for (int i=0; i < columnNames.length; i++) {
columnNames[i]=metaData.getColumnName(i + 1);
if (columnNames[i] == null || columnNames[i].length() == 0) {
columnNames[i]=""String_Node_Str"";
}
typeInfos[i]=new TypeInfo(metaData,i);
int type=metaData.getColumnType(i + 1);
columnTypes[i]=type;
switch (type) {
case Types.CLOB:
columnClasses[i]=String.class;
break;
case Types.BLOB:
columnClasses[i]=byte[].class;
break;
default :
String columnClassName=metaData.getColumnClassName(i + 1);
if (columnClassName == null) {
System.err.println(""String_Node_Str"" + columnNames[i] + ""String_Node_Str""+ getClass().getSimpleName()+ ""String_Node_Str""+ metaData.getColumnTypeName(i));
columnClasses[i]=Object.class;
}
 else {
if (columnClassName.indexOf('.') == -1) {
boolean isArray;
if (columnClassName.endsWith(""String_Node_Str"")) {
columnClassName=columnClassName.substring(0,columnClassName.length() - 2);
isArray=true;
}
 else {
isArray=false;
}
if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=boolean.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=byte.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=char.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=short.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=int.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=long.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=float.class;
}
 else if (""String_Node_Str"".equals(columnClassName)) {
columnClasses[i]=double.class;
}
 else {
isArray=false;
columnClasses[i]=Class.forName(columnClassName);
}
if (isArray) {
columnClasses[i]=Array.newInstance(columnClasses[i],0).getClass();
}
}
 else {
columnClasses[i]=Class.forName(columnClassName);
}
}
break;
}
}
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
final List<Object[]> rowDataList=new ArrayList<Object[]>();
int rowCount=0;
long rsStart=System.currentTimeMillis();
while (rs.next() && rowCount < maxRSRowsParsing) {
if (evaluationThread != Thread.currentThread()) {
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(""String_Node_Str"" + Utils.formatDuration(executionDuration),true));
}
rowCount++;
Object[] rowData=new Object[columnNames.length];
for (int i=0; i < columnNames.length; i++) {
switch (columnTypes[i]) {
case Types.CLOB:
{
Clob clob=rs.getClob(i + 1);
if (clob != null) {
StringWriter stringWriter=new StringWriter();
char[] chars=new char[1024];
Reader reader=new BufferedReader(clob.getCharacterStream());
for (int count; (count=reader.read(chars)) >= 0; ) {
stringWriter.write(chars,0,count);
}
rowData[i]=stringWriter.toString();
}
 else {
rowData[i]=null;
}
break;
}
case Types.BLOB:
{
Blob blob=rs.getBlob(i + 1);
if (blob != null) {
ByteArrayOutputStream baos=new ByteArrayOutputStream();
byte[] bytes=new byte[1024];
InputStream in=new BufferedInputStream(blob.getBinaryStream());
for (int count; (count=in.read(bytes)) >= 0; ) {
baos.write(bytes,0,count);
}
rowData[i]=baos.toByteArray();
}
 else {
rowData[i]=null;
}
break;
}
default :
Object object=rs.getObject(i + 1);
if (object != null) {
String className=object.getClass().getName();
if (""String_Node_Str"".equals(className) || ""String_Node_Str"".equals(className)) {
object=rs.getTimestamp(i + 1);
}
}
rowData[i]=object;
break;
}
}
if (rowCount <= retainParsedRSDataRowCountThreshold) {
rowDataList.add(rowData);
}
 else if (rowCount == retainParsedRSDataRowCountThreshold + 1) {
rowDataList.clear();
}
}
final long resultSetParsingDuration=System.currentTimeMillis() - rsStart;
queryExecutionResult=new LocalStatementExecutionResultSetResult(rs,columnNames,typeInfos,columnClasses,rowDataList.toArray(new Object[0][]),rowCount,resultSetParsingDuration,retainParsedRSDataRowCountThreshold,isReadOnly);
}
 else {
final int updateCount=stmt.getUpdateCount();
queryExecutionResult=new QueryExecutionMessageResult(Utils.formatDuration(executionDuration) + ""String_Node_Str"" + updateCount+ ""String_Node_Str"",false);
}
if (executorContext.getSQLDialect() == SQLDialect.SQLSERVER) {
try {
executeResult=stmt.getMoreResults(Statement.KEEP_CURRENT_RESULT);
}
 catch (Exception e) {
executeResult=stmt.getMoreResults();
}
}
 else {
executeResult=false;
}
statementExecutionResultList.add(queryExecutionResult);
}
 while (executeResult || stmt.getUpdateCount() != -1);
return new QueryExecution(executionDuration,statementExecutionResultList.toArray(new QueryExecutionResult[0]));
}
 catch (Exception e) {
long executionDuration=System.currentTimeMillis() - start;
return new QueryExecution(executionDuration,new QueryExecutionMessageResult(e));
}
 finally {
if (isReadOnly) {
closeConnection();
}
}
}",0.9817993393354492
150498,"CMS_doStatementExecutorExecution(int id,String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold){
  this.id=id;
  this.sql=sql;
  this.maxRSRowsParsing=maxRSRowsParsing;
  this.retainParsedRSDataRowCountThreshold=retainParsedRSDataRowCountThreshold;
}","CMS_doStatementExecutorExecution(int id,String sql,int maxRSRowsParsing,int retainParsedRSDataRowCountThreshold,boolean isUpdatable){
  this.id=id;
  this.sql=sql;
  this.maxRSRowsParsing=maxRSRowsParsing;
  this.retainParsedRSDataRowCountThreshold=retainParsedRSDataRowCountThreshold;
  this.isUpdatable=isUpdatable;
}",0.9112627986348124
150499,"/** 
 * Convert this record into an array of a given component type.
 */
@SuppressWarnings(""String_Node_Str"") private final <T>T intoArray(Object[] result,Class<?> componentType){
  int size=getFields().size();
  if (size > result.length) {
    result=(Object[])Array.newInstance(componentType,size);
  }
  for (int i=0; i < size; i++) {
    result[i]=Convert.convert(getValue(i),componentType);
  }
  return (T)result;
}","/** 
 * Convert this record into an array of a given component type.
 */
private final Object[] intoArray(Object[] result,Class<?> componentType){
  int size=getFields().size();
  if (size > result.length) {
    result=(Object[])Array.newInstance(componentType,size);
  }
  for (int i=0; i < size; i++) {
    result[i]=Convert.convert(getValue(i),componentType);
  }
  return result;
}",0.9081885856079404
150500,"@Override public final Object getObject(String columnLabel,Map<String,Class<?>> map) throws SQLException {
  return ctx.resultSet().getObject(columnLabel,map);
}","@Override public <T>T getObject(String columnLabel,Class<T> type) throws SQLException {
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.6089743589743589
150501,"@Test public void testPlainSQLWithQueryParts() throws Exception {
  String sql=""String_Node_Str"";
  QueryPart[] parts={val(1),name(TAuthor_ID().getName()),name(TAuthor().getName()),name(TAuthor_ID().getName()),inline(1)};
  Record author=create().select(val(1),TAuthor_ID()).from(TAuthor()).where(TAuthor_ID().equal(1)).fetchOne();
  Record record=create().fetchOne(sql,parts);
  Result<Record> result=create().fetch(sql,parts);
  Cursor<Record> cursor=create().fetchLazy(sql,parts);
  List<Result<Record>> many=create().fetchMany(sql,parts);
  assertEquals(author,record);
  assertEquals(author,result.get(0));
  assertEquals(author,cursor.fetchOne());
  assertEquals(author,many.get(0).get(0));
}","@Test public void testPlainSQLWithQueryParts() throws Exception {
  String sql=""String_Node_Str"";
  QueryPart[] parts={val(""String_Node_Str""),name(TAuthor_LAST_NAME().getName()),name(TAuthor().getName()),name(TAuthor_ID().getName()),inline(1)};
  Record author=create().select(val(""String_Node_Str""),TAuthor_LAST_NAME()).from(TAuthor()).where(TAuthor_ID().equal(1)).fetchOne();
  Record record=create().fetchOne(sql,parts);
  Result<Record> result=create().fetch(sql,parts);
  Cursor<Record> cursor=create().fetchLazy(sql,parts);
  assertEquals(author,record);
  assertEquals(author,result.get(0));
  assertEquals(author,cursor.fetchOne());
}",0.5388059701492537
150502,"public StatementProcessorPane(StatementProcessor statementProcessor){
  super(new GridBagLayout());
  setOpaque(false);
  if (statementProcessor == null) {
    statementProcessor=new StatementProcessor(StatementProcessor.ProcessorExecutionType.STATIC,""String_Node_Str"");
  }
  processorTypeComboBox=new JComboBox(StatementProcessor.ProcessorExecutionType.values());
  processorTypeComboBox.setSelectedItem(statementProcessor.getType());
  processorTypeComboBox.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      adjustStates();
    }
  }
);
  add(processorTypeComboBox,new GridBagConstraints(0,0,1,1,0,0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
  boolean isStatic=statementProcessor.getType() == StatementProcessor.ProcessorExecutionType.STATIC;
  processorTextField=new JTextField(isStatic ? ""String_Node_Str"" : statementProcessor.getText(),14);
  add(processorTextField,new GridBagConstraints(1,0,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,5,0,0),0,0));
  SqlTextArea processorStaticSQLTextArea=new SqlTextArea();
  if (isStatic) {
    processorStaticSQLTextArea.setText(statementProcessor.getText());
    processorStaticSQLTextArea.setCaretPosition(0);
  }
  processorStaticScrollPane=new JScrollPane(processorStaticSQLTextArea);
  processorStaticScrollPane.setPreferredSize(new Dimension(100,100));
  add(processorStaticScrollPane,new GridBagConstraints(1,0,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,5,0,0),0,0));
  adjustStates();
}","public StatementProcessorPane(StatementProcessor statementProcessor){
  super(new GridBagLayout());
  setOpaque(false);
  if (statementProcessor == null) {
    statementProcessor=new StatementProcessor(StatementProcessor.ProcessorExecutionType.STATIC,""String_Node_Str"");
  }
  processorTypeComboBox=new JComboBox(StatementProcessor.ProcessorExecutionType.values());
  processorTypeComboBox.setSelectedItem(statementProcessor.getType());
  processorTypeComboBox.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      adjustStates();
    }
  }
);
  add(processorTypeComboBox,new GridBagConstraints(0,0,1,1,0,0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
  boolean isStatic=statementProcessor.getType() == StatementProcessor.ProcessorExecutionType.STATIC;
  processorTextField=new JTextField(isStatic ? ""String_Node_Str"" : statementProcessor.getText(),14);
  add(processorTextField,new GridBagConstraints(1,0,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,5,0,0),0,0));
  processorStaticSQLTextArea=new SqlTextArea();
  if (isStatic) {
    processorStaticSQLTextArea.setText(statementProcessor.getText());
    processorStaticSQLTextArea.setCaretPosition(0);
  }
  processorStaticScrollPane=new JScrollPane(processorStaticSQLTextArea);
  processorStaticScrollPane.setPreferredSize(new Dimension(100,100));
  add(processorStaticScrollPane,new GridBagConstraints(1,0,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,5,0,0),0,0));
  adjustStates();
}",0.9962335216572504
150503,"public StatementProcessor getStatementProcessor(){
  return new StatementProcessor((StatementProcessor.ProcessorExecutionType)processorTypeComboBox.getSelectedItem(),processorTextField.getText());
}","public StatementProcessor getStatementProcessor(){
  StatementProcessor.ProcessorExecutionType type=(StatementProcessor.ProcessorExecutionType)processorTypeComboBox.getSelectedItem();
  return new StatementProcessor(type,type == StatementProcessor.ProcessorExecutionType.STATIC ? processorStaticSQLTextArea.getText() : processorTextField.getText());
}",0.6120218579234973
150504,"public final Connection getConnection(){
  if (!connectionInitialised) {
    connectionInitialised=true;
    connection=getConnection0(null,null);
    boolean runConsoleInProcess=false;
    if (runConsoleInProcess) {
      try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        Debugger debugger=new ClientDebugger(""String_Node_Str"",DEBUGGER_PORT);
        Console console=new Console(debugger,true);
        console.setLoggingActive(true);
        console.setVisible(true);
      }
 catch (      Exception ignore) {
      }
    }
  }
  return connection;
}","public final Connection getConnection(){
  if (!connectionInitialised) {
    connectionInitialised=true;
    connection=getConnection0(null,null);
    boolean runConsoleInProcess=false;
    if (runConsoleInProcess) {
      try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        Debugger debugger=new ClientDebugger(""String_Node_Str"",DEBUGGER_PORT);
        Console console=new Console(debugger,true,true);
        console.setLoggingActive(true);
        console.setVisible(true);
      }
 catch (      Exception ignore) {
      }
    }
  }
  return connection;
}",0.9958018471872376
150505,"public Object syncSend(Message message){
  Thread thread=Thread.currentThread();
  long threadID=thread.getId();
  ThreadInfo threadInfo=new ThreadInfo();
  boolean isAdded;
synchronized (idToThreadInfo) {
    isAdded=idToThreadInfo.put(threadID,threadInfo) != null;
  }
  CM_asyncExec asyncExec=new CM_asyncExec();
  asyncExec.setArgs(threadID,message);
  asyncSend(asyncExec);
  CommandResultMessage commandResultMessage=null;
synchronized (threadInfo) {
    while (commandResultMessage == null) {
      while (!threadInfo.isValuePresent()) {
        try {
          threadInfo.wait();
        }
 catch (        Exception e) {
        }
        if (!isAlive()) {
          idToThreadInfo.remove(threadID);
          printFailedInvocation(message);
          return null;
        }
      }
      Message value=threadInfo.getMessage();
      if (value instanceof CommandResultMessage) {
        commandResultMessage=(CommandResultMessage)value;
      }
 else {
        commandResultMessage=runMessage(value);
      }
    }
  }
  if (isAdded) {
synchronized (idToThreadInfo) {
      idToThreadInfo.remove(threadID);
    }
  }
  return processCommandResult(commandResultMessage);
}","public Object syncSend(Message message){
  Thread thread=Thread.currentThread();
  long threadID=thread.getId();
  ThreadInfo threadInfo=new ThreadInfo();
  boolean isAdded;
synchronized (idToThreadInfo) {
    isAdded=idToThreadInfo.put(threadID,threadInfo) == null;
  }
  CM_asyncExec asyncExec=new CM_asyncExec();
  asyncExec.setArgs(threadID,message);
  asyncSend(asyncExec);
  CommandResultMessage commandResultMessage=null;
synchronized (threadInfo) {
    while (commandResultMessage == null) {
      while (!threadInfo.isValuePresent()) {
        try {
          threadInfo.wait();
        }
 catch (        Exception e) {
        }
        if (!isAlive()) {
          idToThreadInfo.remove(threadID);
          printFailedInvocation(message);
          return null;
        }
      }
      Message value=threadInfo.getMessage();
      if (value instanceof CommandResultMessage) {
        commandResultMessage=(CommandResultMessage)value;
      }
 else {
        commandResultMessage=runMessage(value);
      }
    }
  }
  if (isAdded) {
synchronized (idToThreadInfo) {
      idToThreadInfo.remove(threadID);
    }
  }
  return processCommandResult(commandResultMessage);
}",0.9991518235793044
150506,"@SuppressWarnings(""String_Node_Str"") public static void main(Configuration configuration) throws Exception {
  Jdbc j=configuration.getJdbc();
  org.jooq.util.jaxb.Generator g=configuration.getGenerator();
  if (g.getStrategy() == null)   g.setStrategy(new Strategy());
  if (g.getTarget() == null)   g.setTarget(new Target());
  Class.forName(j.getDriver());
  Connection connection=null;
  try {
    Properties properties=new Properties();
    for (    Property p : j.getProperties()) {
      properties.put(p.getKey(),p.getValue());
    }
    if (!properties.containsKey(""String_Node_Str""))     properties.put(""String_Node_Str"",defaultString(j.getUser()));
    if (!properties.containsKey(""String_Node_Str""))     properties.put(""String_Node_Str"",defaultString(j.getPassword()));
    connection=DriverManager.getConnection(defaultString(j.getUrl()),properties);
    Class<Generator> generatorClass=(Class<Generator>)(!isBlank(g.getName()) ? Class.forName(trim(g.getName())) : DefaultGenerator.class);
    Generator generator=generatorClass.newInstance();
    Class<GeneratorStrategy> strategyClass=(Class<GeneratorStrategy>)(!isBlank(g.getStrategy().getName()) ? Class.forName(trim(g.getStrategy().getName())) : DefaultGeneratorStrategy.class);
    GeneratorStrategy strategy=strategyClass.newInstance();
    generator.setStrategy(strategy);
    Class<Database> databaseClass=(Class<Database>)Class.forName(trim(g.getDatabase().getName()));
    Database database=databaseClass.newInstance();
    List<Schema> schemata=g.getDatabase().getSchemata();
    if (schemata.isEmpty()) {
      Schema schema=new Schema();
      schema.setInputSchema(trim(g.getDatabase().getInputSchema()));
      schema.setOutputSchema(trim(g.getDatabase().getOutputSchema()));
      schemata.add(schema);
    }
 else {
      if (!StringUtils.isBlank(g.getDatabase().getInputSchema())) {
        log.warn(""String_Node_Str"");
      }
      if (!StringUtils.isBlank(g.getDatabase().getOutputSchema())) {
        log.warn(""String_Node_Str"");
      }
    }
    for (    Schema schema : schemata) {
      if (StringUtils.isBlank(schema.getInputSchema())) {
        if (!StringUtils.isBlank(j.getSchema())) {
          log.warn(""String_Node_Str"");
        }
        schema.setInputSchema(trim(j.getSchema()));
      }
      if (StringUtils.isBlank(schema.getOutputSchema())) {
        schema.setOutputSchema(trim(schema.getInputSchema()));
      }
    }
    if (schemata.size() == 1) {
      if (StringUtils.isBlank(schemata.get(0).getInputSchema())) {
        log.info(""String_Node_Str"");
      }
    }
    database.setConnection(connection);
    database.setConfiguredSchemata(schemata);
    database.setIncludes(defaultString(g.getDatabase().getIncludes()).split(""String_Node_Str""));
    database.setExcludes(defaultString(g.getDatabase().getExcludes()).split(""String_Node_Str""));
    database.setConfiguredMasterDataTables(g.getDatabase().getMasterDataTables());
    database.setConfiguredCustomTypes(g.getDatabase().getCustomTypes());
    database.setConfiguredEnumTypes(g.getDatabase().getEnumTypes());
    database.setConfiguredForcedTypes(g.getDatabase().getForcedTypes());
    if (g.getDatabase().getEnumTypes().size() > 0) {
      log.warn(""String_Node_Str"");
    }
    if (g.getDatabase().isDateAsTimestamp() != null)     database.setDateAsTimestamp(g.getDatabase().isDateAsTimestamp());
    if (g.getDatabase().isUnsignedTypes() != null)     database.setSupportsUnsignedTypes(g.getDatabase().isUnsignedTypes());
    if (StringUtils.isBlank(g.getTarget().getPackageName()))     g.getTarget().setPackageName(""String_Node_Str"");
    if (StringUtils.isBlank(g.getTarget().getDirectory()))     g.getTarget().setPackageName(""String_Node_Str"");
    generator.setTargetPackage(g.getTarget().getPackageName());
    generator.setTargetDirectory(g.getTarget().getDirectory());
    if (g.getGenerate().isRelations() != null)     generator.setGenerateRelations(g.getGenerate().isRelations());
    if (g.getGenerate().isNavigationMethods() != null)     generator.setGenerateNavigationMethods(g.getGenerate().isNavigationMethods());
    if (g.getGenerate().isDeprecated() != null)     generator.setGenerateDeprecated(g.getGenerate().isDeprecated());
    if (g.getGenerate().isInstanceFields() != null)     generator.setGenerateInstanceFields(g.getGenerate().isInstanceFields());
    if (g.getGenerate().isGeneratedAnnotation() != null)     generator.setGenerateGeneratedAnnotation(g.getGenerate().isGeneratedAnnotation());
    if (g.getGenerate().isPojos() != null)     generator.setGeneratePojos(g.getGenerate().isPojos());
    if (g.getGenerate().isRecords() != null)     generator.setGenerateRecords(g.getGenerate().isRecords());
    if (g.getGenerate().isJpaAnnotations() != null)     generator.setGenerateJPAAnnotations(g.getGenerate().isJpaAnnotations());
    if (g.getGenerate().isValidationAnnotations() != null)     generator.setGenerateValidationAnnotations(g.getGenerate().isValidationAnnotations());
    strategy.setInstanceFields(generator.generateInstanceFields());
    generator.generate(database);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
 finally {
    if (connection != null) {
      connection.close();
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public static void main(Configuration configuration) throws Exception {
  Jdbc j=configuration.getJdbc();
  org.jooq.util.jaxb.Generator g=configuration.getGenerator();
  if (g.getStrategy() == null)   g.setStrategy(new Strategy());
  if (g.getTarget() == null)   g.setTarget(new Target());
  Class.forName(j.getDriver());
  Connection connection=null;
  try {
    Properties properties=new Properties();
    for (    Property p : j.getProperties()) {
      properties.put(p.getKey(),p.getValue());
    }
    if (!properties.containsKey(""String_Node_Str""))     properties.put(""String_Node_Str"",defaultString(j.getUser()));
    if (!properties.containsKey(""String_Node_Str""))     properties.put(""String_Node_Str"",defaultString(j.getPassword()));
    connection=DriverManager.getConnection(defaultString(j.getUrl()),properties);
    Class<Generator> generatorClass=(Class<Generator>)(!isBlank(g.getName()) ? Class.forName(trim(g.getName())) : DefaultGenerator.class);
    Generator generator=generatorClass.newInstance();
    Class<GeneratorStrategy> strategyClass=(Class<GeneratorStrategy>)(!isBlank(g.getStrategy().getName()) ? Class.forName(trim(g.getStrategy().getName())) : DefaultGeneratorStrategy.class);
    GeneratorStrategy strategy=strategyClass.newInstance();
    generator.setStrategy(strategy);
    Class<Database> databaseClass=(Class<Database>)Class.forName(trim(g.getDatabase().getName()));
    Database database=databaseClass.newInstance();
    List<Schema> schemata=g.getDatabase().getSchemata();
    if (schemata.isEmpty()) {
      Schema schema=new Schema();
      schema.setInputSchema(trim(g.getDatabase().getInputSchema()));
      schema.setOutputSchema(trim(g.getDatabase().getOutputSchema()));
      schemata.add(schema);
    }
 else {
      if (!StringUtils.isBlank(g.getDatabase().getInputSchema())) {
        log.warn(""String_Node_Str"");
      }
      if (!StringUtils.isBlank(g.getDatabase().getOutputSchema())) {
        log.warn(""String_Node_Str"");
      }
    }
    for (    Schema schema : schemata) {
      if (StringUtils.isBlank(schema.getInputSchema())) {
        if (!StringUtils.isBlank(j.getSchema())) {
          log.warn(""String_Node_Str"");
        }
        schema.setInputSchema(trim(j.getSchema()));
      }
      if (StringUtils.isBlank(schema.getOutputSchema())) {
        schema.setOutputSchema(trim(schema.getInputSchema()));
      }
    }
    if (schemata.size() == 1) {
      if (StringUtils.isBlank(schemata.get(0).getInputSchema())) {
        log.info(""String_Node_Str"");
      }
    }
    database.setConnection(connection);
    database.setConfiguredSchemata(schemata);
    database.setIncludes(defaultString(g.getDatabase().getIncludes()).split(""String_Node_Str""));
    database.setExcludes(defaultString(g.getDatabase().getExcludes()).split(""String_Node_Str""));
    database.setConfiguredMasterDataTables(g.getDatabase().getMasterDataTables());
    database.setConfiguredCustomTypes(g.getDatabase().getCustomTypes());
    database.setConfiguredEnumTypes(g.getDatabase().getEnumTypes());
    database.setConfiguredForcedTypes(g.getDatabase().getForcedTypes());
    if (g.getDatabase().getEnumTypes().size() > 0) {
      log.warn(""String_Node_Str"");
    }
    if (g.getDatabase().isDateAsTimestamp() != null)     database.setDateAsTimestamp(g.getDatabase().isDateAsTimestamp());
    if (g.getDatabase().isUnsignedTypes() != null)     database.setSupportsUnsignedTypes(g.getDatabase().isUnsignedTypes());
    if (StringUtils.isBlank(g.getTarget().getPackageName()))     g.getTarget().setPackageName(""String_Node_Str"");
    if (StringUtils.isBlank(g.getTarget().getDirectory()))     g.getTarget().setDirectory(""String_Node_Str"");
    generator.setTargetPackage(g.getTarget().getPackageName());
    generator.setTargetDirectory(g.getTarget().getDirectory());
    if (g.getGenerate().isRelations() != null)     generator.setGenerateRelations(g.getGenerate().isRelations());
    if (g.getGenerate().isNavigationMethods() != null)     generator.setGenerateNavigationMethods(g.getGenerate().isNavigationMethods());
    if (g.getGenerate().isDeprecated() != null)     generator.setGenerateDeprecated(g.getGenerate().isDeprecated());
    if (g.getGenerate().isInstanceFields() != null)     generator.setGenerateInstanceFields(g.getGenerate().isInstanceFields());
    if (g.getGenerate().isGeneratedAnnotation() != null)     generator.setGenerateGeneratedAnnotation(g.getGenerate().isGeneratedAnnotation());
    if (g.getGenerate().isPojos() != null)     generator.setGeneratePojos(g.getGenerate().isPojos());
    if (g.getGenerate().isRecords() != null)     generator.setGenerateRecords(g.getGenerate().isRecords());
    if (g.getGenerate().isJpaAnnotations() != null)     generator.setGenerateJPAAnnotations(g.getGenerate().isJpaAnnotations());
    if (g.getGenerate().isValidationAnnotations() != null)     generator.setGenerateValidationAnnotations(g.getGenerate().isValidationAnnotations());
    strategy.setInstanceFields(generator.generateInstanceFields());
    generator.generate(database);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
 finally {
    if (connection != null) {
      connection.close();
    }
  }
}",0.9980879541108988
150507,"@Test public void testRelationalDivision(){
  int id=create().select().from(TBookToBookStore().divideBy(TBookStore()).on(TBookToBookStore_BOOK_STORE_NAME().equal(TBookStore_NAME())).returning(TBookToBookStore_BOOK_ID())).fetchOne(0,Integer.class);
  assertEquals(3,id);
  Table<?> notAllBookStores=create().select().from(TBookStore()).where(TBookStore_NAME().notEqual(""String_Node_Str"")).asTable(""String_Node_Str"");
  Result<?> result=create().select().from(TBookToBookStore().divideBy(notAllBookStores).on(TBookToBookStore_BOOK_STORE_NAME().equal(notAllBookStores.getField(TBookStore_NAME()))).returning(TBookToBookStore_BOOK_ID(),field(""String_Node_Str"").as(""String_Node_Str""))).orderBy(1).fetch();
  assertEquals(asList((Object)1,""String_Node_Str""),asList(result.get(0).intoArray()));
  assertEquals(asList((Object)3,""String_Node_Str""),asList(result.get(1).intoArray()));
}","@Test public void testRelationalDivision() throws Exception {
  int id=create().select().from(TBookToBookStore().divideBy(TBookStore()).on(TBookToBookStore_BOOK_STORE_NAME().equal(TBookStore_NAME())).returning(TBookToBookStore_BOOK_ID())).fetchOne(0,Integer.class);
  assertEquals(3,id);
  Table<?> notAllBookStores=create().select().from(TBookStore()).where(TBookStore_NAME().notEqual(""String_Node_Str"")).asTable(""String_Node_Str"");
  Result<?> result=create().select().from(TBookToBookStore().divideBy(notAllBookStores).on(TBookToBookStore_BOOK_STORE_NAME().equal(notAllBookStores.getField(TBookStore_NAME()))).returning(TBookToBookStore_BOOK_ID(),field(""String_Node_Str"").as(""String_Node_Str""))).orderBy(1).fetch();
  assertEquals(asList((Object)1,""String_Node_Str""),asList(result.get(0).intoArray()));
  assertEquals(asList((Object)3,""String_Node_Str""),asList(result.get(1).intoArray()));
}",0.9898305084745764
150508,"@SuppressWarnings(""String_Node_Str"") @Test public void testInsertReturning() throws Exception {
  if (TTriggers() == null) {
    log.info(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  jOOQAbstractTest.reset=false;
  InsertQuery<T> query;
  int ID=0;
  query=create().insertQuery(TTriggers());
  query.addValue(TTriggers_ID(),null);
  query.addValue(TTriggers_COUNTER(),0);
  assertEquals(1,query.execute());
  assertNull(query.getReturnedRecord());
  assertEquals(1,create().selectFrom(TTriggers()).fetch().size());
  assertEquals(++ID,(int)create().selectFrom(TTriggers()).fetchOne(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)create().selectFrom(TTriggers()).fetchOne(TTriggers_ID()));
  assertEquals(2 * ID,(int)create().selectFrom(TTriggers()).fetchOne(TTriggers_COUNTER()));
  query=create().insertQuery(TTriggers());
  query.addValue(TTriggers_COUNTER(),null);
  query.addValue(TTriggers_COUNTER(),0);
  query.setReturning();
  assertEquals(1,query.execute());
  assertNotNull(query.getReturnedRecord());
  assertEquals(++ID,(int)query.getReturnedRecord().getValue(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)query.getReturnedRecord().getValue(TTriggers_ID()));
  assertEquals(2 * ID,(int)query.getReturnedRecord().getValue(TTriggers_COUNTER()));
  query=create().insertQuery(TTriggers());
  query.addValue(TTriggers_COUNTER(),0);
  query.setReturning(TTriggers_ID_GENERATED());
  assertEquals(1,query.execute());
  assertNotNull(query.getReturnedRecord());
  assertEquals(++ID,(int)query.getReturnedRecord().getValue(TTriggers_ID_GENERATED()));
  assertNull(query.getReturnedRecord().getValue(TTriggers_ID()));
  assertNull(query.getReturnedRecord().getValue(TTriggers_COUNTER()));
  query.getReturnedRecord().refresh();
  assertEquals(ID,(int)query.getReturnedRecord().getValue(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)query.getReturnedRecord().getValue(TTriggers_ID()));
  assertEquals(2 * ID,(int)query.getReturnedRecord().getValue(TTriggers_COUNTER()));
  TableRecord<T> returned=create().insertInto(TTriggers(),TTriggers_COUNTER()).values(0).returning().fetchOne();
  assertNotNull(returned);
  assertEquals(++ID,(int)returned.getValue(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)returned.getValue(TTriggers_ID()));
  assertEquals(2 * ID,(int)returned.getValue(TTriggers_COUNTER()));
  returned=create().insertInto(TTriggers()).set(TTriggers_COUNTER(),0).returning(TTriggers_ID_GENERATED()).fetchOne();
  assertNotNull(returned);
  assertEquals(++ID,(int)returned.getValue(TTriggers_ID_GENERATED()));
  assertNull(returned.getValue(TTriggers_ID()));
  assertNull(returned.getValue(TTriggers_COUNTER()));
switch (getDialect()) {
case ASE:
case DERBY:
case H2:
case INGRES:
case ORACLE:
case SQLITE:
case SQLSERVER:
case SYBASE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  break;
default :
Result<?> many=create().insertInto(TTriggers(),TTriggers_COUNTER()).values(-1).values(-2).values(-3).returning().fetch();
assertNotNull(many);
assertEquals(3,many.size());
assertEquals(++ID,(int)many.getValue(0,TTriggers_ID_GENERATED()));
assertEquals(ID,(int)many.getValue(0,TTriggers_ID()));
assertEquals(2 * ID,(int)many.getValue(0,TTriggers_COUNTER()));
assertEquals(++ID,(int)many.getValue(1,TTriggers_ID_GENERATED()));
assertEquals(ID,(int)many.getValue(1,TTriggers_ID()));
assertEquals(2 * ID,(int)many.getValue(1,TTriggers_COUNTER()));
assertEquals(++ID,(int)many.getValue(2,TTriggers_ID_GENERATED()));
assertEquals(ID,(int)many.getValue(2,TTriggers_ID()));
assertEquals(2 * ID,(int)many.getValue(2,TTriggers_COUNTER()));
break;
}
returned=create().insertInto(TTriggers(),TTriggers_COUNTER()).values(0).returning(TTriggers_ID()).fetchOne();
assertNotNull(returned);
assertEquals(++ID,(int)returned.getValue(TTriggers_ID()));
assertNull(returned.getValue(TTriggers_ID_GENERATED()));
assertNull(returned.getValue(TTriggers_COUNTER()));
returned.refreshUsing(TTriggers_ID());
assertEquals(ID,(int)returned.getValue(TTriggers_ID_GENERATED()));
assertEquals(2 * ID,(int)returned.getValue(TTriggers_COUNTER()));
T triggered=create().newRecord(TTriggers());
triggered.setValue(TTriggers_COUNTER(),0);
assertEquals(1,triggered.store());
assertEquals(++ID,(int)triggered.getValue(TTriggers_ID_GENERATED()));
assertEquals(null,triggered.getValue(TTriggers_ID()));
assertEquals(0,(int)triggered.getValue(TTriggers_COUNTER()));
triggered.refresh();
assertEquals(ID,(int)triggered.getValue(TTriggers_ID()));
assertEquals(2 * ID,(int)triggered.getValue(TTriggers_COUNTER()));
}","@SuppressWarnings(""String_Node_Str"") @Test public void testInsertReturning() throws Exception {
  if (TTriggers() == null) {
    log.info(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  jOOQAbstractTest.reset=false;
  InsertQuery<T> query;
  int ID=0;
  query=create().insertQuery(TTriggers());
  query.addValue(TTriggers_ID(),null);
  query.addValue(TTriggers_COUNTER(),0);
  assertEquals(1,query.execute());
  assertNull(query.getReturnedRecord());
  assertEquals(1,create().selectFrom(TTriggers()).fetch().size());
  assertEquals(++ID,(int)create().selectFrom(TTriggers()).fetchOne(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)create().selectFrom(TTriggers()).fetchOne(TTriggers_ID()));
  assertEquals(2 * ID,(int)create().selectFrom(TTriggers()).fetchOne(TTriggers_COUNTER()));
  query=create().insertQuery(TTriggers());
  query.addValue(TTriggers_COUNTER(),null);
  query.addValue(TTriggers_COUNTER(),0);
  query.setReturning();
  assertEquals(1,query.execute());
  assertNotNull(query.getReturnedRecord());
  assertEquals(++ID,(int)query.getReturnedRecord().getValue(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)query.getReturnedRecord().getValue(TTriggers_ID()));
  assertEquals(2 * ID,(int)query.getReturnedRecord().getValue(TTriggers_COUNTER()));
  query=create().insertQuery(TTriggers());
  query.addValue(TTriggers_COUNTER(),0);
  query.setReturning(TTriggers_ID_GENERATED());
  assertEquals(1,query.execute());
  assertNotNull(query.getReturnedRecord());
  assertEquals(++ID,(int)query.getReturnedRecord().getValue(TTriggers_ID_GENERATED()));
  assertNull(query.getReturnedRecord().getValue(TTriggers_ID()));
  assertNull(query.getReturnedRecord().getValue(TTriggers_COUNTER()));
  query.getReturnedRecord().refresh();
  assertEquals(ID,(int)query.getReturnedRecord().getValue(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)query.getReturnedRecord().getValue(TTriggers_ID()));
  assertEquals(2 * ID,(int)query.getReturnedRecord().getValue(TTriggers_COUNTER()));
  TableRecord<T> returned=create().insertInto(TTriggers(),TTriggers_COUNTER()).values(0).returning().fetchOne();
  assertNotNull(returned);
  assertEquals(++ID,(int)returned.getValue(TTriggers_ID_GENERATED()));
  assertEquals(ID,(int)returned.getValue(TTriggers_ID()));
  assertEquals(2 * ID,(int)returned.getValue(TTriggers_COUNTER()));
  returned=create().insertInto(TTriggers()).set(TTriggers_COUNTER(),0).returning(TTriggers_ID_GENERATED()).fetchOne();
  assertNotNull(returned);
  assertEquals(++ID,(int)returned.getValue(TTriggers_ID_GENERATED()));
  assertNull(returned.getValue(TTriggers_ID()));
  assertNull(returned.getValue(TTriggers_COUNTER()));
switch (getDialect()) {
case ASE:
case CUBRID:
case DERBY:
case H2:
case INGRES:
case ORACLE:
case SQLITE:
case SQLSERVER:
case SYBASE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  break;
default :
Result<?> many=create().insertInto(TTriggers(),TTriggers_COUNTER()).values(-1).values(-2).values(-3).returning().fetch();
assertNotNull(many);
assertEquals(3,many.size());
assertEquals(++ID,(int)many.getValue(0,TTriggers_ID_GENERATED()));
assertEquals(ID,(int)many.getValue(0,TTriggers_ID()));
assertEquals(2 * ID,(int)many.getValue(0,TTriggers_COUNTER()));
assertEquals(++ID,(int)many.getValue(1,TTriggers_ID_GENERATED()));
assertEquals(ID,(int)many.getValue(1,TTriggers_ID()));
assertEquals(2 * ID,(int)many.getValue(1,TTriggers_COUNTER()));
assertEquals(++ID,(int)many.getValue(2,TTriggers_ID_GENERATED()));
assertEquals(ID,(int)many.getValue(2,TTriggers_ID()));
assertEquals(2 * ID,(int)many.getValue(2,TTriggers_COUNTER()));
break;
}
returned=create().insertInto(TTriggers(),TTriggers_COUNTER()).values(0).returning(TTriggers_ID()).fetchOne();
assertNotNull(returned);
assertEquals(++ID,(int)returned.getValue(TTriggers_ID()));
assertNull(returned.getValue(TTriggers_ID_GENERATED()));
assertNull(returned.getValue(TTriggers_COUNTER()));
returned.refreshUsing(TTriggers_ID());
assertEquals(ID,(int)returned.getValue(TTriggers_ID_GENERATED()));
assertEquals(2 * ID,(int)returned.getValue(TTriggers_COUNTER()));
T triggered=create().newRecord(TTriggers());
triggered.setValue(TTriggers_COUNTER(),0);
assertEquals(1,triggered.store());
assertEquals(++ID,(int)triggered.getValue(TTriggers_ID_GENERATED()));
assertEquals(null,triggered.getValue(TTriggers_ID()));
assertEquals(0,(int)triggered.getValue(TTriggers_COUNTER()));
triggered.refresh();
assertEquals(ID,(int)triggered.getValue(TTriggers_ID()));
assertEquals(2 * ID,(int)triggered.getValue(TTriggers_COUNTER()));
}",0.9985640119297472
150509,"/** 
 * Extracted method for very similar tests with T_IDENTITY, T_IDENTITY_PK
 */
@SuppressWarnings(""String_Node_Str"") private <R extends TableRecord<R>>void testInsertIdentity0(Table<R> table,TableField<R,Integer> id,TableField<R,Integer> val) throws Exception {
  assertEquals(1,create().insertInto(table,val).values(10).execute());
  if (getDialect() != POSTGRES && getDialect() != DB2) {
    assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
  }
  R r1=create().selectFrom(table).fetchOne();
  assertEquals(1,(int)r1.getValue(id));
  assertEquals(10,(int)r1.getValue(val));
  R r2=create().insertInto(table,val).values(11).returning().fetchOne();
  if (getDialect() != POSTGRES && getDialect() != DB2) {
    assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
    assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
  }
  assertEquals(2,(int)r2.getValue(id));
  assertEquals(11,(int)r2.getValue(val));
  if (getDialect() == SYBASE || getDialect() == SQLSERVER || getDialect() == INGRES || getDialect() == H2 || getDialect() == DERBY || getDialect() == ASE) {
    log.info(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    Result<R> r3=create().insertInto(table,val).values(12).values(13).returning(id).fetch();
    assertEquals(2,r3.size());
    assertNull(r3.getValue(0,val));
    assertNull(r3.getValue(1,val));
    assertEquals(3,(int)r3.getValue(0,id));
    assertEquals(4,(int)r3.getValue(1,id));
    R r4=create().newRecord(table);
    r4.setValue(val,20);
    assertEquals(1,r4.storeUsing(table.getIdentity().getField()));
    if (getDialect() != POSTGRES && getDialect() != DB2) {
      assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
      assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
    }
    R r5=create().fetchOne(table,id.equal(5));
    assertEquals(r5,r4);
  }
}","/** 
 * Extracted method for very similar tests with T_IDENTITY, T_IDENTITY_PK
 */
@SuppressWarnings(""String_Node_Str"") private <R extends TableRecord<R>>void testInsertIdentity0(Table<R> table,TableField<R,Integer> id,TableField<R,Integer> val) throws Exception {
  assertEquals(1,create().insertInto(table,val).values(10).execute());
  if (getDialect() != POSTGRES && getDialect() != DB2) {
    assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
  }
  R r1=create().selectFrom(table).fetchOne();
  assertEquals(1,(int)r1.getValue(id));
  assertEquals(10,(int)r1.getValue(val));
  R r2=create().insertInto(table,val).values(11).returning().fetchOne();
  if (getDialect() != POSTGRES && getDialect() != DB2) {
    assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
    assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
  }
  assertEquals(2,(int)r2.getValue(id));
  assertEquals(11,(int)r2.getValue(val));
  if (getDialect() == CUBRID || getDialect() == SYBASE || getDialect() == SQLSERVER || getDialect() == INGRES || getDialect() == H2 || getDialect() == DERBY || getDialect() == ASE) {
    log.info(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    Result<R> r3=create().insertInto(table,val).values(12).values(13).returning(id).fetch();
    assertEquals(2,r3.size());
    assertNull(r3.getValue(0,val));
    assertNull(r3.getValue(1,val));
    assertEquals(3,(int)r3.getValue(0,id));
    assertEquals(4,(int)r3.getValue(1,id));
    R r4=create().newRecord(table);
    r4.setValue(val,20);
    assertEquals(1,r4.storeUsing(table.getIdentity().getField()));
    if (getDialect() != POSTGRES && getDialect() != DB2) {
      assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
      assertEquals(new BigInteger(""String_Node_Str""),create().lastID());
    }
    R r5=create().fetchOne(table,id.equal(5));
    assertEquals(r5,r4);
  }
}",0.9931107578166402
150510,"@Test public void testJoinQuery() throws Exception {
  SimpleSelectQuery<L> q1=create().selectQuery(VLibrary());
  q1.addOrderBy(VLibrary_TITLE());
  q1.addConditions(VLibrary_TITLE().notEqual(""String_Node_Str""));
  Table<A> a=TAuthor().as(""String_Node_Str"");
  Table<B> b=TBook().as(""String_Node_Str"");
  Field<Integer> a_authorID=a.getField(TAuthor_ID());
  Field<Integer> b_authorID=b.getField(TBook_AUTHOR_ID());
  Field<String> b_title=b.getField(TBook_TITLE());
  SelectQuery q2=create().selectQuery();
  q2.addFrom(a);
  q2.addJoin(b,b_authorID.equal(a_authorID));
  q2.addConditions(b_title.notEqual(""String_Node_Str""));
  q2.addOrderBy(lower(b_title));
  int rows1=q1.execute();
  int rows2=q2.execute();
  assertEquals(3,rows1);
  assertEquals(3,rows2);
  Result<L> result1=q1.getResult();
  Result<?> result2=q2.getResult();
  assertEquals(""String_Node_Str"",result1.get(0).getValue(VLibrary_TITLE()));
  assertEquals(""String_Node_Str"",result2.get(0).getValue(b_title));
  assertEquals(""String_Node_Str"",result1.get(1).getValue(VLibrary_TITLE()));
  assertEquals(""String_Node_Str"",result2.get(1).getValue(b_title));
  assertEquals(""String_Node_Str"",result1.get(2).getValue(VLibrary_TITLE()));
  assertEquals(""String_Node_Str"",result2.get(2).getValue(b_title));
  if (getDialect() != SQLDialect.DB2 && getDialect() != SQLDialect.INGRES) {
    Result<Record> result=create().select().from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID()).and(TBook_LANGUAGE_ID().in(create().select(field(""String_Node_Str"")).from(""String_Node_Str"").where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).orExists(create().selectOne().from(TAuthor()).where(falseCondition()))).orderBy(TBook_ID()).fetch();
    assertEquals(3,result.size());
    assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
    Select<A> author=create().selectFrom(TAuthor());
    result=create().select().from(author).join(TBook()).on(author.getField(TAuthor_ID()).equal(TBook_AUTHOR_ID())).and(TBook_LANGUAGE_ID().in(create().select(field(""String_Node_Str"")).from(""String_Node_Str"").where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).orExists(create().selectOne().where(falseCondition())).orderBy(TBook_ID()).fetch();
    assertEquals(3,result.size());
    assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
    Select<B> book=create().selectFrom(TBook());
    result=create().select().from(TAuthor()).join(book).on(TAuthor_ID().equal(book.getField(TBook_AUTHOR_ID()))).and(book.getField(TBook_LANGUAGE_ID()).in(create().select(field(""String_Node_Str"")).from(""String_Node_Str"").where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).orExists(create().selectOne().where(falseCondition())).orderBy(book.getField(TBook_ID())).fetch();
    assertEquals(3,result.size());
    assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
  }
}","@Test public void testJoinQuery() throws Exception {
  SimpleSelectQuery<L> q1=create().selectQuery(VLibrary());
  q1.addOrderBy(VLibrary_TITLE());
  q1.addConditions(VLibrary_TITLE().notEqual(""String_Node_Str""));
  Table<A> a=TAuthor().as(""String_Node_Str"");
  Table<B> b=TBook().as(""String_Node_Str"");
  Field<Integer> a_authorID=a.getField(TAuthor_ID());
  Field<Integer> b_authorID=b.getField(TBook_AUTHOR_ID());
  Field<String> b_title=b.getField(TBook_TITLE());
  SelectQuery q2=create().selectQuery();
  q2.addFrom(a);
  q2.addJoin(b,b_authorID.equal(a_authorID));
  q2.addConditions(b_title.notEqual(""String_Node_Str""));
  q2.addOrderBy(lower(b_title));
  int rows1=q1.execute();
  int rows2=q2.execute();
  assertEquals(3,rows1);
  assertEquals(3,rows2);
  Result<L> result1=q1.getResult();
  Result<?> result2=q2.getResult();
  assertEquals(""String_Node_Str"",result1.get(0).getValue(VLibrary_TITLE()));
  assertEquals(""String_Node_Str"",result2.get(0).getValue(b_title));
  assertEquals(""String_Node_Str"",result1.get(1).getValue(VLibrary_TITLE()));
  assertEquals(""String_Node_Str"",result2.get(1).getValue(b_title));
  assertEquals(""String_Node_Str"",result1.get(2).getValue(VLibrary_TITLE()));
  assertEquals(""String_Node_Str"",result2.get(2).getValue(b_title));
  if (!asList(CUBRID,DB2,INGRES).contains(getDialect())) {
    Result<Record> result=create().select().from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID()).and(TBook_LANGUAGE_ID().in(create().select(field(""String_Node_Str"")).from(""String_Node_Str"").where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).orExists(create().selectOne().from(TAuthor()).where(falseCondition()))).orderBy(TBook_ID()).fetch();
    assertEquals(3,result.size());
    assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
    Select<A> author=create().selectFrom(TAuthor());
    result=create().select().from(author).join(TBook()).on(author.getField(TAuthor_ID()).equal(TBook_AUTHOR_ID())).and(TBook_LANGUAGE_ID().in(create().select(field(""String_Node_Str"")).from(""String_Node_Str"").where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).orExists(create().selectOne().where(falseCondition())).orderBy(TBook_ID()).fetch();
    assertEquals(3,result.size());
    assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
    Select<B> book=create().selectFrom(TBook());
    result=create().select().from(TAuthor()).join(book).on(TAuthor_ID().equal(book.getField(TBook_AUTHOR_ID()))).and(book.getField(TBook_LANGUAGE_ID()).in(create().select(field(""String_Node_Str"")).from(""String_Node_Str"").where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""))).orExists(create().selectOne().where(falseCondition())).orderBy(book.getField(TBook_ID())).fetch();
    assertEquals(3,result.size());
    assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
    assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
  }
}",0.9854147675478578
150511,"@Test public void testInverseAndNestedJoin() throws Exception {
  if (getDialect() == SQLITE) {
    log.info(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  Result<Record> result1=create().select(TAuthor_ID(),TBook_ID(),TBookStore_NAME()).from(TAuthor().join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID()))).join(TBookToBookStore().join(TBookStore()).on(TBookToBookStore_BOOK_STORE_NAME().equal(TBookStore_NAME()))).on(TBook_ID().equal(TBookToBookStore_BOOK_ID())).orderBy(TBook_ID(),TBookStore_NAME()).fetch();
  assertEquals(6,result1.size());
  assertEquals(asList(1,1,1,2,2,2),result1.getValues(0));
  assertEquals(asList(1,1,2,3,3,3),result1.getValues(1));
  assertEquals(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),result1.getValues(2));
  Result<Record> result2=create().select(TAuthor_ID(),TBook_ID(),TBookStore_NAME()).from(TAuthor().join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())),TBookToBookStore().join(TBookStore()).on(TBookToBookStore_BOOK_STORE_NAME().equal(TBookStore_NAME()))).where(TBook_ID().equal(TBookToBookStore_BOOK_ID())).orderBy(TBook_ID(),TBookStore_NAME()).fetch();
  assertEquals(6,result2.size());
  assertEquals(asList(1,1,1,2,2,2),result2.getValues(0));
  assertEquals(asList(1,1,2,3,3,3),result2.getValues(1));
  assertEquals(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),result2.getValues(2));
  assertEquals(result1,result2);
}","@Test public void testInverseAndNestedJoin() throws Exception {
  if (getDialect() == SQLITE || getDialect() == CUBRID) {
    log.info(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  Result<Record> result1=create().select(TAuthor_ID(),TBook_ID(),TBookStore_NAME()).from(TAuthor().join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID()))).join(TBookToBookStore().join(TBookStore()).on(TBookToBookStore_BOOK_STORE_NAME().equal(TBookStore_NAME()))).on(TBook_ID().equal(TBookToBookStore_BOOK_ID())).orderBy(TBook_ID(),TBookStore_NAME()).fetch();
  assertEquals(6,result1.size());
  assertEquals(asList(1,1,1,2,2,2),result1.getValues(0));
  assertEquals(asList(1,1,2,3,3,3),result1.getValues(1));
  assertEquals(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),result1.getValues(2));
  Result<Record> result2=create().select(TAuthor_ID(),TBook_ID(),TBookStore_NAME()).from(TAuthor().join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())),TBookToBookStore().join(TBookStore()).on(TBookToBookStore_BOOK_STORE_NAME().equal(TBookStore_NAME()))).where(TBook_ID().equal(TBookToBookStore_BOOK_ID())).orderBy(TBook_ID(),TBookStore_NAME()).fetch();
  assertEquals(6,result2.size());
  assertEquals(asList(1,1,1,2,2,2),result2.getValues(0));
  assertEquals(asList(1,1,2,3,3,3),result2.getValues(1));
  assertEquals(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),result2.getValues(2));
  assertEquals(result1,result2);
}",0.9915309446254073
150512,"/** 
 * Create a new <code>TABLE</code> reference from this table, applying relational division. <p> Relational division is the inverse of a cross join operation. The following is an approximate definition of a relational division: <code><pre> Assume the following cross join / cartesian product C = A × B Then it can be said that A = C ÷ B B = C ÷ A </pre></code> <p> With jOOQ, you can simplify using relational divisions by using the following syntax: <code><pre> C.divideBy(B).on(C.ID.equal(B.C_ID)).returning(C.TEXT) </pre></code> <p> The above roughly translates to <code><pre> SELECT DISTINCT C.TEXT FROM C ""c1"" WHERE NOT EXISTS ( SELECT 1 FROM B WHERE NOT EXISTS ( SELECT 1 FROM C ""c2"" WHERE ""c2"".TEXT = ""c1"".TEXT AND ""c2"".ID = B.C_ID ) ) </pre></code> <p> Or in plain text: Find those TEXT values in C whose ID's correspond to all ID's in B. Note that from the above SQL statement, it is immediately clear that proper indexing is of the essence. Be sure to have indexes on all columns referenced from the <code>on(...)</code> and <code>returning(...)</code> clauses. <p> For more information about relational division and some nice, real-life examples, see <ul> <li><a href=""http://en.wikipedia.org/wiki/Relational_algebra#Division"">http://en.wikipedia.org/wiki/Relational_algebra#Division</a></li> <li><a href= ""http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/"" >http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a></li> </ul> <p> This has been observed to work with all dialects
 */
DivideByOnStep divideBy(Table<?> divisor);","/** 
 * Create a new <code>TABLE</code> reference from this table, applying relational division. <p> Relational division is the inverse of a cross join operation. The following is an approximate definition of a relational division: <code><pre> Assume the following cross join / cartesian product C = A × B Then it can be said that A = C ÷ B B = C ÷ A </pre></code> <p> With jOOQ, you can simplify using relational divisions by using the following syntax: <code><pre> C.divideBy(B).on(C.ID.equal(B.C_ID)).returning(C.TEXT) </pre></code> <p> The above roughly translates to <code><pre> SELECT DISTINCT C.TEXT FROM C ""c1"" WHERE NOT EXISTS ( SELECT 1 FROM B WHERE NOT EXISTS ( SELECT 1 FROM C ""c2"" WHERE ""c2"".TEXT = ""c1"".TEXT AND ""c2"".ID = B.C_ID ) ) </pre></code> <p> Or in plain text: Find those TEXT values in C whose ID's correspond to all ID's in B. Note that from the above SQL statement, it is immediately clear that proper indexing is of the essence. Be sure to have indexes on all columns referenced from the <code>on(...)</code> and <code>returning(...)</code> clauses. <p> For more information about relational division and some nice, real-life examples, see <ul> <li><a href=""http://en.wikipedia.org/wiki/Relational_algebra#Division"">http://en.wikipedia.org/wiki/Relational_algebra#Division</a></li> <li><a href= ""http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/"" >http://www.simple-talk.com/sql/t-sql-programming/divided-we-stand-the-sql-of-relational-division/</a></li> </ul> <p> This has been observed to work with all dialects
 */
@Support DivideByOnStep divideBy(Table<?> divisor);",0.9972535855965824
150513,"@Override protected final void prepare(ExecuteContext ctx) throws SQLException {
  Connection connection=ctx.getConnection();
  if (ctx.getDialect() == SQLDialect.ASE) {
    ctx.statement(connection.prepareStatement(ctx.sql(),Statement.RETURN_GENERATED_KEYS));
    return;
  }
 else   if (returning.isEmpty()) {
    super.prepare(ctx);
    return;
  }
 else {
switch (ctx.getDialect()) {
case POSTGRES:
case SQLITE:
case SYBASE:
      super.prepare(ctx);
    return;
case ASE:
case CUBRID:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case SQLSERVER:
  ctx.statement(connection.prepareStatement(ctx.sql(),Statement.RETURN_GENERATED_KEYS));
return;
default :
{
List<String> names=new ArrayList<String>();
for (Field<?> field : returning) {
  names.add(field.getName());
}
ctx.statement(connection.prepareStatement(ctx.sql(),names.toArray(new String[names.size()])));
return;
}
}
}
}","@Override protected final void prepare(ExecuteContext ctx) throws SQLException {
  Connection connection=ctx.getConnection();
  if (ctx.getDialect() == SQLDialect.ASE) {
    ctx.statement(connection.prepareStatement(ctx.sql(),Statement.RETURN_GENERATED_KEYS));
    return;
  }
 else   if (returning.isEmpty()) {
    super.prepare(ctx);
    return;
  }
 else {
switch (ctx.getDialect()) {
case POSTGRES:
case SQLITE:
case CUBRID:
case SYBASE:
      super.prepare(ctx);
    return;
case ASE:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case SQLSERVER:
  ctx.statement(connection.prepareStatement(ctx.sql(),Statement.RETURN_GENERATED_KEYS));
return;
default :
{
List<String> names=new ArrayList<String>();
for (Field<?> field : returning) {
  names.add(field.getName());
}
ctx.statement(connection.prepareStatement(ctx.sql(),names.toArray(new String[names.size()])));
return;
}
}
}
}",0.9852607709750568
150514,"@Override protected final int execute(ExecuteContext ctx,ExecuteListener listener) throws SQLException {
  if (returning.isEmpty()) {
    return super.execute(ctx,listener);
  }
 else {
    int result=1;
    ResultSet rs;
switch (ctx.getDialect()) {
case SQLITE:
{
        listener.executeStart(ctx);
        result=ctx.statement().executeUpdate();
        listener.executeEnd(ctx);
        SQLiteFactory create=new SQLiteFactory(ctx.getConnection(),ctx.getSettings());
        returned=create.select(returning).from(getInto()).where(rowid().equal(rowid().getDataType().convert(create.lastID()))).fetchInto(getInto());
        return result;
      }
case SYBASE:
{
      listener.executeStart(ctx);
      result=ctx.statement().executeUpdate();
      listener.executeEnd(ctx);
      selectReturning(ctx.configuration(),create(ctx).lastID());
      return result;
    }
case ASE:
case CUBRID:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case SQLSERVER:
{
    listener.executeStart(ctx);
    result=ctx.statement().executeUpdate();
    listener.executeEnd(ctx);
    rs=ctx.statement().getGeneratedKeys();
    try {
      List<Object> list=new ArrayList<Object>();
      while (rs.next()) {
        list.add(rs.getObject(1));
      }
      selectReturning(ctx,list.toArray());
      return result;
    }
  finally {
      rs.close();
    }
  }
case POSTGRES:
{
  listener.executeStart(ctx);
  rs=ctx.statement().executeQuery();
  listener.executeEnd(ctx);
  break;
}
case DB2:
case HSQLDB:
case ORACLE:
default :
{
listener.executeStart(ctx);
result=ctx.statement().executeUpdate();
listener.executeEnd(ctx);
rs=ctx.statement().getGeneratedKeys();
break;
}
}
ExecuteContext ctx2=new DefaultExecuteContext(ctx.configuration());
ExecuteListener listener2=new ExecuteListeners(ctx2);
ctx2.resultSet(rs);
returned=new CursorImpl<R>(ctx2,listener2,returning,getInto().getRecordType()).fetch();
return result;
}
}","@Override protected final int execute(ExecuteContext ctx,ExecuteListener listener) throws SQLException {
  if (returning.isEmpty()) {
    return super.execute(ctx,listener);
  }
 else {
    int result=1;
    ResultSet rs;
switch (ctx.getDialect()) {
case SQLITE:
{
        listener.executeStart(ctx);
        result=ctx.statement().executeUpdate();
        listener.executeEnd(ctx);
        SQLiteFactory create=new SQLiteFactory(ctx.getConnection(),ctx.getSettings());
        returned=create.select(returning).from(getInto()).where(rowid().equal(rowid().getDataType().convert(create.lastID()))).fetchInto(getInto());
        return result;
      }
case CUBRID:
case SYBASE:
{
      listener.executeStart(ctx);
      result=ctx.statement().executeUpdate();
      listener.executeEnd(ctx);
      selectReturning(ctx.configuration(),create(ctx).lastID());
      return result;
    }
case ASE:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case SQLSERVER:
{
    listener.executeStart(ctx);
    result=ctx.statement().executeUpdate();
    listener.executeEnd(ctx);
    rs=ctx.statement().getGeneratedKeys();
    try {
      List<Object> list=new ArrayList<Object>();
      while (rs.next()) {
        list.add(rs.getObject(1));
      }
      selectReturning(ctx,list.toArray());
      return result;
    }
  finally {
      rs.close();
    }
  }
case POSTGRES:
{
  listener.executeStart(ctx);
  rs=ctx.statement().executeQuery();
  listener.executeEnd(ctx);
  break;
}
case DB2:
case HSQLDB:
case ORACLE:
default :
{
listener.executeStart(ctx);
result=ctx.statement().executeUpdate();
listener.executeEnd(ctx);
rs=ctx.statement().getGeneratedKeys();
break;
}
}
ExecuteContext ctx2=new DefaultExecuteContext(ctx.configuration());
ExecuteListener listener2=new ExecuteListeners(ctx2);
ctx2.resultSet(rs);
returned=new CursorImpl<R>(ctx2,listener2,returning,getInto().getRecordType()).fetch();
return result;
}
}",0.8798530954879329
150515,"@Override final Field<T> getFunction0(Configuration configuration){
switch (configuration.getDialect()) {
case ASE:
    return function(""String_Node_Str"",getDataType(),literal(""String_Node_Str""),val(value),field);
case DB2:
case HSQLDB:
  return field.add(field(""String_Node_Str"",BigDecimal.class,value));
case DERBY:
return new FnPrefixFunction<T>(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(value.intValue()),field);
case INGRES:
return field.add(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case MYSQL:
return function(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(value),field);
case POSTGRES:
return field.add(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case SQLITE:
return function(""String_Node_Str"",getDataType(),field,val(""String_Node_Str"" + value + ""String_Node_Str""));
default :
return field.add(val(value));
}
}","@Override final Field<T> getFunction0(Configuration configuration){
switch (configuration.getDialect()) {
case ASE:
    return function(""String_Node_Str"",getDataType(),literal(""String_Node_Str""),val(value),field);
case CUBRID:
  return function(""String_Node_Str"",getDataType(),field,val(value));
case DB2:
case HSQLDB:
return field.add(field(""String_Node_Str"",BigDecimal.class,value));
case DERBY:
return new FnPrefixFunction<T>(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(value.intValue()),field);
case INGRES:
return field.add(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case MYSQL:
return function(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(value),field);
case POSTGRES:
return field.add(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case SQLITE:
return function(""String_Node_Str"",getDataType(),field,val(""String_Node_Str"" + value + ""String_Node_Str""));
default :
return field.add(val(value));
}
}",0.9557428872497366
150516,"@Override final Field<T> getFunction0(Configuration configuration){
switch (configuration.getDialect()) {
case ASE:
    return function(""String_Node_Str"",getDataType(),literal(""String_Node_Str""),val(-value.intValue()),field);
case DB2:
case HSQLDB:
  return field.sub(field(""String_Node_Str"",BigDecimal.class,value));
case DERBY:
return new FnPrefixFunction<T>(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(-value.intValue()),field);
case INGRES:
return field.sub(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case MYSQL:
return function(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(-value.intValue()),field);
case POSTGRES:
return field.sub(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case SQLITE:
return function(""String_Node_Str"",getDataType(),field,val(""String_Node_Str"" + value + ""String_Node_Str""));
default :
return field.sub(val(value));
}
}","@Override final Field<T> getFunction0(Configuration configuration){
switch (configuration.getDialect()) {
case ASE:
    return function(""String_Node_Str"",getDataType(),literal(""String_Node_Str""),val(-value.intValue()),field);
case CUBRID:
  return function(""String_Node_Str"",getDataType(),field,val(value));
case DB2:
case HSQLDB:
return field.sub(field(""String_Node_Str"",BigDecimal.class,value));
case DERBY:
return new FnPrefixFunction<T>(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(-value.intValue()),field);
case INGRES:
return field.sub(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case MYSQL:
return function(""String_Node_Str"",getDataType(),field(""String_Node_Str""),val(-value.intValue()),field);
case POSTGRES:
return field.sub(field(""String_Node_Str"" + value + ""String_Node_Str"",BigDecimal.class));
case SQLITE:
return function(""String_Node_Str"",getDataType(),field,val(""String_Node_Str"" + value + ""String_Node_Str""));
default :
return field.sub(val(value));
}
}",0.9568788501026694
150517,"protected TableField<D,Byte> TDirectory_IS_DIRECTORY(){
  return delegate.TDirectory_IS_DIRECTORY();
}","protected TableField<D,Integer> TDirectory_IS_DIRECTORY(){
  return delegate.TDirectory_IS_DIRECTORY();
}",0.966183574879227
150518,"@Test public void testConnectByDirectory() throws Exception {
switch (getDialect()) {
case ASE:
case DB2:
case DERBY:
case H2:
case HSQLDB:
case INGRES:
case MYSQL:
case POSTGRES:
case SQLITE:
case SQLSERVER:
case SYBASE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  return;
}
List<?> paths=create().select(substring(sysConnectByPath(TDirectory_NAME(),""String_Node_Str""),2)).from(TDirectory()).where(trueCondition()).and(trueCondition()).connectBy(prior(TDirectory_ID()).equal(TDirectory_PARENT_ID())).startWith(TDirectory_PARENT_ID().isNull()).orderBy(one()).fetch(0);
assertEquals(26,paths.size());
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),paths);
}","@Test public void testConnectByDirectory() throws Exception {
switch (getDialect()) {
case ASE:
case DB2:
case DERBY:
case H2:
case HSQLDB:
case INGRES:
case MYSQL:
case POSTGRES:
case SQLITE:
case SQLSERVER:
case SYBASE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  return;
}
List<?> paths=create().select(substring(sysConnectByPath(lower(TDirectory_NAME()),""String_Node_Str""),2).as(""String_Node_Str"")).from(TDirectory()).where(trueCondition()).and(trueCondition()).connectBy(prior(TDirectory_ID()).equal(TDirectory_PARENT_ID())).startWith(TDirectory_PARENT_ID().isNull()).orderBy(1).fetch(0);
assertEquals(25,paths.size());
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),paths);
}",0.9753914988814316
150519,"@Test public void testAggregateFunctions() throws Exception {
  Field<BigDecimal> median=median(TBook_ID());
switch (getDialect()) {
case ASE:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case SQLITE:
case SQLSERVER:
case POSTGRES:
case DB2:
    median=avg(TBook_ID());
  break;
}
Result<Record> result=create().select(TBook_AUTHOR_ID(),count(),count(TBook_ID()),countDistinct(TBook_AUTHOR_ID()),sum(TBook_ID()),avg(TBook_ID()),min(TBook_ID()),max(TBook_ID()),median).from(TBook()).groupBy(TBook_AUTHOR_ID()).orderBy(TBook_AUTHOR_ID()).fetch();
assertEquals(2,(int)result.getValueAsInteger(0,1));
assertEquals(2,(int)result.getValueAsInteger(0,2));
assertEquals(1,(int)result.getValueAsInteger(0,3));
assertEquals(3d,result.getValueAsDouble(0,4));
assertEquals(1,(int)result.getValueAsInteger(0,6));
assertEquals(2,(int)result.getValueAsInteger(0,7));
assertEquals(2,(int)result.getValueAsInteger(1,1));
assertEquals(2,(int)result.getValueAsInteger(1,2));
assertEquals(1,(int)result.getValueAsInteger(1,3));
assertEquals(7d,result.getValueAsDouble(1,4));
assertEquals(3,(int)result.getValueAsInteger(1,6));
assertEquals(4,(int)result.getValueAsInteger(1,7));
assertTrue(asList(1.0,1.5,2.0).contains(result.getValueAsDouble(0,5)));
assertTrue(asList(1.0,1.5,2.0).contains(result.getValueAsDouble(0,8)));
assertTrue(asList(3.0,3.5,4.0).contains(result.getValueAsDouble(1,5)));
assertTrue(asList(3.0,3.5,4.0).contains(result.getValueAsDouble(1,8)));
int distinct1=create().select(countDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
int distinct2=create().select(minDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
int distinct3=create().select(maxDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
int distinct4=create().select(sumDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
double distinct5=create().select(avgDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Double.class);
assertEquals(2,distinct1);
assertEquals(1,distinct2);
assertEquals(2,distinct3);
assertEquals(3,distinct4);
assertTrue(asList(1.0,1.5,2.0).contains(distinct5));
switch (getDialect()) {
case DERBY:
case SQLITE:
log.info(""String_Node_Str"",""String_Node_Str"");
break;
default :
{
result=create().select(TBook_AUTHOR_ID(),stddevPop(TBook_ID()),stddevSamp(TBook_ID()),varPop(TBook_ID()),varSamp(TBook_ID())).from(TBook()).groupBy(TBook_AUTHOR_ID()).orderBy(TBook_AUTHOR_ID()).fetch();
assertEquals(0.5,result.getValueAsDouble(0,1));
assertEquals(0.25,result.getValueAsDouble(0,3));
assertEquals(0.5,result.getValueAsDouble(1,1));
assertEquals(0.25,result.getValueAsDouble(1,3));
if (getDialect() != SQLDialect.DB2) {
assertEquals(""String_Node_Str"",result.getValueAsString(0,2).substring(0,5));
assertEquals(0.5,result.getValueAsDouble(0,4));
assertEquals(""String_Node_Str"",result.getValueAsString(1,2).substring(0,5));
assertEquals(0.5,result.getValueAsDouble(1,4));
}
}
}
result=create().select(TBook_AUTHOR_ID(),max(TBook_ID()),max(TBook_ID())).from(TBook()).groupBy(TBook_AUTHOR_ID()).orderBy(TBook_AUTHOR_ID()).fetch();
assertEquals(2,(int)result.getValueAsInteger(0,1));
assertEquals(2,(int)result.getValueAsInteger(0,2));
assertEquals(4,(int)result.getValueAsInteger(1,1));
assertEquals(4,(int)result.getValueAsInteger(1,2));
}","@Test public void testAggregateFunctions() throws Exception {
  Field<BigDecimal> median=median(TBook_ID());
switch (getDialect()) {
case ASE:
case CUBRID:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case SQLITE:
case SQLSERVER:
case POSTGRES:
case DB2:
    median=avg(TBook_ID());
  break;
}
Result<Record> result=create().select(TBook_AUTHOR_ID(),count(),count(TBook_ID()),countDistinct(TBook_AUTHOR_ID()),sum(TBook_ID()),avg(TBook_ID()),min(TBook_ID()),max(TBook_ID()),median).from(TBook()).groupBy(TBook_AUTHOR_ID()).orderBy(TBook_AUTHOR_ID()).fetch();
assertEquals(2,(int)result.getValueAsInteger(0,1));
assertEquals(2,(int)result.getValueAsInteger(0,2));
assertEquals(1,(int)result.getValueAsInteger(0,3));
assertEquals(3d,result.getValueAsDouble(0,4));
assertEquals(1,(int)result.getValueAsInteger(0,6));
assertEquals(2,(int)result.getValueAsInteger(0,7));
assertEquals(2,(int)result.getValueAsInteger(1,1));
assertEquals(2,(int)result.getValueAsInteger(1,2));
assertEquals(1,(int)result.getValueAsInteger(1,3));
assertEquals(7d,result.getValueAsDouble(1,4));
assertEquals(3,(int)result.getValueAsInteger(1,6));
assertEquals(4,(int)result.getValueAsInteger(1,7));
assertTrue(asList(1.0,1.5,2.0).contains(result.getValueAsDouble(0,5)));
assertTrue(asList(1.0,1.5,2.0).contains(result.getValueAsDouble(0,8)));
assertTrue(asList(3.0,3.5,4.0).contains(result.getValueAsDouble(1,5)));
assertTrue(asList(3.0,3.5,4.0).contains(result.getValueAsDouble(1,8)));
int distinct1=create().select(countDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
int distinct2=create().select(minDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
int distinct3=create().select(maxDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
int distinct4=create().select(sumDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Integer.class);
double distinct5=create().select(avgDistinct(TBook_AUTHOR_ID())).from(TBook()).fetchOne(0,Double.class);
assertEquals(2,distinct1);
assertEquals(1,distinct2);
assertEquals(2,distinct3);
assertEquals(3,distinct4);
assertTrue(asList(1.0,1.5,2.0).contains(distinct5));
switch (getDialect()) {
case DERBY:
case SQLITE:
log.info(""String_Node_Str"",""String_Node_Str"");
break;
default :
{
result=create().select(TBook_AUTHOR_ID(),stddevPop(TBook_ID()),stddevSamp(TBook_ID()),varPop(TBook_ID()),varSamp(TBook_ID())).from(TBook()).groupBy(TBook_AUTHOR_ID()).orderBy(TBook_AUTHOR_ID()).fetch();
assertEquals(0.5,result.getValueAsDouble(0,1));
assertEquals(0.25,result.getValueAsDouble(0,3));
assertEquals(0.5,result.getValueAsDouble(1,1));
assertEquals(0.25,result.getValueAsDouble(1,3));
if (getDialect() != SQLDialect.DB2) {
assertEquals(""String_Node_Str"",result.getValueAsString(0,2).substring(0,5));
assertEquals(0.5,result.getValueAsDouble(0,4));
assertEquals(""String_Node_Str"",result.getValueAsString(1,2).substring(0,5));
assertEquals(0.5,result.getValueAsDouble(1,4));
}
}
}
result=create().select(TBook_AUTHOR_ID(),max(TBook_ID()),max(TBook_ID())).from(TBook()).groupBy(TBook_AUTHOR_ID()).orderBy(TBook_AUTHOR_ID()).fetch();
assertEquals(2,(int)result.getValueAsInteger(0,1));
assertEquals(2,(int)result.getValueAsInteger(0,2));
assertEquals(4,(int)result.getValueAsInteger(1,1));
assertEquals(4,(int)result.getValueAsInteger(1,2));
}",0.9980306014240268
150520,"@Test public void testMetaModel() throws Exception {
  Schema schema=TAuthor().getSchema();
  if (schema != null) {
    int sequences=0;
    if (cSequences() != null) {
      sequences++;
      if (getDialect() == SQLDialect.DB2 || getDialect() == SQLDialect.H2) {
        sequences++;
      }
 else       if (getDialect() == ORACLE) {
        sequences+=5;
      }
    }
    assertEquals(sequences,schema.getSequences().size());
    for (    Table<?> table : schema.getTables()) {
      assertEquals(table,schema.getTable(table.getName()));
    }
    for (    UDT<?> udt : schema.getUDTs()) {
      assertEquals(udt,schema.getUDT(udt.getName()));
    }
    for (    Sequence<?> sequence : schema.getSequences()) {
      assertEquals(sequence,schema.getSequence(sequence.getName()));
    }
    int tables=17;
    if (supportsRecursiveQueries()) {
      tables++;
    }
    if (TTriggers() != null) {
      tables++;
    }
    if (TUnsigned() != null) {
      tables++;
    }
    if (TIdentity() != null) {
      tables++;
    }
    if (TIdentityPK() != null) {
      tables++;
    }
    if (getDialect() == MYSQL || getDialect() == POSTGRES) {
      tables++;
    }
    if (getDialect() == ASE || getDialect() == DB2 || getDialect() == POSTGRES || getDialect() == SQLITE || getDialect() == SYBASE) {
      tables+=2;
    }
    if (TArrays() == null) {
      assertEquals(tables,schema.getTables().size());
    }
 else     if (getDialect() == ORACLE || getDialect() == H2) {
      assertEquals(tables + 2,schema.getTables().size());
    }
 else     if (getDialect() == HSQLDB) {
      assertEquals(tables + 11,schema.getTables().size());
    }
 else {
      assertEquals(tables + 1,schema.getTables().size());
    }
    if (cUAddressType() == null) {
      assertEquals(0,schema.getUDTs().size());
    }
 else     if (getDialect() == ORACLE) {
      assertEquals(7,schema.getUDTs().size());
    }
 else {
      assertEquals(2,schema.getUDTs().size());
    }
  }
  assertNull(TAuthor().getIdentity());
  assertNull(TBook().getIdentity());
  if (TIdentity() != null || TIdentityPK() != null) {
    if (TIdentity() != null) {
      assertEquals(TIdentity(),TIdentity().getIdentity().getTable());
      assertEquals(TIdentity_ID(),TIdentity().getIdentity().getField());
    }
    if (TIdentityPK() != null) {
      assertEquals(TIdentityPK(),TIdentityPK().getIdentity().getTable());
      assertEquals(TIdentityPK_ID(),TIdentityPK().getIdentity().getField());
    }
  }
 else {
    log.info(""String_Node_Str"",""String_Node_Str"");
  }
  assertNotNull(TAuthor().getMainKey());
  assertNotNull(TAuthor().getKeys());
  assertTrue(TAuthor().getKeys().contains(TAuthor().getMainKey()));
  assertEquals(1,TAuthor().getKeys().size());
  assertEquals(1,TAuthor().getMainKey().getFields().size());
  assertEquals(TAuthor_ID(),TAuthor().getMainKey().getFields().get(0));
  if (supportsReferences()) {
    assertEquals(0,TAuthor().getReferences().size());
    assertEquals(2,TAuthor().getMainKey().getReferences().size());
    assertEquals(TBook(),TAuthor().getMainKey().getReferences().get(0).getTable());
    assertEquals(TBook(),TAuthor().getMainKey().getReferences().get(1).getTable());
    assertEquals(Arrays.asList(),TAuthor().getReferencesTo(TBook()));
    assertTrue(TBook().getReferences().containsAll(TAuthor().getReferencesFrom(TBook())));
    assertTrue(TBook().getReferences().containsAll(TBook().getReferencesFrom(TAuthor())));
    assertEquals(TBook().getReferencesTo(TAuthor()),TAuthor().getReferencesFrom(TBook()));
  }
 else {
    log.info(""String_Node_Str"",""String_Node_Str"");
  }
  for (  Field<?> field : T639().getFields()) {
    if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Byte.class,field.getType());
      assertEquals(SQLDataType.TINYINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Short.class,field.getType());
      assertEquals(SQLDataType.SMALLINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Integer.class,field.getType());
      assertEquals(SQLDataType.INTEGER,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Long.class,field.getType());
      assertEquals(SQLDataType.BIGINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Byte.class,field.getType());
      assertEquals(SQLDataType.TINYINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Short.class,field.getType());
      assertEquals(SQLDataType.SMALLINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Integer.class,field.getType());
      assertEquals(SQLDataType.INTEGER,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Long.class,field.getType());
      assertEquals(SQLDataType.BIGINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(BigInteger.class,field.getType());
      assertEquals(SQLDataType.DECIMAL_INTEGER,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.ORACLE && getDialect() != SQLDialect.POSTGRES && getDialect() != SQLDialect.SQLITE && getDialect() != SQLDialect.SQLSERVER) {
      assertEquals(BigDecimal.class,field.getType());
      assertEquals(SQLDataType.DECIMAL,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(BigDecimal.class,field.getType());
      assertEquals(SQLDataType.NUMERIC,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.HSQLDB && getDialect() != SQLDialect.MYSQL && getDialect() != SQLDialect.SYBASE) {
      assertEquals(Float.class,field.getType());
      assertEquals(SQLDataType.REAL,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.MYSQL && getDialect() != SQLDialect.SYBASE) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.DOUBLE,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.FLOAT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.SQLSERVER && getDialect() != SQLDialect.ASE) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.DOUBLE,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.FLOAT,field.getDataType());
    }
  }
}","@Test public void testMetaModel() throws Exception {
  Schema schema=TAuthor().getSchema();
  if (schema != null) {
    int sequences=0;
    if (cSequences() != null) {
      sequences++;
      if (getDialect() == DB2 || getDialect() == H2) {
        sequences++;
      }
 else       if (getDialect() == CUBRID) {
        sequences+=3;
      }
 else       if (getDialect() == ORACLE) {
        sequences+=5;
      }
    }
    assertEquals(sequences,schema.getSequences().size());
    for (    Table<?> table : schema.getTables()) {
      assertEquals(table,schema.getTable(table.getName()));
    }
    for (    UDT<?> udt : schema.getUDTs()) {
      assertEquals(udt,schema.getUDT(udt.getName()));
    }
    for (    Sequence<?> sequence : schema.getSequences()) {
      assertEquals(sequence,schema.getSequence(sequence.getName()));
    }
    int tables=17;
    if (supportsRecursiveQueries()) {
      tables++;
    }
    if (TTriggers() != null) {
      tables++;
    }
    if (TUnsigned() != null) {
      tables++;
    }
    if (TIdentity() != null) {
      tables++;
    }
    if (TIdentityPK() != null) {
      tables++;
    }
    if (getDialect() == MYSQL || getDialect() == POSTGRES) {
      tables++;
    }
    if (getDialect() == ASE || getDialect() == CUBRID || getDialect() == DB2 || getDialect() == POSTGRES || getDialect() == SQLITE || getDialect() == SYBASE) {
      tables+=2;
    }
    if (TArrays() == null) {
      assertEquals(tables,schema.getTables().size());
    }
 else     if (getDialect() == ORACLE || getDialect() == H2) {
      assertEquals(tables + 2,schema.getTables().size());
    }
 else     if (getDialect() == HSQLDB) {
      assertEquals(tables + 11,schema.getTables().size());
    }
 else {
      assertEquals(tables + 1,schema.getTables().size());
    }
    if (cUAddressType() == null) {
      assertEquals(0,schema.getUDTs().size());
    }
 else     if (getDialect() == ORACLE) {
      assertEquals(7,schema.getUDTs().size());
    }
 else {
      assertEquals(2,schema.getUDTs().size());
    }
  }
  assertNull(TAuthor().getIdentity());
  assertNull(TBook().getIdentity());
  if (TIdentity() != null || TIdentityPK() != null) {
    if (TIdentity() != null) {
      assertEquals(TIdentity(),TIdentity().getIdentity().getTable());
      assertEquals(TIdentity_ID(),TIdentity().getIdentity().getField());
    }
    if (TIdentityPK() != null) {
      assertEquals(TIdentityPK(),TIdentityPK().getIdentity().getTable());
      assertEquals(TIdentityPK_ID(),TIdentityPK().getIdentity().getField());
    }
  }
 else {
    log.info(""String_Node_Str"",""String_Node_Str"");
  }
  assertNotNull(TAuthor().getMainKey());
  assertNotNull(TAuthor().getKeys());
  assertTrue(TAuthor().getKeys().contains(TAuthor().getMainKey()));
  assertEquals(1,TAuthor().getKeys().size());
  assertEquals(1,TAuthor().getMainKey().getFields().size());
  assertEquals(TAuthor_ID(),TAuthor().getMainKey().getFields().get(0));
  if (supportsReferences()) {
    assertEquals(0,TAuthor().getReferences().size());
    assertEquals(2,TAuthor().getMainKey().getReferences().size());
    assertEquals(TBook(),TAuthor().getMainKey().getReferences().get(0).getTable());
    assertEquals(TBook(),TAuthor().getMainKey().getReferences().get(1).getTable());
    assertEquals(Arrays.asList(),TAuthor().getReferencesTo(TBook()));
    assertTrue(TBook().getReferences().containsAll(TAuthor().getReferencesFrom(TBook())));
    assertTrue(TBook().getReferences().containsAll(TBook().getReferencesFrom(TAuthor())));
    assertEquals(TBook().getReferencesTo(TAuthor()),TAuthor().getReferencesFrom(TBook()));
  }
 else {
    log.info(""String_Node_Str"",""String_Node_Str"");
  }
  for (  Field<?> field : T639().getFields()) {
    if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Byte.class,field.getType());
      assertEquals(SQLDataType.TINYINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Short.class,field.getType());
      assertEquals(SQLDataType.SMALLINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Integer.class,field.getType());
      assertEquals(SQLDataType.INTEGER,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Long.class,field.getType());
      assertEquals(SQLDataType.BIGINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Byte.class,field.getType());
      assertEquals(SQLDataType.TINYINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Short.class,field.getType());
      assertEquals(SQLDataType.SMALLINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Integer.class,field.getType());
      assertEquals(SQLDataType.INTEGER,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Long.class,field.getType());
      assertEquals(SQLDataType.BIGINT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(BigInteger.class,field.getType());
      assertEquals(SQLDataType.DECIMAL_INTEGER,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.ORACLE && getDialect() != SQLDialect.POSTGRES && getDialect() != SQLDialect.SQLITE && getDialect() != SQLDialect.SQLSERVER) {
      assertEquals(BigDecimal.class,field.getType());
      assertEquals(SQLDataType.DECIMAL,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(BigDecimal.class,field.getType());
      assertEquals(SQLDataType.NUMERIC,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.HSQLDB && getDialect() != SQLDialect.MYSQL && getDialect() != SQLDialect.SYBASE) {
      assertEquals(Float.class,field.getType());
      assertEquals(SQLDataType.REAL,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.MYSQL && getDialect() != SQLDialect.SYBASE) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.DOUBLE,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.FLOAT,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName()) && getDialect() != SQLDialect.SQLSERVER && getDialect() != SQLDialect.ASE) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.DOUBLE,field.getDataType());
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(field.getName())) {
      assertEquals(Double.class,field.getType());
      assertEquals(SQLDataType.FLOAT,field.getDataType());
    }
  }
}",0.9914965986394558
150521,"@Test public void testMerge() throws Exception {
switch (getDialect()) {
case ASE:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case POSTGRES:
case SQLITE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  return;
}
jOOQAbstractTest.reset=false;
create().mergeInto(TAuthor()).using(create().selectOne()).on(""String_Node_Str"").whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),""String_Node_Str"").whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_LAST_NAME()).values(3,""String_Node_Str"").execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
create().mergeInto(TAuthor()).using(create().selectOne()).on(TAuthor_ID().equal(1)).whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),""String_Node_Str"").whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_LAST_NAME()).values(3,""String_Node_Str"").execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
Field<String> f=val(""String_Node_Str"").as(""String_Node_Str"");
Field<String> l=val(""String_Node_Str"").as(""String_Node_Str"");
MergeFinalStep<A> q=create().mergeInto(TAuthor()).using(create().select(f,l)).on(TAuthor_LAST_NAME().equal(l)).whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),""String_Node_Str"").whenNotMatchedThenInsert().set(TAuthor_ID(),3).set(TAuthor_FIRST_NAME(),f).set(TAuthor_LAST_NAME(),l);
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
f=val(""String_Node_Str"").as(""String_Node_Str"");
l=val(""String_Node_Str"").as(""String_Node_Str"");
q=create().mergeInto(TAuthor()).using(create().select(f,l)).on(TAuthor_LAST_NAME().equal(l)).whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_FIRST_NAME(),TAuthor_LAST_NAME(),TAuthor_DATE_OF_BIRTH()).values(""String_Node_Str"",f,l,0L);
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
}","@Test public void testMerge() throws Exception {
switch (getDialect()) {
case ASE:
case CUBRID:
case DERBY:
case H2:
case INGRES:
case MYSQL:
case POSTGRES:
case SQLITE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  return;
}
jOOQAbstractTest.reset=false;
create().mergeInto(TAuthor()).using(create().selectOne()).on(""String_Node_Str"").whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),""String_Node_Str"").whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_LAST_NAME()).values(3,""String_Node_Str"").execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
create().mergeInto(TAuthor()).using(create().selectOne()).on(TAuthor_ID().equal(1)).whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),""String_Node_Str"").whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_LAST_NAME()).values(3,""String_Node_Str"").execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
Field<String> f=val(""String_Node_Str"").as(""String_Node_Str"");
Field<String> l=val(""String_Node_Str"").as(""String_Node_Str"");
MergeFinalStep<A> q=create().mergeInto(TAuthor()).using(create().select(f,l)).on(TAuthor_LAST_NAME().equal(l)).whenMatchedThenUpdate().set(TAuthor_FIRST_NAME(),""String_Node_Str"").whenNotMatchedThenInsert().set(TAuthor_ID(),3).set(TAuthor_FIRST_NAME(),f).set(TAuthor_LAST_NAME(),l);
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
f=val(""String_Node_Str"").as(""String_Node_Str"");
l=val(""String_Node_Str"").as(""String_Node_Str"");
q=create().mergeInto(TAuthor()).using(create().select(f,l)).on(TAuthor_LAST_NAME().equal(l)).whenNotMatchedThenInsert(TAuthor_ID(),TAuthor_FIRST_NAME(),TAuthor_LAST_NAME(),TAuthor_DATE_OF_BIRTH()).values(""String_Node_Str"",f,l,0L);
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
q.execute();
assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),create().selectFrom(TAuthor()).orderBy(TAuthor_ID()).fetch(TAuthor_FIRST_NAME()));
}",0.9974293059125964
150522,"@Test public void testFetchLater() throws Exception {
  Future<Result<B>> later;
  Result<B> result;
  int activeCount=Thread.activeCount();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  assertFalse(later.isDone());
  assertFalse(later.isCancelled());
  assertEquals(activeCount + 1,Thread.activeCount());
  result=later.get();
  Thread.sleep(500);
  assertEquals(activeCount,Thread.activeCount());
  result=later.get();
  result=later.get(1000,TimeUnit.MILLISECONDS);
  assertEquals(4,result.size());
  assertEquals(BOOK_IDS,result.getValues(TBook_ID()));
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  assertEquals(activeCount + 4,Thread.activeCount());
  later=null;
  System.gc();
  System.gc();
  Thread.sleep(500);
  assertEquals(activeCount,Thread.activeCount());
}","@Test public void testFetchLater() throws Exception {
  Future<Result<B>> later;
  Result<B> result;
  int activeCount=Thread.activeCount();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  assertFalse(later.isDone());
  assertFalse(later.isCancelled());
  assertEquals(activeCount + 1,Thread.activeCount());
  result=later.get();
  Thread.sleep(500);
  assertEquals(activeCount,Thread.activeCount());
  result=later.get();
  result=later.get(1000,TimeUnit.MILLISECONDS);
  assertEquals(4,result.size());
  assertEquals(BOOK_IDS,result.getValues(TBook_ID()));
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  later=create().selectFrom(TBook()).orderBy(TBook_ID()).fetchLater();
  assertEquals(activeCount + 3,Thread.activeCount());
  later=null;
  System.gc();
  System.gc();
  Thread.sleep(500);
  assertEquals(activeCount,Thread.activeCount());
}",0.9635910224438904
150523,"@Test public void testSystemFunctions() throws Exception {
  if (getDialect() == SQLDialect.SQLITE) {
    log.info(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  Field<?> user=trim(lower(currentUser()));
  Record record=create().select(user).fetchOne();
  assertTrue(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").contains(record.getValue(user)));
}","@Test public void testSystemFunctions() throws Exception {
  if (getDialect() == SQLDialect.SQLITE) {
    log.info(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  Field<?> user=trim(lower(currentUser()));
  Record record=create().select(user).fetchOne();
  assertTrue(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").contains(record.getValue(user)));
}",0.980477223427332
150524,"@Test public void testSchemaMapping() throws Exception {
switch (getDialect()) {
case SQLITE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  return;
}
Settings settings=new Settings().withRenderMapping(new RenderMapping().withSchemata(new MappedSchema().withInput(TAuthor().getSchema().getName()).withOutput(TAuthor().getSchema().getName()).withTables(new MappedTable().withInput(TAuthor().getName()).withOutput(TAuthor().getName()),new MappedTable().withInput(TBook().getName()).withOutput(TBook().getName()))));
Select<Record> query=create(settings).select(TBook_TITLE()).from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())).orderBy(TBook_ID().asc());
Result<Record> result=query.fetch();
assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(3,TBook_TITLE()));
String sql=query.getSQL();
log.info(""String_Node_Str"",sql);
assertEquals(result,create().fetch(sql,query.getBindValues().toArray()));
switch (getDialect()) {
case ASE:
case DB2:
case DERBY:
case H2:
case HSQLDB:
case INGRES:
case ORACLE:
case POSTGRES:
case SQLITE:
case SQLSERVER:
case SYBASE:
log.info(""String_Node_Str"",""String_Node_Str"");
return;
case MYSQL:
if (delegate.getClass() == jOOQMySQLTestSchemaRewrite.class) {
log.info(""String_Node_Str"",""String_Node_Str"");
return;
}
}
settings=new Settings().withRenderMapping(new RenderMapping().withSchemata(new MappedSchema().withInput(TAuthor().getSchema().getName()).withOutput(TAuthor().getSchema().getName() + ""String_Node_Str"")));
Select<Record> q=create(settings).select(TBook_TITLE()).from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())).orderBy(TBook_ID().asc());
assertTrue(create(settings).render(q).contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertTrue(q.getSQL().contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertEquals(create(settings).render(q),q.getSQL());
result=q.fetch();
assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(3,TBook_TITLE()));
Field<Integer> f1=FOneField().cast(Integer.class);
Field<Integer> f2=FNumberField(42).cast(Integer.class);
q=create(settings).select(f1,f2);
assertTrue(create(settings).render(q).contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertTrue(q.getSQL().contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertEquals(create(settings).render(q),q.getSQL());
Record record=q.fetchOne();
assertEquals(1,(int)record.getValue(f1));
assertEquals(42,(int)record.getValue(f2));
settings=new Settings().withRenderMapping(new RenderMapping().withSchemata(new MappedSchema().withInput(TAuthor().getSchema().getName()).withOutput(TAuthor().getSchema().getName() + ""String_Node_Str"").withTables(new MappedTable().withInput(TAuthor().getName()).withOutput(VAuthor().getName()),new MappedTable().withInput(TBook().getName()).withOutput(VBook().getName()))));
q=create(settings).select(TBook_TITLE()).from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())).orderBy(TBook_ID().asc());
assertTrue(create(settings).render(q).contains(VAuthor().getName()));
assertTrue(create(settings).render(q).contains(VBook().getName()));
assertTrue(create(settings).render(q).contains(""String_Node_Str""));
assertFalse(create(settings).render(q).contains(TAuthor().getName()));
assertFalse(create(settings).render(q).contains(TBook().getName()));
result=q.fetch();
assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(3,TBook_TITLE()));
}","@Test public void testSchemaMapping() throws Exception {
switch (getDialect()) {
case SQLITE:
    log.info(""String_Node_Str"",""String_Node_Str"");
  return;
}
Settings settings=new Settings().withRenderMapping(new RenderMapping().withSchemata(new MappedSchema().withInput(TAuthor().getSchema().getName()).withOutput(TAuthor().getSchema().getName()).withTables(new MappedTable().withInput(TAuthor().getName()).withOutput(TAuthor().getName()),new MappedTable().withInput(TBook().getName()).withOutput(TBook().getName()))));
Select<Record> query=create(settings).select(TBook_TITLE()).from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())).orderBy(TBook_ID().asc());
Result<Record> result=query.fetch();
assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(3,TBook_TITLE()));
String sql=query.getSQL();
log.info(""String_Node_Str"",sql);
assertEquals(result,create().fetch(sql,query.getBindValues().toArray()));
switch (getDialect()) {
case ASE:
case CUBRID:
case DB2:
case DERBY:
case H2:
case HSQLDB:
case INGRES:
case ORACLE:
case POSTGRES:
case SQLITE:
case SQLSERVER:
case SYBASE:
log.info(""String_Node_Str"",""String_Node_Str"");
return;
case MYSQL:
if (delegate.getClass() == jOOQMySQLTestSchemaRewrite.class) {
log.info(""String_Node_Str"",""String_Node_Str"");
return;
}
}
settings=new Settings().withRenderMapping(new RenderMapping().withSchemata(new MappedSchema().withInput(TAuthor().getSchema().getName()).withOutput(TAuthor().getSchema().getName() + ""String_Node_Str"")));
Select<Record> q=create(settings).select(TBook_TITLE()).from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())).orderBy(TBook_ID().asc());
assertTrue(create(settings).render(q).contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertTrue(q.getSQL().contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertEquals(create(settings).render(q),q.getSQL());
result=q.fetch();
assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(3,TBook_TITLE()));
Field<Integer> f1=FOneField().cast(Integer.class);
Field<Integer> f2=FNumberField(42).cast(Integer.class);
q=create(settings).select(f1,f2);
assertTrue(create(settings).render(q).contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertTrue(q.getSQL().contains(TAuthor().getSchema().getName() + ""String_Node_Str""));
assertEquals(create(settings).render(q),q.getSQL());
Record record=q.fetchOne();
assertEquals(1,(int)record.getValue(f1));
assertEquals(42,(int)record.getValue(f2));
settings=new Settings().withRenderMapping(new RenderMapping().withSchemata(new MappedSchema().withInput(TAuthor().getSchema().getName()).withOutput(TAuthor().getSchema().getName() + ""String_Node_Str"").withTables(new MappedTable().withInput(TAuthor().getName()).withOutput(VAuthor().getName()),new MappedTable().withInput(TBook().getName()).withOutput(VBook().getName()))));
q=create(settings).select(TBook_TITLE()).from(TAuthor()).join(TBook()).on(TAuthor_ID().equal(TBook_AUTHOR_ID())).orderBy(TBook_ID().asc());
assertTrue(create(settings).render(q).contains(VAuthor().getName()));
assertTrue(create(settings).render(q).contains(VBook().getName()));
assertTrue(create(settings).render(q).contains(""String_Node_Str""));
assertFalse(create(settings).render(q).contains(TAuthor().getName()));
assertFalse(create(settings).render(q).contains(TBook().getName()));
result=q.fetch();
assertEquals(""String_Node_Str"",result.getValue(0,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(1,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(2,TBook_TITLE()));
assertEquals(""String_Node_Str"",result.getValue(3,TBook_TITLE()));
}",0.9983711314371632
150525,"@Override protected TableField<T_639NumbersTableRecord,Byte> T639_BYTE(){
  return T_639NumbersTable.BYTE;
}","@Override protected TableField<T_639NumbersTableRecord,Byte> T639_BYTE(){
  return null;
}",0.8888888888888888
150526,"private static Time getTime(SQLDialect dialect,ResultSet rs,int index) throws SQLException {
  if (dialect == SQLDialect.SQLITE) {
    String time=rs.getString(index);
    if (time != null) {
      return new Time(parse(""String_Node_Str"",time));
    }
    return null;
  }
 else {
    return rs.getTime(index);
  }
}","private static Time getTime(SQLDialect dialect,ResultSet rs,int index) throws SQLException {
  if (dialect == SQLDialect.SQLITE) {
    String time=rs.getString(index);
    if (time != null) {
      return new Time(parse(""String_Node_Str"",time));
    }
    return null;
  }
 else   if (dialect == CUBRID) {
    Time time=rs.getTime(index);
    if (time != null) {
      Calendar cal=Calendar.getInstance();
      cal.setTimeInMillis(time.getTime());
      cal.set(Calendar.MILLISECOND,0);
      time=new Time(cal.getTimeInMillis());
    }
    return time;
  }
 else {
    return rs.getTime(index);
  }
}",0.673202614379085
150527,"private static Date getDate(SQLDialect dialect,ResultSet rs,int index) throws SQLException {
  if (dialect == SQLDialect.SQLITE) {
    String date=rs.getString(index);
    if (date != null) {
      return new Date(parse(""String_Node_Str"",date));
    }
    return null;
  }
 else   if (dialect == CUBRID) {
    Date date=rs.getDate(index);
    if (date != null) {
      date=new Date((rs.getDate(index).getTime() / 1000) * 1000);
    }
    return date;
  }
 else {
    return rs.getDate(index);
  }
}","private static Date getDate(SQLDialect dialect,ResultSet rs,int index) throws SQLException {
  if (dialect == SQLDialect.SQLITE) {
    String date=rs.getString(index);
    if (date != null) {
      return new Date(parse(""String_Node_Str"",date));
    }
    return null;
  }
 else   if (dialect == CUBRID) {
    Date date=rs.getDate(index);
    if (date != null) {
      Calendar cal=Calendar.getInstance();
      cal.setTimeInMillis(date.getTime());
      cal.set(Calendar.MILLISECOND,0);
      date=new Date(cal.getTimeInMillis());
    }
    return date;
  }
 else {
    return rs.getDate(index);
  }
}",0.7356948228882834
150528,"@Override public void stateChanged(ChangeEvent e){
  if (!isAdjusting && editorTabbedPane.getSelectedIndex() == editorTabbedPane.getTabCount() - 1) {
    addSQLEditorPane(databaseDescriptor);
  }
}","@Override public void stateChanged(ChangeEvent e){
  int selectedIndex=editorTabbedPane.getSelectedIndex();
  Component tabComponent2=editorTabbedPane.getTabComponentAt(selectedIndex);
  closeLabel.setVisible(tabComponent2 == tabComponent && editorTabbedPane.getTabCount() > 2);
}",0.3941299790356394
150529,"private void addSQLEditorPane(DatabaseDescriptor databaseDescriptor){
  isAdjusting=true;
  int index=editorTabbedPane.getTabCount() - 1;
  final EditorPane sqlEditorPane=new EditorPane(databaseDescriptor);
  String title=""String_Node_Str"" + contextCount++;
  editorTabbedPane.insertTab(title,null,sqlEditorPane,null,index);
  final JPanel tabComponent=new JPanel(new BorderLayout());
  tabComponent.setOpaque(false);
  tabComponent.add(new JLabel(title),BorderLayout.CENTER);
  final JLabel closeLabel=new JLabel(new ImageIcon(getClass().getResource(""String_Node_Str"")));
  closeLabel.addMouseListener(new MouseAdapter(){
    @Override public void mouseReleased(    MouseEvent e){
      if (!closeLabel.contains(e.getPoint())) {
        return;
      }
      isAdjusting=true;
      if (editorTabbedPane.getTabCount() > 2) {
        for (int i=editorTabbedPane.getTabCount() - 1; i >= 0; i--) {
          if (editorTabbedPane.getTabComponentAt(i) == tabComponent) {
            ((EditorPane)editorTabbedPane.getComponentAt(i)).closeConnection();
            editorTabbedPane.removeTabAt(i);
            if (i == editorTabbedPane.getTabCount() - 1) {
              editorTabbedPane.setSelectedIndex(i - 1);
            }
            break;
          }
        }
      }
      isAdjusting=false;
    }
    @Override public void mouseEntered(    MouseEvent e){
      if (editorTabbedPane.getTabCount() > 2) {
        closeLabel.setIcon(new ImageIcon(getClass().getResource(""String_Node_Str"")));
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      closeLabel.setIcon(new ImageIcon(getClass().getResource(""String_Node_Str"")));
    }
  }
);
  tabComponent.add(closeLabel,BorderLayout.EAST);
  editorTabbedPane.setTabComponentAt(index,tabComponent);
  editorTabbedPane.setSelectedIndex(index);
  isAdjusting=false;
  sqlEditorPane.adjustDefaultFocus();
}","private void addSQLEditorPane(DatabaseDescriptor databaseDescriptor){
  isAdjusting=true;
  int index=editorTabbedPane.getTabCount() - 1;
  final EditorPane sqlEditorPane=new EditorPane(databaseDescriptor);
  String title=""String_Node_Str"" + contextCount++;
  editorTabbedPane.insertTab(title,null,sqlEditorPane,null,index);
  final JPanel tabComponent=new JPanel(new BorderLayout());
  tabComponent.setOpaque(false);
  tabComponent.add(new JLabel(title),BorderLayout.CENTER);
  final JLabel closeLabel=new JLabel(new ImageIcon(getClass().getResource(""String_Node_Str"")));
  closeLabel.setBorder(BorderFactory.createEmptyBorder(0,2,0,0));
  closeLabel.addMouseListener(new MouseAdapter(){
    @Override public void mouseReleased(    MouseEvent e){
      if (!closeLabel.contains(e.getPoint())) {
        return;
      }
      isAdjusting=true;
      if (editorTabbedPane.getTabCount() > 2) {
        for (int i=editorTabbedPane.getTabCount() - 1; i >= 0; i--) {
          if (editorTabbedPane.getTabComponentAt(i) == tabComponent) {
            ((EditorPane)editorTabbedPane.getComponentAt(i)).closeConnection();
            editorTabbedPane.removeTabAt(i);
            if (i == editorTabbedPane.getTabCount() - 1) {
              editorTabbedPane.setSelectedIndex(i - 1);
            }
            break;
          }
        }
      }
      isAdjusting=false;
    }
    @Override public void mouseEntered(    MouseEvent e){
      if (editorTabbedPane.getTabCount() > 2) {
        closeLabel.setIcon(new ImageIcon(getClass().getResource(""String_Node_Str"")));
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      closeLabel.setIcon(new ImageIcon(getClass().getResource(""String_Node_Str"")));
    }
  }
);
  editorTabbedPane.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      int selectedIndex=editorTabbedPane.getSelectedIndex();
      Component tabComponent2=editorTabbedPane.getTabComponentAt(selectedIndex);
      closeLabel.setVisible(tabComponent2 == tabComponent && editorTabbedPane.getTabCount() > 2);
    }
  }
);
  tabComponent.add(closeLabel,BorderLayout.EAST);
  editorTabbedPane.setTabComponentAt(index,tabComponent);
  editorTabbedPane.setSelectedIndex(index);
  isAdjusting=false;
  sqlEditorPane.adjustDefaultFocus();
}",0.8955295242648816
150530,"@Override public void run(){
  startButton.setVisible(true);
  stopButton.setVisible(false);
}","@Override public void run(){
  startButton.setVisible(true);
  stopButton.setVisible(false);
  stopButton.setToolTipText(null);
}",0.8430493273542601
150531,"private void evaluate_unrestricted_nothread(final String sql,final int maxDisplayedRowCount){
  closeConnection();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      startButton.setVisible(false);
      stopButton.setVisible(true);
      stopButton.setToolTipText(""String_Node_Str"" + Utils.formatDateTimeTZ(new Date()));
    }
  }
);
  try {
    conn=databaseDescriptor.createConnection();
    stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);
    final long start=System.currentTimeMillis();
    if (evaluationThread != Thread.currentThread()) {
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(System.currentTimeMillis() - start),true);
        }
      }
);
      return;
    }
    boolean executeResult;
    try {
      executeResult=stmt.execute(sql);
    }
 catch (    SQLException e) {
      if (evaluationThread != Thread.currentThread()) {
        SwingUtilities.invokeLater(new Runnable(){
          @Override public void run(){
            setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(System.currentTimeMillis() - start),true);
          }
        }
);
        return;
      }
      throw e;
    }
    final long duration=System.currentTimeMillis() - start;
    if (evaluationThread != Thread.currentThread()) {
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(duration),true);
        }
      }
);
      return;
    }
    do {
      if (executeResult) {
        final ResultSet rs=stmt.getResultSet();
        ResultSetMetaData metaData=rs.getMetaData();
        final String[] columnNames=new String[metaData.getColumnCount() + 1];
        final int[] columnTypes=new int[columnNames.length];
        final TypeInfo[] typeInfos=new TypeInfo[columnNames.length];
        final Class<?>[] columnClasses=new Class[columnNames.length];
        columnNames[0]=""String_Node_Str"";
        columnClasses[0]=Integer.class;
        for (int i=1; i < columnNames.length; i++) {
          columnNames[i]=metaData.getColumnName(i);
          if (columnNames[i] == null || columnNames[i].length() == 0) {
            columnNames[i]=""String_Node_Str"";
          }
          typeInfos[i]=new TypeInfo(metaData,i);
          int type=metaData.getColumnType(i);
          columnTypes[i]=type;
switch (type) {
case Types.CLOB:
            columnClasses[i]=String.class;
          break;
case Types.BLOB:
        columnClasses[i]=byte[].class;
      break;
default :
    String columnClassName=metaData.getColumnClassName(i);
  if (columnClassName == null) {
    System.err.println(""String_Node_Str"" + columnNames[i] + ""String_Node_Str""+ metaData.getColumnTypeName(i));
    columnClasses[i]=Object.class;
  }
 else {
    columnClasses[i]=Class.forName(columnClassName);
  }
break;
}
}
if (evaluationThread != Thread.currentThread()) {
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(duration),true);
}
}
);
return;
}
final List<Object[]> rowDataList=new ArrayList<Object[]>();
int rowCount=0;
long rsStart=System.currentTimeMillis();
while (rs.next() && (!isUsingMaxRowCount || rowCount < MAX_ROW_COUNT)) {
if (evaluationThread != Thread.currentThread()) {
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
  setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(duration),true);
}
}
);
return;
}
rowCount++;
Object[] rowData=new Object[columnNames.length];
rowData[0]=rowCount;
for (int i=1; i < columnNames.length; i++) {
switch (columnTypes[i]) {
case Types.CLOB:
{
  Clob clob=rs.getClob(i);
  if (clob != null) {
    StringWriter stringWriter=new StringWriter();
    char[] chars=new char[1024];
    Reader reader=new BufferedReader(clob.getCharacterStream());
    for (int count; (count=reader.read(chars)) >= 0; ) {
      stringWriter.write(chars,0,count);
    }
    rowData[i]=stringWriter.toString();
  }
 else {
    rowData[i]=null;
  }
  break;
}
case Types.BLOB:
{
Blob blob=rs.getBlob(i);
if (blob != null) {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  byte[] bytes=new byte[1024];
  InputStream in=new BufferedInputStream(blob.getBinaryStream());
  for (int count; (count=in.read(bytes)) >= 0; ) {
    baos.write(bytes,0,count);
  }
  rowData[i]=baos.toByteArray();
}
 else {
  rowData[i]=null;
}
break;
}
default :
Object object=rs.getObject(i);
if (object != null) {
String className=object.getClass().getName();
if (""String_Node_Str"".equals(className) || ""String_Node_Str"".equals(className)) {
object=rs.getTimestamp(i);
}
}
rowData[i]=object;
break;
}
}
if (rowCount <= maxDisplayedRowCount) {
rowDataList.add(rowData);
}
 else if (rowCount == maxDisplayedRowCount + 1) {
rowDataList.clear();
}
}
final long rsDuration=System.currentTimeMillis() - rsStart;
final int rowCount_=rowCount;
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
addResultTable(sql,duration,rs,columnNames,typeInfos,columnClasses,rowDataList,rowCount_,rsDuration,maxDisplayedRowCount);
}
}
);
}
 else {
final int updateCount=stmt.getUpdateCount();
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
setMessage(addResultPane(),Utils.formatDuration(duration) + ""String_Node_Str"" + updateCount+ ""String_Node_Str"",false);
}
}
);
}
if (databaseDescriptor.getSQLDialect() == SQLDialect.SQLSERVER) {
try {
executeResult=stmt.getMoreResults(Statement.KEEP_CURRENT_RESULT);
}
 catch (Exception e) {
executeResult=stmt.getMoreResults();
}
}
 else {
executeResult=false;
}
}
 while (executeResult || stmt.getUpdateCount() != -1);
}
 catch (Exception e) {
StringWriter stringWriter=new StringWriter();
e.printStackTrace(new PrintWriter(stringWriter));
final String message=stringWriter.toString();
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
setMessage(addResultPane(),message,true);
}
}
);
}
 finally {
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
startButton.setVisible(true);
stopButton.setVisible(false);
}
}
);
if (!isDBEditable) {
closeConnection();
}
}
}","private void evaluate_unrestricted_nothread(final String sql,final int maxDisplayedRowCount){
  closeConnection();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      startButton.setVisible(false);
      stopButton.setVisible(true);
      stopButton.setToolTipText(""String_Node_Str"" + Utils.formatDateTimeTZ(new Date()));
    }
  }
);
  try {
    conn=databaseDescriptor.createConnection();
    stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);
    final long start=System.currentTimeMillis();
    if (evaluationThread != Thread.currentThread()) {
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(System.currentTimeMillis() - start),true);
        }
      }
);
      return;
    }
    boolean executeResult;
    try {
      executeResult=stmt.execute(sql);
    }
 catch (    SQLException e) {
      if (evaluationThread != Thread.currentThread()) {
        SwingUtilities.invokeLater(new Runnable(){
          @Override public void run(){
            setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(System.currentTimeMillis() - start),true);
          }
        }
);
        return;
      }
      throw e;
    }
    final long duration=System.currentTimeMillis() - start;
    if (evaluationThread != Thread.currentThread()) {
      SwingUtilities.invokeLater(new Runnable(){
        @Override public void run(){
          setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(duration),true);
        }
      }
);
      return;
    }
    do {
      if (executeResult) {
        final ResultSet rs=stmt.getResultSet();
        ResultSetMetaData metaData=rs.getMetaData();
        final String[] columnNames=new String[metaData.getColumnCount() + 1];
        final int[] columnTypes=new int[columnNames.length];
        final TypeInfo[] typeInfos=new TypeInfo[columnNames.length];
        final Class<?>[] columnClasses=new Class[columnNames.length];
        columnNames[0]=""String_Node_Str"";
        columnClasses[0]=Integer.class;
        for (int i=1; i < columnNames.length; i++) {
          columnNames[i]=metaData.getColumnName(i);
          if (columnNames[i] == null || columnNames[i].length() == 0) {
            columnNames[i]=""String_Node_Str"";
          }
          typeInfos[i]=new TypeInfo(metaData,i);
          int type=metaData.getColumnType(i);
          columnTypes[i]=type;
switch (type) {
case Types.CLOB:
            columnClasses[i]=String.class;
          break;
case Types.BLOB:
        columnClasses[i]=byte[].class;
      break;
default :
    String columnClassName=metaData.getColumnClassName(i);
  if (columnClassName == null) {
    System.err.println(""String_Node_Str"" + columnNames[i] + ""String_Node_Str""+ metaData.getColumnTypeName(i));
    columnClasses[i]=Object.class;
  }
 else {
    columnClasses[i]=Class.forName(columnClassName);
  }
break;
}
}
if (evaluationThread != Thread.currentThread()) {
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(duration),true);
}
}
);
return;
}
final List<Object[]> rowDataList=new ArrayList<Object[]>();
int rowCount=0;
long rsStart=System.currentTimeMillis();
while (rs.next() && (!isUsingMaxRowCount || rowCount < MAX_ROW_COUNT)) {
if (evaluationThread != Thread.currentThread()) {
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
  setMessage(addResultPane(),""String_Node_Str"" + Utils.formatDuration(duration),true);
}
}
);
return;
}
rowCount++;
Object[] rowData=new Object[columnNames.length];
rowData[0]=rowCount;
for (int i=1; i < columnNames.length; i++) {
switch (columnTypes[i]) {
case Types.CLOB:
{
  Clob clob=rs.getClob(i);
  if (clob != null) {
    StringWriter stringWriter=new StringWriter();
    char[] chars=new char[1024];
    Reader reader=new BufferedReader(clob.getCharacterStream());
    for (int count; (count=reader.read(chars)) >= 0; ) {
      stringWriter.write(chars,0,count);
    }
    rowData[i]=stringWriter.toString();
  }
 else {
    rowData[i]=null;
  }
  break;
}
case Types.BLOB:
{
Blob blob=rs.getBlob(i);
if (blob != null) {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  byte[] bytes=new byte[1024];
  InputStream in=new BufferedInputStream(blob.getBinaryStream());
  for (int count; (count=in.read(bytes)) >= 0; ) {
    baos.write(bytes,0,count);
  }
  rowData[i]=baos.toByteArray();
}
 else {
  rowData[i]=null;
}
break;
}
default :
Object object=rs.getObject(i);
if (object != null) {
String className=object.getClass().getName();
if (""String_Node_Str"".equals(className) || ""String_Node_Str"".equals(className)) {
object=rs.getTimestamp(i);
}
}
rowData[i]=object;
break;
}
}
if (rowCount <= maxDisplayedRowCount) {
rowDataList.add(rowData);
}
 else if (rowCount == maxDisplayedRowCount + 1) {
rowDataList.clear();
}
}
final long rsDuration=System.currentTimeMillis() - rsStart;
final int rowCount_=rowCount;
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
addResultTable(sql,duration,rs,columnNames,typeInfos,columnClasses,rowDataList,rowCount_,rsDuration,maxDisplayedRowCount);
}
}
);
}
 else {
final int updateCount=stmt.getUpdateCount();
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
setMessage(addResultPane(),Utils.formatDuration(duration) + ""String_Node_Str"" + updateCount+ ""String_Node_Str"",false);
}
}
);
}
if (databaseDescriptor.getSQLDialect() == SQLDialect.SQLSERVER) {
try {
executeResult=stmt.getMoreResults(Statement.KEEP_CURRENT_RESULT);
}
 catch (Exception e) {
executeResult=stmt.getMoreResults();
}
}
 else {
executeResult=false;
}
}
 while (executeResult || stmt.getUpdateCount() != -1);
}
 catch (Exception e) {
StringWriter stringWriter=new StringWriter();
e.printStackTrace(new PrintWriter(stringWriter));
final String message=stringWriter.toString();
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
setMessage(addResultPane(),message,true);
}
}
);
}
 finally {
SwingUtilities.invokeLater(new Runnable(){
@Override public void run(){
startButton.setVisible(true);
stopButton.setVisible(false);
stopButton.setToolTipText(null);
}
}
);
if (!isDBEditable) {
closeConnection();
}
}
}",0.9973869665056616
150532,"EditorPane(DatabaseDescriptor databaseDescriptor){
  super(new BorderLayout());
  this.databaseDescriptor=databaseDescriptor;
  this.isDBEditable=!databaseDescriptor.isReadOnly();
  setOpaque(false);
  JPanel northPanel=new JPanel(new BorderLayout());
  northPanel.setOpaque(false);
  JToolBar northWestPanel=new JToolBar();
  northWestPanel.setOpaque(false);
  northWestPanel.setFloatable(false);
  startButton=new JButton(new ImageIcon(getClass().getResource(""String_Node_Str"")));
  startButton.setOpaque(false);
  startButton.setFocusable(false);
  startButton.setToolTipText(""String_Node_Str"");
  startButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      evaluateInternal();
    }
  }
);
  northWestPanel.add(startButton);
  stopButton=new JButton(new ImageIcon(getClass().getResource(""String_Node_Str"")));
  stopButton.setVisible(false);
  stopButton.setOpaque(false);
  stopButton.setFocusable(false);
  stopButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      evaluationThread=null;
      closeConnection();
    }
  }
);
  northWestPanel.add(stopButton);
  northPanel.add(northWestPanel,BorderLayout.WEST);
  JPanel northEastPanel=new JPanel(new FlowLayout(FlowLayout.CENTER,5,2));
  northEastPanel.setOpaque(false);
  JCheckBox limitCheckBox=new JCheckBox(""String_Node_Str"",isUsingMaxRowCount);
  limitCheckBox.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      isUsingMaxRowCount=e.getStateChange() == ItemEvent.SELECTED;
    }
  }
);
  limitCheckBox.setOpaque(false);
  northEastPanel.add(limitCheckBox);
  northEastPanel.add(Box.createHorizontalStrut(5));
  northEastPanel.add(new JLabel(""String_Node_Str""));
  NumberFormat numberFormat=NumberFormat.getIntegerInstance();
  displayedRowCountField=new JFormattedTextField(numberFormat);
  displayedRowCountField.setHorizontalAlignment(JFormattedTextField.RIGHT);
  displayedRowCountField.setValue(100000);
  displayedRowCountField.setColumns(7);
  northEastPanel.add(displayedRowCountField);
  northPanel.add(northEastPanel,BorderLayout.CENTER);
  add(northPanel,BorderLayout.NORTH);
  editorTextArea=new SqlTextArea();
  editorTextArea.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      boolean isControlDown=e.isControlDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_SPACE:
        if (isControlDown) {
          showCompletion();
        }
      break;
case KeyEvent.VK_F5:
    if (startButton.isEnabled()) {
      evaluateInternal();
    }
  break;
case KeyEvent.VK_ESCAPE:
new Thread(""String_Node_Str""){
  @Override public void run(){
    if (evaluationThread != null) {
      evaluationThread=null;
      closeConnection();
    }
  }
}
.start();
break;
}
}
}
);
RTextScrollPane editorTextAreaScrollPane=new RTextScrollPane(editorTextArea);
JSplitPane verticalSplitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,editorTextAreaScrollPane,southPanel);
add(verticalSplitPane,BorderLayout.CENTER);
verticalSplitPane.setDividerLocation(150);
}","EditorPane(DatabaseDescriptor databaseDescriptor){
  super(new BorderLayout());
  this.databaseDescriptor=databaseDescriptor;
  this.isDBEditable=!databaseDescriptor.isReadOnly();
  setOpaque(false);
  JPanel northPanel=new JPanel(new BorderLayout());
  northPanel.setOpaque(false);
  JToolBar northWestPanel=new JToolBar();
  northWestPanel.setOpaque(false);
  northWestPanel.setFloatable(false);
  startButton=new JButton(new ImageIcon(getClass().getResource(""String_Node_Str"")));
  startButton.setOpaque(false);
  startButton.setFocusable(false);
  startButton.setToolTipText(""String_Node_Str"");
  startButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      evaluateInternal();
    }
  }
);
  northWestPanel.add(startButton);
  stopButton=new JButton(new ImageIcon(getClass().getResource(""String_Node_Str"")));
  stopButton.setVisible(false);
  stopButton.setOpaque(false);
  stopButton.setFocusable(false);
  stopButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      evaluationThread=null;
      closeConnection();
    }
  }
);
  northWestPanel.add(stopButton);
  northPanel.add(northWestPanel,BorderLayout.WEST);
  JPanel northEastPanel=new JPanel(new FlowLayout(FlowLayout.CENTER,5,2));
  northEastPanel.setOpaque(false);
  JCheckBox limitCheckBox=new JCheckBox(""String_Node_Str"",isUsingMaxRowCount);
  limitCheckBox.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      isUsingMaxRowCount=e.getStateChange() == ItemEvent.SELECTED;
    }
  }
);
  limitCheckBox.setOpaque(false);
  northEastPanel.add(limitCheckBox);
  northEastPanel.add(Box.createHorizontalStrut(5));
  northEastPanel.add(new JLabel(""String_Node_Str""));
  NumberFormat numberFormat=NumberFormat.getIntegerInstance();
  displayedRowCountField=new JFormattedTextField(numberFormat);
  displayedRowCountField.setHorizontalAlignment(JFormattedTextField.RIGHT);
  displayedRowCountField.setValue(100000);
  displayedRowCountField.setColumns(7);
  northEastPanel.add(displayedRowCountField);
  northPanel.add(northEastPanel,BorderLayout.CENTER);
  add(northPanel,BorderLayout.NORTH);
  editorTextArea=new SqlTextArea();
  editorTextArea.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      boolean isControlDown=e.isControlDown();
switch (e.getKeyCode()) {
case KeyEvent.VK_SPACE:
        if (isControlDown) {
          showCompletion();
        }
      break;
case KeyEvent.VK_F5:
    if (startButton.isVisible()) {
      evaluateInternal();
    }
  break;
case KeyEvent.VK_ESCAPE:
new Thread(""String_Node_Str""){
  @Override public void run(){
    if (evaluationThread != null) {
      evaluationThread=null;
      closeConnection();
    }
  }
}
.start();
break;
}
}
}
);
RTextScrollPane editorTextAreaScrollPane=new RTextScrollPane(editorTextArea);
JSplitPane verticalSplitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,editorTextAreaScrollPane,southPanel);
add(verticalSplitPane,BorderLayout.CENTER);
verticalSplitPane.setDividerLocation(150);
}",0.9987212276214834
150533,"private void generate(Database database,SchemaDefinition schema,StopWatch watch) throws SQLException, IOException {
  File targetSchemaDir=strategy.getFile(schema).getParentFile();
  GenerationWriter outS=null;
  GenerationWriter outF=null;
  if (!schema.isDefaultSchema()) {
    log.info(""String_Node_Str"",strategy.getFileName(schema));
    log.info(""String_Node_Str"");
    outS=new GenerationWriter(strategy.getFile(schema));
    printHeader(outS,schema);
    printClassJavadoc(outS,schema);
    outS.print(""String_Node_Str"");
    outS.print(strategy.getJavaClassName(schema));
    outS.print(""String_Node_Str"");
    outS.print(SchemaImpl.class);
    outS.println(""String_Node_Str"");
    outS.printSerial();
    outS.println();
    outS.println(""String_Node_Str"");
    outS.println(""String_Node_Str"" + schema.getName());
    outS.println(""String_Node_Str"");
    outS.println(""String_Node_Str"" + strategy.getJavaClassName(schema) + ""String_Node_Str""+ strategy.getJavaIdentifierUC(schema)+ ""String_Node_Str""+ strategy.getJavaClassName(schema)+ ""String_Node_Str"");
    outS.println();
    printNoFurtherInstancesAllowedJavadoc(outS);
    outS.println(""String_Node_Str"" + strategy.getJavaClassName(schema) + ""String_Node_Str"");
    outS.println(""String_Node_Str"" + schema.getName() + ""String_Node_Str"");
    outS.println(""String_Node_Str"");
    outS.printInitialisationStatementsPlaceholder();
    log.info(""String_Node_Str"",strategy.getFileName(schema,""String_Node_Str""));
    outF=new GenerationWriter(strategy.getFile(schema,""String_Node_Str""));
    printHeader(outF,schema);
    printClassJavadoc(outF,schema);
    outF.print(""String_Node_Str"");
    outF.print(strategy.getJavaClassName(schema,""String_Node_Str""));
    outF.print(""String_Node_Str"");
    outF.print(database.getDialect().getFactory());
    outF.println(""String_Node_Str"");
    outF.printSerial();
    outF.println();
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.print(""String_Node_Str"");
    outF.print(strategy.getJavaClassName(schema,""String_Node_Str""));
    outF.print(""String_Node_Str"");
    outF.print(Connection.class);
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println();
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.print(""String_Node_Str"");
    outF.print(strategy.getJavaClassName(schema,""String_Node_Str""));
    outF.print(""String_Node_Str"");
    outF.print(Connection.class);
    outF.print(""String_Node_Str"");
    outF.print(SchemaMapping.class);
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getSequences(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + schema.getName());
    out.println(""String_Node_Str"");
    for (    SequenceDefinition sequence : database.getSequences(schema)) {
      out.println();
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"" + sequence.getQualifiedName());
      out.println(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(Sequence.class);
      out.print(""String_Node_Str"");
      out.print(getJavaType(sequence.getType()));
      out.print(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(sequence));
      out.print(""String_Node_Str"");
      out.print(SequenceImpl.class);
      out.print(""String_Node_Str"");
      out.print(getJavaType(sequence.getType()));
      out.print(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(sequence.getName());
      out.print(""String_Node_Str"");
      if (!schema.isDefaultSchema()) {
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaIdentifierUC(schema));
      }
 else {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(getJavaTypeReference(sequence.getDatabase(),sequence.getType()));
      out.println(""String_Node_Str"");
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    registerInSchema(outS,database.getSequences(schema),Sequence.class,true);
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getMasterDataTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    MasterDataTableDefinition table : database.getMasterDataTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table));
        printHeader(out,table);
        printClassJavadoc(out,table);
        ColumnDefinition pk=table.getPrimaryKeyColumn();
        ColumnDefinition l=table.getLiteralColumn();
        ColumnDefinition d=table.getDescriptionColumn();
        Result<Record> data=table.getData();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table));
        out.print(""String_Node_Str"");
        out.print(MasterDataType.class);
        out.print(""String_Node_Str"");
        out.print(data.getField(pk.getName()).getType());
        out.println(""String_Node_Str"");
        Set<ColumnDefinition> columns=new LinkedHashSet<ColumnDefinition>(Arrays.asList(pk,l,d));
        for (        Record record : data) {
          String literal=record.getValueAsString(l.getName());
          String description=record.getValueAsString(d.getName());
          if (!StringUtils.isEmpty(description)) {
            out.println();
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"" + description);
            out.println(""String_Node_Str"");
          }
          out.print(""String_Node_Str"");
          out.print(GenerationUtil.convertToJavaIdentifierEnum(literal));
          out.print(""String_Node_Str"");
          String separator=""String_Node_Str"";
          for (          ColumnDefinition column : columns) {
            out.print(separator);
            out.printNewJavaObject(record.getValue(column.getName()));
            separator=""String_Node_Str"";
          }
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println();
        for (        ColumnDefinition column : columns) {
          out.print(""String_Node_Str"");
          out.print(data.getField(column.getName()).getType());
          out.print(""String_Node_Str"");
          out.println(strategy.getJavaClassNameLC(column) + ""String_Node_Str"");
        }
        out.println();
        out.print(""String_Node_Str"" + strategy.getJavaClassName(table) + ""String_Node_Str"");
        String separator=""String_Node_Str"";
        for (        ColumnDefinition column : columns) {
          out.print(separator);
          out.print(data.getField(column.getName()).getType());
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          separator=""String_Node_Str"";
        }
        out.println(""String_Node_Str"");
        for (        ColumnDefinition column : columns) {
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println();
        printOverride(out);
        out.print(""String_Node_Str"");
        out.print(data.getField(pk.getName()).getType());
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"" + strategy.getJavaClassNameLC(pk) + ""String_Node_Str"");
        out.println(""String_Node_Str"");
        for (        ColumnDefinition column : columns) {
          printFieldJavaDoc(out,column);
          out.print(""String_Node_Str"");
          out.print(data.getField(column.getName()).getType());
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassName(column));
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table));
        printHeader(out,table);
        printClassJavadoc(out,table);
        Class<?> baseClass;
        if (generateRelations() && table.getMainUniqueKey() != null) {
          baseClass=UpdatableTableImpl.class;
        }
 else {
          baseClass=TableImpl.class;
        }
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table));
        out.print(""String_Node_Str"");
        out.print(baseClass);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.printSerial();
        printSingletonInstance(table,out);
        printRecordTypeMethod(table,out);
        for (        ColumnDefinition column : table.getColumns()) {
          printTableColumn(out,column,table);
        }
        out.println();
        printNoFurtherInstancesAllowedJavadoc(out);
        out.println(""String_Node_Str"" + strategy.getJavaClassName(table) + ""String_Node_Str"");
        if (!schema.isDefaultSchema()) {
          out.println(""String_Node_Str"" + table.getName() + ""String_Node_Str""+ strategy.getFullJavaIdentifierUC(schema)+ ""String_Node_Str"");
        }
 else {
          out.println(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        if (generateInstanceFields()) {
          out.println();
          printNoFurtherInstancesAllowedJavadoc(out);
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassName(table));
          out.print(""String_Node_Str"");
          out.print(String.class);
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaIdentifierUC(schema));
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(table));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaIdentifierUC(table));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        if (generateRelations()) {
          ColumnDefinition identity=table.getIdentity();
          if (identity != null) {
            out.println();
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(Identity.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(getJavaType(table.getIdentity().getType()));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaPackageName(schema));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(identity.getContainer()));
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
          UniqueKeyDefinition mainKey=table.getMainUniqueKey();
          if (mainKey != null) {
            out.println();
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaPackageName(schema));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(mainKey));
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
          List<UniqueKeyDefinition> uniqueKeys=table.getUniqueKeys();
          if (uniqueKeys.size() > 0) {
            out.println();
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(List.class);
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(Arrays.class);
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            UniqueKeyDefinition uniqueKey : uniqueKeys) {
              out.print(separator);
              out.print(strategy.getJavaPackageName(schema));
              out.print(""String_Node_Str"");
              out.print(strategy.getJavaIdentifier(uniqueKey));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
          List<ForeignKeyDefinition> foreignKeys=table.getForeignKeys();
          if (foreignKeys.size() > 0) {
            out.println();
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(List.class);
            out.print(""String_Node_Str"");
            out.print(ForeignKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(Arrays.class);
            out.print(""String_Node_Str"");
            out.print(ForeignKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            ForeignKeyDefinition foreignKey : foreignKeys) {
              TableDefinition referencedTable=foreignKey.getReferencedTable();
              if (referencedTable instanceof MasterDataTableDefinition) {
                continue;
              }
              out.print(separator);
              out.print(strategy.getJavaPackageName(schema));
              out.print(""String_Node_Str"");
              out.print(strategy.getJavaIdentifier(foreignKey));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
        }
        if (generateInstanceFields()) {
          out.println();
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(table));
          out.print(""String_Node_Str"");
          out.print(String.class);
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(table));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        out.printStaticInitialisationStatementsPlaceholder();
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    registerInSchema(outS,database.getTables(schema),Table.class,true);
    watch.splitInfo(""String_Node_Str"");
  }
  if (generatePojos() && database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table,""String_Node_Str""));
        printHeader(out,table,""String_Node_Str"");
        printClassJavadoc(out,table);
        printTableJPAAnnotation(out,table);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table));
        out.print(""String_Node_Str"");
        out.println();
        out.printSerial();
        out.println();
        int maxLength=0;
        for (        ColumnDefinition column : table.getColumns()) {
          maxLength=Math.max(maxLength,getJavaType(column.getType()).length());
        }
        for (        ColumnDefinition column : table.getColumns()) {
          out.print(""String_Node_Str"");
          out.print(StringUtils.rightPad(getJavaType(column.getType()),maxLength));
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
        }
        for (        ColumnDefinition column : table.getColumns()) {
          out.println();
          printColumnJPAAnnotation(out,column);
          out.print(""String_Node_Str"");
          out.print(getJavaType(column.getType()));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaGetterName(column));
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
          out.println();
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaSetterName(column));
          out.print(""String_Node_Str"");
          out.print(getJavaType(column.getType()));
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + schema.getName());
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      out.println();
      out.println(""String_Node_Str"");
      if (!StringUtils.isBlank(table.getComment())) {
        out.println(""String_Node_Str"" + table.getComment());
      }
 else {
        out.println(""String_Node_Str"" + table.getQualifiedName());
      }
      out.println(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(table));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(table));
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(table));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(table));
      out.println(""String_Node_Str"");
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (generateRelations() && database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + schema.getName() + ""String_Node_Str"");
    out.suppressWarnings(""String_Node_Str"");
    out.print(""String_Node_Str"");
    out.print(AbstractKeys.class);
    out.println(""String_Node_Str"");
    out.println();
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        ColumnDefinition identity=table.getIdentity();
        if (identity != null) {
          out.print(""String_Node_Str"");
          out.print(Identity.class);
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(identity.getContainer(),""String_Node_Str""));
          out.print(""String_Node_Str"");
          out.print(getJavaType(identity.getType()));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaIdentifier(identity.getContainer()));
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaIdentifierUC(identity.getContainer()));
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaIdentifierUC(identity));
          out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    out.println();
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        List<UniqueKeyDefinition> uniqueKeys=table.getUniqueKeys();
        if (uniqueKeys.size() > 0) {
          for (          UniqueKeyDefinition uniqueKey : uniqueKeys) {
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(uniqueKey.getTable(),""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(uniqueKey));
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaIdentifierUC(uniqueKey.getTable()));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            ColumnDefinition column : uniqueKey.getKeyColumns()) {
              out.print(separator);
              out.print(strategy.getFullJavaIdentifierUC(column));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    out.println();
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        List<ForeignKeyDefinition> foreignKeys=table.getForeignKeys();
        if (foreignKeys.size() > 0) {
          for (          ForeignKeyDefinition foreignKey : foreignKeys) {
            if (foreignKey.getReferencedTable() instanceof MasterDataTableDefinition) {
              continue;
            }
            out.print(""String_Node_Str"");
            out.print(ForeignKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(foreignKey.getKeyTable(),""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(foreignKey.getReferencedTable(),""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(foreignKey));
            out.print(""String_Node_Str"");
            if (!foreignKey.getSchema().equals(foreignKey.getReferencedKey().getSchema())) {
              out.print(strategy.getJavaPackageName(foreignKey.getReferencedKey().getSchema()));
              out.print(""String_Node_Str"");
            }
            out.print(strategy.getJavaIdentifier(foreignKey.getReferencedKey()));
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaIdentifierUC(foreignKey.getKeyTable()));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            ColumnDefinition column : foreignKey.getKeyColumns()) {
              out.print(separator);
              out.print(strategy.getFullJavaIdentifierUC(column));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table,""String_Node_Str""));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table,""String_Node_Str""));
        printHeader(out,table,""String_Node_Str"");
        printClassJavadoc(out,table);
        printTableJPAAnnotation(out,table);
        Class<?> baseClass;
        if (generateRelations() && table.getMainUniqueKey() != null) {
          baseClass=UpdatableRecordImpl.class;
        }
 else {
          baseClass=TableRecordImpl.class;
        }
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(baseClass);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.printSerial();
        for (        ColumnDefinition column : table.getColumns()) {
          printGetterAndSetter(out,column);
        }
        out.println();
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"" + strategy.getJavaClassName(table,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"" + strategy.getJavaClassName(table,""String_Node_Str"") + ""String_Node_Str"");
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaIdentifierUC(table));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getUDTs(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(udt));
        GenerationWriter out=new GenerationWriter(strategy.getFile(udt));
        printHeader(out,udt);
        printClassJavadoc(out,udt);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(udt));
        out.print(""String_Node_Str"");
        out.print(UDTImpl.class);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(udt,""String_Node_Str""));
        out.print(""String_Node_Str"");
        if (udt.getRoutines().size() > 0) {
          out.print(""String_Node_Str"");
          out.print(org.jooq.Package.class);
        }
        out.println(""String_Node_Str"");
        out.printSerial();
        printSingletonInstance(udt,out);
        printRecordTypeMethod(udt,out);
        for (        AttributeDefinition attribute : udt.getAttributes()) {
          printUDTColumn(out,attribute,udt);
        }
        for (        RoutineDefinition routine : udt.getRoutines()) {
          try {
            if (!routine.isSQLUsable()) {
              printConvenienceMethodProcedure(out,routine,false);
            }
 else {
              printConvenienceMethodFunction(out,routine,false);
              printConvenienceMethodFunctionAsField(out,routine,false);
              printConvenienceMethodFunctionAsField(out,routine,true);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        out.println();
        printNoFurtherInstancesAllowedJavadoc(out);
        out.println(""String_Node_Str"" + strategy.getJavaClassName(udt) + ""String_Node_Str"");
        if (!schema.isDefaultSchema()) {
          out.println(""String_Node_Str"" + udt.getName() + ""String_Node_Str""+ strategy.getFullJavaIdentifierUC(schema)+ ""String_Node_Str"");
        }
 else {
          out.println(""String_Node_Str"" + udt.getName() + ""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
        if (outS != null) {
          outS.printInitialisationStatement(""String_Node_Str"" + schema.getName() + ""String_Node_Str""+ udt.getName()+ ""String_Node_Str""+ strategy.getFullJavaClassName(udt,""String_Node_Str"")+ ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + udt,e);
      }
    }
    registerInSchema(outS,database.getUDTs(schema),UDT.class,true);
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getUDTs(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(udt,""String_Node_Str""));
        GenerationWriter out=new GenerationWriter(strategy.getFile(udt,""String_Node_Str""));
        printHeader(out,udt,""String_Node_Str"");
        printClassJavadoc(out,udt);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(udt,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(UDTRecordImpl.class);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(udt,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.printSerial();
        out.println();
        for (        AttributeDefinition attribute : udt.getAttributes()) {
          printGetterAndSetter(out,attribute);
        }
        for (        RoutineDefinition routine : udt.getRoutines()) {
          try {
            if (!routine.isSQLUsable()) {
              printConvenienceMethodProcedure(out,routine,true);
            }
 else {
              printConvenienceMethodFunction(out,routine,true);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        out.println();
        out.println(""String_Node_Str"" + strategy.getJavaClassName(udt,""String_Node_Str"") + ""String_Node_Str"");
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaIdentifierUC(udt));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + udt,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getUDTs(schema).size() > 0) {
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      if (udt.getRoutines().size() > 0) {
        try {
          log.info(""String_Node_Str"");
          for (          RoutineDefinition routine : udt.getRoutines()) {
            try {
              printRoutine(database,schema,routine);
            }
 catch (            Exception e) {
              log.error(""String_Node_Str"" + routine,e);
            }
          }
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + udt,e);
        }
        watch.splitInfo(""String_Node_Str"");
      }
    }
  }
  if (database.getUDTs(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + schema.getName());
    out.println(""String_Node_Str"");
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      out.println();
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"" + udt.getQualifiedName());
      out.println(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(udt));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(udt));
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(udt));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(udt));
      out.println(""String_Node_Str"");
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getArrays(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    ArrayDefinition array : database.getArrays(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(array,""String_Node_Str""));
        GenerationWriter out=new GenerationWriter(strategy.getFile(array,""String_Node_Str""));
        printHeader(out,array,""String_Node_Str"");
        printClassJavadoc(out,array);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(ArrayRecordImpl.class);
        out.print(""String_Node_Str"");
        out.print(getJavaType(array.getElementType()));
        out.println(""String_Node_Str"");
        out.printSerial();
        out.println();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(Configuration.class);
        out.println(""String_Node_Str"");
        out.print(""String_Node_Str"");
        out.print(array.getSchema().getName());
        out.print(""String_Node_Str"");
        out.print(array.getName());
        out.print(""String_Node_Str"");
        out.print(getJavaTypeReference(database,array.getElementType()));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(Configuration.class);
        out.print(""String_Node_Str"");
        out.print(getJavaType(array.getElementType()));
        out.print(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(Configuration.class);
        out.print(""String_Node_Str"");
        out.print(List.class);
        out.print(""String_Node_Str"");
        out.print(getJavaType(array.getElementType()));
        out.print(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + array,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getEnums(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    EnumDefinition e : database.getEnums(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(e));
        GenerationWriter out=new GenerationWriter(strategy.getFile(e));
        printHeader(out,e);
        printClassJavadoc(out,e);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(e));
        out.print(""String_Node_Str"");
        out.print(EnumType.class);
        out.print(""String_Node_Str"");
        out.println();
        for (        String literal : e.getLiterals()) {
          out.println(""String_Node_Str"" + GenerationUtil.convertToJavaIdentifierEnum(literal) + ""String_Node_Str""+ literal+ ""String_Node_Str"");
          out.println();
        }
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"" + strategy.getJavaClassName(e) + ""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        if (e.isSynthetic()) {
          out.println(""String_Node_Str"");
        }
 else {
          out.println(""String_Node_Str"" + e.getName() + ""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception ex) {
        log.error(""String_Node_Str"" + e,ex);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getRoutines(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter outR=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(outR,schema);
    printClassJavadoc(outR,""String_Node_Str"" + schema.getName());
    outR.println(""String_Node_Str"");
    for (    RoutineDefinition routine : database.getRoutines(schema)) {
      try {
        printRoutine(database,schema,routine);
        if (!routine.isSQLUsable()) {
          printConvenienceMethodProcedure(outR,routine,false);
        }
 else {
          printConvenienceMethodFunction(outR,routine,false);
          printConvenienceMethodFunctionAsField(outR,routine,false);
          printConvenienceMethodFunctionAsField(outR,routine,true);
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + routine,e);
      }
    }
    printPrivateConstructor(outR,""String_Node_Str"");
    outR.println(""String_Node_Str"");
    outR.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getPackages(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    PackageDefinition pkg : database.getPackages(schema)) {
      try {
        log.info(""String_Node_Str"",pkg);
        for (        RoutineDefinition routine : pkg.getRoutines()) {
          try {
            printRoutine(database,schema,routine);
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        GenerationWriter outPkg=new GenerationWriter(strategy.getFile(pkg));
        printHeader(outPkg,pkg);
        printClassJavadoc(outPkg,""String_Node_Str"" + pkg.getName());
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getJavaClassName(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(PackageImpl.class);
        outPkg.println(""String_Node_Str"");
        outPkg.printSerial();
        outPkg.println();
        outPkg.println(""String_Node_Str"");
        outPkg.println(""String_Node_Str"" + strategy.getJavaIdentifierUC(pkg));
        outPkg.println(""String_Node_Str"");
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getFullJavaClassName(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getJavaIdentifierUC(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getFullJavaClassName(pkg));
        outPkg.println(""String_Node_Str"");
        for (        RoutineDefinition routine : pkg.getRoutines()) {
          try {
            if (!routine.isSQLUsable()) {
              printConvenienceMethodProcedure(outPkg,routine,false);
            }
 else {
              printConvenienceMethodFunction(outPkg,routine,false);
              printConvenienceMethodFunctionAsField(outPkg,routine,false);
              printConvenienceMethodFunctionAsField(outPkg,routine,true);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        printNoFurtherInstancesAllowedJavadoc(outPkg);
        outPkg.println(""String_Node_Str"" + strategy.getJavaClassName(pkg) + ""String_Node_Str"");
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getJavaIdentifierUC(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getFullJavaIdentifierUC(schema));
        outPkg.println(""String_Node_Str"");
        outPkg.println(""String_Node_Str"");
        outPkg.println(""String_Node_Str"");
        outPkg.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + pkg,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (outS != null) {
    outS.println(""String_Node_Str"");
    outS.close();
  }
  if (outF != null) {
    outF.println(""String_Node_Str"");
    outF.close();
  }
  watch.splitInfo(""String_Node_Str"");
}","private void generate(Database database,SchemaDefinition schema,StopWatch watch) throws SQLException, IOException {
  File targetSchemaDir=strategy.getFile(schema).getParentFile();
  GenerationWriter outS=null;
  GenerationWriter outF=null;
  if (!schema.isDefaultSchema()) {
    log.info(""String_Node_Str"",strategy.getFileName(schema));
    log.info(""String_Node_Str"");
    outS=new GenerationWriter(strategy.getFile(schema));
    printHeader(outS,schema);
    printClassJavadoc(outS,schema);
    outS.print(""String_Node_Str"");
    outS.print(strategy.getJavaClassName(schema));
    outS.print(""String_Node_Str"");
    outS.print(SchemaImpl.class);
    outS.println(""String_Node_Str"");
    outS.printSerial();
    outS.println();
    outS.println(""String_Node_Str"");
    outS.println(""String_Node_Str"" + database.getOutputSchema(schema.getName()));
    outS.println(""String_Node_Str"");
    outS.println(""String_Node_Str"" + strategy.getJavaClassName(schema) + ""String_Node_Str""+ strategy.getJavaIdentifierUC(schema)+ ""String_Node_Str""+ strategy.getJavaClassName(schema)+ ""String_Node_Str"");
    outS.println();
    printNoFurtherInstancesAllowedJavadoc(outS);
    outS.println(""String_Node_Str"" + strategy.getJavaClassName(schema) + ""String_Node_Str"");
    outS.println(""String_Node_Str"" + database.getOutputSchema(schema.getName()) + ""String_Node_Str"");
    outS.println(""String_Node_Str"");
    outS.printInitialisationStatementsPlaceholder();
    log.info(""String_Node_Str"",strategy.getFileName(schema,""String_Node_Str""));
    outF=new GenerationWriter(strategy.getFile(schema,""String_Node_Str""));
    printHeader(outF,schema);
    printClassJavadoc(outF,schema);
    outF.print(""String_Node_Str"");
    outF.print(strategy.getJavaClassName(schema,""String_Node_Str""));
    outF.print(""String_Node_Str"");
    outF.print(database.getDialect().getFactory());
    outF.println(""String_Node_Str"");
    outF.printSerial();
    outF.println();
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.print(""String_Node_Str"");
    outF.print(strategy.getJavaClassName(schema,""String_Node_Str""));
    outF.print(""String_Node_Str"");
    outF.print(Connection.class);
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println();
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.print(""String_Node_Str"");
    outF.print(strategy.getJavaClassName(schema,""String_Node_Str""));
    outF.print(""String_Node_Str"");
    outF.print(Connection.class);
    outF.print(""String_Node_Str"");
    outF.print(SchemaMapping.class);
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    outF.println(""String_Node_Str"");
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getSequences(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + database.getOutputSchema(schema.getName()));
    out.println(""String_Node_Str"");
    for (    SequenceDefinition sequence : database.getSequences(schema)) {
      out.println();
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"" + sequence.getQualifiedName());
      out.println(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(Sequence.class);
      out.print(""String_Node_Str"");
      out.print(getJavaType(sequence.getType()));
      out.print(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(sequence));
      out.print(""String_Node_Str"");
      out.print(SequenceImpl.class);
      out.print(""String_Node_Str"");
      out.print(getJavaType(sequence.getType()));
      out.print(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(sequence.getName());
      out.print(""String_Node_Str"");
      if (!schema.isDefaultSchema()) {
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaIdentifierUC(schema));
      }
 else {
        out.print(""String_Node_Str"");
      }
      out.print(""String_Node_Str"");
      out.print(getJavaTypeReference(sequence.getDatabase(),sequence.getType()));
      out.println(""String_Node_Str"");
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    registerInSchema(outS,database.getSequences(schema),Sequence.class,true);
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getMasterDataTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    MasterDataTableDefinition table : database.getMasterDataTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table));
        printHeader(out,table);
        printClassJavadoc(out,table);
        ColumnDefinition pk=table.getPrimaryKeyColumn();
        ColumnDefinition l=table.getLiteralColumn();
        ColumnDefinition d=table.getDescriptionColumn();
        Result<Record> data=table.getData();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table));
        out.print(""String_Node_Str"");
        out.print(MasterDataType.class);
        out.print(""String_Node_Str"");
        out.print(data.getField(pk.getName()).getType());
        out.println(""String_Node_Str"");
        Set<ColumnDefinition> columns=new LinkedHashSet<ColumnDefinition>(Arrays.asList(pk,l,d));
        for (        Record record : data) {
          String literal=record.getValueAsString(l.getName());
          String description=record.getValueAsString(d.getName());
          if (!StringUtils.isEmpty(description)) {
            out.println();
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"" + description);
            out.println(""String_Node_Str"");
          }
          out.print(""String_Node_Str"");
          out.print(GenerationUtil.convertToJavaIdentifierEnum(literal));
          out.print(""String_Node_Str"");
          String separator=""String_Node_Str"";
          for (          ColumnDefinition column : columns) {
            out.print(separator);
            out.printNewJavaObject(record.getValue(column.getName()));
            separator=""String_Node_Str"";
          }
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println();
        for (        ColumnDefinition column : columns) {
          out.print(""String_Node_Str"");
          out.print(data.getField(column.getName()).getType());
          out.print(""String_Node_Str"");
          out.println(strategy.getJavaClassNameLC(column) + ""String_Node_Str"");
        }
        out.println();
        out.print(""String_Node_Str"" + strategy.getJavaClassName(table) + ""String_Node_Str"");
        String separator=""String_Node_Str"";
        for (        ColumnDefinition column : columns) {
          out.print(separator);
          out.print(data.getField(column.getName()).getType());
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          separator=""String_Node_Str"";
        }
        out.println(""String_Node_Str"");
        for (        ColumnDefinition column : columns) {
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println();
        printOverride(out);
        out.print(""String_Node_Str"");
        out.print(data.getField(pk.getName()).getType());
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"" + strategy.getJavaClassNameLC(pk) + ""String_Node_Str"");
        out.println(""String_Node_Str"");
        for (        ColumnDefinition column : columns) {
          printFieldJavaDoc(out,column);
          out.print(""String_Node_Str"");
          out.print(data.getField(column.getName()).getType());
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassName(column));
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassNameLC(column));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table));
        printHeader(out,table);
        printClassJavadoc(out,table);
        Class<?> baseClass;
        if (generateRelations() && table.getMainUniqueKey() != null) {
          baseClass=UpdatableTableImpl.class;
        }
 else {
          baseClass=TableImpl.class;
        }
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table));
        out.print(""String_Node_Str"");
        out.print(baseClass);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.printSerial();
        printSingletonInstance(table,out);
        printRecordTypeMethod(table,out);
        for (        ColumnDefinition column : table.getColumns()) {
          printTableColumn(out,column,table);
        }
        out.println();
        printNoFurtherInstancesAllowedJavadoc(out);
        out.println(""String_Node_Str"" + strategy.getJavaClassName(table) + ""String_Node_Str"");
        if (!schema.isDefaultSchema()) {
          out.println(""String_Node_Str"" + table.getName() + ""String_Node_Str""+ strategy.getFullJavaIdentifierUC(schema)+ ""String_Node_Str"");
        }
 else {
          out.println(""String_Node_Str"" + table.getName() + ""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        if (generateInstanceFields()) {
          out.println();
          printNoFurtherInstancesAllowedJavadoc(out);
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaClassName(table));
          out.print(""String_Node_Str"");
          out.print(String.class);
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaIdentifierUC(schema));
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(table));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaIdentifierUC(table));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        if (generateRelations()) {
          ColumnDefinition identity=table.getIdentity();
          if (identity != null) {
            out.println();
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(Identity.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(getJavaType(table.getIdentity().getType()));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaPackageName(schema));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(identity.getContainer()));
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
          UniqueKeyDefinition mainKey=table.getMainUniqueKey();
          if (mainKey != null) {
            out.println();
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaPackageName(schema));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(mainKey));
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
          List<UniqueKeyDefinition> uniqueKeys=table.getUniqueKeys();
          if (uniqueKeys.size() > 0) {
            out.println();
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(List.class);
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(Arrays.class);
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            UniqueKeyDefinition uniqueKey : uniqueKeys) {
              out.print(separator);
              out.print(strategy.getJavaPackageName(schema));
              out.print(""String_Node_Str"");
              out.print(strategy.getJavaIdentifier(uniqueKey));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
          List<ForeignKeyDefinition> foreignKeys=table.getForeignKeys();
          if (foreignKeys.size() > 0) {
            out.println();
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(List.class);
            out.print(""String_Node_Str"");
            out.print(ForeignKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.println(""String_Node_Str"");
            out.print(""String_Node_Str"");
            out.print(Arrays.class);
            out.print(""String_Node_Str"");
            out.print(ForeignKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            ForeignKeyDefinition foreignKey : foreignKeys) {
              TableDefinition referencedTable=foreignKey.getReferencedTable();
              if (referencedTable instanceof MasterDataTableDefinition) {
                continue;
              }
              out.print(separator);
              out.print(strategy.getJavaPackageName(schema));
              out.print(""String_Node_Str"");
              out.print(strategy.getJavaIdentifier(foreignKey));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
            out.println(""String_Node_Str"");
          }
        }
        if (generateInstanceFields()) {
          out.println();
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(table));
          out.print(""String_Node_Str"");
          out.print(String.class);
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(table));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        out.printStaticInitialisationStatementsPlaceholder();
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    registerInSchema(outS,database.getTables(schema),Table.class,true);
    watch.splitInfo(""String_Node_Str"");
  }
  if (generatePojos() && database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table,""String_Node_Str""));
        printHeader(out,table,""String_Node_Str"");
        printClassJavadoc(out,table);
        printTableJPAAnnotation(out,table);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table));
        out.print(""String_Node_Str"");
        out.println();
        out.printSerial();
        out.println();
        int maxLength=0;
        for (        ColumnDefinition column : table.getColumns()) {
          maxLength=Math.max(maxLength,getJavaType(column.getType()).length());
        }
        for (        ColumnDefinition column : table.getColumns()) {
          out.print(""String_Node_Str"");
          out.print(StringUtils.rightPad(getJavaType(column.getType()),maxLength));
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
        }
        for (        ColumnDefinition column : table.getColumns()) {
          out.println();
          printColumnJPAAnnotation(out,column);
          out.print(""String_Node_Str"");
          out.print(getJavaType(column.getType()));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaGetterName(column));
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
          out.println();
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaSetterName(column));
          out.print(""String_Node_Str"");
          out.print(getJavaType(column.getType()));
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.print(""String_Node_Str"");
          out.print(convertToJavaIdentifierEnum(strategy.getJavaClassNameLC(column)));
          out.println(""String_Node_Str"");
          out.println(""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + database.getOutputSchema(schema.getName()));
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      out.println();
      out.println(""String_Node_Str"");
      if (!StringUtils.isBlank(table.getComment())) {
        out.println(""String_Node_Str"" + table.getComment());
      }
 else {
        out.println(""String_Node_Str"" + table.getQualifiedName());
      }
      out.println(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(table));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(table));
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(table));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(table));
      out.println(""String_Node_Str"");
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (generateRelations() && database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + database.getOutputSchema(schema.getName()) + ""String_Node_Str"");
    out.suppressWarnings(""String_Node_Str"");
    out.print(""String_Node_Str"");
    out.print(AbstractKeys.class);
    out.println(""String_Node_Str"");
    out.println();
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        ColumnDefinition identity=table.getIdentity();
        if (identity != null) {
          out.print(""String_Node_Str"");
          out.print(Identity.class);
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaClassName(identity.getContainer(),""String_Node_Str""));
          out.print(""String_Node_Str"");
          out.print(getJavaType(identity.getType()));
          out.print(""String_Node_Str"");
          out.print(strategy.getJavaIdentifier(identity.getContainer()));
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaIdentifierUC(identity.getContainer()));
          out.print(""String_Node_Str"");
          out.print(strategy.getFullJavaIdentifierUC(identity));
          out.println(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    out.println();
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        List<UniqueKeyDefinition> uniqueKeys=table.getUniqueKeys();
        if (uniqueKeys.size() > 0) {
          for (          UniqueKeyDefinition uniqueKey : uniqueKeys) {
            out.print(""String_Node_Str"");
            out.print(UniqueKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(uniqueKey.getTable(),""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(uniqueKey));
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaIdentifierUC(uniqueKey.getTable()));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            ColumnDefinition column : uniqueKey.getKeyColumns()) {
              out.print(separator);
              out.print(strategy.getFullJavaIdentifierUC(column));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    out.println();
    out.println(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        List<ForeignKeyDefinition> foreignKeys=table.getForeignKeys();
        if (foreignKeys.size() > 0) {
          for (          ForeignKeyDefinition foreignKey : foreignKeys) {
            if (foreignKey.getReferencedTable() instanceof MasterDataTableDefinition) {
              continue;
            }
            out.print(""String_Node_Str"");
            out.print(ForeignKey.class);
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(foreignKey.getKeyTable(),""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaClassName(foreignKey.getReferencedTable(),""String_Node_Str""));
            out.print(""String_Node_Str"");
            out.print(strategy.getJavaIdentifier(foreignKey));
            out.print(""String_Node_Str"");
            if (!foreignKey.getSchema().equals(foreignKey.getReferencedKey().getSchema())) {
              out.print(strategy.getJavaPackageName(foreignKey.getReferencedKey().getSchema()));
              out.print(""String_Node_Str"");
            }
            out.print(strategy.getJavaIdentifier(foreignKey.getReferencedKey()));
            out.print(""String_Node_Str"");
            out.print(strategy.getFullJavaIdentifierUC(foreignKey.getKeyTable()));
            out.print(""String_Node_Str"");
            String separator=""String_Node_Str"";
            for (            ColumnDefinition column : foreignKey.getKeyColumns()) {
              out.print(separator);
              out.print(strategy.getFullJavaIdentifierUC(column));
              separator=""String_Node_Str"";
            }
            out.println(""String_Node_Str"");
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getTables(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    TableDefinition table : database.getTables(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(table,""String_Node_Str""));
        GenerationWriter out=new GenerationWriter(strategy.getFile(table,""String_Node_Str""));
        printHeader(out,table,""String_Node_Str"");
        printClassJavadoc(out,table);
        printTableJPAAnnotation(out,table);
        Class<?> baseClass;
        if (generateRelations() && table.getMainUniqueKey() != null) {
          baseClass=UpdatableRecordImpl.class;
        }
 else {
          baseClass=TableRecordImpl.class;
        }
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(table,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(baseClass);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(table,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.printSerial();
        for (        ColumnDefinition column : table.getColumns()) {
          printGetterAndSetter(out,column);
        }
        out.println();
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"" + strategy.getJavaClassName(table,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"" + strategy.getJavaClassName(table,""String_Node_Str"") + ""String_Node_Str"");
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaIdentifierUC(table));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + table,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getUDTs(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(udt));
        GenerationWriter out=new GenerationWriter(strategy.getFile(udt));
        printHeader(out,udt);
        printClassJavadoc(out,udt);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(udt));
        out.print(""String_Node_Str"");
        out.print(UDTImpl.class);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(udt,""String_Node_Str""));
        out.print(""String_Node_Str"");
        if (udt.getRoutines().size() > 0) {
          out.print(""String_Node_Str"");
          out.print(org.jooq.Package.class);
        }
        out.println(""String_Node_Str"");
        out.printSerial();
        printSingletonInstance(udt,out);
        printRecordTypeMethod(udt,out);
        for (        AttributeDefinition attribute : udt.getAttributes()) {
          printUDTColumn(out,attribute,udt);
        }
        for (        RoutineDefinition routine : udt.getRoutines()) {
          try {
            if (!routine.isSQLUsable()) {
              printConvenienceMethodProcedure(out,routine,false);
            }
 else {
              printConvenienceMethodFunction(out,routine,false);
              printConvenienceMethodFunctionAsField(out,routine,false);
              printConvenienceMethodFunctionAsField(out,routine,true);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        out.println();
        printNoFurtherInstancesAllowedJavadoc(out);
        out.println(""String_Node_Str"" + strategy.getJavaClassName(udt) + ""String_Node_Str"");
        if (!schema.isDefaultSchema()) {
          out.println(""String_Node_Str"" + udt.getName() + ""String_Node_Str""+ strategy.getFullJavaIdentifierUC(schema)+ ""String_Node_Str"");
        }
 else {
          out.println(""String_Node_Str"" + udt.getName() + ""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
        if (outS != null) {
          outS.printInitialisationStatement(""String_Node_Str"" + database.getOutputSchema(schema.getName()) + ""String_Node_Str""+ udt.getName()+ ""String_Node_Str""+ strategy.getFullJavaClassName(udt,""String_Node_Str"")+ ""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + udt,e);
      }
    }
    registerInSchema(outS,database.getUDTs(schema),UDT.class,true);
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getUDTs(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(udt,""String_Node_Str""));
        GenerationWriter out=new GenerationWriter(strategy.getFile(udt,""String_Node_Str""));
        printHeader(out,udt,""String_Node_Str"");
        printClassJavadoc(out,udt);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(udt,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(UDTRecordImpl.class);
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaClassName(udt,""String_Node_Str""));
        out.println(""String_Node_Str"");
        out.printSerial();
        out.println();
        for (        AttributeDefinition attribute : udt.getAttributes()) {
          printGetterAndSetter(out,attribute);
        }
        for (        RoutineDefinition routine : udt.getRoutines()) {
          try {
            if (!routine.isSQLUsable()) {
              printConvenienceMethodProcedure(out,routine,true);
            }
 else {
              printConvenienceMethodFunction(out,routine,true);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        out.println();
        out.println(""String_Node_Str"" + strategy.getJavaClassName(udt,""String_Node_Str"") + ""String_Node_Str"");
        out.print(""String_Node_Str"");
        out.print(strategy.getFullJavaIdentifierUC(udt));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + udt,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getUDTs(schema).size() > 0) {
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      if (udt.getRoutines().size() > 0) {
        try {
          log.info(""String_Node_Str"");
          for (          RoutineDefinition routine : udt.getRoutines()) {
            try {
              printRoutine(database,schema,routine);
            }
 catch (            Exception e) {
              log.error(""String_Node_Str"" + routine,e);
            }
          }
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"" + udt,e);
        }
        watch.splitInfo(""String_Node_Str"");
      }
    }
  }
  if (database.getUDTs(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter out=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(out,schema);
    printClassJavadoc(out,""String_Node_Str"" + database.getOutputSchema(schema.getName()));
    out.println(""String_Node_Str"");
    for (    UDTDefinition udt : database.getUDTs(schema)) {
      out.println();
      out.println(""String_Node_Str"");
      out.println(""String_Node_Str"" + udt.getQualifiedName());
      out.println(""String_Node_Str"");
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(udt));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(udt));
      out.print(""String_Node_Str"");
      out.print(strategy.getFullJavaClassName(udt));
      out.print(""String_Node_Str"");
      out.print(strategy.getJavaIdentifierUC(udt));
      out.println(""String_Node_Str"");
    }
    printPrivateConstructor(out,""String_Node_Str"");
    out.println(""String_Node_Str"");
    out.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getArrays(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    ArrayDefinition array : database.getArrays(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(array,""String_Node_Str""));
        GenerationWriter out=new GenerationWriter(strategy.getFile(array,""String_Node_Str""));
        printHeader(out,array,""String_Node_Str"");
        printClassJavadoc(out,array);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(ArrayRecordImpl.class);
        out.print(""String_Node_Str"");
        out.print(getJavaType(array.getElementType()));
        out.println(""String_Node_Str"");
        out.printSerial();
        out.println();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(Configuration.class);
        out.println(""String_Node_Str"");
        out.print(""String_Node_Str"");
        out.print(array.getSchema().getName());
        out.print(""String_Node_Str"");
        out.print(array.getName());
        out.print(""String_Node_Str"");
        out.print(getJavaTypeReference(database,array.getElementType()));
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(Configuration.class);
        out.print(""String_Node_Str"");
        out.print(getJavaType(array.getElementType()));
        out.print(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println();
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(array,""String_Node_Str""));
        out.print(""String_Node_Str"");
        out.print(Configuration.class);
        out.print(""String_Node_Str"");
        out.print(List.class);
        out.print(""String_Node_Str"");
        out.print(getJavaType(array.getElementType()));
        out.print(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + array,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getEnums(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    EnumDefinition e : database.getEnums(schema)) {
      try {
        log.info(""String_Node_Str"",strategy.getFileName(e));
        GenerationWriter out=new GenerationWriter(strategy.getFile(e));
        printHeader(out,e);
        printClassJavadoc(out,e);
        out.print(""String_Node_Str"");
        out.print(strategy.getJavaClassName(e));
        out.print(""String_Node_Str"");
        out.print(EnumType.class);
        out.print(""String_Node_Str"");
        out.println();
        for (        String literal : e.getLiterals()) {
          out.println(""String_Node_Str"" + GenerationUtil.convertToJavaIdentifierEnum(literal) + ""String_Node_Str""+ literal+ ""String_Node_Str"");
          out.println();
        }
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"" + strategy.getJavaClassName(e) + ""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        if (e.isSynthetic()) {
          out.println(""String_Node_Str"");
        }
 else {
          out.println(""String_Node_Str"" + e.getName() + ""String_Node_Str"");
        }
        out.println(""String_Node_Str"");
        out.println();
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.close();
      }
 catch (      Exception ex) {
        log.error(""String_Node_Str"" + e,ex);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getRoutines(schema).size() > 0) {
    log.info(""String_Node_Str"");
    GenerationWriter outR=new GenerationWriter(new File(targetSchemaDir,""String_Node_Str""));
    printHeader(outR,schema);
    printClassJavadoc(outR,""String_Node_Str"" + database.getOutputSchema(schema.getName()));
    outR.println(""String_Node_Str"");
    for (    RoutineDefinition routine : database.getRoutines(schema)) {
      try {
        printRoutine(database,schema,routine);
        if (!routine.isSQLUsable()) {
          printConvenienceMethodProcedure(outR,routine,false);
        }
 else {
          printConvenienceMethodFunction(outR,routine,false);
          printConvenienceMethodFunctionAsField(outR,routine,false);
          printConvenienceMethodFunctionAsField(outR,routine,true);
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + routine,e);
      }
    }
    printPrivateConstructor(outR,""String_Node_Str"");
    outR.println(""String_Node_Str"");
    outR.close();
    watch.splitInfo(""String_Node_Str"");
  }
  if (database.getPackages(schema).size() > 0) {
    log.info(""String_Node_Str"");
    for (    PackageDefinition pkg : database.getPackages(schema)) {
      try {
        log.info(""String_Node_Str"",pkg);
        for (        RoutineDefinition routine : pkg.getRoutines()) {
          try {
            printRoutine(database,schema,routine);
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        GenerationWriter outPkg=new GenerationWriter(strategy.getFile(pkg));
        printHeader(outPkg,pkg);
        printClassJavadoc(outPkg,""String_Node_Str"" + pkg.getName());
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getJavaClassName(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(PackageImpl.class);
        outPkg.println(""String_Node_Str"");
        outPkg.printSerial();
        outPkg.println();
        outPkg.println(""String_Node_Str"");
        outPkg.println(""String_Node_Str"" + strategy.getJavaIdentifierUC(pkg));
        outPkg.println(""String_Node_Str"");
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getFullJavaClassName(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getJavaIdentifierUC(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getFullJavaClassName(pkg));
        outPkg.println(""String_Node_Str"");
        for (        RoutineDefinition routine : pkg.getRoutines()) {
          try {
            if (!routine.isSQLUsable()) {
              printConvenienceMethodProcedure(outPkg,routine,false);
            }
 else {
              printConvenienceMethodFunction(outPkg,routine,false);
              printConvenienceMethodFunctionAsField(outPkg,routine,false);
              printConvenienceMethodFunctionAsField(outPkg,routine,true);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"" + routine,e);
          }
        }
        printNoFurtherInstancesAllowedJavadoc(outPkg);
        outPkg.println(""String_Node_Str"" + strategy.getJavaClassName(pkg) + ""String_Node_Str"");
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getJavaIdentifierUC(pkg));
        outPkg.print(""String_Node_Str"");
        outPkg.print(strategy.getFullJavaIdentifierUC(schema));
        outPkg.println(""String_Node_Str"");
        outPkg.println(""String_Node_Str"");
        outPkg.println(""String_Node_Str"");
        outPkg.close();
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"" + pkg,e);
      }
    }
    watch.splitInfo(""String_Node_Str"");
  }
  if (outS != null) {
    outS.println(""String_Node_Str"");
    outS.close();
  }
  if (outF != null) {
    outF.println(""String_Node_Str"");
    outF.close();
  }
  watch.splitInfo(""String_Node_Str"");
}",0.9957961114030478
150534,"private String getJavaClassName0(Definition definition,String suffix){
  StringBuilder result=new StringBuilder();
  String name=GenerationUtil.convertToJavaIdentifier(definition.getName());
  result.append(StringUtils.toCamelCase(name));
  if (!""String_Node_Str"".equals(suffix) && !StringUtils.isEmpty(suffix)) {
    result.append(suffix);
  }
  if (!StringUtils.isBlank(definition.getOverload())) {
    result.append(definition.getOverload());
  }
  return result.toString();
}","private String getJavaClassName0(Definition definition,String suffix){
  StringBuilder result=new StringBuilder();
  String n=(definition instanceof SchemaDefinition) ? definition.getDatabase().getOutputSchema(definition.getName()) : definition.getName();
  String name=GenerationUtil.convertToJavaIdentifier(n);
  result.append(StringUtils.toCamelCase(name));
  if (!""String_Node_Str"".equals(suffix) && !StringUtils.isEmpty(suffix)) {
    result.append(suffix);
  }
  if (!StringUtils.isBlank(definition.getOverload())) {
    result.append(definition.getOverload());
  }
  return result.toString();
}",0.85
150535,"@Override public String getJavaIdentifier(Definition definition){
  return GenerationUtil.convertToJavaIdentifier(definition.getName());
}","@Override public String getJavaIdentifier(Definition definition){
  String n=(definition instanceof SchemaDefinition) ? definition.getDatabase().getOutputSchema(definition.getName()) : definition.getName();
  return GenerationUtil.convertToJavaIdentifier(n);
}",0.592964824120603
150536,"@Override public final List<SchemaDefinition> getSchemata(){
  if (schemata == null) {
    schemata=new ArrayList<SchemaDefinition>();
    for (    String name : getInputSchemata()) {
      schemata.add(new SchemaDefinition(this,getOutputSchema(name),null));
    }
  }
  return schemata;
}","@Override public final List<SchemaDefinition> getSchemata(){
  if (schemata == null) {
    schemata=new ArrayList<SchemaDefinition>();
    for (    String name : getInputSchemata()) {
      schemata.add(new SchemaDefinition(this,name,null));
    }
  }
  return schemata;
}",0.9554367201426024
150537,"@Override public final SchemaDefinition getSchema(String name){
  for (  SchemaDefinition schema : getSchemata()) {
    if (schema.getName().equals(getOutputSchema(name))) {
      return schema;
    }
  }
  return null;
}","@Override public final SchemaDefinition getSchema(String inputName){
  for (  SchemaDefinition schema : getSchemata()) {
    if (schema.getName().equals(inputName)) {
      return schema;
    }
  }
  return null;
}",0.928735632183908
150538,"@Override public final String getQualifiedName(){
  if (StringUtils.isBlank(getSchema().getName())) {
    return getName();
  }
 else {
    return getSchema().getName() + ""String_Node_Str"" + getName();
  }
}","@Override public final String getQualifiedName(){
  if (StringUtils.isBlank(getSchema().getName())) {
    return getName();
  }
 else {
    return getDatabase().getOutputSchema(getSchema().getName()) + ""String_Node_Str"" + getName();
  }
}",0.8853932584269663
150539,"@Override public final String getQualifiedName(){
  if (StringUtils.isBlank(getSchema().getName())) {
    return getContainer().getName() + ""String_Node_Str"" + getName();
  }
 else {
    return getSchema().getName() + ""String_Node_Str"" + getContainer().getName()+ ""String_Node_Str""+ getName();
  }
}","@Override public final String getQualifiedName(){
  if (StringUtils.isBlank(getSchema().getName())) {
    return getContainer().getName() + ""String_Node_Str"" + getName();
  }
 else {
    return getDatabase().getOutputSchema(getSchema().getName()) + ""String_Node_Str"" + getContainer().getName()+ ""String_Node_Str""+ getName();
  }
}",0.918918918918919
150540,"@Override public final String getQualifiedName(){
  return getName();
}","@Override public final String getQualifiedName(){
  return getDatabase().getOutputSchema(getName());
}",0.8208092485549133
150541,"@Override public final void toSQL(RenderContext context){
  if (context.declareFields() || context.declareTables()) {
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    context.sql(aliasProvider);
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    if (Arrays.asList(DERBY,HSQLDB,MYSQL,POSTGRES).contains(context.getDialect())) {
      context.sql(""String_Node_Str"");
    }
    context.sql(""String_Node_Str"");
    context.literal(alias);
switch (context.getDialect()) {
case HSQLDB:
case POSTGRES:
{
        if (context.declareTables() && aliasProvider instanceof ArrayTable) {
          Object o=aliasProvider;
          ArrayTable table=(ArrayTable)o;
          context.sql(""String_Node_Str"");
          Util.toSQLNames(context,table.getFields());
          context.sql(""String_Node_Str"");
        }
        break;
      }
  }
}
 else {
  context.literal(alias);
}
}","@Override public final void toSQL(RenderContext context){
  if (context.declareFields() || context.declareTables()) {
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    context.sql(aliasProvider);
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    if (Arrays.asList(DERBY,HSQLDB,MYSQL,POSTGRES).contains(context.getDialect())) {
      context.sql(""String_Node_Str"");
    }
    context.sql(""String_Node_Str"");
    context.literal(alias);
switch (context.getDialect()) {
case HSQLDB:
case POSTGRES:
{
        Object o=aliasProvider;
        if (context.declareTables() && o instanceof ArrayTable) {
          ArrayTable table=(ArrayTable)o;
          context.sql(""String_Node_Str"");
          Util.toSQLNames(context,table.getFields());
          context.sql(""String_Node_Str"");
        }
        break;
      }
  }
}
 else {
  context.literal(alias);
}
}",0.9199561403508772
150542,"private final Table<?> getTable(String name) throws Exception {
  if (schema() == null) {
    Class<?> tables=Class.forName(""String_Node_Str"" + getDialect().getName().toLowerCase() + ""String_Node_Str"");
    return (Table<?>)tables.getField(name).get(tables);
  }
 else {
    Table<?> result=schema().getTable(name);
    if (result == null) {
      result=schema().getTable(name.toUpperCase());
    }
    if (result == null) {
      result=schema().getTable(name.toLowerCase());
    }
    return result;
  }
}","private final Table<?> getTable(String name) throws Exception {
  Schema schema=TAuthor().getSchema();
  if (schema == null) {
    Class<?> tables=Class.forName(""String_Node_Str"" + getDialect().getName().toLowerCase() + ""String_Node_Str"");
    return (Table<?>)tables.getField(name).get(tables);
  }
 else {
    Table<?> result=schema.getTable(name);
    if (result == null) {
      result=schema.getTable(name.toUpperCase());
    }
    if (result == null) {
      result=schema.getTable(name.toLowerCase());
    }
    return result;
  }
}",0.9551098376313276
150543,"@SuppressWarnings(""String_Node_Str"") private final InsertImpl<R> values0(List<Field<?>> values){
  if (fields.size() == 0) {
    fields.addAll(into.getFields());
  }
  if (fields.size() != values.size()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  getDelegate().newRecord();
  for (int i=0; i < fields.size(); i++) {
    getDelegate().addValue((Field<Object>)fields.get(i),(Field<Object>)values.get(i));
  }
  return this;
}","@SuppressWarnings(""String_Node_Str"") private final InsertImpl<R> values0(List<Field<?>> values){
  if (fields.size() == 0) {
    fields.addAll(into.getFields());
  }
  if (fields.size() != values.size()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  getDelegate().newRecord();
  for (int i=0; i < fields.size(); i++) {
    getDelegate().addValue((Field<Void>)fields.get(i),(Field<Void>)values.get(i));
  }
  return this;
}",0.9775280898876404
150544,"@Override public final void toSQL(RenderContext context){
  if (context.declareFields() || context.declareTables()) {
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    context.sql(aliasProvider);
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
switch (context.getDialect()) {
case POSTGRES:
case HSQLDB:
case DERBY:
case MYSQL:
      context.sql(""String_Node_Str"");
    break;
}
context.sql(""String_Node_Str"");
context.literal(alias);
switch (context.getDialect()) {
case HSQLDB:
case POSTGRES:
{
    if (context.declareTables() && aliasProvider instanceof ArrayTable) {
      Table<?> table=(Table<?>)aliasProvider;
      context.sql(""String_Node_Str"");
      JooqUtil.toSQLNames(context,table.getFields());
      context.sql(""String_Node_Str"");
    }
    break;
  }
}
}
 else {
context.literal(alias);
}
}","@Override public final void toSQL(RenderContext context){
  if (context.declareFields() || context.declareTables()) {
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    context.sql(aliasProvider);
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
switch (context.getDialect()) {
case POSTGRES:
case HSQLDB:
case DERBY:
case MYSQL:
      context.sql(""String_Node_Str"");
    break;
}
context.sql(""String_Node_Str"");
context.literal(alias);
switch (context.getDialect()) {
case HSQLDB:
case POSTGRES:
{
    if (context.declareTables() && aliasProvider instanceof ArrayTable) {
      Object o=aliasProvider;
      ArrayTable<?> table=(ArrayTable<?>)o;
      context.sql(""String_Node_Str"");
      JooqUtil.toSQLNames(context,table.getFields());
      context.sql(""String_Node_Str"");
    }
    break;
  }
}
}
 else {
context.literal(alias);
}
}",0.9690721649484536
150545,"@Override public final void toSQL(RenderContext context){
  if (context.declareFields() || context.declareTables()) {
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    context.sql(aliasProvider);
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
switch (context.getDialect()) {
case POSTGRES:
case HSQLDB:
case DERBY:
case MYSQL:
      context.sql(""String_Node_Str"");
    break;
}
context.sql(""String_Node_Str"");
context.literal(alias);
switch (context.getDialect()) {
case HSQLDB:
case POSTGRES:
{
    if (context.declareTables() && aliasProvider instanceof ArrayTable) {
      ArrayTable<?> table=(ArrayTable<?>)aliasProvider;
      context.sql(""String_Node_Str"");
      table.getFields().toSQLNames(context);
      context.sql(""String_Node_Str"");
    }
    break;
  }
}
}
 else {
context.literal(alias);
}
}","@Override public final void toSQL(RenderContext context){
  if (context.declareFields() || context.declareTables()) {
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
    context.sql(aliasProvider);
    if (wrapInParentheses) {
      context.sql(""String_Node_Str"");
    }
switch (context.getDialect()) {
case POSTGRES:
case HSQLDB:
case DERBY:
case MYSQL:
      context.sql(""String_Node_Str"");
    break;
}
context.sql(""String_Node_Str"");
context.literal(alias);
switch (context.getDialect()) {
case HSQLDB:
case POSTGRES:
{
    if (context.declareTables() && aliasProvider instanceof ArrayTable) {
      Table<?> table=(Table<?>)aliasProvider;
      context.sql(""String_Node_Str"");
      JooqUtil.toSQLNames(context,table.getFields());
      context.sql(""String_Node_Str"");
    }
    break;
  }
}
}
 else {
context.literal(alias);
}
}",0.9691681210005816
150546,"private void toSQL0(RenderContext context){
  if (usingSyntax) {
    context.sql(""String_Node_Str"");
    using.toSQLNames(context);
    context.sql(""String_Node_Str"");
  }
 else {
    context.sql(""String_Node_Str"").sql(getCondition());
  }
}","private void toSQL0(RenderContext context){
  if (usingSyntax) {
    context.sql(""String_Node_Str"");
    JooqUtil.toSQLNames(context,using);
    context.sql(""String_Node_Str"");
  }
 else {
    context.sql(""String_Node_Str"").sql(getCondition());
  }
}",0.9613034623217924
150547,"/** 
 * Whether this data type is any binary type. This applies to any of these types. <ul> <li>   {@link SQLDataType#BINARY}</li> <li>   {@link SQLDataType#BLOB}</li> <li>   {@link SQLDataType#LONGVARBINARY}</li> <li>   {@link SQLDataType#VARBINARY}</li> </ul>
 * @return
 */
boolean isBinary();","/** 
 * Whether this data type is any binary type. This applies to any of these types. <ul> <li>   {@link SQLDataType#BINARY}</li> <li>   {@link SQLDataType#BLOB}</li> <li>   {@link SQLDataType#LONGVARBINARY}</li> <li>   {@link SQLDataType#VARBINARY}</li> </ul>
 */
boolean isBinary();",0.9810671256454389
150548,"/** 
 * Whether this data type is any date or time type. This applies to any of these types. <ul> <li>   {@link SQLDataType#DATE}</li> <li>   {@link SQLDataType#TIME}</li> <li>   {@link SQLDataType#TIMESTAMP}</li> </ul>
 * @return
 */
boolean isTemporal();","/** 
 * Whether this data type is any date or time type. This applies to any of these types. <ul> <li>   {@link SQLDataType#DATE}</li> <li>   {@link SQLDataType#TIME}</li> <li>   {@link SQLDataType#TIMESTAMP}</li> </ul>
 */
boolean isTemporal();",0.9780439121756488
150549,"/** 
 * Whether this data type is any character data type. This applies to any of these types: <ul> <li>   {@link SQLDataType#CHAR}</li> <li>   {@link SQLDataType#CLOB}</li> <li>   {@link SQLDataType#LONGNVARCHAR}</li> <li>   {@link SQLDataType#LONGVARCHAR}</li> <li>   {@link SQLDataType#NCHAR}</li> <li>   {@link SQLDataType#NCLOB}</li> <li>   {@link SQLDataType#NVARCHAR}</li> <li>   {@link SQLDataType#VARCHAR}</li> </ul>
 * @return
 */
boolean isString();","/** 
 * Whether this data type is any character data type. This applies to any of these types: <ul> <li>   {@link SQLDataType#CHAR}</li> <li>   {@link SQLDataType#CLOB}</li> <li>   {@link SQLDataType#LONGNVARCHAR}</li> <li>   {@link SQLDataType#LONGVARCHAR}</li> <li>   {@link SQLDataType#NCHAR}</li> <li>   {@link SQLDataType#NCLOB}</li> <li>   {@link SQLDataType#NVARCHAR}</li> <li>   {@link SQLDataType#VARCHAR}</li> </ul>
 */
boolean isString();",0.987898789878988
150550,"/** 
 * Creates the intial response to be sent to the server.
 * @param challenge  Challenge in bytes recived form the Server
 * @return Initial response to be sent to the server
 */
private String createDigestResponse(byte[] challenge) throws SaslException {
  char[] response;
  StringBuffer digestResponse=new StringBuffer(512);
  int realmSize;
  m_dc=new DigestChallenge(challenge);
  m_digestURI=m_protocol + ""String_Node_Str"" + m_serverName;
  if ((m_dc.getQop() & DigestChallenge.QOP_AUTH) == DigestChallenge.QOP_AUTH)   m_qopValue=""String_Node_Str"";
 else   throw new SaslException(""String_Node_Str"");
  Callback[] callbacks=new Callback[3];
  ArrayList realms=m_dc.getRealms();
  realmSize=realms.size();
  if (realmSize == 0) {
    callbacks[0]=new RealmCallback(""String_Node_Str"");
  }
 else   if (realmSize == 1) {
    callbacks[0]=new RealmCallback(""String_Node_Str"",(String)realms.get(0));
  }
 else {
    callbacks[0]=new RealmChoiceCallback(""String_Node_Str"",(String[])realms.toArray(new String[realmSize]),0,false);
  }
  callbacks[1]=new PasswordCallback(""String_Node_Str"",false);
  if (m_authorizationId == null || m_authorizationId.length() == 0)   callbacks[2]=new NameCallback(""String_Node_Str"");
 else   callbacks[2]=new NameCallback(""String_Node_Str"",m_authorizationId);
  try {
    m_cbh.handle(callbacks);
  }
 catch (  UnsupportedCallbackException e) {
    throw new SaslException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new SaslException(""String_Node_Str"",e);
  }
  if (realmSize > 1) {
    int[] selections=((RealmChoiceCallback)callbacks[0]).getSelectedIndexes();
    if (selections.length > 0)     m_realm=((RealmChoiceCallback)callbacks[0]).getChoices()[selections[0]];
 else     m_realm=((RealmChoiceCallback)callbacks[0]).getChoices()[0];
  }
 else   m_realm=((RealmCallback)callbacks[0]).getText();
  m_clientNonce=getClientNonce();
  m_name=((NameCallback)callbacks[2]).getName();
  if (m_name == null)   m_name=((NameCallback)callbacks[2]).getDefaultName();
  if (m_name == null)   throw new SaslException(""String_Node_Str"");
  m_HA1=DigestCalcHA1(m_dc.getAlgorithm(),m_name,m_realm,new String(((PasswordCallback)callbacks[1]).getPassword()),m_dc.getNonce(),m_clientNonce);
  response=DigestCalcResponse(m_HA1,m_dc.getNonce(),""String_Node_Str"",m_clientNonce,m_qopValue,""String_Node_Str"",m_digestURI,true);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_authorizationId);
  if (0 != m_realm.length()) {
    digestResponse.append(""String_Node_Str"");
    digestResponse.append(m_realm);
  }
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_clientNonce);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_qopValue);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_serverName);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(response);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_dc.getNonce());
  digestResponse.append(""String_Node_Str"");
  return digestResponse.toString();
}","/** 
 * Creates the intial response to be sent to the server.
 * @param challenge  Challenge in bytes recived form the Server
 * @return Initial response to be sent to the server
 */
private String createDigestResponse(byte[] challenge) throws SaslException {
  char[] response;
  StringBuffer digestResponse=new StringBuffer(512);
  int realmSize;
  m_dc=new DigestChallenge(challenge);
  m_digestURI=m_protocol + ""String_Node_Str"" + m_serverName;
  if ((m_dc.getQop() & DigestChallenge.QOP_AUTH) == DigestChallenge.QOP_AUTH)   m_qopValue=""String_Node_Str"";
 else   throw new SaslException(""String_Node_Str"");
  Callback[] callbacks=new Callback[3];
  ArrayList realms=m_dc.getRealms();
  realmSize=realms.size();
  if (realmSize == 0) {
    callbacks[0]=new RealmCallback(""String_Node_Str"");
  }
 else   if (realmSize == 1) {
    callbacks[0]=new RealmCallback(""String_Node_Str"",(String)realms.get(0));
  }
 else {
    callbacks[0]=new RealmChoiceCallback(""String_Node_Str"",(String[])realms.toArray(new String[realmSize]),0,false);
  }
  callbacks[1]=new PasswordCallback(""String_Node_Str"",false);
  if (m_authorizationId == null || m_authorizationId.length() == 0)   callbacks[2]=new NameCallback(""String_Node_Str"");
 else   callbacks[2]=new NameCallback(""String_Node_Str"",m_authorizationId);
  try {
    m_cbh.handle(callbacks);
  }
 catch (  UnsupportedCallbackException e) {
    throw new SaslException(""String_Node_Str"" + ""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new SaslException(""String_Node_Str"",e);
  }
  if (realmSize > 1) {
    int[] selections=((RealmChoiceCallback)callbacks[0]).getSelectedIndexes();
    if (selections.length > 0)     m_realm=((RealmChoiceCallback)callbacks[0]).getChoices()[selections[0]];
 else     m_realm=((RealmChoiceCallback)callbacks[0]).getChoices()[0];
  }
 else   m_realm=((RealmCallback)callbacks[0]).getText();
  m_clientNonce=getClientNonce();
  m_name=((NameCallback)callbacks[2]).getName();
  if (m_name == null)   m_name=((NameCallback)callbacks[2]).getDefaultName();
  if (m_name == null)   throw new SaslException(""String_Node_Str"");
  m_HA1=DigestCalcHA1(m_dc.getAlgorithm(),m_name,m_realm,new String(((PasswordCallback)callbacks[1]).getPassword()),m_dc.getNonce(),m_clientNonce);
  response=DigestCalcResponse(m_HA1,m_dc.getNonce(),""String_Node_Str"",m_clientNonce,m_qopValue,""String_Node_Str"",m_digestURI,true);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_name);
  if (0 != m_realm.length()) {
    digestResponse.append(""String_Node_Str"");
    digestResponse.append(m_realm);
  }
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_clientNonce);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_qopValue);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_serverName);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(response);
  digestResponse.append(""String_Node_Str"");
  digestResponse.append(m_dc.getNonce());
  if (m_authorizationId != null && m_authorizationId.length() > 0) {
    digestResponse.append(""String_Node_Str"");
    digestResponse.append(m_authorizationId);
  }
  digestResponse.append(""String_Node_Str"");
  return digestResponse.toString();
}",0.8092307692307692
150551,"/** 
 * Opens a window showing the found point cloud. Points are colorized using the pixel value inside one of the input images
 */
private void visualizeResults(BundleAdjustmentSceneStructure structure,CameraPinholeRadial intrinsic,List<BufferedImage> colorImages){
  PointCloudViewer gui=new PointCloudViewer(intrinsic,1);
  Point3D_F64 world=new Point3D_F64();
  Point3D_F64 camera=new Point3D_F64();
  Point2D_F64 pixel=new Point2D_F64();
  for (int i=0; i < structure.points.length; i++) {
    BundleAdjustmentSceneStructure.Point p=structure.points[i];
    p.get(world);
    for (int j=0; j < p.views.size; j++) {
      int viewIdx=p.views.get(j);
      SePointOps_F64.transform(structure.views[viewIdx].worldToView,world,camera);
      int cameraIdx=structure.views[viewIdx].camera;
      structure.cameras[cameraIdx].model.project(camera.x,camera.y,camera.z,pixel);
      BufferedImage image=colorImages.get(viewIdx);
      int x=(int)pixel.x;
      int y=(int)pixel.y;
      if (x < 0 || y < 0 || x >= image.getWidth() || y >= image.getHeight())       continue;
      int rgb=image.getRGB((int)pixel.x,(int)pixel.y);
      gui.addPoint(world.x,world.y,world.z,rgb);
    }
  }
  gui.setPreferredSize(new Dimension(500,500));
  ShowImages.showWindow(gui,""String_Node_Str"",true);
}","/** 
 * Opens a window showing the found point cloud. Points are colorized using the pixel value inside one of the input images
 */
private void visualizeResults(BundleAdjustmentSceneStructure structure,CameraPinholeRadial intrinsic,List<BufferedImage> colorImages){
  PointCloudViewer gui=new PointCloudViewer(intrinsic,1);
  Point3D_F64 world=new Point3D_F64();
  Point3D_F64 camera=new Point3D_F64();
  Point2D_F64 pixel=new Point2D_F64();
  for (int i=0; i < structure.points.length; i++) {
    BundleAdjustmentSceneStructure.Point p=structure.points[i];
    p.get(world);
    for (int j=0; j < p.views.size; j++) {
      int viewIdx=p.views.get(j);
      SePointOps_F64.transform(structure.views[viewIdx].worldToView,world,camera);
      int cameraIdx=structure.views[viewIdx].camera;
      structure.cameras[cameraIdx].model.project(camera.x,camera.y,camera.z,pixel);
      BufferedImage image=colorImages.get(viewIdx);
      int x=(int)pixel.x;
      int y=(int)pixel.y;
      if (x < 0 || y < 0 || x >= image.getWidth() || y >= image.getHeight())       continue;
      int rgb=image.getRGB((int)pixel.x,(int)pixel.y);
      gui.addPoint(world.x,world.y,world.z,rgb);
      break;
    }
  }
  gui.setPreferredSize(new Dimension(500,500));
  ShowImages.showWindow(gui,""String_Node_Str"",true);
}",0.9949748743718592
150552,"public static void main(String[] args){
  String directory=UtilIO.pathExample(""String_Node_Str"");
  CameraPinholeRadial intrinsic=CalibrationIO.load(new File(directory,""String_Node_Str""));
  List<BufferedImage> images=UtilImageIO.loadImages(directory,""String_Node_Str"");
  int N=2;
  while (images.size() > N) {
    images.remove(N);
  }
  ExampleMultiviewSceneReconstruction example=new ExampleMultiviewSceneReconstruction();
  long before=System.currentTimeMillis();
  example.process(intrinsic,images);
  long after=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (after - before) / 1000.0 + ""String_Node_Str"");
}","public static void main(String[] args){
  String directory=UtilIO.pathExample(""String_Node_Str"");
  CameraPinholeRadial intrinsic=CalibrationIO.load(new File(directory,""String_Node_Str""));
  List<BufferedImage> images=UtilImageIO.loadImages(directory,""String_Node_Str"");
  int N=5;
  while (images.size() > N) {
    images.remove(N);
  }
  ExampleMultiviewSceneReconstruction example=new ExampleMultiviewSceneReconstruction();
  long before=System.currentTimeMillis();
  example.process(intrinsic,images);
  long after=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (after - before) / 1000.0 + ""String_Node_Str"");
}",0.998430141287284
150553,"private void triangulateNoLocation(CameraView target){
  Vector3D_F64 arrowA=new Vector3D_F64();
  Vector3D_F64 arrowB=new Vector3D_F64();
  TriangulateTwoViewsCalibrated triangulator=FactoryMultiView.triangulateTwoGeometric();
  Se3_F64 otherToTarget=new Se3_F64();
  Se3_F64 worldToTarget=target.viewToWorld.invert(null);
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    other.viewToWorld.concat(worldToTarget,otherToTarget);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      int indexTarget=isSrc ? a.src : a.dst;
      int indexOther=isSrc ? a.dst : a.src;
      if (target.features3D[indexTarget] != null || other.features3D[indexOther] != null)       continue;
      Point2D_F64 normOther=other.featureNorm.get(indexOther);
      Point2D_F64 normTarget=target.featureNorm.get(indexTarget);
      arrowA.set(normOther.x,normOther.y,1);
      arrowB.set(normTarget.x,normTarget.y,1);
      GeometryMath_F64.mult(otherToTarget.R,arrowA,arrowA);
      double angle=UtilVector3D_F64.acute(arrowA,arrowB);
      if (angle < TRIANGULATE_MIN_ANGLE)       continue;
      Feature3D f=new Feature3D();
      if (!triangulator.triangulate(normOther,normTarget,otherToTarget,f.worldPt))       continue;
      SePointOps_F64.transform(other.viewToWorld,f.worldPt,f.worldPt);
      f.views.add(target);
      f.views.add(other);
      f.feature.add(indexTarget);
      f.feature.add(indexOther);
      features3D.add(f);
      target.features3D[indexTarget]=f;
      other.features3D[indexOther]=f;
    }
  }
}","private void triangulateNoLocation(CameraView target){
  Vector3D_F64 arrowA=new Vector3D_F64();
  Vector3D_F64 arrowB=new Vector3D_F64();
  TriangulateTwoViewsCalibrated triangulator=FactoryMultiView.triangulateTwoGeometric();
  Se3_F64 otherToTarget=new Se3_F64();
  Se3_F64 worldToTarget=target.viewToWorld.invert(null);
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    other.viewToWorld.concat(worldToTarget,otherToTarget);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      int indexTarget=isSrc ? a.src : a.dst;
      int indexOther=isSrc ? a.dst : a.src;
      if (target.features3D[indexTarget] != null || other.features3D[indexOther] != null)       continue;
      Point2D_F64 normOther=other.observationNorm.get(indexOther);
      Point2D_F64 normTarget=target.observationNorm.get(indexTarget);
      arrowA.set(normOther.x,normOther.y,1);
      arrowB.set(normTarget.x,normTarget.y,1);
      GeometryMath_F64.mult(otherToTarget.R,arrowA,arrowA);
      double angle=UtilVector3D_F64.acute(arrowA,arrowB);
      if (angle < TRIANGULATE_MIN_ANGLE)       continue;
      Feature3D f=new Feature3D();
      if (!triangulator.triangulate(normOther,normTarget,otherToTarget,f.worldPt))       continue;
      SePointOps_F64.transform(other.viewToWorld,f.worldPt,f.worldPt);
      f.views.add(target);
      f.views.add(other);
      f.obsIdx.add(indexTarget);
      f.obsIdx.add(indexOther);
      features3D.add(f);
      target.features3D[indexTarget]=f;
      other.features3D[indexOther]=f;
    }
  }
}",0.9662322274881516
150554,"/** 
 * Uses the previously found motion between the two cameras to estimate the scale and 3D point of common features. If a feature already has a known 3D point that is not modified. Scale is found by computing the 3D coordinate of all points with a 3D point again then dividing the two distances. New features are also triangulated and have their location's update using this scale. A known feature has the current view added to its list of views.
 */
private boolean determinePose(CameraView target){
  List<Point2D3D> list=new ArrayList<>();
  List<Feature3D> features=new ArrayList<>();
  GrowQueue_I32 featureIndexes=new GrowQueue_I32();
  int closestDistance=Integer.MAX_VALUE;
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    closestDistance=Math.min(closestDistance,other.distanceFromRoot);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      Feature3D f=other.features3D[isSrc ? a.dst : a.src];
      if (f == null || f.mark == target.index)       continue;
      f.mark=target.index;
      features.add(f);
      featureIndexes.add(isSrc ? a.src : a.dst);
      Point2D_F64 norm=target.featureNorm.get(isSrc ? a.src : a.dst);
      Point2D3D p=new Point2D3D();
      p.location.set(f.worldPt);
      p.observation.set(norm);
      list.add(p);
    }
  }
  ransacPnP.setIntrinsic(0,camerasIntrinsc.get(target.camera));
  if (list.size() < 100 || !ransacPnP.process(list)) {
    if (verbose)     System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ list.size());
    return false;
  }
  target.distanceFromRoot=closestDistance + 1;
  int N=ransacPnP.getMatchSet().size();
  if (verbose)   System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ N+ ""String_Node_Str""+ list.size());
  for (int i=0; i < N; i++) {
    int which=ransacPnP.getInputIndex(i);
    Feature3D f=features.get(which);
    if (f.views.contains(target))     continue;
    f.views.add(target);
    f.feature.add(featureIndexes.get(which));
    target.features3D[featureIndexes.get(which)]=f;
    if (f.views.size() != f.feature.size)     throw new RuntimeException(""String_Node_Str"");
  }
  Se3_F64 worldToView=ransacPnP.getModelParameters();
  target.viewToWorld.set(worldToView.invert(null));
  return true;
}","/** 
 * Uses the previously found motion between the two cameras to estimate the scale and 3D point of common features. If a feature already has a known 3D point that is not modified. Scale is found by computing the 3D coordinate of all points with a 3D point again then dividing the two distances. New features are also triangulated and have their location's update using this scale. A known feature has the current view added to its list of views.
 */
private boolean determinePose(CameraView target){
  List<Point2D3D> list=new ArrayList<>();
  List<Feature3D> features=new ArrayList<>();
  GrowQueue_I32 featureIndexes=new GrowQueue_I32();
  int closestDistance=Integer.MAX_VALUE;
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    closestDistance=Math.min(closestDistance,other.distanceFromRoot);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      Feature3D f=other.features3D[isSrc ? a.dst : a.src];
      if (f == null || f.mark == target.index)       continue;
      f.mark=target.index;
      features.add(f);
      featureIndexes.add(isSrc ? a.src : a.dst);
      Point2D_F64 norm=target.observationNorm.get(isSrc ? a.src : a.dst);
      Point2D3D p=new Point2D3D();
      p.location.set(f.worldPt);
      p.observation.set(norm);
      list.add(p);
    }
  }
  ransacPnP.setIntrinsic(0,camerasIntrinsc.get(target.camera));
  if (list.size() < 100 || !ransacPnP.process(list)) {
    if (verbose)     System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ list.size());
    return false;
  }
  target.distanceFromRoot=closestDistance + 1;
  int N=ransacPnP.getMatchSet().size();
  if (verbose)   System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ N+ ""String_Node_Str""+ list.size());
  for (int i=0; i < N; i++) {
    int which=ransacPnP.getInputIndex(i);
    Feature3D f=features.get(which);
    if (f.views.contains(target))     continue;
    f.views.add(target);
    f.obsIdx.add(featureIndexes.get(which));
    target.features3D[featureIndexes.get(which)]=f;
    if (f.views.size() != f.obsIdx.size)     throw new RuntimeException(""String_Node_Str"");
  }
  Se3_F64 worldToView=ransacPnP.getModelParameters();
  target.viewToWorld.set(worldToView.invert(null));
  return true;
}",0.9908637873754153
150555,"@Override public void addCamera(String cameraName,LensDistortionNarrowFOV intrinsic,int width,int height){
  if (camerasPixelToNorm.isEmpty())   calibrated=true;
 else   if (!calibrated)   throw new IllegalArgumentException(""String_Node_Str"");
  Point2Transform2_F64 pixelToNorm=intrinsic.undistort_F64(true,false);
  camerasPixelToNorm.put(cameraName,pixelToNorm);
  camerasIntrinsc.put(cameraName,PerspectiveOps.estimatePinhole(pixelToNorm,width,height));
}","@Override public void addCamera(String cameraName,LensDistortionNarrowFOV intrinsic,int width,int height){
  if (camerasPixelToNorm.isEmpty())   calibrated=true;
 else   if (!calibrated)   throw new IllegalArgumentException(""String_Node_Str"");
  Point2Transform2_F64 pixelToNorm=intrinsic.undistort_F64(true,false);
  camerasPixelToNorm.put(cameraName,pixelToNorm);
  camerasIntrinsc.put(cameraName,PerspectiveOps.estimatePinhole(pixelToNorm,width,height));
  cameraToIndex.put(cameraName,cameraToIndex.size());
}",0.9444444444444444
150556,"@Override public boolean estimate(){
  if (calibrated) {
    ransacEssential=FactoryMultiViewRobust.essentialRansac(configEssential,configRansac);
    ransacHomography=FactoryMultiViewRobust.homographyCalibratedRansac(configRansac);
    ransacPnP=FactoryMultiViewRobust.pnpRansac(null,configRansac);
  }
 else {
    ransacFundamental=FactoryMultiViewRobust.fundamentalRansac(configFundamental,configRansac);
  }
  if (graphNodes.size() < 2)   return false;
  for (int i=0; i < graphNodes.size(); i++) {
    for (int j=i + 1; j < graphNodes.size(); j++) {
      connectViews(graphNodes.get(i),graphNodes.get(j));
      if (stopRequested)       return false;
    }
  }
  if (graphEdges.size() < 1)   return false;
  CameraView origin=selectOriginNode();
  CameraMotion baseMotion=selectCoordinateBase(origin);
  defineCoordinateSystem(origin,baseMotion);
  if (stopRequested)   return false;
  triangulateInitialSeed(origin,baseMotion);
  estimateAllFeatures(origin,baseMotion.destination(origin));
  if (stopRequested)   return false;
  convertToOutput(origin);
  return viewsAdded.size() >= 2;
}","@Override public boolean estimate(){
  if (graphNodes.size() < 2)   return false;
  declareModelFitting();
  for (int i=0; i < graphNodes.size(); i++) {
    for (int j=i + 1; j < graphNodes.size(); j++) {
      connectViews(graphNodes.get(i),graphNodes.get(j));
      if (stopRequested)       return false;
    }
  }
  if (graphEdges.size() < 1)   return false;
  CameraView origin=selectOriginNode();
  CameraMotion baseMotion=selectCoordinateBase(origin);
  defineCoordinateSystem(origin,baseMotion);
  if (stopRequested)   return false;
  triangulateInitialSeed(origin,baseMotion);
  estimateAllFeatures(origin,baseMotion.destination(origin));
  if (stopRequested)   return false;
  convertToOutput(origin);
  return viewsAdded.size() >= 2;
}",0.782608695652174
150557,"/** 
 * For the two seed views just triangulate all the common features. The motion already has its translation normalized to one
 */
private void triangulateInitialSeed(CameraView origin,CameraMotion edge){
  CameraView viewA=edge.viewSrc;
  CameraView viewB=edge.viewDst;
  Vector3D_F64 arrowA=new Vector3D_F64();
  Vector3D_F64 arrowB=new Vector3D_F64();
  Se3_F64 viewAtoB=new Se3_F64();
  viewA.viewToWorld.concat(viewB.viewToWorld.invert(null),viewAtoB);
  for (int i=0; i < edge.features.size(); i++) {
    AssociatedIndex f=edge.features.get(i);
    if (viewA.features3D[f.src] != null || viewB.features3D[f.dst] != null)     continue;
    Point2D_F64 normA=viewA.featureNorm.get(f.src);
    Point2D_F64 normB=viewB.featureNorm.get(f.dst);
    Feature3D feature3D=new Feature3D();
    feature3D.feature.add(f.src);
    feature3D.feature.add(f.dst);
    arrowA.set(normA.x,normA.y,1);
    arrowB.set(normB.x,normB.y,1);
    GeometryMath_F64.mult(viewAtoB.R,arrowA,arrowA);
    double angle=UtilVector3D_F64.acute(arrowA,arrowB);
    if (angle < TRIANGULATE_MIN_ANGLE)     continue;
    if (!triangulate.triangulate(normA,normB,viewAtoB,feature3D.worldPt)) {
      System.out.println(""String_Node_Str"");
      continue;
    }
    if (viewB == origin) {
      SePointOps_F64.transformReverse(viewAtoB,feature3D.worldPt,feature3D.worldPt);
    }
    viewA.features3D[f.src]=feature3D;
    viewB.features3D[f.dst]=feature3D;
    if (feature3D.views.contains(viewA))     throw new RuntimeException(""String_Node_Str"");
    if (feature3D.views.contains(viewB))     throw new RuntimeException(""String_Node_Str"");
    feature3D.views.add(viewA);
    feature3D.views.add(viewB);
    features3D.add(feature3D);
  }
  System.out.println(""String_Node_Str"" + viewA.index + ""String_Node_Str""+ viewB.index+ ""String_Node_Str""+ features3D.size()+ ""String_Node_Str""+ edge.features.size());
}","/** 
 * For the two seed views just triangulate all the common features. The motion already has its translation normalized to one
 */
private void triangulateInitialSeed(CameraView origin,CameraMotion edge){
  CameraView viewA=edge.viewSrc;
  CameraView viewB=edge.viewDst;
  Vector3D_F64 arrowA=new Vector3D_F64();
  Vector3D_F64 arrowB=new Vector3D_F64();
  Se3_F64 viewAtoB=new Se3_F64();
  viewA.viewToWorld.concat(viewB.viewToWorld.invert(null),viewAtoB);
  for (int i=0; i < edge.features.size(); i++) {
    AssociatedIndex f=edge.features.get(i);
    if (viewA.features3D[f.src] != null || viewB.features3D[f.dst] != null)     continue;
    Point2D_F64 normA=viewA.observationNorm.get(f.src);
    Point2D_F64 normB=viewB.observationNorm.get(f.dst);
    Feature3D feature3D=new Feature3D();
    feature3D.obsIdx.add(f.src);
    feature3D.obsIdx.add(f.dst);
    arrowA.set(normA.x,normA.y,1);
    arrowB.set(normB.x,normB.y,1);
    GeometryMath_F64.mult(viewAtoB.R,arrowA,arrowA);
    double angle=UtilVector3D_F64.acute(arrowA,arrowB);
    if (angle < TRIANGULATE_MIN_ANGLE)     continue;
    if (!triangulate.triangulate(normA,normB,viewAtoB,feature3D.worldPt)) {
      System.out.println(""String_Node_Str"");
      continue;
    }
    if (viewB == origin) {
      SePointOps_F64.transform(viewAtoB,feature3D.worldPt,feature3D.worldPt);
    }
    viewA.features3D[f.src]=feature3D;
    viewB.features3D[f.dst]=feature3D;
    if (feature3D.views.contains(viewA))     throw new RuntimeException(""String_Node_Str"");
    if (feature3D.views.contains(viewB))     throw new RuntimeException(""String_Node_Str"");
    feature3D.views.add(viewA);
    feature3D.views.add(viewB);
    features3D.add(feature3D);
  }
  System.out.println(""String_Node_Str"" + viewA.index + ""String_Node_Str""+ viewB.index+ ""String_Node_Str""+ features3D.size()+ ""String_Node_Str""+ edge.features.size());
}",0.9672611125898324
150558,"/** 
 * Detect features inside the image and save the results
 * @param image
 */
@Override public void add(T image,String cameraName){
  if (cameraName == null || !camerasPixelToNorm.containsKey(cameraName))   throw new IllegalArgumentException(""String_Node_Str"");
  CameraView view=new CameraView(graphNodes.size(),new FastQueue<TupleDesc>(TupleDesc.class,true){
    @Override protected TupleDesc createInstance(){
      return detDesc.createDescription();
    }
  }
);
  view.camera=cameraName;
  graphNodes.add(view);
  detDesc.detect(image);
  view.descriptions.growArray(detDesc.getNumberOfFeatures());
  view.featurePixels.growArray(detDesc.getNumberOfFeatures());
  view.features3D=new Feature3D[detDesc.getNumberOfFeatures()];
  for (int i=0; i < detDesc.getNumberOfFeatures(); i++) {
    Point2D_F64 p=detDesc.getLocation(i);
    view.descriptions.grow().setTo(detDesc.getDescription(i));
    view.featurePixels.grow().set(p);
  }
  Point2Transform2_F64 pixelToNorm=camerasPixelToNorm.get(cameraName);
  if (pixelToNorm == null) {
    return;
  }
  view.featureNorm.growArray(detDesc.getNumberOfFeatures());
  for (int i=0; i < view.featurePixels.size; i++) {
    Point2D_F64 p=view.featurePixels.get(i);
    pixelToNorm.compute(p.x,p.y,view.featureNorm.grow());
  }
}","/** 
 * Detect features inside the image and save the results
 * @param image
 */
@Override public void add(T image,String cameraName){
  if (cameraName == null || !camerasPixelToNorm.containsKey(cameraName))   throw new IllegalArgumentException(""String_Node_Str"");
  CameraView view=new CameraView(graphNodes.size(),new FastQueue<TupleDesc>(TupleDesc.class,true){
    @Override protected TupleDesc createInstance(){
      return detDesc.createDescription();
    }
  }
);
  view.camera=cameraName;
  graphNodes.add(view);
  detDesc.detect(image);
  view.descriptions.growArray(detDesc.getNumberOfFeatures());
  view.observationPixels.growArray(detDesc.getNumberOfFeatures());
  view.features3D=new Feature3D[detDesc.getNumberOfFeatures()];
  for (int i=0; i < detDesc.getNumberOfFeatures(); i++) {
    Point2D_F64 p=detDesc.getLocation(i);
    view.descriptions.grow().setTo(detDesc.getDescription(i));
    view.observationPixels.grow().set(p);
  }
  Point2Transform2_F64 pixelToNorm=camerasPixelToNorm.get(cameraName);
  if (pixelToNorm == null) {
    return;
  }
  view.observationNorm.growArray(detDesc.getNumberOfFeatures());
  for (int i=0; i < view.observationPixels.size; i++) {
    Point2D_F64 p=view.observationPixels.get(i);
    pixelToNorm.compute(p.x,p.y,view.observationNorm.grow());
  }
}",0.958139534883721
150559,"boolean fitEpipolar(FastQueue<AssociatedIndex> matches,FastQueue<Point2D_F64> pointsA,FastQueue<Point2D_F64> PointsB,Ransac<?,AssociatedPair> ransac,CameraMotion edge){
  pairs.resize(matches.size);
  for (int i=0; i < matches.size; i++) {
    AssociatedIndex a=matches.get(i);
    pairs.get(i).p1.set(pointsA.get(a.src));
    pairs.get(i).p2.set(PointsB.get(a.dst));
  }
  if (!ransac.process(pairs.toList()))   return false;
  int N=ransac.getMatchSet().size();
  for (int i=0; i < N; i++) {
    AssociatedIndex a=matches.get(ransac.getInputIndex(i));
    edge.features.add(a.copy());
  }
  return true;
}","/** 
 * Uses ransac to fit an epipolar model to the associated features. Adds list of matched features to the edge.
 * @param matches List of matched features by index
 * @param pointsA Set of observations from image A
 * @param pointsB Set of observations from image B
 * @param ransac Model fitter
 * @param edge Edge which will contain a description of found motion
 * @return true if no error
 */
boolean fitEpipolar(FastQueue<AssociatedIndex> matches,List<Point2D_F64> pointsA,List<Point2D_F64> pointsB,Ransac<?,AssociatedPair> ransac,CameraMotion edge){
  pairs.resize(matches.size);
  for (int i=0; i < matches.size; i++) {
    AssociatedIndex a=matches.get(i);
    pairs.get(i).p1.set(pointsA.get(a.src));
    pairs.get(i).p2.set(pointsB.get(a.dst));
  }
  if (!ransac.process(pairs.toList()))   return false;
  int N=ransac.getMatchSet().size();
  for (int i=0; i < N; i++) {
    AssociatedIndex a=matches.get(ransac.getInputIndex(i));
    edge.features.add(a.copy());
  }
  return true;
}",0.7314641744548287
150560,"/** 
 * Associate features between the two views. Then compute a homography and essential matrix using LSMed. Add features to the edge if they an inlier in essential. Save fit score of homography vs essential.
 */
void connectViews(CameraView viewA,CameraView viewB){
  associate.setSource(viewA.descriptions);
  associate.setDestination(viewB.descriptions);
  associate.associate();
  if (associate.getMatches().size < MIN_FEATURE_ASSOCIATED)   return;
  FastQueue<AssociatedIndex> matches=associate.getMatches();
  CameraMotion edge=new CameraMotion();
  int inliersEpipolar;
  if (calibrated) {
    ransacEssential.setIntrinsic(0,camerasIntrinsc.get(viewA.camera));
    ransacEssential.setIntrinsic(1,camerasIntrinsc.get(viewB.camera));
    if (!fitEpipolar(matches,viewA.featureNorm,viewB.featureNorm,ransacEssential,edge))     return;
    inliersEpipolar=ransacEssential.getMatchSet().size();
    edge.a_to_b.set(ransacEssential.getModelParameters());
    ransacHomography.setIntrinsic(0,camerasIntrinsc.get(viewA.camera));
    ransacHomography.setIntrinsic(1,camerasIntrinsc.get(viewB.camera));
  }
 else {
    if (!fitEpipolar(matches,viewA.featurePixels,viewB.featurePixels,ransacFundamental,edge))     return;
    inliersEpipolar=ransacFundamental.getMatchSet().size();
  }
  if (inliersEpipolar < MIN_FEATURE_ASSOCIATED)   return;
  if (!ransacHomography.process(pairs.toList())) {
    return;
  }
  edge.ratio_H_to_Epi=ransacHomography.getMatchSet().size() / (double)inliersEpipolar;
  edge.viewSrc=viewA;
  edge.viewDst=viewB;
  viewA.connections.add(edge);
  viewB.connections.add(edge);
  List<AssociatedPair> inliersEssential=ransacEssential.getMatchSet();
  for (int i=0; i < inliersEssential.size(); i++) {
    int index=ransacEssential.getInputIndex(i);
    edge.features.add(matches.get(index).copy());
  }
  graphEdges.add(edge);
}","/** 
 * Associate features between the two views. Then compute a homography and essential matrix using LSMed. Add features to the edge if they an inlier in essential. Save fit score of homography vs essential.
 */
void connectViews(CameraView viewA,CameraView viewB){
  associate.setSource(viewA.descriptions);
  associate.setDestination(viewB.descriptions);
  associate.associate();
  if (associate.getMatches().size < MIN_FEATURE_ASSOCIATED)   return;
  FastQueue<AssociatedIndex> matches=associate.getMatches();
  CameraMotion edge=new CameraMotion();
  int inliersEpipolar;
  if (calibrated) {
    ransacEssential.setIntrinsic(0,camerasIntrinsc.get(viewA.camera));
    ransacEssential.setIntrinsic(1,camerasIntrinsc.get(viewB.camera));
    if (!fitEpipolar(matches,viewA.observationNorm.toList(),viewB.observationNorm.toList(),ransacEssential,edge))     return;
    inliersEpipolar=ransacEssential.getMatchSet().size();
    edge.a_to_b.set(ransacEssential.getModelParameters());
    ransacHomography.setIntrinsic(0,camerasIntrinsc.get(viewA.camera));
    ransacHomography.setIntrinsic(1,camerasIntrinsc.get(viewB.camera));
  }
 else {
    if (!fitEpipolar(matches,viewA.observationPixels.toList(),viewB.observationPixels.toList(),ransacFundamental,edge))     return;
    inliersEpipolar=ransacFundamental.getMatchSet().size();
  }
  if (inliersEpipolar < MIN_FEATURE_ASSOCIATED)   return;
  if (!ransacHomography.process(pairs.toList())) {
    return;
  }
  edge.ratio_H_to_Epi=ransacHomography.getMatchSet().size() / (double)inliersEpipolar;
  edge.viewSrc=viewA;
  edge.viewDst=viewB;
  viewA.connections.add(edge);
  viewB.connections.add(edge);
  graphEdges.add(edge);
}",0.8931708699348258
150561,"public EstimateSceneUnordered(DetectDescribePoint<T,TupleDesc> detDesc){
  this.detDesc=detDesc;
  scorer=FactoryAssociation.defaultScore(detDesc.getDescriptionType());
  associate=FactoryAssociation.greedy(scorer,Double.MAX_VALUE,true);
  configRansac.inlierThreshold=3.0;
  configRansac.maxIterations=2000;
}","/** 
 * Constructor for unit tests
 */
EstimateSceneUnordered(){
  configRansac.inlierThreshold=3.0;
  configRansac.maxIterations=2000;
}",0.4519015659955257
150562,"private void convertToOutput(CameraView origin){
  structure=new BundleAdjustmentSceneStructure(false);
  observations=new BundleAdjustmentObservations(graphNodes.size());
  structure.initialize(camerasPixelToNorm.size(),graphNodes.size(),features3D.size());
  for (int i=0; i < graphNodes.size(); i++) {
    CameraView v=graphNodes.get(i);
    structure.setView(i,v == origin,v.viewToWorld.invert(null));
    structure.connectViewToCamera(i,0);
  }
  for (int indexPoint=0; indexPoint < features3D.size(); indexPoint++) {
    Feature3D f=features3D.get(indexPoint);
    structure.setPoint(indexPoint,f.worldPt.x,f.worldPt.y,f.worldPt.z);
    if (f.views.size() != f.feature.size)     throw new RuntimeException(""String_Node_Str"");
    for (int j=0; j < f.views.size(); j++) {
      CameraView view=f.views.get(j);
      structure.connectPointToView(indexPoint,view.index);
      Point2D_F64 pixel=graphNodes.get(view.index).featurePixels.get(f.feature.get(j));
      observations.getView(view.index).add(indexPoint,(float)(pixel.x),(float)(pixel.y));
    }
  }
}","/** 
 * Converts the internal data structures into the output format for bundle adjustment. Camera models are omitted since they are not available
 * @param origin The origin of the coordinate system
 */
private void convertToOutput(CameraView origin){
  structure=new BundleAdjustmentSceneStructure(false);
  observations=new BundleAdjustmentObservations(graphNodes.size());
  structure.initialize(cameraToIndex.size(),graphNodes.size(),features3D.size());
  for (int i=0; i < viewsAdded.size(); i++) {
    CameraView v=viewsAdded.get(i);
    int cameraIndex=cameraToIndex.get(v.camera);
    structure.setView(i,v == origin,v.viewToWorld.invert(null));
    structure.connectViewToCamera(i,cameraIndex);
  }
  for (int indexPoint=0; indexPoint < features3D.size(); indexPoint++) {
    Feature3D f=features3D.get(indexPoint);
    structure.setPoint(indexPoint,f.worldPt.x,f.worldPt.y,f.worldPt.z);
    if (f.views.size() != f.obsIdx.size)     throw new RuntimeException(""String_Node_Str"");
    for (int j=0; j < f.views.size(); j++) {
      CameraView view=f.views.get(j);
      structure.connectPointToView(indexPoint,view.index);
      Point2D_F64 pixel=graphNodes.get(view.index).observationPixels.get(f.obsIdx.get(j));
      observations.getView(view.index).add(indexPoint,(float)(pixel.x),(float)(pixel.y));
    }
  }
}",0.8424140821458508
150563,"/** 
 * Process the images and reconstructor the scene as a point cloud using matching interest points between images.
 */
public void process(CameraPinholeRadial intrinsic,List<BufferedImage> colorImages){
  pixelToNorm=LensDistortionOps.narrow(intrinsic).undistort_F64(true,false);
  estimateEssential=FactoryMultiViewRobust.essentialRansac(new ConfigEssential(intrinsic),new ConfigRansac(4000,inlierTol));
  estimatePnP=FactoryMultiViewRobust.pnpRansac(new ConfigPnP(intrinsic),new ConfigRansac(4000,inlierTol));
  detectImageFeatures(colorImages);
  computeConnections();
  printConnectionMatrix();
  System.out.println(""String_Node_Str"");
  CameraView seed=selectMostConnectFrame();
  CameraView seedNext=estimateFeatureLocations(seed);
  estimateAllFeatures(seed,seedNext);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  pruneFeatures();
  System.out.println(""String_Node_Str"" + featuresAll.size() + ""String_Node_Str""+ featuresPruned.size());
  System.out.println(""String_Node_Str"");
  long before=System.currentTimeMillis();
  performBundleAdjustment(seed,intrinsic);
  long after=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (after - before) + ""String_Node_Str"");
  visualizeResults(intrinsic);
  System.out.println(""String_Node_Str"");
}","/** 
 * Process the images and reconstructor the scene as a point cloud using matching interest points between images.
 */
public void process(CameraPinholeRadial intrinsic,List<BufferedImage> colorImages){
  this.intrinsic=intrinsic;
  pixelToNorm=LensDistortionOps.narrow(intrinsic).undistort_F64(true,false);
  estimateEssential=FactoryMultiViewRobust.essentialRansac(new ConfigEssential(intrinsic),new ConfigRansac(4000,inlierTol));
  estimatePnP=FactoryMultiViewRobust.pnpRansac(new ConfigPnP(intrinsic),new ConfigRansac(4000,inlierTol));
  detectImageFeatures(colorImages);
  computeConnections();
  printConnectionMatrix();
  System.out.println(""String_Node_Str"");
  CameraView seed=selectMostConnectFrame();
  CameraView seedNext=estimateFeatureLocations(seed);
  estimateAllFeatures(seed,seedNext);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  featuresPruned.addAll(featuresAll);
  System.out.println(""String_Node_Str"" + featuresAll.size() + ""String_Node_Str""+ featuresPruned.size());
  System.out.println(""String_Node_Str"");
  long before=System.currentTimeMillis();
  performBundleAdjustment(seed,intrinsic);
  long after=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (after - before) + ""String_Node_Str"");
  visualizeResults(intrinsic);
  System.out.println(""String_Node_Str"");
}",0.9717939074840164
150564,"private void triangulateNoLocation(CameraView target){
  Vector3D_F64 arrowA=new Vector3D_F64();
  Vector3D_F64 arrowB=new Vector3D_F64();
  TriangulateTwoViewsCalibrated triangulator=FactoryMultiView.triangulateTwoGeometric();
  Se3_F64 otherToTarget=new Se3_F64();
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    other.viewToWorld.concat(target.viewToWorld.invert(null),otherToTarget);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      int indexTarget=isSrc ? a.src : a.dst;
      int indexOther=isSrc ? a.dst : a.src;
      if (target.features3D[indexTarget] != null || other.features3D[indexOther] != null)       continue;
      Point2D_F64 normOther=other.featureNorm.get(indexOther);
      Point2D_F64 normTarget=target.featureNorm.get(indexTarget);
      arrowA.set(normOther.x,normOther.y,1);
      arrowB.set(normTarget.x,normTarget.y,1);
      GeometryMath_F64.mult(otherToTarget.R,arrowA,arrowA);
      double angle=UtilVector3D_F64.acute(arrowA,arrowB);
      if (angle < TRIANGULATE_MIN_ANGLE)       continue;
      Feature3D f=new Feature3D();
      if (!triangulator.triangulate(normOther,normTarget,otherToTarget,f.worldPt))       continue;
      SePointOps_F64.transform(target.viewToWorld,f.worldPt,f.worldPt);
      f.views.add(target.index);
      f.views.add(other.index);
      f.feature.add(indexTarget);
      f.feature.add(indexOther);
      f.color=target.colors.get(indexTarget);
      featuresAll.add(f);
      target.features3D[indexTarget]=f;
      other.features3D[indexOther]=f;
    }
  }
}","private void triangulateNoLocation(CameraView target){
  Vector3D_F64 arrowA=new Vector3D_F64();
  Vector3D_F64 arrowB=new Vector3D_F64();
  TriangulateTwoViewsCalibrated triangulator=FactoryMultiView.triangulateTwoGeometric();
  Se3_F64 otherToTarget=new Se3_F64();
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    other.viewToWorld.concat(target.viewToWorld.invert(null),otherToTarget);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      int indexTarget=isSrc ? a.src : a.dst;
      int indexOther=isSrc ? a.dst : a.src;
      if (target.features3D[indexTarget] != null || other.features3D[indexOther] != null)       continue;
      Point2D_F64 normOther=other.featureNorm.get(indexOther);
      Point2D_F64 normTarget=target.featureNorm.get(indexTarget);
      arrowA.set(normOther.x,normOther.y,1);
      arrowB.set(normTarget.x,normTarget.y,1);
      GeometryMath_F64.mult(otherToTarget.R,arrowA,arrowA);
      double angle=UtilVector3D_F64.acute(arrowA,arrowB);
      if (angle < TRIANGULATE_MIN_ANGLE)       continue;
      Feature3D f=new Feature3D();
      if (!triangulator.triangulate(normOther,normTarget,otherToTarget,f.worldPt))       continue;
      SePointOps_F64.transform(other.viewToWorld,f.worldPt,f.worldPt);
      f.views.add(target);
      f.views.add(other);
      f.feature.add(indexTarget);
      f.feature.add(indexOther);
      f.color=target.colors.get(indexTarget);
      featuresAll.add(f);
      target.features3D[indexTarget]=f;
      other.features3D[indexOther]=f;
    }
  }
}",0.9932333039129156
150565,"public static void main(String[] args){
  String directory=UtilIO.pathExample(""String_Node_Str"");
  CameraPinholeRadial intrinsic=CalibrationIO.load(new File(directory,""String_Node_Str""));
  List<BufferedImage> images=UtilImageIO.loadImages(directory,""String_Node_Str"");
  while (images.size() > 8) {
    images.remove(8);
  }
  ExampleMultiviewSceneReconstruction example=new ExampleMultiviewSceneReconstruction();
  long before=System.currentTimeMillis();
  example.process(intrinsic,images);
  long after=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (after - before) / 1000.0 + ""String_Node_Str"");
}","public static void main(String[] args){
  String directory=UtilIO.pathExample(""String_Node_Str"");
  CameraPinholeRadial intrinsic=CalibrationIO.load(new File(directory,""String_Node_Str""));
  List<BufferedImage> images=UtilImageIO.loadImages(directory,""String_Node_Str"");
  while (images.size() > 12) {
    images.remove(12);
  }
  ExampleMultiviewSceneReconstruction example=new ExampleMultiviewSceneReconstruction();
  long before=System.currentTimeMillis();
  example.process(intrinsic,images);
  long after=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (after - before) / 1000.0 + ""String_Node_Str"");
}",0.9952153110047848
150566,"/** 
 * Bundle adjustment can run very slow if there are too many features. This uses a heuristic explained in the code to reduce the number of 3D features by removing redundant ones. Could improve this approach by applying stricture geometric constraints that should improve the feature quality, in theory.
 */
private void pruneFeatures(){
  List<Feature3D> candidates=new ArrayList<>();
  for (  CameraMotion m : graphEdges) {
    candidates.clear();
    for (int i=0; i < m.features.size(); i++) {
      AssociatedIndex a=m.features.get(i);
      Feature3D f=m.viewSrc.features3D[a.src];
      if (f != null && !f.included && f.views.size >= 3) {
        candidates.add(f);
      }
    }
    int totalSave=Math.min(TARGET_FEATURE_EDGE,candidates.size());
    Collections.shuffle(candidates);
    for (int i=0; i < totalSave; i++) {
      candidates.get(i).included=true;
    }
  }
  for (  Feature3D f : featuresAll) {
    if (f.included) {
      featuresPruned.add(f);
    }
  }
}","/** 
 * Bundle adjustment can run very slow if there are too many features. This uses a heuristic explained in the code to reduce the number of 3D features by removing redundant ones. Could improve this approach by applying stricture geometric constraints that should improve the feature quality, in theory.
 */
private void pruneFeatures(){
  List<Feature3D> candidates=new ArrayList<>();
  for (  CameraMotion m : graphEdges) {
    candidates.clear();
    for (int i=0; i < m.features.size(); i++) {
      AssociatedIndex a=m.features.get(i);
      Feature3D f=m.viewSrc.features3D[a.src];
      if (f != null && !f.included && f.views.size() >= 3) {
        candidates.add(f);
      }
    }
    int totalSave=Math.min(TARGET_FEATURE_EDGE,candidates.size());
    Collections.shuffle(candidates);
    for (int i=0; i < totalSave; i++) {
      candidates.get(i).included=true;
    }
  }
  for (  Feature3D f : featuresAll) {
    if (f.included) {
      featuresPruned.add(f);
    }
  }
}",0.9989858012170384
150567,"private CameraView estimateFeatureLocations(CameraView viewRoot){
  CameraMotion best=null;
  double bestScore=0;
  Rodrigues_F64 rod=new Rodrigues_F64();
  for (  CameraMotion e : viewRoot.connections) {
    ConvertRotation3D_F64.matrixToRodrigues(e.a_to_b.R,rod);
    double score=e.features.size() * rod.theta;
    System.out.println(""String_Node_Str"" + score + ""String_Node_Str""+ e.features.size()+ ""String_Node_Str""+ rod.theta);
    if (score > bestScore) {
      bestScore=score;
      best=e;
    }
  }
  if (best == null)   throw new RuntimeException(""String_Node_Str"");
  viewRoot.viewToWorld.reset();
  viewRoot.distanceFromRoot=0;
  best.a_to_b.T.normalize();
  CameraView viewB=best.destination(viewRoot);
  viewB.viewToWorld.set(best.motionSrcToDst(viewB));
  viewB.distanceFromRoot=1;
  triangulateMatchedFeatures(best);
  return viewB;
}","private CameraView estimateFeatureLocations(CameraView viewRoot){
  CameraMotion best=null;
  double bestScore=0;
  Rodrigues_F64 rod=new Rodrigues_F64();
  for (  CameraMotion e : viewRoot.connections) {
    ConvertRotation3D_F64.matrixToRodrigues(e.a_to_b.R,rod);
    double score=e.features.size() * rod.theta;
    System.out.println(""String_Node_Str"" + score + ""String_Node_Str""+ e.features.size()+ ""String_Node_Str""+ rod.theta);
    if (score > bestScore) {
      bestScore=score;
      best=e;
    }
  }
  if (best == null)   throw new RuntimeException(""String_Node_Str"");
  viewRoot.viewToWorld.reset();
  viewRoot.distanceFromRoot=0;
  best.a_to_b.T.normalize();
  CameraView viewB=best.destination(viewRoot);
  viewB.viewToWorld.set(best.motionSrcToDst(viewB));
  viewB.distanceFromRoot=1;
  triangulateInitialSeed(viewRoot,best);
  viewsAdded.add(viewRoot);
  viewsAdded.add(viewB);
  refineScene(viewRoot,featuresAll);
  return viewB;
}",0.9116175653140632
150568,"/** 
 * Uses the previously found motion between the two cameras to estimate the scale and 3D point of common features. If a feature already has a known 3D point that is not modified. Scale is found by computing the 3D coordinate of all points with a 3D point again then dividing the two distances. New features are also triangulated and have their location's update using this scale. A known feature has the current view added to its list of views.
 */
private boolean determinePose(CameraView target){
  List<Point2D3D> list=new ArrayList<>();
  List<Feature3D> features=new ArrayList<>();
  GrowQueue_I32 featureIndexes=new GrowQueue_I32();
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      Feature3D f=other.features3D[isSrc ? a.dst : a.src];
      if (f == null || f.mark == target.index)       continue;
      f.mark=target.index;
      features.add(f);
      featureIndexes.add(isSrc ? a.src : a.dst);
      Point2D_F64 norm=target.featureNorm.get(isSrc ? a.src : a.dst);
      Point2D3D p=new Point2D3D();
      p.location.set(f.worldPt);
      p.observation.set(norm);
      list.add(p);
    }
  }
  if (list.size() < 100 || !estimatePnP.process(list)) {
    System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ list.size());
    return false;
  }
  int N=estimatePnP.getMatchSet().size();
  System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ N+ ""String_Node_Str""+ list.size());
  for (int i=0; i < N; i++) {
    int which=estimatePnP.getInputIndex(i);
    Feature3D f=features.get(which);
    if (f.views.contains(target.index))     continue;
    f.views.add(target.index);
    f.feature.add(featureIndexes.get(which));
    target.features3D[featureIndexes.get(which)]=f;
  }
  Se3_F64 worldToView=estimatePnP.getModelParameters();
  target.viewToWorld.set(worldToView.invert(null));
  return true;
}","/** 
 * Uses the previously found motion between the two cameras to estimate the scale and 3D point of common features. If a feature already has a known 3D point that is not modified. Scale is found by computing the 3D coordinate of all points with a 3D point again then dividing the two distances. New features are also triangulated and have their location's update using this scale. A known feature has the current view added to its list of views.
 */
private boolean determinePose(CameraView target){
  List<Point2D3D> list=new ArrayList<>();
  List<Feature3D> features=new ArrayList<>();
  GrowQueue_I32 featureIndexes=new GrowQueue_I32();
  int closestDistance=Integer.MAX_VALUE;
  for (  CameraMotion c : target.connections) {
    boolean isSrc=c.viewSrc == target;
    CameraView other=c.destination(target);
    if (other.distanceFromRoot < 0)     continue;
    closestDistance=Math.min(closestDistance,other.distanceFromRoot);
    for (int i=0; i < c.features.size(); i++) {
      AssociatedIndex a=c.features.get(i);
      Feature3D f=other.features3D[isSrc ? a.dst : a.src];
      if (f == null || f.mark == target.index)       continue;
      f.mark=target.index;
      features.add(f);
      featureIndexes.add(isSrc ? a.src : a.dst);
      Point2D_F64 norm=target.featureNorm.get(isSrc ? a.src : a.dst);
      Point2D3D p=new Point2D3D();
      p.location.set(f.worldPt);
      p.observation.set(norm);
      list.add(p);
    }
  }
  if (list.size() < 100 || !estimatePnP.process(list)) {
    System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ list.size());
    return false;
  }
  target.distanceFromRoot=closestDistance + 1;
  int N=estimatePnP.getMatchSet().size();
  System.out.println(""String_Node_Str"" + target.index + ""String_Node_Str""+ N+ ""String_Node_Str""+ list.size());
  for (int i=0; i < N; i++) {
    int which=estimatePnP.getInputIndex(i);
    Feature3D f=features.get(which);
    if (f.views.contains(target.index))     continue;
    f.views.add(target);
    f.feature.add(featureIndexes.get(which));
    target.features3D[featureIndexes.get(which)]=f;
  }
  Se3_F64 worldToView=estimatePnP.getModelParameters();
  target.viewToWorld.set(worldToView.invert(null));
  return true;
}",0.9619666048237476
150569,"private void retriangulateFeatures(CameraPinholeRadial intrinsic){
  TriangulateLinearDLT triangulate=new TriangulateLinearDLT();
  List<Point2D_F64> observations=new ArrayList<>();
  List<Se3_F64> worldToView=new ArrayList<>();
  WorldToCameraToPixel wcp=new WorldToCameraToPixel();
  Point2D_F64 pixel=new Point2D_F64();
  int removedCount=0;
  for (int i=featuresAll.size() - 1; i >= 0; i--) {
    Feature3D f=featuresAll.get(i);
    if (f.views.size < 3)     continue;
    observations.clear();
    worldToView.clear();
    for (int j=0; j < f.views.size; j++) {
      CameraView v=graphNodes.get(f.views.get(j));
      worldToView.add(v.viewToWorld.invert(null));
      observations.add(v.featureNorm.get(f.feature.get(j)));
    }
    triangulate.triangulate(observations,worldToView,f.worldPt);
    for (int j=0; j < f.views.size; j++) {
      CameraView v=graphNodes.get(f.views.get(j));
      wcp.configure(intrinsic,worldToView.get(j));
      wcp.transform(f.worldPt,pixel);
      Point2D_F64 observed=v.featurePixels.get(f.feature.get(j));
      if (observed.distance(pixel) > 20) {
        removedCount++;
        featuresAll.remove(i);
        break;
      }
    }
  }
  System.out.println(""String_Node_Str"" + removedCount);
}","private void retriangulateFeatures(CameraPinholeRadial intrinsic){
  TriangulateLinearDLT triangulate=new TriangulateLinearDLT();
  List<Point2D_F64> observations=new ArrayList<>();
  List<Se3_F64> worldToView=new ArrayList<>();
  WorldToCameraToPixel wcp=new WorldToCameraToPixel();
  Point2D_F64 pixel=new Point2D_F64();
  int removedCount=0;
  for (int i=featuresAll.size() - 1; i >= 0; i--) {
    Feature3D f=featuresAll.get(i);
    if (f.views.size() < 3)     continue;
    observations.clear();
    worldToView.clear();
    for (int j=0; j < f.views.size(); j++) {
      CameraView v=f.views.get(j);
      worldToView.add(v.viewToWorld.invert(null));
      observations.add(v.featureNorm.get(f.feature.get(j)));
    }
    triangulate.triangulate(observations,worldToView,f.worldPt);
    for (int j=0; j < f.views.size(); j++) {
      CameraView v=f.views.get(j);
      wcp.configure(intrinsic,worldToView.get(j));
      wcp.transform(f.worldPt,pixel);
      Point2D_F64 observed=v.featurePixels.get(f.feature.get(j));
      if (observed.distance(pixel) > 20) {
        removedCount++;
        featuresAll.remove(i);
        break;
      }
    }
  }
  System.out.println(""String_Node_Str"" + removedCount);
}",0.8261224489795919
150570,"/** 
 * Perform a breath first search to find the structure of all the remaining camrea views
 */
private void estimateAllFeatures(CameraView seedA,CameraView seedB){
  List<CameraView> open=new ArrayList<>();
  addUnvistedToStack(seedA,open);
  addUnvistedToStack(seedB,open);
  while (!open.isEmpty()) {
    System.out.println(""String_Node_Str"" + open.size());
    CameraView v=open.remove(0);
    System.out.println(""String_Node_Str"" + v.index);
    int bestDistance=Integer.MAX_VALUE;
    CameraMotion best=null;
    for (    CameraMotion m : v.connections) {
      CameraView o=m.destination(v);
      if (o.distanceFromRoot >= 0 && o.distanceFromRoot < bestDistance) {
        best=m;
        bestDistance=o.distanceFromRoot;
      }
    }
    if (best == null)     throw new RuntimeException(""String_Node_Str"");
    v.distanceFromRoot=best.destination(v).distanceFromRoot + 1;
    if (!determinePose(v)) {
      System.out.println(""String_Node_Str"");
      best.destination(v).connections.remove(best);
      v.connections.remove(best);
      graphEdges.remove(best);
    }
 else {
      triangulateNoLocation(v);
    }
    addUnvistedToStack(v,open);
  }
}","/** 
 * Perform a breath first search to find the structure of all the remaining camrea views
 */
private void estimateAllFeatures(CameraView seedA,CameraView seedB){
  List<CameraView> open=new ArrayList<>();
  addUnvistedToStack(seedA,open);
  addUnvistedToStack(seedB,open);
  while (!open.isEmpty()) {
    System.out.println(""String_Node_Str"" + open.size());
    CameraView v=open.remove(0);
    System.out.println(""String_Node_Str"" + v.index);
    if (!determinePose(v)) {
      System.out.println(""String_Node_Str"");
      for (      CameraMotion m : v.connections) {
        CameraView a=m.destination(v);
        a.connections.remove(m);
        graphEdges.remove(m);
      }
      graphNodes.remove(v);
      for (int i=0; i < graphNodes.size(); i++) {
        graphNodes.get(i).index=i;
      }
    }
 else {
      triangulateNoLocation(v);
      viewsAdded.add(v);
    }
    addUnvistedToStack(v,open);
  }
}",0.456072971675468
150571,"private void performBundleAdjustment(CameraView seed,CameraPinholeRadial intrinsic){
  BundleAdjustmentShur_DSCC sba=new BundleAdjustmentShur_DSCC(1e-3);
  sba.configure(1e-4,1e-4,20);
  BundleAdjustmentSceneStructure structure=new BundleAdjustmentSceneStructure();
  BundleAdjustmentObservations observations=new BundleAdjustmentObservations(graphNodes.size());
  structure.initialize(1,graphNodes.size(),featuresPruned.size());
  double scale=Math.max(intrinsic.width,intrinsic.height);
  intrinsic.fx/=scale;
  intrinsic.fy/=scale;
  intrinsic.cx/=scale;
  intrinsic.cy/=scale;
  intrinsic.skew/=scale;
  structure.setCamera(0,true,intrinsic);
  for (int i=0; i < graphNodes.size(); i++) {
    CameraView v=graphNodes.get(i);
    structure.setView(i,v == seed,v.viewToWorld.invert(null));
    structure.connectViewToCamera(i,0);
  }
  for (int indexPoint=0; indexPoint < featuresPruned.size(); indexPoint++) {
    Feature3D f=featuresPruned.get(indexPoint);
    structure.setPoint(indexPoint,f.worldPt.x,f.worldPt.y,f.worldPt.z);
    for (int j=0; j < f.views.size; j++) {
      int indexView=f.views.get(j);
      structure.connectPointToView(indexPoint,indexView);
      Point2D_F64 pixel=graphNodes.get(indexView).featurePixels.get(f.feature.get(j));
      observations.getView(indexView).add(indexPoint,(float)(pixel.x / scale),(float)(pixel.y / scale));
    }
  }
  if (!sba.optimize(structure,observations)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + sba.getErrorBefore() + ""String_Node_Str""+ sba.getErrorAfter());
  for (int i=0; i < graphNodes.size(); i++) {
    structure.views[i].worldToView.invert(graphNodes.get(i).viewToWorld);
  }
  for (int i=0; i < featuresPruned.size(); i++) {
    featuresPruned.get(i).worldPt.set(structure.points[i]);
  }
  intrinsic.fx*=scale;
  intrinsic.fy*=scale;
  intrinsic.cx*=scale;
  intrinsic.cy*=scale;
  intrinsic.skew*=scale;
}","private void performBundleAdjustment(CameraView seed,CameraPinholeRadial intrinsic){
  BundleAdjustmentShur_DSCC sba=new BundleAdjustmentShur_DSCC(1e-3);
  sba.configure(1e-4,1e-4,20);
  BundleAdjustmentSceneStructure structure=new BundleAdjustmentSceneStructure();
  BundleAdjustmentObservations observations=new BundleAdjustmentObservations(graphNodes.size());
  structure.initialize(1,graphNodes.size(),featuresPruned.size());
  double scale=Math.max(intrinsic.width,intrinsic.height);
  intrinsic.fx/=scale;
  intrinsic.fy/=scale;
  intrinsic.cx/=scale;
  intrinsic.cy/=scale;
  intrinsic.skew/=scale;
  structure.setCamera(0,true,intrinsic);
  for (int i=0; i < graphNodes.size(); i++) {
    CameraView v=graphNodes.get(i);
    structure.setView(i,v == seed,v.viewToWorld.invert(null));
    structure.connectViewToCamera(i,0);
  }
  for (int indexPoint=0; indexPoint < featuresPruned.size(); indexPoint++) {
    Feature3D f=featuresPruned.get(indexPoint);
    structure.setPoint(indexPoint,f.worldPt.x,f.worldPt.y,f.worldPt.z);
    for (int j=0; j < f.views.size(); j++) {
      CameraView view=f.views.get(j);
      structure.connectPointToView(indexPoint,view.index);
      Point2D_F64 pixel=graphNodes.get(view.index).featurePixels.get(f.feature.get(j));
      observations.getView(view.index).add(indexPoint,(float)(pixel.x / scale),(float)(pixel.y / scale));
    }
  }
  if (!sba.optimize(structure,observations)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + sba.getErrorBefore() + ""String_Node_Str""+ sba.getErrorAfter());
  for (int i=0; i < graphNodes.size(); i++) {
    structure.views[i].worldToView.invert(graphNodes.get(i).viewToWorld);
  }
  for (int i=0; i < featuresPruned.size(); i++) {
    featuresPruned.get(i).worldPt.set(structure.points[i]);
  }
  intrinsic.fx*=scale;
  intrinsic.fy*=scale;
  intrinsic.cx*=scale;
  intrinsic.cy*=scale;
  intrinsic.skew*=scale;
}",0.9476399277792108
150572,"/** 
 * J[rows,col:(col+3)] =  [a;b]*R
 */
private void addToJacobian(DMatrixSparseTriplet tripplet,int col,double a[],double b[],DMatrixRMaj R){
  tripplet.addItem(jacRowX,col + 0,a[0] * R.data[0] + a[1] * R.data[3] + a[2] * R.data[6]);
  tripplet.addItem(jacRowX,col + 1,a[0] * R.data[1] + a[1] * R.data[4] + a[2] * R.data[7]);
  tripplet.addItem(jacRowX,col + 2,a[0] * R.data[2] + a[1] * R.data[5] + a[2] * R.data[8]);
  tripplet.addItem(jacRowY,col + 0,b[0] * R.data[0] + b[1] * R.data[3] + b[2] * R.data[6]);
  tripplet.addItem(jacRowY,col + 1,b[0] * R.data[1] + b[1] * R.data[4] + b[2] * R.data[7]);
  tripplet.addItem(jacRowY,col + 2,b[0] * R.data[2] + b[1] * R.data[5] + b[2] * R.data[8]);
}","private void addToJacobian(DMatrixSparseTriplet tripplet,int col,double a[],double b[],DMatrixRMaj R,Point3D_F64 X){
  double x=R.data[0] * X.x + R.data[1] * X.y + R.data[2] * X.z;
  double y=R.data[3] * X.x + R.data[4] * X.y + R.data[5] * X.z;
  double z=R.data[6] * X.x + R.data[7] * X.y + R.data[8] * X.z;
  tripplet.addItem(jacRowX,col,a[0] * x + a[1] * y + a[2] * z);
  tripplet.addItem(jacRowY,col,b[0] * x + b[1] * y + b[2] * z);
}",0.3394898856640281
150573,"@Override public void process(double[] input,DMatrixSparseCSC left,DMatrixSparseCSC right){
  int numRows=getNumOfOutputsM();
  int numViewParam=numViewsUnknown * 6;
  int numPointParam=numParameters - numViewParam;
  tripletView.reshape(numRows,numViewParam);
  tripletPoint.reshape(numRows,numPointParam);
  int observationCount=0;
  for (int viewIndex=0; viewIndex < structure.views.length; viewIndex++) {
    BundleAdjustmentSceneStructure.View view=structure.views[viewIndex];
    BundleAdjustmentSceneStructure.Camera camera=structure.cameras[view.camera];
    if (!view.known) {
      int paramIndex=viewIndex * 6;
      double rodX=input[paramIndex];
      double rodY=input[paramIndex + 1];
      double rodZ=input[paramIndex + 2];
      worldToView.T.x=input[paramIndex + 3];
      worldToView.T.y=input[paramIndex + 4];
      worldToView.T.z=input[paramIndex + 5];
      rodrigues.setParamVector(rodX,rodY,rodZ);
      rodJacobian.process(rodX,rodY,rodZ);
      ConvertRotation3D_F64.rodriguesToMatrix(rodrigues,worldToView.R);
    }
 else {
      worldToView.set(view.worldToView);
    }
    int cameraParamStartIndex=cameraParameterIndexes[view.camera];
    if (!camera.known) {
      camera.model.setParameters(input,cameraParamStartIndex);
    }
    BundleAdjustmentObservations.View obsView=observations.views[viewIndex];
    for (int i=0; i < obsView.size(); i++) {
      int featureIndex=indexFirstPoint + obsView.feature.get(i) * 3;
      worldPt.x=input[featureIndex];
      worldPt.y=input[featureIndex + 1];
      worldPt.z=input[featureIndex + 2];
      SePointOps_F64.transform(worldToView,worldPt,cameraPt);
      jacRowX=observationCount * 2;
      jacRowY=jacRowX + 1;
      if (!camera.known) {
        int N=camera.model.getParameterCount();
        camera.model.jacobian(cameraPt.x,cameraPt.y,cameraPt.z,pointGradX,pointGradY,calibGradX,calibGradY);
        for (int j=0; j < N; j++) {
          tripletPoint.addItem(jacRowX,cameraParamStartIndex + j,calibGradX[j]);
          tripletPoint.addItem(jacRowY,cameraParamStartIndex + j,calibGradY[j]);
        }
      }
 else {
        camera.model.jacobian(cameraPt.x,cameraPt.y,cameraPt.z,pointGradX,pointGradY);
      }
      addToJacobian(tripletPoint,featureIndex,pointGradX,pointGradY,worldToView.R);
      if (!view.known) {
        int col=view.camera * 6;
        addToJacobian(tripletView,col,pointGradX,pointGradY,rodJacobian.Rx);
        addToJacobian(tripletView,col,pointGradX,pointGradY,rodJacobian.Ry);
        addToJacobian(tripletView,col,pointGradX,pointGradY,rodJacobian.Rz);
        tripletView.addItem(jacRowX,col + 3,pointGradX[0]);
        tripletView.addItem(jacRowX,col + 4,pointGradX[1]);
        tripletView.addItem(jacRowX,col + 5,pointGradX[2]);
        tripletView.addItem(jacRowY,col + 3,pointGradY[0]);
        tripletView.addItem(jacRowY,col + 4,pointGradY[1]);
        tripletView.addItem(jacRowY,col + 5,pointGradY[2]);
      }
      observationCount++;
    }
  }
  ConvertDMatrixStruct.convert(tripletView,left);
  ConvertDMatrixStruct.convert(tripletPoint,right);
}","@Override public void process(double[] input,DMatrixSparseCSC left,DMatrixSparseCSC right){
  int numRows=getNumOfOutputsM();
  int numViewParam=numViewsUnknown * 6;
  int numPointParam=numParameters - numViewParam;
  tripletView.reshape(numRows,numViewParam);
  tripletPoint.reshape(numRows,numPointParam);
  int observationCount=0;
  int columnLastPointJac=structure.points.length * 3;
  for (int viewIndex=0; viewIndex < structure.views.length; viewIndex++) {
    BundleAdjustmentSceneStructure.View view=structure.views[viewIndex];
    BundleAdjustmentSceneStructure.Camera camera=structure.cameras[view.camera];
    if (!view.known) {
      int paramIndex=viewParameterIndexes[viewIndex];
      double rodX=input[paramIndex];
      double rodY=input[paramIndex + 1];
      double rodZ=input[paramIndex + 2];
      worldToView.T.x=input[paramIndex + 3];
      worldToView.T.y=input[paramIndex + 4];
      worldToView.T.z=input[paramIndex + 5];
      rodrigues.setParamVector(rodX,rodY,rodZ);
      rodJacobian.process(rodX,rodY,rodZ);
      ConvertRotation3D_F64.rodriguesToMatrix(rodrigues,worldToView.R);
    }
 else {
      worldToView.set(view.worldToView);
    }
    int cameraParamStartIndex=cameraParameterIndexes[view.camera];
    if (!camera.known) {
      camera.model.setParameters(input,indexLastPoint + cameraParamStartIndex);
    }
    BundleAdjustmentObservations.View obsView=observations.views[viewIndex];
    for (int i=0; i < obsView.size(); i++) {
      int columnOfPointInJac=obsView.feature.get(i) * 3;
      int indexOfPointInInput=indexFirstPoint + columnOfPointInJac;
      worldPt.x=input[indexOfPointInInput];
      worldPt.y=input[indexOfPointInInput + 1];
      worldPt.z=input[indexOfPointInInput + 2];
      SePointOps_F64.transform(worldToView,worldPt,cameraPt);
      jacRowX=observationCount * 2;
      jacRowY=jacRowX + 1;
      if (!camera.known) {
        int N=camera.model.getParameterCount();
        camera.model.jacobian(cameraPt.x,cameraPt.y,cameraPt.z,pointGradX,pointGradY,calibGradX,calibGradY);
        for (int j=0; j < N; j++) {
          tripletPoint.addItem(jacRowX,columnLastPointJac + cameraParamStartIndex + j,calibGradX[j]);
          tripletPoint.addItem(jacRowY,columnLastPointJac + cameraParamStartIndex + j,calibGradY[j]);
        }
      }
 else {
        camera.model.jacobian(cameraPt.x,cameraPt.y,cameraPt.z,pointGradX,pointGradY);
      }
      addToJacobian(tripletPoint,columnOfPointInJac,pointGradX,pointGradY,worldToView.R);
      if (!view.known) {
        int col=viewParameterIndexes[viewIndex];
        addToJacobian(tripletView,col + 0,pointGradX,pointGradY,rodJacobian.Rx,worldPt);
        addToJacobian(tripletView,col + 1,pointGradX,pointGradY,rodJacobian.Ry,worldPt);
        addToJacobian(tripletView,col + 2,pointGradX,pointGradY,rodJacobian.Rz,worldPt);
        tripletView.addItem(jacRowX,col + 3,pointGradX[0]);
        tripletView.addItem(jacRowY,col + 3,pointGradY[0]);
        tripletView.addItem(jacRowX,col + 4,pointGradX[1]);
        tripletView.addItem(jacRowY,col + 4,pointGradY[1]);
        tripletView.addItem(jacRowX,col + 5,pointGradX[2]);
        tripletView.addItem(jacRowY,col + 5,pointGradY[2]);
      }
      observationCount++;
    }
  }
  ConvertDMatrixStruct.convert(tripletView,left);
  ConvertDMatrixStruct.convert(tripletPoint,right);
}",0.8900996264009963
150574,"public void configure(BundleAdjustmentSceneStructure structure,BundleAdjustmentObservations observations){
  this.structure=structure;
  this.observations=observations;
  numViewsUnknown=structure.getUnknownViewCount();
  int numCameraParameters=structure.getUnknownCameraParameterCount();
  indexFirstPoint=numViewsUnknown * 6;
  numParameters=indexFirstPoint + structure.points.length * 3 + numCameraParameters;
  cameraParameterIndexes=new int[structure.cameras.length];
  int index=numParameters - numCameraParameters;
  int largestcameraSize=0;
  for (int i=0; i < structure.cameras.length; i++) {
    if (!structure.cameras[i].known) {
      cameraParameterIndexes[i]=index;
      int count=structure.cameras[i].model.getParameterCount();
      largestcameraSize=Math.max(largestcameraSize,count);
      index+=count;
    }
  }
  calibGradX=new double[largestcameraSize];
  calibGradY=new double[largestcameraSize];
}","public void configure(BundleAdjustmentSceneStructure structure,BundleAdjustmentObservations observations){
  this.structure=structure;
  this.observations=observations;
  numViewsUnknown=structure.getUnknownViewCount();
  int numCameraParameters=structure.getUnknownCameraParameterCount();
  indexFirstPoint=numViewsUnknown * 6;
  indexLastPoint=indexFirstPoint + structure.points.length * 3;
  numParameters=indexLastPoint + numCameraParameters;
  viewParameterIndexes=new int[structure.views.length];
  int index=0;
  for (int i=0; i < structure.views.length; i++) {
    viewParameterIndexes[i]=index;
    if (!structure.views[i].known) {
      index+=6;
    }
  }
  cameraParameterIndexes=new int[structure.cameras.length];
  index=0;
  int largestCameraSize=0;
  for (int i=0; i < structure.cameras.length; i++) {
    if (!structure.cameras[i].known) {
      cameraParameterIndexes[i]=index;
      int count=structure.cameras[i].model.getParameterCount();
      largestCameraSize=Math.max(largestCameraSize,count);
      index+=count;
    }
  }
  calibGradX=new double[largestCameraSize];
  calibGradY=new double[largestCameraSize];
}",0.8025230470645318
150575,"/** 
 * Check the jacobians numerically
 */
@Test public void jacobians(){
  double X[]=new double[]{0.2,0.6,2};
  for (  double p[] : parameters) {
    DerivativeChecker.jacobian(new FunctionOfPoint(p),new JacobianOfPoint(p),X,1e-4);
    DerivativeChecker.jacobian(new FunctionOfParameters(X),new JacobianOfParameters(X),p,1e-4);
  }
}","/** 
 * Check the jacobians numerically
 */
@Test public void jacobians(){
  double X[]=new double[]{0.2,0.6,2};
  for (  double p[] : parameters) {
    assertTrue(DerivativeChecker.jacobian(new FunctionOfPoint(p),new JacobianOfPoint(p),X,1e-4));
    assertTrue(DerivativeChecker.jacobian(new FunctionOfParameters(X),new JacobianOfParameters(X),p,1e-4));
  }
}",0.9655172413793104
150576,"/** 
 * Change each parameter and see if it changes the output
 */
@Test public void changeInParamChangesOutput(){
  BundleAdjustmentSceneStructure structure=createScene(rand);
  double param[]=new double[structure.getParameterCount()];
  new CodecBundleAdjustmentSceneStructure().encode(structure,param);
  BundleAdjustmentObservations obs=createObservations(structure);
  BundleAdjustmentResidualFunction alg=new BundleAdjustmentResidualFunction();
  alg.configure(structure,obs);
  double[] original=new double[alg.getNumOfOutputsM()];
  double[] found=new double[alg.getNumOfOutputsM()];
  alg.process(param,original);
  for (int paramIndex=0; paramIndex < original.length; paramIndex++) {
    double v=param[paramIndex];
    param[paramIndex]+=0.001;
    alg.process(param,found);
    boolean identical=true;
    for (int i=0; i < found.length; i++) {
      if (Math.abs(original[i] - found[i]) > UtilEjml.TEST_F64) {
        identical=false;
        break;
      }
    }
    assertFalse(identical);
    param[paramIndex]=v;
  }
}","/** 
 * Change each parameter and see if it changes the output
 */
@Test public void changeInParamChangesOutput(){
  BundleAdjustmentSceneStructure structure=createScene(rand);
  double param[]=new double[structure.getParameterCount()];
  new CodecBundleAdjustmentSceneStructure().encode(structure,param);
  BundleAdjustmentObservations obs=createObservations(rand,structure);
  BundleAdjustmentResidualFunction alg=new BundleAdjustmentResidualFunction();
  alg.configure(structure,obs);
  double[] original=new double[alg.getNumOfOutputsM()];
  double[] found=new double[alg.getNumOfOutputsM()];
  alg.process(param,original);
  for (int paramIndex=0; paramIndex < original.length; paramIndex++) {
    double v=param[paramIndex];
    param[paramIndex]+=0.001;
    alg.process(param,found);
    boolean identical=true;
    for (int i=0; i < found.length; i++) {
      if (Math.abs(original[i] - found[i]) > UtilEjml.TEST_F64) {
        identical=false;
        break;
      }
    }
    assertFalse(identical);
    param[paramIndex]=v;
  }
}",0.9975903614457832
150577,"private BundleAdjustmentObservations createObservations(BundleAdjustmentSceneStructure structure){
  BundleAdjustmentObservations obs=new BundleAdjustmentObservations(structure.views.length);
  for (int j=0; j < structure.points.length; j++) {
    BundleAdjustmentSceneStructure.Point p=structure.points[j];
    for (int i=0; i < p.views.size; i++) {
      BundleAdjustmentObservations.View v=obs.getView(p.views.get(i));
      v.feature.add(j);
      v.observations.add(rand.nextInt(300) + 20);
      v.observations.add(rand.nextInt(300) + 20);
    }
  }
  return obs;
}","public static BundleAdjustmentObservations createObservations(Random rand,BundleAdjustmentSceneStructure structure){
  BundleAdjustmentObservations obs=new BundleAdjustmentObservations(structure.views.length);
  for (int j=0; j < structure.points.length; j++) {
    BundleAdjustmentSceneStructure.Point p=structure.points[j];
    for (int i=0; i < p.views.size; i++) {
      BundleAdjustmentObservations.View v=obs.getView(p.views.get(i));
      v.feature.add(j);
      v.observations.add(rand.nextInt(300) + 20);
      v.observations.add(rand.nextInt(300) + 20);
    }
  }
  return obs;
}",0.9741379310344828
150578,"/** 
 * Makes sure that when given the same input it produces the same output
 */
@Test public void multipleCalls(){
  BundleAdjustmentSceneStructure structure=createScene(rand);
  BundleAdjustmentObservations obs=createObservations(structure);
  double param[]=new double[structure.getParameterCount()];
  new CodecBundleAdjustmentSceneStructure().encode(structure,param);
  BundleAdjustmentResidualFunction alg=new BundleAdjustmentResidualFunction();
  alg.configure(structure,obs);
  double[] expected=new double[alg.getNumOfOutputsM()];
  double[] found=new double[alg.getNumOfOutputsM()];
  alg.process(param,expected);
  alg.process(param,found);
  assertArrayEquals(expected,found,UtilEjml.TEST_F64);
}","/** 
 * Makes sure that when given the same input it produces the same output
 */
@Test public void multipleCalls(){
  BundleAdjustmentSceneStructure structure=createScene(rand);
  BundleAdjustmentObservations obs=createObservations(rand,structure);
  double param[]=new double[structure.getParameterCount()];
  new CodecBundleAdjustmentSceneStructure().encode(structure,param);
  BundleAdjustmentResidualFunction alg=new BundleAdjustmentResidualFunction();
  alg.configure(structure,obs);
  double[] expected=new double[alg.getNumOfOutputsM()];
  double[] found=new double[alg.getNumOfOutputsM()];
  alg.process(param,expected);
  alg.process(param,found);
  assertArrayEquals(expected,found,UtilEjml.TEST_F64);
}",0.9964862965565706
150579,"/** 
 * Closes the camera. Returns true if the camera was not already closed and it closed it
 * @return
 */
protected boolean closeCamera(){
  if (verbose)   Log.i(TAG,""String_Node_Str"");
  if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  boolean closed=false;
  if (verbose) {
    StackTraceElement[] trace=new RuntimeException().getStackTrace();
    for (int i=0; i < Math.min(trace.length,3); i++) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ trace[i].toString());
    }
  }
  try {
    open.mLock.lock();
    if (verbose)     Log.i(TAG,""String_Node_Str"" + (open.mCameraDevice == null));
    closePreviewSession();
    if (null != open.mCameraDevice) {
      closed=true;
      open.mCameraDevice.close();
      open.mCameraDevice=null;
    }
    open.mCameraSize=null;
    open.mCameraCharacterstics=null;
  }
  finally {
    open.mLock.unlock();
  }
  return closed;
}","/** 
 * Closes the camera. Returns true if the camera was not already closed and it closed it
 * @return
 */
protected boolean closeCamera(){
  if (verbose)   Log.i(TAG,""String_Node_Str"");
  if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  boolean closed=false;
  if (verbose) {
    StackTraceElement[] trace=new RuntimeException().getStackTrace();
    for (int i=0; i < Math.min(trace.length,3); i++) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ trace[i].toString());
    }
  }
  open.mLock.lock();
  try {
    if (verbose)     Log.i(TAG,""String_Node_Str"" + (open.mCameraDevice == null) + ""String_Node_Str""+ open.state);
    closePreviewSession();
    if (open.state == CameraState.OPENING) {
      open.state=CameraState.CLOSING;
      if (open.mCameraDevice != null) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 else {
      if (null != open.mCameraDevice) {
        closed=true;
        open.mCameraDevice.close();
        open.mCameraDevice=null;
      }
      open.state=CameraState.CLOSED;
      open.mCameraSize=null;
      open.mCameraCharacterstics=null;
    }
  }
  finally {
    open.mLock.unlock();
  }
  return closed;
}",0.8359409924005364
150580,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  displayMetrics=Resources.getSystem().getDisplayMetrics();
}","@Override protected void onCreate(Bundle savedInstanceState){
  if (verbose)   Log.i(TAG,""String_Node_Str"");
  super.onCreate(savedInstanceState);
  displayMetrics=Resources.getSystem().getDisplayMetrics();
}",0.8726287262872628
150581,"/** 
 * Tries to open a   {@link CameraDevice}. The result is listened by `mStateCallback`.
 */
@SuppressWarnings(""String_Node_Str"") protected void openCamera(int widthTexture,int heightTexture){
  if (verbose)   Log.i(TAG,""String_Node_Str"" + widthTexture + ""String_Node_Str""+ heightTexture+ ""String_Node_Str"");
  if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (isFinishing()) {
    return;
  }
  CameraManager manager=(CameraManager)getSystemService(Context.CAMERA_SERVICE);
  if (manager == null)   throw new RuntimeException(""String_Node_Str"");
  this.viewWidth=widthTexture;
  this.viewHeight=heightTexture;
  this.cameraToDisplayDensity=0;
  this.firstFrame=true;
  boolean releaseCamera=true;
  try {
    if (verbose)     Log.d(TAG,""String_Node_Str"");
    if (!open.mLock.tryLock(2500,TimeUnit.MILLISECONDS)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (mBackgroundHandler == null) {
      if (verbose)       Log.i(TAG,""String_Node_Str"");
      return;
    }
    if (open.mCameraDevice != null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    String[] cameras=manager.getCameraIdList();
    for (    String cameraId : cameras) {
      CameraCharacteristics characteristics=manager.getCameraCharacteristics(cameraId);
      if (!selectCamera(cameraId,characteristics))       continue;
      StreamConfigurationMap map=characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
      if (map == null) {
        continue;
      }
      Size[] sizes=map.getOutputSizes(ImageFormat.YUV_420_888);
      int which=selectResolution(widthTexture,heightTexture,sizes);
      if (which < 0 || which >= sizes.length)       continue;
      open.mCameraSize=sizes[which];
      open.cameraId=cameraId;
      open.mSensorOrientation=characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
      this.cameraToDisplayDensity=displayDensityAdjusted();
      if (verbose)       Log.i(TAG,""String_Node_Str"" + cameraId + ""String_Node_Str""+ open.mSensorOrientation);
      open.mCameraCharacterstics=characteristics;
      onCameraResolutionChange(open.mCameraSize.getWidth(),open.mCameraSize.getHeight(),open.mSensorOrientation);
      try {
        mPreviewReader=ImageReader.newInstance(open.mCameraSize.getWidth(),open.mCameraSize.getHeight(),ImageFormat.YUV_420_888,2);
        mPreviewReader.setOnImageAvailableListener(onAvailableListener,mBackgroundHandler);
        configureTransform(widthTexture,heightTexture);
        manager.openCamera(cameraId,mStateCallback,null);
        releaseCamera=false;
      }
 catch (      IllegalArgumentException e) {
        Toast.makeText(this,e.getMessage(),Toast.LENGTH_LONG).show();
        finish();
      }
      return;
    }
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    finish();
  }
 catch (  CameraAccessException e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    finish();
  }
catch (  NullPointerException e) {
    e.printStackTrace();
    Log.e(TAG,""String_Node_Str"");
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    finish();
  }
catch (  InterruptedException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
 finally {
    if (releaseCamera)     open.mLock.unlock();
  }
}","/** 
 * Tries to open a   {@link CameraDevice}. The result is listened by `mStateCallback`.
 */
@SuppressWarnings(""String_Node_Str"") protected void openCamera(int widthTexture,int heightTexture){
  if (verbose)   Log.i(TAG,""String_Node_Str"" + widthTexture + ""String_Node_Str""+ heightTexture+ ""String_Node_Str"");
  if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (isFinishing()) {
    return;
  }
  CameraManager manager=(CameraManager)getSystemService(Context.CAMERA_SERVICE);
  if (manager == null)   throw new RuntimeException(""String_Node_Str"");
  this.viewWidth=widthTexture;
  this.viewHeight=heightTexture;
  this.cameraToDisplayDensity=0;
  this.firstFrame=true;
  boolean releaseCamera=true;
  try {
    if (verbose)     Log.d(TAG,""String_Node_Str"");
    if (!open.mLock.tryLock(2500,TimeUnit.MILLISECONDS)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    if (open.state != CameraState.CLOSED) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      open.state=CameraState.OPENING;
    }
    if (mBackgroundHandler == null) {
      if (verbose)       Log.i(TAG,""String_Node_Str"");
      return;
    }
    if (open.mCameraDevice != null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    String[] cameras=manager.getCameraIdList();
    for (    String cameraId : cameras) {
      CameraCharacteristics characteristics=manager.getCameraCharacteristics(cameraId);
      if (!selectCamera(cameraId,characteristics))       continue;
      StreamConfigurationMap map=characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
      if (map == null) {
        continue;
      }
      Size[] sizes=map.getOutputSizes(ImageFormat.YUV_420_888);
      int which=selectResolution(widthTexture,heightTexture,sizes);
      if (which < 0 || which >= sizes.length)       continue;
      open.mCameraSize=sizes[which];
      open.cameraId=cameraId;
      open.mSensorOrientation=characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
      this.cameraToDisplayDensity=displayDensityAdjusted();
      if (verbose)       Log.i(TAG,""String_Node_Str"" + cameraId + ""String_Node_Str""+ open.mSensorOrientation);
      open.mCameraCharacterstics=characteristics;
      onCameraResolutionChange(open.mCameraSize.getWidth(),open.mCameraSize.getHeight(),open.mSensorOrientation);
      try {
        mPreviewReader=ImageReader.newInstance(open.mCameraSize.getWidth(),open.mCameraSize.getHeight(),ImageFormat.YUV_420_888,2);
        mPreviewReader.setOnImageAvailableListener(onAvailableListener,mBackgroundHandler);
        configureTransform(widthTexture,heightTexture);
        manager.openCamera(cameraId,mStateCallback,null);
        releaseCamera=false;
      }
 catch (      IllegalArgumentException e) {
        Toast.makeText(this,e.getMessage(),Toast.LENGTH_LONG).show();
        finish();
      }
      return;
    }
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    finish();
  }
 catch (  CameraAccessException e) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
    finish();
  }
catch (  NullPointerException e) {
    e.printStackTrace();
    Log.e(TAG,""String_Node_Str"");
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    finish();
  }
catch (  InterruptedException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
 finally {
    if (releaseCamera)     open.mLock.unlock();
  }
}",0.9774217042971596
150582,"/** 
 * Re-opens the camera with the same settings at the specified resolution. It is assumed that you know what you're doing and that this is a valid resolution. WARNING: UNTESTED
 */
protected void reopenCameraAtResolution(int cameraWidth,int cameraHeight){
  boolean releaseLock=true;
  try {
    open.mLock.lock();
    if (verbose)     Log.i(TAG,""String_Node_Str"" + (open.mCameraDevice == null));
    if (null == open.mCameraDevice) {
      throw new RuntimeException(""String_Node_Str"");
    }
    closePreviewSession();
    open.mCameraSize=null;
    open.mCameraCharacterstics=null;
    firstFrame=true;
    CameraManager manager=(CameraManager)getSystemService(Context.CAMERA_SERVICE);
    if (manager == null)     throw new RuntimeException(""String_Node_Str"");
    try {
      mPreviewReader=ImageReader.newInstance(cameraWidth,cameraHeight,ImageFormat.YUV_420_888,2);
      mPreviewReader.setOnImageAvailableListener(onAvailableListener,mBackgroundHandler);
      configureTransform(viewWidth,viewHeight);
      manager.openCamera(open.cameraId,mStateCallback,null);
      releaseLock=false;
    }
 catch (    IllegalArgumentException e) {
      Toast.makeText(this,e.getMessage(),Toast.LENGTH_LONG).show();
      finish();
    }
catch (    CameraAccessException e) {
      e.printStackTrace();
    }
  }
  finally {
    if (releaseLock)     open.mLock.unlock();
  }
}","/** 
 * Re-opens the camera with the same settings at the specified resolution. It is assumed that you know what you're doing and that this is a valid resolution. WARNING: UNTESTED
 */
protected void reopenCameraAtResolution(int cameraWidth,int cameraHeight){
  if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  boolean releaseLock=true;
  open.mLock.lock();
  try {
    if (verbose)     Log.i(TAG,""String_Node_Str"" + (open.mCameraDevice == null) + ""String_Node_Str""+ open.state);
    if (open.state != CameraState.OPEN)     throw new RuntimeException(""String_Node_Str"");
    if (null == open.mCameraDevice) {
      throw new RuntimeException(""String_Node_Str"");
    }
    closePreviewSession();
    open.mCameraSize=null;
    open.mCameraCharacterstics=null;
    firstFrame=true;
    CameraManager manager=(CameraManager)getSystemService(Context.CAMERA_SERVICE);
    if (manager == null)     throw new RuntimeException(""String_Node_Str"");
    try {
      mPreviewReader=ImageReader.newInstance(cameraWidth,cameraHeight,ImageFormat.YUV_420_888,2);
      mPreviewReader.setOnImageAvailableListener(onAvailableListener,mBackgroundHandler);
      configureTransform(viewWidth,viewHeight);
      manager.openCamera(open.cameraId,mStateCallback,null);
      releaseLock=false;
    }
 catch (    IllegalArgumentException e) {
      Toast.makeText(this,e.getMessage(),Toast.LENGTH_LONG).show();
      finish();
    }
catch (    CameraAccessException e) {
      e.printStackTrace();
    }
  }
  finally {
    if (releaseLock)     open.mLock.unlock();
  }
}",0.9026666666666666
150583,"public static void processYuv(Image yuv,byte work[],ProcessorYuv processor){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideUV=planes[1].getRowStride();
  int stridePixelUV=planes[1].getPixelStride();
  int periodUV=(int)Math.round(width / (strideUV / (double)stridePixelUV));
  int workLength=strideY + strideUV + strideUV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideUV;
  if (ImageFormat.YUV_420_888 != yuv.getFormat())   throw new RuntimeException(""String_Node_Str"");
  int totalBytesY=bufferY.remaining();
  int totalBytesU=bufferU.remaining();
  int totalBytesV=bufferV.remaining();
  int x=-1, y=-1, indexY=-1, indexU=-1, indexV=-1;
  try {
    for (y=0; y < height; y++) {
      bufferY.get(work,0,strideY);
      if (y % periodUV == 0) {
        bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideUV));
        bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideUV));
      }
      indexY=0;
      indexU=offsetU;
      indexV=offsetV;
      for (x=0; x < width; x++, indexY++) {
        processor.processYUV(work[indexY] & 0xFF,work[indexU] & 0xFF,work[indexV] & 0xFF);
        int stepUV=stridePixelUV * ((x + 1) % periodUV == 0 ? 1 : 0);
        indexU+=stepUV;
        indexV+=stepUV;
      }
    }
  }
 catch (  RuntimeException e) {
    e.printStackTrace();
    String message=""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ totalBytesY+ ""String_Node_Str""+ totalBytesU+ ""String_Node_Str""+ totalBytesV+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ work.length+ ""String_Node_Str""+ strideY+ ""String_Node_Str""+ strideUV+ ""String_Node_Str""+ stridePixelUV+ ""String_Node_Str""+ periodUV+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ indexY+ ""String_Node_Str""+ indexU+ ""String_Node_Str""+ indexV;
    throw new RuntimeException(message);
  }
}","public static void processYuv(Image yuv,byte work[],ProcessorYuv processor){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideUV=planes[1].getRowStride();
  int stridePixelUV=planes[1].getPixelStride();
  int periodUV=(int)Math.round(width / (strideUV / (double)stridePixelUV));
  int workLength=strideY + strideUV + strideUV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideUV;
  if (ImageFormat.YUV_420_888 != yuv.getFormat())   throw new RuntimeException(""String_Node_Str"");
  int totalBytesY=bufferY.remaining();
  int totalBytesU=bufferU.remaining();
  int totalBytesV=bufferV.remaining();
  int x=-1, y=-1, indexY=-1, indexU=-1, indexV=-1;
  try {
    for (y=0; y < height; y++) {
      bufferY.get(work,0,Math.min(bufferY.remaining(),strideY));
      if (y % periodUV == 0) {
        bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideUV));
        bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideUV));
      }
      indexY=0;
      indexU=offsetU;
      indexV=offsetV;
      for (x=0; x < width; x++, indexY++) {
        processor.processYUV(work[indexY] & 0xFF,work[indexU] & 0xFF,work[indexV] & 0xFF);
        int stepUV=stridePixelUV * ((x + 1) % periodUV == 0 ? 1 : 0);
        indexU+=stepUV;
        indexV+=stepUV;
      }
    }
  }
 catch (  RuntimeException e) {
    e.printStackTrace();
    String message=""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ totalBytesY+ ""String_Node_Str""+ totalBytesU+ ""String_Node_Str""+ totalBytesV+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ work.length+ ""String_Node_Str""+ strideY+ ""String_Node_Str""+ strideUV+ ""String_Node_Str""+ stridePixelUV+ ""String_Node_Str""+ periodUV+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ indexY+ ""String_Node_Str""+ indexU+ ""String_Node_Str""+ indexV;
    throw new RuntimeException(message);
  }
}",0.9906625166740772
150584,"@Override public int getFormat(){
  return 0;
}","@Override public int getFormat(){
  return ImageFormat.YUV_420_888;
}",0.8103448275862069
150585,"public static Planar<GrayU8> yuvToPlanarYuvU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayU8.class,width,height,3);
  }
  final byte[] dataY=output.getBand(0).data;
  final byte[] dataU=output.getBand(1).data;
  final byte[] dataV=output.getBand(2).data;
  ProcessorYuv processor=new ProcessorYuv(){
    int indexOut=0;
    @Override final public void processYUV(    final int y,    final int u,    final int v){
      dataY[indexOut]=(byte)y;
      dataU[indexOut]=(byte)u;
      dataV[indexOut++]=(byte)v;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}","public static Planar<GrayU8> yuvToPlanarYuvU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.reshape(width,height,3);
  }
 else {
    output=new Planar(GrayU8.class,width,height,3);
  }
  final byte[] dataY=output.getBand(0).data;
  final byte[] dataU=output.getBand(1).data;
  final byte[] dataV=output.getBand(2).data;
  ProcessorYuv processor=new ProcessorYuv(){
    int indexOut=0;
    @Override final public void processYUV(    final int y,    final int u,    final int v){
      dataY[indexOut]=(byte)y;
      dataU[indexOut]=(byte)u;
      dataV[indexOut++]=(byte)v;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}",0.9516778523489932
150586,"public static Planar<GrayF32> yuvToPlanarRgbF32(Image yuv,Planar<GrayF32> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar<>(GrayF32.class,width,height,3);
  }
  final float[] red=output.getBand(0).data;
  final float[] green=output.getBand(1).data;
  final float[] blue=output.getBand(2).data;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      red[indexOut]=r;
      green[indexOut]=g;
      blue[indexOut++]=b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}","public static Planar<GrayF32> yuvToPlanarRgbF32(Image yuv,Planar<GrayF32> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.reshape(width,height,3);
  }
 else {
    output=new Planar<>(GrayF32.class,width,height,3);
  }
  final float[] red=output.getBand(0).data;
  final float[] green=output.getBand(1).data;
  final float[] blue=output.getBand(2).data;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      red[indexOut]=r;
      green[indexOut]=g;
      blue[indexOut++]=b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}",0.9504814305364512
150587,"public static void processYuv(Image yuv,byte work[],ProcessorYuv processor){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideUV=planes[1].getRowStride();
  int workLength=strideY + strideUV + strideUV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideUV;
  int stridePixelUV=planes[1].getPixelStride();
  if (bufferU.remaining() % strideUV != 0) {
    int extra=bufferU.remaining() % strideUV;
    extra=extra / stridePixelUV + ((extra % stridePixelUV) != 0 ? 1 : 0);
    if (extra < width / stridePixelUV) {
      throw new RuntimeException(""String_Node_Str"" + bufferU.slice() + ""String_Node_Str""+ strideUV+ ""String_Node_Str""+ stridePixelUV+ ""String_Node_Str""+ width);
    }
  }
  if (bufferV.remaining() % strideUV != 0) {
    int extra=bufferV.remaining() % strideUV;
    extra=extra / stridePixelUV + ((extra % stridePixelUV) != 0 ? 1 : 0);
    if (extra < width / stridePixelUV) {
      throw new RuntimeException(""String_Node_Str"" + bufferV.slice() + ""String_Node_Str""+ strideUV+ ""String_Node_Str""+ stridePixelUV+ ""String_Node_Str""+ width);
    }
  }
  for (int y=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideUV));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideUV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      processor.processYUV(work[indexY] & 0xFF,work[indexU] & 0xFF,work[indexV] & 0xFF);
      int stepUV=stridePixelUV * ((x + 1) % stridePixelUV == 0 ? 1 : 0);
      indexU+=stepUV;
      indexV+=stepUV;
    }
  }
}","public static void processYuv(Image yuv,byte work[],ProcessorYuv processor){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideUV=planes[1].getRowStride();
  int stridePixelUV=planes[1].getPixelStride();
  int periodUV=(int)Math.round(width / (strideUV / (double)stridePixelUV));
  int workLength=strideY + strideUV + strideUV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideUV;
  if (ImageFormat.YUV_420_888 != yuv.getFormat())   throw new RuntimeException(""String_Node_Str"");
  int totalBytesY=bufferY.remaining();
  int totalBytesU=bufferU.remaining();
  int totalBytesV=bufferV.remaining();
  int x=-1, y=-1, indexY=-1, indexU=-1, indexV=-1;
  try {
    for (y=0; y < height; y++) {
      bufferY.get(work,0,strideY);
      if (y % periodUV == 0) {
        bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideUV));
        bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideUV));
      }
      indexY=0;
      indexU=offsetU;
      indexV=offsetV;
      for (x=0; x < width; x++, indexY++) {
        processor.processYUV(work[indexY] & 0xFF,work[indexU] & 0xFF,work[indexV] & 0xFF);
        int stepUV=stridePixelUV * ((x + 1) % periodUV == 0 ? 1 : 0);
        indexU+=stepUV;
        indexV+=stepUV;
      }
    }
  }
 catch (  RuntimeException e) {
    e.printStackTrace();
    String message=""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ totalBytesY+ ""String_Node_Str""+ totalBytesU+ ""String_Node_Str""+ totalBytesV+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ work.length+ ""String_Node_Str""+ strideY+ ""String_Node_Str""+ strideUV+ ""String_Node_Str""+ stridePixelUV+ ""String_Node_Str""+ periodUV+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ indexY+ ""String_Node_Str""+ indexU+ ""String_Node_Str""+ indexV;
    throw new RuntimeException(message);
  }
}",0.5064237327727167
150588,"public static Planar<GrayU8> yuvToPlanarRgbU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar<>(GrayU8.class,width,height,3);
  }
  final byte[] red=output.getBand(0).data;
  final byte[] green=output.getBand(1).data;
  final byte[] blue=output.getBand(2).data;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      red[indexOut]=(byte)r;
      green[indexOut]=(byte)g;
      blue[indexOut++]=(byte)b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}","public static Planar<GrayU8> yuvToPlanarRgbU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.reshape(width,height,3);
  }
 else {
    output=new Planar<>(GrayU8.class,width,height,3);
  }
  final byte[] red=output.getBand(0).data;
  final byte[] green=output.getBand(1).data;
  final byte[] blue=output.getBand(2).data;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      red[indexOut]=(byte)r;
      green[indexOut]=(byte)g;
      blue[indexOut++]=(byte)b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}",0.951219512195122
150589,"public static InterleavedU8 yuvToInterleavedRgbU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  InterleavedU8 _output=output;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      _output.data[indexOut++]=(byte)r;
      _output.data[indexOut++]=(byte)g;
      _output.data[indexOut++]=(byte)b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}","public static InterleavedU8 yuvToInterleavedRgbU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.reshape(width,height,3);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  InterleavedU8 _output=output;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      _output.data[indexOut++]=(byte)r;
      _output.data[indexOut++]=(byte)g;
      _output.data[indexOut++]=(byte)b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}",0.94553706505295
150590,"public static InterleavedF32 yuvToInterleavedRgbF32(Image yuv,InterleavedF32 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedF32(width,height,3);
  }
  InterleavedF32 _output=output;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      _output.data[indexOut++]=r;
      _output.data[indexOut++]=g;
      _output.data[indexOut++]=b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}","public static InterleavedF32 yuvToInterleavedRgbF32(Image yuv,InterleavedF32 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.reshape(width,height,3);
  }
 else {
    output=new InterleavedF32(width,height,3);
  }
  InterleavedF32 _output=output;
  ProcessorYuv processor=new ProcessorYuvRgb(){
    int indexOut=0;
    @Override public void processRGB(    final int r,    final int g,    final int b){
      _output.data[indexOut++]=r;
      _output.data[indexOut++]=g;
      _output.data[indexOut++]=b;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}",0.9444444444444444
150591,"public static InterleavedU8 yuvToInterleavedYuvU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  final byte[] data=output.data;
  ProcessorYuv processor=new ProcessorYuv(){
    int indexOut=0;
    @Override final public void processYUV(    final int y,    final int u,    final int v){
      data[indexOut++]=(byte)y;
      data[indexOut++]=(byte)u;
      data[indexOut++]=(byte)v;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}","public static InterleavedU8 yuvToInterleavedYuvU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.reshape(width,height,3);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  final byte[] data=output.data;
  ProcessorYuv processor=new ProcessorYuv(){
    int indexOut=0;
    @Override final public void processYUV(    final int y,    final int u,    final int v){
      data[indexOut++]=(byte)y;
      data[indexOut++]=(byte)u;
      data[indexOut++]=(byte)v;
    }
  }
;
  processYuv(yuv,work,processor);
  return output;
}",0.9438377535101404
150592,"public static Planar<GrayU8> yuvToPlanarYuvU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayU8.class,width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int workLength=planes[0].getRowStride() + planes[1].getRowStride() + planes[2].getRowStride();
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int strideY=planes[0].getRowStride();
  int strideU=planes[1].getRowStride();
  int strideV=planes[2].getRowStride();
  int offsetU=strideY;
  int offsetV=strideY + offsetU;
  int stridePixelUV=planes[1].getPixelStride();
  GrayU8 bandY=output.getBand(0);
  GrayU8 bandU=output.getBand(1);
  GrayU8 bandV=output.getBand(2);
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++, indexOut++) {
      bandY.data[indexOut]=work[indexY];
      bandU.data[indexOut]=work[indexU];
      bandV.data[indexOut]=work[indexV];
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
    }
  }
  return output;
}","public static Planar<GrayU8> yuvToPlanarYuvU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayU8.class,width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideU=planes[2].getRowStride();
  int strideV=planes[1].getRowStride();
  int workLength=strideY + strideU + strideV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideU;
  int stridePixelUV=planes[1].getPixelStride();
  GrayU8 bandY=output.getBand(0);
  GrayU8 bandU=output.getBand(1);
  GrayU8 bandV=output.getBand(2);
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++, indexOut++) {
      bandY.data[indexOut]=work[indexY];
      bandU.data[indexOut]=work[indexU];
      bandV.data[indexOut]=work[indexV];
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
    }
  }
  return output;
}",0.8074788197487583
150593,"public static Planar<GrayF32> yuvToPlanarRgbF32(Image yuv,Planar<GrayF32> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayF32.class,width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int workLength=planes[0].getRowStride() + planes[1].getRowStride() + planes[2].getRowStride();
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int strideY=planes[0].getRowStride();
  int strideU=planes[1].getRowStride();
  int strideV=planes[2].getRowStride();
  int offsetU=strideY;
  int offsetV=strideY + offsetU;
  int stridePixelUV=planes[1].getPixelStride();
  GrayF32 R=output.getBand(0);
  GrayF32 G=output.getBand(1);
  GrayF32 B=output.getBand(2);
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++, indexOut++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      R.data[indexOut]=r;
      G.data[indexOut]=g;
      B.data[indexOut]=b;
    }
  }
  return output;
}","public static Planar<GrayF32> yuvToPlanarRgbF32(Image yuv,Planar<GrayF32> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayF32.class,width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideU=planes[2].getRowStride();
  int strideV=planes[1].getRowStride();
  int workLength=strideY + strideU + strideV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideU;
  int stridePixelUV=planes[1].getPixelStride();
  GrayF32 R=output.getBand(0);
  GrayF32 G=output.getBand(1);
  GrayF32 B=output.getBand(2);
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++, indexOut++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      R.data[indexOut]=r;
      G.data[indexOut]=g;
      B.data[indexOut]=b;
    }
  }
  return output;
}",0.9232223009685802
150594,"public static Planar<GrayU8> yuvToPlanarRgbU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayU8.class,width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int workLength=planes[0].getRowStride() + planes[1].getRowStride() + planes[2].getRowStride();
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int strideY=planes[0].getRowStride();
  int strideU=planes[1].getRowStride();
  int strideV=planes[2].getRowStride();
  int offsetU=strideY;
  int offsetV=strideY + offsetU;
  int stridePixelUV=planes[1].getPixelStride();
  GrayU8 R=output.getBand(0);
  GrayU8 G=output.getBand(1);
  GrayU8 B=output.getBand(2);
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++, indexOut++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      R.data[indexOut]=(byte)r;
      G.data[indexOut]=(byte)g;
      B.data[indexOut]=(byte)b;
    }
  }
  return output;
}","public static Planar<GrayU8> yuvToPlanarRgbU8(Image yuv,Planar<GrayU8> output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new Planar(GrayU8.class,width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideU=planes[2].getRowStride();
  int strideV=planes[1].getRowStride();
  int workLength=strideY + strideU + strideV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideU;
  int stridePixelUV=planes[1].getPixelStride();
  GrayU8 R=output.getBand(0);
  GrayU8 G=output.getBand(1);
  GrayU8 B=output.getBand(2);
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++, indexOut++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      R.data[indexOut]=(byte)r;
      G.data[indexOut]=(byte)g;
      B.data[indexOut]=(byte)b;
    }
  }
  return output;
}",0.9236192714453584
150595,"public static InterleavedU8 yuvToInterleavedRgbU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int workLength=planes[0].getRowStride() + planes[1].getRowStride() + planes[2].getRowStride();
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int strideY=planes[0].getRowStride();
  int strideU=planes[1].getRowStride();
  int strideV=planes[2].getRowStride();
  int offsetU=strideY;
  int offsetV=strideY + offsetU;
  int stridePixelUV=planes[1].getPixelStride();
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      output.data[indexOut++]=(byte)r;
      output.data[indexOut++]=(byte)g;
      output.data[indexOut++]=(byte)b;
    }
  }
  return output;
}","public static InterleavedU8 yuvToInterleavedRgbU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideU=planes[2].getRowStride();
  int strideV=planes[1].getRowStride();
  int workLength=strideY + strideU + strideV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideU;
  int stridePixelUV=planes[1].getPixelStride();
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      output.data[indexOut++]=(byte)r;
      output.data[indexOut++]=(byte)g;
      output.data[indexOut++]=(byte)b;
    }
  }
  return output;
}",0.9204795693662834
150596,"public static InterleavedF32 yuvToInterleavedRgbF32(Image yuv,InterleavedF32 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedF32(width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int workLength=planes[0].getRowStride() + planes[1].getRowStride() + planes[2].getRowStride();
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int strideY=planes[0].getRowStride();
  int strideU=planes[1].getRowStride();
  int strideV=planes[2].getRowStride();
  int offsetU=strideY;
  int offsetV=strideY + offsetU;
  int stridePixelUV=planes[1].getPixelStride();
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      output.data[indexOut++]=r;
      output.data[indexOut++]=g;
      output.data[indexOut++]=b;
    }
  }
  return output;
}","public static InterleavedF32 yuvToInterleavedRgbF32(Image yuv,InterleavedF32 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedF32(width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideU=planes[2].getRowStride();
  int strideV=planes[1].getRowStride();
  int workLength=strideY + strideU + strideV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideU;
  int stridePixelUV=planes[1].getPixelStride();
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      int Y=1191 * ((work[indexY] & 0xFF) - 16);
      int CR=(work[indexU] & 0xFF) - 128;
      int CB=(work[indexV] & 0xFF) - 128;
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
      Y=((Y >>> 31) ^ 1) * Y;
      int r=(Y + 1836 * CR) >> 10;
      int g=(Y - 547 * CR - 218 * CB) >> 10;
      int b=(Y + 2165 * CB) >> 10;
      r*=((r >>> 31) ^ 1);
      g*=((g >>> 31) ^ 1);
      b*=((b >>> 31) ^ 1);
      if (r > 255)       r=255;
      if (g > 255)       g=255;
      if (b > 255)       b=255;
      output.data[indexOut++]=r;
      output.data[indexOut++]=g;
      output.data[indexOut++]=b;
    }
  }
  return output;
}",0.9199310174919932
150597,"public static InterleavedU8 yuvToInterleavedYuvU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int workLength=planes[0].getRowStride() + planes[1].getRowStride() + planes[2].getRowStride();
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int strideY=planes[0].getRowStride();
  int strideU=planes[1].getRowStride();
  int strideV=planes[2].getRowStride();
  int offsetU=strideY;
  int offsetV=strideY + offsetU;
  int stridePixelUV=planes[1].getPixelStride();
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      output.data[indexOut++]=work[indexY];
      output.data[indexOut++]=work[indexU];
      output.data[indexOut++]=work[indexV];
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
    }
  }
  return output;
}","public static InterleavedU8 yuvToInterleavedYuvU8(Image yuv,InterleavedU8 output,byte work[]){
  int width=yuv.getWidth();
  int height=yuv.getHeight();
  if (output != null) {
    output.setNumberOfBands(3);
    output.reshape(width,height);
  }
 else {
    output=new InterleavedU8(width,height,3);
  }
  Image.Plane planes[]=yuv.getPlanes();
  int strideY=planes[0].getRowStride();
  int strideU=planes[2].getRowStride();
  int strideV=planes[1].getRowStride();
  int workLength=strideY + strideU + strideV;
  if (work.length < workLength)   throw new IllegalArgumentException(""String_Node_Str"" + workLength);
  ByteBuffer bufferY=planes[0].getBuffer();
  ByteBuffer bufferU=planes[2].getBuffer();
  ByteBuffer bufferV=planes[1].getBuffer();
  bufferY.position(0);
  bufferU.position(0);
  bufferV.position(0);
  int offsetU=strideY;
  int offsetV=strideY + strideU;
  int stridePixelUV=planes[1].getPixelStride();
  for (int y=0, indexOut=0; y < height; y++) {
    bufferY.get(work,0,strideY);
    if (y % stridePixelUV == 0) {
      bufferU.get(work,offsetU,Math.min(bufferU.remaining(),strideU));
      bufferV.get(work,offsetV,Math.min(bufferV.remaining(),strideV));
    }
    int indexY=0;
    int indexU=offsetU;
    int indexV=offsetV;
    for (int x=0; x < width; x++, indexY++) {
      output.data[indexOut++]=work[indexY];
      output.data[indexOut++]=work[indexU];
      output.data[indexOut++]=work[indexV];
      int stepUV=stridePixelUV * (((x + stridePixelUV - 1) % stridePixelUV) ^ 1);
      indexU+=stepUV;
      indexV+=stepUV;
    }
  }
  return output;
}",0.790770190208918
150598,"/** 
 * Determine the QR code's version. For QR codes version < 7 it can be determined using the marker's size alone. Otherwise the version is read from the image itself
 * @return true if version was successfully extracted or false if it failed
 */
private boolean extractVersionInfo(QrCode qr){
  int version=estimateVersionBySize(qr);
  if (version >= QrCode.VERSION_ENCODED_AT) {
    readVersionRegion0(qr);
    int version0=decodeVersion();
    readVersionRegion1(qr);
    int version1=decodeVersion();
    if (version0 < 1 && version1 < 1) {
      version=-1;
    }
 else     if (version0 < 1) {
      version=version1;
    }
 else     if (version1 < 1) {
      version=version0;
    }
 else     if (version0 != version1) {
      version=-1;
    }
 else {
      version=version0;
    }
  }
 else   if (version <= 0) {
    qr.version=-1;
  }
  qr.version=version;
  return version != -1;
}","/** 
 * Determine the QR code's version. For QR codes version < 7 it can be determined using the marker's size alone. Otherwise the version is read from the image itself
 * @return true if version was successfully extracted or false if it failed
 */
boolean extractVersionInfo(QrCode qr){
  int version=estimateVersionBySize(qr);
  if (version >= QrCode.VERSION_ENCODED_AT) {
    readVersionRegion0(qr);
    int version0=decodeVersion();
    readVersionRegion1(qr);
    int version1=decodeVersion();
    if (version0 < 1 && version1 < 1) {
      version=-1;
    }
 else     if (version0 < 1) {
      version=version1;
    }
 else     if (version1 < 1) {
      version=version0;
    }
 else     if (version0 != version1) {
      version=-1;
    }
 else {
      version=version0;
    }
  }
 else   if (version <= 0) {
    version=-1;
  }
  qr.version=version;
  return version >= 1 && version <= QrCode.MAX_VERSION;
}",0.9198452183526812
150599,"/** 
 * Decode version information from read in bits
 * @return The found version or -1 if it failed
 */
private int decodeVersion(){
  int bitField=this.bits.read(0,18,false);
  int message;
  if (QrCodePolynomialMath.checkVersionBits(bitField)) {
    message=bitField >> 12;
  }
 else {
    message=QrCodePolynomialMath.correctVersionBits(bitField);
  }
  if (message > QrCode.MAX_VERSION || message < QrCode.VERSION_ENCODED_AT)   return -1;
  return message;
}","/** 
 * Decode version information from read in bits
 * @return The found version or -1 if it failed
 */
int decodeVersion(){
  int bitField=this.bits.read(0,18,false);
  int message;
  if (QrCodePolynomialMath.checkVersionBits(bitField)) {
    message=bitField >> 12;
  }
 else {
    message=QrCodePolynomialMath.correctVersionBits(bitField);
  }
  if (message > QrCode.MAX_VERSION || message < QrCode.VERSION_ENCODED_AT)   return -1;
  return message;
}",0.9912854030501088
150600,"/** 
 * Attempts to estimate the qr-code's version based on distance between position patterns. If it can't estimate it based on distance return -1
 */
private int estimateVersionBySize(QrCode qr){
  gridReader.setSquare(qr.ppCorner,0);
  gridReader.imageToGrid(qr.ppRight.get(0),grid);
  if (Math.abs(grid.y) >= 1)   return -1;
  double versionX=((grid.x + 7) - 17) / 4;
  gridReader.imageToGrid(qr.ppDown.get(0),grid);
  if (Math.abs(grid.x) >= 1)   return -1;
  double versionY=((grid.y + 7) - 17) / 4;
  if (Math.abs(versionX - versionY) > 1.5)   return -1;
  return (int)((versionX + versionY) / 2.0 + 0.5);
}","/** 
 * Attempts to estimate the qr-code's version based on distance between position patterns. If it can't estimate it based on distance return -1
 */
int estimateVersionBySize(QrCode qr){
  gridReader.setSquare(qr.ppCorner,0);
  gridReader.imageToGrid(qr.ppRight.get(0),grid);
  if (Math.abs(grid.y) >= 1)   return -1;
  double versionX=((grid.x + 7) - 17) / 4;
  gridReader.imageToGrid(qr.ppDown.get(0),grid);
  if (Math.abs(grid.x) >= 1)   return -1;
  double versionY=((grid.y + 7) - 17) / 4;
  if (Math.abs(versionX - versionY) > 1.5)   return -1;
  return (int)((versionX + versionY) / 2.0 + 0.5);
}",0.9934426229508196
150601,"@Override public void configureBeforePolyline(PointsToPolyline contourToPolyline,boolean touchesBorder){
  if (touchesBorder) {
    contourToPolyline.setMinimumSides(3);
    contourToPolyline.setMaximumSides(8);
  }
 else {
    contourToPolyline.setMinimumSides(4);
    contourToPolyline.setMaximumSides(4);
  }
}","@Override public void configureBeforePolyline(PointsToPolyline contourToPolyline,boolean touchesBorder){
  if (touchesBorder) {
    contourToPolyline.setConvex(false);
    contourToPolyline.setMinimumSides(3);
    contourToPolyline.setMaximumSides(8);
  }
 else {
    contourToPolyline.setConvex(true);
    contourToPolyline.setMinimumSides(4);
    contourToPolyline.setMaximumSides(4);
  }
}",0.8879432624113475
150602,"@Override public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture,int width,int height){
  openCamera(width,height);
}","@Override public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture,int width,int height){
  if (verbose)   Log.i(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ (mCameraSize != null));
  openCamera(width,height);
}",0.6753246753246753
150603,"@Override public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture,int width,int height){
  configureTransform(width,height);
}","@Override public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture,int width,int height){
  if (verbose)   Log.i(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
  configureTransform(width,height);
}",0.7713498622589532
150604,"@Override public void onLayoutChange(View view,int left,int top,int right,int bottom,int leftWas,int topWas,int rightWas,int bottomWas){
  int width=right - left;
  int height=bottom - top;
  if (mCameraSize == null) {
    openCamera(width,height);
  }
  view.removeOnLayoutChangeListener(this);
}","@Override public void onLayoutChange(View view,int left,int top,int right,int bottom,int leftWas,int topWas,int rightWas,int bottomWas){
  int width=right - left;
  int height=bottom - top;
  if (verbose)   Log.i(TAG,""String_Node_Str"" + top + ""String_Node_Str""+ left+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ (mCameraSize != null));
  if (mCameraSize == null) {
    openCamera(width,height);
  }
  view.removeOnLayoutChangeListener(this);
}",0.7734375
150605,"/** 
 * Called when the camera's resolution has changed.
 */
protected void onCameraResolutionChange(int width,int height){
  if (verbose)   Log.i(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
}","/** 
 * Called when the camera's resolution has changed.
 */
protected void onCameraResolutionChange(int cameraWidth,int cameraHeight){
  if (verbose)   Log.i(TAG,""String_Node_Str"" + cameraWidth + ""String_Node_Str""+ cameraHeight+ ""String_Node_Str"");
}",0.9330543933054394
150606,"/** 
 * Renders the visualizations. Override and invoke super to add your own
 */
protected void onDrawFrame(SurfaceView view,Canvas canvas){
  if (showBitmap) {
synchronized (bitmapLock) {
      canvas.drawBitmap(bitmap,imageToView,null);
    }
  }
}","/** 
 * Renders the visualizations. Override and invoke super to add your own
 */
protected void onDrawFrame(SurfaceView view,Canvas canvas){
  canvas.setMatrix(identity);
  if (showBitmap) {
synchronized (bitmapLock) {
      canvas.drawBitmap(bitmap,imageToView,null);
    }
  }
}",0.943609022556391
150607,"/** 
 * Internal function which manages images and invokes   {@link #processImage}.
 */
private void processImageOuter(ImageBase image){
  long startTime=System.currentTimeMillis();
  processImage(image);
  if (!visualizeOnlyMostRecent || startTime > timeOfLastUpdated) {
    timeOfLastUpdated=startTime;
    if (showBitmap) {
synchronized (bitmapLock) {
        ConvertBitmap.boofToBitmap(image,bitmap,bitmapTmp);
      }
    }
    runOnUiThread(() -> displayView.invalidate());
  }
synchronized (imageLock) {
    if (imageType.getFamily() != image.getImageType().getFamily())     return;
    if (imageType.getDataType() != image.getImageType().getDataType())     return;
    if (imageType.getNumBands() != image.getImageType().getNumBands())     return;
    stackImages.add(image);
  }
}","/** 
 * Internal function which manages images and invokes   {@link #processImage}.
 */
private void processImageOuter(ImageBase image){
  long startTime=System.currentTimeMillis();
  processImage(image);
  if (!visualizeOnlyMostRecent || startTime > timeOfLastUpdated) {
    timeOfLastUpdated=startTime;
    if (showBitmap) {
synchronized (bitmapLock) {
        ConvertBitmap.boofToBitmap(image,bitmap,bitmapTmp);
      }
    }
    runOnUiThread(() -> displayView.invalidate());
  }
synchronized (imageLock) {
    if (imageType.isSameType(image.getImageType()))     stackImages.add(image);
  }
}",0.7740072202166065
150608,"@Override protected void onCameraResolutionChange(int width,int height){
  if (showBitmap) {
synchronized (bitmapLock) {
      if (bitmap.getWidth() != width || bitmap.getHeight() != height)       bitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
      bitmapTmp=ConvertBitmap.declareStorage(bitmap,bitmapTmp);
    }
  }
  int rotatedWidth=width;
  int rotatedHeight=height;
  int rotation=getWindowManager().getDefaultDisplay().getRotation();
  int offsetX=0, offsetY=0;
  if (Surface.ROTATION_0 == rotation || Surface.ROTATION_180 == rotation) {
    rotatedWidth=height;
    rotatedHeight=width;
    offsetX=(rotatedWidth - rotatedHeight) / 2;
    offsetY=(rotatedHeight - rotatedWidth) / 2;
  }
  imageToView.reset();
  float scale=Math.min((float)displayView.getWidth() / rotatedWidth,(float)displayView.getHeight() / rotatedHeight);
  if (scale == 0) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  imageToView.postRotate(-90 * rotation + mSensorOrientation,width / 2,height / 2);
  imageToView.postTranslate(offsetX,offsetY);
  imageToView.postScale(scale,scale);
  if (stretchToFill) {
    imageToView.postScale(displayView.getWidth() / (rotatedWidth * scale),displayView.getHeight() / (rotatedHeight * scale));
  }
 else {
    imageToView.postTranslate((displayView.getWidth() - rotatedWidth * scale) / 2,(displayView.getHeight() - rotatedHeight * scale) / 2);
  }
  Log.i(TAG,imageToView.toString());
  Log.i(TAG,""String_Node_Str"" + scale);
  Log.i(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ displayView.getWidth()+ ""String_Node_Str""+ displayView.getHeight());
}","@Override protected void onCameraResolutionChange(int cameraWidth,int cameraHeight){
  if (showBitmap) {
synchronized (bitmapLock) {
      if (bitmap.getWidth() != cameraWidth || bitmap.getHeight() != cameraHeight)       bitmap=Bitmap.createBitmap(cameraWidth,cameraHeight,Bitmap.Config.ARGB_8888);
      bitmapTmp=ConvertBitmap.declareStorage(bitmap,bitmapTmp);
    }
  }
  int rotatedWidth=cameraWidth;
  int rotatedHeight=cameraHeight;
  int rotation=getWindowManager().getDefaultDisplay().getRotation();
  int offsetX=0, offsetY=0;
  if (verbose)   Log.i(TAG,""String_Node_Str"" + mSensorOrientation + ""String_Node_Str""+ rotation);
  boolean needToRotateView=(Surface.ROTATION_0 == rotation || Surface.ROTATION_180 == rotation) != (mSensorOrientation == 0 || mSensorOrientation == 180);
  if (needToRotateView) {
    rotatedWidth=cameraHeight;
    rotatedHeight=cameraWidth;
    offsetX=(rotatedWidth - rotatedHeight) / 2;
    offsetY=(rotatedHeight - rotatedWidth) / 2;
  }
  imageToView.reset();
  float scale=Math.min((float)viewWidth / rotatedWidth,(float)viewHeight / rotatedHeight);
  if (scale == 0) {
    Log.e(TAG,""String_Node_Str"");
    return;
  }
  imageToView.postRotate(-90 * rotation + mSensorOrientation,cameraWidth / 2,cameraHeight / 2);
  imageToView.postTranslate(offsetX,offsetY);
  imageToView.postScale(scale,scale);
  if (stretchToFill) {
    imageToView.postScale(viewWidth / (rotatedWidth * scale),viewHeight / (rotatedHeight * scale));
  }
 else {
    imageToView.postTranslate((viewWidth - rotatedWidth * scale) / 2,(viewHeight - rotatedHeight * scale) / 2);
  }
  Log.i(TAG,imageToView.toString());
  Log.i(TAG,""String_Node_Str"" + scale);
  Log.i(TAG,""String_Node_Str"" + cameraWidth + ""String_Node_Str""+ cameraHeight+ ""String_Node_Str""+ viewWidth+ ""String_Node_Str""+ viewHeight);
}",0.6810119220703693
150609,"/** 
 * Solves the IPPE problem
 */
protected void IPPE(DMatrixRMaj R1,DMatrixRMaj R2){
  compute_Kv();
  compute_B(B,R_v,v1,v2);
  CommonOps_DDF2.invert(B,B);
  CommonOps_DDF2.mult(B,J,A);
  double gamma=largestSingularValue(A);
  CommonOps_DDF2.scale(1.0 / gamma,A,R22);
  CommonOps_DDF2.setIdentity(B);
  CommonOps_DDF2.multAddTransA(-1,R22,R22,B);
  double b1=Math.sqrt(B.a11);
  double b2=Math.signum(B.a12) * Math.sqrt(B.a22);
  l0.set(R22.a11,R22.a12,b1);
  l1.set(R22.a21,R22.a22,b2);
  l0.cross(l1,ca);
  constructR(R1,R_v,R22,b1,b2,ca,1,tmp);
  constructR(R2,R_v,R22,b1,b2,ca,1,tmp);
}","/** 
 * Solves the IPPE problem
 */
protected void IPPE(DMatrixRMaj R1,DMatrixRMaj R2){
  double norm_v=Math.sqrt(v1 * v1 + v2 * v2);
  if (norm_v <= UtilEjml.EPS) {
    CommonOps_DDRM.setIdentity(R_v);
  }
 else {
    compute_Rv();
  }
  compute_B(B,R_v,v1,v2);
  CommonOps_DDF2.invert(B,B);
  CommonOps_DDF2.mult(B,J,A);
  double gamma=largestSingularValue2x2(A);
  CommonOps_DDF2.scale(1.0 / gamma,A,R22);
  CommonOps_DDF2.setIdentity(B);
  CommonOps_DDF2.multAddTransA(-1,R22,R22,B);
  double b1=Math.sqrt(B.a11);
  double b2=Math.signum(B.a12) * Math.sqrt(B.a22);
  l0.set(R22.a11,R22.a12,b1);
  l1.set(R22.a21,R22.a22,b2);
  l0.cross(l1,ca);
  constructR(R1,R_v,R22,b1,b2,ca,1,tmp);
  constructR(R2,R_v,R22,b1,b2,ca,1,tmp);
}",0.8371040723981901
150610,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowMarkers) {
      List<QrCode> detected=detector.getDetections();
      for (int i=0; i < detected.size(); i++) {
        g2.setColor(new Color(0x5011FF00,true));
        QrCode qr=detected.get(i);
        VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
        if (controls.bShowBits)         renderBinaryValues(g2,qr);
      }
      List<QrCode> failures=detector.getFailures();
      for (int i=0; i < failures.size(); i++) {
        QrCode qr=failures.get(i);
        if (qr.failureCause.ordinal() < ALIGNMENT.ordinal())         continue;
switch (qr.failureCause) {
case ERROR_CORRECTION:
          g2.setColor(new Color(0x80FF0000,true));
        break;
case DECODING_MESSAGE:
      g2.setColor(new Color(0x80FF9000,true));
    break;
default :
  g2.setColor(new Color(0x80FF00C0,true));
break;
}
VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
if (controls.bShowBits) renderBinaryValues(g2,qr);
}
}
if (controls.bShowSquares) {
List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null,null);
g2.setColor(Color.GREEN);
g2.setStroke(new BasicStroke(3));
for (Polygon2D_F64 p : polygons) {
VisualizeShapes.drawPolygon(p,true,scale,g2);
}
}
if (controls.bShowAlignmentPattern) {
renderAlignmentPatterns(g2,detector.getDetections());
renderAlignmentPatterns(g2,detector.getFailures());
}
if (controls.bShowPositionPattern) {
FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
g2.setColor(Color.ORANGE);
g2.setStroke(new BasicStroke(3));
List<SquareEdge> list=new ArrayList<>();
for (int i=0; i < nodes.size(); i++) {
SquareNode n=nodes.get(i);
VisualizeShapes.drawPolygon(n.square,true,scale,g2);
for (int j=0; j < 4; j++) {
if (n.edges[j] != null) {
if (!list.contains(n.edges[j])) {
  list.add(n.edges[j]);
}
}
}
}
g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
g2.setColor(new Color(255,150,100));
g2.setStroke(new BasicStroke(3));
Line2D.Double l=new Line2D.Double();
for (int i=0; i < list.size(); i++) {
SquareEdge e=list.get(i);
Point2D_F64 a=e.a.center;
Point2D_F64 b=e.b.center;
l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
g2.draw(l);
}
}
}
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowMarkers) {
synchronized (detected) {
        for (int i=0; i < detected.size(); i++) {
          g2.setColor(new Color(0x5011FF00,true));
          QrCode qr=detected.get(i);
          VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
          if (controls.bShowBits)           renderBinaryValues(g2,qr);
        }
        for (int i=0; i < failures.size(); i++) {
          QrCode qr=failures.get(i);
          if (qr.failureCause.ordinal() < ALIGNMENT.ordinal())           continue;
switch (qr.failureCause) {
case ERROR_CORRECTION:
            g2.setColor(new Color(0x80FF0000,true));
          break;
case DECODING_MESSAGE:
        g2.setColor(new Color(0x80FF9000,true));
      break;
default :
    g2.setColor(new Color(0x80FF00C0,true));
  break;
}
VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
if (controls.bShowBits) renderBinaryValues(g2,qr);
}
}
}
if (controls.bShowSquares) {
List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null,null);
g2.setColor(Color.GREEN);
g2.setStroke(new BasicStroke(3));
for (Polygon2D_F64 p : polygons) {
VisualizeShapes.drawPolygon(p,true,scale,g2);
}
}
if (controls.bShowAlignmentPattern) {
synchronized (detected) {
renderAlignmentPatterns(g2,detected.toList());
renderAlignmentPatterns(g2,failures.toList());
}
}
if (controls.bShowPositionPattern) {
FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
g2.setColor(Color.ORANGE);
g2.setStroke(new BasicStroke(3));
List<SquareEdge> list=new ArrayList<>();
for (int i=0; i < nodes.size(); i++) {
SquareNode n=nodes.get(i);
VisualizeShapes.drawPolygon(n.square,true,scale,g2);
for (int j=0; j < 4; j++) {
if (n.edges[j] != null) {
if (!list.contains(n.edges[j])) {
  list.add(n.edges[j]);
}
}
}
}
g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
g2.setColor(new Color(255,150,100));
g2.setStroke(new BasicStroke(3));
Line2D.Double l=new Line2D.Double();
for (int i=0; i < list.size(); i++) {
SquareEdge e=list.get(i);
Point2D_F64 a=e.a.center;
Point2D_F64 b=e.b.center;
l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
g2.draw(l);
}
}
}
}",0.95696789142668
150611,"/** 
 * Draws the estimated value of each bit onto the image
 */
private void renderBinaryValues(Graphics2D g2,QrCode qr){
  locatorB.setMarker(qr);
  List<Point2D_I32> points=QrCode.LOCATION_BITS[qr.version];
  PackedBits8 bits=new PackedBits8();
  bits.data=qr.rawbits;
  bits.size=qr.rawbits.length * 8;
  Point2D_F32 p=new Point2D_F32();
  g2.setStroke(new BasicStroke(1));
  for (int i=0; i < bits.size; i++) {
    Point2D_I32 c=points.get(i);
    locatorB.gridToImage(c.y + 0.5f,c.x + 0.5f,p);
    int value=qr.mask.apply(c.y,c.x,bits.get(i));
    if (value == 1) {
      renderCircleAt(g2,p,Color.BLACK,Color.LIGHT_GRAY);
    }
 else     if (value == 0) {
      renderCircleAt(g2,p,Color.WHITE,Color.LIGHT_GRAY);
    }
 else {
      renderCircleAt(g2,p,Color.RED,Color.LIGHT_GRAY);
    }
  }
}","/** 
 * Draws the estimated value of each bit onto the image
 */
private void renderBinaryValues(Graphics2D g2,QrCode qr){
  locator.setMarker(qr);
  List<Point2D_I32> points=QrCode.LOCATION_BITS[qr.version];
  PackedBits8 bits=new PackedBits8();
  bits.data=qr.rawbits;
  bits.size=qr.rawbits.length * 8;
  Point2D_F32 p=new Point2D_F32();
  g2.setStroke(new BasicStroke(1));
  for (int i=0; i < bits.size; i++) {
    Point2D_I32 c=points.get(i);
    locator.gridToImage(c.y + 0.5f,c.x + 0.5f,p);
    int value=qr.mask.apply(c.y,c.x,bits.get(i));
    if (value == 1) {
      renderCircleAt(g2,p,Color.BLACK,Color.LIGHT_GRAY);
    }
 else     if (value == 0) {
      renderCircleAt(g2,p,Color.WHITE,Color.LIGHT_GRAY);
    }
 else {
      renderCircleAt(g2,p,Color.RED,Color.LIGHT_GRAY);
    }
  }
}",0.9987484355444304
150612,"/** 
 * Override this function so that it doesn't threshold the image twice
 */
@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  System.out.flush();
  original=ConvertBufferedImage.checkCopy(buffered,original);
  work=ConvertBufferedImage.checkDeclare(buffered,work);
  final double timeInSeconds;
synchronized (this) {
    long before=System.nanoTime();
    detector.process((T)input);
    long after=System.nanoTime();
    timeInSeconds=(after - before) * 1e-9;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      controls.setProcessingTime(timeInSeconds);
      viewUpdated();
    }
  }
);
}","/** 
 * Override this function so that it doesn't threshold the image twice
 */
@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  System.out.flush();
  original=ConvertBufferedImage.checkCopy(buffered,original);
  work=ConvertBufferedImage.checkDeclare(buffered,work);
  final double timeInSeconds;
synchronized (this) {
    long before=System.nanoTime();
    detector.process((T)input);
    long after=System.nanoTime();
    timeInSeconds=(after - before) * 1e-9;
  }
synchronized (detected) {
    this.detected.reset();
    for (    QrCode d : detector.getDetections()) {
      this.detected.grow().set(d);
    }
    this.failures.reset();
    for (    QrCode d : detector.getFailures()) {
      this.failures.grow().set(d);
    }
    System.out.println(""String_Node_Str"" + failures.size());
    for (    QrCode qr : failures.toList()) {
      System.out.println(""String_Node_Str"" + qr.failureCause);
    }
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      controls.setProcessingTime(timeInSeconds);
      viewUpdated();
    }
  }
);
}",0.7568455640744798
150613,"@Override public void process(T gray){
  long time0=System.nanoTime();
  binary.reshape(gray.width,gray.height);
  inputToBinary.process(gray,binary);
  long time1=System.nanoTime();
  milliBinary.update((time1 - time0) * 1e-6);
  System.out.printf(""String_Node_Str"",milliBinary.getAverage());
  detectPositionPatterns.process(gray,binary);
  time0=System.nanoTime();
  decoder.process(detectPositionPatterns.getPositionPatterns(),gray);
  time1=System.nanoTime();
  milliDecoding.update((time1 - time0) * 1e-6);
  System.out.printf(""String_Node_Str"",milliDecoding.getAverage());
  System.out.println(""String_Node_Str"" + decoder.getFailures().size());
  for (  QrCode qr : decoder.getFailures()) {
    System.out.println(""String_Node_Str"" + qr.failureCause);
  }
}","@Override public void process(T gray){
  long time0=System.nanoTime();
  binary.reshape(gray.width,gray.height);
  inputToBinary.process(gray,binary);
  long time1=System.nanoTime();
  milliBinary.update((time1 - time0) * 1e-6);
  System.out.printf(""String_Node_Str"",milliBinary.getAverage());
  detectPositionPatterns.process(gray,binary);
  time0=System.nanoTime();
  decoder.process(detectPositionPatterns.getPositionPatterns(),gray);
  time1=System.nanoTime();
  milliDecoding.update((time1 - time0) * 1e-6);
  System.out.printf(""String_Node_Str"",milliDecoding.getAverage());
}",0.8639405204460967
150614,"public void reset(){
  for (int i=0; i < 4; i++) {
    ppCorner.get(i).set(0,0);
    ppDown.get(i).set(0,0);
    ppRight.get(i).set(0,0);
  }
  version=1;
  error=L;
  mask=QrCodeMaskPattern.M111;
  alignment.reset();
  mode=Mode.ALPHANUMERIC;
  failureCause=Failure.NONE;
  rawbits=null;
  rawdata=null;
  message=null;
}","/** 
 * Resets the QR-Code so that it's in its initial state.
 */
public void reset(){
  for (int i=0; i < 4; i++) {
    ppCorner.get(i).set(0,0);
    ppDown.get(i).set(0,0);
    ppRight.get(i).set(0,0);
  }
  this.threshCorner=0;
  this.threshDown=0;
  this.threshRight=0;
  version=1;
  error=L;
  mask=QrCodeMaskPattern.M111;
  alignment.reset();
  mode=Mode.ALPHANUMERIC;
  failureCause=Failure.NONE;
  rawbits=null;
  rawdata=null;
  message=null;
}",0.8298969072164949
150615,"/** 
 * Increases the size of the data array so that it can store an addition number of bits
 * @param amountBits Number of bits beyond 'size' that you wish the array to be able to store
 * @param saveValue if true it will save the value of the array. If false it will not copy it
 */
public void growArray(int amountBits,boolean saveValue){
  size=size + amountBits;
  int N=size / 8 + (size % 8 == 0 ? 0 : 1);
  if (N > data.length) {
    byte[] tmp=new byte[N];
    if (saveValue)     System.arraycopy(data,0,tmp,0,data.length);
    this.data=tmp;
  }
}","/** 
 * Increases the size of the data array so that it can store an addition number of bits
 * @param amountBits Number of bits beyond 'size' that you wish the array to be able to store
 * @param saveValue if true it will save the value of the array. If false it will not copy it
 */
public void growArray(int amountBits,boolean saveValue){
  size=size + amountBits;
  int N=size / 8 + (size % 8 == 0 ? 0 : 1);
  if (N > data.length) {
    int extra=Math.min(1024,N + 10);
    byte[] tmp=new byte[N + extra];
    if (saveValue)     System.arraycopy(data,0,tmp,0,data.length);
    this.data=tmp;
  }
}",0.961106309420916
150616,"public static Mode lookup(int bits){
  if (NUMERIC.bits == bits)   return NUMERIC;
 else   if (ALPHANUMERIC.bits == bits)   return ALPHANUMERIC;
 else   if (BYTE.bits == bits)   return BYTE;
 else   if (KANJI.bits == bits)   return KANJI;
 else   if (ECI.bits == bits)   return ECI;
 else   if (FNC1_FIRST.bits == bits)   return FNC1_FIRST;
 else   if (FNC1_SECOND.bits == bits)   return FNC1_SECOND;
 else   return UNKNOWN;
}","public static Mode lookup(int bits){
  if (NUMERIC.bits == bits)   return NUMERIC;
 else   if (ALPHANUMERIC.bits == bits)   return ALPHANUMERIC;
 else   if (BYTE.bits == bits)   return BYTE;
 else   if (KANJI.bits == bits)   return KANJI;
 else   if (ECI.bits == bits)   return ECI;
 else   if (STRUCTURE_APPENDED.bits == bits)   return STRUCTURE_APPENDED;
 else   if (FNC1_FIRST.bits == bits)   return FNC1_FIRST;
 else   if (FNC1_SECOND.bits == bits)   return FNC1_SECOND;
 else   return UNKNOWN;
}",0.9200863930885528
150617,"/** 
 * Creates a list of alignment patterns to look for and their grid coordinates
 */
void initializePatterns(QrCode qr){
  int qrsize=qr.getNumberOfModules();
  int where[]=QrCode.VERSION_INFO[qr.version].alignment;
  qr.alignment.reset();
  lookup.reset();
  for (int row=0; row < where.length; row++) {
    for (int col=0; col < where.length; col++) {
      boolean skip=false;
      if (row == 0 && col == 0)       skip=true;
 else       if (row == 0 && col == where.length - 1)       skip=true;
 else       if (row == where.length - 1 && col == 0)       skip=true;
      if (skip) {
        lookup.add(null);
      }
 else {
        QrCode.Alignment a=qr.alignment.grow();
        a.moduleX=where[col];
        a.moduleY=where[row];
        lookup.add(a);
      }
    }
  }
}","/** 
 * Creates a list of alignment patterns to look for and their grid coordinates
 */
void initializePatterns(QrCode qr){
  int N=qr.getNumberOfModules();
  int where[]=QrCode.VERSION_INFO[qr.version].alignment;
  qr.alignment.reset();
  lookup.reset();
  for (int row=where.length - 1; row >= 0; row--) {
    for (int col=0; col < where.length; col++) {
      boolean skip=false;
      if (row == 0 && col == 0)       skip=true;
 else       if (row == where.length - 1 && col == where.length - 1)       skip=true;
 else       if (row == where.length - 1 && col == 0)       skip=true;
      if (skip) {
        lookup.add(null);
      }
 else {
        QrCode.Alignment a=qr.alignment.grow();
        a.moduleX=where[col];
        a.moduleY=N - where[row] - 1;
        lookup.add(a);
      }
    }
  }
}",0.9111531190926276
150618,"private int decodeVersion(){
  int bits=this.bits.data[0];
  int message;
  if (QrCodePolynomialMath.checkVersionBits(bits)) {
    message=bits >> 12;
  }
 else {
    message=QrCodePolynomialMath.correctVersionBits(bits);
  }
  if (message > QrCode.MAX_VERSION || message < QrCode.VERSION_VERSION)   return -1;
  return message;
}","/** 
 * Decode version information from read in bits
 * @return The found version or -1 if it failed
 */
private int decodeVersion(){
  int bits=this.bits.data[0];
  int message;
  if (QrCodePolynomialMath.checkVersionBits(bits)) {
    message=bits >> 12;
  }
 else {
    message=QrCodePolynomialMath.correctVersionBits(bits);
  }
  if (message > QrCode.MAX_VERSION || message < QrCode.VERSION_VERSION)   return -1;
  return message;
}",0.8627450980392157
150619,"private static int alignToBytes(int lengthBits){
  return lengthBits + (8 - lengthBits % 8) % 8;
}","public static int alignToBytes(int lengthBits){
  return lengthBits + (8 - lengthBits % 8) % 8;
}",0.953846153846154
150620,"/** 
 * Creates a QR-Code which encodes data in the alphanumeric format
 * @param alphaNumeric String containing only alphanumeric values.
 * @return The QR-Code
 */
public QrCode alphanumeric(String alphaNumeric){
}","/** 
 * Creates a QR-Code which encodes data in the alphanumeric format
 * @param alphaNumeric String containing only alphanumeric values.
 * @return The QR-Code
 */
public QrCodeEncoder alphanumeric(String alphaNumeric){
}",0.9840546697038725
150621,"/** 
 * Creates a QR-Code which encodes Kanji characters
 * @param message Data to be encoded
 * @return The QR-Code
 */
public QrCode kanji(String message){
}","/** 
 * Creates a QR-Code which encodes Kanji characters
 * @param message Data to be encoded
 * @return The QR-Code
 */
public QrCodeEncoder kanji(String message){
}",0.9784615384615384
150622,"/** 
 * Creates a QR-Code which encodes a number sequence
 * @param numbers Array of numbers. Each number has to be from 0 to 9 inclusive.
 * @return The QR-Code
 */
public QrCode numeric(int[] numbers){
}","/** 
 * Creates a QR-Code which encodes a number sequence
 * @param numbers Array of numbers. Each number has to be from 0 to 9 inclusive.
 * @return The QR-Code
 */
public QrCodeEncoder numeric(int[] numbers){
}",0.9832134292565948
150623,"public static byte[] alphanumericToValues(String data){
  byte[] output=new byte[data.length()];
  for (int i=0; i < data.length(); i++) {
    char c=data.charAt(i);
    if (Character.isDigit(c)) {
      output[i]=(byte)(c - '0');
    }
 else {
      int value=(int)(Character.toUpperCase(c) - 'A');
      if (value >= 0 && value < 36) {
        output[i]=(byte)(10 + value);
      }
 else {
switch (c) {
case ' ':
          output[i]=36;
        break;
case '$':
      output[i]=37;
    break;
case '%':
  output[i]=38;
break;
case '*':
output[i]=39;
break;
case '+':
output[i]=40;
break;
case '-':
output[i]=41;
break;
case '.':
output[i]=42;
break;
case '/':
output[i]=43;
break;
case ':':
output[i]=44;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + c + ""String_Node_Str""+ (int)c);
}
}
}
}
return output;
}","public static byte[] alphanumericToValues(String data){
  byte[] output=new byte[data.length()];
  for (int i=0; i < data.length(); i++) {
    char c=data.charAt(i);
    int value=ALPHANUMERIC.indexOf(c);
    if (value < 0)     throw new IllegalArgumentException(""String_Node_Str"" + c + ""String_Node_Str""+ (int)c);
    output[i]=(byte)value;
  }
  return output;
}",0.4386989157631359
150624,"public QrCodeEncoder(){
  qr.version=-1;
}","public QrCodeEncoder(){
  reset();
}",0.8205128205128205
150625,"/** 
 * Creates a QR-Code which encodes data in the byte format.
 * @param data Data to be encoded
 * @return The QR-Code
 */
public QrCode bytes(byte[] data){
}","/** 
 * Creates a QR-Code which encodes data in the byte format.
 * @param data Data to be encoded
 * @return The QR-Code
 */
public QrCodeEncoder bytes(byte[] data){
}",0.9787234042553192
150626,"public static char valueToAlphanumeric(int value){
  if (value <= 9)   return (char)(value + '0');
  if (value < 36)   return (char)(value - 10 + 'A');
switch (value) {
case 36:
    return ' ';
case 37:
  return '$';
case 38:
return '%';
case 39:
return '*';
case 40:
return '+';
case 41:
return '-';
case 42:
return '.';
case 43:
return '/';
case 44:
return ':';
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","public static char valueToAlphanumeric(int value){
  if (value < 0 || value >= ALPHANUMERIC.length())   throw new RuntimeException(""String_Node_Str"");
  return ALPHANUMERIC.charAt(value);
}",0.3993558776167472
150627,"@Before public void setup(){
  expected=new QrCodeEncoder().setVersion(2).setError(QrCode.ErrorLevel.H).setMask(QrCodeMaskPattern.M010).numeric(message);
}","@Before public void setup(){
  expected=new QrCodeEncoder().setVersion(2).setError(QrCode.ErrorLevel.H).setMask(QrCodeMaskPattern.M010).numeric(message).fixate();
}",0.9717868338557992
150628,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowMarkers) {
      List<QrCode> detected=detector.getDetections();
      g2.setColor(new Color(0x5011FF00,true));
      for (int i=0; i < detected.size(); i++) {
        QrCode qr=detected.get(i);
        VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
        if (controls.bShowBits)         renderBinaryValues(g2,qr);
      }
      List<QrCode> failures=detector.getFailures();
      for (int i=0; i < failures.size(); i++) {
        QrCode qr=failures.get(i);
        if (qr.failureCause.ordinal() < ALIGNMENT.ordinal())         continue;
switch (qr.failureCause) {
case ERROR_CORRECTION:
          g2.setColor(new Color(0x80FF0000,true));
        break;
case DECODING_MESSAGE:
      g2.setColor(new Color(0x80FF9000,true));
    break;
default :
  g2.setColor(new Color(0x80FF00C0,true));
break;
}
VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
if (controls.bShowBits) renderBinaryValues(g2,qr);
}
}
if (controls.bShowSquares) {
List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null,null);
g2.setColor(Color.GREEN);
g2.setStroke(new BasicStroke(3));
for (Polygon2D_F64 p : polygons) {
VisualizeShapes.drawPolygon(p,true,scale,g2);
}
}
if (controls.bShowAlignmentPattern) {
List<QrCode> codes=detector.getDetections();
g2.setColor(Color.BLUE);
g2.setStroke(new BasicStroke(3));
for (QrCode qr : codes) {
double size=Math.sqrt(qr.ppCorner.areaSimple()) / 14.0;
for (int i=0; i < qr.alignment.size; i++) {
QrCode.Alignment a=qr.alignment.get(i);
VisualizeFeatures.drawCircle(g2,a.pixel.x * scale,a.pixel.y * scale,size * scale);
}
}
}
if (controls.bShowPositionPattern) {
FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
g2.setColor(Color.ORANGE);
g2.setStroke(new BasicStroke(3));
List<SquareEdge> list=new ArrayList<>();
for (int i=0; i < nodes.size(); i++) {
SquareNode n=nodes.get(i);
VisualizeShapes.drawPolygon(n.square,true,scale,g2);
for (int j=0; j < 4; j++) {
if (n.edges[j] != null) {
if (!list.contains(n.edges[j])) {
  list.add(n.edges[j]);
}
}
}
}
g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
g2.setColor(new Color(255,150,100));
g2.setStroke(new BasicStroke(3));
Line2D.Double l=new Line2D.Double();
for (int i=0; i < list.size(); i++) {
SquareEdge e=list.get(i);
Point2D_F64 a=e.a.center;
Point2D_F64 b=e.b.center;
l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
g2.draw(l);
}
}
}
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowMarkers) {
      List<QrCode> detected=detector.getDetections();
      for (int i=0; i < detected.size(); i++) {
        g2.setColor(new Color(0x5011FF00,true));
        QrCode qr=detected.get(i);
        VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
        if (controls.bShowBits)         renderBinaryValues(g2,qr);
      }
      List<QrCode> failures=detector.getFailures();
      for (int i=0; i < failures.size(); i++) {
        QrCode qr=failures.get(i);
        if (qr.failureCause.ordinal() < ALIGNMENT.ordinal())         continue;
switch (qr.failureCause) {
case ERROR_CORRECTION:
          g2.setColor(new Color(0x80FF0000,true));
        break;
case DECODING_MESSAGE:
      g2.setColor(new Color(0x80FF9000,true));
    break;
default :
  g2.setColor(new Color(0x80FF00C0,true));
break;
}
VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
if (controls.bShowBits) renderBinaryValues(g2,qr);
}
}
if (controls.bShowSquares) {
List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null,null);
g2.setColor(Color.GREEN);
g2.setStroke(new BasicStroke(3));
for (Polygon2D_F64 p : polygons) {
VisualizeShapes.drawPolygon(p,true,scale,g2);
}
}
if (controls.bShowAlignmentPattern) {
List<QrCode> codes=detector.getDetections();
g2.setColor(Color.BLUE);
g2.setStroke(new BasicStroke(3));
for (QrCode qr : codes) {
double size=Math.sqrt(qr.ppCorner.areaSimple()) / 14.0;
for (int i=0; i < qr.alignment.size; i++) {
QrCode.Alignment a=qr.alignment.get(i);
VisualizeFeatures.drawCircle(g2,a.pixel.x * scale,a.pixel.y * scale,size * scale);
}
}
}
if (controls.bShowPositionPattern) {
FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
g2.setColor(Color.ORANGE);
g2.setStroke(new BasicStroke(3));
List<SquareEdge> list=new ArrayList<>();
for (int i=0; i < nodes.size(); i++) {
SquareNode n=nodes.get(i);
VisualizeShapes.drawPolygon(n.square,true,scale,g2);
for (int j=0; j < 4; j++) {
if (n.edges[j] != null) {
if (!list.contains(n.edges[j])) {
  list.add(n.edges[j]);
}
}
}
}
g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
g2.setColor(new Color(255,150,100));
g2.setStroke(new BasicStroke(3));
Line2D.Double l=new Line2D.Double();
for (int i=0; i < list.size(); i++) {
SquareEdge e=list.get(i);
Point2D_F64 a=e.a.center;
Point2D_F64 b=e.b.center;
l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
g2.draw(l);
}
}
}
}",0.9850837138508372
150629,"@Override public void viewUpdated(){
  BufferedImage active=null;
  if (controls.selectedView == 0) {
    active=original;
  }
 else   if (controls.selectedView == 1) {
    VisualizeBinaryData.renderBinary(detector.getBinary(),false,work);
    active=work;
    work.setRGB(0,0,work.getRGB(0,0));
  }
 else {
    Graphics2D g2=work.createGraphics();
    g2.setColor(Color.BLACK);
    g2.fillRect(0,0,work.getWidth(),work.getHeight());
    active=work;
  }
  guiImage.setBufferedImage(active);
  guiImage.setScale(controls.zoom);
  guiImage.repaint();
}","@Override public void viewUpdated(){
  BufferedImage active;
  if (controls.selectedView == 0) {
    active=original;
  }
 else   if (controls.selectedView == 1) {
    VisualizeBinaryData.renderBinary(detector.getBinary(),false,work);
    active=work;
    work.setRGB(0,0,work.getRGB(0,0));
  }
 else {
    Graphics2D g2=work.createGraphics();
    g2.setColor(Color.BLACK);
    g2.fillRect(0,0,work.getWidth(),work.getHeight());
    active=work;
  }
  guiImage.setBufferedImage(active);
  guiImage.setScale(controls.zoom);
  guiImage.repaint();
}",0.9954421148587056
150630,"private void renderBinaryValues(Graphics2D g2,QrCode qr){
  QrCodeAlignmentPatternLocator<T> locator=detector.getDecoder().getAlignmentLocator();
  locator.setTransform(qr);
  List<Point2D_I32> points=QrCode.LOCATION_BITS[qr.version];
  PackedBits8 bits=new PackedBits8();
  bits.data=qr.rawbits;
  bits.size=qr.rawbits.length * 8;
  Point2D_F32 p=new Point2D_F32();
  for (int i=0; i < bits.size; i++) {
    Point2D_I32 c=points.get(i);
    locator.gridToImage(c.y + 0.5f,c.x + 0.5f,p);
    int value=qr.mask.apply(c.y,c.x,bits.get(i));
    if (value == 1)     g2.setColor(Color.BLACK);
 else     if (value == 0)     g2.setColor(Color.WHITE);
 else     g2.setColor(Color.RED);
    renderCircleAt(g2,p);
  }
  int N=qr.totalModules();
  g2.setColor(Color.BLUE);
  locator.gridToImage(0,N - 7,p);
  renderCircleAt(g2,p);
  locator.gridToImage(7,N - 7,p);
  renderCircleAt(g2,p);
  locator.gridToImage(N - 7,0,p);
  renderCircleAt(g2,p);
  locator.gridToImage(N - 7,7,p);
  renderCircleAt(g2,p);
}","/** 
 * Draws the estimated value of each bit onto the image
 */
private void renderBinaryValues(Graphics2D g2,QrCode qr){
  locator.setTransform(qr);
  List<Point2D_I32> points=QrCode.LOCATION_BITS[qr.version];
  PackedBits8 bits=new PackedBits8();
  bits.data=qr.rawbits;
  bits.size=qr.rawbits.length * 8;
  Point2D_F32 p=new Point2D_F32();
  for (int i=0; i < bits.size; i++) {
    Point2D_I32 c=points.get(i);
    locator.gridToImage(c.y + 0.5f,c.x + 0.5f,p);
    int value=qr.mask.apply(c.y,c.x,bits.get(i));
    if (value == 1)     g2.setColor(Color.BLACK);
 else     if (value == 0)     g2.setColor(Color.WHITE);
 else     g2.setColor(Color.RED);
    renderCircleAt(g2,p);
  }
}",0.7388459250446163
150631,"public ErrorBlock(int codewords,int dataCodewords,int eccBlocks){
  this.codewords=codewords;
  this.dataCodewords=dataCodewords;
  this.eccBlocks=eccBlocks;
}","public ErrorBlock(int codewords,int dataCodewords,int blocks){
  this.codewords=codewords;
  this.dataCodewords=dataCodewords;
  this.blocks=blocks;
}",0.9514563106796116
150632,"/** 
 * Reconstruct the data while applying error correction.
 */
private boolean applyErrorCorrection(QrCode qr){
  QrCode.VersionInfo info=QrCode.VERSION_INFO[qr.version];
  QrCode.ErrorBlock block=info.levels.get(qr.error);
  int wordsBlockAllA=block.codewords;
  int wordsBlockDataA=block.dataCodewords;
  int wordsEcc=wordsBlockAllA - wordsBlockDataA;
  int numBlocksA=block.eccBlocks;
  int wordsBlockAllB=wordsBlockAllA + 1;
  int wordsBlockDataB=wordsBlockDataA + 1;
  int numBlocksB=(info.codewords - wordsBlockAllA * numBlocksA) / wordsBlockAllB;
  int totalBlocks=numBlocksA + numBlocksB;
  int totalDataBytes=wordsBlockDataA * numBlocksA + wordsBlockDataB * numBlocksB;
  qr.rawdata=new byte[totalDataBytes];
  ecc.resize(wordsEcc);
  rscodes.generator(wordsEcc);
  if (!decodeBlocks(qr,wordsBlockDataA,numBlocksA,0,0,totalDataBytes,totalBlocks))   return false;
  return decodeBlocks(qr,wordsBlockDataB,numBlocksB,numBlocksA * wordsBlockDataA,numBlocksA,totalDataBytes,totalBlocks);
}","/** 
 * Reconstruct the data while applying error correction.
 */
private boolean applyErrorCorrection(QrCode qr){
  QrCode.VersionInfo info=QrCode.VERSION_INFO[qr.version];
  QrCode.ErrorBlock block=info.levels.get(qr.error);
  int wordsBlockAllA=block.codewords;
  int wordsBlockDataA=block.dataCodewords;
  int wordsEcc=wordsBlockAllA - wordsBlockDataA;
  int numBlocksA=block.blocks;
  int wordsBlockAllB=wordsBlockAllA + 1;
  int wordsBlockDataB=wordsBlockDataA + 1;
  int numBlocksB=(info.codewords - wordsBlockAllA * numBlocksA) / wordsBlockAllB;
  int totalBlocks=numBlocksA + numBlocksB;
  int totalDataBytes=wordsBlockDataA * numBlocksA + wordsBlockDataB * numBlocksB;
  qr.rawdata=new byte[totalDataBytes];
  ecc.resize(wordsEcc);
  rscodes.generator(wordsEcc);
  if (!decodeBlocks(qr,wordsBlockDataA,numBlocksA,0,0,totalDataBytes,totalBlocks))   return false;
  return decodeBlocks(qr,wordsBlockDataB,numBlocksB,numBlocksA * wordsBlockDataA,numBlocksA,totalDataBytes,totalBlocks);
}",0.9974886991461576
150633,"protected void bitsToMessage(PackedBits8 stream){
  stream.append(0,(8 - (stream.size % 8)) % 8,false);
  QrCode.VersionInfo info=QrCode.VERSION_INFO[qr.version];
  QrCode.ErrorBlock block=info.levels.get(qr.error);
  qr.rawbits=new byte[info.codewords];
  int wordsBlockAllA=block.codewords;
  int wordsBlockDataA=block.dataCodewords;
  int wordsEcc=wordsBlockAllA - wordsBlockDataA;
  int numBlocksA=block.eccBlocks;
  int wordsBlockAllB=wordsBlockAllA + 1;
  int wordsBlockDataB=wordsBlockDataA + 1;
  int numBlocksB=(info.codewords - wordsBlockAllA * numBlocksA) / wordsBlockAllB;
  message.resize(wordsBlockDataA + 1);
  int startEcc=numBlocksA * wordsBlockDataA + numBlocksB * wordsBlockDataB;
  int totalBlocks=numBlocksA + numBlocksB;
  rscodes.generator(wordsEcc);
  ecc.resize(wordsEcc);
  encodeBlocks(stream,wordsBlockDataA,numBlocksA,0,0,startEcc,totalBlocks);
  encodeBlocks(stream,wordsBlockDataB,numBlocksB,wordsBlockDataA * numBlocksA,numBlocksA,startEcc,totalBlocks);
}","protected void bitsToMessage(PackedBits8 stream){
  stream.append(0,(8 - (stream.size % 8)) % 8,false);
  QrCode.VersionInfo info=QrCode.VERSION_INFO[qr.version];
  QrCode.ErrorBlock block=info.levels.get(qr.error);
  qr.rawbits=new byte[info.codewords];
  int wordsBlockAllA=block.codewords;
  int wordsBlockDataA=block.dataCodewords;
  int wordsEcc=wordsBlockAllA - wordsBlockDataA;
  int numBlocksA=block.blocks;
  int wordsBlockAllB=wordsBlockAllA + 1;
  int wordsBlockDataB=wordsBlockDataA + 1;
  int numBlocksB=(info.codewords - wordsBlockAllA * numBlocksA) / wordsBlockAllB;
  message.resize(wordsBlockDataA + 1);
  int startEcc=numBlocksA * wordsBlockDataA + numBlocksB * wordsBlockDataB;
  int totalBlocks=numBlocksA + numBlocksB;
  rscodes.generator(wordsEcc);
  ecc.resize(wordsEcc);
  encodeBlocks(stream,wordsBlockDataA,numBlocksA,0,0,startEcc,totalBlocks);
  encodeBlocks(stream,wordsBlockDataB,numBlocksB,wordsBlockDataA * numBlocksA,numBlocksA,startEcc,totalBlocks);
}",0.9974632166412988
150634,"/** 
 * Can through version info and see if it passes a few simple checks. It's still possible for wrong entries to exist.
 */
@Test public void sanityVersionInfo(){
  for (int version=1; version <= QrCode.MAX_VERSION; version++) {
    QrCode.VersionInfo info=QrCode.VERSION_INFO[version];
    int totalBits=new QrCodeCodeWordLocations(version).bits.size();
    assertEquals(totalBits / 8,info.codewords);
    for (    QrCode.ErrorLevel level : QrCode.ErrorLevel.values()) {
      QrCode.ErrorBlock block=info.levels.get(level);
      assertTrue(block.dataCodewords < block.codewords);
      int byteBlockB=block.codewords + 1;
      int byteDataB=block.dataCodewords + 1;
      int countB=(info.codewords - block.codewords * block.eccBlocks);
      assertTrue(countB >= 0);
      if (countB > 0) {
        assertTrue(countB % byteBlockB == 0);
        countB/=byteBlockB;
        assertEquals(info.codewords,block.codewords * block.eccBlocks + byteBlockB * countB);
        assertTrue(byteDataB < byteBlockB);
      }
    }
  }
}","/** 
 * Can through version info and see if it passes a few simple checks. It's still possible for wrong entries to exist.
 */
@Test public void sanityVersionInfo(){
  for (int version=1; version <= QrCode.MAX_VERSION; version++) {
    QrCode.VersionInfo info=QrCode.VERSION_INFO[version];
    int totalBits=new QrCodeCodeWordLocations(version).bits.size();
    assertEquals(totalBits / 8,info.codewords);
    for (    QrCode.ErrorLevel level : QrCode.ErrorLevel.values()) {
      QrCode.ErrorBlock block=info.levels.get(level);
      assertTrue(block.dataCodewords < block.codewords);
      int byteBlockB=block.codewords + 1;
      int byteDataB=block.dataCodewords + 1;
      int countB=(info.codewords - block.codewords * block.blocks);
      assertTrue(countB >= 0);
      if (countB > 0) {
        assertTrue(countB % byteBlockB == 0);
        countB/=byteBlockB;
        assertEquals(info.codewords,block.codewords * block.blocks + byteBlockB * countB);
        assertTrue(byteDataB < byteBlockB);
      }
    }
  }
}",0.9951314508276532
150635,"protected void bitsToMessage(PackedBits8 stream){
}","protected void bitsToMessage(PackedBits8 stream){
  stream.append(0,(8 - (stream.size % 8)) % 8,false);
  QrCode.VersionInfo info=QrCode.VERSION_INFO[qr.version];
  QrCode.ErrorBlock block=info.levels.get(qr.error);
  qr.dataRaw=new byte[info.codewords];
  int wordsBlockAllA=block.codewords;
  int wordsBlockDataA=block.dataCodewords;
  int wordsEcc=wordsBlockAllA - wordsBlockDataA;
  int numBlocksA=block.eccBlocks;
  int wordsBlockAllB=wordsBlockAllA + 1;
  int wordsBlockDataB=wordsBlockDataA + 1;
  int numBlocksB=(info.codewords - wordsBlockAllA * numBlocksA) / wordsBlockAllB;
  input.resize(wordsBlockDataA + 1);
  int startEcc=numBlocksA * wordsBlockDataA + numBlocksB * wordsBlockDataB;
  int totalBlocks=numBlocksA + numBlocksB;
  codes.generator(wordsEcc);
  ecc.resize(wordsEcc);
  encodeBlocks(stream,wordsBlockDataA,numBlocksA,0,0,startEcc,totalBlocks);
  encodeBlocks(stream,wordsBlockDataB,numBlocksB,wordsBlockDataA * numBlocksA,numBlocksA,startEcc,totalBlocks);
}",0.0986460348162475
150636,"/** 
 * Renders the raw data bit output while applying the selected mask
 */
private void renderData(){
  QrCodeMaskPattern mask=qr.mask;
  int count=0;
  while (count < bitLocations.size()) {
    int bits=qr.dataRaw[count / 8] & 0xFF;
    int N=Math.min(8,bitLocations.size() - count);
    for (int i=0; i < N; i++) {
      Point2D_I32 coor=bitLocations.get(count + i);
      int value=mask.apply(coor.y,coor.x,((bits >> i) & 0x01));
      if (value > 0) {
        square(coor.y,coor.x);
      }
    }
    count+=8;
  }
}","/** 
 * Renders the raw data bit output while applying the selected mask
 */
private void renderData(){
  QrCodeMaskPattern mask=qr.mask;
  int count=0;
  int length=bitLocations.size() - bitLocations.size() % 8;
  while (count < length) {
    int bits=qr.dataRaw[count / 8] & 0xFF;
    int N=Math.min(8,bitLocations.size() - count);
    for (int i=0; i < N; i++) {
      Point2D_I32 coor=bitLocations.get(count + i);
      int value=mask.apply(coor.y,coor.x,((bits >> i) & 0x01));
      if (value > 0) {
        square(coor.y,coor.x);
      }
    }
    count+=8;
  }
}",0.922089825847846
150637,"/** 
 * Generates a QR Code with the specified message. An exception is thrown if the message is too long to be encoded.
 */
public void render(QrCode qr){
  this.qr=qr;
  this.numModules=QrCode.totalModules(qr.version);
  this.moduleWidth=markerWidth / numModules;
  init();
  positionPattern(0,0,qr.ppCorner);
  positionPattern((numModules - 7) * moduleWidth,0,qr.ppRight);
  positionPattern(0,(numModules - 7) * moduleWidth,qr.ppDown);
  timingPattern(7 * moduleWidth,6 * moduleWidth,moduleWidth,0);
  timingPattern(6 * moduleWidth,7 * moduleWidth,0,moduleWidth);
  formatInformation();
  if (qr.version >= QrCode.VERSION_VERSION)   versionInformation();
  int alignment[]=QrCode.VERSION_INFO[qr.version].alignment;
  for (int i=0; i < alignment.length; i++) {
    int row=alignment[i];
    for (int j=0; j < alignment.length; j++) {
      if (i == 0 & j == 0)       continue;
      if (i == alignment.length - 1 & j == 0)       continue;
      if (i == alignment.length - 1 & j == alignment.length - 1)       continue;
      int col=alignment[j];
      alignmentPattern(col,numModules - row - 1);
    }
  }
  bitLocations=new QrCodeCodeWordLocations(numModules,alignment,qr.version >= QrCode.VERSION_VERSION).bits;
  int numBytes=bitLocations.size() / 8;
  if (numBytes != qr.dataRaw.length)   throw new RuntimeException(""String_Node_Str"");
  renderData();
}","/** 
 * Generates a QR Code with the specified message. An exception is thrown if the message is too long to be encoded.
 */
public void render(QrCode qr){
  this.qr=qr;
  this.numModules=QrCode.totalModules(qr.version);
  this.moduleWidth=markerWidth / numModules;
  if (qr.dataRaw.length != QrCode.VERSION_INFO[qr.version].codewords)   throw new RuntimeException(""String_Node_Str"");
  init();
  positionPattern(0,0,qr.ppCorner);
  positionPattern((numModules - 7) * moduleWidth,0,qr.ppRight);
  positionPattern(0,(numModules - 7) * moduleWidth,qr.ppDown);
  timingPattern(7 * moduleWidth,6 * moduleWidth,moduleWidth,0);
  timingPattern(6 * moduleWidth,7 * moduleWidth,0,moduleWidth);
  formatInformation();
  if (qr.version >= QrCode.VERSION_VERSION)   versionInformation();
  int alignment[]=QrCode.VERSION_INFO[qr.version].alignment;
  for (int i=0; i < alignment.length; i++) {
    int row=alignment[i];
    for (int j=0; j < alignment.length; j++) {
      if (i == 0 & j == 0)       continue;
      if (i == alignment.length - 1 & j == 0)       continue;
      if (i == alignment.length - 1 & j == alignment.length - 1)       continue;
      int col=alignment[j];
      alignmentPattern(col,numModules - row - 1);
    }
  }
  bitLocations=new QrCodeCodeWordLocations(qr.version).bits;
  int numBytes=bitLocations.size() / 8;
  if (numBytes != qr.dataRaw.length)   throw new RuntimeException(""String_Node_Str"");
  renderData();
}",0.9406294706723892
150638,"@Test public void savePolyline(){
  PolylineSplitMerge alg=new PolylineSplitMerge();
  alg.getPolylines().grow();
  alg.getPolylines().grow();
  alg.getPolylines().grow();
  alg.getPolylines().grow();
  alg.addCorner(0).object.sideError=10;
  alg.addCorner(0);
  alg.addCorner(0);
  alg.addCorner(0);
  alg.savePolyline(20);
  assertTrue(alg.getPolylines().get(1).score > 0);
  assertEquals(4,alg.getPolylines().get(1).splits.size);
  fail(""String_Node_Str"");
}","@Test public void savePolyline(){
  PolylineSplitMerge alg=new PolylineSplitMerge();
  alg.getPolylines().grow();
  alg.getPolylines().grow();
  alg.getPolylines().grow();
  alg.getPolylines().grow();
  alg.addCorner(0).object.sideError=10;
  alg.addCorner(0);
  alg.addCorner(0);
  alg.addCorner(0);
  alg.savePolyline();
  assertTrue(alg.getPolylines().get(1).score > 0);
  assertEquals(4,alg.getPolylines().get(1).splits.size);
  fail(""String_Node_Str"");
}",0.9978260869565218
150639,"@Override protected List<Polygon2D_F64> getFoundPolygons(){
  return alg.getFindSeeds().getDetectorSquare().getPolygons(null);
}","@Override protected List<Polygon2D_F64> getFoundPolygons(){
  return alg.getFindSeeds().getDetectorSquare().getPolygons(null,null);
}",0.9808429118773946
150640,"@Override protected List<Polygon2D_F64> getFoundPolygons(){
  return alg.getDetectorSquare().getPolygons(null);
}","@Override protected List<Polygon2D_F64> getFoundPolygons(){
  return alg.getDetectorSquare().getPolygons(null,null);
}",0.9783549783549784
150641,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectFiducialSquareBinaryApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    FastQueue<FoundFiducial> detected=detector.getFound();
    if (controls.bShowSquares) {
      List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null);
      g2.setColor(Color.GREEN);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowOrienation) {
      g2.setStroke(new BasicStroke(2));
      for (int i=0; i < detected.size; i++) {
        VisualizeShapes.drawArrowSubPixel(detected.get(i).distortedPixels,3,scale,g2);
      }
    }
    if (controls.bShowlabels) {
      Point2D_F64 center=new Point2D_F64();
      g2.setStroke(new BasicStroke(2));
      for (int i=0; i < detected.size; i++) {
        FoundFiducial f=detected.get(i);
        UtilPolygons2D_F64.center(f.distortedPixels,center);
        center.x*=scale;
        center.y*=scale;
        VisualizeFiducial.drawLabel(center,""String_Node_Str"" + f.id,g2);
      }
    }
  }
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (lockProcessing) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    FastQueue<FoundFiducial> detected=detector.getFound();
    if (controls.bShowSquares) {
      List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null,null);
      g2.setColor(Color.GREEN);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowOrienation) {
      g2.setStroke(new BasicStroke(2));
      for (int i=0; i < detected.size; i++) {
        VisualizeShapes.drawArrowSubPixel(detected.get(i).distortedPixels,3,scale,g2);
      }
    }
    if (controls.bShowlabels) {
      Point2D_F64 center=new Point2D_F64();
      g2.setStroke(new BasicStroke(2));
      for (int i=0; i < detected.size; i++) {
        FoundFiducial f=detected.get(i);
        UtilPolygons2D_F64.center(f.distortedPixels,center);
        center.x*=scale;
        center.y*=scale;
        VisualizeFiducial.drawLabel(center,""String_Node_Str"" + f.id,g2);
      }
    }
  }
}",0.9839830764581444
150642,"/** 
 * Called when how the data is visualized has changed
 */
public void viewUpdated(){
  BufferedImage active=null;
  if (controls.selectedView == 0) {
    active=original;
  }
 else   if (controls.selectedView == 1) {
synchronized (this) {
      VisualizeBinaryData.renderBinary(detector.getBinaryImage(),false,work);
    }
    active=work;
    work.setRGB(0,0,work.getRGB(0,0));
  }
 else {
    Graphics2D g2=work.createGraphics();
    g2.setColor(Color.BLACK);
    g2.fillRect(0,0,work.getWidth(),work.getHeight());
    active=work;
  }
  guiImage.setBufferedImage(active);
  guiImage.setScale(controls.zoom);
  guiImage.repaint();
}","/** 
 * Called when how the data is visualized has changed
 */
public void viewUpdated(){
  BufferedImage active=null;
  if (controls.selectedView == 0) {
    active=original;
  }
 else   if (controls.selectedView == 1) {
synchronized (lockProcessing) {
      VisualizeBinaryData.renderBinary(detector.getBinaryImage(),false,work);
    }
    active=work;
    work.setRGB(0,0,work.getRGB(0,0));
  }
 else {
    Graphics2D g2=work.createGraphics();
    g2.setColor(Color.BLACK);
    g2.fillRect(0,0,work.getWidth(),work.getHeight());
    active=work;
  }
  guiImage.setBufferedImage(active);
  guiImage.setScale(controls.zoom);
  guiImage.repaint();
}",0.9860248447204968
150643,"protected void createDetector(boolean initializing){
  if (!initializing)   BoofSwingUtil.checkGuiThread();
synchronized (this) {
    ConfigThreshold configThresh=controls.polygonPanel.getThresholdPanel().createConfig();
    ConfigFiducialBinary configFid=controls.getConfig();
    final InputToBinary<GrayF32> binary=FactoryThresholdBinary.threshold(configThresh,GrayF32.class);
    final DetectPolygonBinaryGrayRefine<GrayF32> squareDetector=FactoryShapeDetector.polygon(configFid.squareDetector,GrayF32.class);
    detector=new Detector(configFid,binary,squareDetector);
  }
}","protected void createDetector(boolean initializing){
  if (!initializing)   BoofSwingUtil.checkGuiThread();
synchronized (lockProcessing) {
    ConfigThreshold configThresh=controls.polygonPanel.getThresholdPanel().createConfig();
    ConfigFiducialBinary configFid=controls.getConfig();
    final InputToBinary<GrayF32> binary=FactoryThresholdBinary.threshold(configThresh,GrayF32.class);
    final DetectPolygonBinaryGrayRefine<GrayF32> squareDetector=FactoryShapeDetector.polygon(configFid.squareDetector,GrayF32.class);
    detector=new Detector(configFid,binary,squareDetector);
  }
}",0.9845890410958904
150644,"@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  System.out.flush();
  original=ConvertBufferedImage.checkCopy(buffered,original);
  work=ConvertBufferedImage.checkDeclare(buffered,work);
  final double timeInSeconds;
synchronized (this) {
    long before=System.nanoTime();
    detector.process((GrayF32)input);
    long after=System.nanoTime();
    timeInSeconds=(after - before) * 1e-9;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      controls.setProcessingTime(timeInSeconds);
      viewUpdated();
    }
  }
);
}","@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  System.out.flush();
  original=ConvertBufferedImage.checkCopy(buffered,original);
  work=ConvertBufferedImage.checkDeclare(buffered,work);
  final double timeInSeconds;
synchronized (lockProcessing) {
    long before=System.nanoTime();
    detector.process((GrayF32)input);
    long after=System.nanoTime();
    timeInSeconds=(after - before) * 1e-9;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      controls.setProcessingTime(timeInSeconds);
      viewUpdated();
    }
  }
);
}",0.9855305466237942
150645,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (true) {
      FastQueue<QrCode> detected=detector.getDetections();
      g2.setColor(new Color(0x50FF0000,true));
      for (int i=0; i < detected.size; i++) {
        QrCode qr=detected.get(i);
        VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
      }
    }
    if (controls.bShowSquares) {
      List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null);
      g2.setColor(Color.GREEN);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowAlignmentPattern) {
      List<QrCode> codes=detector.getDetections().toList();
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(3));
      for (      QrCode qr : codes) {
        double size=Math.sqrt(qr.ppCorner.areaSimple()) / 14.0;
        for (int i=0; i < qr.alignment.size; i++) {
          QrCode.Alignment a=qr.alignment.get(i);
          VisualizeFeatures.drawCircle(g2,a.pixel.x * scale,a.pixel.y * scale,size * scale);
        }
      }
    }
    if (controls.bShowPositionPattern) {
      FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
      g2.setColor(Color.ORANGE);
      g2.setStroke(new BasicStroke(3));
      List<SquareEdge> list=new ArrayList<>();
      for (int i=0; i < nodes.size(); i++) {
        SquareNode n=nodes.get(i);
        VisualizeShapes.drawPolygon(n.square,true,scale,g2);
        for (int j=0; j < 4; j++) {
          if (n.edges[j] != null) {
            if (!list.contains(n.edges[j])) {
              list.add(n.edges[j]);
            }
          }
        }
      }
      g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
      g2.setColor(new Color(255,150,100));
      g2.setStroke(new BasicStroke(3));
      Line2D.Double l=new Line2D.Double();
      for (int i=0; i < list.size(); i++) {
        SquareEdge e=list.get(i);
        Point2D_F64 a=e.a.center;
        Point2D_F64 b=e.b.center;
        l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
        g2.draw(l);
      }
    }
  }
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      LinearContourLabelChang2004 contour=detector.getSquareDetector().getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    FastQueue<QrCode> detected=detector.getDetections();
    g2.setColor(new Color(0x50FF0000,true));
    for (int i=0; i < detected.size; i++) {
      QrCode qr=detected.get(i);
      VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
    }
    if (controls.bShowSquares) {
      List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null,null);
      g2.setColor(Color.GREEN);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowAlignmentPattern) {
      List<QrCode> codes=detector.getDetections().toList();
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(3));
      for (      QrCode qr : codes) {
        double size=Math.sqrt(qr.ppCorner.areaSimple()) / 14.0;
        for (int i=0; i < qr.alignment.size; i++) {
          QrCode.Alignment a=qr.alignment.get(i);
          VisualizeFeatures.drawCircle(g2,a.pixel.x * scale,a.pixel.y * scale,size * scale);
        }
      }
    }
    if (controls.bShowPositionPattern) {
      FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
      g2.setColor(Color.ORANGE);
      g2.setStroke(new BasicStroke(3));
      List<SquareEdge> list=new ArrayList<>();
      for (int i=0; i < nodes.size(); i++) {
        SquareNode n=nodes.get(i);
        VisualizeShapes.drawPolygon(n.square,true,scale,g2);
        for (int j=0; j < 4; j++) {
          if (n.edges[j] != null) {
            if (!list.contains(n.edges[j])) {
              list.add(n.edges[j]);
            }
          }
        }
      }
      g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
      g2.setColor(new Color(255,150,100));
      g2.setStroke(new BasicStroke(3));
      Line2D.Double l=new Line2D.Double();
      for (int i=0; i < list.size(); i++) {
        SquareEdge e=list.get(i);
        Point2D_F64 a=e.a.center;
        Point2D_F64 b=e.b.center;
        l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
        g2.draw(l);
      }
    }
  }
}",0.9934508816120908
150646,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectBlackPolygonAppControlPanel controls=(DetectBlackPolygonAppControlPanel)DetectBlackPolygonApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectBlackPolygonApp.this) {
    if (controls.bShowContour) {
      g2.setStroke(new BasicStroke(1));
      LinearContourLabelChang2004 contour=detector.getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowLines) {
      List<Polygon2D_F64> polygons=detector.getPolygons(null);
      g2.setColor(Color.RED);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        int red=255 * ((p.size() - 3) % 4) / 3;
        int green=255 * ((p.size()) % 5) / 4;
        int blue=255 * ((p.size() + 2) % 6) / 5;
        g2.setColor(new Color(red,green,blue));
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowCorners) {
      List<Polygon2D_F64> polygons=detector.getPolygons(null);
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(1));
      for (      Polygon2D_F64 p : polygons) {
        for (int i=0; i < p.size(); i++) {
          Point2D_F64 c=p.get(i);
          VisualizeFeatures.drawCircle(g2,scale * c.x,scale * c.y,5);
        }
      }
    }
  }
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectBlackPolygonAppControlPanel controls=(DetectBlackPolygonAppControlPanel)DetectBlackPolygonApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectBlackPolygonApp.this) {
    if (controls.bShowContour) {
      g2.setStroke(new BasicStroke(1));
      LinearContourLabelChang2004 contour=detector.getDetector().getContourFinder();
      List<Contour> contours=BinaryImageOps.convertContours(contour.getPackedPoints(),contour.getContours());
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowLines) {
      List<Polygon2D_F64> polygons=detector.getPolygons(null,null);
      g2.setColor(Color.RED);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        int red=255 * ((p.size() - 3) % 4) / 3;
        int green=255 * ((p.size()) % 5) / 4;
        int blue=255 * ((p.size() + 2) % 6) / 5;
        g2.setColor(new Color(red,green,blue));
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowCorners) {
      List<Polygon2D_F64> polygons=detector.getPolygons(null,null);
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(1));
      for (      Polygon2D_F64 p : polygons) {
        for (int i=0; i < p.size(); i++) {
          Point2D_F64 c=p.get(i);
          VisualizeFeatures.drawCircle(g2,scale * c.x,scale * c.y,5);
        }
      }
    }
  }
}",0.9969230769230768
150647,"private static void processImages(String[] files,DetectPolygonBinaryGrayRefine<GrayU8> detector,ListDisplayPanel panel){
  for (  String fileName : files) {
    BufferedImage image=UtilImageIO.loadImage(UtilIO.pathExample(fileName));
    GrayU8 input=ConvertBufferedImage.convertFromSingle(image,null,GrayU8.class);
    GrayU8 binary=new GrayU8(input.width,input.height);
    int threshold=GThresholdImageOps.computeOtsu(input,0,255);
    ThresholdImageOps.threshold(input,binary,threshold,true);
    detector.process(input,binary);
    java.util.List<Polygon2D_F64> found=detector.getPolygons(null);
    Graphics2D g2=image.createGraphics();
    g2.setStroke(new BasicStroke(3));
    for (int i=0; i < found.size(); i++) {
      g2.setColor(Color.RED);
      VisualizeShapes.drawPolygon(found.get(i),true,g2,true);
      g2.setColor(Color.CYAN);
      VisualizeShapes.drawPolygonCorners(found.get(i),2,g2,true);
    }
    panel.addImage(image,new File(fileName).getName());
  }
}","private static void processImages(String[] files,DetectPolygonBinaryGrayRefine<GrayU8> detector,ListDisplayPanel panel){
  for (  String fileName : files) {
    BufferedImage image=UtilImageIO.loadImage(UtilIO.pathExample(fileName));
    GrayU8 input=ConvertBufferedImage.convertFromSingle(image,null,GrayU8.class);
    GrayU8 binary=new GrayU8(input.width,input.height);
    int threshold=GThresholdImageOps.computeOtsu(input,0,255);
    ThresholdImageOps.threshold(input,binary,threshold,true);
    detector.process(input,binary);
    java.util.List<Polygon2D_F64> found=detector.getPolygons(null,null);
    Graphics2D g2=image.createGraphics();
    g2.setStroke(new BasicStroke(3));
    for (int i=0; i < found.size(); i++) {
      g2.setColor(Color.RED);
      VisualizeShapes.drawPolygon(found.get(i),true,g2,true);
      g2.setColor(Color.CYAN);
      VisualizeShapes.drawPolygonCorners(found.get(i),2,g2,true);
    }
    panel.addImage(image,new File(fileName).getName());
  }
}",0.9974554707379136
150648,"public SplitMergeLineRefine_to_PointsToPolyline(double splitFraction,ConfigLength minimumSplit,int maxIterations,int refineIterations,double pruneSplitPentially,boolean loop){
  if (loop) {
    splitMerge=new SplitMergeLineFitLoop(splitFraction,minimumSplit,maxIterations);
  }
 else {
    splitMerge=new SplitMergeLineFitSegment(splitFraction,minimumSplit,maxIterations);
  }
  if (refineIterations > 0) {
    refine=new RefinePolyLineCorner(loop,refineIterations);
  }
  if (pruneSplitPentially > 0) {
    pruner=new MinimizeEnergyPrune(pruneSplitPentially);
  }
}","public SplitMergeLineRefine_to_PointsToPolyline(double splitFraction,ConfigLength minimumSplit,int maxIterations,int refineIterations,double pruneSplitPentially,boolean loop){
  minimumSplit=minimumSplit.copy();
  if (loop) {
    splitMerge=new SplitMergeLineFitLoop(splitFraction,minimumSplit,maxIterations);
  }
 else {
    splitMerge=new SplitMergeLineFitSegment(splitFraction,minimumSplit,maxIterations);
  }
  if (refineIterations > 0) {
    refine=new RefinePolyLineCorner(loop,refineIterations);
  }
  if (pruneSplitPentially > 0) {
    pruner=new MinimizeEnergyPrune(pruneSplitPentially);
  }
}",0.9691780821917808
150649,"/** 
 * Returns a list of all polygons with an edge threshold above the minimum
 */
public List<Polygon2D_F64> getPolygons(List<Polygon2D_F64> storage){
  if (storage == null)   storage=new ArrayList<>();
 else   storage.clear();
  List<DetectPolygonFromContour.Info> detections=detector.getFound().toList();
  for (int i=0; i < detections.size(); i++) {
    DetectPolygonFromContour.Info d=detections.get(i);
    if (d.computeEdgeIntensity() >= minimumRefineEdgeIntensity)     storage.add(d.polygon);
  }
  return storage;
}","/** 
 * Returns a list of all polygons with an edge threshold above the minimum
 * @param storageInfo Optional storage for info associated with polygons. Pruning is done so the info listand the returned polygon list are not in synch with each other
 */
public List<Polygon2D_F64> getPolygons(List<Polygon2D_F64> storage,List<DetectPolygonFromContour.Info> storageInfo){
  if (storage == null)   storage=new ArrayList<>();
 else   storage.clear();
  if (storageInfo != null)   storageInfo.clear();
  List<DetectPolygonFromContour.Info> detections=detector.getFound().toList();
  for (int i=0; i < detections.size(); i++) {
    DetectPolygonFromContour.Info d=detections.get(i);
    if (d.computeEdgeIntensity() >= minimumRefineEdgeIntensity) {
      storage.add(d.polygon);
      if (storageInfo != null) {
        storageInfo.add(d);
      }
    }
  }
  return storage;
}",0.7292263610315186
150650,"/** 
 * Specifies the image's intrinsic parameters and target size
 * @param width Width of the input image
 * @param height Height of the input image
 */
private void configure(int width,int height){
  labeled.reshape(width,height);
  this.minimumContour=minimumContourConfig.computeI(Math.min(width,height));
  this.minimumArea=Math.pow(this.minimumContour / 4.0,2);
  contourFinder.setMinContourSize(minimumContour);
  if (helper != null)   helper.setImageShape(width,height);
}","/** 
 * Specifies the image's intrinsic parameters and target size
 * @param width Width of the input image
 * @param height Height of the input image
 */
private void configure(int width,int height){
  labeled.reshape(width,height);
  this.minimumContour=minimumContourConfig.computeI(Math.min(width,height));
  this.minimumContour=Math.max(4,minimumContour);
  this.minimumArea=Math.pow(this.minimumContour / 4.0,2);
  contourFinder.setMinContourSize(minimumContour);
  if (helper != null)   helper.setImageShape(width,height);
}",0.950592885375494
150651,"@Override public void checkValidity(){
}","@Override public void checkValidity(){
  minimumContour.checkValidity();
}",0.7017543859649122
150652,"/** 
 * Process the image and detect the calibration target
 * @param image Input image
 * @return true if a calibration target was found and false if not
 */
public boolean process(T image){
  configureContourDetector(image);
  binary.reshape(image.width,image.height);
  inputToBinary.process(image,binary);
  detectorSquare.process(image,binary);
  detectorSquare.refineAll();
  detectorSquare.getPolygons(found);
  clusters=s2c.process(found);
  c2g.process(clusters);
  List<SquareGrid> grids=c2g.getGrids();
  SquareGrid match=null;
  double matchSize=0;
  for (  SquareGrid g : grids) {
    if (g.columns != numCols || g.rows != numRows) {
      if (g.columns == numRows && g.rows == numCols) {
        tools.transpose(g);
      }
 else {
        continue;
      }
    }
    double size=tools.computeSize(g);
    if (size > matchSize) {
      matchSize=size;
      match=g;
    }
  }
  if (match != null) {
    if (tools.checkFlip(match)) {
      tools.flipRows(match);
    }
    tools.putIntoCanonical(match);
    if (!tools.orderSquareCorners(match))     return false;
    extractCalibrationPoints(match);
    return true;
  }
  return false;
}","/** 
 * Process the image and detect the calibration target
 * @param image Input image
 * @return true if a calibration target was found and false if not
 */
public boolean process(T image){
  configureContourDetector(image);
  binary.reshape(image.width,image.height);
  inputToBinary.process(image,binary);
  detectorSquare.process(image,binary);
  detectorSquare.refineAll();
  detectorSquare.getPolygons(found,null);
  clusters=s2c.process(found);
  c2g.process(clusters);
  List<SquareGrid> grids=c2g.getGrids();
  SquareGrid match=null;
  double matchSize=0;
  for (  SquareGrid g : grids) {
    if (g.columns != numCols || g.rows != numRows) {
      if (g.columns == numRows && g.rows == numCols) {
        tools.transpose(g);
      }
 else {
        continue;
      }
    }
    double size=tools.computeSize(g);
    if (size > matchSize) {
      matchSize=size;
      match=g;
    }
  }
  if (match != null) {
    if (tools.checkFlip(match)) {
      tools.flipRows(match);
    }
    tools.putIntoCanonical(match);
    if (!tools.orderSquareCorners(match))     return false;
    extractCalibrationPoints(match);
    return true;
  }
  return false;
}",0.9978364344439636
150653,"/** 
 * Examines the input image to detect fiducials inside of it
 * @param gray Undistorted input image
 */
public void process(T gray){
  configureContourDetector(gray);
  binary.reshape(gray.width,gray.height);
  inputToBinary.process(gray,binary);
  squareDetector.process(gray,binary);
  squareDetector.refineAll();
  squareDetector.getPolygons(candidates);
  found.reset();
  if (verbose)   System.out.println(""String_Node_Str"" + candidates.size());
  for (int i=0; i < candidates.size(); i++) {
    Polygon2D_F64 p=candidates.get(i);
    if (!checkSideSize(p)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    double best=Double.MAX_VALUE;
    for (int j=0; j < 4; j++) {
      double found=p.get(0).normSq();
      if (found < best) {
        best=found;
        interpolationHack.set(p);
      }
      UtilPolygons2D_F64.shiftDown(p);
    }
    UtilPolygons2D_F64.convert(interpolationHack,q);
    pairsRemovePerspective.get(0).set(0,0,q.a.x,q.a.y);
    pairsRemovePerspective.get(1).set(square.width,0,q.b.x,q.b.y);
    pairsRemovePerspective.get(2).set(square.width,square.height,q.c.x,q.c.y);
    pairsRemovePerspective.get(3).set(0,square.height,q.d.x,q.d.y);
    if (!computeHomography.process(pairsRemovePerspective,H)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    if (!refineHomography.fitModel(pairsRemovePerspective,H,H_refined)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    ConvertDMatrixStruct.convert(H_refined,H_fixed);
    ConvertFloatType.convert(H_fixed,transformHomography.getModel());
    removePerspective.apply(gray,square);
    DetectPolygonFromContour.Info info=squareDetector.getPolygonInfo().get(i);
    if (minimumBorderBlackFraction > 0) {
      double pixelThreshold=(info.edgeInside + info.edgeOutside) / 2;
      double foundFraction=computeFractionBoundary((float)pixelThreshold);
      if (foundFraction < minimumBorderBlackFraction) {
        if (verbose)         System.out.println(""String_Node_Str"" + foundFraction);
        continue;
      }
    }
    if (processSquare(square,result,info.edgeInside,info.edgeOutside)) {
      prepareForOutput(q,result);
      if (verbose)       System.out.println(""String_Node_Str"");
    }
 else {
      if (verbose)       System.out.println(""String_Node_Str"");
    }
  }
}","/** 
 * Examines the input image to detect fiducials inside of it
 * @param gray Undistorted input image
 */
public void process(T gray){
  configureContourDetector(gray);
  binary.reshape(gray.width,gray.height);
  inputToBinary.process(gray,binary);
  squareDetector.process(gray,binary);
  squareDetector.refineAll();
  squareDetector.getPolygons(candidates,candidatesInfo);
  found.reset();
  if (verbose)   System.out.println(""String_Node_Str"" + candidates.size());
  for (int i=0; i < candidates.size(); i++) {
    Polygon2D_F64 p=candidates.get(i);
    if (!checkSideSize(p)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    double best=Double.MAX_VALUE;
    for (int j=0; j < 4; j++) {
      double found=p.get(0).normSq();
      if (found < best) {
        best=found;
        interpolationHack.set(p);
      }
      UtilPolygons2D_F64.shiftDown(p);
    }
    UtilPolygons2D_F64.convert(interpolationHack,q);
    pairsRemovePerspective.get(0).set(0,0,q.a.x,q.a.y);
    pairsRemovePerspective.get(1).set(square.width,0,q.b.x,q.b.y);
    pairsRemovePerspective.get(2).set(square.width,square.height,q.c.x,q.c.y);
    pairsRemovePerspective.get(3).set(0,square.height,q.d.x,q.d.y);
    if (!computeHomography.process(pairsRemovePerspective,H)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    if (!refineHomography.fitModel(pairsRemovePerspective,H,H_refined)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    ConvertDMatrixStruct.convert(H_refined,H_fixed);
    ConvertFloatType.convert(H_fixed,transformHomography.getModel());
    removePerspective.apply(gray,square);
    DetectPolygonFromContour.Info info=candidatesInfo.get(i);
    if (minimumBorderBlackFraction > 0) {
      double pixelThreshold=(info.edgeInside + info.edgeOutside) / 2;
      double foundFraction=computeFractionBoundary((float)pixelThreshold);
      if (foundFraction < minimumBorderBlackFraction) {
        if (verbose)         System.out.println(""String_Node_Str"" + foundFraction);
        continue;
      }
    }
    if (processSquare(square,result,info.edgeInside,info.edgeOutside)) {
      prepareForOutput(q,result);
      if (verbose)       System.out.println(""String_Node_Str"");
    }
 else {
      if (verbose)       System.out.println(""String_Node_Str"");
    }
  }
}",0.9891122278056952
150654,"@Test public void computePotentialSplitScore(){
  PolylineSplitMerge alg=new PolylineSplitMerge();
  alg.setMinimumSideLength(5);
  alg.setThresholdSideSplitScore(0);
  List<Point2D_I32> contour=new ArrayList<>();
  for (int i=0; i < 20; i++) {
    contour.add(new Point2D_I32(i,0));
  }
  contour.get(3).y=5;
  contour.get(15).y=5;
  contour.get(10).y=20;
  alg.addCorner(0);
  alg.addCorner(19);
  Element<Corner> e=alg.list.getHead();
  e.object.sideError=20;
  alg.computePotentialSplitScore(contour,e);
  assertTrue(e.object.splitable);
  assertTrue(e.object.splitError0 > 0);
  assertTrue(e.object.splitError1 > 0);
  assertEquals(10,e.object.splitLocation);
}","@Test public void computePotentialSplitScore(){
  PolylineSplitMerge alg=new PolylineSplitMerge();
  alg.setMinimumSideLength(5);
  alg.setThresholdSideSplitScore(0);
  List<Point2D_I32> contour=new ArrayList<>();
  for (int i=0; i < 20; i++) {
    contour.add(new Point2D_I32(i,0));
  }
  contour.get(3).y=5;
  contour.get(15).y=5;
  contour.get(10).y=20;
  alg.addCorner(0);
  alg.addCorner(19);
  Element<Corner> e=alg.list.getHead();
  e.object.sideError=20;
  alg.computePotentialSplitScore(contour,e,false);
  assertTrue(e.object.splitable);
  assertTrue(e.object.splitError0 > 0);
  assertTrue(e.object.splitError1 > 0);
  assertEquals(10,e.object.splitLocation);
}",0.9955156950672646
150655,"/** 
 * Computes the error locator polynomial using  Berlekamp-Massey algorithm [1] <p>[1] Massey, J. L. (1969), ""Shift-register synthesis and BCH decoding"" (PDF), IEEE Trans. Information Theory, IT-15 (1): 122–127</p>
 * @param syndromes (Input) The syndromes
 * @param errorLocator (Output) Error locator polynomial. Coefficients are large to small.
 */
void findErrorLocatorPolynomialBM(GrowQueue_I8 syndromes,GrowQueue_I8 errorLocator){
  GrowQueue_I8 C=errorLocator;
  GrowQueue_I8 B=new GrowQueue_I8();
  initToOne(C,syndromes.size + 1);
  initToOne(B,syndromes.size + 1);
  GrowQueue_I8 tmp=new GrowQueue_I8(syndromes.size);
  int b=1;
  for (int n=0; n < syndromes.size; n++) {
    int delta=syndromes.data[n] & 0xFF;
    for (int j=1; j < C.size; j++) {
      delta^=math.multiply(C.data[C.size - j - 1] & 0xFF,syndromes.data[n - j] & 0xFF);
    }
    B.data[B.size++]=0;
    if (delta != 0) {
      int scale=math.multiply(delta,math.inverse(b));
      math.polyAddScaleB(C,B,scale,tmp);
      if (2 * C.size > syndromes.size) {
      }
 else {
        B.setTo(C);
        b=delta;
      }
      C.setTo(tmp);
    }
  }
  removeLeadingZeros(C);
}","/** 
 * Computes the error locator polynomial using  Berlekamp-Massey algorithm [1] <p>[1] Massey, J. L. (1969), ""Shift-register synthesis and BCH decoding"" (PDF), IEEE Trans. Information Theory, IT-15 (1): 122–127</p>
 * @param syndromes (Input) The syndromes
 * @param errorLocator (Output) Error locator polynomial. Coefficients are large to small.
 */
void findErrorLocatorPolynomialBM(GrowQueue_I8 syndromes,GrowQueue_I8 errorLocator){
  GrowQueue_I8 C=errorLocator;
  GrowQueue_I8 B=new GrowQueue_I8();
  initToOne(C,syndromes.size + 1);
  initToOne(B,syndromes.size + 1);
  GrowQueue_I8 tmp=new GrowQueue_I8(syndromes.size);
  int b=1;
  for (int n=0; n < syndromes.size; n++) {
    int delta=syndromes.data[n] & 0xFF;
    for (int j=1; j < C.size; j++) {
      delta^=math.multiply(C.data[C.size - j - 1] & 0xFF,syndromes.data[n - j] & 0xFF);
    }
    B.data[B.size++]=0;
    if (delta != 0) {
      int scale=math.multiply(delta,math.inverse(b));
      math.polyAddScaleB(C,B,scale,tmp);
      if (B.size <= C.size) {
      }
 else {
        B.setTo(C);
        b=delta;
      }
      C.setTo(tmp);
    }
  }
  removeLeadingZeros(C);
}",0.9908735332464146
150656,"/** 
 * Randomly correct the message and ECC. See if the message is correctly reconstructed.
 */
@Test public void correctErrors_random(){
  GrowQueue_I8 ecc=new GrowQueue_I8();
  GrowQueue_I8 syndromes=new GrowQueue_I8();
  GrowQueue_I8 errorLocator=new GrowQueue_I8();
  GrowQueue_I32 locations=new GrowQueue_I32();
  int nsyn=10;
  ReidSolomonCodes alg=new ReidSolomonCodes(8,primitive8);
  alg.generator(nsyn);
  for (int i=0; i < 2000; i++) {
    GrowQueue_I8 message=randomMessage(100);
    GrowQueue_I8 corrupted=message.copy();
    int numErrors=4;
    int eccErrors=0;
    for (int j=0; j < numErrors; j++) {
      int selected=rand.nextInt(message.size);
      corrupted.data[selected]^=(0x12 + j);
    }
    alg.computeECC(message,ecc);
    int N=message.size + ecc.size;
    alg.computeSyndromes(corrupted,ecc,syndromes);
    alg.findErrorLocatorPolynomialBM(syndromes,errorLocator);
    if (!alg.findErrorLocations_BruteForce(errorLocator,N,locations)) {
      fail(""String_Node_Str"" + numErrors + ""String_Node_Str""+ eccErrors);
    }
    alg.correctErrors(corrupted,N,syndromes,errorLocator,locations);
    assertEquals(corrupted.size,message.size);
    for (int j=0; j < corrupted.size; j++) {
      assertEquals(corrupted.get(j),message.get(j));
    }
  }
}","/** 
 * Randomly correct the message and ECC. See if the message is correctly reconstructed.
 */
@Test public void correctErrors_random(){
  GrowQueue_I8 ecc=new GrowQueue_I8();
  GrowQueue_I8 syndromes=new GrowQueue_I8();
  GrowQueue_I8 errorLocator=new GrowQueue_I8();
  GrowQueue_I32 locations=new GrowQueue_I32();
  int nsyn=10;
  ReidSolomonCodes alg=new ReidSolomonCodes(8,primitive8);
  alg.generator(nsyn);
  for (int i=0; i < 20000; i++) {
    GrowQueue_I8 message=randomMessage(10);
    GrowQueue_I8 corrupted=message.copy();
    alg.computeECC(message,ecc);
    int numErrors=rand.nextInt(6);
    int eccErrors=0;
    for (int j=0; j < numErrors; j++) {
      int selected=rand.nextInt(message.size);
      corrupted.data[selected]^=(0x12 + j);
    }
    if (numErrors < 5 && rand.nextInt(5) < 1) {
      numErrors++;
      ecc.data[rand.nextInt(ecc.size)]^=0x13;
    }
    int N=message.size + ecc.size;
    alg.computeSyndromes(corrupted,ecc,syndromes);
    alg.findErrorLocatorPolynomialBM(syndromes,errorLocator);
    if (!alg.findErrorLocations_BruteForce(errorLocator,N,locations)) {
      message.printHex();
      System.out.println();
      corrupted.printHex();
      fail(""String_Node_Str"" + numErrors + ""String_Node_Str""+ eccErrors);
    }
    alg.correctErrors(corrupted,N,syndromes,errorLocator,locations);
    assertEquals(corrupted.size,message.size);
    for (int j=0; j < corrupted.size; j++) {
      assertEquals(corrupted.get(j),message.get(j));
    }
  }
}",0.8917059036580949
150657,"/** 
 * Computes the split location and the score of the two new sides if it's split there
 */
void computePotentialSplitScore(List<Point2D_I32> contour,LinkedList.Element<Corner> e0){
  LinkedList.Element<Corner> e1=next(e0);
  e0.object.splitable=canBeSplit(contour,e0);
  if (e0.object.splitable) {
    splitter.selectSplitPoint(contour,e0.object.index,e1.object.index,resultsA);
    e0.object.splitLocation=resultsA.index;
    e0.object.splitScore0=scoreSide(contour,e0.object.index,resultsA.index);
    e0.object.splitScore1=scoreSide(contour,resultsA.index,e1.object.index);
  }
}","/** 
 * Computes the split location and the score of the two new sides if it's split there
 */
void computePotentialSplitScore(List<Point2D_I32> contour,LinkedList.Element<Corner> e0){
  LinkedList.Element<Corner> e1=next(e0);
  e0.object.splitable=canBeSplit(contour.size(),e0);
  if (e0.object.splitable) {
    splitter.selectSplitPoint(contour,e0.object.index,e1.object.index,resultsA);
    e0.object.splitLocation=resultsA.index;
    e0.object.splitScore0=computeSideError(contour,e0.object.index,resultsA.index);
    e0.object.splitScore1=computeSideError(contour,resultsA.index,e1.object.index);
  }
}",0.9522212908633696
150658,"/** 
 * See if removing a corner will improve the overall score. If it will remove the score remove the corner (merging two sides)
 * @param contour Shape's contour
 * @param target The corner which is to be removed
 * @param scoreCurrent Score of the current polygon
 */
private void considerAndRemoveCorner(List<Point2D_I32> contour,LinkedList.Element<Corner> target,double scoreCurrent){
  LinkedList.Element<Corner> p=previous(target);
  LinkedList.Element<Corner> n=next(target);
  double sumSides=0;
  LinkedList.Element<Corner> e=list.getHead();
  while (e != null) {
    sumSides+=e.object.sideScore;
    e=e.next;
  }
  sumSides-=target.object.sideScore + p.object.sideScore;
  double scoreNewSide=scoreSide(contour,p.object.index,n.object.index);
  sumSides+=scoreNewSide;
  double scoreNoCorner=sumSides / (list.size() - 1) + cornerScorePenalty * (list.size() - 1);
  if (scoreNoCorner < scoreCurrent) {
    list.remove(target);
    p.object.splitLocation=target.object.index;
    p.object.splitScore0=target.object.sideScore;
    p.object.splitScore1=n.object.sideScore;
    p.object.sideScore=scoreNewSide;
    savePolyline();
  }
}","/** 
 * See if removing a corner will improve the overall score. If it will remove the score remove the corner (merging two sides)
 * @param contour Shape's contour
 * @param target The corner which is to be removed
 * @param scoreCurrent Score of the current polygon
 */
private void considerAndRemoveCorner(List<Point2D_I32> contour,LinkedList.Element<Corner> target,double scoreCurrent){
  LinkedList.Element<Corner> p=previous(target);
  LinkedList.Element<Corner> n=next(target);
  double sumSides=0;
  LinkedList.Element<Corner> e=list.getHead();
  while (e != null) {
    sumSides+=e.object.sideScore;
    e=e.next;
  }
  sumSides-=target.object.sideScore + p.object.sideScore;
  double scoreNewSide=computeSideError(contour,p.object.index,n.object.index);
  sumSides+=scoreNewSide;
  double scoreNoCorner=sumSides / (list.size() - 1) + cornerScorePenalty * (list.size() - 1);
  if (scoreNoCorner < scoreCurrent) {
    list.remove(target);
    p.object.splitLocation=target.object.index;
    p.object.splitScore0=target.object.sideScore;
    p.object.splitScore1=n.object.sideScore;
    p.object.sideScore=scoreNewSide;
    savePolyline();
  }
}",0.9891162385720506
150659,"private boolean findInitialTriangle(List<Point2D_I32> contour){
  int cornerSeed=findCornerSeed(contour);
  if (convex) {
    if (!sanityCheckConvex(contour,0,cornerSeed))     return false;
  }
  splitter.selectSplitPoint(contour,0,cornerSeed,resultsA);
  splitter.selectSplitPoint(contour,cornerSeed,0,resultsB);
  if (splitter.compareScore(resultsA.score,resultsB.score) >= 0) {
    addCorner(resultsA.index);
    addCorner(cornerSeed);
  }
 else {
    addCorner(cornerSeed);
    addCorner(resultsA.index);
  }
  int index0=list.getHead().object.index;
  int index1=list.getHead().next.object.index;
  splitter.selectSplitPoint(contour,index0,index1,resultsA);
  addCorner(resultsA.index);
  LinkedList.Element<Corner> e=list.getHead();
  while (e != null) {
    LinkedList.Element<Corner> n=e.next;
    double score;
    if (n == null) {
      score=scoreSide(contour,e.object.index,list.getHead().object.index);
    }
 else {
      score=scoreSide(contour,e.object.index,n.object.index);
    }
    e.object.sideScore=score;
    e=n;
  }
  e=list.getHead();
  while (e != null) {
    computePotentialSplitScore(contour,e);
    e=e.next;
  }
  return true;
}","private boolean findInitialTriangle(List<Point2D_I32> contour){
  int cornerSeed=findCornerSeed(contour);
  if (convex) {
    if (!sanityCheckConvex(contour,0,cornerSeed))     return false;
  }
  splitter.selectSplitPoint(contour,0,cornerSeed,resultsA);
  splitter.selectSplitPoint(contour,cornerSeed,0,resultsB);
  if (splitter.compareScore(resultsA.score,resultsB.score) >= 0) {
    addCorner(resultsA.index);
    addCorner(cornerSeed);
  }
 else {
    addCorner(cornerSeed);
    addCorner(resultsA.index);
  }
  int index0=list.getHead().object.index;
  int index1=list.getHead().next.object.index;
  splitter.selectSplitPoint(contour,index0,index1,resultsA);
  addCorner(resultsA.index);
  LinkedList.Element<Corner> e=list.getHead();
  while (e != null) {
    LinkedList.Element<Corner> n=e.next;
    double score;
    if (n == null) {
      score=computeSideError(contour,e.object.index,list.getHead().object.index);
    }
 else {
      score=computeSideError(contour,e.object.index,n.object.index);
    }
    e.object.sideScore=score;
    e=n;
  }
  e=list.getHead();
  while (e != null) {
    computePotentialSplitScore(contour,e);
    e=e.next;
  }
  return true;
}",0.9785775492716366
150660,"public static void assignLine(List<Point2D_I32> contour,int indexA,int indexB,LineParametric2D_F64 line){
  Point2D_I32 endA=contour.get(indexA);
  Point2D_I32 endB=contour.get(indexB);
  line.p.x=endA.x;
  line.p.y=endA.y;
  line.slope.x=endB.x - endA.x;
  line.slope.y=endB.y - endA.y;
}","/** 
 * Assigns the line so that it passes through points A and B.
 */
public static void assignLine(List<Point2D_I32> contour,int indexA,int indexB,LineParametric2D_F64 line){
  Point2D_I32 endA=contour.get(indexA);
  Point2D_I32 endB=contour.get(indexB);
  line.p.x=endA.x;
  line.p.y=endA.y;
  line.slope.x=endB.x - endA.x;
  line.slope.y=endB.y - endA.y;
}",0.8906009244992296
150661,"/** 
 * For convex shapes no point along the contour can be farther away from A is from B. Thus the maximum number of points can't exceed a 1/2 circle. NOTE: indexA is probably the top left point in the contour, since that's how most contour algorithm scan but this isn't known for sure. If it was known you could make this requirement tighter.
 * @param contour Contour points
 * @param indexA index of first point
 * @param indexB index of second point
 * @return if it passes the sanity check
 */
static boolean sanityCheckConvex(List<Point2D_I32> contour,int indexA,int indexB){
  double d=Math.sqrt(distanceSq(contour.get(indexA),contour.get(indexB)));
  int maxAllowed=(int)(2 * Math.PI * d + 0.5);
  if (indexB - indexA > maxAllowed)   return false;
  if (indexA + contour.size() - indexB > maxAllowed)   return false;
  return true;
}","/** 
 * For convex shapes no point along the contour can be farther away from A is from B. Thus the maximum number of points can't exceed a 1/2 circle. NOTE: indexA is probably the top left point in the contour, since that's how most contour algorithm scan but this isn't known for sure. If it was known you could make this requirement tighter.
 * @param contour Contour points
 * @param indexA index of first point
 * @param indexB index of second point
 * @return if it passes the sanity check
 */
static boolean sanityCheckConvex(List<Point2D_I32> contour,int indexA,int indexB){
  double d=Math.sqrt(distanceSq(contour.get(indexA),contour.get(indexB)));
  int maxAllowed=(int)(2 * Math.PI * d + 0.5);
  if (indexA > indexB) {
    int tmp=indexA;
    indexA=indexB;
    indexB=tmp;
  }
  if (indexB - indexA > maxAllowed)   return false;
  if (indexA + contour.size() - indexB > maxAllowed)   return false;
  return true;
}",0.9524886877828054
150662,"private void addCorner(int where){
  Corner c=corners.grow();
  c.index=where;
  list.pushTail(c);
}","void addCorner(int where){
  Corner c=corners.grow();
  c.index=where;
  list.pushTail(c);
}",0.9583333333333334
150663,"/** 
 * Determines if the side can be split again
 */
boolean canBeSplit(List<Point2D_I32> contour,LinkedList.Element<Corner> e0){
  LinkedList.Element<Corner> e1=next(e0);
  int length=CircularIndex.distance(e0.object.index,e1.object.index,contour.size());
  if (length < minimumSideLength) {
    return false;
  }
  return !(e0.object.sideScore <= perfectSideScore);
}","/** 
 * Determines if the side can be split again. A side can always be split as long as its >= the minimum length or that the side score is larger the the split threshold
 */
boolean canBeSplit(int contourSize,LinkedList.Element<Corner> e0){
  LinkedList.Element<Corner> e1=next(e0);
  int length=CircularIndex.distance(e0.object.index,e1.object.index,contourSize);
  if (length < minimumSideLength) {
    return false;
  }
  return !(e0.object.sideScore < thresholdSideSplitScore);
}",0.7695906432748538
150664,"protected void handleDirectory(){
  final CalibrateMonoPlanar calibrationAlg=new CalibrateMonoPlanar(detector);
  final CalibratedPlanarPanel gui;
switch (modeType) {
case PINHOLE:
    calibrationAlg.configurePinhole(zeroSkew,numRadial,tangential);
  gui=new MonoPlanarPanel();
break;
case UNIVERSAL:
calibrationAlg.configureUniversalOmni(zeroSkew,numRadial,tangential);
gui=new FisheyePlanarPanel();
break;
default :
throw new RuntimeException(""String_Node_Str"" + modeType);
}
File directory=new File(inputDirectory);
if (!directory.exists()) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + inputDirectory);
System.exit(0);
}
List<File> files=Arrays.asList(directory.listFiles());
Collections.sort(files);
if (files.isEmpty()) {
System.err.println(""String_Node_Str"");
System.err.println(inputDirectory);
System.exit(0);
}
boolean first=true;
for (File f : files) {
if (f.isDirectory() || f.isHidden()) continue;
BufferedImage buffered=UtilImageIO.loadImage(f.getPath());
if (buffered == null) continue;
GrayF32 image=ConvertBufferedImage.convertFrom(buffered,(GrayF32)null);
if (gui != null) {
gui.addImage(f);
if (first) {
first=false;
ShowImages.showWindow(gui,""String_Node_Str"",true);
}
}
if (!calibrationAlg.addImage(image)) System.err.println(""String_Node_Str"" + f.getName());
}
final CameraModel intrinsic=calibrationAlg.process();
if (gui != null) {
SwingUtilities.invokeLater(new Runnable(){
public void run(){
gui.setObservations(calibrationAlg.getObservations());
gui.setResults(calibrationAlg.getErrors());
gui.setCalibration(calibrationAlg.getZhangParam());
gui.setCorrection(intrinsic);
gui.repaint();
}
}
);
}
calibrationAlg.printStatistics();
System.out.println();
System.out.println(""String_Node_Str"" + modeType + ""String_Node_Str"");
System.out.println();
switch (modeType) {
case PINHOLE:
{
CameraPinholeRadial m=(CameraPinholeRadial)intrinsic;
switch (formatType) {
case BOOFCV:
CalibrationIO.save(m,outputFileName);
break;
case OPENCV:
UtilOpenCV.save(m,outputFileName);
break;
}
m.print();
}
break;
case UNIVERSAL:
{
CameraUniversalOmni m=(CameraUniversalOmni)intrinsic;
CalibrationIO.save(m,outputFileName);
m.print();
}
break;
default :
throw new RuntimeException(""String_Node_Str"" + modeType);
}
System.out.println();
System.out.println(""String_Node_Str"" + formatType);
System.out.println();
}","protected void handleDirectory(){
}",0.0293624161073825
150665,"public void parse(String[] args){
  if (args.length < 1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  cameraId=-1;
  for (int i=0; i < args.length; i++) {
    String arg=args[i];
    if (arg.startsWith(""String_Node_Str"")) {
      if (!checkCameraFlag(arg)) {
        splitFlag(arg);
        if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          inputDirectory=parameters;
          inputType=InputType.IMAGE;
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          visualize=Boolean.parseBoolean(parameters);
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            modeType=ModelType.PINHOLE;
          }
 else           if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            modeType=ModelType.UNIVERSAL;
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + parameters);
          }
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            formatType=FormatType.BOOFCV;
          }
 else           if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            formatType=FormatType.OPENCV;
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + parameters);
          }
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          zeroSkew=Boolean.parseBoolean(parameters);
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          numRadial=Integer.parseInt(parameters);
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          tangential=Boolean.parseBoolean(parameters);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + flagName);
        }
      }
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseChessboard(i + 1,args);
      break;
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseSquareGrid(i + 1,args);
      break;
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseCircle(i + 1,args,true);
      break;
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseCircle(i + 1,args,false);
      break;
    }
 else     if (i == 0) {
      outputFileName=arg;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + arg);
    }
  }
  if (visualize && modeType != ModelType.PINHOLE) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (formatType == FormatType.OPENCV && modeType != ModelType.PINHOLE) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public void parse(String[] args){
  if (args.length < 1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  cameraId=-1;
  for (int i=0; i < args.length; i++) {
    String arg=args[i];
    if (arg.startsWith(""String_Node_Str"")) {
      if (!checkCameraFlag(arg)) {
        splitFlag(arg);
        if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          inputDirectory=parameters;
          inputType=InputType.IMAGE;
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          visualize=Boolean.parseBoolean(parameters);
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            modeType=ModelType.PINHOLE;
          }
 else           if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            modeType=ModelType.UNIVERSAL;
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + parameters);
          }
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            formatType=FormatType.BOOFCV;
          }
 else           if (parameters.compareToIgnoreCase(""String_Node_Str"") == 0) {
            formatType=FormatType.OPENCV;
          }
 else {
            throw new RuntimeException(""String_Node_Str"" + parameters);
          }
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          zeroSkew=Boolean.parseBoolean(parameters);
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          numRadial=Integer.parseInt(parameters);
        }
 else         if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
          tangential=Boolean.parseBoolean(parameters);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + flagName);
        }
      }
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseChessboard(i + 1,args);
      break;
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseSquareGrid(i + 1,args);
      break;
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseCircle(i + 1,args,true);
      break;
    }
 else     if (arg.compareToIgnoreCase(""String_Node_Str"") == 0) {
      parseCircle(i + 1,args,false);
      break;
    }
 else     if (i == 0) {
      outputFileName=arg;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + arg);
    }
  }
  if (formatType == FormatType.OPENCV && modeType != ModelType.PINHOLE) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9693674098241798
150666,"/** 
 * Takes the detected squares and turns it into a list of   {@link PositionPatternNode}.
 */
private void squaresToPositionList(){
  this.positionPatterns.reset();
  List<DetectPolygonFromContour.Info> infoList=squareDetector.getPolygonInfo();
  for (int i=0; i < infoList.size(); i++) {
    DetectPolygonFromContour.Info info=infoList.get(i);
    if (info.hasInternal())     continue;
    double grayThreshold=(info.edgeInside + info.edgeOutside) / 2;
    if (!checkPositionPatternAppearance(info.polygon,(float)grayThreshold))     continue;
    squareDetector.refine(info);
    PositionPatternNode pp=this.positionPatterns.grow();
    pp.reset();
    pp.square=info.polygon;
    pp.grayThreshold=grayThreshold;
    graph.computeNodeInfo(pp);
  }
}","/** 
 * Takes the detected squares and turns it into a list of   {@link PositionPatternNode}.
 */
private void squaresToPositionList(){
  this.positionPatterns.reset();
  List<DetectPolygonFromContour.Info> infoList=squareDetector.getPolygonInfo();
  for (int i=0; i < infoList.size(); i++) {
    DetectPolygonFromContour.Info info=infoList.get(i);
    if (!info.hasInternal())     continue;
    double grayThreshold=(info.edgeInside + info.edgeOutside) / 2;
    if (!checkPositionPatternAppearance(info.polygon,(float)grayThreshold))     continue;
    squareDetector.refine(info);
    PositionPatternNode pp=this.positionPatterns.grow();
    pp.reset();
    pp.square=info.polygon;
    pp.grayThreshold=grayThreshold;
    graph.computeNodeInfo(pp);
  }
}",0.9993373094764744
150667,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      List<Contour> contours=detector.getSquareDetector().getAllContours();
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (true) {
      FastQueue<QrCode> detected=detector.getDetections();
      g2.setColor(new Color(0x90FF0000,true));
      for (int i=0; i < detected.size; i++) {
        QrCode qr=detected.get(i);
        VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
      }
    }
    if (controls.bShowSquares) {
      List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null);
      g2.setColor(Color.GREEN);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowPositionPattern) {
      FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
      g2.setColor(Color.ORANGE);
      g2.setStroke(new BasicStroke(3));
      List<SquareEdge> list=new ArrayList<>();
      for (int i=0; i < nodes.size(); i++) {
        SquareNode n=nodes.get(i);
        VisualizeShapes.drawPolygon(n.square,true,scale,g2);
        for (int j=0; j < 4; j++) {
          if (n.edges[j] != null) {
            if (!list.contains(n.edges[j])) {
              list.add(n.edges[j]);
            }
          }
        }
      }
      g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
      g2.setColor(new Color(255,150,100));
      g2.setStroke(new BasicStroke(3));
      Line2D.Double l=new Line2D.Double();
      for (int i=0; i < list.size(); i++) {
        SquareEdge e=list.get(i);
        Point2D_F64 a=e.a.center;
        Point2D_F64 b=e.b.center;
        l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
        g2.draw(l);
      }
    }
  }
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectQrCodeControlPanel controls=(DetectQrCodeControlPanel)DetectQrCodeApp.this.controls;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (DetectQrCodeApp.this) {
    if (controls.bShowContour) {
      List<Contour> contours=detector.getSquareDetector().getAllContours();
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (true) {
      FastQueue<QrCode> detected=detector.getDetections();
      g2.setColor(new Color(0x50FF0000,true));
      for (int i=0; i < detected.size; i++) {
        QrCode qr=detected.get(i);
        VisualizeShapes.fillPolygon(qr.bounds,scale,g2);
      }
    }
    if (controls.bShowSquares) {
      List<Polygon2D_F64> polygons=detector.getSquareDetector().getPolygons(null);
      g2.setColor(Color.GREEN);
      g2.setStroke(new BasicStroke(3));
      for (      Polygon2D_F64 p : polygons) {
        VisualizeShapes.drawPolygon(p,true,scale,g2);
      }
    }
    if (controls.bShowAlignmentPattern) {
      List<QrCode> codes=detector.getDetections().toList();
      g2.setColor(Color.BLUE);
      g2.setStroke(new BasicStroke(3));
      for (      QrCode qr : codes) {
        double size=Math.sqrt(qr.ppCorner.areaSimple()) / 14.0;
        for (int i=0; i < qr.alignment.size; i++) {
          QrCode.Alignment a=qr.alignment.get(i);
          VisualizeFeatures.drawCircle(g2,a.pixel.x * scale,a.pixel.y * scale,size * scale);
        }
      }
    }
    if (controls.bShowPositionPattern) {
      FastQueue<PositionPatternNode> nodes=detector.getDetectPositionPatterns().getPositionPatterns();
      g2.setColor(Color.ORANGE);
      g2.setStroke(new BasicStroke(3));
      List<SquareEdge> list=new ArrayList<>();
      for (int i=0; i < nodes.size(); i++) {
        SquareNode n=nodes.get(i);
        VisualizeShapes.drawPolygon(n.square,true,scale,g2);
        for (int j=0; j < 4; j++) {
          if (n.edges[j] != null) {
            if (!list.contains(n.edges[j])) {
              list.add(n.edges[j]);
            }
          }
        }
      }
      g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
      g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
      g2.setColor(new Color(255,150,100));
      g2.setStroke(new BasicStroke(3));
      Line2D.Double l=new Line2D.Double();
      for (int i=0; i < list.size(); i++) {
        SquareEdge e=list.get(i);
        Point2D_F64 a=e.a.center;
        Point2D_F64 b=e.b.center;
        l.setLine(scale * a.x,scale * a.y,scale * b.x,scale * b.y);
        g2.draw(l);
      }
    }
  }
}",0.9048349961627016
150668,"public DetectQrCodeApp(List<String> examples,Class<T> imageType){
  super(examples,imageType);
  setupGui(new VisualizePanel(),new DetectQrCodeControlPanel(this));
}","public DetectQrCodeApp(List<String> examples,Class<T> imageType){
  super(examples,imageType);
  final VisualizePanel gui=new VisualizePanel();
  setupGui(gui,new DetectQrCodeControlPanel(this));
  gui.getImagePanel().addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      double scale=gui.getScale();
      System.out.printf(""String_Node_Str"",e.getX() / scale,e.getY() / scale);
    }
  }
);
}",0.3900826446280991
150669,"@Override public void actionPerformed(ActionEvent e){
  if (e.getSource() == imageView) {
    selectedView=imageView.getSelectedIndex();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showSquares) {
    bShowSquares=showSquares.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showPositionPattern) {
    bShowPositionPattern=showPositionPattern.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showContour) {
    bShowContour=showContour.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == setBorder) {
    config.polygon.detector.canTouchBorder=setBorder.isSelected();
    owner.configUpdate();
  }
 else   if (e.getSource() == setRefineContour) {
    config.polygon.refineContour=setRefineContour.isSelected();
    owner.configUpdate();
  }
 else   if (e.getSource() == setRefineGray) {
    bRefineGray=setRefineGray.isSelected();
    owner.configUpdate();
  }
 else   if (e.getSource() == setRemoveBias) {
    config.polygon.adjustForThresholdBias=setRemoveBias.isSelected();
    owner.configUpdate();
  }
}","@Override public void actionPerformed(ActionEvent e){
  if (e.getSource() == imageView) {
    selectedView=imageView.getSelectedIndex();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showSquares) {
    bShowSquares=showSquares.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showPositionPattern) {
    bShowPositionPattern=showPositionPattern.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showAlignmentPattern) {
    bShowAlignmentPattern=showAlignmentPattern.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == showContour) {
    bShowContour=showContour.isSelected();
    owner.viewUpdated();
  }
 else   if (e.getSource() == setBorder) {
    config.polygon.detector.canTouchBorder=setBorder.isSelected();
    owner.configUpdate();
  }
 else   if (e.getSource() == setRefineContour) {
    config.polygon.refineContour=setRefineContour.isSelected();
    owner.configUpdate();
  }
 else   if (e.getSource() == setRefineGray) {
    bRefineGray=setRefineGray.isSelected();
    owner.configUpdate();
  }
 else   if (e.getSource() == setRemoveBias) {
    config.polygon.adjustForThresholdBias=setRemoveBias.isSelected();
    owner.configUpdate();
  }
}",0.8062149331031506
150670,"public DetectQrCodeControlPanel(DetectQrCodeApp owner){
  this.owner=owner;
  bRunAgain.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent actionEvent){
      DetectQrCodeControlPanel.this.owner.reprocessImageOnly();
    }
  }
);
  imageView=new JComboBox();
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addActionListener(this);
  imageView.setMaximumSize(imageView.getPreferredSize());
  selectZoom=new JSpinner(new SpinnerNumberModel(1,MIN_ZOOM,MAX_ZOOM,1));
  selectZoom.addChangeListener(this);
  selectZoom.setMaximumSize(selectZoom.getPreferredSize());
  showSquares=new JCheckBox(""String_Node_Str"");
  showSquares.addActionListener(this);
  showSquares.setSelected(bShowSquares);
  showPositionPattern=new JCheckBox(""String_Node_Str"");
  showPositionPattern.setSelected(bShowPositionPattern);
  showPositionPattern.addActionListener(this);
  showContour=new JCheckBox(""String_Node_Str"");
  showContour.addActionListener(this);
  showContour.setSelected(bShowContour);
  threshold=new ThresholdControlPanel(owner,ThresholdType.BLOCK_OTSU);
  threshold.setRadius(15);
  threshold.setOtsuTuning(20);
  spinnerMinContourSize=new JSpinner(new SpinnerNumberModel(config.polygon.detector.minimumContour.pixels,5,10000,2));
  spinnerMinContourSize.setMaximumSize(spinnerMinContourSize.getPreferredSize());
  spinnerMinContourSize.addChangeListener(this);
  spinnerMinEdgeD=new JSpinner(new SpinnerNumberModel(config.polygon.detector.minimumEdgeIntensity,0.0,255.0,1.0));
  spinnerMinEdgeD.setMaximumSize(spinnerMinEdgeD.getPreferredSize());
  spinnerMinEdgeD.addChangeListener(this);
  spinnerMinEdgeR=new JSpinner(new SpinnerNumberModel(config.polygon.minimumRefineEdgeIntensity,0.0,255.0,1.0));
  spinnerMinEdgeR.setMaximumSize(spinnerMinEdgeR.getPreferredSize());
  spinnerMinEdgeR.addChangeListener(this);
  spinnerContourSplit=new JSpinner(new SpinnerNumberModel(config.polygon.detector.contourToPoly.splitFraction,0.0,1.0,0.01));
  configureSpinnerFloat(spinnerContourSplit);
  spinnerContourMinSplit=new JSpinner(new SpinnerNumberModel(config.polygon.detector.contourToPoly.minimumSideFraction,0.0,1.0,0.001));
  configureSpinnerFloat(spinnerContourMinSplit);
  spinnerContourIterations=new JSpinner(new SpinnerNumberModel(config.polygon.detector.contourToPoly.iterations,1,200,1));
  spinnerContourIterations.setMaximumSize(spinnerContourIterations.getPreferredSize());
  spinnerContourIterations.addChangeListener(this);
  spinnerSplitPenalty=new JSpinner(new SpinnerNumberModel(config.polygon.detector.splitPenalty,0.0,100.0,1.0));
  configureSpinnerFloat(spinnerSplitPenalty);
  setBorder=new JCheckBox(""String_Node_Str"");
  setBorder.addActionListener(this);
  setBorder.setSelected(config.polygon.detector.canTouchBorder);
  setRefineContour=new JCheckBox(""String_Node_Str"");
  setRefineContour.addActionListener(this);
  setRefineContour.setSelected(config.polygon.refineContour);
  setRefineGray=new JCheckBox(""String_Node_Str"");
  setRefineGray.addActionListener(this);
  setRefineGray.setSelected(config.polygon.refineGray != null);
  setRemoveBias=new JCheckBox(""String_Node_Str"");
  setRemoveBias.addActionListener(this);
  setRemoveBias.setSelected(config.polygon.adjustForThresholdBias);
  spinnerLineSamples=new JSpinner(new SpinnerNumberModel(refineGray.lineSamples,5,100,1));
  spinnerLineSamples.setMaximumSize(spinnerLineSamples.getPreferredSize());
  spinnerLineSamples.addChangeListener(this);
  spinnerCornerOffset=new JSpinner(new SpinnerNumberModel(refineGray.cornerOffset,0,10,1));
  spinnerCornerOffset.setMaximumSize(spinnerCornerOffset.getPreferredSize());
  spinnerCornerOffset.addChangeListener(this);
  spinnerSampleRadius=new JSpinner(new SpinnerNumberModel(refineGray.sampleRadius,1,10,1));
  spinnerSampleRadius.setMaximumSize(spinnerCornerOffset.getPreferredSize());
  spinnerSampleRadius.addChangeListener(this);
  spinnerRefineMaxIterations=new JSpinner(new SpinnerNumberModel(refineGray.maxIterations,1,200,1));
  spinnerRefineMaxIterations.setMaximumSize(spinnerRefineMaxIterations.getPreferredSize());
  spinnerRefineMaxIterations.addChangeListener(this);
  spinnerConvergeTol=new JSpinner(new SpinnerNumberModel(refineGray.convergeTolPixels,0.0,2.0,0.005));
  configureSpinnerFloat(spinnerConvergeTol);
  spinnerMaxCornerChange=new JSpinner(new SpinnerNumberModel(refineGray.maxCornerChangePixel,0.0,50.0,1.0));
  configureSpinnerFloat(spinnerMaxCornerChange);
  addLabeled(processingTimeLabel,""String_Node_Str"",this);
  addLabeled(imageSizeLabel,""String_Node_Str"",this);
  add(bRunAgain);
  addLabeled(imageView,""String_Node_Str"",this);
  addLabeled(selectZoom,""String_Node_Str"",this);
  addAlignLeft(showSquares,this);
  addAlignLeft(showPositionPattern,this);
  addAlignLeft(showContour,this);
  add(threshold);
  addLabeled(spinnerMinContourSize,""String_Node_Str"",this);
  addLabeled(spinnerMinEdgeD,""String_Node_Str"",this);
  addLabeled(spinnerMinEdgeR,""String_Node_Str"",this);
  addAlignLeft(setBorder,this);
  addCenterLabel(""String_Node_Str"",this);
  addLabeled(spinnerContourSplit,""String_Node_Str"",this);
  addLabeled(spinnerContourMinSplit,""String_Node_Str"",this);
  addLabeled(spinnerContourIterations,""String_Node_Str"",this);
  addLabeled(spinnerSplitPenalty,""String_Node_Str"",this);
  addCenterLabel(""String_Node_Str"",this);
  addAlignLeft(setRemoveBias,this);
  addAlignLeft(setRefineContour,this);
  addAlignLeft(setRefineGray,this);
  addLabeled(spinnerLineSamples,""String_Node_Str"",this);
  addLabeled(spinnerCornerOffset,""String_Node_Str"",this);
  addLabeled(spinnerSampleRadius,""String_Node_Str"",this);
  addLabeled(spinnerRefineMaxIterations,""String_Node_Str"",this);
  addLabeled(spinnerConvergeTol,""String_Node_Str"",this);
  addLabeled(spinnerMaxCornerChange,""String_Node_Str"",this);
  addVerticalGlue(this);
}","public DetectQrCodeControlPanel(DetectQrCodeApp owner){
  this.owner=owner;
  bRunAgain.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent actionEvent){
      DetectQrCodeControlPanel.this.owner.reprocessImageOnly();
    }
  }
);
  imageView=new JComboBox();
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addActionListener(this);
  imageView.setMaximumSize(imageView.getPreferredSize());
  selectZoom=new JSpinner(new SpinnerNumberModel(1,MIN_ZOOM,MAX_ZOOM,1));
  selectZoom.addChangeListener(this);
  selectZoom.setMaximumSize(selectZoom.getPreferredSize());
  showSquares=new JCheckBox(""String_Node_Str"");
  showSquares.addActionListener(this);
  showSquares.setSelected(bShowSquares);
  showPositionPattern=new JCheckBox(""String_Node_Str"");
  showPositionPattern.setSelected(bShowPositionPattern);
  showPositionPattern.addActionListener(this);
  showAlignmentPattern=new JCheckBox(""String_Node_Str"");
  showAlignmentPattern.setSelected(bShowAlignmentPattern);
  showAlignmentPattern.addActionListener(this);
  showContour=new JCheckBox(""String_Node_Str"");
  showContour.addActionListener(this);
  showContour.setSelected(bShowContour);
  threshold=new ThresholdControlPanel(owner,ThresholdType.BLOCK_OTSU);
  threshold.setRadius(15);
  threshold.setOtsuTuning(20);
  spinnerMinContourSize=new JSpinner(new SpinnerNumberModel(config.polygon.detector.minimumContour.pixels,5,10000,2));
  spinnerMinContourSize.setMaximumSize(spinnerMinContourSize.getPreferredSize());
  spinnerMinContourSize.addChangeListener(this);
  spinnerMinEdgeD=new JSpinner(new SpinnerNumberModel(config.polygon.detector.minimumEdgeIntensity,0.0,255.0,1.0));
  spinnerMinEdgeD.setMaximumSize(spinnerMinEdgeD.getPreferredSize());
  spinnerMinEdgeD.addChangeListener(this);
  spinnerMinEdgeR=new JSpinner(new SpinnerNumberModel(config.polygon.minimumRefineEdgeIntensity,0.0,255.0,1.0));
  spinnerMinEdgeR.setMaximumSize(spinnerMinEdgeR.getPreferredSize());
  spinnerMinEdgeR.addChangeListener(this);
  spinnerContourSplit=new JSpinner(new SpinnerNumberModel(config.polygon.detector.contourToPoly.splitFraction,0.0,1.0,0.01));
  configureSpinnerFloat(spinnerContourSplit);
  spinnerContourMinSplit=new JSpinner(new SpinnerNumberModel(config.polygon.detector.contourToPoly.minimumSideFraction,0.0,1.0,0.001));
  configureSpinnerFloat(spinnerContourMinSplit);
  spinnerContourIterations=new JSpinner(new SpinnerNumberModel(config.polygon.detector.contourToPoly.iterations,1,200,1));
  spinnerContourIterations.setMaximumSize(spinnerContourIterations.getPreferredSize());
  spinnerContourIterations.addChangeListener(this);
  spinnerSplitPenalty=new JSpinner(new SpinnerNumberModel(config.polygon.detector.splitPenalty,0.0,100.0,1.0));
  configureSpinnerFloat(spinnerSplitPenalty);
  setBorder=new JCheckBox(""String_Node_Str"");
  setBorder.addActionListener(this);
  setBorder.setSelected(config.polygon.detector.canTouchBorder);
  setRefineContour=new JCheckBox(""String_Node_Str"");
  setRefineContour.addActionListener(this);
  setRefineContour.setSelected(config.polygon.refineContour);
  setRefineGray=new JCheckBox(""String_Node_Str"");
  setRefineGray.addActionListener(this);
  setRefineGray.setSelected(config.polygon.refineGray != null);
  setRemoveBias=new JCheckBox(""String_Node_Str"");
  setRemoveBias.addActionListener(this);
  setRemoveBias.setSelected(config.polygon.adjustForThresholdBias);
  spinnerLineSamples=new JSpinner(new SpinnerNumberModel(refineGray.lineSamples,5,100,1));
  spinnerLineSamples.setMaximumSize(spinnerLineSamples.getPreferredSize());
  spinnerLineSamples.addChangeListener(this);
  spinnerCornerOffset=new JSpinner(new SpinnerNumberModel(refineGray.cornerOffset,0,10,1));
  spinnerCornerOffset.setMaximumSize(spinnerCornerOffset.getPreferredSize());
  spinnerCornerOffset.addChangeListener(this);
  spinnerSampleRadius=new JSpinner(new SpinnerNumberModel(refineGray.sampleRadius,1,10,1));
  spinnerSampleRadius.setMaximumSize(spinnerCornerOffset.getPreferredSize());
  spinnerSampleRadius.addChangeListener(this);
  spinnerRefineMaxIterations=new JSpinner(new SpinnerNumberModel(refineGray.maxIterations,1,200,1));
  spinnerRefineMaxIterations.setMaximumSize(spinnerRefineMaxIterations.getPreferredSize());
  spinnerRefineMaxIterations.addChangeListener(this);
  spinnerConvergeTol=new JSpinner(new SpinnerNumberModel(refineGray.convergeTolPixels,0.0,2.0,0.005));
  configureSpinnerFloat(spinnerConvergeTol);
  spinnerMaxCornerChange=new JSpinner(new SpinnerNumberModel(refineGray.maxCornerChangePixel,0.0,50.0,1.0));
  configureSpinnerFloat(spinnerMaxCornerChange);
  addLabeled(processingTimeLabel,""String_Node_Str"",this);
  addLabeled(imageSizeLabel,""String_Node_Str"",this);
  add(bRunAgain);
  addLabeled(imageView,""String_Node_Str"",this);
  addLabeled(selectZoom,""String_Node_Str"",this);
  addAlignLeft(showSquares,this);
  addAlignLeft(showAlignmentPattern,this);
  addAlignLeft(showPositionPattern,this);
  addAlignLeft(showContour,this);
  add(threshold);
  addLabeled(spinnerMinContourSize,""String_Node_Str"",this);
  addLabeled(spinnerMinEdgeD,""String_Node_Str"",this);
  addLabeled(spinnerMinEdgeR,""String_Node_Str"",this);
  addAlignLeft(setBorder,this);
  addCenterLabel(""String_Node_Str"",this);
  addLabeled(spinnerContourSplit,""String_Node_Str"",this);
  addLabeled(spinnerContourMinSplit,""String_Node_Str"",this);
  addLabeled(spinnerContourIterations,""String_Node_Str"",this);
  addLabeled(spinnerSplitPenalty,""String_Node_Str"",this);
  addCenterLabel(""String_Node_Str"",this);
  addAlignLeft(setRemoveBias,this);
  addAlignLeft(setRefineContour,this);
  addAlignLeft(setRefineGray,this);
  addLabeled(spinnerLineSamples,""String_Node_Str"",this);
  addLabeled(spinnerCornerOffset,""String_Node_Str"",this);
  addLabeled(spinnerSampleRadius,""String_Node_Str"",this);
  addLabeled(spinnerRefineMaxIterations,""String_Node_Str"",this);
  addLabeled(spinnerConvergeTol,""String_Node_Str"",this);
  addLabeled(spinnerMaxCornerChange,""String_Node_Str"",this);
  addVerticalGlue(this);
}",0.9827973074046372
150671,"/** 
 * Returns an algorithm for estimating a homography matrix given a set of  {@link AssociatedPair}.
 * @see HomographyLinear4
 * @param normalize If input is in pixel coordinates set to true.  False if in normalized image coordinates.
 * @return Homography estimator.
 */
public static Estimate1ofEpipolar computeHomography(boolean normalize){
  HomographyLinear4 alg=new HomographyLinear4(normalize);
  return new WrapHomographyLinear(alg);
}","/** 
 * Returns an algorithm for estimating a homography matrix given a set of  {@link AssociatedPair}.
 * @see HomographyLinear4
 * @param normalizeInput If input is in pixel coordinates set to true.  False if in normalized image coordinates.
 * @return Homography estimator.
 */
public static Estimate1ofEpipolar computeHomography(boolean normalizeInput){
  HomographyLinear4 alg=new HomographyLinear4(normalizeInput);
  return new WrapHomographyLinear(alg);
}",0.9834983498349836
150672,"/** 
 * Localizizes the alignment pattern crudely by searching for the black box in the center by looking for its edges in the gray scale image
 * @return true if success or false if it doesn't resemble an alignment pattern
 */
protected boolean localize(QrCode.Alignment pattern,float guessX,float guessY){
  for (int i=0; i < arrayY.length; i++) {
    float x=guessX - 1.25f + i * 2.5f / 10.0f;
    float y=guessY - 1.25f + i * 2.5f / 10.0f;
    arrayX[i]=interpolate.get(x,guessY);
    arrayY[i]=interpolate.get(guessX,y);
  }
  int downX=greatestDown(arrayX);
  int upX=greatestUp(arrayX,downX);
  if (downX == -1 || upX == -1)   return false;
  int downY=greatestDown(arrayY);
  int upY=greatestUp(arrayY,downY);
  if (downY == -1 || upY == -1)   return false;
  pattern.moduleFound.x=guessX - 1.25f + (downX + upX) * 2.5f / 20.0f;
  pattern.moduleFound.y=guessY - 1.25f + (downY + upY) * 2.5f / 20.0f;
  gridToImage.compute((float)pattern.moduleFound.x,(float)pattern.moduleFound.y,p32);
  pattern.pixel.set(p32.x,p32.y);
  return true;
}","/** 
 * Localizizes the alignment pattern crudely by searching for the black box in the center by looking for its edges in the gray scale image
 * @return true if success or false if it doesn't resemble an alignment pattern
 */
boolean localize(QrCode.Alignment pattern,float guessX,float guessY){
  for (int i=0; i < arrayY.length; i++) {
    float x=guessX - 1.5f + i * 3f / 12.0f;
    float y=guessY - 1.5f + i * 3f / 12.0f;
    gridToImage.compute(x,guessY,pixel);
    arrayX[i]=interpolate.get(pixel.x,pixel.y);
    gridToImage.compute(guessX,y,pixel);
    arrayY[i]=interpolate.get(pixel.x,pixel.y);
  }
  int downX=greatestDown(arrayX);
  if (downX == -1)   return false;
  int upX=greatestUp(arrayX,downX);
  if (upX == -1)   return false;
  int downY=greatestDown(arrayY);
  if (downY == -1)   return false;
  int upY=greatestUp(arrayY,downY);
  if (upY == -1)   return false;
  pattern.moduleFound.x=guessX - 1.5f + (downX + upX) * 3f / 24.0f;
  pattern.moduleFound.y=guessY - 1.5f + (downY + upY) * 3f / 24.0f;
  gridToImage.compute((float)pattern.moduleFound.x,(float)pattern.moduleFound.y,pixel);
  pattern.pixel.set(pixel.x,pixel.y);
  return true;
}",0.6612318840579711
150673,"static int greatestUp(float array[],int start){
  int best=-1;
  float bestScore=0;
  for (int i=start; i < array.length; i++) {
    float diff=array[i] - array[i - 1];
    if (diff > bestScore) {
      bestScore=diff;
      best=i;
    }
  }
  return best;
}","static int greatestUp(float array[],int start){
  int best=-1;
  float bestScore=0;
  for (int i=start; i < array.length; i++) {
    float diff=array[i] - array[i - 1];
    if (diff > bestScore) {
      bestScore=diff;
      best=i - 1;
    }
  }
  return best;
}",0.992337164750958
150674,"/** 
 * Computes an approximate homography the initialize the search. Avoid corner features since they are more likely to be damaged. Outside features are also likely to be damaged fewer of them are sampled
 * @param qr The QR code with detected position patterns
 */
private boolean computeHomography(QrCode qr){
  int gridSize=patternLocations.size[qr.version];
  associatedPairs.get(0).p1.set(7,0);
  associatedPairs.get(1).p1.set(7,7);
  associatedPairs.get(2).p1.set(0,7);
  associatedPairs.get(3).p1.set(gridSize - 7,0);
  associatedPairs.get(4).p1.set(gridSize - 7,7);
  associatedPairs.get(5).p1.set(0,gridSize - 7);
  associatedPairs.get(6).p1.set(7,gridSize - 7);
  set(0,qr.ppCorner,1);
  set(1,qr.ppCorner,2);
  set(2,qr.ppCorner,3);
  set(3,qr.ppRight,0);
  set(4,qr.ppRight,3);
  set(5,qr.ppDown,0);
  set(6,qr.ppDown,1);
  if (!computeHomography.process(associatedPairs,H))   return false;
  ConvertMatrixData.convert(H,H32);
  UnrolledInverseFromMinor_FDRM.inv(H32,H_inv);
  gridToImage.set(H32);
  imageToGrid.set(H_inv);
  return true;
}","/** 
 * Computes an approximate homography the initialize the search. Avoid corner features since they are more likely to be damaged. Outside features are also likely to be damaged fewer of them are sampled
 * @param qr The QR code with detected position patterns
 */
boolean computeHomography(QrCode qr){
  int gridSize=patternLocations.size[qr.version];
  associatedPairs.get(0).p1.set(7,0);
  associatedPairs.get(1).p1.set(7,7);
  associatedPairs.get(2).p1.set(0,7);
  associatedPairs.get(3).p1.set(gridSize - 7,0);
  associatedPairs.get(4).p1.set(gridSize - 7,7);
  associatedPairs.get(5).p1.set(0,gridSize - 7);
  associatedPairs.get(6).p1.set(7,gridSize - 7);
  set(0,qr.ppCorner,1);
  set(1,qr.ppCorner,2);
  set(2,qr.ppCorner,3);
  set(3,qr.ppRight,0);
  set(4,qr.ppRight,3);
  set(5,qr.ppDown,0);
  set(6,qr.ppDown,1);
  if (!computeHomography.process(associatedPairs,H))   return false;
  ConvertMatrixData.convert(H,H32);
  UnrolledInverseFromMinor_FDRM.inv(H32,H_inv);
  gridToImage.set(H32);
  imageToGrid.set(H_inv);
  return true;
}",0.9961941008563272
150675,"/** 
 * Searches for the greatest down slope in the list
 */
static int greatestDown(float array[]){
  int best=-1;
  float bestScore=0;
  for (int i=1; i < array.length; i++) {
    float diff=array[i] - array[i - 1];
    if (diff < bestScore) {
      bestScore=diff;
      best=i;
    }
  }
  return best;
}","/** 
 * Searches for the greatest down slope in the list
 */
static int greatestDown(float array[]){
  int best=-1;
  float bestScore=0;
  for (int i=5; i < array.length; i++) {
    float diff=(4.0f / 2.0f) * (array[i - 5] + array[i]);
    diff-=array[i - 4] + array[i - 3] + array[i - 2]+ array[i - 1];
    if (diff > bestScore) {
      bestScore=diff;
      best=i - 4;
    }
  }
  return best;
}",0.5580736543909348
150676,"/** 
 * Creates a list of alignment patterns to look for and their grid coordinates
 */
private void initializePatterns(QrCode qr){
  int where[]=patternLocations.alignment[qr.version];
  qr.alignment.reset();
  for (int row=0; row < where.length; row++) {
    for (int col=0; col < where.length; col++) {
      boolean skip=false;
      if (row == 0 & col == 0)       skip=true;
 else       if (row == where.length - 1 & col == 0)       skip=true;
 else       if (row == where.length - 1 & col == where.length - 1)       skip=true;
      if (skip) {
        lookup.add(null);
      }
 else {
        QrCode.Alignment a=qr.alignment.grow();
        a.moduleX=col;
        a.moduleY=row;
        lookup.add(a);
      }
    }
  }
}","/** 
 * Creates a list of alignment patterns to look for and their grid coordinates
 */
void initializePatterns(QrCode qr){
  int qrsize=patternLocations.size[qr.version];
  int where[]=patternLocations.alignment[qr.version];
  qr.alignment.reset();
  lookup.reset();
  for (int row=where.length - 1; row >= 0; row--) {
    for (int col=0; col < where.length; col++) {
      boolean skip=false;
      if (row == 0 & col == 0)       skip=true;
 else       if (row == where.length - 1 & col == 0)       skip=true;
 else       if (row == where.length - 1 & col == where.length - 1)       skip=true;
      if (skip) {
        lookup.add(null);
      }
 else {
        QrCode.Alignment a=qr.alignment.grow();
        a.moduleX=where[col];
        a.moduleY=qrsize - where[row] - 1;
        lookup.add(a);
      }
    }
  }
}",0.813953488372093
150677,"public QrCodeAlignmentPatternLocator(Class<T> imageType){
  interpolate=FactoryInterpolation.nearestNeighborPixelS(imageType);
  for (int i=0; i < 5; i++) {
    associatedPairs.add(new AssociatedPair());
  }
}","public QrCodeAlignmentPatternLocator(Class<T> imageType){
  interpolate=FactoryInterpolation.nearestNeighborPixelS(imageType);
  interpolate.setBorder(FactoryImageBorder.single(imageType,BorderType.EXTENDED));
  for (int i=0; i < 7; i++) {
    associatedPairs.add(new AssociatedPair());
  }
}",0.8303393213572854
150678,"private boolean localizePositionPatterns(int[] alignmentLocations){
  int size=alignmentLocations.length;
  for (int row=0; row < size; row++) {
    for (int col=0; col < size; col++) {
      QrCode.Alignment a=lookup.get(row * size + col);
      if (a == null)       continue;
      double adjY=0, adjX=0;
      if (row > 0) {
        QrCode.Alignment p=lookup.get((row - 1) * size + col);
        adjY=p.moduleY + 0.5 - p.moduleFound.y;
      }
      if (col > 0) {
        QrCode.Alignment p=lookup.get((row - 1) * size + col);
        adjX=p.moduleX + 0.5 - p.moduleFound.x;
      }
      if (!localize(a,(float)(a.moduleX + 0.5 + adjX),(float)(a.moduleY + 0.5 + adjY)))       return false;
    }
  }
  return true;
}","boolean localizePositionPatterns(int[] alignmentLocations){
  int size=alignmentLocations.length;
  for (int row=0; row < size; row++) {
    for (int col=0; col < size; col++) {
      QrCode.Alignment a=lookup.get(row * size + col);
      if (a == null)       continue;
      double adjY=0, adjX=0;
      if (row > 0) {
        QrCode.Alignment p=lookup.get((row - 1) * size + col);
        if (p != null)         adjY=p.moduleY + 0.5 - p.moduleFound.y;
      }
      if (col > 0) {
        QrCode.Alignment p=lookup.get(row * size + col - 1);
        if (p != null)         adjX=p.moduleX + 0.5 - p.moduleFound.x;
      }
      if (!centerOnSquare(a,(float)(a.moduleX + 0.5 + adjX),(float)(a.moduleY + 0.5 + adjY))) {
        return false;
      }
      if (!localize(a,(float)a.moduleFound.x,(float)a.moduleFound.y)) {
        return false;
      }
    }
  }
  return true;
}",0.8210262828535669
150679,"public static ConfigThreshold local(ThresholdType type,int radius){
  if (!type.isAdaptive())   throw new IllegalArgumentException(""String_Node_Str"");
  if (type.isGlobal())   throw new IllegalArgumentException(""String_Node_Str"");
  if (type == ThresholdType.LOCAL_BLOCK_MIN_MAX) {
    return new ConfigThresholdBlockMinMax(radius,10,true);
  }
 else {
    ConfigThreshold config=new ConfigThreshold();
    config.type=type;
    config.radius=radius;
    return config;
  }
}","public static <T extends ConfigThreshold>T local(ThresholdType type,int radius){
  if (!type.isAdaptive())   throw new IllegalArgumentException(""String_Node_Str"");
  if (type.isGlobal())   throw new IllegalArgumentException(""String_Node_Str"");
  ConfigThreshold config;
  if (type == ThresholdType.LOCAL_BLOCK_MIN_MAX) {
    config=new ConfigThresholdBlockMinMax(radius,10,true);
  }
 else   if (type == ThresholdType.LOCAL_BLOCK_OTSU) {
    config=new ConfigThresholdBlockOtsu();
  }
 else {
    config=new ConfigThreshold();
  }
  config.type=type;
  config.radius=radius;
  return (T)config;
}",0.7133520074696545
150680,"/** 
 * Step 2: If the pixel below is unmarked and white then it must be an internal contour Same behavior it the pixel in question has been labeled or not already
 */
private void handleStep2(GrayS32 labeled,int label){
  if (label == 0)   label=labeled.data[indexOut - 1];
  Contour c=contours.get(label - 1);
  List<Point2D_I32> inner=storageLists.grow();
  inner.clear();
  tracer.setMaxContourSize(saveInternalContours ? maxContourSize : 0);
  tracer.trace(label,x,y,false,inner);
  if (inner.size() >= maxContourSize || inner.size() == 0) {
    storagePoints.size-=inner.size();
    storageLists.removeTail();
    inner.clear();
  }
  c.internal.add(inner);
}","/** 
 * Step 2: If the pixel below is unmarked and white then it must be an internal contour Same behavior it the pixel in question has been labeled or not already
 */
private void handleStep2(GrayS32 labeled,int label){
  if (label == 0)   label=labeled.data[indexOut - 1];
  Contour c=contours.get(label - 1);
  List<Point2D_I32> inner=storageLists.grow();
  inner.clear();
  tracer.setMaxContourSize(saveInternalContours ? maxContourSize : 0);
  tracer.trace(label,x,y,false,inner);
  if (inner.size() >= maxContourSize) {
    storagePoints.size-=inner.size();
    inner.clear();
  }
  c.internal.add(inner);
}",0.9593114241001564
150681,"/** 
 * {@inheritDoc}
 */
@Override public void process(List<EllipseRotated_F64> ellipses,List<List<Node>> clusters){
  foundGrids.reset();
  if (clusters.size() == 0)   return;
  verbose=true;
  for (int i=0; i < clusters.size(); i++) {
    List<Node> cluster=clusters.get(i);
    int clusterSize=cluster.size();
    if (clusterSize < 5)     continue;
    computeNodeInfo(ellipses,cluster);
    if (!findContour(true)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    NodeInfo corner=selectSeedCorner();
    if (corner == null) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    List<List<NodeInfo>> grid=new ArrayList<>();
    double distLeft=corner.distance(corner.left);
    double distRight=corner.distance(corner.right);
    NodeInfo next=distLeft < distRight ? corner.left : corner.right;
    next.marked=true;
    List<NodeInfo> column0=new ArrayList<>();
    List<NodeInfo> column1=new ArrayList<>();
    bottomTwoColumns(corner,next,column0,column1);
    if (column0.size() < 2 || column1.size() < 2) {
      if (verbose)       System.out.println(""String_Node_Str"" + column0.size() + ""String_Node_Str""+ column1.size());
      continue;
    }
    grid.add(column0);
    grid.add(column1);
    boolean error=false;
    boolean even=true;
    while (true) {
      int expected=column0.size();
      column0=column1;
      column1=new ArrayList<>();
      if (!addRemainingColumns(column1,column0,even))       break;
      even=!even;
      grid.add(column1);
      if (expected != column1.size()) {
        error=true;
        if (verbose)         System.out.println(""String_Node_Str"" + expected + ""String_Node_Str""+ column1.size());
        break;
      }
    }
    if (!error) {
      if (grid.size() < 3)       continue;
      if (checkDuplicates(grid)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      saveResults(grid);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void process(List<EllipseRotated_F64> ellipses,List<List<Node>> clusters){
  foundGrids.reset();
  if (clusters.size() == 0)   return;
  for (int i=0; i < clusters.size(); i++) {
    List<Node> cluster=clusters.get(i);
    int clusterSize=cluster.size();
    if (clusterSize < 5)     continue;
    computeNodeInfo(ellipses,cluster);
    if (!findContour(true)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    NodeInfo corner=selectSeedCorner();
    if (corner == null) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    List<List<NodeInfo>> grid=new ArrayList<>();
    double distLeft=corner.distance(corner.left);
    double distRight=corner.distance(corner.right);
    NodeInfo next=distLeft < distRight ? corner.left : corner.right;
    next.marked=true;
    List<NodeInfo> column0=new ArrayList<>();
    List<NodeInfo> column1=new ArrayList<>();
    bottomTwoColumns(corner,next,column0,column1);
    if (column0.size() < 2 || column1.size() < 2) {
      if (verbose)       System.out.println(""String_Node_Str"" + column0.size() + ""String_Node_Str""+ column1.size());
      continue;
    }
    grid.add(column0);
    grid.add(column1);
    boolean error=false;
    boolean even=true;
    while (true) {
      int expected=column0.size();
      column0=column1;
      column1=new ArrayList<>();
      if (!addRemainingColumns(column1,column0,even))       break;
      even=!even;
      grid.add(column1);
      if (expected != column1.size()) {
        error=true;
        if (verbose)         System.out.println(""String_Node_Str"" + expected + ""String_Node_Str""+ column1.size());
        break;
      }
    }
    if (!error) {
      if (grid.size() < 3)       continue;
      if (checkDuplicates(grid)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      saveResults(grid);
    }
  }
}",0.995943204868154
150682,"/** 
 * Simulated scene using a pinhole camera model with radial distortion. Entire target is visible
 */
@Test public void pinhole_radial_fullview(){
  CameraPinholeRadial model=CalibrationIO.load(getClass().getResource(""String_Node_Str""));
  SimulatePlanarWorld simulator=new SimulatePlanarWorld();
  simulator.setCamera(model);
  List<Point2D_F64> locations2D=new ArrayList<>();
  GrayF32 pattern=new GrayF32(1,1);
  for (int i=0; i < targetConfigs.size(); i++) {
    DetectorFiducialCalibration detector=createDetector(targetConfigs.get(i));
    renderTarget(targetConfigs.get(i),simulatedTargetWidth,pattern,locations2D);
    simulator.resetScene();
    Se3_F64 markerToWorld=new Se3_F64();
    simulator.addTarget(markerToWorld,simulatedTargetWidth,pattern);
    markerToWorld.T.set(0,0,0.5);
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(0,0,1);
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(-0.33,0,1);
    checkRenderedResults(detector,simulator,locations2D);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0,-1,0,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0,-1,0.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(-0.33,0.33,1);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0,-1,0.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(0,-0.20,1);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0.8,-1,0.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0.8,-1,1.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(0,-0.15,1);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0.2,-1,2.4,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
  }
}","/** 
 * Simulated scene using a pinhole camera model with radial distortion. Entire target is visible
 */
@Test public void pinhole_radial_fullview(){
  CameraPinholeRadial model=CalibrationIO.load(getClass().getResource(""String_Node_Str""));
  SimulatePlanarWorld simulator=new SimulatePlanarWorld();
  simulator.setCamera(model);
  List<Point2D_F64> locations2D=new ArrayList<>();
  GrayF32 pattern=new GrayF32(1,1);
  for (int i=0; i < targetConfigs.size(); i++) {
    failedToDetect=0;
    DetectorFiducialCalibration detector=createDetector(targetConfigs.get(i));
    renderTarget(targetConfigs.get(i),simulatedTargetWidth,pattern,locations2D);
    simulator.resetScene();
    Se3_F64 markerToWorld=new Se3_F64();
    simulator.addTarget(markerToWorld,simulatedTargetWidth,pattern);
    markerToWorld.T.set(0,0,0.5);
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(0,0,1);
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(-0.33,0,1);
    checkRenderedResults(detector,simulator,locations2D);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0,-1,0,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0,-1,0.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(-0.33,0.33,1);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0,-1,0.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(0,-0.20,1);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0.8,-1,0.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0.8,-1,1.8,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
    markerToWorld.T.set(0,-0.15,1);
    ConvertRotation3D_F64.eulerToMatrix(EulerType.XYZ,0.2,-1,2.4,markerToWorld.getR());
    checkRenderedResults(detector,simulator,locations2D);
  }
  assertEquals(0,failedToDetect);
}",0.9863614223088164
150683,"/** 
 * See if it can detect targets distorted by fisheye lens. Entire target is always seen
 */
@Test public void fisheye_fullview(){
  CameraUniversalOmni model=CalibrationIO.load(getClass().getResource(""String_Node_Str""));
  SimulatePlanarWorld simulator=new SimulatePlanarWorld();
  simulator.setCamera(model);
  List<Point2D_F64> locations2D=new ArrayList<>();
  GrayF32 pattern=new GrayF32(1,1);
  for (int i=0; i < targetConfigs.size(); i++) {
    DetectorFiducialCalibration detector=createDetector(targetConfigs.get(i));
    renderTarget(targetConfigs.get(i),simulatedTargetWidth,pattern,locations2D);
    simulator.resetScene();
    Se3_F64 markerToWorld=new Se3_F64();
    simulator.addTarget(markerToWorld,simulatedTargetWidth,pattern);
    for (int j=0; j < fisheye_poses.size(); j++) {
      System.out.println(""String_Node_Str"" + j);
      markerToWorld.set(fisheye_poses.get(j));
      checkRenderedResults(detector,simulator,locations2D);
    }
  }
}","/** 
 * See if it can detect targets distorted by fisheye lens. Entire target is always seen
 */
@Test public void fisheye_fullview(){
  CameraUniversalOmni model=CalibrationIO.load(getClass().getResource(""String_Node_Str""));
  SimulatePlanarWorld simulator=new SimulatePlanarWorld();
  simulator.setCamera(model);
  List<Point2D_F64> locations2D=new ArrayList<>();
  GrayF32 pattern=new GrayF32(1,1);
  for (int i=0; i < targetConfigs.size(); i++) {
    DetectorFiducialCalibration detector=createDetector(targetConfigs.get(i));
    renderTarget(targetConfigs.get(i),simulatedTargetWidth,pattern,locations2D);
    simulator.resetScene();
    Se3_F64 markerToWorld=new Se3_F64();
    simulator.addTarget(markerToWorld,simulatedTargetWidth,pattern);
    failedToDetect=0;
    for (int j=0; j < fisheye_poses.size(); j++) {
      markerToWorld.set(fisheye_poses.get(j));
      checkRenderedResults(detector,simulator,locations2D);
    }
  }
  assertTrue(failedToDetect <= fisheyeAllowedFails);
}",0.936734693877551
150684,"private void checkRenderedResults(DetectorFiducialCalibration detector,SimulatePlanarWorld simulator,List<Point2D_F64> locations2D){
  simulator.render();
  if (!detector.process(simulator.getOutput())) {
    visualize(simulator,locations2D,null);
    fail(""String_Node_Str"");
  }
  checkResults(simulator,detector.getDetectedPoints(),locations2D);
}","private void checkRenderedResults(DetectorFiducialCalibration detector,SimulatePlanarWorld simulator,List<Point2D_F64> locations2D){
  simulator.render();
  if (!detector.process(simulator.getOutput())) {
    visualize(simulator,locations2D,null);
    failedToDetect++;
    return;
  }
  checkResults(simulator,detector.getDetectedPoints(),locations2D);
}",0.9390070921985816
150685,"@Override public void renderTarget(Object layout,double length3D,GrayF32 image,List<Point2D_F64> points2D){
  ConfigCircleHexagonalGrid config=(ConfigCircleHexagonalGrid)layout;
  double radiusPixels=20;
  double centerDistancePixels=2 * radiusPixels * config.centerDistance / config.circleDiameter;
  double borderPixels=30;
  double spaceX=centerDistancePixels / 2.0;
  double spaceY=centerDistancePixels * Math.sin(UtilAngle.radian(60));
  int imageWidth=(int)(borderPixels * 2 + (config.numCols - 1) * spaceX + 2 * radiusPixels + 0.5);
  int imageHeight=(int)(borderPixels * 2 + (config.numRows - 1) * spaceY + 2 * radiusPixels + 0.5);
  double centerDistanceWorld=length3D * centerDistancePixels / (double)imageWidth;
  image.reshape(imageWidth,imageHeight);
  BufferedImage buffered=new BufferedImage(image.width,image.height,BufferedImage.TYPE_INT_BGR);
  Graphics2D g2=buffered.createGraphics();
  g2.setColor(Color.WHITE);
  g2.fillRect(0,0,buffered.getWidth(),buffered.getHeight());
  g2.setColor(Color.BLACK);
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  Ellipse2D.Double ellipse=new Ellipse2D.Double();
  for (int row=0; row < config.numRows; row++) {
    double y=borderPixels + radiusPixels + row * spaceY;
    for (int col=0; col < config.numCols; col++) {
      double x=borderPixels + radiusPixels + col * spaceX;
      if (row % 2 == 1 && col % 2 == 0)       continue;
      if (row % 2 == 0 && col % 2 == 1)       continue;
      ellipse.setFrame(x - radiusPixels,y - radiusPixels,2 * radiusPixels,2 * radiusPixels);
      g2.fill(ellipse);
    }
  }
  ConvertBufferedImage.convertFrom(buffered,image);
  points2D.clear();
  points2D.addAll(createLayout(config.numRows,config.numCols,centerDistanceWorld));
}","@Override public void renderTarget(Object layout,double length3D,GrayF32 image,List<Point2D_F64> points2D){
  ConfigCircleHexagonalGrid config=(ConfigCircleHexagonalGrid)layout;
  double radiusPixels=20;
  double centerDistancePixels=2 * radiusPixels * config.centerDistance / config.circleDiameter;
  double borderPixels=30;
  double spaceX=centerDistancePixels / 2.0;
  double spaceY=centerDistancePixels * Math.sin(UtilAngle.radian(60));
  int imageWidth=(int)(borderPixels * 2 + (config.numCols - 1) * spaceX + 2 * radiusPixels + 0.5);
  int imageHeight=(int)(borderPixels * 2 + (config.numRows - 1) * spaceY + 2 * radiusPixels + 0.5);
  double centerDistanceWorld=length3D * centerDistancePixels / (double)imageWidth;
  image.reshape(imageWidth,imageHeight);
  BufferedImage buffered=new BufferedImage(image.width,image.height,BufferedImage.TYPE_INT_BGR);
  Graphics2D g2=buffered.createGraphics();
  g2.setColor(Color.WHITE);
  g2.fillRect(0,0,buffered.getWidth(),buffered.getHeight());
  g2.setColor(Color.BLACK);
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  Ellipse2D.Double ellipse=new Ellipse2D.Double();
  for (int row=0; row < config.numRows; row++) {
    double y=borderPixels + radiusPixels;
    y+=(config.numRows - 1 - row) * spaceY;
    for (int col=0; col < config.numCols; col++) {
      double x=borderPixels + radiusPixels + col * spaceX;
      if (row % 2 == 1 && col % 2 == 0)       continue;
      if (row % 2 == 0 && col % 2 == 1)       continue;
      ellipse.setFrame(x - radiusPixels,y - radiusPixels,2 * radiusPixels,2 * radiusPixels);
      g2.fill(ellipse);
    }
  }
  ConvertBufferedImage.convertFrom(buffered,image);
  points2D.clear();
  points2D.addAll(createLayout(config.numRows,config.numCols,centerDistanceWorld));
}",0.9906890130353816
150686,"public TestCalibrationDetectorCircleHexagonalGrid(){
  targetConfigs.add(new ConfigCircleHexagonalGrid(5,5,20,24));
  targetConfigs.add(new ConfigCircleHexagonalGrid(5,4,20,24));
  fisheyeMatchTol=10;
}","public TestCalibrationDetectorCircleHexagonalGrid(){
  targetConfigs.add(new ConfigCircleHexagonalGrid(5,5,20,24));
  targetConfigs.add(new ConfigCircleHexagonalGrid(5,6,20,24));
  targetConfigs.add(new ConfigCircleHexagonalGrid(6,6,20,24));
  fisheyeMatchTol=10;
  fisheyeAllowedFails=4;
}",0.8170731707317073
150687,"@Override protected List<EllipseRotated_F64> getFoundEllipses(){
  return detector.getDetector().getEllipseDetector().getFoundEllipses().toList();
}","@Override protected List<EllipseRotated_F64> getFoundEllipses(){
  return detector.getDetector().getEllipseDetector().getFoundEllipses(null);
}",0.9553264604810996
150688,"@Override protected void renderClusters(Graphics2D g2,double scale){
  List<EllipseRotated_F64> found=detector.getDetector().getEllipseDetector().getFoundEllipses().toList();
  List<List<EllipsesIntoClusters.Node>> clusters=detector.getDetector().getClusters();
  g2.setStroke(new BasicStroke(2));
  int id=0;
  for (  List<EllipsesIntoClusters.Node> c : clusters) {
    g2.setColor(colorId[Math.min(id++,colorId.length - 1)]);
    for (    EllipsesIntoClusters.Node n : c) {
      EllipseRotated_F64 a=found.get(n.which);
      for (int i=0; i < n.connections.size; i++) {
        EllipseRotated_F64 b=found.get(n.connections.get(i));
        g2.drawLine((int)(a.center.x * scale),(int)(a.center.y * scale),(int)(b.center.x * scale),(int)(b.center.y * scale));
      }
    }
  }
}","@Override protected void renderClusters(Graphics2D g2,double scale){
  List<EllipseRotated_F64> found=detector.getDetector().getEllipseDetector().getFoundEllipses(null);
  List<List<EllipsesIntoClusters.Node>> clusters=detector.getDetector().getClusters();
  g2.setStroke(new BasicStroke(2));
  int id=0;
  for (  List<EllipsesIntoClusters.Node> c : clusters) {
    g2.setColor(colorId[Math.min(id++,colorId.length - 1)]);
    for (    EllipsesIntoClusters.Node n : c) {
      EllipseRotated_F64 a=found.get(n.which);
      for (int i=0; i < n.connections.size; i++) {
        EllipseRotated_F64 b=found.get(n.connections.get(i));
        g2.drawLine((int)(a.center.x * scale),(int)(a.center.y * scale),(int)(b.center.x * scale),(int)(b.center.y * scale));
      }
    }
  }
}",0.99165061014772
150689,"@Override protected List<EllipseRotated_F64> getFoundEllipses(){
  return detector.getDetector().getEllipseDetector().getFoundEllipses().toList();
}","@Override protected List<EllipseRotated_F64> getFoundEllipses(){
  return detector.getDetector().getEllipseDetector().getFoundEllipses(null);
}",0.9553264604810996
150690,"@Override protected void renderClusters(Graphics2D g2,double scale){
  List<EllipseRotated_F64> found=detector.getDetector().getEllipseDetector().getFoundEllipses().toList();
  List<List<EllipsesIntoClusters.Node>> clusters=detector.getDetector().getClusters();
  g2.setStroke(new BasicStroke(2));
  int id=0;
  for (  List<EllipsesIntoClusters.Node> c : clusters) {
    g2.setColor(colorId[Math.min(id++,colorId.length - 1)]);
    for (    EllipsesIntoClusters.Node n : c) {
      EllipseRotated_F64 a=found.get(n.which);
      for (int i=0; i < n.connections.size; i++) {
        EllipseRotated_F64 b=found.get(n.connections.get(i));
        g2.drawLine((int)(a.center.x * scale),(int)(a.center.y * scale),(int)(b.center.x * scale),(int)(b.center.y * scale));
      }
    }
  }
}","@Override protected void renderClusters(Graphics2D g2,double scale){
  List<BinaryEllipseDetector.EllipseInfo> found=detector.getDetector().getEllipseDetector().getFound().toList();
  List<List<EllipsesIntoClusters.Node>> clusters=detector.getDetector().getClusters();
  g2.setStroke(new BasicStroke(2));
  int id=0;
  for (  List<EllipsesIntoClusters.Node> c : clusters) {
    g2.setColor(colorId[Math.min(id++,colorId.length - 1)]);
    for (    EllipsesIntoClusters.Node n : c) {
      EllipseRotated_F64 a=found.get(n.which).ellipse;
      for (int i=0; i < n.connections.size; i++) {
        EllipseRotated_F64 b=found.get(n.connections.get(i)).ellipse;
        g2.drawLine((int)(a.center.x * scale),(int)(a.center.y * scale),(int)(b.center.x * scale),(int)(b.center.y * scale));
      }
    }
  }
}",0.3974763406940063
150691,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectEllipseControlPanel controls=(DetectEllipseControlPanel)DetectBlackEllipseApp.this.controls;
synchronized (DetectBlackEllipseApp.this) {
    g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
    if (controls.bShowContour) {
      List<Contour> contours=detector.getAllContours();
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowShapes) {
      List<EllipseRotated_F64> ellipses=detector.getFoundEllipses().toList();
      g2.setColor(Color.RED);
      g2.setStroke(new BasicStroke(3));
      for (      EllipseRotated_F64 p : ellipses) {
        VisualizeShapes.drawEllipse(p,scale,g2);
      }
    }
  }
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  DetectEllipseControlPanel controls=(DetectEllipseControlPanel)DetectBlackEllipseApp.this.controls;
synchronized (DetectBlackEllipseApp.this) {
    g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
    if (controls.bShowContour) {
      List<Contour> contours=detector.getAllContours();
      g2.setStroke(new BasicStroke(1));
      VisualizeBinaryData.render(contours,null,Color.CYAN,scale,g2);
    }
    if (controls.bShowShapes) {
      List<BinaryEllipseDetector.EllipseInfo> ellipses=detector.getFound().toList();
      g2.setColor(Color.RED);
      g2.setStroke(new BasicStroke(3));
      for (      BinaryEllipseDetector.EllipseInfo p : ellipses) {
        VisualizeShapes.drawEllipse(p.ellipse,scale,g2);
      }
    }
  }
}",0.9112554112554112
150692,"@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  System.out.flush();
  original=ConvertBufferedImage.checkCopy(buffered,original);
  work=ConvertBufferedImage.checkDeclare(buffered,work);
  binary.reshape(work.getWidth(),work.getHeight());
  final double timeInSeconds;
synchronized (this) {
    long before=System.nanoTime();
    inputToBinary.process((T)input,binary);
    detectorProcess((T)input,binary);
    long after=System.nanoTime();
    timeInSeconds=(after - before) * 1e-9;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      controls.setProcessingTime(timeInSeconds);
      viewUpdated();
    }
  }
);
}","@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  System.out.flush();
  original=ConvertBufferedImage.checkCopy(buffered,original);
  work=ConvertBufferedImage.checkDeclare(buffered,work);
  binary.reshape(work.getWidth(),work.getHeight());
  final double timeInSeconds;
synchronized (this) {
    long before=System.nanoTime();
    inputToBinary.process((T)input,binary);
    long middle=System.nanoTime();
    double a=(middle - before) * 1e-6;
    if (milliBinary == 0) {
      milliBinary=a;
    }
 else {
      milliBinary=0.95 * milliBinary + 0.05 * a;
    }
    System.out.printf(""String_Node_Str"",milliBinary);
    detectorProcess((T)input,binary);
    long after=System.nanoTime();
    timeInSeconds=(after - before) * 1e-9;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      controls.setProcessingTime(timeInSeconds);
      viewUpdated();
    }
  }
);
}",0.8528708133971292
150693,"@Override protected void handleInputChange(int source,InputMethod method,final int width,final int height){
  BoofSwingUtil.invokeNowOrLater(new Runnable(){
    @Override public void run(){
      int w=guiImage.getWidth();
      int h=guiImage.getHeight();
      if (w == 0) {
        w=guiImage.getPreferredSize().width;
        h=guiImage.getPreferredSize().height;
      }
      double scale=Math.max(width / (double)w,height / (double)h);
      if (scale > 1.0) {
        controls.setZoom(1.0 / scale);
      }
 else {
        controls.setZoom(1.0);
      }
    }
  }
);
}","@Override protected void handleInputChange(int source,InputMethod method,final int width,final int height){
  BoofSwingUtil.invokeNowOrLater(new Runnable(){
    @Override public void run(){
      int w=guiImage.getWidth();
      int h=guiImage.getHeight();
      if (w == 0) {
        w=guiImage.getPreferredSize().width;
        h=guiImage.getPreferredSize().height;
      }
      double scale=Math.max(width / (double)w,height / (double)h);
      if (scale > 1.0) {
        controls.setZoom(1.0 / scale);
      }
 else {
        controls.setZoom(1.0);
      }
      milliBinary=0;
    }
  }
);
}",0.9820971867007672
150694,"public static void main(String[] args){
  String images[]=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ListDisplayPanel panel=new ListDisplayPanel();
  BinaryEllipseDetector<GrayU8> detector=FactoryShapeDetector.ellipse(null,GrayU8.class);
  for (  String fileName : images) {
    BufferedImage image=UtilImageIO.loadImage(UtilIO.pathExample(fileName));
    GrayU8 input=ConvertBufferedImage.convertFromSingle(image,null,GrayU8.class);
    GrayU8 binary=new GrayU8(input.width,input.height);
    int threshold=GThresholdImageOps.computeOtsu(input,0,255);
    ThresholdImageOps.threshold(input,binary,threshold,true);
    detector.process(input,binary);
    FastQueue<EllipseRotated_F64> found=detector.getFoundEllipses();
    Graphics2D g2=image.createGraphics();
    g2.setStroke(new BasicStroke(3));
    g2.setColor(Color.RED);
    for (int i=0; i < found.size; i++) {
      VisualizeShapes.drawEllipse(found.get(i),g2);
    }
    panel.addImage(image,new File(fileName).getName());
  }
  ShowImages.showWindow(panel,""String_Node_Str"",true);
}","public static void main(String[] args){
  String images[]=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ListDisplayPanel panel=new ListDisplayPanel();
  BinaryEllipseDetector<GrayU8> detector=FactoryShapeDetector.ellipse(null,GrayU8.class);
  for (  String fileName : images) {
    BufferedImage image=UtilImageIO.loadImage(UtilIO.pathExample(fileName));
    GrayU8 input=ConvertBufferedImage.convertFromSingle(image,null,GrayU8.class);
    GrayU8 binary=new GrayU8(input.width,input.height);
    int threshold=GThresholdImageOps.computeOtsu(input,0,255);
    ThresholdImageOps.threshold(input,binary,threshold,true);
    detector.process(input,binary);
    FastQueue<BinaryEllipseDetector.EllipseInfo> found=detector.getFound();
    Graphics2D g2=image.createGraphics();
    g2.setStroke(new BasicStroke(3));
    g2.setColor(Color.RED);
    for (int i=0; i < found.size; i++) {
      VisualizeShapes.drawEllipse(found.get(i).ellipse,g2);
    }
    panel.addImage(image,new File(fileName).getName());
  }
  ShowImages.showWindow(panel,""String_Node_Str"",true);
}",0.9539443684450524
150695,"/** 
 * Detects ellipses inside the binary image and refines the edges for all detections inside the gray image
 * @param gray Grayscale image
 * @param binary Binary image of grayscale. 1 = ellipse and 0 = ignored background
 */
public void process(T gray,GrayU8 binary){
  refined.reset();
  ellipseDetector.process(binary);
  if (ellipseRefiner != null)   ellipseRefiner.setImage(gray);
  intensityCheck.setImage(gray);
  List<BinaryEllipseDetectorPixel.Found> found=ellipseDetector.getFound();
  for (  BinaryEllipseDetectorPixel.Found f : found) {
    if (!intensityCheck.process(f.ellipse)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    EllipseRotated_F64 r=refined.grow();
    if (ellipseRefiner != null) {
      if (!ellipseRefiner.process(f.ellipse,r)) {
        refined.removeTail();
      }
    }
 else {
      r.set(f.ellipse);
    }
  }
}","/** 
 * Detects ellipses inside the binary image and refines the edges for all detections inside the gray image
 * @param gray Grayscale image
 * @param binary Binary image of grayscale. 1 = ellipse and 0 = ignored background
 */
public void process(T gray,GrayU8 binary){
  results.reset();
  ellipseDetector.process(binary);
  if (ellipseRefiner != null)   ellipseRefiner.setImage(gray);
  intensityCheck.setImage(gray);
  List<BinaryEllipseDetectorPixel.Found> found=ellipseDetector.getFound();
  for (  BinaryEllipseDetectorPixel.Found f : found) {
    if (!intensityCheck.process(f.ellipse)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    EllipseInfo r=results.grow();
    r.contour=f.contour;
    if (ellipseRefiner != null) {
      if (!ellipseRefiner.process(f.ellipse,r.ellipse)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        results.removeTail();
        continue;
      }
 else       if (!intensityCheck.process(f.ellipse)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
    }
 else {
      r.ellipse.set(f.ellipse);
    }
    r.averageInside=intensityCheck.averageInside;
    r.averageOutside=intensityCheck.averageOutside;
  }
}",0.8012939001848429
150696,"/** 
 * <p>Returns all the found ellipses in the input image.</p> WARNING: Returned data is recycled on the next call to process
 * @return List of found ellipses.
 */
public FastQueue<EllipseRotated_F64> getFoundEllipses(){
  return refined;
}","public List<EllipseRotated_F64> getFoundEllipses(List<EllipseRotated_F64> storage){
  if (storage == null)   storage=new ArrayList<>();
  for (int i=0; i < results.size; i++) {
    storage.add(results.get(i).ellipse);
  }
  return storage;
}",0.2103092783505154
150697,"/** 
 * Processes the edge along the ellipse and determines if the edge intensity is strong enough to pass or not
 * @param ellipse The ellipse in undistorted image coordinates.
 * @return true if it passes or false if not
 */
public boolean process(EllipseRotated_F64 ellipse){
  if (numContourPoints <= 0) {
    score=0;
    return true;
  }
  double cphi=Math.cos(ellipse.phi);
  double sphi=Math.sin(ellipse.phi);
  double aveInside=0;
  double aveOutside=0;
  int total=0;
  for (int contourIndex=0; contourIndex < numContourPoints; contourIndex++) {
    double theta=contourIndex * Math.PI * 2.0 / numContourPoints;
    double ct=Math.cos(theta);
    double st=Math.sin(theta);
    double px=ellipse.center.x + ellipse.a * ct * cphi - ellipse.b * st * sphi;
    double py=ellipse.center.y + ellipse.a * ct * sphi + ellipse.b * st * cphi;
    double edx=ellipse.a * ct * ellipse.b* ellipse.b;
    double edy=ellipse.b * st * ellipse.a* ellipse.a;
    double r=Math.sqrt(edx * edx + edy * edy);
    edx/=r;
    edy/=r;
    double dx=edx * cphi - edy * sphi;
    double dy=edx * sphi + edy * cphi;
    double xin=px - dx * tangentDistance;
    double yin=py - dy * tangentDistance;
    double xout=px + dx * tangentDistance;
    double yout=py + dy * tangentDistance;
    if (integral.isInside(xin,yin) && integral.isInside(xout,yout)) {
      aveInside+=integral.compute(px,py,xin,yin);
      aveOutside+=integral.compute(px,py,xout,yout);
      total++;
    }
  }
  score=0;
  if (total > 0) {
    score=Math.abs(aveOutside - aveInside) / (total * tangentDistance);
  }
  return score >= passThreshold;
}","/** 
 * Processes the edge along the ellipse and determines if the edge intensity is strong enough to pass or not
 * @param ellipse The ellipse in undistorted image coordinates.
 * @return true if it passes or false if not
 */
public boolean process(EllipseRotated_F64 ellipse){
  if (numContourPoints <= 0) {
    score=0;
    return true;
  }
  double cphi=Math.cos(ellipse.phi);
  double sphi=Math.sin(ellipse.phi);
  averageInside=0;
  averageOutside=0;
  int total=0;
  for (int contourIndex=0; contourIndex < numContourPoints; contourIndex++) {
    double theta=contourIndex * Math.PI * 2.0 / numContourPoints;
    double ct=Math.cos(theta);
    double st=Math.sin(theta);
    double px=ellipse.center.x + ellipse.a * ct * cphi - ellipse.b * st * sphi;
    double py=ellipse.center.y + ellipse.a * ct * sphi + ellipse.b * st * cphi;
    double edx=ellipse.a * ct * ellipse.b* ellipse.b;
    double edy=ellipse.b * st * ellipse.a* ellipse.a;
    double r=Math.sqrt(edx * edx + edy * edy);
    edx/=r;
    edy/=r;
    double dx=edx * cphi - edy * sphi;
    double dy=edx * sphi + edy * cphi;
    double xin=px - dx * tangentDistance;
    double yin=py - dy * tangentDistance;
    double xout=px + dx * tangentDistance;
    double yout=py + dy * tangentDistance;
    if (integral.isInside(xin,yin) && integral.isInside(xout,yout)) {
      averageInside+=integral.compute(px,py,xin,yin);
      averageOutside+=integral.compute(px,py,xout,yout);
      total++;
    }
  }
  score=0;
  if (total > 0) {
    score=Math.abs(averageOutside - averageInside) / (total * tangentDistance);
  }
  return score >= passThreshold;
}",0.9882280049566295
150698,"/** 
 * Detects polygons inside the grayscale image and its thresholded version
 * @param gray Gray scale image
 * @param binary Binary version of grayscale image
 */
public void process(T gray,GrayU8 binary){
  detector.process(gray,binary);
  if (refineGray != null)   refineGray.setImage(gray);
  edgeIntensity.setImage(gray);
  List<DetectPolygonFromContour.Info> detections=detector.getFound().toList();
  if (adjustForBias != null) {
    for (int i=0; i < detections.size(); i++) {
      adjustForBias.process(detections.get(i).polygon,detector.isOutputClockwise());
    }
  }
}","/** 
 * Detects polygons inside the grayscale image and its thresholded version
 * @param gray Gray scale image
 * @param binary Binary version of grayscale image
 */
public void process(T gray,GrayU8 binary){
  detector.process(gray,binary);
  if (refineGray != null)   refineGray.setImage(gray);
  edgeIntensity.setImage(gray);
  long time0=System.nanoTime();
  List<DetectPolygonFromContour.Info> detections=detector.getFound().toList();
  if (adjustForBias != null) {
    for (int i=0; i < detections.size(); i++) {
      adjustForBias.process(detections.get(i).polygon,detector.isOutputClockwise());
    }
  }
  long time1=System.nanoTime();
  double milli=(time1 - time0) * 1e-6;
  if (milliAdjustBias == 0) {
    milliAdjustBias=milli;
  }
 else {
    milliAdjustBias=0.95 * milliAdjustBias + 0.5 * milli;
  }
  System.out.printf(""String_Node_Str"",milliAdjustBias);
}",0.8010973936899863
150699,"/** 
 * Examines the undistorted gray scake input image for squares.
 * @param gray Input image
 */
public void process(T gray,GrayU8 binary){
  if (verbose)   System.out.println(""String_Node_Str"");
  InputSanityCheck.checkSameShape(binary,gray);
  if (labeled.width != gray.width || labeled.height != gray.height)   configure(gray.width,gray.height);
  for (int i=0; i < foundInfo.size; i++) {
    foundInfo.get(i).reset();
  }
  foundInfo.reset();
  if (contourEdgeIntensity != null)   contourEdgeIntensity.setImage(gray);
  contourFinder.process(binary,labeled);
  findCandidateShapes();
  if (verbose)   System.out.println(""String_Node_Str"");
}","/** 
 * Examines the undistorted gray scake input image for squares.
 * @param gray Input image
 */
public void process(T gray,GrayU8 binary){
  if (verbose)   System.out.println(""String_Node_Str"");
  InputSanityCheck.checkSameShape(binary,gray);
  if (labeled.width != gray.width || labeled.height != gray.height)   configure(gray.width,gray.height);
  for (int i=0; i < foundInfo.size; i++) {
    foundInfo.get(i).reset();
  }
  foundInfo.reset();
  if (contourEdgeIntensity != null)   contourEdgeIntensity.setImage(gray);
  long time0=System.nanoTime();
  contourFinder.process(binary,labeled);
  long time1=System.nanoTime();
  findCandidateShapes();
  long time2=System.nanoTime();
  double a=(time1 - time0) * 1e-6;
  double b=(time2 - time1) * 1e-6;
  if (milliContour == 0) {
    milliContour=a;
    milliShapes=b;
  }
 else {
    double alpha=0.95;
    milliContour=alpha * milliContour + (1.0 - alpha) * a;
    milliShapes=alpha * milliShapes + (1.0 - alpha) * b;
  }
  System.out.printf(""String_Node_Str"",milliContour,milliShapes);
  if (verbose)   System.out.println(""String_Node_Str"");
}",0.7036613272311213
150700,"/** 
 * Specifies the image's intrinsic parameters and target size
 * @param width Width of the input image
 * @param height Height of the input image
 */
private void configure(int width,int height){
  labeled.reshape(width,height);
  this.minimumContour=minimumContourConfig.computeI(width,height);
  this.minimumArea=Math.pow(this.minimumContour / 4.0,2);
  if (helper != null)   helper.setImageShape(width,height);
}","/** 
 * Specifies the image's intrinsic parameters and target size
 * @param width Width of the input image
 * @param height Height of the input image
 */
private void configure(int width,int height){
  milliContour=0;
  milliShapes=0;
  labeled.reshape(width,height);
  this.minimumContour=minimumContourConfig.computeI(width,height);
  this.minimumArea=Math.pow(this.minimumContour / 4.0,2);
  if (helper != null)   helper.setImageShape(width,height);
}",0.96
150701,"/** 
 * Loads a pinhole camera model with radian and tangential distortion in OpenCV format
 * @param fileName path to file
 * @return CameraPinholeRadial
 */
public static CameraPinholeRadial loadPinholeRadial(String fileName){
  FileStorage fs=new FileStorage(fileName,FileStorage.READ);
  IntPointer width=new IntPointer(1);
  IntPointer height=new IntPointer(1);
  read(fs.get(""String_Node_Str""),width,-1);
  read(fs.get(""String_Node_Str""),height,-1);
  Mat K=new Mat();
  read(fs.get(""String_Node_Str""),K);
  Mat distortion=new Mat();
  read(fs.get(""String_Node_Str""),distortion);
  CameraPinholeRadial boof=new CameraPinholeRadial();
  boof.width=width.get();
  boof.height=height.get();
  DoubleRawIndexer indexerK=K.createIndexer();
  boof.fx=indexerK.get(0,0);
  boof.skew=indexerK.get(0,1);
  boof.fy=indexerK.get(1,1);
  boof.cx=indexerK.get(0,2);
  boof.cy=indexerK.get(1,2);
  DoubleRawIndexer indexerD=distortion.createIndexer();
  if (distortion.rows() == 5)   boof.setRadial(indexerD.get(0,0),indexerD.get(1,0),indexerD.get(4,0));
 else   if (distortion.rows() >= 2)   boof.setRadial(indexerD.get(0,0),indexerD.get(1,0));
  if (distortion.rows() >= 5)   boof.fsetTangental(indexerD.get(2,0),indexerD.get(3,0));
  return boof;
}","/** 
 * Loads a pinhole camera model with radian and tangential distortion in OpenCV format
 * @param fileName path to file
 * @return CameraPinholeRadial
 */
public static CameraPinholeRadial loadPinholeRadial(String fileName){
  FileStorage fs=new FileStorage(new File(fileName).getAbsolutePath(),FileStorage.READ);
  IntPointer width=new IntPointer(1);
  IntPointer height=new IntPointer(1);
  read(fs.get(""String_Node_Str""),width,-1);
  read(fs.get(""String_Node_Str""),height,-1);
  Mat K=new Mat();
  read(fs.get(""String_Node_Str""),K);
  Mat distortion=new Mat();
  read(fs.get(""String_Node_Str""),distortion);
  CameraPinholeRadial boof=new CameraPinholeRadial();
  boof.width=width.get();
  boof.height=height.get();
  DoubleRawIndexer indexerK=K.createIndexer();
  boof.fx=indexerK.get(0,0);
  boof.skew=indexerK.get(0,1);
  boof.fy=indexerK.get(1,1);
  boof.cx=indexerK.get(0,2);
  boof.cy=indexerK.get(1,2);
  DoubleRawIndexer indexerD=distortion.createIndexer();
  if (distortion.rows() == 5)   boof.setRadial(indexerD.get(0,0),indexerD.get(1,0),indexerD.get(4,0));
 else   if (distortion.rows() >= 2)   boof.setRadial(indexerD.get(0,0),indexerD.get(1,0));
  if (distortion.rows() >= 5)   boof.fsetTangental(indexerD.get(2,0),indexerD.get(3,0));
  return boof;
}",0.988862370723946
150702,"public static void save(CameraPinholeRadial model,String fileName){
  FileStorage fs=new FileStorage(fileName,FileStorage.WRITE);
  DMatrixRMaj K=PerspectiveOps.calibrationMatrix(model,(DMatrixRMaj)null);
  write(fs,""String_Node_Str"",model.width);
  write(fs,""String_Node_Str"",model.height);
  write(fs,""String_Node_Str"",toMat(K));
  DMatrixRMaj D=new DMatrixRMaj(2 + model.radial.length,1);
  D.set(0,0,model.radial[0]);
  D.set(1,0,model.radial[1]);
  D.set(4,0,model.radial[2]);
  D.set(2,0,model.t1);
  D.set(3,0,model.t2);
  write(fs,""String_Node_Str"",toMat(D));
  try {
    fs.close();
  }
 catch (  Exception ignore) {
  }
}","public static void save(CameraPinholeRadial model,String fileName){
  FileStorage fs=new FileStorage(new File(fileName).getAbsolutePath(),FileStorage.WRITE);
  DMatrixRMaj K=PerspectiveOps.calibrationMatrix(model,(DMatrixRMaj)null);
  write(fs,""String_Node_Str"",model.width);
  write(fs,""String_Node_Str"",model.height);
  write(fs,""String_Node_Str"",toMat(K));
  DMatrixRMaj D=new DMatrixRMaj(2 + model.radial.length,1);
  D.set(0,0,model.radial[0]);
  D.set(1,0,model.radial[1]);
  D.set(4,0,model.radial[2]);
  D.set(2,0,model.t1);
  D.set(3,0,model.t2);
  write(fs,""String_Node_Str"",toMat(D));
  try {
    fs.close();
  }
 catch (  Exception ignore) {
  }
}",0.9782945736434108
150703,"@Test public void loadImage_saveImage(){
  BufferedImage orig=new BufferedImage(width,height,BufferedImage.TYPE_BYTE_GRAY);
  for (int i=0; i < height; i++) {
    for (int j=0; j < width; j++) {
      int a=rand.nextInt(255);
      int rgb=a << 16 | a << 8 << a;
      orig.setRGB(j,i,rgb);
    }
  }
  UtilImageIO.saveImage(orig,""String_Node_Str"");
  BufferedImage found=UtilImageIO.loadImage(""String_Node_Str"");
  for (int i=0; i < height; i++) {
    for (int j=0; j < width; j++) {
      int a=orig.getRGB(j,i) & 0xFF;
      int b=found.getRGB(j,i) & 0xFF;
      assertEquals(a,b);
    }
  }
  File f=new File(""String_Node_Str"");
  assertTrue(f.delete());
}","@Test public void loadImage_saveImage() throws IOException {
  BufferedImage orig=new BufferedImage(width,height,BufferedImage.TYPE_BYTE_GRAY);
  for (int i=0; i < height; i++) {
    for (int j=0; j < width; j++) {
      int a=rand.nextInt(255);
      int rgb=a << 16 | a << 8 << a;
      orig.setRGB(j,i,rgb);
    }
  }
  File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  UtilImageIO.saveImage(orig,temp.getPath());
  BufferedImage found=UtilImageIO.loadImage(""String_Node_Str"");
  for (int i=0; i < height; i++) {
    for (int j=0; j < width; j++) {
      int a=orig.getRGB(j,i) & 0xFF;
      int b=found.getRGB(j,i) & 0xFF;
      assertEquals(a,b);
    }
  }
  assertTrue(temp.delete());
}",0.8658892128279884
150704,"@Test public void loadImage_saveImage_PPM() throws IOException {
  Planar<GrayU8> orig=new Planar<>(GrayU8.class,width,height,3);
  GImageMiscOps.fillUniform(orig,rand,0,256);
  UtilImageIO.savePPM(orig,""String_Node_Str"",null);
  Planar<GrayU8> found=UtilImageIO.loadPPM_U8(""String_Node_Str"",null,null);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      for (int k=0; k < 3; k++)       assertEquals(orig.getBand(k).get(x,y),found.getBand(k).get(x,y));
    }
  }
  File f=new File(""String_Node_Str"");
  assertTrue(f.delete());
}","@Test public void loadImage_saveImage_PPM() throws IOException {
  Planar<GrayU8> orig=new Planar<>(GrayU8.class,width,height,3);
  GImageMiscOps.fillUniform(orig,rand,0,256);
  File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  UtilImageIO.savePPM(orig,temp.getPath(),null);
  Planar<GrayU8> found=UtilImageIO.loadPPM_U8(""String_Node_Str"",null,null);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      for (int k=0; k < 3; k++)       assertEquals(orig.getBand(k).get(x,y),found.getBand(k).get(x,y));
    }
  }
  assertTrue(temp.delete());
}",0.8596491228070176
150705,"@Test public void loadImage_saveImage_PGM() throws IOException {
  GrayU8 orig=new GrayU8(width,height);
  GImageMiscOps.fillUniform(orig,rand,0,256);
  UtilImageIO.savePGM(orig,""String_Node_Str"");
  GrayU8 found=UtilImageIO.loadPGM_U8(""String_Node_Str"",null);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      assertEquals(orig.get(x,y),found.get(x,y));
    }
  }
  File f=new File(""String_Node_Str"");
  assertTrue(f.delete());
}","@Test public void loadImage_saveImage_PGM() throws IOException {
  GrayU8 orig=new GrayU8(width,height);
  GImageMiscOps.fillUniform(orig,rand,0,256);
  File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  UtilImageIO.savePGM(orig,temp.getPath());
  GrayU8 found=UtilImageIO.loadPGM_U8(""String_Node_Str"",null);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      assertEquals(orig.get(x,y),found.get(x,y));
    }
  }
  assertTrue(temp.delete());
}",0.8477801268498943
150706,"/** 
 * Configures the detector
 * @param minimumSpread If the difference between min max is less than or equal to thisvalue then it is considered textureless.  Set to <= -1 to disable.
 * @param requestedBlockWidth About how wide and tall you wish a block to be in pixels.
 */
public ThresholdSquareBlockMinMax(double minimumSpread,int requestedBlockWidth){
  this.minimumSpread=minimumSpread;
  this.requestedBlockWidth=requestedBlockWidth;
}","/** 
 * Configures the detector
 * @param minimumSpread If the difference between min max is less than or equal to thisvalue then it is considered textureless.  Set to &le; -1 to disable.
 * @param requestedBlockWidth About how wide and tall you wish a block to be in pixels.
 */
public ThresholdSquareBlockMinMax(double minimumSpread,int requestedBlockWidth){
  this.minimumSpread=minimumSpread;
  this.requestedBlockWidth=requestedBlockWidth;
}",0.9932584269662922
150707,"public static <T extends ImageGray<T>>InputToBinary<T> localSquareBlockMinMax(int regionWidth,double scale,boolean down,double minimumSpread,Class<T> inputType){
  return new LocalSquareBlockMinMaxBinaryFilter<>(minimumSpread,regionWidth,scale,down,inputType);
}","/** 
 * Applies a very fast non-overlapping block thresholding algorithm which uses min/max statistics.
 * @see ThresholdSquareBlockMinMax
 * @param scale Scale factor adjust for threshold.  1.0 means no change.
 * @param down Should it threshold up or down.
 * @param minimumSpread If the difference between min max is less than or equal to thisvalue then it is considered textureless.  Set to &le; -1 to disable.
 * @param regionWidth About how wide and tall you wish a block to be in pixels.
 * @param inputType Type of input image
 * @return Filter to binary
 */
public static <T extends ImageGray<T>>InputToBinary<T> localSquareBlockMinMax(int regionWidth,double scale,boolean down,double minimumSpread,Class<T> inputType){
  return new LocalSquareBlockMinMaxBinaryFilter<>(minimumSpread,regionWidth,scale,down,inputType);
}",0.4802933088909257
150708,"/** 
 * Make sure the requested VFOV is the actual
 */
@Test public void checkFOV(){
  CylinderToEquirectangular_F32 alg=new CylinderToEquirectangular_F32();
  alg.setEquirectangularShape(400,500);
  alg.configure(200,300,UtilAngle.radian(100));
  GeoLL_F32 ll=new GeoLL_F32();
  alg.compute(100,0);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  float lon0=ll.lon;
  alg.compute(100,299);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  float lon1=ll.lon;
  assertEquals(UtilAngle.radian(100),lon1 - lon0,GrlConstants.TEST_F32);
}","/** 
 * Make sure the requested VFOV is the actual
 */
@Test public void checkFOV(){
  CylinderToEquirectangular_F32 alg=new CylinderToEquirectangular_F32();
  alg.setEquirectangularShape(400,500);
  alg.configure(200,300,UtilAngle.radian(100));
  GeoLL_F32 ll=new GeoLL_F32();
  alg.compute(100,0);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  double lat0=ll.lat;
  alg.compute(100,299);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  double lat1=ll.lat;
  assertEquals(UtilAngle.radian(100),lat1 - lat0,GrlConstants.TEST_F64);
}",0.9473684210526316
150709,"/** 
 * Make sure the requested VFOV is the actual
 */
@Test public void checkFOV(){
  CylinderToEquirectangular_F64 alg=new CylinderToEquirectangular_F64();
  alg.setEquirectangularShape(400,500);
  alg.configure(200,300,UtilAngle.radian(100));
  GeoLL_F64 ll=new GeoLL_F64();
  alg.compute(100,0);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  double lon0=ll.lon;
  alg.compute(100,299);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  double lon1=ll.lon;
  assertEquals(UtilAngle.radian(100),lon1 - lon0,GrlConstants.TEST_F64);
}","/** 
 * Make sure the requested VFOV is the actual
 */
@Test public void checkFOV(){
  CylinderToEquirectangular_F64 alg=new CylinderToEquirectangular_F64();
  alg.setEquirectangularShape(400,500);
  alg.configure(200,300,UtilAngle.radian(100));
  GeoLL_F64 ll=new GeoLL_F64();
  alg.compute(100,0);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  double lat0=ll.lat;
  alg.compute(100,299);
  alg.getTools().equiToLatLon(alg.distX,alg.distY,ll);
  double lat1=ll.lat;
  assertEquals(UtilAngle.radian(100),lat1 - lat0,GrlConstants.TEST_F64);
}",0.9782608695652174
150710,"/** 
 * Computes tangent points to the two ellipses specified by the grid coordinates
 */
private boolean addTangents(Grid grid,int rowA,int colA,int rowB,int colB){
  EllipseRotated_F64 a=grid.get(rowA,colA);
  EllipseRotated_F64 b=grid.get(rowB,colB);
  if (!tangentFinder.process(a,b,A0,A1,A2,A3,B0,B1,B2,B3)) {
    return false;
  }
  Tangents ta=tangents.get(grid.getIndexOfRegEllipse(rowA,colA));
  Tangents tb=tangents.get(grid.getIndexOfRegEllipse(rowB,colB));
  if (rowA == rowB) {
    ta.t[ta.countT++].set(A0);
    ta.b[ta.countB++].set(A3);
    tb.t[tb.countT++].set(B0);
    tb.b[tb.countB++].set(B3);
  }
 else {
    ta.r[ta.countL++].set(A0);
    ta.l[ta.countR++].set(A3);
    tb.r[tb.countL++].set(B0);
    tb.l[tb.countR++].set(B3);
  }
  return true;
}","/** 
 * Computes tangent points to the two ellipses specified by the grid coordinates
 */
private boolean addTangents(Grid grid,int rowA,int colA,int rowB,int colB){
  EllipseRotated_F64 a=grid.get(rowA,colA);
  EllipseRotated_F64 b=grid.get(rowB,colB);
  if (!tangentFinder.process(a,b,A0,A1,A2,A3,B0,B1,B2,B3)) {
    return false;
  }
  Tangents ta=tangents.get(grid.getIndexOfRegEllipse(rowA,colA));
  Tangents tb=tangents.get(grid.getIndexOfRegEllipse(rowB,colB));
  double slopeX=b.center.x - a.center.x;
  double slopeY=b.center.y - a.center.y;
  double dx0=A0.x - a.center.x;
  double dy0=A0.y - a.center.y;
  double z=slopeX * dy0 - slopeY * dx0;
  if (z < 0 == (rowA == rowB)) {
    Point2D_F64 tmp=A0;
    A0=A3;
    A3=tmp;
    tmp=B0;
    B0=B3;
    B3=tmp;
  }
  if (rowA == rowB) {
    ta.t[ta.countT++].set(A0);
    ta.b[ta.countB++].set(A3);
    tb.t[tb.countT++].set(B0);
    tb.b[tb.countB++].set(B3);
  }
 else {
    ta.r[ta.countL++].set(A0);
    ta.l[ta.countR++].set(A3);
    tb.r[tb.countL++].set(B0);
    tb.l[tb.countR++].set(B3);
  }
  return true;
}",0.8348673524634542
150711,"@Test public void all(){
  int numRows=3, numCols=4;
  double space=3, r=1;
  Grid g=createGrid(numRows,numCols,space,r);
  KeyPointsCircleRegularGrid alg=new KeyPointsCircleRegularGrid();
  alg.process(g);
  int index=0;
  for (int row=0; row < numRows; row++) {
    for (int col=0; col < numCols; col++) {
      double cx=col * space;
      double cy=row * space;
      Point2D_F64 a=alg.getKeyPoints().get(index++);
      Point2D_F64 b=alg.getKeyPoints().get(index++);
      Point2D_F64 c=alg.getKeyPoints().get(index++);
      Point2D_F64 d=alg.getKeyPoints().get(index++);
      assertTrue(a.distance(cx,cy + r) <= BoofDefaults.TEST_DOUBLE_TOL);
      assertTrue(b.distance(cx + r,cy) <= BoofDefaults.TEST_DOUBLE_TOL);
      assertTrue(c.distance(cx,cy - r) <= BoofDefaults.TEST_DOUBLE_TOL);
      assertTrue(d.distance(cx - r,cy) <= BoofDefaults.TEST_DOUBLE_TOL);
    }
  }
}","public void all(Affine2D_F64 affine){
  int numRows=3, numCols=4;
  double space=3, r=1;
  Grid g=createGrid(numRows,numCols,space,r);
  transform(affine,g);
  KeyPointsCircleRegularGrid alg=new KeyPointsCircleRegularGrid();
  alg.process(g);
  Point2D_F64 p=new Point2D_F64();
  int index=0;
  for (int row=0; row < numRows; row++) {
    for (int col=0; col < numCols; col++) {
      double cx=col * space;
      double cy=row * space;
      Point2D_F64 a=alg.getKeyPoints().get(index++);
      Point2D_F64 b=alg.getKeyPoints().get(index++);
      Point2D_F64 c=alg.getKeyPoints().get(index++);
      Point2D_F64 d=alg.getKeyPoints().get(index++);
      AffinePointOps_F64.transform(affine,cx,cy + r,p);
      assertTrue(a.distance(p.x,p.y) <= BoofDefaults.TEST_DOUBLE_TOL);
      AffinePointOps_F64.transform(affine,cx + r,cy,p);
      assertTrue(b.distance(p.x,p.y) <= BoofDefaults.TEST_DOUBLE_TOL);
      AffinePointOps_F64.transform(affine,cx,cy - r,p);
      assertTrue(c.distance(p.x,p.y) <= BoofDefaults.TEST_DOUBLE_TOL);
      AffinePointOps_F64.transform(affine,cx - r,cy,p);
      assertTrue(d.distance(p.x,p.y) <= BoofDefaults.TEST_DOUBLE_TOL);
    }
  }
}",0.3250366032210834
150712,"@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered.getWidth(),buffered.getHeight(),work,buffered.getType());
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=guiImage.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          guiImage.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
  binary.reshape(input.width,input.height);
  labeled.reshape(input.width,input.height);
  inputToBinary.process((T)input,binary);
synchronized (this) {
    contourAlg.process(binary,labeled);
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      viewUpdated();
    }
  }
);
}","@Override public void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered,work);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=guiImage.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          guiImage.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
  binary.reshape(input.width,input.height);
  labeled.reshape(input.width,input.height);
  inputToBinary.process((T)input,binary);
synchronized (this) {
    contourAlg.process(binary,labeled);
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      viewUpdated();
    }
  }
);
}",0.9728289824187534
150713,"@Override public synchronized void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkCopy(buffered,work);
    this.original.createGraphics().drawImage(buffered,0,0,null);
    binary.reshape(work.getWidth(),work.getHeight());
    inputPrev.setTo((T)input);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=guiImage.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          guiImage.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
 else {
    input=inputPrev;
  }
  inputToBinary.process((T)input,binary);
  detector.process((T)input,binary);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      viewUpdated();
    }
  }
);
}","@Override public synchronized void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered,work);
    binary.reshape(work.getWidth(),work.getHeight());
    inputPrev.setTo((T)input);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=guiImage.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          guiImage.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
 else {
    input=inputPrev;
  }
  inputToBinary.process((T)input,binary);
  detector.process((T)input,binary);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      viewUpdated();
    }
  }
);
}",0.412748171368861
150714,"@Override public synchronized void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered.getWidth(),buffered.getHeight(),work,buffered.getType());
    binary.reshape(work.getWidth(),work.getHeight());
    inputPrev.setTo((T)input);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=guiImage.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          guiImage.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
 else {
    input=inputPrev;
  }
  inputToBinary.process((T)input,binary);
  detector.process((T)input,binary);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      viewUpdated();
    }
  }
);
}","@Override public synchronized void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered,work);
    binary.reshape(work.getWidth(),work.getHeight());
    inputPrev.setTo((T)input);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=guiImage.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          guiImage.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
 else {
    input=inputPrev;
  }
  inputToBinary.process((T)input,binary);
  detector.process((T)input,binary);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      viewUpdated();
    }
  }
);
}",0.9732002101944298
150715,"@Override public synchronized void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered.getWidth(),buffered.getHeight(),work,buffered.getType());
    binary.reshape(input.getWidth(),input.getHeight());
    filtered.reshape(input.getWidth(),input.getHeight());
    inputPrev.setTo((GrayU8)input);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=gui.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          gui.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
 else {
    input=inputPrev;
  }
  process((GrayU8)input);
}","@Override public synchronized void processImage(int sourceID,long frameID,final BufferedImage buffered,ImageBase input){
  if (buffered != null) {
    original=ConvertBufferedImage.checkCopy(buffered,original);
    work=ConvertBufferedImage.checkDeclare(buffered,work);
    binary.reshape(input.getWidth(),input.getHeight());
    filtered.reshape(input.getWidth(),input.getHeight());
    inputPrev.setTo((GrayU8)input);
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        Dimension d=gui.getPreferredSize();
        if (d.getWidth() < buffered.getWidth() || d.getHeight() < buffered.getHeight()) {
          gui.setPreferredSize(new Dimension(buffered.getWidth(),buffered.getHeight()));
        }
      }
    }
);
  }
 else {
    input=inputPrev;
  }
  process((GrayU8)input);
}",0.9696969696969696
150716,"/** 
 * If the provided image does not have the same shape and same type a new one is declared and returned.
 */
public static BufferedImage checkDeclare(int width,int height,BufferedImage image,int type){
  if (image == null)   return new BufferedImage(width,height,type);
  if (image.getType() != type)   return new BufferedImage(width,height,type);
  if (image.getWidth() != width || image.getHeight() != height)   return new BufferedImage(width,height,type);
  return image;
}","public static BufferedImage checkDeclare(BufferedImage template,BufferedImage target){
  int width=template.getWidth();
  int height=template.getHeight();
  int type=template.getType();
  if (type == 0) {
    if (target != null)     type=target.getType();
 else     type=BufferedImage.TYPE_INT_RGB;
  }
  if (target == null)   return new BufferedImage(width,height,type);
  if (target.getType() != type)   return new BufferedImage(width,height,type);
  if (target.getWidth() != width || target.getHeight() != height)   return new BufferedImage(width,height,type);
  return target;
}",0.3182674199623352
150717,"/** 
 * Specifies the input image size and the size of the grid it will use to approximate the idea solution. All control points are discarded
 * @param width Image width
 * @param height Image height
 * @param gridRows grid rows
 * @param gridCols grid columns
 */
public void configure(int width,int height,int gridRows,int gridCols){
  int s=Math.max(width,height);
  scaleX=s / (float)(gridCols - 1);
  scaleY=s / (float)(gridRows - 1);
  if (gridRows > gridCols) {
    scaleY/=gridCols / (float)gridRows;
  }
 else {
    scaleX/=gridRows / (float)gridCols;
  }
  this.gridRows=gridRows;
  this.gridCols=gridCols;
  grid.resize(gridCols * gridRows);
  reset();
}","/** 
 * Specifies the input image size and the size of the grid it will use to approximate the idea solution. All control points are discarded
 * @param width Image width
 * @param height Image height
 * @param gridRows grid rows
 * @param gridCols grid columns
 */
public void configure(int width,int height,int gridRows,int gridCols){
  int s=Math.max(width,height);
  scaleX=s / (float)(gridCols - 1);
  scaleY=s / (float)(gridRows - 1);
  if (gridRows > gridCols) {
    scaleY/=(gridCols - 1) / (float)(gridRows - 1);
  }
 else {
    scaleX/=(gridRows - 1) / (float)(gridCols - 1);
  }
  this.gridRows=gridRows;
  this.gridCols=gridCols;
  grid.resize(gridCols * gridRows);
  reset();
}",0.9056047197640118
150718,"/** 
 * Makes sure modifying a single points is the same as modifying all the points at once
 */
@Test public void individualSrcSameAsAll(){
  fail(""String_Node_Str"");
}","/** 
 * Makes sure modifying a single points is the same as modifying all the points at once
 */
@Test public void individualSrcSameAsAll(){
  List<Point2D_F32> src=createTestPoints();
  List<Point2D_F32> dst=createTestPoints();
  PointDeformKeyPoints alg=createAlgorithm();
  alg.setImageShape(80,100);
  alg.setSource(src);
  alg.setSource(dst);
  alg.setSource(1,20,25);
  Point2D_F32 expected=new Point2D_F32();
  alg.compute(12,19.5f,expected);
  src.get(1).set(20,25);
  Point2D_F32 found=new Point2D_F32();
  alg.compute(12,19.5f,found);
  assertEquals(expected.x,found.x,GrlConstants.FLOAT_TEST_TOL);
  assertEquals(expected.y,found.y,GrlConstants.FLOAT_TEST_TOL);
}",0.3487544483985765
150719,"/** 
 * Sees if a local copy of inputs points is not made
 */
@Test public void checkPointsCopied(){
  fail(""String_Node_Str"");
}","/** 
 * Sees if a local copy of inputs points is not made
 */
@Test public void checkPointsCopied(){
  List<Point2D_F32> src=createTestPoints();
  List<Point2D_F32> dst=createTestPoints();
  PointDeformKeyPoints alg=createAlgorithm();
  alg.setImageShape(80,100);
  alg.setSource(src);
  alg.setSource(dst);
  Point2D_F32 expected=new Point2D_F32();
  alg.compute(12,19.5f,expected);
  for (int i=0; i < src.size(); i++) {
    src.get(i).x+=2.5;
    dst.get(i).x+=2.5;
  }
  Point2D_F32 found=new Point2D_F32();
  alg.compute(12,19.5f,found);
  assertEquals(expected.x,found.x,GrlConstants.FLOAT_TEST_TOL);
  assertEquals(expected.y,found.y,GrlConstants.FLOAT_TEST_TOL);
}",0.264669163545568
150720,"/** 
 * Makes sure modifying a single points is the same as modifying all the points at once
 */
@Test public void individualDstSameAsAll(){
  fail(""String_Node_Str"");
}","/** 
 * Makes sure modifying a single points is the same as modifying all the points at once
 */
@Test public void individualDstSameAsAll(){
  List<Point2D_F32> src=createTestPoints();
  List<Point2D_F32> dst=createTestPoints();
  PointDeformKeyPoints alg=createAlgorithm();
  alg.setImageShape(80,100);
  alg.setSource(src);
  alg.setSource(dst);
  alg.setDestination(1,20,25);
  Point2D_F32 expected=new Point2D_F32();
  alg.compute(12,19.5f,expected);
  dst.get(1).set(20,25);
  Point2D_F32 found=new Point2D_F32();
  alg.compute(12,19.5f,found);
  assertEquals(expected.x,found.x,GrlConstants.FLOAT_TEST_TOL);
  assertEquals(expected.y,found.y,GrlConstants.FLOAT_TEST_TOL);
}",0.3514150943396226
150721,"@Override public void mouseDragged(MouseEvent e){
  if (active < 0)   return;
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
synchronized (pointsUndistorted) {
    Point2D_F32 u;
    if (selectedUndist) {
      u=pointsUndistorted.get(active);
    }
 else {
      u=pointsDistorted.get(active);
    }
    u.set(x,y);
  }
  controlPointsModified();
}","@Override public void mouseDragged(MouseEvent e){
  if (!SwingUtilities.isLeftMouseButton(e))   return;
  if (active < 0)   return;
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
synchronized (pointsUndistorted) {
    Point2D_F32 u;
    if (selectedUndist) {
      u=pointsUndistorted.get(active);
    }
 else {
      u=pointsDistorted.get(active);
    }
    u.set(x,y);
  }
  controlPointsModified();
}",0.9330024813895782
150722,"@Override public void mousePressed(MouseEvent e){
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
  active=-1;
synchronized (pointsUndistorted) {
    for (int i=0; i < pointsDistorted.size(); i++) {
      Point2D_F32 p=pointsDistorted.get(i);
      if (p.distance(x,y) <= clickTol) {
        active=i;
        selectedUndist=false;
      }
    }
    if (active < 0) {
      for (int i=0; i < pointsUndistorted.size(); i++) {
        Point2D_F32 p=pointsUndistorted.get(i);
        if (p.distance(x,y) <= clickTol) {
          active=i;
          selectedUndist=true;
        }
      }
    }
    if (active < 0) {
      active=pointsDistorted.size();
      selectedUndist=false;
      pointsUndistorted.add(new Point2D_F32(x,y));
      pointsDistorted.add(new Point2D_F32(x,y));
      controlPointsModified();
    }
  }
}","@Override public void mousePressed(MouseEvent e){
  if (!SwingUtilities.isLeftMouseButton(e))   return;
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
  active=-1;
synchronized (pointsUndistorted) {
    for (int i=0; i < pointsDistorted.size(); i++) {
      Point2D_F32 p=pointsDistorted.get(i);
      if (p.distance(x,y) <= clickTol) {
        active=i;
        selectedUndist=false;
      }
    }
    if (active < 0) {
      for (int i=0; i < pointsUndistorted.size(); i++) {
        Point2D_F32 p=pointsUndistorted.get(i);
        if (p.distance(x,y) <= clickTol) {
          active=i;
          selectedUndist=true;
        }
      }
    }
    if (active < 0) {
      active=pointsDistorted.size();
      selectedUndist=false;
      pointsUndistorted.add(new Point2D_F32(x,y));
      pointsDistorted.add(new Point2D_F32(x,y));
      controlPointsModified();
    }
  }
}",0.9690721649484536
150723,"@Override public void mouseReleased(MouseEvent e){
  if (active < 0)   return;
  active=-1;
  repaint();
}","@Override public void mouseReleased(MouseEvent e){
  if (!SwingUtilities.isLeftMouseButton(e))   return;
  if (active < 0)   return;
  active=-1;
  repaint();
}",0.7969924812030075
150724,"/** 
 * Specifies the input image size and the size of the grid it will use to approximate the idea solution. All control points are discarded
 * @param width Image width
 * @param height Image height
 * @param gridRows grid rows
 * @param gridCols grid columns
 */
public void configure(int width,int height,int gridRows,int gridCols){
  scaleX=width / (float)(gridCols - 1);
  scaleY=height / (float)(gridRows - 1);
  this.gridRows=gridRows;
  this.gridCols=gridCols;
  grid.resize(gridCols * gridRows);
  reset();
}","/** 
 * Specifies the input image size and the size of the grid it will use to approximate the idea solution. All control points are discarded
 * @param width Image width
 * @param height Image height
 * @param gridRows grid rows
 * @param gridCols grid columns
 */
public void configure(int width,int height,int gridRows,int gridCols){
  scaleX=width / (float)(gridCols - 1);
  scaleY=height / (float)(gridRows - 1);
  float ratioX, ratioY;
  if (gridRows > gridCols) {
    ratioX=1.0f;
    ratioY=gridCols / (float)gridRows;
  }
 else {
    ratioX=gridRows / (float)gridCols;
    ratioY=1.0f;
  }
  scaleX/=ratioX;
  scaleY/=ratioY;
  this.gridRows=gridRows;
  this.gridCols=gridCols;
  grid.resize(gridCols * gridRows);
  reset();
}",0.7406225059856345
150725,"/** 
 * When sampled exactly on a control point the distortion should be the distortion for that point
 */
@Test public void testAllAtOnce_OnControlPoints(){
  ImageDeformPointMLS_F32 alg=new ImageDeformPointMLS_F32(TypeDeformMLS.AFFINE);
  alg.configure(width,height,rows,cols);
  alg.addControl(5,5.45455f);
  alg.addControl(10,21.818182f);
  alg.addControl(30,49.090908f);
  alg.addControl(15,5.4545455f);
  alg.setDistorted(0,10,12);
  alg.setDistorted(1,14,30);
  alg.setDistorted(2,25,45);
  alg.setDistorted(3,20,8);
  alg.fixateUndistorted();
  alg.fixateDistorted();
  checkCompute(5,5.45455f,10,12,alg);
  checkCompute(10,21.818182f,14,30,alg);
  checkCompute(30,49.090908f,25,45,alg);
  checkCompute(15,5.4545455f,20,8,alg);
}","/** 
 * When sampled exactly on a control point the distortion should be the distortion for that point
 */
@Test public void testAllAtOnce_OnControlPoints(){
  ImageDeformPointMLS_F32 alg=new ImageDeformPointMLS_F32(TypeDeformMLS.AFFINE);
  alg.configure(width,height,rows,cols);
  alg.addControl(5,5.45455f);
  alg.addControl(10,21.818182f);
  alg.addControl(30,49.090908f);
  alg.addControl(15,5.4545455f);
  alg.setDistorted(0,10,12);
  alg.setDistorted(1,14,30);
  alg.setDistorted(2,25,45);
  alg.setDistorted(3,20,8);
  alg.fixateUndistorted();
  alg.fixateDistorted();
  checkCompute(5,5.45455f,10,12,alg);
  checkCompute(10,21.818182f,14,30,alg);
  checkCompute(30,49.090908f,25,45,alg);
  checkCompute(15,5.4545455f,20,8,alg);
  fail(""String_Node_Str"");
}",0.9820119920053296
150726,"/** 
 * The distorted control points are at the same location
 */
@Test public void testAllAtOnce_noChange(){
  ImageDeformPointMLS_F32 alg=new ImageDeformPointMLS_F32(TypeDeformMLS.AFFINE);
  alg.configure(width,height,rows,cols);
  alg.addControl(5,5);
  alg.addControl(10,20);
  alg.addControl(30,50);
  alg.addControl(16,0);
  checkNoTransform(alg);
}","/** 
 * The distorted control points are at the same location
 */
@Test public void testAllAtOnce_noChange(){
  ImageDeformPointMLS_F32 alg=new ImageDeformPointMLS_F32(TypeDeformMLS.AFFINE);
  alg.configure(width,height,rows,cols);
  alg.addControl(5,5);
  alg.addControl(10,20);
  alg.addControl(30,50);
  alg.addControl(16,0);
  checkNoTransform(alg);
  fail(""String_Node_Str"");
}",0.9633649932157394
150727,"/** 
 * See if the distorted point is closer to the closest control point
 */
@Test public void testAllAtOnce_CloserToCloser(){
  ImageDeformPointMLS_F32 alg=new ImageDeformPointMLS_F32(TypeDeformMLS.AFFINE);
  alg.configure(width,height,rows,cols);
  alg.addControl(5,5);
  alg.addControl(10,20);
  alg.addControl(30,50);
  alg.addControl(16,0);
  alg.setDistorted(0,10,12);
  alg.setDistorted(1,14,30);
  alg.setDistorted(2,25,45);
  alg.setDistorted(3,20,8);
  alg.fixateUndistorted();
  alg.fixateDistorted();
  Point2D_F32 a=new Point2D_F32();
  Point2D_F32 b=new Point2D_F32();
  alg.compute(4,4,a);
  alg.compute(1,4,b);
  float distA=a.distance(10,12);
  float distB=b.distance(10,12);
  assertTrue(distA < distB);
}","/** 
 * See if the distorted point is closer to the closest control point
 */
@Test public void testAllAtOnce_CloserToCloser(){
  ImageDeformPointMLS_F32 alg=new ImageDeformPointMLS_F32(TypeDeformMLS.AFFINE);
  alg.configure(width,height,rows,cols);
  alg.addControl(5,5);
  alg.addControl(10,20);
  alg.addControl(30,50);
  alg.addControl(16,0);
  alg.setDistorted(0,10,12);
  alg.setDistorted(1,14,30);
  alg.setDistorted(2,25,45);
  alg.setDistorted(3,20,8);
  alg.fixateUndistorted();
  alg.fixateDistorted();
  Point2D_F32 a=new Point2D_F32();
  Point2D_F32 b=new Point2D_F32();
  alg.compute(4,4,a);
  alg.compute(1,4,b);
  float distA=a.distance(10,12);
  float distB=b.distance(10,12);
  assertTrue(distA < distB);
  fail(""String_Node_Str"");
}",0.9816949152542372
150728,"/** 
 * Converts the buffered image into an   {@link Planar} image of the specified ype.
 * @param src Input image. Not modified.
 * @param dst Output. The converted image is written to.  If null a new unsigned image is created.
 * @param orderRgb If applicable, should it adjust the ordering of each color band to maintain color consistency.Most of the time you want this to be true.
 * @param type Which type of data structure is each band. (GrayU8 or GrayF32)
 * @return Converted image.
 */
public static <T extends ImageGray<T>>Planar<T> convertFromPlanar(BufferedImage src,Planar<T> dst,boolean orderRgb,Class<T> type){
  if (src == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (dst != null) {
    dst.reshape(src.getWidth(),dst.getHeight());
  }
  try {
    WritableRaster raster=src.getRaster();
    int numBands;
    if (src.getType() == BufferedImage.TYPE_BYTE_INDEXED)     numBands=3;
 else     numBands=raster.getNumBands();
    if (dst == null)     dst=new Planar<>(type,src.getWidth(),src.getHeight(),numBands);
 else     if (dst.getNumBands() != numBands)     dst.setNumberOfBands(numBands);
    if (type == GrayU8.class) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          for (int i=0; i < dst.getNumBands(); i++)           ConvertRaster.bufferedToGray(src,((Planar<GrayU8>)dst).getBand(i));
        }
 else {
          ConvertRaster.bufferedToMulti_U8((ByteInterleavedRaster)src.getRaster(),(Planar<GrayU8>)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToMulti_U8((IntegerInterleavedRaster)src.getRaster(),(Planar<GrayU8>)dst);
      }
 else {
        ConvertRaster.bufferedToMulti_U8(src,(Planar<GrayU8>)dst);
      }
    }
 else     if (type == GrayF32.class) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          for (int i=0; i < dst.getNumBands(); i++)           ConvertRaster.bufferedToGray(src,((Planar<GrayF32>)dst).getBand(i));
        }
 else {
          ConvertRaster.bufferedToMulti_F32((ByteInterleavedRaster)src.getRaster(),(Planar<GrayF32>)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToMulti_F32((IntegerInterleavedRaster)src.getRaster(),(Planar<GrayF32>)dst);
      }
 else {
        ConvertRaster.bufferedToMulti_F32(src,(Planar<GrayF32>)dst);
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 catch (  java.security.AccessControlException e) {
    if (dst == null)     dst=new Planar<>(type,src.getWidth(),src.getHeight(),3);
 else {
      dst.setNumberOfBands(3);
    }
    if (type == GrayU8.class) {
      ConvertRaster.bufferedToMulti_U8(src,(Planar<GrayU8>)dst);
    }
 else     if (type == GrayF32.class) {
      ConvertRaster.bufferedToMulti_F32(src,(Planar<GrayF32>)dst);
    }
  }
  if (orderRgb) {
    orderBandsIntoRGB(dst,src);
  }
  return dst;
}","/** 
 * Converts the buffered image into an   {@link Planar} image of the specified ype.
 * @param src Input image. Not modified.
 * @param dst Output. The converted image is written to.  If null a new unsigned image is created.
 * @param orderRgb If applicable, should it adjust the ordering of each color band to maintain color consistency.Most of the time you want this to be true.
 * @param type Which type of data structure is each band. (GrayU8 or GrayF32)
 * @return Converted image.
 */
public static <T extends ImageGray<T>>Planar<T> convertFromPlanar(BufferedImage src,Planar<T> dst,boolean orderRgb,Class<T> type){
  if (src == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (dst != null) {
    dst.reshape(src.getWidth(),src.getHeight());
  }
  try {
    WritableRaster raster=src.getRaster();
    int numBands;
    if (src.getType() == BufferedImage.TYPE_BYTE_INDEXED)     numBands=3;
 else     numBands=raster.getNumBands();
    if (dst == null)     dst=new Planar<>(type,src.getWidth(),src.getHeight(),numBands);
 else     if (dst.getNumBands() != numBands)     dst.setNumberOfBands(numBands);
    if (type == GrayU8.class) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          for (int i=0; i < dst.getNumBands(); i++)           ConvertRaster.bufferedToGray(src,((Planar<GrayU8>)dst).getBand(i));
        }
 else {
          ConvertRaster.bufferedToMulti_U8((ByteInterleavedRaster)src.getRaster(),(Planar<GrayU8>)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToMulti_U8((IntegerInterleavedRaster)src.getRaster(),(Planar<GrayU8>)dst);
      }
 else {
        ConvertRaster.bufferedToMulti_U8(src,(Planar<GrayU8>)dst);
      }
    }
 else     if (type == GrayF32.class) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          for (int i=0; i < dst.getNumBands(); i++)           ConvertRaster.bufferedToGray(src,((Planar<GrayF32>)dst).getBand(i));
        }
 else {
          ConvertRaster.bufferedToMulti_F32((ByteInterleavedRaster)src.getRaster(),(Planar<GrayF32>)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToMulti_F32((IntegerInterleavedRaster)src.getRaster(),(Planar<GrayF32>)dst);
      }
 else {
        ConvertRaster.bufferedToMulti_F32(src,(Planar<GrayF32>)dst);
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 catch (  java.security.AccessControlException e) {
    if (dst == null)     dst=new Planar<>(type,src.getWidth(),src.getHeight(),3);
 else {
      dst.setNumberOfBands(3);
    }
    if (type == GrayU8.class) {
      ConvertRaster.bufferedToMulti_U8(src,(Planar<GrayU8>)dst);
    }
 else     if (type == GrayF32.class) {
      ConvertRaster.bufferedToMulti_F32(src,(Planar<GrayF32>)dst);
    }
  }
  if (orderRgb) {
    orderBandsIntoRGB(dst,src);
  }
  return dst;
}",0.9990595611285268
150729,"private void controlPointsModified(boolean justDistorted){
synchronized (pointsUndistorted) {
    try {
      if (!justDistorted) {
        alg.setKeyPoints(pointsUndistorted);
        validTransform=true;
      }
      System.out.println(""String_Node_Str"");
      alg.setDistorted(pointsDistorted);
    }
 catch (    RuntimeException e) {
      System.out.println(""String_Node_Str"");
      validTransform=false;
    }
  }
  distortImage.setModel(p2p);
  if (inputMethod == InputMethod.IMAGE) {
    renderDistorted(distortedBuff,undistorted);
  }
  gui.repaint();
}","private void controlPointsModified(){
synchronized (pointsUndistorted) {
    try {
      alg.setSource(pointsDistorted);
      alg.setDestination(pointsUndistorted);
      validTransform=true;
    }
 catch (    RuntimeException e) {
      System.out.println(""String_Node_Str"" + e.getMessage());
      System.out.println(""String_Node_Str"" + pointsDistorted.size());
      validTransform=false;
    }
  }
  distortImage.setModel(p2p);
  if (inputMethod == InputMethod.IMAGE) {
    renderDistorted(distortedBuff,undistorted);
  }
  gui.repaint();
}",0.7423423423423423
150730,"@Override public void mouseDragged(MouseEvent e){
  if (active < 0)   return;
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
synchronized (pointsUndistorted) {
    Point2D_F32 u=pointsDistorted.get(active);
    u.set(x,y);
  }
  controlPointsModified(true);
}","@Override public void mouseDragged(MouseEvent e){
  if (active < 0)   return;
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
synchronized (pointsUndistorted) {
    Point2D_F32 u;
    if (selectedUndist) {
      u=pointsUndistorted.get(active);
    }
 else {
      u=pointsDistorted.get(active);
    }
    u.set(x,y);
  }
  controlPointsModified();
}",0.851963746223565
150731,"@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (pointsUndistorted) {
    g2.setStroke(strokeThin);
    g2.setColor(Color.GRAY);
    for (int i=0; i < pointsUndistorted.size(); i++) {
      Point2D_F32 u=pointsUndistorted.get(i);
      Point2D_F32 d=pointsDistorted.get(i);
      line.setLine(u.x * scale,u.y * scale,d.x * scale,d.y * scale);
      g2.draw(line);
    }
    double r=clickTol / 2.0;
    g2.setStroke(strokeThick);
    g2.setColor(Color.RED);
    for (int i=0; i < pointsUndistorted.size(); i++) {
      Point2D_F32 p=pointsUndistorted.get(i);
      c.setFrame(p.x * scale - r,p.y * scale - r,2 * r,2 * r);
      g2.draw(c);
    }
    g2.setColor(Color.BLUE);
    for (int i=0; i < pointsDistorted.size(); i++) {
      Point2D_F32 p=pointsDistorted.get(i);
      c.setFrame(p.x * scale - r,p.y * scale - r,2 * r,2 * r);
      g2.draw(c);
    }
  }
}","@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (pointsUndistorted) {
    g2.setStroke(strokeThin);
    g2.setColor(Color.GRAY);
    for (int i=0; i < pointsUndistorted.size(); i++) {
      if (active != -1 && i != active)       continue;
      Point2D_F32 u=pointsUndistorted.get(i);
      Point2D_F32 d=pointsDistorted.get(i);
      line.setLine(u.x * scale,u.y * scale,d.x * scale,d.y * scale);
      g2.draw(line);
    }
    double r=clickTol / 2.0;
    g2.setStroke(strokeThick);
    g2.setColor(Color.RED);
    for (int i=0; i < pointsUndistorted.size(); i++) {
      if (active != -1 && i != active)       continue;
      Point2D_F32 p=pointsUndistorted.get(i);
      c.setFrame(p.x * scale - r,p.y * scale - r,2 * r,2 * r);
      g2.draw(c);
    }
    g2.setColor(Color.BLUE);
    for (int i=0; i < pointsDistorted.size(); i++) {
      if (active != -1 && i != active)       continue;
      Point2D_F32 p=pointsDistorted.get(i);
      c.setFrame(p.x * scale - r,p.y * scale - r,2 * r,2 * r);
      g2.draw(c);
    }
  }
}",0.9312786339025406
150732,"public static void main(String args[]){
  ImageType type=ImageType.pl(3,GrayU8.class);
  List<PathLabel> inputs=new ArrayList<>();
  inputs.add(new PathLabel(""String_Node_Str"",UtilIO.pathExample(""String_Node_Str"")));
  DeformImageKeyPointsApp app=new DeformImageKeyPointsApp(inputs,type);
  app.openFile(new File(inputs.get(0).getPath()));
  app.waitUntilDoneProcessing();
  ShowImages.showWindow(app,""String_Node_Str"",true);
}","public static void main(String args[]){
  ImageType type=ImageType.pl(3,GrayU8.class);
  List<PathLabel> inputs=new ArrayList<>();
  inputs.add(new PathLabel(""String_Node_Str"",UtilIO.pathExample(""String_Node_Str"")));
  inputs.add(new PathLabel(""String_Node_Str"",UtilIO.pathExample(""String_Node_Str"")));
  DeformImageKeyPointsApp app=new DeformImageKeyPointsApp(inputs,type);
  app.openFile(new File(inputs.get(0).getPath()));
  app.waitUntilDoneProcessing();
  ShowImages.showWindow(app,""String_Node_Str"",true);
}",0.9085106382978724
150733,"@Override public void handleAlgorithmChange(){
  alg=FactoryDistort.deformMls(control.getConfigMLS());
  p2p.setTransform(alg);
  controlPointsModified(false);
}","@Override public void handleAlgorithmChange(){
  System.out.println(""String_Node_Str"");
  alg=FactoryDistort.deformMls(control.getConfigMLS());
  p2p.setTransform(alg);
  alg.setImageShape(undistorted.width,undistorted.height);
  controlPointsModified();
}",0.7482014388489209
150734,"@Override public void mousePressed(MouseEvent e){
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
  active=-1;
synchronized (pointsUndistorted) {
    for (int i=0; i < pointsUndistorted.size(); i++) {
      Point2D_F32 p=pointsUndistorted.get(i);
      if (p.distance(x,y) <= clickTol) {
        active=i;
        selectedUndist=true;
      }
    }
    if (active < 0) {
      active=pointsDistorted.size();
      selectedUndist=false;
      pointsUndistorted.add(new Point2D_F32(x,y));
      pointsDistorted.add(new Point2D_F32(x,y));
      controlPointsModified(false);
    }
  }
}","@Override public void mousePressed(MouseEvent e){
  float x=(float)(e.getX() / scale);
  float y=(float)(e.getY() / scale);
  active=-1;
synchronized (pointsUndistorted) {
    for (int i=0; i < pointsDistorted.size(); i++) {
      Point2D_F32 p=pointsDistorted.get(i);
      if (p.distance(x,y) <= clickTol) {
        active=i;
        selectedUndist=false;
      }
    }
    if (active < 0) {
      for (int i=0; i < pointsUndistorted.size(); i++) {
        Point2D_F32 p=pointsUndistorted.get(i);
        if (p.distance(x,y) <= clickTol) {
          active=i;
          selectedUndist=true;
        }
      }
    }
    if (active < 0) {
      active=pointsDistorted.size();
      selectedUndist=false;
      pointsUndistorted.add(new Point2D_F32(x,y));
      pointsDistorted.add(new Point2D_F32(x,y));
      controlPointsModified();
    }
  }
}",0.6941580756013745
150735,"@Override public void mouseReleased(MouseEvent e){
  if (active < 0)   return;
  active=-1;
}","@Override public void mouseReleased(MouseEvent e){
  if (active < 0)   return;
  active=-1;
  repaint();
}",0.9346733668341708
150736,"@Override public void processImage(final BufferedImage buffered,final T undistorted){
  BufferedImage tmp=distortedBuff;
  distortedBuff=ConvertBufferedImage.checkDeclare(undistorted.width,undistorted.height,distortedBuff,BufferedImage.TYPE_INT_RGB);
  if (tmp != distortedBuff) {
    distorted.reshape(undistorted.width,undistorted.height);
    this.undistorted.reshape(undistorted.width,undistorted.height);
    gui.setPreferredSize(new Dimension(undistorted.width,undistorted.height));
    alg.setImageShape(undistorted.width,undistorted.height);
synchronized (pointsUndistorted) {
      validTransform=false;
      pointsUndistorted.clear();
      pointsDistorted.clear();
      alg.setKeyPoints(pointsUndistorted);
    }
  }
  if (inputMethod == InputMethod.IMAGE) {
    this.undistorted.setTo(undistorted);
  }
  renderDistorted(buffered,undistorted);
}","@Override public void processImage(final BufferedImage buffered,final T undistorted){
  BufferedImage tmp=distortedBuff;
  distortedBuff=ConvertBufferedImage.checkDeclare(undistorted.width,undistorted.height,distortedBuff,BufferedImage.TYPE_INT_RGB);
  if (tmp != distortedBuff) {
    distorted.reshape(undistorted.width,undistorted.height);
    this.undistorted.reshape(undistorted.width,undistorted.height);
    gui.setPreferredSize(new Dimension(undistorted.width,undistorted.height));
    alg.setImageShape(undistorted.width,undistorted.height);
synchronized (pointsUndistorted) {
      validTransform=false;
      pointsUndistorted.clear();
      pointsDistorted.clear();
      alg.setSource(pointsDistorted);
    }
  }
  if (inputMethod == InputMethod.IMAGE) {
    this.undistorted.setTo(undistorted);
  }
  renderDistorted(buffered,undistorted);
}",0.9807355516637478
150737,"@Override public void stateChanged(ChangeEvent e){
  if (e.getSource() == selectModel) {
    configMLS.type=(TypeDeformMLS)selectModel.getValue();
  }
 else   if (e.getSource() == selectGridRows) {
    configMLS.rows=((SpinnerNumberModel)selectGridRows.getModel()).getNumber().intValue();
  }
 else   if (e.getSource() == selectGridCols) {
    configMLS.cols=((SpinnerNumberModel)selectGridCols.getModel()).getNumber().intValue();
  }
 else   if (e.getSource() == selectAlpha) {
    configMLS.alpha=((SpinnerNumberModel)selectGridCols.getModel()).getNumber().floatValue();
  }
 else {
    return;
  }
  listener.handleAlgorithmChange();
}","@Override public void stateChanged(ChangeEvent e){
  if (e.getSource() == selectModel) {
    configMLS.type=(TypeDeformMLS)selectModel.getValue();
  }
 else   if (e.getSource() == selectGridRows) {
    configMLS.rows=((SpinnerNumberModel)selectGridRows.getModel()).getNumber().intValue();
  }
 else   if (e.getSource() == selectGridCols) {
    configMLS.cols=((SpinnerNumberModel)selectGridCols.getModel()).getNumber().intValue();
  }
 else   if (e.getSource() == selectAlpha) {
    configMLS.alpha=((SpinnerNumberModel)selectAlpha.getModel()).getNumber().floatValue();
  }
 else {
    return;
  }
  listener.handleAlgorithmChange();
}",0.8373919874312648
150738,"/** 
 * Sets the distorted location of a specific control point
 * @param which Which control point
 * @param x distorted coordinate x-axis in image pixels
 * @param y distorted coordinate y-axis in image pixels
 */
public void setDistorted(int which,float x,float y){
  if (controls.get(which).q.distance(x,y) > 0.0001) {
    System.out.println(""String_Node_Str"" + which);
  }
  controls.get(which).q.set(x,y);
}","/** 
 * Sets the distorted location of a specific control point
 * @param which Which control point
 * @param x distorted coordinate x-axis in image pixels
 * @param y distorted coordinate y-axis in image pixels
 */
public void setDistorted(int which,float x,float y){
  controls.get(which).q.set(x,y);
}",0.8479776847977685
150739,"/** 
 * Sets the location of a control point.  Initially the distorted and undistorted location will be set to be the same.
 * @param x coordinate x-axis in image pixels
 * @param y coordinate y-axis in image pixels
 * @return Index of control point
 */
public int addControl(float x,float y){
  if (scaleX <= 0 || scaleY <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  Control c=controls.grow();
  c.p.set(x / scaleX,y / scaleY);
  c.q.set(x,y);
  return controls.size() - 1;
}","/** 
 * Adds a new control point at the specified location.  Initially the distorted and undistorted location will be set to the same
 * @param x coordinate x-axis in image pixels
 * @param y coordinate y-axis in image pixels
 * @return Index of control point
 */
public int addControl(float x,float y){
  Control c=controls.grow();
  c.q.set(x,y);
  setUndistorted(controls.size() - 1,x,y);
  return controls.size() - 1;
}",0.6840958605664488
150740,"/** 
 * Recompute the deformation of each point in the internal grid now that the location of control points is not changing any more.  Must call   {@link #fixateUndistorted()} first.
 */
public void fixateDistorted(){
  for (int row=0; row < gridRows; row++) {
    for (int col=0; col < gridCols; col++) {
      AffineCache cache=getGrid(row,col);
      computeAverageQ(cache);
      computeAffineDeformed(cache);
      if (row == 0 && col == 1) {
        System.out.println(""String_Node_Str"" + cache.aveQ);
        System.out.println(""String_Node_Str"" + cache.deformed);
      }
    }
  }
}","/** 
 * Recompute the deformation of each point in the internal grid now that the location of control points is not changing any more.  Must call   {@link #fixateUndistorted()} first.
 */
public void fixateDistorted(){
  for (int row=0; row < gridRows; row++) {
    for (int col=0; col < gridCols; col++) {
      AffineCache cache=getGrid(row,col);
      computeAverageQ(cache);
      computeAffineDeformed(cache);
    }
  }
}",0.8369351669941061
150741,"/** 
 * Blob detector which uses a 3x3 kernel to approximate the second order derivatives and compute a Laplacian blob.
 */
public static <I extends ImageGray<I>>GeneralFeatureIntensity<I,?> laplacian(){
  return new WrapperLaplacianBlobIntensity<>();
}","/** 
 * Blob detector which uses a 3x3 kernel to approximate the second order derivatives and compute a Laplacian blob.
 */
public static <I extends ImageGray<I>>GeneralFeatureIntensity<I,?> laplacian(){
  return new WrapperLaplacianBlobIntensity();
}",0.996031746031746
150742,"@Override public void setCalibration(CameraPinholeRadial paramVisual,Point2Transform2_F32 visToDepth){
  CameraPinhole desired=new CameraPinhole(paramVisual);
  desired.skew=0;
  adjustImage=LensDistortionOps.changeCameraModel(AdjustmentType.EXPAND,BorderType.ZERO,paramVisual,desired,paramAdjusted,visType);
  Point2Transform2_F32 desiredToOriginal=LensDistortionOps.transformChangeModel_F32(AdjustmentType.EXPAND,paramVisual,desired,false,null);
  Point2Transform2_F32 adjustedToDepth=new SequencePoint2Transform2_F32(desiredToOriginal,visToDepth);
  PixelTransform2_F32 pixelAdjToDepth=new PixelTransformCached_F32(paramAdjusted.width,paramAdjusted.height,adjustedToDepth);
  Point2Transform2_F64 pixelAdjToNorm=LensDistortionOps.narrow(paramAdjusted).undistort_F64(true,false);
  sparse3D.configure(pixelAdjToNorm,pixelAdjToDepth);
  undistorted.reshape(paramAdjusted.width,paramAdjusted.height);
  alg.setCameraParameters((float)paramAdjusted.fx,(float)paramAdjusted.fy,(float)paramAdjusted.cy,(float)paramAdjusted.cy,paramAdjusted.width,paramAdjusted.height);
}","@Override public void setCalibration(CameraPinholeRadial paramVisual,Point2Transform2_F32 visToDepth){
  CameraPinhole desired=new CameraPinhole(paramVisual);
  desired.skew=0;
  adjustImage=LensDistortionOps.changeCameraModel(AdjustmentType.EXPAND,BorderType.ZERO,paramVisual,desired,paramAdjusted,visType);
  Point2Transform2_F32 desiredToOriginal=LensDistortionOps.transformChangeModel_F32(AdjustmentType.EXPAND,paramVisual,desired,false,null);
  Point2Transform2_F32 adjustedToDepth=new SequencePoint2Transform2_F32(desiredToOriginal,visToDepth);
  PixelTransform2_F32 pixelAdjToDepth=new PixelTransformCached_F32(paramAdjusted.width,paramAdjusted.height,adjustedToDepth);
  sparse3D.configure(LensDistortionOps.narrow(paramAdjusted),pixelAdjToDepth);
  undistorted.reshape(paramAdjusted.width,paramAdjusted.height);
  alg.setCameraParameters((float)paramAdjusted.fx,(float)paramAdjusted.fy,(float)paramAdjusted.cy,(float)paramAdjusted.cy,paramAdjusted.width,paramAdjusted.height);
}",0.9425511197663096
150743,"@Override public void setCalibration(CameraPinholeRadial paramVisual,Point2Transform2_F32 visToDepth){
  PointToPixelTransform_F32 visToDepth_pixel=new PointToPixelTransform_F32(visToDepth);
  sparse3D.configure(paramVisual,visToDepth_pixel);
  Point2Transform2_F64 leftPixelToNorm=narrow(paramVisual).undistort_F64(true,false);
  Point2Transform2_F64 leftNormToPixel=narrow(paramVisual).distort_F64(false,true);
  alg.setPixelToNorm(leftPixelToNorm);
  alg.setNormToPixel(leftNormToPixel);
  distance.setIntrinsic(paramVisual.fx,paramVisual.fy,paramVisual.skew);
}","@Override public void setCalibration(CameraPinholeRadial paramVisual,Point2Transform2_F32 visToDepth){
  PointToPixelTransform_F32 visToDepth_pixel=new PointToPixelTransform_F32(visToDepth);
  sparse3D.configure(LensDistortionOps.narrow(paramVisual),visToDepth_pixel);
  Point2Transform2_F64 leftPixelToNorm=narrow(paramVisual).undistort_F64(true,false);
  Point2Transform2_F64 leftNormToPixel=narrow(paramVisual).distort_F64(false,true);
  alg.setPixelToNorm(leftPixelToNorm);
  alg.setNormToPixel(leftNormToPixel);
  distance.setIntrinsic(paramVisual.fx,paramVisual.fy,paramVisual.skew);
}",0.9584775086505192
150744,"/** 
 * Configures intrinsic camera parameters
 * @param pixelToNorm Transform from pixel to undistorted normalized image coordinates
 * @param visualToDepth Transform from visual to depth camera pixel coordinate systems.
 */
public void configure(Point2Transform2_F64 pixelToNorm,PixelTransform2_F32 visualToDepth){
  this.visualToDepth=visualToDepth;
  this.p2n=pixelToNorm;
}","/** 
 * Configures intrinsic camera parameters
 * @param model Model for narrow FOV cameras
 * @param visualToDepth Transform from visual to depth camera pixel coordinate systems.
 */
public void configure(LensDistortionNarrowFOV model,PixelTransform2_F32 visualToDepth){
  this.visualToDepth=visualToDepth;
  this.p2n=model.undistort_F64(true,false);
}",0.4131326949384405
150745,"@Test public void basicTest(){
  GrayU16 depth=new GrayU16(w,h);
  depth.set(5,6,1000);
  CameraPinholeRadial param=new CameraPinholeRadial(1,1,0,5,10,w,h).fsetRadial(0,0);
  PixelTransform2_F32 v2d=new PixelTransform2_F32(){
    @Override public void compute(    int x,    int y){
      distX=x + 1;
      distY=y + 2;
    }
  }
;
  DepthSparse3D<GrayU16> alg=new DepthSparse3D.I<>(2.1);
  alg.configure(param,v2d);
  alg.setDepthImage(depth);
  assertTrue(alg.process(4,4));
  Point3D_F64 found=alg.getWorldPt();
  Point2D_F64 norm=new Point2D_F64();
  PerspectiveOps.convertPixelToNorm(param,new Point2D_F64(4,4),norm);
  double z=1000 * 2.1;
  assertEquals(z,found.z,1e-8);
  assertEquals(norm.x * z,found.x,1e-8);
  assertEquals(norm.y * z,found.y,1e-8);
}","@Test public void basicTest(){
  GrayU16 depth=new GrayU16(w,h);
  depth.set(5,6,1000);
  CameraPinholeRadial param=new CameraPinholeRadial(1,1,0,5,10,w,h).fsetRadial(0,0);
  PixelTransform2_F32 v2d=new PixelTransform2_F32(){
    @Override public void compute(    int x,    int y){
      distX=x + 1;
      distY=y + 2;
    }
  }
;
  DepthSparse3D<GrayU16> alg=new DepthSparse3D.I<>(2.1);
  alg.configure(LensDistortionOps.narrow(param),v2d);
  alg.setDepthImage(depth);
  assertTrue(alg.process(4,4));
  Point3D_F64 found=alg.getWorldPt();
  Point2D_F64 norm=new Point2D_F64();
  PerspectiveOps.convertPixelToNorm(param,new Point2D_F64(4,4),norm);
  double z=1000 * 2.1;
  assertEquals(z,found.z,1e-8);
  assertEquals(norm.x * z,found.x,1e-8);
  assertEquals(norm.y * z,found.y,1e-8);
}",0.9767441860465116
150746,"private void putGridIntoCanonical_vertical(int numRows,int numCols){
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid<>(numRows,numCols,null,null,null);
  Grid g=createGrid(numRows,numCols);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.putGridIntoCanonical(flipVertical(g));
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
}","private void putGridIntoCanonical_vertical(int numRows,int numCols){
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid(numRows,numCols,null,null,null);
  Grid g=createGrid(numRows,numCols);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.putGridIntoCanonical(flipVertical(g));
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
}",0.998463901689708
150747,"public void putGridIntoCanonical_rotate(int numRows,int numCols){
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid<>(numRows,numCols,null,null,null);
  Grid g=createGrid(numRows,numCols);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.rotateGridCCW(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.rotateGridCCW(g);
  alg.rotateGridCCW(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.rotateGridCCW(g);
  alg.rotateGridCCW(g);
  alg.rotateGridCCW(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.flipVertical(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
}","public void putGridIntoCanonical_rotate(int numRows,int numCols){
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid(numRows,numCols,null,null,null);
  Grid g=createGrid(numRows,numCols);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.rotateGridCCW(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.rotateGridCCW(g);
  alg.rotateGridCCW(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.rotateGridCCW(g);
  alg.rotateGridCCW(g);
  alg.rotateGridCCW(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  alg.flipVertical(g);
  alg.putGridIntoCanonical(g);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
}",0.9990439770554492
150748,"@Test public void rotateGridCCW(){
  Grid g=createGrid(3,3);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid<>(3,3,null,null,null);
  alg.rotateGridCCW(g);
  assertEquals(9,g.ellipses.size());
  assertTrue(original.get(6) == g.get(0,0));
  assertTrue(original.get(0) == g.get(0,2));
  assertTrue(original.get(2) == g.get(2,2));
  assertTrue(original.get(8) == g.get(2,0));
}","@Test public void rotateGridCCW(){
  Grid g=createGrid(3,3);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid(3,3,null,null,null);
  alg.rotateGridCCW(g);
  assertEquals(9,g.ellipses.size());
  assertTrue(original.get(6) == g.get(0,0));
  assertTrue(original.get(0) == g.get(0,2));
  assertTrue(original.get(2) == g.get(2,2));
  assertTrue(original.get(8) == g.get(2,0));
}",0.997907949790795
150749,"private void putGridIntoCanonical_horizontal(int numRows,int numCols){
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid<>(numRows,numCols,null,null,null);
  Grid g=createGrid(numRows,numCols);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  g=flipHorizontal(g);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
}","private void putGridIntoCanonical_horizontal(int numRows,int numCols){
  DetectAsymmetricCircleGrid<?> alg=new DetectAsymmetricCircleGrid(numRows,numCols,null,null,null);
  Grid g=createGrid(numRows,numCols);
  List<EllipseRotated_F64> original=new ArrayList<>();
  original.addAll(g.ellipses);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
  g=flipHorizontal(g);
  alg.putGridIntoCanonical(g);
  assertEquals(numRows,g.rows);
  assertEquals(numCols,g.columns);
  assertTrue(original.get(0) == g.get(0,0));
  checkCounterClockWise(g);
}",0.9984894259818732
150750,"@Override public boolean process(GrayF32 input){
  if (alg.process(input)) {
    detected=new CalibrationObservation();
    List<Point2D_F64> found=alg.getCalibrationPoints();
    for (int i=0; i < found.size(); i++) {
      detected.add(found.get(i),i);
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean process(GrayF32 input){
  detected=new CalibrationObservation();
  if (alg.process(input)) {
    List<Point2D_F64> found=alg.getCalibrationPoints();
    for (int i=0; i < found.size(); i++) {
      detected.add(found.get(i),i);
    }
    return true;
  }
 else {
    return false;
  }
}",0.8653846153846154
150751,"@Override public boolean process(GrayF32 input){
  detector.process(input);
  List<Grid> grids=detector.getGrids();
  if (grids.size() != 1)   return false;
  if (!keypoint.process(grids.get(0)))   return false;
  FastQueue<Point2D_F64> foundPixels=keypoint.getKeyPoints();
  results=new CalibrationObservation();
  for (int i=0; i < foundPixels.size; i++) {
    results.add(foundPixels.get(i),i);
  }
  return true;
}","@Override public boolean process(GrayF32 input){
  results=new CalibrationObservation();
  detector.process(input);
  List<Grid> grids=detector.getGrids();
  if (grids.size() != 1)   return false;
  if (!keypoint.process(grids.get(0)))   return false;
  FastQueue<Point2D_F64> foundPixels=keypoint.getKeyPoints();
  for (int i=0; i < foundPixels.size; i++) {
    results.add(foundPixels.get(i),i);
  }
  return true;
}",0.9043062200956936
150752,"@Override public boolean process(GrayF32 input){
  if (!detector.detect(input)) {
    return false;
  }
  observations=new CalibrationObservation();
  List<DetectFiducialSquareGrid.Detection> detections=detector.getDetections();
  for (int i=0; i < detections.size(); i++) {
    DetectFiducialSquareGrid.Detection d=detections.get(i);
    int row=d.gridIndex / numCols;
    int col=d.gridIndex % numCols;
    int pointRow=row * 2;
    int pointCol=col * 2;
    observations.add(d.location.a,getPointIndex(pointRow,pointCol));
    observations.add(d.location.b,getPointIndex(pointRow,pointCol + 1));
    observations.add(d.location.c,getPointIndex(pointRow + 1,pointCol + 1));
    observations.add(d.location.d,getPointIndex(pointRow + 1,pointCol));
  }
  observations.sort();
  return true;
}","@Override public boolean process(GrayF32 input){
  observations=new CalibrationObservation();
  if (!detector.detect(input)) {
    return false;
  }
  List<DetectFiducialSquareGrid.Detection> detections=detector.getDetections();
  for (int i=0; i < detections.size(); i++) {
    DetectFiducialSquareGrid.Detection d=detections.get(i);
    int row=d.gridIndex / numCols;
    int col=d.gridIndex % numCols;
    int pointRow=row * 2;
    int pointCol=col * 2;
    observations.add(d.location.a,getPointIndex(pointRow,pointCol));
    observations.add(d.location.b,getPointIndex(pointRow,pointCol + 1));
    observations.add(d.location.c,getPointIndex(pointRow + 1,pointCol + 1));
    observations.add(d.location.d,getPointIndex(pointRow + 1,pointCol));
  }
  observations.sort();
  return true;
}",0.9431818181818182
150753,"@Override public boolean process(GrayF32 input){
  if (detect.process(input)) {
    detected=new CalibrationObservation();
    List<Point2D_F64> found=detect.getCalibrationPoints();
    for (int i=0; i < found.size(); i++) {
      detected.add(found.get(i),i);
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean process(GrayF32 input){
  detected=new CalibrationObservation();
  if (detect.process(input)) {
    List<Point2D_F64> found=detect.getCalibrationPoints();
    for (int i=0; i < found.size(); i++) {
      detected.add(found.get(i),i);
    }
    return true;
  }
 else {
    return false;
  }
}",0.8679245283018868
150754,"@Override public void changeInput(String name,int index){
  stopWorker();
  processedInputImage=false;
  String videoName=inputRefs.get(index).getPath();
  String path=videoName.substring(0,videoName.lastIndexOf('/'));
  ConfigThreshold configThreshold=ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10);
  if (name.compareTo(SQUARE_NUMBER) == 0) {
    detector=FactoryFiducial.squareBinary(new ConfigFiducialBinary(0.1),configThreshold,imageClass);
  }
 else   if (name.compareTo(SQUARE_PICTURE) == 0) {
    double length=0.1;
    detector=FactoryFiducial.squareImage(new ConfigFiducialImage(),configThreshold,imageClass);
    SquareImage_to_FiducialDetector<I> d=(SquareImage_to_FiducialDetector<I>)detector;
    String pathImg=new File(path,""String_Node_Str"").getPath();
    List<String> names=new ArrayList<>();
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    for (    String foo : names) {
      BufferedImage img=media.openImage(new File(pathImg,foo).getPath());
      if (img == null)       throw new RuntimeException(""String_Node_Str"" + new File(pathImg,foo).getPath());
      d.addPatternImage(ConvertBufferedImage.convertFromSingle(img,null,imageClass),125,length);
    }
  }
 else   if (name.compareTo(CALIB_CHESS) == 0) {
    detector=FactoryFiducial.calibChessboard(new ConfigChessboard(7,5,0.03),imageClass);
  }
 else   if (name.compareTo(CALIB_SQUARE_GRID) == 0) {
    detector=FactoryFiducial.calibSquareGrid(new ConfigSquareGrid(4,3,0.03,0.03),imageClass);
  }
 else   if (name.compareTo(CALIB_SQUARE_BINARY_GRID) == 0) {
    File configFile=new File(path,""String_Node_Str"");
    try {
      ConfigSquareGridBinary config=ConfigSquareGridBinary.parseSimple(new BufferedReader(new FileReader(configFile)));
      detector=FactoryFiducial.calibSquareGridBinary(config,imageClass);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  intrinsic=CalibrationIO.load(media.openFile(path + ""String_Node_Str""));
  detector.setLensDistortion(new LensDistortionRadialTangential(intrinsic));
  fiducialInfo.clear();
  stabilityMax.location=0.05;
  stabilityMax.orientation=0.02;
  SimpleImageSequence<Planar<I>> video=media.openVideo(videoName,ImageType.pl(3,imageClass));
  if (video == null) {
    System.err.println(""String_Node_Str"" + videoName);
    System.exit(1);
  }
  process(video);
}","@Override public void changeInput(String name,int index){
  stopWorker();
  processedInputImage=false;
  String videoName=inputRefs.get(index).getPath();
  String path=videoName.substring(0,videoName.lastIndexOf('/'));
  ConfigThreshold configThreshold=ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10);
  if (name.compareTo(SQUARE_NUMBER) == 0) {
    detector=FactoryFiducial.squareBinary(new ConfigFiducialBinary(0.1),configThreshold,imageClass);
  }
 else   if (name.compareTo(SQUARE_PICTURE) == 0) {
    double length=0.1;
    detector=FactoryFiducial.squareImage(new ConfigFiducialImage(),configThreshold,imageClass);
    SquareImage_to_FiducialDetector<I> d=(SquareImage_to_FiducialDetector<I>)detector;
    String pathImg=new File(path,""String_Node_Str"").getPath();
    List<String> names=new ArrayList<>();
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    for (    String foo : names) {
      BufferedImage img=media.openImage(new File(pathImg,foo).getPath());
      if (img == null)       throw new RuntimeException(""String_Node_Str"" + new File(pathImg,foo).getPath());
      d.addPatternImage(ConvertBufferedImage.convertFromSingle(img,null,imageClass),125,length);
    }
  }
 else   if (name.compareTo(CALIB_CHESS) == 0) {
    detector=FactoryFiducial.calibChessboard(new ConfigChessboard(7,5,0.03),imageClass);
  }
 else   if (name.compareTo(CALIB_SQUARE_GRID) == 0) {
    detector=FactoryFiducial.calibSquareGrid(new ConfigSquareGrid(4,3,0.03,0.03),imageClass);
  }
 else   if (name.compareTo(CALIB_SQUARE_BINARY_GRID) == 0) {
    File configFile=new File(path,""String_Node_Str"");
    try {
      ConfigSquareGridBinary config=ConfigSquareGridBinary.parseSimple(new BufferedReader(new FileReader(configFile)));
      detector=FactoryFiducial.calibSquareGridBinary(config,imageClass);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  intrinsic=CalibrationIO.load(media.openFile(path + ""String_Node_Str""));
  detector.setLensDistortion(new LensDistortionRadialTangential(intrinsic));
  fiducialInfo.clear();
  stabilityMax.location=0.01;
  stabilityMax.orientation=0.02;
  SimpleImageSequence<Planar<I>> video=media.openVideo(videoName,ImageType.pl(3,imageClass));
  if (video == null) {
    System.err.println(""String_Node_Str"" + videoName);
    System.exit(1);
  }
  process(video);
}",0.999586947542338
150755,"public static void main(String[] args){
  String directory=UtilIO.pathExample(""String_Node_Str"");
  CameraPinholeRadial param=CalibrationIO.load(new File(directory,""String_Node_Str""));
  LensDistortionNarrowFOV lensDistortion=new LensDistortionRadialTangential(param);
  BufferedImage input=UtilImageIO.loadImage(directory,""String_Node_Str"");
  GrayF32 original=ConvertBufferedImage.convertFrom(input,true,ImageType.single(GrayF32.class));
  FiducialDetector<GrayF32> detector=FactoryFiducial.squareBinary(new ConfigFiducialBinary(0.1),ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10),GrayF32.class);
  detector.setLensDistortion(lensDistortion);
  detector.detect(original);
  Graphics2D g2=input.createGraphics();
  Se3_F64 targetToSensor=new Se3_F64();
  Point2D_F64 locationPixel=new Point2D_F64();
  for (int i=0; i < detector.totalFound(); i++) {
    detector.getImageLocation(i,locationPixel);
    System.out.println(""String_Node_Str"" + detector.getId(i));
    detector.getFiducialToCamera(i,targetToSensor);
    detector.getImageLocation(i,locationPixel);
    System.out.println(""String_Node_Str"" + locationPixel);
    System.out.println(""String_Node_Str"");
    System.out.println(targetToSensor);
    VisualizeFiducial.drawCube(targetToSensor,param,detector.getWidth(i),3,g2);
    VisualizeFiducial.drawLabelCenter(targetToSensor,param,""String_Node_Str"" + detector.getId(i),g2);
  }
  ShowImages.showWindow(input,""String_Node_Str"",true);
}","public static void main(String[] args){
  String directory=UtilIO.pathExample(""String_Node_Str"");
  CameraPinholeRadial param=CalibrationIO.load(new File(directory,""String_Node_Str""));
  LensDistortionNarrowFOV lensDistortion=new LensDistortionRadialTangential(param);
  BufferedImage input=UtilImageIO.loadImage(directory,""String_Node_Str"");
  GrayF32 original=ConvertBufferedImage.convertFrom(input,true,ImageType.single(GrayF32.class));
  FiducialDetector<GrayF32> detector=FactoryFiducial.squareBinary(new ConfigFiducialBinary(0.1),ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10),GrayF32.class);
  detector.setLensDistortion(lensDistortion);
  detector.detect(original);
  Graphics2D g2=input.createGraphics();
  Se3_F64 targetToSensor=new Se3_F64();
  Point2D_F64 locationPixel=new Point2D_F64();
  for (int i=0; i < detector.totalFound(); i++) {
    detector.getImageLocation(i,locationPixel);
    if (detector.hasUniqueID())     System.out.println(""String_Node_Str"" + detector.getId(i));
    if (detector.hasMessage())     System.out.println(""String_Node_Str"" + detector.getMessage(i));
    System.out.println(""String_Node_Str"" + locationPixel);
    if (detector.is3D()) {
      detector.getFiducialToCamera(i,targetToSensor);
      System.out.println(""String_Node_Str"");
      System.out.println(targetToSensor);
      VisualizeFiducial.drawCube(targetToSensor,param,detector.getWidth(i),3,g2);
      VisualizeFiducial.drawLabelCenter(targetToSensor,param,""String_Node_Str"" + detector.getId(i),g2);
    }
 else {
      VisualizeFiducial.drawLabel(locationPixel,""String_Node_Str"" + detector.getId(i),g2);
    }
  }
  ShowImages.showWindow(input,""String_Node_Str"",true);
}",0.8574162679425837
150756,"public static void main(String[] args){
  String imagePath=UtilIO.pathExample(""String_Node_Str"");
  String patternPath=UtilIO.pathExample(""String_Node_Str"");
  String imageName=""String_Node_Str"";
  CameraPinholeRadial param=CalibrationIO.load(new File(imagePath,""String_Node_Str""));
  LensDistortionNarrowFOV lensDistortion=new LensDistortionRadialTangential(param);
  BufferedImage input=UtilImageIO.loadImage(imagePath,imageName);
  GrayF32 original=ConvertBufferedImage.convertFrom(input,true,ImageType.single(GrayF32.class));
  SquareImage_to_FiducialDetector<GrayF32> detector=FactoryFiducial.squareImage(new ConfigFiducialImage(),ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10),GrayF32.class);
  double width=4;
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.setLensDistortion(lensDistortion);
  detector.detect(original);
  Graphics2D g2=input.createGraphics();
  Se3_F64 targetToSensor=new Se3_F64();
  for (int i=0; i < detector.totalFound(); i++) {
    System.out.println(""String_Node_Str"" + detector.getId(i));
    detector.getFiducialToCamera(i,targetToSensor);
    System.out.println(""String_Node_Str"");
    System.out.println(targetToSensor);
    VisualizeFiducial.drawLabelCenter(targetToSensor,param,""String_Node_Str"" + detector.getId(i),g2);
    VisualizeFiducial.drawCube(targetToSensor,param,detector.getWidth(i),3,g2);
  }
  ShowImages.showWindow(input,""String_Node_Str"",true);
}","public static void main(String[] args){
  String imagePath=UtilIO.pathExample(""String_Node_Str"");
  String patternPath=UtilIO.pathExample(""String_Node_Str"");
  String imageName=""String_Node_Str"";
  CameraPinholeRadial param=CalibrationIO.load(new File(imagePath,""String_Node_Str""));
  LensDistortionNarrowFOV lensDistortion=new LensDistortionRadialTangential(param);
  BufferedImage input=UtilImageIO.loadImage(imagePath,imageName);
  GrayF32 original=ConvertBufferedImage.convertFrom(input,true,ImageType.single(GrayF32.class));
  SquareImage_to_FiducialDetector<GrayF32> detector=FactoryFiducial.squareImage(new ConfigFiducialImage(),ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10),GrayF32.class);
  double width=4;
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.addPatternImage(loadImage(patternPath,""String_Node_Str"",GrayF32.class),100,width);
  detector.setLensDistortion(lensDistortion);
  detector.detect(original);
  Graphics2D g2=input.createGraphics();
  Se3_F64 targetToSensor=new Se3_F64();
  Point2D_F64 locationPixel=new Point2D_F64();
  for (int i=0; i < detector.totalFound(); i++) {
    detector.getImageLocation(i,locationPixel);
    if (detector.hasUniqueID())     System.out.println(""String_Node_Str"" + detector.getId(i));
    if (detector.hasMessage())     System.out.println(""String_Node_Str"" + detector.getMessage(i));
    System.out.println(""String_Node_Str"" + locationPixel);
    if (detector.is3D()) {
      detector.getFiducialToCamera(i,targetToSensor);
      System.out.println(""String_Node_Str"");
      System.out.println(targetToSensor);
      VisualizeFiducial.drawCube(targetToSensor,param,detector.getWidth(i),3,g2);
      VisualizeFiducial.drawLabelCenter(targetToSensor,param,""String_Node_Str"" + detector.getId(i),g2);
    }
 else {
      VisualizeFiducial.drawLabel(locationPixel,""String_Node_Str"" + detector.getId(i),g2);
    }
  }
  ShowImages.showWindow(input,""String_Node_Str"",true);
}",0.8777880184331798
150757,"public boolean touchesBorder(){
  if (borderCorners.size() == 0)   return false;
 else {
    for (int i=0; i < borderCorners.size(); i++) {
      if (borderCorners.get(i))       return true;
    }
  }
  return false;
}","/** 
 * Checks to see if some part of the contour touches the image border.  Most likely cropped
 */
protected final boolean touchesBorder(List<Point2D_I32> contour){
  int endX=labeled.width - 1;
  int endY=labeled.height - 1;
  for (int j=0; j < contour.size(); j++) {
    Point2D_I32 p=contour.get(j);
    if (p.x == 0 || p.y == 0 || p.x == endX || p.y == endY) {
      return true;
    }
  }
  return false;
}",0.2662440570522979
150758,"/** 
 * <p>Specifies transforms which can be used to change coordinates from distorted to undistorted and the opposite coordinates.  The undistorted image is never explicitly created.</p> <p> WARNING: The undistorted image must have the same bounds as the distorted input image.  This is because several of the bounds checks use the image shape.  This are simplified greatly by this assumption. </p>
 * @param width Input image width.  Used in sanity check only.
 * @param height Input image height.  Used in sanity check only.
 * @param distToUndist Transform from distorted to undistorted image.
 * @param undistToDist Transform from undistorted to distorted image.
 */
public void setLensDistortion(int width,int height,PixelTransform2_F32 distToUndist,PixelTransform2_F32 undistToDist){
  this.distToUndist=distToUndist;
  this.undistToDist=undistToDist;
  RectangleLength2D_F32 rect=DistortImageOps.boundBox_F32(width,height,distToUndist);
  float x1=rect.x0 + rect.width;
  float y1=rect.y0 + rect.height;
  float tol=1e-4f;
  if (rect.getX() < -tol || rect.getY() < -tol || x1 > width + tol || y1 > height + tol) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (refinePolygon != null) {
    refinePolygon.setLensDistortion(width,height,distToUndist,undistToDist);
  }
  edgeIntensity.setTransform(undistToDist);
}","/** 
 * <p>Specifies transforms which can be used to change coordinates from distorted to undistorted and the opposite coordinates.  The undistorted image is never explicitly created.</p>
 * @param width Input image width.  Used in sanity check only.
 * @param height Input image height.  Used in sanity check only.
 * @param distToUndist Transform from distorted to undistorted image.
 * @param undistToDist Transform from undistorted to distorted image.
 */
public void setLensDistortion(int width,int height,PixelTransform2_F32 distToUndist,PixelTransform2_F32 undistToDist){
  this.distToUndist=distToUndist;
  this.undistToDist=undistToDist;
  if (refinePolygon != null) {
    refinePolygon.setLensDistortion(width,height,distToUndist,undistToDist);
  }
  edgeIntensity.setTransform(undistToDist);
}",0.6371191135734072
150759,"/** 
 * Estimates the stability by perturbing each land mark by the specified number of pixels in the distorted image.
 */
@Override public boolean computeStability(int which,double disturbance,FiducialStability results){
  if (!getFiducialToCamera(which,targetToCamera))   return false;
  targetToCamera.invert(referenceCameraToTarget);
  maxOrientation=0;
  maxLocation=0;
  for (int i=0; i < detected2D3D.size(); i++) {
    Point2D3D p23=detected2D3D.get(i);
    Point2D_F64 p=detectedPixels.get(i);
    workPt.set(p);
    perturb(disturbance,workPt,p,p23);
  }
  results.location=maxLocation;
  results.orientation=maxOrientation;
  return true;
}","/** 
 * Estimates the stability by perturbing each land mark by the specified number of pixels in the distorted image.
 */
@Override public boolean computeStability(int which,double disturbance,FiducialStability results){
  if (!getFiducialToCamera(which,targetToCamera))   return false;
  targetToCamera.invert(referenceCameraToTarget);
  maxOrientation=0;
  maxLocation=0;
  for (int i=0; i < detected2D3D.size(); i++) {
    estimatePose(which,detected2D3D,targetToCameraSample);
    referenceCameraToTarget.concat(targetToCameraSample,difference);
    Point2D3D p23=detected2D3D.get(i);
    Point2D_F64 p=detectedPixels.get(i);
    workPt.set(p);
    perturb(which,disturbance,workPt,p,p23);
  }
  results.location=maxLocation;
  results.orientation=maxOrientation;
  return true;
}",0.9066852367688022
150760,"private void computeDisturbance(Point2D_F64 pixel,Point2D3D p23){
  pixelToNorm.compute(pixel.x,pixel.y,p23.observation);
  if (estimatePose(detected2D3D,targetToCameraSample)) {
    referenceCameraToTarget.concat(targetToCameraSample,difference);
    double d=difference.getT().norm();
    ConvertRotation3D_F64.matrixToRodrigues(difference.getR(),rodrigues);
    double theta=Math.abs(rodrigues.theta);
    if (theta > maxOrientation) {
      maxOrientation=theta;
    }
    if (d > maxLocation) {
      maxLocation=d;
    }
  }
}","private void computeDisturbance(int which,Point2D_F64 pixel,Point2D3D p23){
  pixelToNorm.compute(pixel.x,pixel.y,p23.observation);
  if (estimatePose(which,detected2D3D,targetToCameraSample)) {
    referenceCameraToTarget.concat(targetToCameraSample,difference);
    double d=difference.getT().norm();
    ConvertRotation3D_F64.matrixToRodrigues(difference.getR(),rodrigues);
    double theta=Math.abs(rodrigues.theta);
    if (theta > maxOrientation) {
      maxOrientation=theta;
    }
    if (d > maxLocation) {
      maxLocation=d;
    }
  }
}",0.9851851851851852
150761,"/** 
 * Given the mapping of 2D observations to known 3D points estimate the pose of the fiducial. This solves the P-n-P problem.
 */
protected boolean estimatePose(List<Point2D3D> points,Se3_F64 fiducialToCamera){
  return estimatePnP.process(points,initialEstimate) && refinePnP.fitModel(points,initialEstimate,fiducialToCamera);
}","/** 
 * Given the mapping of 2D observations to known 3D points estimate the pose of the fiducial. This solves the P-n-P problem.
 */
protected boolean estimatePose(int which,List<Point2D3D> points,Se3_F64 fiducialToCamera){
  return estimatePnP.process(points,initialEstimate) && refinePnP.fitModel(points,initialEstimate,fiducialToCamera);
}",0.985207100591716
150762,"@Override public boolean getFiducialToCamera(int which,Se3_F64 fiducialToCamera){
  if (!hasCameraModel)   return false;
  detectedPixels=getDetectedControl(which);
  if (detectedPixels.size() < 3)   return false;
  createDetectedList(which,detectedPixels);
  return estimatePose(detected2D3D,fiducialToCamera);
}","@Override public boolean getFiducialToCamera(int which,Se3_F64 fiducialToCamera){
  if (!hasCameraModel)   return false;
  detectedPixels=getDetectedControl(which);
  if (detectedPixels.size() < 3)   return false;
  createDetectedList(which,detectedPixels);
  return estimatePose(which,detected2D3D,fiducialToCamera);
}",0.990506329113924
150763,"private void perturb(double disturbance,Point2D_F64 pixel,Point2D_F64 original,Point2D3D p23){
  pixel.x=original.x + disturbance;
  computeDisturbance(pixel,p23);
  pixel.x=original.x - disturbance;
  computeDisturbance(pixel,p23);
  pixel.y=original.y;
  pixel.y=original.y + disturbance;
  computeDisturbance(pixel,p23);
  pixel.y=original.y - disturbance;
  computeDisturbance(pixel,p23);
}","private void perturb(int which,double disturbance,Point2D_F64 pixel,Point2D_F64 original,Point2D3D p23){
  pixel.x=original.x + disturbance;
  computeDisturbance(which,pixel,p23);
  pixel.x=original.x - disturbance;
  computeDisturbance(which,pixel,p23);
  pixel.y=original.y;
  pixel.y=original.y + disturbance;
  computeDisturbance(which,pixel,p23);
  pixel.y=original.y - disturbance;
  computeDisturbance(which,pixel,p23);
}",0.9586374695863747
150764,"@Override protected boolean estimatePose(List<Point2D3D> points,Se3_F64 fiducialToCamera){
  quad.a.set(points.get(0).observation);
  quad.b.set(points.get(1).observation);
  quad.c.set(points.get(2).observation);
  quad.d.set(points.get(3).observation);
  if (!poseEstimator.process(quad)) {
    return false;
  }
  fiducialToCamera.set(poseEstimator.getWorldToCamera());
  return true;
}","@Override protected boolean estimatePose(int which,List<Point2D3D> points,Se3_F64 fiducialToCamera){
  quad.a.set(points.get(0).observation);
  quad.b.set(points.get(1).observation);
  quad.c.set(points.get(2).observation);
  quad.d.set(points.get(3).observation);
  if (!poseEstimator.process(quad)) {
    return false;
  }
  fiducialToCamera.set(poseEstimator.getWorldToCamera());
  double width=getWidth(which);
  fiducialToCamera.T.x*=width;
  fiducialToCamera.T.y*=width;
  fiducialToCamera.T.z*=width;
  return true;
}",0.8521358159912377
150765,"/** 
 * <p>Estimate the 3D pose of the camera from the observed location of the fiducial.</p> MUST call   {@link #setFiducial} and {@link #setLensDistoriton} before calling this function.
 * @param corners Observed corners of the fiducial in normalized image coordinates.
 * @return true if successful or false if not
 */
public boolean process(Quadrilateral_F64 corners){
  normToPixel.compute(corners.a.x,corners.a.y,pixelCorners.a);
  normToPixel.compute(corners.b.x,corners.b.y,pixelCorners.b);
  normToPixel.compute(corners.c.x,corners.c.y,pixelCorners.c);
  normToPixel.compute(corners.d.x,corners.d.y,pixelCorners.d);
  double length0=pixelCorners.getSideLength(0);
  double length1=pixelCorners.getSideLength(1);
  double ratio=Math.max(length0,length1) / Math.min(length0,length1);
  boolean success;
  if (ratio < 1.3 && length0 < SMALL_PIXELS && length1 < SMALL_PIXELS) {
    success=estimatePathological(outputFiducialToCamera);
  }
 else {
    success=estimate(pixelCorners,outputFiducialToCamera);
  }
  if (success) {
    outputError=computeErrors(outputFiducialToCamera);
  }
  return success;
}","/** 
 * <p>Estimate the 3D pose of the camera from the observed location of the fiducial.</p> MUST call   {@link #setFiducial} and {@link #setLensDistoriton} before calling this function.
 * @param corners Observed corners of the fiducial in normalized image coordinates.
 * @return true if successful or false if not
 */
public boolean process(Quadrilateral_F64 corners){
  normToPixel.compute(corners.a.x,corners.a.y,pixelCorners.a);
  normToPixel.compute(corners.b.x,corners.b.y,pixelCorners.b);
  normToPixel.compute(corners.c.x,corners.c.y,pixelCorners.c);
  normToPixel.compute(corners.d.x,corners.d.y,pixelCorners.d);
  double length0=pixelCorners.getSideLength(0);
  double length1=pixelCorners.getSideLength(1);
  double ratio=Math.max(length0,length1) / Math.min(length0,length1);
  boolean success;
  success=estimate(pixelCorners,outputFiducialToCamera);
  if (success) {
    outputError=computeErrors(outputFiducialToCamera);
  }
  return success;
}",0.8162083936324168
150766,"@Override protected void updateAlgGUI(Planar<I> frame,BufferedImage imageGUI,double fps){
  if (firstFrame) {
    panel.setPreferredSize(new Dimension(imageGUI.getWidth(),imageGUI.getHeight()));
    firstFrame=false;
  }
  int height=getHeight();
  Graphics2D g2=imageGUI.createGraphics();
  Se3_F64 targetToSensor=new Se3_F64();
  for (int i=0; i < detector.totalFound(); i++) {
    detector.getFiducialToCamera(i,targetToSensor);
    double width=detector.getWidth(i);
    long id=detector.getId(i);
    VisualizeFiducial.drawLabelCenter(targetToSensor,intrinsic,""String_Node_Str"" + id,g2);
    VisualizeFiducial.drawCube(targetToSensor,intrinsic,width,3,g2);
    if (computeStability.isSelected()) {
      handleStability(height,g2,i,id);
    }
  }
  panel.setBufferedImageSafe(imageGUI);
  panel.repaint();
}","@Override protected void updateAlgGUI(Planar<I> frame,BufferedImage imageGUI,double fps){
  if (firstFrame) {
    panel.setPreferredSize(new Dimension(imageGUI.getWidth(),imageGUI.getHeight()));
    firstFrame=false;
    imageCopy=new BufferedImage(imageGUI.getWidth(),imageGUI.getHeight(),BufferedImage.TYPE_INT_RGB);
  }
  int height=getHeight();
  Graphics2D g2=imageCopy.createGraphics();
  g2.drawImage(imageGUI,0,0,null);
  Se3_F64 targetToSensor=new Se3_F64();
  for (int i=0; i < detector.totalFound(); i++) {
    detector.getFiducialToCamera(i,targetToSensor);
    double width=detector.getWidth(i);
    long id=detector.getId(i);
    VisualizeFiducial.drawLabelCenter(targetToSensor,intrinsic,""String_Node_Str"" + id,g2);
    VisualizeFiducial.drawCube(targetToSensor,intrinsic,width,3,g2);
    if (computeStability.isSelected()) {
      handleStability(height,g2,i,id);
    }
  }
  panel.setBufferedImageSafe(imageCopy);
  panel.repaint();
}",0.8996029495178672
150767,"public void configure(LensDistortionWideFOV wide,LensDistortionNarrowFOV narrow){
  narrowToNorm=narrow.undistort_F32(true,false);
  unitToWide=wide.distortStoP_F32();
}","public void configure(LensDistortionNarrowFOV narrow,LensDistortionWideFOV wide){
  narrowToNorm=narrow.undistort_F32(true,false);
  unitToWide=wide.distortStoP_F32();
}",0.8402366863905325
150768,"/** 
 * Apply the transformation
 * @param x x-coordinate of point in pixels.  Synthetic narrow FOV camera
 * @param y y-coordinate of point in pixels.  Synthetic narrow FOV camera
 * @param out Pixel location of point in wide FOV camera.
 */
@Override public void compute(double x,double y,Point2D_F64 out){
  narrowToNorm.compute(x,y,norm);
  unit.set(norm.x,norm.y,1.0);
  GeometryMath_F64.mult(rotateWideToNarrow,unit,unit);
  double n=unit.norm();
  unit.x/=n;
  unit.y/=n;
  unit.z/=n;
  System.out.println(""String_Node_Str"" + norm);
  System.out.println(""String_Node_Str"" + unit);
  unitToWide.compute(unit.x,unit.y,unit.z,out);
  System.out.println(""String_Node_Str"" + out);
  Point3D_F64 hack=new Point3D_F64();
  wideToUnit.compute(out.x,out.y,hack);
  System.out.println(""String_Node_Str"" + hack);
}","/** 
 * Apply the transformation
 * @param x x-coordinate of point in pixels.  Synthetic narrow FOV camera
 * @param y y-coordinate of point in pixels.  Synthetic narrow FOV camera
 * @param out Pixel location of point in wide FOV camera.
 */
@Override public void compute(double x,double y,Point2D_F64 out){
  narrowToNorm.compute(x,y,norm);
  unit.set(norm.x,norm.y,1.0);
  GeometryMath_F64.mult(rotateWideToNarrow,unit,unit);
  double n=unit.norm();
  unit.x/=n;
  unit.y/=n;
  unit.z/=n;
  unitToWide.compute(unit.x,unit.y,unit.z,out);
}",0.7387120651369357
150769,"public void configure(LensDistortionNarrowFOV narrow,LensDistortionWideFOV wide){
  narrowToNorm=narrow.undistort_F64(true,false);
  unitToWide=wide.distortStoP_F64();
  wideToUnit=wide.undistortPtoS_F64();
}","public void configure(LensDistortionNarrowFOV narrow,LensDistortionWideFOV wide){
  narrowToNorm=narrow.undistort_F64(true,false);
  unitToWide=wide.distortStoP_F64();
}",0.896551724137931
150770,"/** 
 * Static function for removing radial and tangential distortion
 * @param x Distorted x-coordinate normalized image coordinate
 * @param y Distorted y-coordinate normalized image coordinate
 * @param radial Radial distortion parameters
 * @param t1 tangential distortion
 * @param t2 tangential distortion
 * @param out Undistorted normalized image coordinate
 * @param tol convergence tolerance
 */
public static void removeRadial(float x,float y,float[] radial,float t1,float t2,Point2D_F32 out,float tol){
  float origX=x;
  float origY=y;
  float prevSum=0;
  for (int iter=0; iter < 20; iter++) {
    float r2=x * x + y * y;
    float ri2=r2;
    float sum=0;
    for (int i=0; i < radial.length; i++) {
      sum+=radial[i] * ri2;
      ri2*=r2;
    }
    float tx=2.0f * t1 * x* y + t2 * (r2 + 2.0f * x * x);
    float ty=t1 * (r2 + 2.0f * y * y) + 2.0f * t2 * x* y;
    x=(origX - tx) / (1.0f + sum);
    y=(origY - ty) / (1.0f + sum);
    if ((float)Math.abs(prevSum - sum) <= tol) {
      break;
    }
 else {
      prevSum=sum;
    }
  }
  out.set(x,y);
}","/** 
 * Static function for removing radial and tangential distortion
 * @param x Distorted x-coordinate normalized image coordinate
 * @param y Distorted y-coordinate normalized image coordinate
 * @param radial Radial distortion parameters
 * @param t1 tangential distortion
 * @param t2 tangential distortion
 * @param out Undistorted normalized image coordinate
 * @param tol convergence tolerance
 */
public static void removeRadial(float x,float y,float[] radial,float t1,float t2,Point2D_F32 out,float tol){
  float origX=x;
  float origY=y;
  float prevSum=0;
  for (int iter=0; iter < 500; iter++) {
    float r2=x * x + y * y;
    float ri2=r2;
    float sum=0;
    for (int i=0; i < radial.length; i++) {
      sum+=radial[i] * ri2;
      ri2*=r2;
    }
    float tx=2.0f * t1 * x* y + t2 * (r2 + 2.0f * x * x);
    float ty=t1 * (r2 + 2.0f * y * y) + 2.0f * t2 * x* y;
    x=(origX - tx) / (1.0f + sum);
    y=(origY - ty) / (1.0f + sum);
    if ((float)Math.abs(prevSum - sum) <= tol) {
      break;
    }
 else {
      prevSum=sum;
    }
  }
  out.set(x,y);
}",0.9986013986013986
150771,"@Override public void compute(float x,float y,Point3D_F32 out){
  p2.x=x;
  p2.y=y;
  GeometryMath_F32.mult(K_inv,p2,p2);
  removeRadial(p2.x,p2.y,distortion.radial,distortion.t1,distortion.t2,p2,tol);
  float u=p2.x;
  float v=p2.y;
  float a;
  float xi=mirrorOffset;
  if (mirrorOffset == 1.0f) {
    a=2.0f / (u * u + v * v + 1.0f);
  }
 else {
    float c0=u * u + v * v + 1.0f;
    float c1=-2.0f * xi;
    float c2=xi * xi - 1;
    a=(-c1 + (float)Math.sqrt(c1 * c1 - 4.0f * c0 * c2)) / (2.0f * c0);
  }
  out.x=u * a;
  out.y=v * a;
  out.z=a - xi;
}","@Override public void compute(float x,float y,Point3D_F32 out){
  p2.x=x;
  p2.y=y;
  GeometryMath_F32.mult(K_inv,p2,p2);
  removeRadial(p2.x,p2.y,distortion.radial,distortion.t1,distortion.t2,p2,tol);
  float u=p2.x;
  float v=p2.y;
  float a;
  float xi=mirrorOffset;
  float c0=u * u + v * v + 1.0f;
  float c1=-2.0f * xi;
  float c2=xi * xi - 1;
  a=(-c1 + (float)Math.sqrt(c1 * c1 - 4.0f * c0 * c2)) / (2.0f * c0);
  out.x=u * a;
  out.y=v * a;
  out.z=a - xi;
}",0.8039024390243903
150772,"@Override public void compute(double x,double y,Point3D_F64 out){
  p2.x=x;
  p2.y=y;
  GeometryMath_F64.mult(K_inv,p2,p2);
  removeRadial(p2.x,p2.y,distortion.radial,distortion.t1,distortion.t2,p2,tol);
  double u=p2.x;
  double v=p2.y;
  double a;
  double xi=mirrorOffset;
  if (mirrorOffset == 1.0) {
    a=2.0 / (u * u + v * v + 1.0);
  }
 else {
    double c0=u * u + v * v + 1.0;
    double c1=-2.0 * xi;
    double c2=xi * xi - 1;
    a=(-c1 + Math.sqrt(c1 * c1 - 4.0 * c0 * c2)) / (2.0 * c0);
  }
  out.x=u * a;
  out.y=v * a;
  out.z=a - xi;
}","@Override public void compute(double x,double y,Point3D_F64 out){
  p2.x=x;
  p2.y=y;
  GeometryMath_F64.mult(K_inv,p2,p2);
  removeRadial(p2.x,p2.y,distortion.radial,distortion.t1,distortion.t2,p2,tol);
  double u=p2.x;
  double v=p2.y;
  double a;
  double xi=mirrorOffset;
  double c0=u * u + v * v + 1.0;
  double c1=-2.0 * xi;
  double c2=xi * xi - 1;
  a=(-c1 + Math.sqrt(c1 * c1 - 4.0 * c0 * c2)) / (2.0 * c0);
  out.x=u * a;
  out.y=v * a;
  out.z=a - xi;
}",0.8035363457760314
150773,"@Override public void compute(float x,float y,float z,Point2D_F32 out){
  float[] radial=distortion.radial;
  float t1=distortion.t1;
  float t2=distortion.t2;
  float r2=x * x + y * y;
  float ri2=r2;
  float sum=0;
  for (int i=0; i < radial.length; i++) {
    sum+=radial[i] * ri2;
    ri2*=r2;
  }
  z+=mirrorOffset;
  x/=z;
  y/=z;
  x=x * (1 + sum);
  y=y * (1 + sum);
  x+=2 * t1 * x* y + t2 * (r2 + 2 * x * x);
  y+=t1 * (r2 + 2 * y * y) + 2 * t2 * x* y;
  out.x=fx * x + skew * y + cx;
  out.y=fy * y + cy;
}","@Override public void compute(float x,float y,float z,Point2D_F32 out){
  float[] radial=distortion.radial;
  float t1=distortion.t1;
  float t2=distortion.t2;
  z+=mirrorOffset;
  x/=z;
  y/=z;
  float r2=x * x + y * y;
  float ri2=r2;
  float sum=0;
  for (int i=0; i < radial.length; i++) {
    sum+=radial[i] * ri2;
    ri2*=r2;
  }
  x=x * (1.0f + sum);
  y=y * (1.0f + sum);
  x+=2.0f * t1 * x* y + t2 * (r2 + 2.0f * x * x);
  y+=t1 * (r2 + 2.0f * y * y) + 2.0f * t2 * x* y;
  out.x=fx * x + skew * y + cx;
  out.y=fy * y + cy;
}",0.9163498098859316
150774,"@Override public void compute(double x,double y,double z,Point2D_F64 out){
  double[] radial=distortion.radial;
  double t1=distortion.t1;
  double t2=distortion.t2;
  double r2=x * x + y * y;
  double ri2=r2;
  double sum=0;
  for (int i=0; i < radial.length; i++) {
    sum+=radial[i] * ri2;
    ri2*=r2;
  }
  z+=mirrorOffset;
  x/=z;
  y/=z;
  x=x * (1 + sum);
  y=y * (1 + sum);
  x+=2 * t1 * x* y + t2 * (r2 + 2 * x * x);
  y+=t1 * (r2 + 2 * y * y) + 2 * t2 * x* y;
  out.x=fx * x + skew * y + cx;
  out.y=fy * y + cy;
}","@Override public void compute(double x,double y,double z,Point2D_F64 out){
  double[] radial=distortion.radial;
  double t1=distortion.t1;
  double t2=distortion.t2;
  z+=mirrorOffset;
  x/=z;
  y/=z;
  double r2=x * x + y * y;
  double ri2=r2;
  double sum=0;
  for (int i=0; i < radial.length; i++) {
    sum+=radial[i] * ri2;
    ri2*=r2;
  }
  x=x * (1.0 + sum);
  y=y * (1.0 + sum);
  x+=2.0 * t1 * x* y + t2 * (r2 + 2.0 * x * x);
  y+=t1 * (r2 + 2.0 * y * y) + 2.0 * t2 * x* y;
  out.x=fx * x + skew * y + cx;
  out.y=fy * y + cy;
}",0.7161654135338346
150775,"@Test public void pixel_unit_pixel_F64(){
  LensDistortionWideFOV alg=create();
  Point2Transform3_F64 undistort=alg.undistortPtoS_F64();
  Point3Transform2_F64 distort=alg.distortStoP_F64();
  Point3D_F64 middle=new Point3D_F64();
  Point2D_F64 found=new Point2D_F64();
  undistort.compute(240,260,middle);
  distort.compute(middle.x,middle.y,middle.z,found);
  assertEquals(240,found.x,pixel_tol_F32);
  assertEquals(260,found.y,pixel_tol_F32);
}","@Test public void pixel_unit_pixel_F64(){
  LensDistortionWideFOV alg=create();
  Point2Transform3_F64 undistort=alg.undistortPtoS_F64();
  Point3Transform2_F64 distort=alg.distortStoP_F64();
  Point3D_F64 middle=new Point3D_F64();
  Point2D_F64 found=new Point2D_F64();
  undistort.compute(240,260,middle);
  distort.compute(middle.x,middle.y,middle.z,found);
  assertEquals(240,found.x,pixel_tol_F64);
  assertEquals(260,found.y,pixel_tol_F64);
}",0.9910714285714286
150776,"/** 
 * Request points at the border and see if it has the expected vertical and horizontal FOV
 */
@Test public void checkFOVBounds(){
  NarrowToWidePtoP_F64 alg=createAlg();
  Point2D_F64 foundA=new Point2D_F64();
  Point2D_F64 foundB=new Point2D_F64();
  Point3D_F64 vA=new Point3D_F64();
  Point3D_F64 vB=new Point3D_F64();
  alg.compute(0,250,foundA);
  alg.compute(499,250,foundB);
  Point2Transform3_F64 wideToSphere=createModelWide().undistortPtoS_F64();
  wideToSphere.compute(foundA.x,foundA.y,vA);
  wideToSphere.compute(foundB.x,foundB.y,vB);
  double angle=UtilVector3D_F64.acute(new Vector3D_F64(vA),new Vector3D_F64(vB));
  double expected=2.0 * Math.atan(250.0 / 400.0);
  assertEquals(expected,angle,0.01);
}","/** 
 * Request points at the border and see if it has the expected vertical and horizontal FOV
 */
@Test public void checkFOVBounds(){
  NarrowToWidePtoP_F64 alg=createAlg();
  Point2D_F64 foundA=new Point2D_F64();
  Point2D_F64 foundB=new Point2D_F64();
  Point3D_F64 vA=new Point3D_F64();
  Point3D_F64 vB=new Point3D_F64();
  alg.compute(0,250,foundA);
  alg.compute(500,250,foundB);
  Point2Transform3_F64 wideToSphere=createModelWide().undistortPtoS_F64();
  wideToSphere.compute(foundA.x,foundA.y,vA);
  wideToSphere.compute(foundB.x,foundB.y,vB);
  double found=UtilVector3D_F64.acute(new Vector3D_F64(vA),new Vector3D_F64(vB));
  double expected=2.0 * Math.atan(250.0 / 400.0);
  assertEquals(expected,found,0.01);
  alg.compute(250,0,foundA);
  alg.compute(250,500,foundB);
  wideToSphere.compute(foundA.x,foundA.y,vA);
  wideToSphere.compute(foundB.x,foundB.y,vB);
  found=UtilVector3D_F64.acute(new Vector3D_F64(vA),new Vector3D_F64(vB));
  expected=2.0 * Math.atan(250.0 / 400.0);
  assertEquals(expected,found,0.001);
}",0.8077360637087599
150777,"@Override protected String getPatternName(int num){
  return ""String_Node_Str"" + numbers.get(num);
}","@Override protected String getPatternName(int num){
  return ""String_Node_Str"" + gridWidth + ""String_Node_Str""+ numbers.get(num);
}",0.8658008658008658
150778,"public EquirectangularRotatingApp(List<?> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  panelImage=new ImagePanel();
  add(panelImage,BorderLayout.CENTER);
  BorderType borderType=BorderType.EXTENDED;
  InterpolatePixel<T> interp=FactoryInterpolation.createPixel(0,255,TypeInterpolate.BILINEAR,borderType,imageType);
  distortImage=FactoryDistort.distort(true,interp,imageType);
  distortImage.setRenderAll(true);
  distorted=imageType.createImage(1,1);
  inputCopy=imageType.createImage(1,1);
  panelImage.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      Point2D_F32 latlon=new Point2D_F32();
      Point2D_F32 r=new Point2D_F32();
      EquirectangularTools_F32 tools=distorter.getTools();
      distorter.compute(e.getX(),e.getY());
      tools.equiToLonlat(distorter.distX,distorter.distY,latlon);
      distorter.setCenter(latlon.x,latlon.y);
      distortImage.setModel(distorter);
      if (inputMethod == InputMethod.IMAGE) {
        renderOutput(inputCopy);
      }
    }
  }
);
}","public EquirectangularRotatingApp(List<?> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  panelImage=new ImagePanel();
  add(panelImage,BorderLayout.CENTER);
  BorderType borderType=BorderType.EXTENDED;
  InterpolatePixel<T> interp=FactoryInterpolation.createPixel(0,255,TypeInterpolate.BILINEAR,borderType,imageType);
  distortImage=FactoryDistort.distort(true,interp,imageType);
  distortImage.setRenderAll(true);
  distorted=imageType.createImage(1,1);
  inputCopy=imageType.createImage(1,1);
  panelImage.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      Point2D_F32 latlon=new Point2D_F32();
      EquirectangularTools_F32 tools=distorter.getTools();
      double scale=panelImage.scale;
      distorter.compute((int)(e.getX() / scale),(int)(e.getY() / scale));
      tools.equiToLonlat(distorter.distX,distorter.distY,latlon);
      distorter.setCenter(latlon.x,latlon.y);
      distortImage.setModel(distorter);
      if (inputMethod == InputMethod.IMAGE) {
        renderOutput(inputCopy);
      }
    }
  }
);
}",0.8865313653136532
150779,"@Override public void mouseClicked(MouseEvent e){
  Point2D_F32 latlon=new Point2D_F32();
  Point2D_F32 r=new Point2D_F32();
  EquirectangularTools_F32 tools=distorter.getTools();
  distorter.compute(e.getX(),e.getY());
  tools.equiToLonlat(distorter.distX,distorter.distY,latlon);
  distorter.setCenter(latlon.x,latlon.y);
  distortImage.setModel(distorter);
  if (inputMethod == InputMethod.IMAGE) {
    renderOutput(inputCopy);
  }
}","@Override public void mouseClicked(MouseEvent e){
  Point2D_F32 latlon=new Point2D_F32();
  EquirectangularTools_F32 tools=distorter.getTools();
  double scale=panelImage.scale;
  distorter.compute((int)(e.getX() / scale),(int)(e.getY() / scale));
  tools.equiToLonlat(distorter.distX,distorter.distY,latlon);
  distorter.setCenter(latlon.x,latlon.y);
  distortImage.setModel(distorter);
  if (inputMethod == InputMethod.IMAGE) {
    renderOutput(inputCopy);
  }
}",0.76
150780,"@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  BufferedImage img=this.img;
  if (img != null) {
    if (scaling != ScaleOptions.NONE) {
      double ratioW=(double)getWidth() / (double)img.getWidth();
      double ratioH=(double)getHeight() / (double)img.getHeight();
      double ratio=Math.min(ratioW,ratioH);
      if (scaling == ScaleOptions.DOWN && ratio >= 1)       ratio=1;
      if (ratio == 1) {
        g.drawImage(img,0,0,this);
      }
 else {
        AffineTransform tran=AffineTransform.getScaleInstance(ratio,ratio);
        g2.drawImage(img,tran,null);
      }
    }
 else {
      g2.drawImage(img,0,0,this);
    }
  }
}","@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  BufferedImage img=this.img;
  if (img != null) {
    if (scaling != ScaleOptions.NONE) {
      double ratioW=(double)getWidth() / (double)img.getWidth();
      double ratioH=(double)getHeight() / (double)img.getHeight();
      scale=Math.min(ratioW,ratioH);
      if (scaling == ScaleOptions.DOWN && scale >= 1)       scale=1;
      if (scale == 1) {
        g.drawImage(img,0,0,this);
      }
 else {
        AffineTransform tran=AffineTransform.getScaleInstance(scale,scale);
        g2.drawImage(img,tran,null);
      }
    }
 else {
      scale=1;
      g2.drawImage(img,0,0,this);
    }
  }
}",0.9402560455192034
150781,"@Override public void mouseClicked(MouseEvent e){
  Point2D_F32 latlon=new Point2D_F32();
  double scale=panelEqui.scale;
  int x=(int)(e.getX() / scale);
  int y=(int)(e.getY() / scale);
  if (!equi.isInBounds(x,y))   return;
  distorter.getTools().equiToLonlat(x,y,latlon);
  distorter.setDirection(latlon.x,latlon.y,0);
  DenseMatrix64F A=ConvertRotation3D_F64.eulerToMatrix(EulerType.YZX,Math.PI / 2,0,-Math.PI / 2,null);
  DenseMatrix64F tmp=distorter.getRotation().copy();
  CommonOps.mult(tmp,A,distorter.getRotation());
  distortImage.setModel(distorter);
  if (inputMethod == InputMethod.IMAGE) {
    rerenderPinhole();
  }
}","@Override public void mouseClicked(MouseEvent e){
  Point2D_F32 latlon=new Point2D_F32();
  double scale=panelEqui.scale;
  int x=(int)(e.getX() / scale);
  int y=(int)(e.getY() / scale);
  if (!equi.isInBounds(x,y))   return;
  distorter.getTools().equiToLonlatFV(x,y,latlon);
  distorter.setDirection(latlon.x,latlon.y,0);
  DenseMatrix64F A=ConvertRotation3D_F64.eulerToMatrix(EulerType.YZX,Math.PI / 2,0,Math.PI / 2,null);
  DenseMatrix64F tmp=distorter.getRotation().copy();
  CommonOps.mult(tmp,A,distorter.getRotation());
  distortImage.setModel(distorter);
  if (inputMethod == InputMethod.IMAGE) {
    rerenderPinhole();
  }
}",0.9976359338061466
150782,"@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  DenseMatrix64F R=distorter.getRotation();
  v.set(0,0,1);
  GeometryMath_F64.mult(R,v,v);
  distorter.getTools().normToEqui((float)v.x,(float)v.y,(float)v.z,p);
  circle.setFrame(p.x * scale - 10,p.y * scale - 10,20,20);
  g2.setStroke(stroke1);
  g2.setColor(Color.BLACK);
  g2.draw(circle);
  g2.setStroke(stroke0);
  g2.setColor(Color.RED);
  g2.draw(circle);
}","@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g;
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  DenseMatrix64F R=distorter.getRotation();
  v.set(0,0,1);
  GeometryMath_F64.mult(R,v,v);
  distorter.getTools().normToEquiFV((float)v.x,(float)v.y,(float)v.z,p);
  circle.setFrame(p.x * scale - 10,p.y * scale - 10,20,20);
  g2.setStroke(stroke1);
  g2.setColor(Color.BLACK);
  g2.draw(circle);
  g2.setStroke(stroke0);
  g2.setColor(Color.RED);
  g2.draw(circle);
}",0.9984756097560976
150783,"public EquirectangularPinholeApp(List<?> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  updateIntrinsic();
  distorter.setPinhole(cameraModel);
  BorderType borderType=BorderType.EXTENDED;
  InterpolatePixel<T> interp=FactoryInterpolation.createPixel(0,255,TypeInterpolate.BILINEAR,borderType,imageType);
  distortImage=FactoryDistort.distort(true,interp,imageType);
  distortImage.setRenderAll(true);
  equi=imageType.createImage(1,1);
  pinhole=imageType.createImage(camWidth,camHeight);
  buffPinhole=new BufferedImage(camWidth,camHeight,BufferedImage.TYPE_INT_BGR);
  panelPinhole.setPreferredSize(new Dimension(camWidth,camHeight));
  panelPinhole.setBufferedImage(buffEqui);
  panelPinhole.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      double pitch=0;
      double yaw=0;
      double roll=0;
switch (e.getKeyCode()) {
case KeyEvent.VK_W:
        pitch+=0.01;
      break;
case KeyEvent.VK_S:
    pitch-=0.01;
  break;
case KeyEvent.VK_A:
yaw-=0.01;
break;
case KeyEvent.VK_D:
yaw+=0.01;
break;
case KeyEvent.VK_Q:
roll-=0.01;
break;
case KeyEvent.VK_E:
roll+=0.01;
break;
default :
return;
}
DenseMatrix64F R=ConvertRotation3D_F64.eulerToMatrix(EulerType.YZX,yaw,roll,pitch,null);
DenseMatrix64F tmp=distorter.getRotation().copy();
CommonOps.mult(tmp,R,distorter.getRotation());
distortImage.setModel(distorter);
if (inputMethod == InputMethod.IMAGE) {
rerenderPinhole();
}
}
}
);
panelEqui.addMouseListener(new MouseAdapter(){
@Override public void mouseClicked(MouseEvent e){
Point2D_F32 latlon=new Point2D_F32();
double scale=panelEqui.scale;
int x=(int)(e.getX() / scale);
int y=(int)(e.getY() / scale);
if (!equi.isInBounds(x,y)) return;
distorter.getTools().equiToLonlat(x,y,latlon);
distorter.setDirection(latlon.x,latlon.y,0);
DenseMatrix64F A=ConvertRotation3D_F64.eulerToMatrix(EulerType.YZX,Math.PI / 2,0,-Math.PI / 2,null);
DenseMatrix64F tmp=distorter.getRotation().copy();
CommonOps.mult(tmp,A,distorter.getRotation());
distortImage.setModel(distorter);
if (inputMethod == InputMethod.IMAGE) {
rerenderPinhole();
}
}
}
);
panelPinhole.setFocusable(true);
panelPinhole.grabFocus();
add(panelPinhole,BorderLayout.CENTER);
add(panelEqui,BorderLayout.SOUTH);
}","public EquirectangularPinholeApp(List<?> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  updateIntrinsic();
  distorter.setPinhole(cameraModel);
  BorderType borderType=BorderType.EXTENDED;
  InterpolatePixel<T> interp=FactoryInterpolation.createPixel(0,255,TypeInterpolate.BILINEAR,borderType,imageType);
  distortImage=FactoryDistort.distort(true,interp,imageType);
  distortImage.setRenderAll(true);
  equi=imageType.createImage(1,1);
  pinhole=imageType.createImage(camWidth,camHeight);
  buffPinhole=new BufferedImage(camWidth,camHeight,BufferedImage.TYPE_INT_BGR);
  panelPinhole.setPreferredSize(new Dimension(camWidth,camHeight));
  panelPinhole.setBufferedImage(buffEqui);
  panelPinhole.addKeyListener(new KeyAdapter(){
    @Override public void keyPressed(    KeyEvent e){
      double pitch=0;
      double yaw=0;
      double roll=0;
switch (e.getKeyCode()) {
case KeyEvent.VK_W:
        pitch+=0.01;
      break;
case KeyEvent.VK_S:
    pitch-=0.01;
  break;
case KeyEvent.VK_A:
yaw-=0.01;
break;
case KeyEvent.VK_D:
yaw+=0.01;
break;
case KeyEvent.VK_Q:
roll-=0.01;
break;
case KeyEvent.VK_E:
roll+=0.01;
break;
default :
return;
}
DenseMatrix64F R=ConvertRotation3D_F64.eulerToMatrix(EulerType.YZX,yaw,roll,pitch,null);
DenseMatrix64F tmp=distorter.getRotation().copy();
CommonOps.mult(tmp,R,distorter.getRotation());
distortImage.setModel(distorter);
if (inputMethod == InputMethod.IMAGE) {
rerenderPinhole();
}
}
}
);
panelEqui.addMouseListener(new MouseAdapter(){
@Override public void mouseClicked(MouseEvent e){
Point2D_F32 latlon=new Point2D_F32();
double scale=panelEqui.scale;
int x=(int)(e.getX() / scale);
int y=(int)(e.getY() / scale);
if (!equi.isInBounds(x,y)) return;
distorter.getTools().equiToLonlatFV(x,y,latlon);
distorter.setDirection(latlon.x,latlon.y,0);
DenseMatrix64F A=ConvertRotation3D_F64.eulerToMatrix(EulerType.YZX,Math.PI / 2,0,Math.PI / 2,null);
DenseMatrix64F tmp=distorter.getRotation().copy();
CommonOps.mult(tmp,A,distorter.getRotation());
distortImage.setModel(distorter);
if (inputMethod == InputMethod.IMAGE) {
rerenderPinhole();
}
}
}
);
panelPinhole.setFocusable(true);
panelPinhole.grabFocus();
add(panelPinhole,BorderLayout.CENTER);
add(panelEqui,BorderLayout.SOUTH);
}",0.9993340732519422
150784,"public EquirectangularRotatingApp(List<?> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  panelImage=new ImagePanel();
  add(panelImage,BorderLayout.CENTER);
  BorderType borderType=BorderType.EXTENDED;
  InterpolatePixel<T> interp=FactoryInterpolation.createPixel(0,255,TypeInterpolate.BILINEAR,borderType,imageType);
  distortImage=FactoryDistort.distort(true,interp,imageType);
  distortImage.setRenderAll(true);
  distorted=imageType.createImage(1,1);
  inputCopy=imageType.createImage(1,1);
  panelImage.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      Point2D_F32 latlon=new Point2D_F32();
      EquirectangularTools_F32 tools=distorter.getTools();
      double scale=panelImage.scale;
      distorter.compute((int)(e.getX() / scale),(int)(e.getY() / scale));
      tools.equiToLonlat(distorter.distX,distorter.distY,latlon);
      distorter.setDirection(latlon.x,latlon.y,0);
      distortImage.setModel(distorter);
      if (inputMethod == InputMethod.IMAGE) {
        renderOutput(inputCopy);
      }
    }
  }
);
}","public EquirectangularRotatingApp(List<?> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  panelImage=new ImagePanel();
  add(panelImage,BorderLayout.CENTER);
  BorderType borderType=BorderType.EXTENDED;
  InterpolatePixel<T> interp=FactoryInterpolation.createPixel(0,255,TypeInterpolate.BILINEAR,borderType,imageType);
  distortImage=FactoryDistort.distort(true,interp,imageType);
  distortImage.setRenderAll(true);
  distorted=imageType.createImage(1,1);
  inputCopy=imageType.createImage(1,1);
  panelImage.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      Point2D_F32 latlon=new Point2D_F32();
      EquirectangularTools_F32 tools=distorter.getTools();
      double scale=panelImage.scale;
      distorter.compute((int)(e.getX() / scale),(int)(e.getY() / scale));
      tools.equiToLonlatFV(distorter.distX,distorter.distY,latlon);
      distorter.setDirection(latlon.x,latlon.y,0);
      distortImage.setModel(distorter);
      if (inputMethod == InputMethod.IMAGE) {
        renderOutput(inputCopy);
      }
    }
  }
);
}",0.9990942028985508
150785,"@Override public void mouseClicked(MouseEvent e){
  Point2D_F32 latlon=new Point2D_F32();
  EquirectangularTools_F32 tools=distorter.getTools();
  double scale=panelImage.scale;
  distorter.compute((int)(e.getX() / scale),(int)(e.getY() / scale));
  tools.equiToLonlat(distorter.distX,distorter.distY,latlon);
  distorter.setDirection(latlon.x,latlon.y,0);
  distortImage.setModel(distorter);
  if (inputMethod == InputMethod.IMAGE) {
    renderOutput(inputCopy);
  }
}","@Override public void mouseClicked(MouseEvent e){
  Point2D_F32 latlon=new Point2D_F32();
  EquirectangularTools_F32 tools=distorter.getTools();
  double scale=panelImage.scale;
  distorter.compute((int)(e.getX() / scale),(int)(e.getY() / scale));
  tools.equiToLonlatFV(distorter.distX,distorter.distY,latlon);
  distorter.setDirection(latlon.x,latlon.y,0);
  distortImage.setModel(distorter);
  if (inputMethod == InputMethod.IMAGE) {
    renderOutput(inputCopy);
  }
}",0.997872340425532
150786,"/** 
 * Input is in pinhole camera pixel coordinates.  Output is in equirectangular coordinates
 * @param x Pixel x-coordinate in rendered pinhole camera
 * @param y Pixel y-coordinate in rendered pinhole camera
 */
@Override public void compute(int x,int y){
  Vector3D_F32 v=vectors[y * outWidth + x];
  GeometryMath_F32.mult(R,v,n);
  tools.normToEqui(n.x,n.y,n.z,out);
  distX=out.x;
  distY=out.y;
}","/** 
 * Input is in pinhole camera pixel coordinates.  Output is in equirectangular coordinates
 * @param x Pixel x-coordinate in rendered pinhole camera
 * @param y Pixel y-coordinate in rendered pinhole camera
 */
@Override public void compute(int x,int y){
  Vector3D_F32 v=vectors[y * outWidth + x];
  GeometryMath_F32.mult(R,v,n);
  tools.normToEquiFV(n.x,n.y,n.z,out);
  distX=out.x;
  distY=out.y;
}",0.9975308641975308
150787,"/** 
 * Input is in pinhole camera pixel coordinates.  Output is in equirectangular coordinates
 * @param x Pixel x-coordinate in rendered pinhole camera
 * @param y Pixel y-coordinate in rendered pinhole camera
 */
@Override public void compute(int x,int y){
  Vector3D_F64 v=vectors[y * outWidth + x];
  GeometryMath_F64.mult(R,v,n);
  tools.normToEqui(n.x,n.y,n.z,out);
  distX=out.x;
  distY=out.y;
}","/** 
 * Input is in pinhole camera pixel coordinates.  Output is in equirectangular coordinates
 * @param x Pixel x-coordinate in rendered pinhole camera
 * @param y Pixel y-coordinate in rendered pinhole camera
 */
@Override public void compute(int x,int y){
  Vector3D_F64 v=vectors[y * outWidth + x];
  GeometryMath_F64.mult(R,v,n);
  tools.normToEquiFV(n.x,n.y,n.z,out);
  distX=out.x;
  distY=out.y;
}",0.9975308641975308
150788,"/** 
 * Specifies the image's width and height
 * @param width Image width
 * @param height Image height
 */
public void setImageShape(int width,int height){
  tools.configure(width,height);
  declareVectors(width,height);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      tools.equiToNorm(x,y,vectors[y * width + x]);
    }
  }
}","/** 
 * Specifies the image's width and height
 * @param width Image width
 * @param height Image height
 */
public void setImageShape(int width,int height){
  tools.configure(width,height);
  declareVectors(width,height);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      tools.equiToNormFV(x,y,vectors[y * width + x]);
    }
  }
}",0.9972067039106144
150789,"/** 
 * Specifies the image's width and height
 * @param width Image width
 * @param height Image height
 */
public void setImageShape(int width,int height){
  tools.configure(width,height);
  declareVectors(width,height);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      tools.equiToNorm(x,y,vectors[y * width + x]);
    }
  }
}","/** 
 * Specifies the image's width and height
 * @param width Image width
 * @param height Image height
 */
public void setImageShape(int width,int height){
  tools.configure(width,height);
  declareVectors(width,height);
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      tools.equiToNormFV(x,y,vectors[y * width + x]);
    }
  }
}",0.9972067039106144
150790,"/** 
 * Converts the equirectangular coordinate into a latitude and longitude
 * @param x pixel coordinate in equirectangular image
 * @param y pixel coordinate in equirectangular image
 * @param latlon  (output) x = longitude, y = latitude
 */
public void equiToLonlat(float x,float y,Point2D_F32 latlon){
  latlon.x=(x / width - 0.5f) * GrlConstants.F_PI2;
  latlon.y=(y / height - 0.5f) * GrlConstants.F_PI;
}","/** 
 * Converts the equirectangular coordinate into a latitude and longitude
 * @param x pixel coordinate in equirectangular image
 * @param y pixel coordinate in equirectangular image
 * @param lonlat  (output) x = longitude, y = latitude
 */
public void equiToLonlat(float x,float y,Point2D_F32 lonlat){
  lonlat.x=(x / width - 0.5f) * GrlConstants.F_PI2;
  lonlat.y=(y / height - 0.5f) * GrlConstants.F_PI;
}",0.9514563106796116
150791,"/** 
 * Converts the equirectangular coordinate into a latitude and longitude
 * @param x pixel coordinate in equirectangular image
 * @param y pixel coordinate in equirectangular image
 * @param latlon  (output) x = longitude, y = latitude
 */
public void equiToLonlat(double x,double y,Point2D_F64 latlon){
  latlon.x=(x / width - 0.5) * GrlConstants.PI2;
  latlon.y=(y / height - 0.5) * GrlConstants.PI;
}","/** 
 * Converts the equirectangular coordinate into a latitude and longitude
 * @param x pixel coordinate in equirectangular image
 * @param y pixel coordinate in equirectangular image
 * @param lonlat  (output) x = longitude, y = latitude
 */
public void equiToLonlat(double x,double y,Point2D_F64 lonlat){
  lonlat.x=(x / width - 0.5) * GrlConstants.PI2;
  lonlat.y=(y / height - 0.5) * GrlConstants.PI;
}",0.9509803921568628
150792,"/** 
 * Finds all valid ellipses in the binary image
 * @param binary binary image
 */
public void process(GrayU8 binary){
  labeled.reshape(binary.width,binary.height);
  contourFinder.process(binary,labeled);
  FastQueue<Contour> blobs=contourFinder.getContours();
  for (int i=0; i < blobs.size; i++) {
    Contour c=blobs.get(i);
    if (c.external.size() < minimumContour || (maximumContour > 0 && c.external.size() > maximumContour)) {
      if (verbose)       System.out.println(""String_Node_Str"" + c.external.size());
      continue;
    }
    pointsF.reset();
    undistortContour(c.external,pointsF);
    if (!algebraic.process(pointsF.toList())) {
      if (verbose)       System.out.println(""String_Node_Str"" + pointsF.size());
      continue;
    }
    EllipseQuadratic_F64 quad=algebraic.getEllipse();
    Found f=found.grow();
    UtilEllipse_F64.convert(quad,f.ellipse);
    if (!isApproximatelyElliptical(f.ellipse,pointsF.toList(),20)) {
      if (verbose)       System.out.println(""String_Node_Str"" + pointsF.size());
      found.removeTail();
    }
    if (verbose)     System.out.println(""String_Node_Str"" + pointsF.size());
    f.contour=c.external;
  }
}","/** 
 * Finds all valid ellipses in the binary image
 * @param binary binary image
 */
public void process(GrayU8 binary){
  found.reset();
  labeled.reshape(binary.width,binary.height);
  contourFinder.process(binary,labeled);
  FastQueue<Contour> blobs=contourFinder.getContours();
  for (int i=0; i < blobs.size; i++) {
    Contour c=blobs.get(i);
    proccessContour(c.external);
    if (internalContour) {
      for (int j=0; j < c.internal.size(); j++) {
        proccessContour(c.internal.get(j));
      }
    }
  }
}",0.4467960023515579
150793,"/** 
 * Creates an ellipse detector which will detect all ellipses in the image initially using a binary image and then refine the estimate using a subpixel algorithm in the gray scale image.
 * @param config Configuration for ellipse detector.  null == default
 * @param imageType Input image type
 * @return Detecto
 */
public static <T extends ImageGray>BinaryEllipseDetector<T> ellipse(ConfigEllipseDetector config,Class<T> imageType){
  if (config == null)   config=new ConfigEllipseDetector();
  config.checkValidity();
  BinaryEllipseDetectorPixel detector=new BinaryEllipseDetectorPixel();
  detector.setMaxDistanceFromEllipse(config.maxDistanceFromEllipse);
  detector.setMaximumContour(config.maximumContour);
  detector.setMinimumContour(config.minimumContour);
  SnapToEllipseEdge<T> refine=new SnapToEllipseEdge<T>(config.numSampleContour,config.radialSamples,imageType);
  refine.setConvergenceTol(config.convergenceTol);
  refine.setMaxIterations(config.maxIterations);
  return new BinaryEllipseDetector<T>(detector,refine);
}","/** 
 * Creates an ellipse detector which will detect all ellipses in the image initially using a binary image and then refine the estimate using a subpixel algorithm in the gray scale image.
 * @param config Configuration for ellipse detector.  null == default
 * @param imageType Input image type
 * @return Detecto
 */
public static <T extends ImageGray>BinaryEllipseDetector<T> ellipse(ConfigEllipseDetector config,Class<T> imageType){
  if (config == null)   config=new ConfigEllipseDetector();
  config.checkValidity();
  BinaryEllipseDetectorPixel detector=new BinaryEllipseDetectorPixel();
  detector.setMaxDistanceFromEllipse(config.maxDistanceFromEllipse);
  detector.setMaximumContour(config.maximumContour);
  detector.setMinimumContour(config.minimumContour);
  detector.setInternalContour(config.processInternal);
  SnapToEllipseEdge<T> refine=new SnapToEllipseEdge<T>(config.numSampleContour,config.radialSamples,imageType);
  refine.setConvergenceTol(config.convergenceTol);
  refine.setMaxIterations(config.maxIterations);
  return new BinaryEllipseDetector<T>(detector,refine);
}",0.9742870500233756
150794,"/** 
 * Detects ellipses inside the binary image and refines the edges for all detections inside the gray image
 * @param gray Grayscale image
 * @param binary Binary image of grayscale. 1 = ellipse and 0 = ignored background
 */
public void process(T gray,GrayU8 binary){
  refined.reset();
  ellipseDetector.process(binary);
  ellipseRefiner.setImage(gray);
  intensityCheck.setImage(gray);
  List<BinaryEllipseDetectorPixel.Found> found=ellipseDetector.getFound();
  for (  BinaryEllipseDetectorPixel.Found f : found) {
    if (!intensityCheck.process(f.ellipse)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    EllipseRotated_F64 r=refined.grow();
    if (ellipseRefiner != null) {
      if (!ellipseRefiner.process(f.ellipse,r)) {
        refined.removeTail();
      }
    }
 else {
      r.set(f.ellipse);
    }
  }
}","/** 
 * Detects ellipses inside the binary image and refines the edges for all detections inside the gray image
 * @param gray Grayscale image
 * @param binary Binary image of grayscale. 1 = ellipse and 0 = ignored background
 */
public void process(T gray,GrayU8 binary){
  refined.reset();
  ellipseDetector.process(binary);
  if (ellipseRefiner != null)   ellipseRefiner.setImage(gray);
  intensityCheck.setImage(gray);
  List<BinaryEllipseDetectorPixel.Found> found=ellipseDetector.getFound();
  for (  BinaryEllipseDetectorPixel.Found f : found) {
    if (!intensityCheck.process(f.ellipse)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    EllipseRotated_F64 r=refined.grow();
    if (ellipseRefiner != null) {
      if (!ellipseRefiner.process(f.ellipse,r)) {
        refined.removeTail();
      }
    }
 else {
      r.set(f.ellipse);
    }
  }
}",0.9829931972789115
150795,"public Class<T> getInputType(){
  return ellipseRefiner.getInputType();
}","public Class<T> getInputType(){
  return inputType;
}",0.8412698412698413
150796,"/** 
 * <p>Specifies transforms which can be used to change coordinates from distorted to undistorted. The undistorted image is never explicitly created.</p> <p> WARNING: The undistorted image must have the same bounds as the distorted input image.  This is because several of the bounds checks use the image shape.  This are simplified greatly by this assumption. </p>
 * @param distToUndist Transform from distorted to undistorted image.
 */
public void setLensDistortion(PixelTransform_F32 distToUndist){
  this.ellipseDetector.setLensDistortion(distToUndist);
  this.ellipseRefiner.setTransform(distToUndist);
  this.intensityCheck.setTransform(distToUndist);
}","/** 
 * <p>Specifies transforms which can be used to change coordinates from distorted to undistorted. The undistorted image is never explicitly created.</p> <p> WARNING: The undistorted image must have the same bounds as the distorted input image.  This is because several of the bounds checks use the image shape.  This are simplified greatly by this assumption. </p>
 * @param distToUndist Transform from distorted to undistorted image.
 */
public void setLensDistortion(PixelTransform_F32 distToUndist){
  this.ellipseDetector.setLensDistortion(distToUndist);
  if (this.ellipseRefiner != null)   this.ellipseRefiner.setTransform(distToUndist);
  this.intensityCheck.setTransform(distToUndist);
}",0.9743589743589745
150797,"public BinaryEllipseDetector(BinaryEllipseDetectorPixel ellipseDetector,SnapToEllipseEdge<T> ellipseRefiner,EdgeIntensityEllipse<T> intensityCheck){
  this.ellipseDetector=ellipseDetector;
  this.ellipseRefiner=ellipseRefiner;
  this.intensityCheck=intensityCheck;
}","public BinaryEllipseDetector(BinaryEllipseDetectorPixel ellipseDetector,SnapToEllipseEdge<T> ellipseRefiner,EdgeIntensityEllipse<T> intensityCheck,Class<T> inputType){
  this.ellipseDetector=ellipseDetector;
  this.ellipseRefiner=ellipseRefiner;
  this.intensityCheck=intensityCheck;
  this.inputType=inputType;
}",0.918825561312608
150798,"/** 
 * Refines provided list by snapping it to edges found in the image
 * @param input Close approximation of the ellipse in the image
 * @param refined Storage for refined estimate.
 * @return True if a refined estimate could be found, false if it failed
 */
public boolean process(EllipseRotated_F64 input,EllipseRotated_F64 refined){
  previous.set(input);
  for (int iteration=0; iteration < maxIterations; iteration++) {
    refined.set(previous);
    computePointsAndWeights(refined);
    if (fitter.process(samplePts.toList(),weights.data)) {
      UtilEllipse_F64.convert(fitter.getEllipse(),refined);
      double scale=previous.a;
      refined.center.x=refined.center.x * scale + previous.center.x;
      refined.center.y=refined.center.y * scale + previous.center.y;
      refined.a*=scale;
      refined.b*=scale;
    }
 else {
      return false;
    }
    if (change(previous,refined) <= convergenceTol) {
      return true;
    }
  }
  return true;
}","/** 
 * Refines provided list by snapping it to edges found in the image
 * @param input Close approximation of the ellipse in the image
 * @param refined Storage for refined estimate.
 * @return True if a refined estimate could be found, false if it failed
 */
public boolean process(EllipseRotated_F64 input,EllipseRotated_F64 refined){
  refined.set(input);
  previous.set(input);
  for (int iteration=0; iteration < maxIterations; iteration++) {
    refined.set(previous);
    computePointsAndWeights(refined);
    if (fitter.process(samplePts.toList(),weights.data)) {
      UtilEllipse_F64.convert(fitter.getEllipse(),refined);
      double scale=previous.a;
      refined.center.x=refined.center.x * scale + previous.center.x;
      refined.center.y=refined.center.y * scale + previous.center.y;
      refined.a*=scale;
      refined.b*=scale;
    }
 else {
      return false;
    }
    if (change(previous,refined) <= convergenceTol) {
      return true;
    }
  }
  return true;
}",0.9887640449438202
150799,"/** 
 * Creates an ellipse detector which will detect all ellipses in the image initially using a binary image and then refine the estimate using a subpixel algorithm in the gray scale image.
 * @param config Configuration for ellipse detector.  null == default
 * @param imageType Input image type
 * @return Detecto
 */
public static <T extends ImageGray>BinaryEllipseDetector<T> ellipse(ConfigEllipseDetector config,Class<T> imageType){
  if (config == null)   config=new ConfigEllipseDetector();
  config.checkValidity();
  BinaryEllipseDetectorPixel detector=new BinaryEllipseDetectorPixel();
  detector.setMaxDistanceFromEllipse(config.maxDistanceFromEllipse);
  detector.setMaximumContour(config.maximumContour);
  detector.setMinimumContour(config.minimumContour);
  detector.setInternalContour(config.processInternal);
  SnapToEllipseEdge<T> refine=new SnapToEllipseEdge<T>(config.numSampleContour,config.refineRadialSamples,imageType);
  refine.setConvergenceTol(config.convergenceTol);
  refine.setMaxIterations(config.maxIterations);
  if (config.numSampleContour <= 0) {
    refine=null;
  }
  EdgeIntensityEllipse<T> check=new EdgeIntensityEllipse<T>(config.checkRadialDistance,config.numSampleContour,config.checkIntensityThreshold,imageType);
  return new BinaryEllipseDetector<T>(detector,refine,check);
}","/** 
 * Creates an ellipse detector which will detect all ellipses in the image initially using a binary image and then refine the estimate using a subpixel algorithm in the gray scale image.
 * @param config Configuration for ellipse detector.  null == default
 * @param imageType Input image type
 * @return Detecto
 */
public static <T extends ImageGray>BinaryEllipseDetector<T> ellipse(ConfigEllipseDetector config,Class<T> imageType){
  if (config == null)   config=new ConfigEllipseDetector();
  config.checkValidity();
  BinaryEllipseDetectorPixel detector=new BinaryEllipseDetectorPixel();
  detector.setMaxDistanceFromEllipse(config.maxDistanceFromEllipse);
  detector.setMaximumContour(config.maximumContour);
  detector.setMinimumContour(config.minimumContour);
  detector.setInternalContour(config.processInternal);
  SnapToEllipseEdge<T> refine=new SnapToEllipseEdge<T>(config.numSampleContour,config.refineRadialSamples,imageType);
  refine.setConvergenceTol(config.convergenceTol);
  refine.setMaxIterations(config.maxIterations);
  if (config.maxIterations <= 0 || config.numSampleContour <= 0) {
    refine=null;
  }
  EdgeIntensityEllipse<T> check=new EdgeIntensityEllipse<T>(config.checkRadialDistance,config.numSampleContour,config.checkIntensityThreshold,imageType);
  return new BinaryEllipseDetector<T>(detector,refine,check,imageType);
}",0.9735370853522176
150800,"public static <T extends ImageInterleaved<T>>T convertFrom(IplImage input,T output){
  ImageDataType dataType=depthToBoofType(input.depth());
  int numBands=input.nChannels();
  int width=input.width();
  int height=input.height();
  if (output != null) {
    if (output.isSubimage())     throw new IllegalArgumentException(""String_Node_Str"");
    if (output.getDataType() != dataType)     throw new IllegalArgumentException(""String_Node_Str"" + dataType + ""String_Node_Str""+ output.getDataType()+ ""String_Node_Str"");
    output.numBands=numBands;
    output.reshape(width,height);
  }
 else {
    output=GeneralizedImageOps.createInterleaved(dataType,width,height,numBands);
  }
switch (dataType) {
case U8:
case S8:
    convertFrom_I(input,(InterleavedI8)output);
  break;
case S16:
convertFrom_I(input,(InterleavedS16)output);
break;
case S32:
convertFrom_I(input,(InterleavedS32)output);
break;
case F32:
convertFrom_I(input,(InterleavedF32)output);
break;
case F64:
convertFrom_I(input,(InterleavedF64)output);
break;
default :
throw new RuntimeException(""String_Node_Str"" + dataType);
}
return output;
}","public static <T extends ImageInterleaved>T convertFrom(IplImage input,T output){
  ImageDataType dataType=depthToBoofType(input.depth());
  int numBands=input.nChannels();
  int width=input.width();
  int height=input.height();
  if (output != null) {
    if (output.isSubimage())     throw new IllegalArgumentException(""String_Node_Str"");
    if (output.getDataType() != dataType)     throw new IllegalArgumentException(""String_Node_Str"" + dataType + ""String_Node_Str""+ output.getDataType()+ ""String_Node_Str"");
    output.numBands=numBands;
    output.reshape(width,height);
  }
 else {
    output=GeneralizedImageOps.createInterleaved(dataType,width,height,numBands);
  }
switch (dataType) {
case U8:
case S8:
    convertFrom_I(input,(InterleavedI8)output);
  break;
case S16:
convertFrom_I(input,(InterleavedS16)output);
break;
case S32:
convertFrom_I(input,(InterleavedS32)output);
break;
case F32:
convertFrom_I(input,(InterleavedF32)output);
break;
case F64:
convertFrom_I(input,(InterleavedF64)output);
break;
default :
throw new RuntimeException(""String_Node_Str"" + dataType);
}
return output;
}",0.998644374152734
150801,"/** 
 * Constructor in which the prefered width and height is specified in pixels
 * @param widthPixels preferred width and height
 */
public ConfusionMatrixPanel(int widthPixels){
  int heightPixels=widthPixels;
  if (labels != null) {
    heightPixels*=1.0 - labelViewFraction;
  }
  setPreferredSize(new Dimension(widthPixels,heightPixels));
}","/** 
 * Constructor in which the prefered width and height is specified in pixels
 * @param widthPixels preferred width and height
 */
public ConfusionMatrixPanel(int widthPixels,List<String> labels){
  setLabels(labels);
  int heightPixels=widthPixels;
  if (labels != null) {
    heightPixels*=1.0 - labelViewFraction;
  }
  setPreferredSize(new Dimension(widthPixels,heightPixels));
}",0.9440654843110504
150802,"/** 
 * Checks to see if its a valid polygon or a false positive by looking at edge intensity
 * @param polygon The polygon being tested
 * @param ccw True if the polygon is counter clockwise
 * @return true if it could compute the edge intensity, otherwise false
 */
public boolean computeEdge(Polygon2D_F64 polygon,boolean ccw){
  averageInside=0;
  averageOutside=0;
  double tagentSign=ccw ? 1 : -1;
  int totalSides=0;
  for (int i=polygon.size() - 1, j=0; j < polygon.size(); i=j, j++) {
    Point2D_F64 a=polygon.get(i);
    Point2D_F64 b=polygon.get(j);
    double dx=b.x - a.x;
    double dy=b.y - a.y;
    double t=Math.sqrt(dx * dx + dy * dy);
    dx/=t;
    dy/=t;
    if (t <= 3 * cornerOffset)     return false;
    offsetA.x=a.x + cornerOffset * dx;
    offsetA.y=a.y + cornerOffset * dy;
    offsetB.x=b.x - cornerOffset * dx;
    offsetB.y=b.y - cornerOffset * dy;
    double tanX=-dy * tangentDistance * tagentSign;
    double tanY=dx * tangentDistance * tagentSign;
    scorer.computeAverageDerivative(offsetA,offsetB,tanX,tanY);
    if (scorer.getSamplesInside() > 0) {
      totalSides++;
      averageInside+=scorer.getAverageUp() / tangentDistance;
      averageOutside+=scorer.getAverageDown() / tangentDistance;
    }
  }
  if (totalSides > 0) {
    averageInside/=totalSides;
    averageOutside/=totalSides;
  }
 else {
    averageInside=averageOutside=0;
    return false;
  }
  return true;
}","/** 
 * Checks to see if its a valid polygon or a false positive by looking at edge intensity
 * @param polygon The polygon being tested
 * @param ccw True if the polygon is counter clockwise
 * @return true if it could compute the edge intensity, otherwise false
 */
public boolean computeEdge(Polygon2D_F64 polygon,boolean ccw){
  averageInside=0;
  averageOutside=0;
  double tangentSign=ccw ? 1 : -1;
  int totalSides=0;
  for (int i=polygon.size() - 1, j=0; j < polygon.size(); i=j, j++) {
    Point2D_F64 a=polygon.get(i);
    Point2D_F64 b=polygon.get(j);
    double dx=b.x - a.x;
    double dy=b.y - a.y;
    double t=Math.sqrt(dx * dx + dy * dy);
    dx/=t;
    dy/=t;
    if (t <= 3 * cornerOffset)     return false;
    offsetA.x=a.x + cornerOffset * dx;
    offsetA.y=a.y + cornerOffset * dy;
    offsetB.x=b.x - cornerOffset * dx;
    offsetB.y=b.y - cornerOffset * dy;
    double tanX=-dy * tangentDistance * tangentSign;
    double tanY=dx * tangentDistance * tangentSign;
    scorer.computeAverageDerivative(offsetA,offsetB,tanX,tanY);
    if (scorer.getSamplesInside() > 0) {
      totalSides++;
      averageInside+=scorer.getAverageUp() / tangentDistance;
      averageOutside+=scorer.getAverageDown() / tangentDistance;
    }
  }
  if (totalSides > 0) {
    averageInside/=totalSides;
    averageOutside/=totalSides;
  }
 else {
    averageInside=averageOutside=0;
    return false;
  }
  return true;
}",0.9989447766443896
150803,"private void global(Graphics2D g2){
  int cell=hog.getWidthCell();
  int rows=hog.getCellRows();
  int cols=hog.getCellCols();
  int width=cell * cols;
  int height=cell * rows;
  int numAngles=hog.getOrientationBins();
  float r=cell / 2;
  float maxValue=0;
  for (int y=0; y < rows; y++) {
    for (int x=0; x < cols; x++) {
      DescribeDenseHogAlg.Cell c=hog.getCell(y,x);
      for (int i=0; i < numAngles; i++) {
        maxValue=Math.max(maxValue,c.histogram[i]);
      }
    }
  }
  System.out.println(""String_Node_Str"" + maxValue);
  Line2D.Float line=new Line2D.Float();
  for (int y=0; y < height; y+=cell) {
    float c_y=y + r;
    for (int x=0; x < width; x+=cell) {
      DescribeDenseHogAlg.Cell c=hog.getCell(y / cell,x / cell);
      float c_x=x + r;
      for (int i=0; i < numAngles; i++) {
        int a=(int)(255.0f * c.histogram[i] / maxValue + 0.5f);
        g2.setColor(colors[a]);
        float x0=c_x - r * cos[i] + 0.5f;
        float x1=c_x + r * cos[i] + 0.5f;
        float y0=c_y - r * sin[i] + 0.5f;
        float y1=c_y + r * sin[i] + 0.5f;
        line.setLine(x0,y0,x1,y1);
        g2.draw(line);
      }
    }
  }
}","private void global(Graphics2D g2){
  int cell=hog.getWidthCell();
  int rows=hog.getCellRows();
  int cols=hog.getCellCols();
  int width=cell * cols;
  int height=cell * rows;
  int numAngles=hog.getOrientationBins();
  float r=cell / 2;
  float foo=cell / 2 - 2;
  float maxValue=0;
  for (int y=0; y < rows; y++) {
    for (int x=0; x < cols; x++) {
      DescribeDenseHogAlg.Cell c=hog.getCell(y,x);
      for (int i=0; i < numAngles; i++) {
        maxValue=Math.max(maxValue,c.histogram[i]);
      }
    }
  }
  Line2D.Float line=new Line2D.Float();
  for (int y=0; y < height; y+=cell) {
    float c_y=y + r;
    for (int x=0; x < width; x+=cell) {
      DescribeDenseHogAlg.Cell c=hog.getCell(y / cell,x / cell);
      float c_x=x + r;
      for (int i=0; i < numAngles; i++) {
        int a=(int)(255.0f * c.histogram[i] / maxValue + 0.5f);
        g2.setColor(colors[a]);
        float x0=c_x - foo * cos[i];
        float x1=c_x + foo * cos[i];
        float y0=c_y - foo * sin[i];
        float y1=c_y + foo * sin[i];
        line.setLine(x0,y0,x1,y1);
        g2.draw(line);
      }
    }
  }
}",0.9460654288240496
150804,"public void render(Graphics2D g2){
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g2.setStroke(new BasicStroke(1));
  if (localMax) {
    local(g2);
  }
 else {
    global(g2);
  }
}","public void render(Graphics2D g2){
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_OFF);
  if (showGrid) {
    int cell=hog.getWidthCell();
    int rows=hog.getCellRows();
    int cols=hog.getCellCols();
    int width=cell * cols;
    int height=cell * rows;
    g2.setColor(new Color(150,150,0));
    g2.setStroke(new BasicStroke(1));
    for (int i=0; i < rows; i++) {
      g2.drawLine(0,i * cell,width,i * cell);
    }
    for (int i=0; i < cols; i++) {
      g2.drawLine(i * cell,0,i * cell,height);
    }
  }
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g2.setStroke(new BasicStroke(1));
  if (localMax) {
    local(g2);
  }
 else {
    global(g2);
  }
}",0.5516045099739809
150805,"private void local(Graphics2D g2){
  int cell=hog.getWidthCell();
  int rows=hog.getCellRows();
  int cols=hog.getCellCols();
  int width=cell * cols;
  int height=cell * rows;
  int numAngles=hog.getOrientationBins();
  float r=cell / 2;
  Line2D.Float line=new Line2D.Float();
  for (int y=0; y < height; y+=cell) {
    float c_y=y + r;
    for (int x=0; x < width; x+=cell) {
      DescribeDenseHogAlg.Cell c=hog.getCell(y / cell,x / cell);
      float c_x=x + r;
      float maxValue=0;
      for (int i=0; i < c.histogram.length; i++) {
        maxValue=Math.max(maxValue,c.histogram[i]);
      }
      for (int i=0; i < numAngles; i++) {
        int a=(int)(255.0f * c.histogram[i] / maxValue + 0.5f);
        g2.setColor(colors[a]);
        float x0=c_x - r * cos[i] + 0.5f;
        float x1=c_x + r * cos[i] + 0.5f;
        float y0=c_y - r * sin[i] + 0.5f;
        float y1=c_y + r * sin[i] + 0.5f;
        line.setLine(x0,y0,x1,y1);
        g2.draw(line);
      }
    }
  }
}","private void local(Graphics2D g2){
  int cell=hog.getWidthCell();
  int rows=hog.getCellRows();
  int cols=hog.getCellCols();
  int width=cell * cols;
  int height=cell * rows;
  int numAngles=hog.getOrientationBins();
  float r=cell / 2 - 1;
  Line2D.Float line=new Line2D.Float();
  for (int y=0; y < height; y+=cell) {
    float c_y=y + r;
    for (int x=0; x < width; x+=cell) {
      DescribeDenseHogAlg.Cell c=hog.getCell(y / cell,x / cell);
      float c_x=x + r;
      float maxValue=0;
      for (int i=0; i < c.histogram.length; i++) {
        maxValue=Math.max(maxValue,c.histogram[i]);
      }
      for (int i=0; i < numAngles; i++) {
        int a=(int)(255.0f * c.histogram[i] / maxValue + 0.5f);
        g2.setColor(colors[a]);
        float x0=c_x - r * cos[i];
        float x1=c_x + r * cos[i];
        float y0=c_y - r * sin[i];
        float y1=c_y + r * sin[i];
        line.setLine(x0,y0,x1,y1);
        g2.draw(line);
      }
    }
  }
}",0.9835560123329908
150806,"public VisualizeImageHogApp(ConfigDenseHoG config,List<String> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  hog=FactoryDescribeImageDenseAlg.hog(config,imageType);
  visualizers=new VisualizeHogCells(hog,true);
  visualizers.setLocalMax(false);
  add(imagePanel,BorderLayout.CENTER);
}","public VisualizeImageHogApp(ConfigDenseHoG config,List<String> exampleInputs,ImageType<T> imageType){
  super(exampleInputs,imageType);
  hog=FactoryDescribeImageDenseAlg.hog(config,imageType);
  visualizers=new VisualizeHogCells(hog,true);
  visualizers.setLocalMax(false);
  add(imagePanel,BorderLayout.CENTER);
  imagePanel.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
    }
    @Override public void mousePressed(    MouseEvent e){
      int row=e.getY() / hog.getWidthCell();
      int col=e.getX() / hog.getWidthCell();
      if (row >= 0 && col >= 0 && row < hog.getCellRows() && col < hog.getCellCols()) {
        DescribeDenseHogAlg.Cell c=hog.getCell(row,col);
        System.out.print(""String_Node_Str"" + row + ""String_Node_Str""+ col+ ""String_Node_Str"");
        for (int i=0; i < c.histogram.length; i++) {
          System.out.print(""String_Node_Str"" + c.histogram[i]);
        }
        System.out.println();
      }
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
  }
);
}",0.4191616766467065
150807,"/** 
 * Compute histograms for all the cells inside the image using precomputed derivative.
 */
void computeCellHistograms(){
  int width=cellCols * widthCell;
  int height=cellRows * widthCell;
  float angleBinSize=GrlConstants.F_PI / orientationBins;
  int indexCell=0;
  for (int i=0; i < height; i+=widthCell) {
    for (int j=0; j < width; j+=widthCell, indexCell++) {
      Cell c=cells[indexCell];
      c.reset();
      for (int k=0; k < widthCell; k++) {
        int indexPixel=(i + k) * derivX.width + j;
        for (int l=0; l < widthCell; l++, indexPixel++) {
          computeDerivative(indexPixel);
          float angle=UtilAngle.atanSafe(pixelDY,pixelDX) + GrlConstants.F_PId2;
          float magnitude=(float)Math.sqrt(pixelDX * pixelDX + pixelDY * pixelDY);
          float findex0=angle / angleBinSize;
          int index0=(int)findex0;
          int index1=(index0 + 1) % orientationBins;
          float weight1=findex0 - index0;
          c.histogram[index0 % orientationBins]=magnitude * (1.0f - weight1);
          c.histogram[index1]=magnitude * weight1;
        }
      }
    }
  }
}","/** 
 * Compute histograms for all the cells inside the image using precomputed derivative.
 */
void computeCellHistograms(){
  int width=cellCols * widthCell;
  int height=cellRows * widthCell;
  float angleBinSize=GrlConstants.F_PI / orientationBins;
  int indexCell=0;
  for (int i=0; i < height; i+=widthCell) {
    for (int j=0; j < width; j+=widthCell, indexCell++) {
      Cell c=cells[indexCell];
      c.reset();
      for (int k=0; k < widthCell; k++) {
        int indexPixel=(i + k) * derivX.width + j;
        for (int l=0; l < widthCell; l++, indexPixel++) {
          computeDerivative(indexPixel);
          float angle=UtilAngle.atanSafe(pixelDY,pixelDX) + GrlConstants.F_PId2;
          float magnitude=(float)Math.sqrt(pixelDX * pixelDX + pixelDY * pixelDY);
          float findex0=angle / angleBinSize;
          int index0=(int)findex0;
          float weight1=findex0 - index0;
          index0%=orientationBins;
          int index1=(index0 + 1) % orientationBins;
          c.histogram[index0]+=magnitude * (1.0f - weight1);
          c.histogram[index1]+=magnitude * weight1;
        }
      }
    }
  }
}",0.9210878288007134
150808,"private static int maxAbsU(short[] array,int startIndex,int rows,int columns,int stride){
  int output=array[startIndex];
  for (int y=0; y < rows; y++) {
    int index=startIndex + y * stride;
    int end=index + columns;
    for (; index < end; index++) {
      int v=array[index] & 0xFFFF;
      if (v > output)       output=v;
    }
  }
  return output;
}","private static int maxAbsU(short[] array,int startIndex,int rows,int columns,int stride){
  int output=array[startIndex] & 0xFFFF;
  for (int y=0; y < rows; y++) {
    int index=startIndex + y * stride;
    int end=index + columns;
    for (; index < end; index++) {
      int v=array[index] & 0xFFFF;
      if (v > output)       output=v;
    }
  }
  return output;
}",0.9876203576341128
150809,"private static int maxU(short[] array,int startIndex,int rows,int columns,int stride){
  int output=array[startIndex];
  for (int y=0; y < rows; y++) {
    int index=startIndex + y * stride;
    int end=index + columns;
    for (; index < end; index++) {
      int v=array[index] & 0xFFFF;
      if (v > output)       output=v;
    }
  }
  return output;
}","private static int maxU(short[] array,int startIndex,int rows,int columns,int stride){
  int output=array[startIndex] & 0xFFFF;
  for (int y=0; y < rows; y++) {
    int index=startIndex + y * stride;
    int end=index + columns;
    for (; index < end; index++) {
      int v=array[index] & 0xFFFF;
      if (v > output)       output=v;
    }
  }
  return output;
}",0.9875173370319
150810,"private static int minU(short[] array,int startIndex,int rows,int columns,int stride){
  int output=array[startIndex];
  for (int y=0; y < rows; y++) {
    int index=startIndex + y * stride;
    int end=index + columns;
    for (; index < end; index++) {
      int v=array[index] & 0xFFFF;
      if (v < output)       output=v;
    }
  }
  return output;
}","private static int minU(short[] array,int startIndex,int rows,int columns,int stride){
  int output=array[startIndex] & 0xFFFF;
  for (int y=0; y < rows; y++) {
    int index=startIndex + y * stride;
    int end=index + columns;
    for (; index < end; index++) {
      int v=array[index] & 0xFFFF;
      if (v < output)       output=v;
    }
  }
  return output;
}",0.9875173370319
150811,"private void testMax(Method m) throws InvocationTargetException, IllegalAccessException {
  Class paramTypes[]=m.getParameterTypes();
  ImageBase input=GeneralizedImageOps.createImage(paramTypes[0],width,height,numBands);
  if (input.getImageType().getDataType().isSigned()) {
    GImageMiscOps.fillUniform(input,rand,-20,-5);
    GeneralizedImageOps.setB(input,0,3,0,-2);
    Number o=(Number)m.invoke(null,input);
    assertEquals(-2,o.doubleValue(),1e-8);
  }
 else {
    GImageMiscOps.fillUniform(input,rand,0,20);
    GeneralizedImageOps.setB(input,0,3,0,100);
    Number o=(Number)m.invoke(null,input);
    assertEquals(100,o.doubleValue(),1e-8);
  }
}","private void testMax(Method m) throws InvocationTargetException, IllegalAccessException {
  Class paramTypes[]=m.getParameterTypes();
  ImageBase input=GeneralizedImageOps.createImage(paramTypes[0],width,height,numBands);
  if (input.getImageType().getDataType().isSigned()) {
    GImageMiscOps.fillUniform(input,rand,-20,-5);
    GeneralizedImageOps.setB(input,0,3,0,-2);
    Number o=(Number)m.invoke(null,input);
    assertEquals(-2,o.doubleValue(),1e-8);
  }
 else {
    GImageMiscOps.fillUniform(input,rand,0,200);
    double maxValue=input.getImageType().getDataType().getMaxValue();
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        double before=GeneralizedImageOps.get(input,x,y,0);
        GeneralizedImageOps.setB(input,x,y,0,maxValue);
        Number o=(Number)m.invoke(null,input);
        assertEquals(maxValue,o.doubleValue(),1e-8);
        GeneralizedImageOps.setB(input,x,y,0,before);
      }
    }
  }
}",0.7890818858560794
150812,"private void testMin(Method m) throws InvocationTargetException, IllegalAccessException {
  Class paramTypes[]=m.getParameterTypes();
  ImageBase input=GeneralizedImageOps.createImage(paramTypes[0],width,height,numBands);
  if (input.getImageType().getDataType().isSigned()) {
    GImageMiscOps.fillUniform(input,rand,-20,-5);
    GeneralizedImageOps.setB(input,0,3,0,-30);
    Number o=(Number)m.invoke(null,input);
    assertEquals(-30,o.doubleValue(),1e-8);
  }
 else {
    GImageMiscOps.fillUniform(input,rand,5,20);
    GeneralizedImageOps.setB(input,0,3,0,2);
    Number o=(Number)m.invoke(null,input);
    assertEquals(2,o.doubleValue(),1e-8);
  }
}","private void testMin(Method m) throws InvocationTargetException, IllegalAccessException {
  Class paramTypes[]=m.getParameterTypes();
  ImageBase input=GeneralizedImageOps.createImage(paramTypes[0],width,height,numBands);
  if (input.getImageType().getDataType().isSigned()) {
    GImageMiscOps.fillUniform(input,rand,-20,-5);
    GeneralizedImageOps.setB(input,0,3,0,-30);
    Number o=(Number)m.invoke(null,input);
    assertEquals(-30,o.doubleValue(),1e-8);
  }
 else {
    double maxValue=input.getImageType().getDataType().getMaxValue();
    GImageMiscOps.fillUniform(input,rand,100,maxValue);
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        double before=GeneralizedImageOps.get(input,x,y,0);
        GeneralizedImageOps.setB(input,x,y,0,5);
        Number o=(Number)m.invoke(null,input);
        assertEquals(5,o.doubleValue(),1e-8);
        GeneralizedImageOps.setB(input,x,y,0,before);
      }
    }
  }
}",0.7526479750778816
150813,"public static void main(String[] args){
  ConfigDenseSurfFast surfFast=new ConfigDenseSurfFast(new DenseSampling(8,8));
  ConfigDenseSurfStable surfStable=new ConfigDenseSurfStable(new DenseSampling(8,8));
  ConfigDenseSift sift=new ConfigDenseSift(new DenseSampling(6,6));
  ConfigDenseHoG hog=new ConfigDenseHoG();
  DescribeImageDense<ImageUInt8,TupleDesc_F64> desc=(DescribeImageDense)FactoryDescribeImageDense.surfFast(surfFast,ImageUInt8.class);
  ComputeClusters<double[]> clusterer=FactoryClustering.kMeans_F64(null,MAX_KNN_ITERATIONS,20,1e-6);
  clusterer.setVerbose(true);
  NearestNeighbor<HistogramScene> nn=FactoryNearestNeighbor.exhaustive();
  ExampleClassifySceneKnn example=new ExampleClassifySceneKnn(desc,clusterer,nn);
  File trainingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  File testingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  if (!trainingDir.exists() || !testingDir.exists()) {
    String path=UtilIO.pathExample(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + path + ""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  example.loadSets(trainingDir,null,testingDir);
  example.learnAndSave();
  example.loadAndCreateClassifier();
  Confusion confusion=example.evaluateTest();
  confusion.getMatrix().print();
  System.out.println(""String_Node_Str"" + confusion.computeAccuracy());
  ShowImages.showWindow(new ConfusionMatrixPanel(confusion.getMatrix(),400,true),""String_Node_Str"",true);
}","public static void main(String[] args){
  ConfigDenseSurfFast surfFast=new ConfigDenseSurfFast(new DenseSampling(8,8));
  ConfigDenseSurfStable surfStable=new ConfigDenseSurfStable(new DenseSampling(8,8));
  ConfigDenseSift sift=new ConfigDenseSift(new DenseSampling(6,6));
  ConfigDenseHoG hog=new ConfigDenseHoG();
  DescribeImageDense<ImageUInt8,TupleDesc_F64> desc=(DescribeImageDense)FactoryDescribeImageDense.hog(hog,ImageType.single(ImageUInt8.class));
  ComputeClusters<double[]> clusterer=FactoryClustering.kMeans_F64(null,MAX_KNN_ITERATIONS,20,1e-6);
  clusterer.setVerbose(true);
  NearestNeighbor<HistogramScene> nn=FactoryNearestNeighbor.exhaustive();
  ExampleClassifySceneKnn example=new ExampleClassifySceneKnn(desc,clusterer,nn);
  File trainingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  File testingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  if (!trainingDir.exists() || !testingDir.exists()) {
    String path=UtilIO.pathExample(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + path + ""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  example.loadSets(trainingDir,null,testingDir);
  example.learnAndSave();
  example.loadAndCreateClassifier();
  Confusion confusion=example.evaluateTest();
  confusion.getMatrix().print();
  System.out.println(""String_Node_Str"" + confusion.computeAccuracy());
  ShowImages.showWindow(new ConfusionMatrixPanel(confusion.getMatrix(),400,true),""String_Node_Str"",true);
}",0.9852744310575636
150814,"/** 
 * Captures calibration data live using a webcam and a GUI to assist the user
 */
public void handleWebcam(){
  Webcam webcam=openSelectedCamera();
  if (desiredWidth > 0 && desiredHeight > 0)   UtilWebcamCapture.adjustResolution(webcam,desiredWidth,desiredHeight);
  webcam.open();
  ComputeGeometryScore quality=new ComputeGeometryScore(zeroSkew,detector.getLayout());
  AssistedCalibrationGui gui=new AssistedCalibrationGui(webcam.getViewSize());
  JFrame frame=ShowImages.showWindow(gui,""String_Node_Str"",true);
  ImageFloat32 gray=new ImageFloat32(webcam.getViewSize().width,webcam.getViewSize().height);
  AssistedCalibration assisted=new AssistedCalibration(detector,quality,gui);
  assisted.init(gray.width,gray.height);
  BufferedImage image;
  while ((image=webcam.getImage()) != null && !assisted.isFinished()) {
    ConvertBufferedImage.convertFrom(image,gray);
    try {
      assisted.process(gray,image);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      UtilImageIO.saveImage(image,""String_Node_Str"");
      throw e;
    }
  }
  webcam.close();
  if (assisted.isFinished()) {
    frame.setVisible(false);
    inputDirectory=AssistedCalibration.IMAGE_DIRECTORY;
    outputFileName=new File(AssistedCalibration.OUTPUT_DIRECTORY,""String_Node_Str"").getPath();
    handleDirectory();
  }
}","/** 
 * Captures calibration data live using a webcam and a GUI to assist the user
 */
public void handleWebcam(){
  final Webcam webcam=openSelectedCamera();
  if (desiredWidth > 0 && desiredHeight > 0)   UtilWebcamCapture.adjustResolution(webcam,desiredWidth,desiredHeight);
  webcam.open();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    public void run(){
      if (webcam.isOpen()) {
        System.out.println(""String_Node_Str"");
        webcam.close();
      }
    }
  }
);
  ComputeGeometryScore quality=new ComputeGeometryScore(zeroSkew,detector.getLayout());
  AssistedCalibrationGui gui=new AssistedCalibrationGui(webcam.getViewSize());
  JFrame frame=ShowImages.showWindow(gui,""String_Node_Str"",true);
  ImageFloat32 gray=new ImageFloat32(webcam.getViewSize().width,webcam.getViewSize().height);
  AssistedCalibration assisted=new AssistedCalibration(detector,quality,gui);
  assisted.init(gray.width,gray.height);
  BufferedImage image;
  while ((image=webcam.getImage()) != null && !assisted.isFinished()) {
    ConvertBufferedImage.convertFrom(image,gray);
    try {
      assisted.process(gray,image);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      UtilImageIO.saveImage(image,""String_Node_Str"");
      throw e;
    }
  }
  webcam.close();
  if (assisted.isFinished()) {
    frame.setVisible(false);
    inputDirectory=AssistedCalibration.IMAGE_DIRECTORY;
    outputFileName=new File(AssistedCalibration.OUTPUT_DIRECTORY,""String_Node_Str"").getPath();
    handleDirectory();
  }
}",0.9298791018998273
150815,"public void run(){
  gui.setObservations(calibrationAlg.getObservations());
  gui.setResults(calibrationAlg.getErrors());
  gui.setCalibration(calibrationAlg.getZhangParam());
  gui.setCorrection(intrinsic);
  gui.repaint();
}","public void run(){
  if (webcam.isOpen()) {
    System.out.println(""String_Node_Str"");
    webcam.close();
  }
}",0.272189349112426
150816,"/** 
 * Converts the cluster into a grid data structure.  If its not a grid then nothing happens
 */
protected void processCluster(List<SquareNode> cluster){
  invalid=false;
  if (cluster.size() == 1) {
    SquareNode n=cluster.get(0);
    if (n.getNumberOfConnections() == 0) {
      SquareGrid grid=grids.grow();
      grid.columns=grid.rows=1;
      grid.nodes.clear();
      grid.nodes.add(n);
      return;
    }
  }
  for (int i=0; i < cluster.size(); i++) {
    cluster.get(i).graph=SquareNode.RESET_GRAPH;
  }
  SquareNode seed=findSeedNode(cluster);
  if (seed == null)   return;
  List<SquareNode> firstRow;
  if (seed.getNumberOfConnections() == 1) {
    firstRow=firstRow1(seed);
  }
 else   if (seed.getNumberOfConnections() == 2) {
    firstRow=firstRow2(seed);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (invalid || firstRow == null)   return;
  List<List<SquareNode>> listRows=new ArrayList<List<SquareNode>>();
  listRows.add(firstRow);
  while (true) {
    List<SquareNode> previous=listRows.get(listRows.size() - 1);
    if (!addNextRow(previous.get(0),listRows)) {
      break;
    }
  }
  if (invalid || listRows.size() < 2)   return;
  SquareGrid grid=assembleGrid(listRows);
  if (grid == null || !checkEdgeCount(grid)) {
    grids.removeTail();
  }
}","/** 
 * Converts the cluster into a grid data structure.  If its not a grid then nothing happens
 */
protected void processCluster(List<SquareNode> cluster){
  invalid=false;
  if (cluster.size() == 1) {
    SquareNode n=cluster.get(0);
    if (n.getNumberOfConnections() == 0) {
      SquareGrid grid=grids.grow();
      grid.reset();
      grid.columns=grid.rows=1;
      grid.nodes.add(n);
      return;
    }
  }
  for (int i=0; i < cluster.size(); i++) {
    cluster.get(i).graph=SquareNode.RESET_GRAPH;
  }
  SquareNode seed=findSeedNode(cluster);
  if (seed == null)   return;
  List<SquareNode> firstRow;
  if (seed.getNumberOfConnections() == 1) {
    firstRow=firstRow1(seed);
  }
 else   if (seed.getNumberOfConnections() == 2) {
    firstRow=firstRow2(seed);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (invalid || firstRow == null)   return;
  List<List<SquareNode>> listRows=new ArrayList<List<SquareNode>>();
  listRows.add(firstRow);
  while (true) {
    List<SquareNode> previous=listRows.get(listRows.size() - 1);
    if (!addNextRow(previous.get(0),listRows)) {
      break;
    }
  }
  if (invalid || listRows.size() < 2)   return;
  SquareGrid grid=assembleGrid(listRows);
  if (grid == null || !checkEdgeCount(grid)) {
    grids.removeTail();
  }
}",0.9823212913143736
150817,"/** 
 * Converts the list of rows into a grid.  Since it is a chessboard pattern some of the grid elements will be null.
 */
private SquareGrid assembleGrid(List<List<SquareNode>> listRows){
  SquareGrid grid=grids.grow();
  List<SquareNode> row0=listRows.get(0);
  List<SquareNode> row1=listRows.get(1);
  int offset=row0.get(0).getNumberOfConnections() == 1 ? 0 : 1;
  grid.columns=row0.size() + row1.size();
  grid.rows=listRows.size();
  grid.nodes.clear();
  for (int i=0; i < grid.columns * grid.rows; i++) {
    grid.nodes.add(null);
  }
  for (int row=0; row < listRows.size(); row++) {
    List<SquareNode> list=listRows.get(row);
    int startCol=offset - row % 2 == 0 ? 0 : 1;
    int adjustedLength=grid.columns - startCol;
    if ((adjustedLength) - adjustedLength / 2 != list.size()) {
      return null;
    }
    int listIndex=0;
    for (int col=startCol; col < grid.columns; col+=2) {
      grid.set(row,col,list.get(listIndex++));
    }
  }
  return grid;
}","/** 
 * Converts the list of rows into a grid.  Since it is a chessboard pattern some of the grid elements will be null.
 */
private SquareGrid assembleGrid(List<List<SquareNode>> listRows){
  SquareGrid grid=grids.grow();
  grid.reset();
  List<SquareNode> row0=listRows.get(0);
  List<SquareNode> row1=listRows.get(1);
  int offset=row0.get(0).getNumberOfConnections() == 1 ? 0 : 1;
  grid.columns=row0.size() + row1.size();
  grid.rows=listRows.size();
  for (int i=0; i < grid.columns * grid.rows; i++) {
    grid.nodes.add(null);
  }
  for (int row=0; row < listRows.size(); row++) {
    List<SquareNode> list=listRows.get(row);
    int startCol=offset - row % 2 == 0 ? 0 : 1;
    int adjustedLength=grid.columns - startCol;
    if ((adjustedLength) - adjustedLength / 2 != list.size()) {
      return null;
    }
    int listIndex=0;
    for (int col=startCol; col < grid.columns; col+=2) {
      grid.set(row,col,list.get(listIndex++));
    }
  }
  return grid;
}",0.9804727646454264
150818,"/** 
 * Discards previous information
 */
public void reset(){
  corners=null;
  touch=null;
  graph=RESET_GRAPH;
  largestSide=0;
  for (int i=0; i < 4; i++) {
    if (edges[i] != null)     throw new RuntimeException(""String_Node_Str"");
    sideLengths[i]=0;
  }
}","/** 
 * Discards previous information
 */
public void reset(){
  corners=null;
  touch=null;
  center.set(-1,-1);
  largestSide=0;
  graph=RESET_GRAPH;
  for (int i=0; i < edges.length; i++) {
    if (edges[i] != null)     throw new RuntimeException(""String_Node_Str"");
    sideLengths[i]=0;
  }
}",0.8434163701067615
150819,"/** 
 * Reset and recycle data structures from the previous run
 */
protected void recycleData(){
  for (int i=0; i < nodes.size(); i++) {
    SquareNode n=nodes.get(i);
    for (int j=0; j < 4; j++) {
      if (n.edges[j] != null) {
        detachEdge(n.edges[j]);
      }
    }
  }
  for (int i=0; i < nodes.size(); i++) {
    SquareNode n=nodes.get(i);
    for (int j=0; j < 4; j++) {
      if (n.edges[j] != null)       throw new RuntimeException(""String_Node_Str"");
    }
  }
  nodes.reset();
  for (int i=0; i < clusters.size; i++) {
    clusters.get(i).clear();
  }
  clusters.reset();
}","/** 
 * Reset and recycle data structures from the previous run
 */
protected void recycleData(){
  for (int i=0; i < nodes.size(); i++) {
    SquareNode n=nodes.get(i);
    for (int j=0; j < n.edges.length; j++) {
      if (n.edges[j] != null) {
        detachEdge(n.edges[j]);
      }
    }
  }
  for (int i=0; i < nodes.size(); i++) {
    SquareNode n=nodes.get(i);
    for (int j=0; j < n.edges.length; j++) {
      if (n.edges[j] != null)       throw new RuntimeException(""String_Node_Str"");
    }
  }
  nodes.reset();
  for (int i=0; i < clusters.size; i++) {
    clusters.get(i).clear();
  }
  clusters.reset();
}",0.9752883031301482
150820,"/** 
 * Finds all neighbors and adds them to the graph.  Repeated until there are no more nodes to add to the graph
 */
void addToCluster(SquareNode seed,List<SquareNode> graph){
  open.clear();
  open.add(seed);
  while (!open.isEmpty()) {
    SquareNode n=open.remove(open.size() - 1);
    for (int i=0; i < 4; i++) {
      SquareEdge edge=n.edges[i];
      if (edge == null)       continue;
      SquareNode other;
      if (edge.a == n)       other=edge.b;
 else       if (edge.b == n)       other=edge.a;
 else       throw new RuntimeException(""String_Node_Str"");
      if (other.graph == SquareNode.RESET_GRAPH) {
        other.graph=n.graph;
        graph.add(other);
        open.add(other);
      }
 else       if (other.graph != n.graph) {
        throw new RuntimeException(""String_Node_Str"" + other.graph + ""String_Node_Str""+ n.graph);
      }
    }
  }
}","/** 
 * Finds all neighbors and adds them to the graph.  Repeated until there are no more nodes to add to the graph
 */
void addToCluster(SquareNode seed,List<SquareNode> graph){
  open.clear();
  open.add(seed);
  while (!open.isEmpty()) {
    SquareNode n=open.remove(open.size() - 1);
    for (int i=0; i < n.corners.size(); i++) {
      SquareEdge edge=n.edges[i];
      if (edge == null)       continue;
      SquareNode other;
      if (edge.a == n)       other=edge.b;
 else       if (edge.b == n)       other=edge.a;
 else       throw new RuntimeException(""String_Node_Str"");
      if (other.graph == SquareNode.RESET_GRAPH) {
        other.graph=n.graph;
        graph.add(other);
        open.add(other);
      }
 else       if (other.graph != n.graph) {
        throw new RuntimeException(""String_Node_Str"" + other.graph + ""String_Node_Str""+ n.graph);
      }
    }
  }
}",0.9902801600914808
150821,"/** 
 * Goes through each node and uses a nearest-neighbor search to find the closest nodes in its local neighborhood. It then checks those to see if it should connect
 */
void connectNodes(){
  setupSearch();
  int indexCornerList=0;
  for (int indexNode=0; indexNode < nodes.size(); indexNode++) {
    SquareNode n=nodes.get(indexNode);
    for (int indexLocal=0; indexLocal < n.corners.size(); indexLocal++) {
      if (n.touch.get(indexLocal))       continue;
      double[] point=searchPoints.get(indexCornerList++);
      searchResults.reset();
      search.findNearest(point,maxCornerDistance * maxCornerDistance,maxNeighbors + 1,searchResults);
      for (int indexResults=0; indexResults < searchResults.size(); indexResults++) {
        NnData<SquareNode> neighborData=searchResults.get(indexResults);
        SquareNode neighborNode=neighborData.data;
        if (neighborNode == n)         continue;
        int neighborCornerIndex=getCornerIndex(neighborNode,neighborData.point[0],neighborData.point[1]);
        if (candidateIsMuchCloser(n,neighborNode,neighborData.distance))         considerConnect(n,indexLocal,neighborNode,neighborCornerIndex,neighborData.distance);
      }
    }
  }
}","/** 
 * Goes through each node and uses a nearest-neighbor search to find the closest nodes in its local neighborhood. It then checks those to see if it should connect
 */
void connectNodes(){
  setupSearch();
  int indexCornerList=0;
  for (int indexNode=0; indexNode < nodes.size(); indexNode++) {
    SquareNode n=nodes.get(indexNode);
    for (int indexLocal=0; indexLocal < n.corners.size(); indexLocal++) {
      if (n.touch.size > 0 && n.touch.get(indexLocal))       continue;
      double[] point=searchPoints.get(indexCornerList++);
      searchResults.reset();
      search.findNearest(point,maxCornerDistance * maxCornerDistance,maxNeighbors + 1,searchResults);
      for (int indexResults=0; indexResults < searchResults.size(); indexResults++) {
        NnData<SquareNode> neighborData=searchResults.get(indexResults);
        SquareNode neighborNode=neighborData.data;
        if (neighborNode == n)         continue;
        int neighborCornerIndex=getCornerIndex(neighborNode,neighborData.point[0],neighborData.point[1]);
        if (candidateIsMuchCloser(n,neighborNode,neighborData.distance))         considerConnect(n,indexLocal,neighborNode,neighborCornerIndex,neighborData.distance);
      }
    }
  }
}",0.9917627677100496
150822,"/** 
 * Sets up data structures for nearest-neighbor search used in   {@link #connectNodes()}
 */
private void setupSearch(){
  searchPoints.reset();
  searchSquareList.clear();
  for (int i=0; i < nodes.size(); i++) {
    SquareNode n=nodes.get(i);
    for (int j=0; j < n.corners.size(); j++) {
      if (n.touch.get(j))       continue;
      Point2D_F64 c=n.corners.get(j);
      double[] point=searchPoints.grow();
      point[0]=c.x;
      point[1]=c.y;
      searchSquareList.add(n);
    }
  }
  search.setPoints(searchPoints.toList(),searchSquareList);
}","/** 
 * Sets up data structures for nearest-neighbor search used in   {@link #connectNodes()}
 */
private void setupSearch(){
  searchPoints.reset();
  searchSquareList.clear();
  for (int i=0; i < nodes.size(); i++) {
    SquareNode n=nodes.get(i);
    for (int j=0; j < n.corners.size(); j++) {
      if (n.touch.size > 0 && n.touch.get(j))       continue;
      Point2D_F64 c=n.corners.get(j);
      double[] point=searchPoints.grow();
      point[0]=c.x;
      point[1]=c.y;
      searchSquareList.add(n);
    }
  }
  search.setPoints(searchPoints.toList(),searchSquareList);
}",0.9824868651488616
150823,"private void findPercentiles(){
  int count=0;
  lowerIndex=0;
  for (lowerIndex=0; lowerIndex < histogram.length; lowerIndex++) {
    count+=histogram[lowerIndex];
    if (count >= lowerCount) {
      break;
    }
  }
  for (upperIndex=lowerIndex; upperIndex < histogram.length; upperIndex++) {
    count+=histogram[upperIndex];
    if (count >= upperCount) {
      break;
    }
  }
}","private void findPercentiles(){
  int count=0;
  lowerIndex=0;
  for (lowerIndex=0; lowerIndex < histogram.length && count < lowerCount; lowerIndex++) {
    count+=histogram[lowerIndex];
  }
  for (upperIndex=lowerIndex; upperIndex < histogram.length && count < upperCount; upperIndex++) {
    count+=histogram[upperIndex];
  }
}",0.7983193277310925
150824,"/** 
 * If not touching the border then the number of corners must be 4.  If touching the border there must be at least 3 corners not touching the border.  7 corners at most.  If there were 8 then all sides of a square would be touching the border.    No more than 3 corners since that's the most number of non-border corners a square can have.
 */
@Override public boolean filterPixelPolygon(List<Point2D_I32> externalUndist,List<Point2D_I32> externalDist,GrowQueue_I32 splits,boolean touchesBorder){
  if (touchesBorder) {
    if (splits.size() > 7)     return false;
    int totalRegular=0;
    for (int i=0; i < splits.size(); i++) {
      Point2D_I32 p=externalDist.get(i);
      if (!(p.x == 0 || p.y == 0 || p.x == width - 1 || p.y == height - 1))       totalRegular++;
    }
    return totalRegular <= 3;
  }
 else {
    return splits.size() == 4;
  }
}","/** 
 * If not touching the border then the number of corners must be 4.  If touching the border there must be at least 3 corners not touching the border.  7 corners at most.  If there were 8 then all sides of a square would be touching the border.    No more than 3 corners since that's the most number of non-border corners a square can have.
 */
@Override public boolean filterPixelPolygon(List<Point2D_I32> externalUndist,List<Point2D_I32> externalDist,GrowQueue_I32 splits,boolean touchesBorder){
  if (touchesBorder) {
    if (splits.size() > 7 || splits.size() <= 3)     return false;
    int totalRegular=0;
    for (int i=0; i < splits.size(); i++) {
      Point2D_I32 p=externalDist.get(splits.get(i));
      if (!(p.x == 0 || p.y == 0 || p.x == width - 1 || p.y == height - 1))       totalRegular++;
    }
    return totalRegular <= 3;
  }
 else {
    return splits.size() == 4;
  }
}",0.979498861047836
150825,"private void renderGraph(Graphics2D g2,double scale){
  java.util.List<java.util.List<SquareNode>> graphs=getClusters();
  BasicStroke strokeWide=new BasicStroke(3);
  BasicStroke strokeNarrow=new BasicStroke(2);
  Line2D.Double l=new Line2D.Double();
  g2.setStroke(new BasicStroke(3));
  for (int i=0; i < graphs.size(); i++) {
    java.util.List<SquareNode> graph=graphs.get(i);
    int key=graphs.size() == 1 ? 0 : 255 * i / (graphs.size() - 1);
    int rgb=key << 8 | (255 - key);
    g2.setColor(new Color(rgb));
    java.util.List<SquareEdge> edges=new ArrayList<SquareEdge>();
    for (    SquareNode n : graph) {
      for (int j=0; j < 4; j++) {
        if (n.edges[j] != null && !edges.contains(n.edges[j])) {
          edges.add(n.edges[j]);
        }
      }
    }
    for (    SquareEdge e : edges) {
      Point2D_F64 a=e.a.center;
      Point2D_F64 b=e.b.center;
      l.setLine(a.x * scale,a.y * scale,b.x * scale,b.y * scale);
      g2.setColor(Color.CYAN);
      g2.setStroke(strokeWide);
      g2.draw(l);
      g2.setColor(new Color(rgb));
      g2.setStroke(strokeNarrow);
      g2.draw(l);
    }
  }
}","private void renderGraph(Graphics2D g2,double scale){
  java.util.List<java.util.List<SquareNode>> graphs=getClusters();
  BasicStroke strokeWide=new BasicStroke(3);
  BasicStroke strokeNarrow=new BasicStroke(2);
  Line2D.Double l=new Line2D.Double();
  g2.setStroke(new BasicStroke(3));
  for (int i=0; i < graphs.size(); i++) {
    java.util.List<SquareNode> graph=graphs.get(i);
    int key=graphs.size() == 1 ? 0 : 255 * i / (graphs.size() - 1);
    int rgb=key << 8 | (255 - key);
    g2.setColor(new Color(rgb));
    java.util.List<SquareEdge> edges=new ArrayList<SquareEdge>();
    for (    SquareNode n : graph) {
      for (int j=0; j < n.edges.length; j++) {
        if (n.edges[j] != null && !edges.contains(n.edges[j])) {
          edges.add(n.edges[j]);
        }
      }
    }
    for (    SquareEdge e : edges) {
      Point2D_F64 a=e.a.center;
      Point2D_F64 b=e.b.center;
      l.setLine(a.x * scale,a.y * scale,b.x * scale,b.y * scale);
      g2.setColor(Color.CYAN);
      g2.setStroke(strokeWide);
      g2.draw(l);
      g2.setColor(new Color(rgb));
      g2.setStroke(strokeNarrow);
      g2.draw(l);
    }
  }
}",0.9933657673595754
150826,"private void drawCornersInside(Graphics2D g2,double scale,Polygon2D_F64 poly){
  double x0=poly.get(0).x * scale;
  double y0=poly.get(0).y * scale;
  double x1=poly.get(1).x * scale;
  double y1=poly.get(1).y * scale;
  double x2=poly.get(2).x * scale;
  double y2=poly.get(2).y * scale;
  double x3=poly.get(3).x * scale;
  double y3=poly.get(3).y * scale;
  double dx02=x2 - x0;
  double dy02=y2 - y0;
  double dx13=x3 - x1;
  double dy13=y3 - y1;
  double fraction=0.2;
  x0+=dx02 * fraction;
  y0+=dy02 * fraction;
  x2-=dx02 * fraction;
  y2-=dy02 * fraction;
  x1+=dx13 * fraction;
  y1+=dy13 * fraction;
  x3-=dx13 * fraction;
  y3-=dy13 * fraction;
  VisualizeFeatures.drawPoint(g2,x0,y0,3,Color.RED,false);
  VisualizeFeatures.drawPoint(g2,x1,y1,3,new Color(190,0,0),false);
  VisualizeFeatures.drawPoint(g2,x2,y2,3,Color.GREEN,false);
  VisualizeFeatures.drawPoint(g2,x3,y3,3,new Color(0,190,0),false);
}","private void drawCornersInside(Graphics2D g2,double scale,Polygon2D_F64 poly){
  Color colors[]=new Color[]{Color.RED,new Color(190,0,0),Color.GREEN,new Color(0,190,0)};
  Point2D_F64 center=new Point2D_F64();
  UtilPolygons2D_F64.vertexAverage(poly,center);
  for (int i=0; i < poly.size(); i++) {
    Point2D_F64 p=poly.get(i);
    Color c=i < 4 ? colors[i] : Color.BLUE;
    double dx=p.x - center.x;
    double dy=p.y - center.y;
    double x=(center.x + dx * 0.75) * scale;
    double y=(center.y + dy * 0.75) * scale;
    VisualizeFeatures.drawPoint(g2,x,y,3,c,false);
  }
}",0.2274247491638795
150827,"@Override protected boolean process(ImageFloat32 image){
  if (controlPanel.isManual()) {
    config.thresholding.type=ThresholdType.FIXED;
    config.thresholding.fixedThreshold=controlPanel.getThresholdLevel();
  }
 else {
    config.thresholding.type=ThresholdType.LOCAL_SQUARE;
  }
  alg=FactoryCalibrationTarget.detectorChessboard(config).getAlgorithm();
  return alg.process(image);
}","@Override protected boolean process(ImageFloat32 image){
  if (controlPanel.isManual()) {
    config.thresholding.type=ThresholdType.FIXED;
    config.thresholding.fixedThreshold=controlPanel.getThresholdLevel();
  }
 else {
    config.thresholding.type=ThresholdType.LOCAL_SQUARE_BORDER;
  }
  alg=FactoryCalibrationTarget.detectorChessboard(config).getAlgorithm();
  return alg.process(image);
}",0.9911054637865312
150828,"public static void main(String args[]) throws FileNotFoundException {
  List<String> examples=new ArrayList<String>();
  examples.add(""String_Node_Str"");
  for (int i=1; i <= 11; i++) {
    examples.add(UtilIO.pathExample(String.format(""String_Node_Str"",i)));
  }
  DetectCalibrationChessboardApp app=new DetectCalibrationChessboardApp(examples);
  app.configure(7,5,false);
  app.openFile(new File(examples.get(0)));
  app.waitUntilDoneProcessing();
  ShowImages.showWindow(app,""String_Node_Str"",true);
}","public static void main(String args[]) throws FileNotFoundException {
  List<String> examples=new ArrayList<String>();
  for (int i=1; i <= 11; i++) {
    examples.add(UtilIO.pathExample(String.format(""String_Node_Str"",i)));
  }
  DetectCalibrationChessboardApp app=new DetectCalibrationChessboardApp(examples);
  app.configure(7,5,false);
  app.openFile(new File(examples.get(0)));
  app.waitUntilDoneProcessing();
  ShowImages.showWindow(app,""String_Node_Str"",true);
}",0.964102564102564
150829,"public static ConfigThreshold local(ThresholdType type,int radius){
  if (!type.isAdaptive())   throw new IllegalArgumentException(""String_Node_Str"");
  if (type.isGlobal())   throw new IllegalArgumentException(""String_Node_Str"");
  ConfigThreshold config=new ConfigThreshold();
  config.type=type;
  config.radius=radius;
  return config;
}","public static ConfigThreshold local(ThresholdType type,int radius){
  if (!type.isAdaptive())   throw new IllegalArgumentException(""String_Node_Str"");
  if (type.isGlobal())   throw new IllegalArgumentException(""String_Node_Str"");
  if (type == ThresholdType.LOCAL_SQUARE_BORDER) {
    return new ConfigThresholdSquareBorder(radius,10,true);
  }
 else {
    ConfigThreshold config=new ConfigThreshold();
    config.type=type;
    config.radius=radius;
    return config;
  }
}",0.7980416156670747
150830,"public DemonstrationBase(List<String> exampleInputs,ImageType<T> imageType){
  super(new BorderLayout());
  createMenuBar(exampleInputs);
  this.input=imageType.createImage(1,1);
  this.imageType=imageType;
}","public DemonstrationBase(List<String> exampleInputs,ImageType<T> imageType){
  super(new BorderLayout());
  createMenuBar(exampleInputs);
  this.input=imageType.createImage(1,1);
  this.imageType=imageType;
  this.boofCopy1=imageType.createImage(1,1);
}",0.9023861171366594
150831,"protected void processImageThread(final BufferedImage buffered,final T input){
synchronized (processLock) {
    if (buffered != null)     imageCopy1=checkCopyBuffered(buffered,imageCopy1);
    if (processRunning) {
      processRequested=true;
    }
 else {
      processRequested=true;
      processRunning=true;
      new Thread(){
        @Override public void run(){
          while (true) {
synchronized (processLock) {
              if (!processRequested) {
                break;
              }
              processRequested=false;
              if (buffered != null)               imageCopy0=checkCopyBuffered(imageCopy1,imageCopy0);
            }
synchronized (waitingLock) {
              waitingToOpenImage=false;
            }
            if (buffered != null)             processImage(imageCopy0,input);
 else             processImage(null,null);
          }
synchronized (processLock) {
            processRunning=false;
          }
        }
      }
.start();
    }
  }
}","protected void processImageThread(final BufferedImage buffered,final T input){
synchronized (processLock) {
    if (processRunning) {
      if (buffered != null) {
        imageCopy1=checkCopyBuffered(buffered,imageCopy1);
        boofCopy1.setTo(input);
      }
 else       imageCopy1=null;
      processRequested=true;
      return;
    }
 else {
      processRunning=true;
      processRequested=false;
      if (buffered != null)       imageCopy0=checkCopyBuffered(buffered,imageCopy0);
 else       imageCopy0=null;
    }
  }
  new Thread(){
    @Override public void run(){
      try {
        while (true) {
synchronized (waitingLock) {
            waitingToOpenImage=false;
          }
          if (imageCopy0 != null)           processImage(imageCopy0,input);
 else           processImage(null,null);
synchronized (processLock) {
            if (!processRequested) {
              processRunning=false;
              break;
            }
            processRequested=false;
            if (imageCopy1 != null) {
              imageCopy0=checkCopyBuffered(imageCopy1,imageCopy0);
              input.setTo(boofCopy1);
            }
 else             imageCopy0=null;
          }
        }
      }
 catch (      RuntimeException e) {
        e.printStackTrace();
        System.out.println(e.getMessage());
        System.out.println(""String_Node_Str"");
        if (imageCopy0 != null)         UtilImageIO.saveImage(imageCopy0,""String_Node_Str"");
synchronized (processLock) {
          processRunning=false;
        }
      }
    }
  }
.start();
}",0.4744295830055074
150832,"/** 
 * Returns additional information on the polygon
 */
public Info getPolygonInfo(int which){
  return foundInfo.get(which);
}","/** 
 * Returns additional information on the polygon
 */
public FastQueue<Info> getPolygonInfo(){
  return foundInfo;
}",0.8755020080321285
150833,"/** 
 * If not touching the border then the number of corners must be 4.  If touching the border there must be at least 3 corners not touching the border.  7 corners at most.  If there were 8 then all sides of a square would be touching the border.    No more than 3 corners since that's the most number of non-border corners a square can have.
 */
@Override public boolean filterPixelPolygon(List<Point2D_I32> externalUndist,List<Point2D_I32> externalDist,GrowQueue_I32 splits,boolean touchesBorder){
  if (touchesBorder) {
    if (splits.size() > 7 || splits.size() < 3)     return false;
    int totalRegular=0;
    for (int i=0; i < splits.size(); i++) {
      Point2D_I32 p=externalDist.get(splits.get(i));
      if (!(p.x == 0 || p.y == 0 || p.x == width - 1 || p.y == height - 1))       totalRegular++;
    }
    return totalRegular <= 4;
  }
 else {
    return splits.size() == 4;
  }
}","/** 
 * If not touching the border then the number of corners must be 4.  If touching the border there must be at least 3 corners not touching the border.  7 corners at most.  If there were 8 then all sides of a square would be touching the border.    No more than 3 corners since that's the most number of non-border corners a square can have.
 */
@Override public boolean filterPixelPolygon(List<Point2D_I32> externalUndist,List<Point2D_I32> externalDist,GrowQueue_I32 splits,boolean touchesBorder){
  if (touchesBorder) {
    if (splits.size() > 7 || splits.size() < 3)     return false;
    int totalRegular=0;
    for (int i=0; i < splits.size(); i++) {
      Point2D_I32 p=externalDist.get(splits.get(i));
      if (!(p.x == 0 || p.y == 0 || p.x == width - 1 || p.y == height - 1))       totalRegular++;
    }
    return totalRegular > 0 && totalRegular <= 4;
  }
 else {
    return splits.size() == 4;
  }
}",0.9889380530973452
150834,"/** 
 * Detects chessboard in the binary image.  Square corners must be disconnected. Returns true if a chessboard was found, false otherwise.
 * @param input Original input image.
 * @param binary Binary image of chessboard
 * @return True if successful.
 */
public boolean process(T input,ImageUInt8 binary){
  boundPolygon.vertexes.reset();
  detectorSquare.process(input,binary);
  FastQueue<Polygon2D_F64> found=detectorSquare.getFoundPolygons();
  clusters=s2c.process(found.toList());
  c2g.process(clusters);
  List<SquareGrid> grids=c2g.getGrids().toList();
  for (int i=0; i < grids.size(); i++) {
    SquareGrid grid=grids.get(i);
    if (grid.rows == numCols && grid.columns == numRows) {
      tools.transpose(grid);
    }
    if (grid.rows == numRows && grid.columns == numCols) {
      if (grid.get(0,0) == null) {
        if (grid.get(0,-1) != null) {
          tools.flipColumns(grid);
        }
 else         if (grid.get(-1,0) != null) {
          tools.flipRows(grid);
        }
 else {
          continue;
        }
      }
      if (!ensureCCW(grid))       continue;
      putIntoCanonical(grid);
      return computeCalibrationPoints(grid);
    }
  }
  return false;
}","/** 
 * Detects chessboard in the binary image.  Square corners must be disconnected. Returns true if a chessboard was found, false otherwise.
 * @param input Original input image.
 * @param binary Binary image of chessboard
 * @return True if successful.
 */
public boolean process(T input,ImageUInt8 binary){
  boundPolygon.vertexes.reset();
  detectorSquare.process(input,binary);
  FastQueue<Polygon2D_F64> found=detectorSquare.getFoundPolygons();
  FastQueue<BinaryPolygonDetector.Info> foundInfo=detectorSquare.getPolygonInfo();
  clusters=s2c.process(found.toList(),foundInfo.toList());
  c2g.process(clusters);
  List<SquareGrid> grids=c2g.getGrids().toList();
  for (int i=0; i < grids.size(); i++) {
    SquareGrid grid=grids.get(i);
    if (grid.rows == numCols && grid.columns == numRows) {
      tools.transpose(grid);
    }
    if (grid.rows == numRows && grid.columns == numCols) {
      if (grid.get(0,0) == null) {
        if (grid.get(0,-1) != null) {
          tools.flipColumns(grid);
        }
 else         if (grid.get(-1,0) != null) {
          tools.flipRows(grid);
        }
 else {
          continue;
        }
      }
      if (!ensureCCW(grid))       continue;
      putIntoCanonical(grid);
      return computeCalibrationPoints(grid);
    }
  }
  return false;
}",0.9589371980676328
150835,"/** 
 * Processes the unordered set of squares and creates a graph out of them using prior knowledge and geometric constraints.
 * @param squares Set of squares
 * @return List of graphs.  All data structures are recycled on the next call to process().
 */
public List<List<SquareNode>> process(List<Polygon2D_F64> squares){
  recycleData();
  computeNodeInfo(squares);
  connectNodes();
  findClusters();
  return clusters.toList();
}","/** 
 * Processes the unordered set of squares and creates a graph out of them using prior knowledge and geometric constraints.
 * @param squares Set of squares
 * @return List of graphs.  All data structures are recycled on the next call to process().
 */
public List<List<SquareNode>> process(List<Polygon2D_F64> squares,List<BinaryPolygonDetector.Info> info){
  recycleData();
  computeNodeInfo(squares,info);
  connectNodes();
  findClusters();
  return clusters.toList();
}",0.9529025191675794
150836,"void computeNodeInfo(List<Polygon2D_F64> squares){
  for (int i=0; i < squares.size(); i++) {
    SquareNode n=nodes.grow();
    n.reset();
    n.corners=squares.get(i);
    UtilPoint2D_F64.mean(n.corners.vertexes.data,0,n.corners.size(),n.center);
    for (int j=0; j < n.corners.size(); j++) {
      int k=(j + 1) % n.corners.size();
      double l=n.corners.get(j).distance(n.corners.get(k));
      n.largestSide=Math.max(n.largestSide,l);
    }
  }
}","void computeNodeInfo(List<Polygon2D_F64> squares,List<BinaryPolygonDetector.Info> squaresInfo){
  for (int i=0; i < squares.size(); i++) {
    SquareNode n=nodes.grow();
    n.reset();
    Polygon2D_F64 polygon=squares.get(i);
    BinaryPolygonDetector.Info info=squaresInfo.get(i);
    UtilPoint2D_F64.mean(polygon.vertexes.data,0,polygon.size(),n.center);
    for (int j=0, k=polygon.size() - 1; j < polygon.size(); k=j, j++) {
      double l=polygon.get(j).distance(polygon.get(k));
      n.largestSide=Math.max(n.largestSide,l);
    }
    if (n.corners == null)     n.corners=new Polygon2D_F64();
 else     n.corners.vertexes.reset();
    for (int j=0; j < polygon.size(); j++) {
      if (!info.borderCorners.get(j)) {
        n.corners.vertexes.grow().set(polygon.get(j));
      }
    }
    if (n.corners.size() == 0) {
      nodes.removeTail();
    }
 else     if (n.corners.size() > 4)     throw new RuntimeException(""String_Node_Str"" + n.corners.size());
  }
}",0.4666198172874209
150837,"/** 
 * Examines the input image to detect fiducials inside of it
 * @param gray Undistorted input image
 */
public void process(T gray){
  binary.reshape(gray.width,gray.height);
  inputToBinary.process(gray,binary);
  squareDetector.process(gray,binary);
  FastQueue<Polygon2D_F64> candidates=squareDetector.getFoundPolygons();
  found.reset();
  if (verbose)   System.out.println(""String_Node_Str"" + candidates.size);
  Quadrilateral_F64 q=new Quadrilateral_F64();
  for (int i=0; i < candidates.size; i++) {
    Polygon2D_F64 p=candidates.get(i);
    double best=Double.MAX_VALUE;
    for (int j=0; j < 4; j++) {
      double found=p.get(0).normSq();
      if (found < best) {
        best=found;
        interpolationHack.set(p);
      }
      UtilPolygons2D_F64.shiftDown(p);
    }
    UtilPolygons2D_F64.convert(interpolationHack,q);
    pairsRemovePerspective.get(0).set(0,0,q.a.x,q.a.y);
    pairsRemovePerspective.get(1).set(square.width,0,q.b.x,q.b.y);
    pairsRemovePerspective.get(2).set(square.width,square.height,q.c.x,q.c.y);
    pairsRemovePerspective.get(3).set(0,square.height,q.d.x,q.d.y);
    if (!computeHomography.process(pairsRemovePerspective,H)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    if (!refineHomography.fitModel(pairsRemovePerspective,H,H_refined)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    UtilHomography.convert(H_refined,transformHomography.getModel());
    removePerspective.apply(gray,square);
    BinaryPolygonDetector.Info info=squareDetector.getPolygonInfo(i);
    if (minimumBorderBlackFraction > 0) {
      double pixelThreshold=(info.edgeInside + info.edgeOutside) / 2;
      double foundFraction=computeFractionBoundary((float)pixelThreshold);
      if (foundFraction < minimumBorderBlackFraction) {
        if (verbose)         System.out.println(""String_Node_Str"" + foundFraction);
        continue;
      }
    }
    if (processSquare(square,result,info.edgeInside,info.edgeOutside)) {
      prepareForOutput(q,result);
      if (verbose)       System.out.println(""String_Node_Str"");
    }
 else {
      if (verbose)       System.out.println(""String_Node_Str"");
    }
  }
}","/** 
 * Examines the input image to detect fiducials inside of it
 * @param gray Undistorted input image
 */
public void process(T gray){
  binary.reshape(gray.width,gray.height);
  inputToBinary.process(gray,binary);
  squareDetector.process(gray,binary);
  FastQueue<Polygon2D_F64> candidates=squareDetector.getFoundPolygons();
  found.reset();
  if (verbose)   System.out.println(""String_Node_Str"" + candidates.size);
  Quadrilateral_F64 q=new Quadrilateral_F64();
  for (int i=0; i < candidates.size; i++) {
    Polygon2D_F64 p=candidates.get(i);
    double best=Double.MAX_VALUE;
    for (int j=0; j < 4; j++) {
      double found=p.get(0).normSq();
      if (found < best) {
        best=found;
        interpolationHack.set(p);
      }
      UtilPolygons2D_F64.shiftDown(p);
    }
    UtilPolygons2D_F64.convert(interpolationHack,q);
    pairsRemovePerspective.get(0).set(0,0,q.a.x,q.a.y);
    pairsRemovePerspective.get(1).set(square.width,0,q.b.x,q.b.y);
    pairsRemovePerspective.get(2).set(square.width,square.height,q.c.x,q.c.y);
    pairsRemovePerspective.get(3).set(0,square.height,q.d.x,q.d.y);
    if (!computeHomography.process(pairsRemovePerspective,H)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    if (!refineHomography.fitModel(pairsRemovePerspective,H,H_refined)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      continue;
    }
    UtilHomography.convert(H_refined,transformHomography.getModel());
    removePerspective.apply(gray,square);
    BinaryPolygonDetector.Info info=squareDetector.getPolygonInfo().get(i);
    if (minimumBorderBlackFraction > 0) {
      double pixelThreshold=(info.edgeInside + info.edgeOutside) / 2;
      double foundFraction=computeFractionBoundary((float)pixelThreshold);
      if (foundFraction < minimumBorderBlackFraction) {
        if (verbose)         System.out.println(""String_Node_Str"" + foundFraction);
        continue;
      }
    }
    if (processSquare(square,result,info.edgeInside,info.edgeOutside)) {
      prepareForOutput(q,result);
      if (verbose)       System.out.println(""String_Node_Str"");
    }
 else {
      if (verbose)       System.out.println(""String_Node_Str"");
    }
  }
}",0.9986516853932584
150838,"/** 
 * Tests the corner distance threshold.  two nodes should be barely within tolerance of each other with the 3rd barely not in tolerance
 */
@Test public void process_connect_threshold(){
  SquaresIntoCrossClusters alg=new SquaresIntoCrossClusters(0.2,-1);
  List<Polygon2D_F64> squares=new ArrayList<Polygon2D_F64>();
  squares.add(createSquare(5,6));
  squares.add(createSquare(6.20001,7));
  squares.add(createSquare(6.1999999,5));
  List<List<SquareNode>> clusters=alg.process(squares);
  assertEquals(2,clusters.size());
}","/** 
 * Tests the corner distance threshold.  two nodes should be barely within tolerance of each other with the 3rd barely not in tolerance
 */
@Test public void process_connect_threshold(){
  SquaresIntoCrossClusters alg=new SquaresIntoCrossClusters(0.2,-1);
  List<Polygon2D_F64> squares=new ArrayList<Polygon2D_F64>();
  squares.add(createSquare(5,6));
  squares.add(createSquare(6.20001,7));
  squares.add(createSquare(6.1999999,5));
  List<BinaryPolygonDetector.Info> squareInfo=createInfo(squares);
  List<List<SquareNode>> clusters=alg.process(squares,squareInfo);
  assertEquals(2,clusters.size());
}",0.9315789473684212
150839,"/** 
 * Create a simple perfect cluster.  Do a crude test based on number of edge histogram
 */
@Test public void process_simple(){
  SquaresIntoCrossClusters alg=new SquaresIntoCrossClusters(0.05,-1);
  List<Polygon2D_F64> squares=new ArrayList<Polygon2D_F64>();
  squares.add(createSquare(7,8));
  squares.add(createSquare(9,8));
  squares.add(createSquare(8,9));
  squares.add(createSquare(7,10));
  squares.add(createSquare(9,10));
  List<List<SquareNode>> clusters=alg.process(squares);
  assertEquals(1,clusters.size());
  List<SquareNode> cluster=clusters.get(0);
  int connections[]=new int[5];
  for (  SquareNode n : cluster) {
    connections[n.getNumberOfConnections()]++;
  }
  assertEquals(0,connections[0]);
  assertEquals(4,connections[1]);
  assertEquals(0,connections[2]);
  assertEquals(0,connections[3]);
  assertEquals(1,connections[4]);
}","/** 
 * Create a simple perfect cluster.  Do a crude test based on number of edge histogram
 */
@Test public void process_simple(){
  SquaresIntoCrossClusters alg=new SquaresIntoCrossClusters(0.05,-1);
  List<Polygon2D_F64> squares=new ArrayList<Polygon2D_F64>();
  squares.add(createSquare(7,8));
  squares.add(createSquare(9,8));
  squares.add(createSquare(8,9));
  squares.add(createSquare(7,10));
  squares.add(createSquare(9,10));
  List<BinaryPolygonDetector.Info> squareInfo=createInfo(squares);
  List<List<SquareNode>> clusters=alg.process(squares,squareInfo);
  assertEquals(1,clusters.size());
  List<SquareNode> cluster=clusters.get(0);
  int connections[]=new int[5];
  for (  SquareNode n : cluster) {
    connections[n.getNumberOfConnections()]++;
  }
  assertEquals(0,connections[0]);
  assertEquals(4,connections[1]);
  assertEquals(0,connections[2]);
  assertEquals(0,connections[3]);
  assertEquals(1,connections[4]);
}",0.9566184649610678
150840,"/** 
 * Specifies the image's intrinsic parameters and target size
 * @param width Width of the input image
 * @param height Height of the input image
 */
private void configure(int width,int height){
  labeled.reshape(width,height);
  this.minimumContour=(int)(width * minContourFraction);
  this.minimumArea=Math.pow(this.minimumContour / 4.0,2);
}","/** 
 * Specifies the image's intrinsic parameters and target size
 * @param width Width of the input image
 * @param height Height of the input image
 */
private void configure(int width,int height){
  labeled.reshape(width,height);
  this.minimumContour=(int)(width * minContourFraction);
  this.minimumArea=Math.pow(this.minimumContour / 4.0,2);
  if (helper != null)   helper.setImageShape(width,height);
}",0.9210526315789472
150841,"@Override public double getCanonicalWidth(){
  throw new RuntimeException(""String_Node_Str"");
}","@Override public double getCanonicalWidth(){
  return alg.getDefinition().radius * 2 + 1;
}",0.6666666666666666
150842,"public void process(float c_x,float c_y,float orientation,float radius,TupleDesc_B feature){
  float scale=radius / definition.radius;
  boolean isInside=BoofMiscOps.checkInside(blur,c_x,c_y,definition.radius * scale);
  float c=(float)Math.cos(orientation);
  float s=(float)Math.sin(orientation);
  Arrays.fill(feature.data,0);
  if (isInside) {
    for (int i=0; i < definition.samplePoints.length; i++) {
      Point2D_I32 a=definition.samplePoints[i];
      float x0=c_x + (c * a.x - s * a.y) * scale;
      float y0=c_y + (s * a.x + c * a.y) * scale;
      values[i]=interp.get_fast(x0,y0);
    }
  }
 else {
    for (int i=0; i < definition.samplePoints.length; i++) {
      Point2D_I32 a=definition.samplePoints[i];
      float x0=c_x + (c * a.x - s * a.y) * scale;
      float y0=c_y + (s * a.x + c * a.y) * scale;
      if (BoofMiscOps.checkInside(blur,x0,y0)) {
        values[i]=interp.get(x0,y0);
      }
    }
  }
  for (int i=0; i < definition.compare.length; i++) {
    Point2D_I32 comp=definition.compare[i];
    if (values[comp.x] < values[comp.y]) {
      feature.data[i / 32]|=1 << (i % 32);
    }
  }
}","public void process(float c_x,float c_y,float orientation,float radius,TupleDesc_B feature){
  float scale=(float)(radius / BoofDefaults.BRIEF_SCALE_TO_RADIUS);
  boolean isInside=BoofMiscOps.checkInside(blur,c_x,c_y,definition.radius * scale);
  float c=(float)Math.cos(orientation);
  float s=(float)Math.sin(orientation);
  Arrays.fill(feature.data,0);
  if (isInside) {
    for (int i=0; i < definition.samplePoints.length; i++) {
      Point2D_I32 a=definition.samplePoints[i];
      float x0=c_x + (c * a.x - s * a.y) * scale;
      float y0=c_y + (s * a.x + c * a.y) * scale;
      values[i]=interp.get_fast(x0,y0);
    }
  }
 else {
    for (int i=0; i < definition.samplePoints.length; i++) {
      Point2D_I32 a=definition.samplePoints[i];
      float x0=c_x + (c * a.x - s * a.y) * scale;
      float y0=c_y + (s * a.x + c * a.y) * scale;
      if (BoofMiscOps.checkInside(blur,x0,y0)) {
        values[i]=interp.get(x0,y0);
      }
    }
  }
  for (int i=0; i < definition.compare.length; i++) {
    Point2D_I32 comp=definition.compare[i];
    if (values[comp.x] < values[comp.y]) {
      feature.data[i / 32]|=1 << (i % 32);
    }
  }
}",0.9735915492957746
150843,"/** 
 * Creates a Fast Hessian blob detector used by SURF.
 * @param config Configuration for detector. Pass in null for default options.
 * @param < II > Integral Image
 * @return The feature detector
 */
public static <II extends ImageSingleBand>FastHessianFeatureDetector<II> fastHessian(ConfigFastHessian config){
  if (config == null)   config=new ConfigFastHessian();
  config.checkValidity();
  NonMaxSuppression extractor=FactoryFeatureExtractor.nonmax(new ConfigExtract(config.extractRadius,config.detectThreshold,5,true));
  return new FastHessianFeatureDetector<II>(extractor,config.maxFeaturesPerScale,config.initialSampleSize,config.initialSize,config.numberScalesPerOctave,config.numberOfOctaves,config.scaleStepSize);
}","/** 
 * Creates a Fast Hessian blob detector used by SURF.
 * @param config Configuration for detector. Pass in null for default options.
 * @param < II > Integral Image
 * @return The feature detector
 */
public static <II extends ImageSingleBand>FastHessianFeatureDetector<II> fastHessian(ConfigFastHessian config){
  if (config == null)   config=new ConfigFastHessian();
  config.checkValidity();
  NonMaxSuppression extractor=FactoryFeatureExtractor.nonmax(new ConfigExtract(config.extractRadius,config.detectThreshold,0,true));
  return new FastHessianFeatureDetector<II>(extractor,config.maxFeaturesPerScale,config.initialSampleSize,config.initialSize,config.numberScalesPerOctave,config.numberOfOctaves,config.scaleStepSize);
}",0.9986376021798364
150844,"/** 
 * <p> Computes the value of a block inside an integral image and treats pixels outside of the image as zero.  The block is defined as follows: x0 < x &le; x1 and y0 < y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static <T extends ImageSingleBand>double block_zero(T integral,int x0,int y0,int x1,int y1){
  if (integral instanceof ImageFloat32) {
    return IntegralImageOps.block_zero((ImageFloat32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageFloat64) {
    return IntegralImageOps.block_zero((ImageFloat64)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt32) {
    return IntegralImageOps.block_zero((ImageSInt32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt64) {
    return IntegralImageOps.block_zero((ImageSInt64)integral,x0,y0,x1,y1);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * <p> Computes the value of a block inside an integral image and treats pixels outside of the image as zero.  The block is defined as follows: x0 &lt; x &le; x1 and y0 &lt; y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static <T extends ImageSingleBand>double block_zero(T integral,int x0,int y0,int x1,int y1){
  if (integral instanceof ImageFloat32) {
    return IntegralImageOps.block_zero((ImageFloat32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageFloat64) {
    return IntegralImageOps.block_zero((ImageFloat64)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt32) {
    return IntegralImageOps.block_zero((ImageSInt32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt64) {
    return IntegralImageOps.block_zero((ImageSInt64)integral,x0,y0,x1,y1);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9842657342657344
150845,"/** 
 * <p> Computes the value of a block inside an integral image without bounds checking.  The block is defined as follows: x0 < x &le; x1 and y0 < y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static <T extends ImageSingleBand>double block_unsafe(T integral,int x0,int y0,int x1,int y1){
  if (integral instanceof ImageFloat32) {
    return IntegralImageOps.block_unsafe((ImageFloat32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageFloat64) {
    return IntegralImageOps.block_unsafe((ImageFloat64)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt32) {
    return IntegralImageOps.block_unsafe((ImageSInt32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt64) {
    return IntegralImageOps.block_unsafe((ImageSInt64)integral,x0,y0,x1,y1);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * <p> Computes the value of a block inside an integral image without bounds checking.  The block is defined as follows: x0 &lt; x &le; x1 and y0 &lt; y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static <T extends ImageSingleBand>double block_unsafe(T integral,int x0,int y0,int x1,int y1){
  if (integral instanceof ImageFloat32) {
    return IntegralImageOps.block_unsafe((ImageFloat32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageFloat64) {
    return IntegralImageOps.block_unsafe((ImageFloat64)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt32) {
    return IntegralImageOps.block_unsafe((ImageSInt32)integral,x0,y0,x1,y1);
  }
 else   if (integral instanceof ImageSInt64) {
    return IntegralImageOps.block_unsafe((ImageSInt64)integral,x0,y0,x1,y1);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9840848806366048
150846,"/** 
 * <p> Computes the value of a block inside an integral image and treats pixels outside of the image as zero.  The block is defined as follows: x0 < x &le; x1 and y0 < y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static long block_zero(ImageSInt64 integral,int x0,int y0,int x1,int y1){
  return ImplIntegralImageOps.block_zero(integral,x0,y0,x1,y1);
}","/** 
 * <p> Computes the value of a block inside an integral image and treats pixels outside of the image as zero.  The block is defined as follows: x0 &lt; x &le; x1 and y0 &lt; y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static long block_zero(ImageSInt64 integral,int x0,int y0,int x1,int y1){
  return ImplIntegralImageOps.block_zero(integral,x0,y0,x1,y1);
}",0.9707792207792209
150847,"/** 
 * <p> Computes the value of a block inside an integral image without bounds checking.  The block is defined as follows: x0 < x &le; x1 and y0 < y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static long block_unsafe(ImageSInt64 integral,int x0,int y0,int x1,int y1){
  return ImplIntegralImageOps.block_unsafe(integral,x0,y0,x1,y1);
}","/** 
 * <p> Computes the value of a block inside an integral image without bounds checking.  The block is defined as follows: x0 &lt; x &le; x1 and y0 &lt; y &le; y1. </p>
 * @param integral Integral image.
 * @param x0 Lower bound of the block.  Exclusive.
 * @param y0 Lower bound of the block.  Exclusive.
 * @param x1 Upper bound of the block.  Inclusive.
 * @param y1 Upper bound of the block.  Inclusive.
 * @return Value inside the block.
 */
public static long block_unsafe(ImageSInt64 integral,int x0,int y0,int x1,int y1){
  return ImplIntegralImageOps.block_unsafe(integral,x0,y0,x1,y1);
}",0.9698492462311558
150848,"@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
synchronized (CommonDetectCalibrationApp.this) {
    if (success) {
      if (controlPanel.isShowPoints()) {
        java.util.List<Point2D_F64> candidates=getCalibrationPoints();
        for (        Point2D_F64 c : candidates) {
          VisualizeFeatures.drawPoint(g2,(int)(scale * c.x + 0.5),(int)(scale * c.y + 0.5),1,Color.RED);
        }
      }
      if (controlPanel.isShowNumbers()) {
        drawNumbers(g2,getCalibrationPoints(),null,scale);
      }
    }
    if (controlPanel.doShowContour) {
      java.util.List<Contour> contour=getContours();
      g2.setStroke(new BasicStroke(1));
      g2.setColor(Color.RED);
      VisualizeBinaryData.renderExternal(contour,scale,g2);
    }
    if (controlPanel.isShowGraph()) {
      renderGraph(g2,scale);
    }
    if (controlPanel.isShowOrder()) {
      renderOrder(g2,scale);
    }
    if (controlPanel.isShowSquares()) {
      FastQueue<Polygon2D_F64> squares=getFoundPolygons();
      for (int i=0; i < squares.size(); i++) {
        Polygon2D_F64 p=squares.get(i);
        if (isInGrids(p))         continue;
        g2.setColor(Color.cyan);
        g2.setStroke(new BasicStroke(4));
        drawPolygon(p,g2,scale);
        g2.setColor(Color.blue);
        g2.setStroke(new BasicStroke(2));
        drawPolygon(p,g2,scale);
        drawCornersInside(g2,scale,p);
      }
    }
    if (controlPanel.isShowGrids()) {
      java.util.List<SquareGrid> grids=getGrids();
      for (int i=0; i < grids.size(); i++) {
        SquareGrid g=grids.get(i);
        int a=grids.size() == 1 ? 0 : 255 * i / (grids.size() - 1);
        int rgb=a << 16 | (255 - a) << 8;
        g2.setStroke(new BasicStroke(3));
        Color color=new Color(rgb);
        for (int j=0; j < g.nodes.size(); j++) {
          SquareNode n=g.nodes.get(j);
          if (n == null)           continue;
          g2.setColor(color);
          VisualizeShapes.drawPolygon(n.corners,true,scale,g2);
          drawCornersInside(g2,scale,n.corners);
        }
      }
    }
  }
}","@Override protected void paintInPanel(AffineTransform tran,Graphics2D g2){
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
synchronized (CommonDetectCalibrationApp.this) {
    if (success) {
      if (controlPanel.isShowPoints()) {
        java.util.List<Point2D_F64> candidates=getCalibrationPoints();
        for (        Point2D_F64 c : candidates) {
          VisualizeFeatures.drawPoint(g2,(int)(scale * c.x + 0.5),(int)(scale * c.y + 0.5),1,Color.RED);
        }
      }
      if (controlPanel.isShowNumbers()) {
        drawNumbers(g2,getCalibrationPoints(),null,scale);
      }
    }
    if (controlPanel.doShowContour) {
      java.util.List<Contour> contour=getContours();
      g2.setStroke(new BasicStroke(1));
      g2.setColor(Color.RED);
      VisualizeBinaryData.renderExternal(contour,scale,g2);
    }
    if (controlPanel.isShowGraph()) {
      renderGraph(g2,scale);
    }
    if (controlPanel.isShowOrder()) {
      renderOrder(g2,scale);
    }
    if (controlPanel.isShowSquares()) {
      FastQueue<Polygon2D_F64> squares=getFoundPolygons();
      for (int i=0; i < squares.size(); i++) {
        Polygon2D_F64 p=squares.get(i);
        if (isInGrids(p))         continue;
        g2.setColor(Color.cyan);
        g2.setStroke(new BasicStroke(4));
        drawPolygon(p,g2,scale);
        g2.setColor(Color.blue);
        g2.setStroke(new BasicStroke(2));
        drawPolygon(p,g2,scale);
        drawCornersInside(g2,scale,p);
      }
    }
    if (controlPanel.isShowGrids()) {
      java.util.List<SquareGrid> grids=getGrids();
      for (int i=0; i < grids.size(); i++) {
        SquareGrid g=grids.get(i);
        int a=grids.size() == 1 ? 0 : 255 * i / (grids.size() - 1);
        int rgb=a << 16 | (255 - a) << 8;
        g2.setStroke(new BasicStroke(3));
        Color color=new Color(rgb);
        for (int j=0; j < g.nodes.size(); j++) {
          SquareNode n=g.nodes.get(j);
          if (n == null)           continue;
          g2.setColor(color);
          VisualizeShapes.drawPolygon(n.corners,true,scale,g2);
          drawCornersInside(g2,scale,n.corners);
        }
      }
    }
  }
}",0.9582660825455384
150849,"private void renderOrder(Graphics2D g2,double scale){
  java.util.List<SquareGrid> grids=getGrids();
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g2.setStroke(new BasicStroke(3));
  Line2D.Double l=new Line2D.Double();
  for (int i=0; i < grids.size(); i++) {
    SquareGrid g=grids.get(i);
    SquareNode p0=null;
    for (int j=0; j < g.nodes.size(); j++) {
      SquareNode p1=g.nodes.get(j);
      if (p1 == null)       continue;
      if (p0 != null) {
        double fraction=j / ((double)g.nodes.size() - 1);
        fraction=fraction * 0.8 + 0.1;
        int red=(int)(0xFF * fraction) + (int)(0x10 * (1 - fraction));
        int green=(int)(0x00 * fraction) + (int)(0x00 * (1 - fraction));
        int blue=(int)(0x10 * fraction) + (int)(0xff * (1 - fraction));
        int lineRGB=red << 16 | green << 8 | blue;
        l.setLine(scale * p0.center.x,scale * p0.center.y,scale * p1.center.x,scale * p1.center.y);
        g2.setColor(new Color(lineRGB));
        g2.draw(l);
      }
      p0=p1;
    }
  }
}","private void renderOrder(Graphics2D g2,double scale){
  java.util.List<SquareGrid> grids=getGrids();
  g2.setStroke(new BasicStroke(3));
  Line2D.Double l=new Line2D.Double();
  for (int i=0; i < grids.size(); i++) {
    SquareGrid g=grids.get(i);
    SquareNode p0=null;
    for (int j=0; j < g.nodes.size(); j++) {
      SquareNode p1=g.nodes.get(j);
      if (p1 == null)       continue;
      if (p0 != null) {
        double fraction=j / ((double)g.nodes.size() - 1);
        fraction=fraction * 0.8 + 0.1;
        int red=(int)(0xFF * fraction) + (int)(0x10 * (1 - fraction));
        int green=(int)(0x00 * fraction) + (int)(0x00 * (1 - fraction));
        int blue=(int)(0x10 * fraction) + (int)(0xff * (1 - fraction));
        int lineRGB=red << 16 | green << 8 | blue;
        l.setLine(scale * p0.center.x,scale * p0.center.y,scale * p1.center.x,scale * p1.center.y);
        g2.setColor(new Color(lineRGB));
        g2.draw(l);
      }
      p0=p1;
    }
  }
}",0.9148235294117648
150850,"private void renderGraph(Graphics2D g2,double scale){
  java.util.List<java.util.List<SquareNode>> graphs=getClusters();
  g2.setStroke(new BasicStroke(3));
  for (int i=0; i < graphs.size(); i++) {
    java.util.List<SquareNode> graph=graphs.get(i);
    int key=graphs.size() == 1 ? 0 : 255 * i / (graphs.size() - 1);
    int rgb=key << 8 | (255 - key);
    g2.setColor(new Color(rgb));
    java.util.List<SquareEdge> edges=new ArrayList<SquareEdge>();
    for (    SquareNode n : graph) {
      for (int j=0; j < 4; j++) {
        if (n.edges[j] != null && !edges.contains(n.edges[j])) {
          edges.add(n.edges[j]);
        }
      }
    }
    for (    SquareEdge e : edges) {
      Point2D_F64 a=e.a.center;
      Point2D_F64 b=e.b.center;
      g2.drawLine((int)(a.x * scale + 0.5),(int)(a.y * scale + 0.5),(int)(b.x * scale + 0.5),(int)(b.y * scale + 0.5));
    }
  }
}","private void renderGraph(Graphics2D g2,double scale){
  java.util.List<java.util.List<SquareNode>> graphs=getClusters();
  BasicStroke strokeWide=new BasicStroke(3);
  BasicStroke strokeNarrow=new BasicStroke(2);
  Line2D.Double l=new Line2D.Double();
  g2.setStroke(new BasicStroke(3));
  for (int i=0; i < graphs.size(); i++) {
    java.util.List<SquareNode> graph=graphs.get(i);
    int key=graphs.size() == 1 ? 0 : 255 * i / (graphs.size() - 1);
    int rgb=key << 8 | (255 - key);
    g2.setColor(new Color(rgb));
    java.util.List<SquareEdge> edges=new ArrayList<SquareEdge>();
    for (    SquareNode n : graph) {
      for (int j=0; j < 4; j++) {
        if (n.edges[j] != null && !edges.contains(n.edges[j])) {
          edges.add(n.edges[j]);
        }
      }
    }
    for (    SquareEdge e : edges) {
      Point2D_F64 a=e.a.center;
      Point2D_F64 b=e.b.center;
      l.setLine(a.x * scale,a.y * scale,b.x * scale,b.y * scale);
      g2.setColor(Color.CYAN);
      g2.setStroke(strokeWide);
      g2.draw(l);
      g2.setColor(new Color(rgb));
      g2.setStroke(strokeNarrow);
      g2.draw(l);
    }
  }
}",0.7748377433849226
150851,"/** 
 * Converts the cluster into a grid data structure.  If its not a grid then nothing happens
 */
protected void processCluster(List<SquareNode> cluster){
  if (cluster.size() == 1) {
    SquareNode n=cluster.get(0);
    if (n.getNumberOfConnections() == 0) {
      SquareGrid grid=grids.grow();
      grid.columns=grid.rows=1;
      grid.nodes.clear();
      grid.nodes.add(n);
      return;
    }
  }
  for (int i=0; i < cluster.size(); i++) {
    cluster.get(i).graph=SquareNode.RESET_GRAPH;
  }
  SquareNode seed=findSeedNode(cluster);
  if (seed == null)   return;
  List<SquareNode> firstRow;
  if (seed.getNumberOfConnections() == 1) {
    firstRow=firstRow1(seed);
  }
 else   if (seed.getNumberOfConnections() == 2) {
    firstRow=firstRow2(seed);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  List<List<SquareNode>> listRows=new ArrayList<List<SquareNode>>();
  listRows.add(firstRow);
  while (true) {
    List<SquareNode> previous=listRows.get(listRows.size() - 1);
    if (!addNextRow(previous.get(0),listRows)) {
      break;
    }
  }
  SquareGrid grid=assembleGrid(listRows);
  if (grid == null || !checkEdgeCount(grid)) {
    grids.removeTail();
  }
}","/** 
 * Converts the cluster into a grid data structure.  If its not a grid then nothing happens
 */
protected void processCluster(List<SquareNode> cluster){
  invalid=false;
  if (cluster.size() == 1) {
    SquareNode n=cluster.get(0);
    if (n.getNumberOfConnections() == 0) {
      SquareGrid grid=grids.grow();
      grid.columns=grid.rows=1;
      grid.nodes.clear();
      grid.nodes.add(n);
      return;
    }
  }
  for (int i=0; i < cluster.size(); i++) {
    cluster.get(i).graph=SquareNode.RESET_GRAPH;
  }
  SquareNode seed=findSeedNode(cluster);
  if (seed == null)   return;
  List<SquareNode> firstRow;
  if (seed.getNumberOfConnections() == 1) {
    firstRow=firstRow1(seed);
  }
 else   if (seed.getNumberOfConnections() == 2) {
    firstRow=firstRow2(seed);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (invalid || firstRow == null)   return;
  List<List<SquareNode>> listRows=new ArrayList<List<SquareNode>>();
  listRows.add(firstRow);
  while (true) {
    List<SquareNode> previous=listRows.get(listRows.size() - 1);
    if (!addNextRow(previous.get(0),listRows)) {
      break;
    }
  }
  if (invalid || listRows.size() < 2)   return;
  SquareGrid grid=assembleGrid(listRows);
  if (grid == null || !checkEdgeCount(grid)) {
    grids.removeTail();
  }
}",0.955964771817454
150852,"/** 
 * Converts all the found clusters into grids, if they are valid.
 * @param clusters List of clusters
 */
public void process(List<List<SquareNode>> clusters){
  grids.reset();
  for (int i=0; i < clusters.size(); i++) {
    processCluster(clusters.get(i));
  }
}","/** 
 * Converts all the found clusters into grids, if they are valid.
 * @param clusters List of clusters
 */
public void process(List<List<SquareNode>> clusters){
  grids.reset();
  for (int i=0; i < clusters.size(); i++) {
    if (checkPreconditions(clusters.get(i)))     processCluster(clusters.get(i));
  }
}",0.9225473321858864
150853,"/** 
 * Adds the first row to the list of rows when the seed element has two edges
 */
List<SquareNode> firstRow2(SquareNode seed){
  int indexLower=lowerEdgeIndex(seed);
  int indexUpper=addOffset(indexLower,1,4);
  List<SquareNode> listDown=new ArrayList<SquareNode>();
  List<SquareNode> list=new ArrayList<SquareNode>();
  addToRow(seed,indexUpper,1,true,listDown);
  flipAdd(listDown,list);
  list.add(seed);
  seed.graph=0;
  addToRow(seed,indexLower,-1,true,list);
  return list;
}","/** 
 * Adds the first row to the list of rows when the seed element has two edges
 */
List<SquareNode> firstRow2(SquareNode seed){
  int indexLower=lowerEdgeIndex(seed);
  int indexUpper=addOffset(indexLower,1,4);
  List<SquareNode> listDown=new ArrayList<SquareNode>();
  List<SquareNode> list=new ArrayList<SquareNode>();
  if (!addToRow(seed,indexUpper,1,true,listDown))   return null;
  flipAdd(listDown,list);
  list.add(seed);
  seed.graph=0;
  if (!addToRow(seed,indexLower,-1,true,list))   return null;
  return list;
}",0.9606299212598424
150854,"/** 
 * Given a node and the corner to the next node down the line, add to the list every other node until it hits the end of the row.
 * @param n Initial node
 * @param corner Which corner points to the next node
 * @param sign Determines the direction it will traverse.  -1 or 1
 * @param skip true = start adding nodes at second, false = start first.
 * @param row List that the nodes are placed into
 */
static void addToRow(SquareNode n,int corner,int sign,boolean skip,List<SquareNode> row){
  SquareEdge e;
  while ((e=n.edges[corner]) != null) {
    if (e.a == n) {
      n=e.b;
      corner=e.sideB;
    }
 else {
      n=e.a;
      corner=e.sideA;
    }
    if (!skip) {
      if (n.graph != SquareNode.RESET_GRAPH)       throw new RuntimeException(""String_Node_Str"");
      n.graph=0;
      row.add(n);
    }
    skip=!skip;
    sign*=-1;
    corner=addOffset(corner,sign,4);
  }
}","/** 
 * Given a node and the corner to the next node down the line, add to the list every other node until it hits the end of the row.
 * @param n Initial node
 * @param corner Which corner points to the next node
 * @param sign Determines the direction it will traverse.  -1 or 1
 * @param skip true = start adding nodes at second, false = start first.
 * @param row List that the nodes are placed into
 */
boolean addToRow(SquareNode n,int corner,int sign,boolean skip,List<SquareNode> row){
  SquareEdge e;
  while ((e=n.edges[corner]) != null) {
    if (e.a == n) {
      n=e.b;
      corner=e.sideB;
    }
 else {
      n=e.a;
      corner=e.sideA;
    }
    if (!skip) {
      if (n.graph != SquareNode.RESET_GRAPH) {
        invalid=true;
        return false;
      }
      n.graph=0;
      row.add(n);
    }
    skip=!skip;
    sign*=-1;
    corner=addOffset(corner,sign,4);
  }
  return true;
}",0.923162583518931
150855,"/** 
 * Adds the first row to the list of rows when the seed element has only one edge
 */
List<SquareNode> firstRow1(SquareNode seed){
  for (int i=0; i < 4; i++) {
    if (isOpenEdge(seed,i)) {
      List<SquareNode> list=new ArrayList<SquareNode>();
      seed.graph=0;
      int corner=seed.edges[i].destinationSide(seed);
      int l=addOffset(corner,-1,4);
      int u=addOffset(corner,1,4);
      SquareNode dst=seed.edges[i].destination(seed);
      if (dst.edges[u] != null) {
        list.add(seed);
        addToRow(seed,i,-1,true,list);
      }
 else       if (dst.edges[l] != null) {
        List<SquareNode> tmp=new ArrayList<SquareNode>();
        addToRow(seed,i,1,true,tmp);
        flipAdd(tmp,list);
        list.add(seed);
      }
 else {
        list.add(seed);
      }
      return list;
    }
  }
  throw new RuntimeException(""String_Node_Str"");
}","/** 
 * Adds the first row to the list of rows when the seed element has only one edge
 */
List<SquareNode> firstRow1(SquareNode seed){
  for (int i=0; i < 4; i++) {
    if (isOpenEdge(seed,i)) {
      List<SquareNode> list=new ArrayList<SquareNode>();
      seed.graph=0;
      int corner=seed.edges[i].destinationSide(seed);
      int l=addOffset(corner,-1,4);
      int u=addOffset(corner,1,4);
      SquareNode dst=seed.edges[i].destination(seed);
      if (dst.edges[u] != null) {
        list.add(seed);
        if (!addToRow(seed,i,-1,true,list))         return null;
      }
 else       if (dst.edges[l] != null) {
        List<SquareNode> tmp=new ArrayList<SquareNode>();
        if (!addToRow(seed,i,1,true,tmp))         return null;
        flipAdd(tmp,list);
        list.add(seed);
      }
 else {
        list.add(seed);
      }
      return list;
    }
  }
  throw new RuntimeException(""String_Node_Str"");
}",0.9709821428571428
150856,"/** 
 * Given a node, add all the squares in the row directly below it.  They will be ordered from ""left"" to ""right"".  The seed node can be anywhere in the row, e.g. middle, start, end.
 * @return true if a row was added to grid and false if not
 */
boolean addNextRow(SquareNode seed,List<List<SquareNode>> grid){
  List<SquareNode> row=new ArrayList<SquareNode>();
  List<SquareNode> tmp=new ArrayList<SquareNode>();
  int numConnections=numberOfOpenEdges(seed);
  if (numConnections == 0) {
    return false;
  }
 else   if (numConnections == 1) {
    for (int i=0; i < 4; i++) {
      SquareEdge edge=seed.edges[i];
      if (edge != null) {
        SquareNode dst=edge.destination(seed);
        if (dst.graph != SquareNode.RESET_GRAPH)         continue;
        int corner=edge.destinationSide(seed);
        int l=addOffset(corner,-1,4);
        int u=addOffset(corner,1,4);
        if (isClosedValidEdge(dst,l)) {
          addToRow(seed,i,1,false,tmp);
          flipAdd(tmp,row);
        }
 else         if (isClosedValidEdge(dst,u)) {
          addToRow(seed,i,-1,false,row);
        }
 else {
          dst.graph=0;
          row.add(dst);
        }
        break;
      }
    }
  }
 else   if (numConnections == 2) {
    int indexLower=lowerEdgeIndex(seed);
    int indexUpper=addOffset(indexLower,1,4);
    addToRow(seed,indexUpper,1,false,tmp);
    flipAdd(tmp,row);
    addToRow(seed,indexLower,-1,false,row);
  }
 else {
    return false;
  }
  grid.add(row);
  return true;
}","/** 
 * Given a node, add all the squares in the row directly below it.  They will be ordered from ""left"" to ""right"".  The seed node can be anywhere in the row, e.g. middle, start, end.
 * @return true if a row was added to grid and false if not
 */
boolean addNextRow(SquareNode seed,List<List<SquareNode>> grid){
  List<SquareNode> row=new ArrayList<SquareNode>();
  List<SquareNode> tmp=new ArrayList<SquareNode>();
  int numConnections=numberOfOpenEdges(seed);
  if (numConnections == 0) {
    return false;
  }
 else   if (numConnections == 1) {
    for (int i=0; i < 4; i++) {
      SquareEdge edge=seed.edges[i];
      if (edge != null) {
        SquareNode dst=edge.destination(seed);
        if (dst.graph != SquareNode.RESET_GRAPH)         continue;
        int corner=edge.destinationSide(seed);
        int l=addOffset(corner,-1,4);
        int u=addOffset(corner,1,4);
        if (isClosedValidEdge(dst,l)) {
          if (!addToRow(seed,i,1,false,tmp))           return false;
          flipAdd(tmp,row);
        }
 else         if (isClosedValidEdge(dst,u)) {
          if (!addToRow(seed,i,-1,false,row))           return false;
        }
 else {
          dst.graph=0;
          row.add(dst);
        }
        break;
      }
    }
  }
 else   if (numConnections == 2) {
    int indexLower=lowerEdgeIndex(seed);
    int indexUpper=addOffset(indexLower,1,4);
    if (!addToRow(seed,indexUpper,1,false,tmp))     return false;
    flipAdd(tmp,row);
    if (!addToRow(seed,indexLower,-1,false,row))     return false;
  }
 else {
    return false;
  }
  grid.add(row);
  return true;
}",0.9663430420711974
150857,"@Override public void process(T input){
  if (periodX <= 0 || periodY <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  alg.setImage(input);
  int x0=featureWidth / 2;
  int x1=input.getWidth() - featureWidth / 2;
  int y0=featureWidth / 2;
  int y1=input.getHeight() - featureWidth / 2;
  descriptions.reset();
  locations.reset();
  for (int y=y0; y < y1; y+=periodY) {
    for (int x=x0; x < x1; x+=periodX) {
      Desc d=descriptions.grow();
      if (!alg.process(x,y,0,scale,d)) {
        descriptions.removeTail();
      }
 else {
        locations.grow().set(x,y);
      }
    }
  }
}","@Override public void process(T input){
  if (periodX <= 0 || periodY <= 0)   throw new IllegalArgumentException(""String_Node_Str"");
  alg.setImage(input);
  int x0=featureWidth / 2;
  int x1=input.getWidth() - featureWidth / 2;
  int y0=featureWidth / 2;
  int y1=input.getHeight() - featureWidth / 2;
  descriptions.reset();
  locations.reset();
  for (int y=y0; y < y1; y+=periodY) {
    for (int x=x0; x < x1; x+=periodX) {
      Desc d=descriptions.grow();
      if (!alg.process(x,y,0,radius,d)) {
        descriptions.removeTail();
      }
 else {
        locations.grow().set(x,y);
      }
    }
  }
}",0.990961380443714
150858,"/** 
 * Configures dense description.
 * @param alg Sparse feature sampler.
 */
public GenericDenseDescribeImageDense(DescribeRegionPoint<T,Desc> alg){
  this.alg=alg;
}","/** 
 * Configures dense description.
 * @param alg Sparse feature sampler.
 */
public GenericDenseDescribeImageDense(DescribeRegionPoint<T,Desc> alg,double scaleToRadius){
  this.scaleToRadius=scaleToRadius;
  this.alg=alg;
}",0.8253164556962025
150859,"@Override public void configure(double scale,double periodX,double periodY){
  this.scale=scale;
  this.periodX=(int)(periodX + 0.5);
  this.periodY=(int)(periodY + 0.5);
  this.featureWidth=(int)(alg.getCanonicalWidth() * scale + 0.5);
  descriptions=new FastQueue<Desc>(alg.getDescriptionType(),true){
    @Override protected Desc createInstance(){
      return alg.createDescription();
    }
  }
;
}","@Override public void configure(double scale,double periodX,double periodY){
  this.radius=scale * scaleToRadius;
  this.periodX=(int)(periodX + 0.5);
  this.periodY=(int)(periodY + 0.5);
  this.featureWidth=(int)(alg.getCanonicalWidth() * scale + 0.5);
  descriptions=new FastQueue<Desc>(alg.getDescriptionType(),true){
    @Override protected Desc createInstance(){
      return alg.createDescription();
    }
  }
;
}",0.9671132764920828
150860,"/** 
 * <p> Creates a SURF descriptor.  SURF descriptors are invariant to illumination, orientation, and scale. BoofCV provides two variants. This SURF variant created here is designed for speed and sacrifices some stability. Different descriptors are produced for gray-scale and color images. </p>
 * @see DescribePointSurf
 * @param configSurf SURF configuration. Pass in null for default options.
 * @param imageType Type of input image.
 * @return SURF description extractor
 */
public static <T extends ImageSingleBand,II extends ImageSingleBand>DescribeImageDense<T,BrightFeature> surfFast(ConfigSurfDescribe.Speed configSurf,Class<T> imageType){
  DescribeRegionPoint<T,BrightFeature> surf=FactoryDescribeRegionPoint.surfFast(configSurf,imageType);
  return new GenericDenseDescribeImageDense<T,BrightFeature>(surf);
}","/** 
 * <p> Creates a SURF descriptor.  SURF descriptors are invariant to illumination, orientation, and scale. BoofCV provides two variants. This SURF variant created here is designed for speed and sacrifices some stability. Different descriptors are produced for gray-scale and color images. </p>
 * @see DescribePointSurf
 * @param configSurf SURF configuration. Pass in null for default options.
 * @param imageType Type of input image.
 * @return SURF description extractor
 */
public static <T extends ImageSingleBand,II extends ImageSingleBand>DescribeImageDense<T,BrightFeature> surfFast(ConfigSurfDescribe.Speed configSurf,Class<T> imageType){
  DescribeRegionPoint<T,BrightFeature> surf=FactoryDescribeRegionPoint.surfFast(configSurf,imageType);
  return new GenericDenseDescribeImageDense<T,BrightFeature>(surf,BoofDefaults.SURF_SCALE_TO_RADIUS);
}",0.9798099762470308
150861,"/** 
 * <p> Creates a SURF descriptor.  SURF descriptors are invariant to illumination, orientation, and scale. BoofCV provides two variants. The SURF variant created here is designed for stability.  Different descriptors are produced for gray-scale and color images. </p>
 * @see DescribePointSurf
 * @param configSurf SURF configuration. Pass in null for default options.
 * @param imageType Type of input image.
 * @return SURF description extractor
 */
public static <T extends ImageSingleBand,II extends ImageSingleBand>DescribeImageDense<T,BrightFeature> surfStable(ConfigSurfDescribe.Stability configSurf,Class<T> imageType){
  DescribeRegionPoint<T,BrightFeature> surf=FactoryDescribeRegionPoint.surfStable(configSurf,imageType);
  return new GenericDenseDescribeImageDense<T,BrightFeature>(surf);
}","/** 
 * <p> Creates a SURF descriptor.  SURF descriptors are invariant to illumination, orientation, and scale. BoofCV provides two variants. The SURF variant created here is designed for stability.  Different descriptors are produced for gray-scale and color images. </p>
 * @see DescribePointSurf
 * @param configSurf SURF configuration. Pass in null for default options.
 * @param imageType Type of input image.
 * @return SURF description extractor
 */
public static <T extends ImageSingleBand,II extends ImageSingleBand>DescribeImageDense<T,BrightFeature> surfStable(ConfigSurfDescribe.Stability configSurf,Class<T> imageType){
  DescribeRegionPoint<T,BrightFeature> surf=FactoryDescribeRegionPoint.surfStable(configSurf,imageType);
  return new GenericDenseDescribeImageDense<T,BrightFeature>(surf,BoofDefaults.SURF_SCALE_TO_RADIUS);
}",0.9793689320388348
150862,"public synchronized void viewUpdated(){
  if (contours == null)   return;
  int view=controlPanel.getSelectedView();
  Graphics2D g2=work.createGraphics();
  if (view == 0) {
    g2.drawImage(original,0,0,null);
  }
 else   if (view == 1) {
    VisualizeBinaryData.renderBinary(binary,false,work);
  }
 else {
    g2.setColor(Color.BLACK);
    g2.fillRect(0,0,work.getWidth(),work.getHeight());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      gui.setBufferedImage(work);
      gui.setScale(controlPanel.getZoom());
      gui.repaint();
      gui.requestFocusInWindow();
    }
  }
);
}","public synchronized void viewUpdated(){
  if (contours == null)   return;
  int view=controlPanel.getSelectedView();
  Graphics2D g2=work.createGraphics();
  if (view == 0) {
    g2.drawImage(original,0,0,null);
  }
 else   if (view == 1) {
    VisualizeBinaryData.renderBinary(binary,false,work);
  }
 else {
    g2.setColor(Color.BLACK);
    g2.fillRect(0,0,work.getWidth(),work.getHeight());
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      gui.setScale(controlPanel.getZoom());
      gui.setBufferedImage(work);
    }
  }
);
}",0.8801341156747695
150863,"protected void renderVisuals(Graphics2D g2,double scale){
  int activeAlg=controlPanel.getSelectedAlgorithm();
  g2.setStroke(new BasicStroke(3));
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  if (controlPanel.contoursVisible) {
    g2.setStroke(new BasicStroke(1));
    g2.setColor(new Color(0,100,0));
    VisualizeBinaryData.renderExternal(contours,scale,g2);
  }
  if (activeAlg == 0) {
    double splitFraction=controlPanel.getSplitFraction();
    double minimumSplitFraction=controlPanel.getMinimumSplitFraction();
    for (    Contour c : contours) {
      List<PointIndex_I32> vertexes=ShapeFittingOps.fitPolygon(c.external,true,splitFraction,minimumSplitFraction,100);
      g2.setColor(Color.RED);
      g2.setStroke(new BasicStroke(2));
      VisualizeShapes.drawPolygon(vertexes,true,scale,g2);
      if (controlPanel.isCornersVisible()) {
        g2.setColor(Color.BLUE);
        g2.setStroke(new BasicStroke(2f));
        for (        PointIndex_I32 p : vertexes) {
          VisualizeFeatures.drawCircle(g2,scale * (p.x + 0.5),scale * (p.y + 0.5),5);
        }
      }
    }
  }
 else   if (activeAlg == 1) {
    for (    Contour c : contours) {
      if (c.external.size() > 10) {
        FitData<EllipseRotated_F64> ellipse=ShapeFittingOps.fitEllipse_I32(c.external,0,false,null);
        g2.setColor(Color.RED);
        g2.setStroke(new BasicStroke(2.5f));
        VisualizeShapes.drawEllipse(ellipse.shape,scale,g2);
      }
      for (      List<Point2D_I32> internal : c.internal) {
        if (internal.size() <= 10)         continue;
        FitData<EllipseRotated_F64> ellipse=ShapeFittingOps.fitEllipse_I32(internal,0,false,null);
        g2.setColor(Color.GREEN);
        g2.setStroke(new BasicStroke(2.5f));
        VisualizeShapes.drawEllipse(ellipse.shape,scale,g2);
      }
    }
  }
}","protected void renderVisuals(Graphics2D g2,double scale){
  int activeAlg=controlPanel.getSelectedAlgorithm();
  g2.setStroke(new BasicStroke(3));
  g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL,RenderingHints.VALUE_STROKE_PURE);
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  if (controlPanel.contoursVisible) {
    g2.setStroke(new BasicStroke(1));
    g2.setColor(new Color(0,100,0));
    VisualizeBinaryData.renderExternal(contours,scale,g2);
  }
  if (activeAlg == 0) {
    double splitFraction=controlPanel.getSplitFraction();
    double minimumSplitFraction=controlPanel.getMinimumSplitFraction();
    for (    Contour c : contours) {
      List<PointIndex_I32> vertexes=ShapeFittingOps.fitPolygon(c.external,true,splitFraction,minimumSplitFraction,100);
      g2.setColor(Color.RED);
      visualizePolygon(g2,scale,vertexes);
      for (      List<Point2D_I32> internal : c.internal) {
        vertexes=ShapeFittingOps.fitPolygon(internal,true,splitFraction,minimumSplitFraction,100);
        g2.setColor(Color.GREEN);
        visualizePolygon(g2,scale,vertexes);
      }
    }
  }
 else   if (activeAlg == 1) {
    for (    Contour c : contours) {
      if (c.external.size() > 10) {
        FitData<EllipseRotated_F64> ellipse=ShapeFittingOps.fitEllipse_I32(c.external,0,false,null);
        g2.setColor(Color.RED);
        g2.setStroke(new BasicStroke(2.5f));
        VisualizeShapes.drawEllipse(ellipse.shape,scale,g2);
      }
      for (      List<Point2D_I32> internal : c.internal) {
        if (internal.size() <= 10)         continue;
        FitData<EllipseRotated_F64> ellipse=ShapeFittingOps.fitEllipse_I32(internal,0,false,null);
        g2.setColor(Color.GREEN);
        g2.setStroke(new BasicStroke(2.5f));
        VisualizeShapes.drawEllipse(ellipse.shape,scale,g2);
      }
    }
  }
}",0.8598375687712864
150864,"@Override public void run(){
  gui.setBufferedImage(work);
  gui.setScale(controlPanel.getZoom());
  gui.repaint();
  gui.requestFocusInWindow();
}","@Override public void run(){
  gui.setScale(controlPanel.getZoom());
  gui.setBufferedImage(work);
}",0.680161943319838
150865,"public ShapeFitContourPanel(ShapeFitContourApp owner){
  this.owner=owner;
  algorithmCombo=new JComboBox();
  algorithmCombo.addItem(""String_Node_Str"");
  algorithmCombo.addItem(""String_Node_Str"");
  algorithmCombo.addActionListener(this);
  algorithmCombo.setMaximumSize(algorithmCombo.getPreferredSize());
  imageView=new JComboBox();
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addActionListener(this);
  imageView.setMaximumSize(imageView.getPreferredSize());
  selectZoom=new JSpinner(new SpinnerNumberModel(1,0.1,50,1));
  selectZoom.addChangeListener(this);
  selectZoom.setMaximumSize(selectZoom.getPreferredSize());
  threshold=new ThresholdControlPanel(owner);
  selectMinimumSideFraction=new JSpinner(new SpinnerNumberModel(minimumSplitFraction,0,0.999,0.0025));
  selectMinimumSideFraction.setEditor(new JSpinner.NumberEditor(selectMinimumSideFraction,""String_Node_Str""));
  selectMinimumSideFraction.addChangeListener(this);
  selectMinimumSideFraction.setMaximumSize(selectMinimumSideFraction.getPreferredSize());
  selectSplitFraction=new JSpinner(new SpinnerNumberModel(splitFraction,0,1.0,0.01));
  selectSplitFraction.setEditor(new JSpinner.NumberEditor(selectSplitFraction,""String_Node_Str""));
  showCorners=new JCheckBox(""String_Node_Str"");
  showCorners.setSelected(cornersVisible);
  showCorners.addChangeListener(this);
  showContour=new JCheckBox(""String_Node_Str"");
  showContour.setSelected(contoursVisible);
  showContour.addChangeListener(this);
  selectSplitFraction.addChangeListener(this);
  selectSplitFraction.setMaximumSize(selectSplitFraction.getPreferredSize());
  addLabeled(algorithmCombo,""String_Node_Str"",this);
  addLabeled(imageView,""String_Node_Str"",this);
  addLabeled(selectZoom,""String_Node_Str"",this);
  add(threshold);
  addLabeled(selectMinimumSideFraction,""String_Node_Str"",this);
  addLabeled(selectSplitFraction,""String_Node_Str"",this);
  addAlignLeft(showCorners,this);
  addAlignLeft(showContour,this);
  addVerticalGlue(this);
}","public ShapeFitContourPanel(ShapeFitContourApp owner){
  this.owner=owner;
  algorithmCombo=new JComboBox();
  algorithmCombo.addItem(""String_Node_Str"");
  algorithmCombo.addItem(""String_Node_Str"");
  algorithmCombo.addActionListener(this);
  algorithmCombo.setMaximumSize(algorithmCombo.getPreferredSize());
  imageView=new JComboBox();
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addItem(""String_Node_Str"");
  imageView.addActionListener(this);
  imageView.setMaximumSize(imageView.getPreferredSize());
  selectZoom=new JSpinner(new SpinnerNumberModel(1,0.1,50,1));
  selectZoom.addChangeListener(this);
  selectZoom.setMaximumSize(selectZoom.getPreferredSize());
  threshold=new ThresholdControlPanel(owner);
  selectMinimumSideFraction=new JSpinner(new SpinnerNumberModel(minimumSplitFraction,0,0.999,0.0025));
  selectMinimumSideFraction.setEditor(new JSpinner.NumberEditor(selectMinimumSideFraction,""String_Node_Str""));
  selectMinimumSideFraction.addChangeListener(this);
  selectMinimumSideFraction.setMaximumSize(selectMinimumSideFraction.getPreferredSize());
  selectSplitFraction=new JSpinner(new SpinnerNumberModel(splitFraction,0,1.0,0.01));
  selectSplitFraction.setEditor(new JSpinner.NumberEditor(selectSplitFraction,""String_Node_Str""));
  showCorners=new JCheckBox(""String_Node_Str"");
  showCorners.setSelected(cornersVisible);
  showCorners.addChangeListener(this);
  showContour=new JCheckBox(""String_Node_Str"");
  showContour.setSelected(contoursVisible);
  showContour.addChangeListener(this);
  selectSplitFraction.addChangeListener(this);
  selectSplitFraction.setMaximumSize(selectSplitFraction.getPreferredSize());
  addLabeled(algorithmCombo,""String_Node_Str"",this);
  addSeparator(200);
  addLabeled(imageView,""String_Node_Str"",this);
  addLabeled(selectZoom,""String_Node_Str"",this);
  addAlignCenter(threshold,this);
  addLabeled(selectMinimumSideFraction,""String_Node_Str"",this);
  addLabeled(selectSplitFraction,""String_Node_Str"",this);
  addAlignLeft(showCorners,this);
  addAlignLeft(showContour,this);
  addVerticalGlue(this);
}",0.9863668978713228
150866,"/** 
 * Detects chessboard in the binary image.  Square corners must be disconnected. Returns true if a chessboard was found, false otherwise.
 * @param input Original input image.
 * @param binary Binary image of chessboard
 * @return True if successful.
 */
public boolean process(T input,ImageUInt8 binary){
  boundPolygon.vertexes.reset();
  detectorSquare.process(input,binary);
  FastQueue<Polygon2D_F64> found=detectorSquare.getFoundPolygons();
  clusters=s2c.process(found.toList());
  c2g.process(clusters);
  List<SquareGrid> grids=c2g.getGrids().toList();
  for (int i=0; i < grids.size(); i++) {
    SquareGrid grid=grids.get(i);
    if (grid.rows == numCols && grid.columns == numRows) {
      tools.transpose(grid);
    }
    if (grid.rows == numRows && grid.columns == numCols) {
      if (grid.get(0,0) == null) {
        if (grid.get(0,grid.columns - 1) != null) {
          tools.flipColumns(grid);
        }
 else {
          continue;
        }
      }
      putIntoCanonical(grid);
      return computeCalibrationPoints(grid);
    }
  }
  return false;
}","/** 
 * Detects chessboard in the binary image.  Square corners must be disconnected. Returns true if a chessboard was found, false otherwise.
 * @param input Original input image.
 * @param binary Binary image of chessboard
 * @return True if successful.
 */
public boolean process(T input,ImageUInt8 binary){
  boundPolygon.vertexes.reset();
  detectorSquare.process(input,binary);
  FastQueue<Polygon2D_F64> found=detectorSquare.getFoundPolygons();
  clusters=s2c.process(found.toList());
  c2g.process(clusters);
  List<SquareGrid> grids=c2g.getGrids().toList();
  for (int i=0; i < grids.size(); i++) {
    SquareGrid grid=grids.get(i);
    if (grid.rows == numCols && grid.columns == numRows) {
      tools.transpose(grid);
    }
    if (grid.rows == numRows && grid.columns == numCols) {
      if (grid.get(0,0) == null) {
        if (grid.get(0,-1) != null) {
          tools.flipColumns(grid);
        }
 else         if (grid.get(-1,0) != null) {
          tools.flipRows(grid);
        }
 else {
          continue;
        }
      }
      if (!ensureCCW(grid))       continue;
      putIntoCanonical(grid);
      return computeCalibrationPoints(grid);
    }
  }
  return false;
}",0.9293909973521624
150867,"/** 
 * Examines the grid and makes sure the (0,0) square is the closest one ot the top left corner. Only flip operations are allowed along symmetric axises
 */
void putIntoCanonical(SquareGrid grid){
  boolean rowOdd=grid.rows % 2 == 1;
  boolean colOdd=grid.columns % 2 == 1;
  if (colOdd) {
    double d0=grid.get(0,0).center.normSq();
    double d1=grid.get(0,-1).center.normSq();
    if (d1 < d0) {
      tools.flipColumns(grid);
    }
  }
  if (rowOdd) {
    double d0=grid.get(0,0).center.normSq();
    double d1=grid.get(-1,0).center.normSq();
    if (d1 < d0) {
      tools.flipRows(grid);
    }
  }
}","/** 
 * Examines the grid and makes sure the (0,0) square is the closest one ot the top left corner. Only flip operations are allowed along symmetric axises
 */
void putIntoCanonical(SquareGrid grid){
  boolean rowOdd=grid.rows % 2 == 1;
  boolean colOdd=grid.columns % 2 == 1;
  if (colOdd == rowOdd) {
    if (rowOdd && grid.rows == grid.columns) {
      int best=-1;
      double bestDistance=Double.MAX_VALUE;
      for (int i=0; i < 4; i++) {
        SquareNode n=grid.getCornerByIndex(i);
        double d=n.center.normSq();
        if (d < bestDistance) {
          best=i;
          bestDistance=d;
        }
      }
      for (int i=0; i < best; i++) {
        tools.rotateCCW(grid);
      }
    }
 else {
      double first=grid.get(0,0).center.normSq();
      double last=grid.getCornerByIndex(2).center.normSq();
      if (last < first) {
        tools.reverse(grid);
      }
    }
  }
}",0.5115970841616965
150868,"/** 
 * Configures chess board detector.
 * @param numRows Number of rows in square grid
 * @param numCols Number of columns in square grid
 * @param maxCornerDistance Maximum distance in pixels that two ""overlapping"" corners can be from each other.
 */
public DetectChessSquarePoints2(int numRows,int numCols,double maxCornerDistance,BinaryPolygonDetector<T> detectorSquare){
  this.maxCornerDistanceSq=maxCornerDistance * maxCornerDistance;
  this.numRows=numRows;
  this.numCols=numCols;
  this.detectorSquare=detectorSquare;
  s2c=new SquaresIntoCrossClusters(maxCornerDistance,0.5,-1);
  c2g=new CrossClustersIntoGrids();
}","/** 
 * Configures chess board detector.
 * @param numRows Number of rows in square grid
 * @param numCols Number of columns in square grid
 * @param maxCornerDistance Maximum distance in pixels that two ""overlapping"" corners can be from each other.
 */
public DetectChessSquarePoints2(int numRows,int numCols,double maxCornerDistance,BinaryPolygonDetector<T> detectorSquare){
  this.maxCornerDistanceSq=maxCornerDistance * maxCornerDistance;
  this.numRows=numRows;
  this.numCols=numCols;
  this.detectorSquare=detectorSquare;
  s2c=new SquaresIntoCrossClusters(maxCornerDistance,-1);
  c2g=new CrossClustersIntoGrids();
}",0.9968051118210862
150869,"/** 
 * Goes through each node and uses a nearest-neighbor search to find the closest nodes in its local neighborhood. It then checks those to see if it should connect
 */
void connectNodes(){
  setupSearch();
  int indexCornerList=0;
  for (int indexNode=0; indexNode < nodes.size(); indexNode++) {
    SquareNode n=nodes.get(indexNode);
    for (int indexLocal=0; indexLocal < 4; indexLocal++) {
      double[] point=searchPoints.get(indexCornerList++);
      searchResults.reset();
      search.findNearest(point,maxCornerDistance * maxCornerDistance,maxNeighbors + 1,searchResults);
      for (int indexResults=0; indexResults < searchResults.size(); indexResults++) {
        NnData<SquareNode> neighborData=searchResults.get(indexResults);
        SquareNode neighborNode=neighborData.data;
        if (neighborNode == n)         continue;
        int neighborCornerIndex=getCornerIndex(neighborNode,neighborData.point[0],neighborData.point[1]);
        considerConnect(n,indexLocal,neighborNode,neighborCornerIndex,neighborData.distance);
      }
    }
  }
}","/** 
 * Goes through each node and uses a nearest-neighbor search to find the closest nodes in its local neighborhood. It then checks those to see if it should connect
 */
void connectNodes(){
  setupSearch();
  int indexCornerList=0;
  for (int indexNode=0; indexNode < nodes.size(); indexNode++) {
    SquareNode n=nodes.get(indexNode);
    for (int indexLocal=0; indexLocal < 4; indexLocal++) {
      double[] point=searchPoints.get(indexCornerList++);
      searchResults.reset();
      search.findNearest(point,maxCornerDistance * maxCornerDistance,maxNeighbors + 1,searchResults);
      for (int indexResults=0; indexResults < searchResults.size(); indexResults++) {
        NnData<SquareNode> neighborData=searchResults.get(indexResults);
        SquareNode neighborNode=neighborData.data;
        if (neighborNode == n)         continue;
        int neighborCornerIndex=getCornerIndex(neighborNode,neighborData.point[0],neighborData.point[1]);
        if (candidateIsMuchCloser(n,indexLocal,neighborNode,neighborCornerIndex,neighborData.distance))         considerConnect(n,indexLocal,neighborNode,neighborCornerIndex,neighborData.distance);
      }
    }
  }
}",0.9409131602506714
150870,"/** 
 * Declares data structures and configures algorithm
 * @param maxCornerDistance Maximum number of pixels apart two connected corners can be. UPDATE WHEN USED
 * @param maxNeighborLengthChange The maximum number of neighbors it will look at when connecting a node
 * @param maxNeighbors Max number of neighbors it will consider.  Try 4 or -1
 */
public SquaresIntoCrossClusters(double maxCornerDistance,double maxNeighborLengthChange,int maxNeighbors){
  this.maxCornerDistance=maxCornerDistance;
  this.maxNeighborLengthChange=maxNeighborLengthChange;
  this.maxNeighbors=maxNeighbors > 0 ? maxNeighbors : Integer.MAX_VALUE;
  if (this.maxNeighbors == Integer.MAX_VALUE) {
    this.maxNeighbors=Integer.MAX_VALUE - 1;
  }
  searchPoints=new FastQueue<double[]>(double[].class,true){
    @Override protected double[] createInstance(){
      return new double[2];
    }
  }
;
  search.init(2);
}","/** 
 * Declares data structures and configures algorithm
 * @param maxCornerDistance Maximum distance two corners can be in pixels.
 * @param maxNeighbors Max number of neighbors it will consider.  Try 4 or -1 for all
 */
public SquaresIntoCrossClusters(double maxCornerDistance,int maxNeighbors){
  this.maxCornerDistance=maxCornerDistance;
  this.maxNeighbors=maxNeighbors > 0 ? maxNeighbors : Integer.MAX_VALUE;
  if (this.maxNeighbors == Integer.MAX_VALUE) {
    this.maxNeighbors=Integer.MAX_VALUE - 1;
  }
  searchPoints=new FastQueue<double[]>(double[].class,true){
    @Override protected double[] createInstance(){
      return new double[2];
    }
  }
;
  search.init(2);
}",0.8149084017687934
150871,"/** 
 * Checks to see if the edge is intense enough or if it should be discarded as noise
 * @return true if the edge is strong enough
 */
private boolean checkPolygonEdge(Polygon2D_F64 polygon,boolean ccw){
  if (!edgeIntensity.computeEdge(polygon,ccw)) {
    if (verbose)     System.out.println(""String_Node_Str"");
    return false;
  }
  if (!edgeIntensity.checkIntensity(true,edgeThreshold)) {
    if (verbose) {
      double inside=edgeIntensity.getAverageInside();
      double outside=edgeIntensity.getAverageInside();
      System.out.println(""String_Node_Str"" + inside + ""String_Node_Str""+ outside);
    }
    return false;
  }
  return true;
}","/** 
 * Checks to see if the edge is intense enough or if it should be discarded as noise
 * @return true if the edge is strong enough
 */
private boolean checkPolygonEdge(Polygon2D_F64 polygon,boolean ccw){
  if (!edgeIntensity.computeEdge(polygon,ccw)) {
    if (verbose)     System.out.println(""String_Node_Str"");
    return false;
  }
  if (!edgeIntensity.checkIntensity(true,edgeThreshold)) {
    if (verbose) {
      double inside=edgeIntensity.getAverageInside();
      double outside=edgeIntensity.getAverageOutside();
      System.out.println(""String_Node_Str"" + inside + ""String_Node_Str""+ outside);
    }
    return false;
  }
  return true;
}",0.9961744452945676
150872,"public static void main(String[] args){
  DescribeImageDense<ImageUInt8,TupleDesc_F64> desc=(DescribeImageDense)FactoryDescribeImageDense.surfFast(null,ImageUInt8.class);
  desc.configure(DESC_SCALE,DESC_SKIP,DESC_SKIP);
  ComputeClusters<double[]> clusterer=FactoryClustering.kMeans_F64(null,MAX_KNN_ITERATIONS,20,1e-6);
  clusterer.setVerbose(true);
  NearestNeighbor<HistogramScene> nn=FactoryNearestNeighbor.exhaustive();
  ExampleClassifySceneKnn example=new ExampleClassifySceneKnn(desc,clusterer,nn);
  File trainingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  File testingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  if (!trainingDir.exists() || !testingDir.exists()) {
    String path=UtilIO.pathExample(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + path + ""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  example.loadSets(trainingDir,null,testingDir);
  example.learnAndSave();
  example.loadAndCreateClassifier();
  Confusion confusion=example.evaluateTest();
  confusion.getMatrix().print();
  System.out.println(""String_Node_Str"" + confusion.computeAccuracy());
  ShowImages.showWindow(new ConfusionMatrixPanel(confusion.getMatrix(),400,true),""String_Node_Str"",true);
}","public static void main(String[] args){
  DescribeImageDense<ImageUInt8,TupleDesc_F64> desc=(DescribeImageDense)FactoryDescribeImageDense.surfFast(null,ImageUInt8.class);
  desc.configure(1,8,8);
  ComputeClusters<double[]> clusterer=FactoryClustering.kMeans_F64(null,MAX_KNN_ITERATIONS,20,1e-6);
  clusterer.setVerbose(true);
  NearestNeighbor<HistogramScene> nn=FactoryNearestNeighbor.exhaustive();
  ExampleClassifySceneKnn example=new ExampleClassifySceneKnn(desc,clusterer,nn);
  File trainingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  File testingDir=new File(UtilIO.pathExample(""String_Node_Str""));
  if (!trainingDir.exists() || !testingDir.exists()) {
    String path=UtilIO.pathExample(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + path + ""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  example.loadSets(trainingDir,null,testingDir);
  example.learnAndSave();
  example.loadAndCreateClassifier();
  Confusion confusion=example.evaluateTest();
  confusion.getMatrix().print();
  System.out.println(""String_Node_Str"" + confusion.computeAccuracy());
  ShowImages.showWindow(new ConfusionMatrixPanel(confusion.getMatrix(),400,true),""String_Node_Str"",true);
}",0.9859606899318092
150873,"@Override public void process(T input){
  if (scale == 1.0) {
    alg.setPeriodColumns(periodX);
    alg.setPeriodRows(periodY);
  }
 else {
    int width=(int)(input.width / scale + 0.5);
    int height=(int)(input.width / scale + 0.5);
    imageScaled.reshape(width,height);
    derivX.reshape(width,height);
    derivY.reshape(width,height);
    if (width < input.width) {
      AverageDownSampleOps.down(input,imageScaled);
    }
 else {
      scaleUp.setRefs(input,imageScaled).scaleExt().apply();
    }
    input=imageScaled;
    alg.setPeriodColumns(periodX / scale);
    alg.setPeriodRows(periodY / scale);
  }
  derivX.reshape(input.width,input.height);
  derivY.reshape(input.width,input.height);
  gradient.process(input,derivX,derivY);
  alg.setImageGradient(derivX,derivY);
  alg.process();
}","@Override public void process(T input){
  if (scale == 1.0) {
    alg.setPeriodColumns(periodX);
    alg.setPeriodRows(periodY);
  }
 else {
    int width=(int)(input.width / scale + 0.5);
    int height=(int)(input.height / scale + 0.5);
    imageScaled.reshape(width,height);
    derivX.reshape(width,height);
    derivY.reshape(width,height);
    if (width < input.width) {
      AverageDownSampleOps.down(input,imageScaled);
    }
 else {
      scaleUp.setRefs(input,imageScaled).scaleExt().apply();
    }
    input=imageScaled;
    alg.setPeriodColumns(periodX / scale);
    alg.setPeriodRows(periodY / scale);
  }
  derivX.reshape(input.width,input.height);
  derivY.reshape(input.width,input.height);
  gradient.process(input,derivX,derivY);
  alg.setImageGradient(derivX,derivY);
  alg.process();
}",0.9931719428926132
150874,"@Test public void checkDescriptorScale(){
  for (  Class type : imageTypes) {
    ImageSingleBand image=GeneralizedImageOps.createSingleBand(type,width,height);
    GImageMiscOps.fillUniform(image,rand,0,200);
    DescribeImageDense alg=createAlg(type);
    alg.configure(1,8,9);
    alg.process(image);
    int found10=alg.getDescriptions().size();
    alg.configure(1.5,8,9);
    alg.process(image);
    int found15=alg.getDescriptions().size();
    alg.configure(0.75,8,9);
    alg.process(image);
    int found07=alg.getDescriptions().size();
    assertTrue(found07 > found10);
    assertTrue(found10 > found15);
  }
}","@Test public void checkDescriptorScale(){
  for (  Class type : imageTypes) {
    ImageSingleBand image=GeneralizedImageOps.createSingleBand(type,width,height);
    GImageMiscOps.fillUniform(image,rand,0,200);
    DescribeImageDense alg=createAlg(type);
    alg.configure(1,8,9);
    alg.process(image);
    int found10=alg.getDescriptions().size();
    alg.configure(1.5,8,9);
    alg.process(image);
    int found15=alg.getDescriptions().size();
    alg.configure(0.75,8,9);
    alg.process(image);
    int found07a=alg.getDescriptions().size();
    alg.configure(0.75,8 * 0.75,9 * 0.75);
    alg.process(image);
    int found07b=alg.getDescriptions().size();
    assertTrue(found07a == found10);
    assertTrue(found07b > found10);
    assertTrue(found10 > found15);
  }
}",0.8904795991410165
150875,"void printHelp(){
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}","void printHelp(){
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
}",0.5052533271071679
150876,"void parseBinary(int index,String[] args){
  boolean robust=true;
  double size=1;
  int gridWidth=4;
  for (; index < args.length; index++) {
    String arg=args[index];
    if (!arg.startsWith(""String_Node_Str"")) {
      throw new RuntimeException(""String_Node_Str"");
    }
    splitFlag(arg);
    if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      robust=Boolean.parseBoolean(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      size=Double.parseDouble(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      size=Integer.parseInt(parameters);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + flagName);
    }
  }
  System.out.println(""String_Node_Str"" + robust + ""String_Node_Str""+ size+ ""String_Node_Str""+ gridWidth);
  ConfigFiducialBinary configFid=new ConfigFiducialBinary();
  configFid.targetWidth=size;
  configFid.gridWidth=gridWidth;
  configFid.squareDetector.minimumEdgeIntensity=10;
  ConfigThreshold configThreshold;
  if (robust)   configThreshold=ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10);
 else   configThreshold=ConfigThreshold.fixed(DEFAULT_THRESHOLD);
  detector=FactoryFiducial.squareBinary(configFid,configThreshold,ImageUInt8.class);
}","void parseBinary(int index,String[] args){
  boolean robust=true;
  double size=1;
  int gridWidth=4;
  double borderWidth=0.25;
  for (; index < args.length; index++) {
    String arg=args[index];
    if (!arg.startsWith(""String_Node_Str"")) {
      throw new RuntimeException(""String_Node_Str"");
    }
    splitFlag(arg);
    if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      robust=Boolean.parseBoolean(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      size=Double.parseDouble(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      gridWidth=Integer.parseInt(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      borderWidth=Double.parseDouble(parameters);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + flagName);
    }
  }
  System.out.println(""String_Node_Str"" + robust + ""String_Node_Str""+ size+ ""String_Node_Str""+ gridWidth+ ""String_Node_Str""+ borderWidth);
  ConfigFiducialBinary configFid=new ConfigFiducialBinary();
  configFid.targetWidth=size;
  configFid.gridWidth=gridWidth;
  configFid.squareDetector.minimumEdgeIntensity=10;
  configFid.borderWidthFraction=borderWidth;
  ConfigThreshold configThreshold;
  if (robust)   configThreshold=ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10);
 else   configThreshold=ConfigThreshold.fixed(DEFAULT_THRESHOLD);
  detector=FactoryFiducial.squareBinary(configFid,configThreshold,ImageUInt8.class);
}",0.9134307089419308
150877,"void parseImage(int index,String[] args){
  boolean robust=true;
  List<String> paths=new ArrayList<String>();
  GrowQueue_F64 sizes=new GrowQueue_F64();
  for (; index < args.length; index++) {
    String arg=args[index];
    if (!arg.startsWith(""String_Node_Str"")) {
      throw new RuntimeException(""String_Node_Str"");
    }
    splitFlag(arg);
    if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      robust=Boolean.parseBoolean(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      String words[]=parameters.split(""String_Node_Str"");
      if (words.length != 2)       throw new RuntimeException(""String_Node_Str"");
      sizes.add(Double.parseDouble(words[0]));
      paths.add(words[1]);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + flagName);
    }
  }
  if (paths.isEmpty())   throw new RuntimeException(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + robust + ""String_Node_Str""+ paths.size());
  ConfigFiducialImage config=new ConfigFiducialImage();
  config.squareDetector.minimumEdgeIntensity=10;
  ConfigThreshold configThreshold;
  if (robust)   configThreshold=ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10);
 else   configThreshold=ConfigThreshold.fixed(DEFAULT_THRESHOLD);
  SquareImage_to_FiducialDetector<ImageUInt8> detector=FactoryFiducial.squareImage(config,configThreshold,ImageUInt8.class);
  for (int i=0; i < paths.size(); i++) {
    BufferedImage buffered=UtilImageIO.loadImage(paths.get(i));
    if (buffered == null)     throw new RuntimeException(""String_Node_Str"" + paths.get(i));
    ImageUInt8 pattern=new ImageUInt8(buffered.getWidth(),buffered.getHeight());
    ConvertBufferedImage.convertFrom(buffered,pattern);
    detector.addPatternImage(pattern,125,sizes.get(i));
  }
  this.detector=detector;
}","void parseImage(int index,String[] args){
  boolean robust=true;
  List<String> paths=new ArrayList<String>();
  GrowQueue_F64 sizes=new GrowQueue_F64();
  double borderWidth=0.25;
  for (; index < args.length; index++) {
    String arg=args[index];
    if (!arg.startsWith(""String_Node_Str"")) {
      throw new RuntimeException(""String_Node_Str"");
    }
    splitFlag(arg);
    if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      robust=Boolean.parseBoolean(parameters);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      String words[]=parameters.split(""String_Node_Str"");
      if (words.length != 2)       throw new RuntimeException(""String_Node_Str"");
      sizes.add(Double.parseDouble(words[0]));
      paths.add(words[1]);
    }
 else     if (flagName.compareToIgnoreCase(""String_Node_Str"") == 0) {
      borderWidth=Double.parseDouble(parameters);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + flagName);
    }
  }
  if (paths.isEmpty())   throw new RuntimeException(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + robust + ""String_Node_Str""+ paths.size()+ ""String_Node_Str""+ borderWidth);
  ConfigFiducialImage config=new ConfigFiducialImage();
  config.borderWidthFraction=borderWidth;
  ConfigThreshold configThreshold;
  if (robust)   configThreshold=ConfigThreshold.local(ThresholdType.LOCAL_SQUARE,10);
 else   configThreshold=ConfigThreshold.fixed(DEFAULT_THRESHOLD);
  SquareImage_to_FiducialDetector<ImageUInt8> detector=FactoryFiducial.squareImage(config,configThreshold,ImageUInt8.class);
  for (int i=0; i < paths.size(); i++) {
    BufferedImage buffered=UtilImageIO.loadImage(paths.get(i));
    if (buffered == null)     throw new RuntimeException(""String_Node_Str"" + paths.get(i));
    ImageUInt8 pattern=new ImageUInt8(buffered.getWidth(),buffered.getHeight());
    ConvertBufferedImage.convertFrom(buffered,pattern);
    detector.addPatternImage(pattern,125,sizes.get(i));
  }
  this.detector=detector;
}",0.9338541666666668
150878,"/** 
 * Captures calibration data live using a webcam and a GUI to assist the user
 */
public void handleWebcam(){
  Webcam webcam=Webcam.getWebcams().get(cameraId);
  if (desiredWidth > 0 && desiredHeight > 0)   UtilWebcamCapture.adjustResolution(webcam,desiredWidth,desiredHeight);
  webcam.open();
  ComputeGeometryScore quality=new ComputeGeometryScore(zeroSkew,detector.getLayout());
  AssistedCalibrationGui gui=new AssistedCalibrationGui(webcam.getViewSize());
  JFrame frame=ShowImages.showWindow(gui,""String_Node_Str"",true);
  ImageFloat32 gray=new ImageFloat32(webcam.getViewSize().width,webcam.getViewSize().height);
  AssistedCalibration assisted=new AssistedCalibration(detector,quality,gui);
  assisted.init(gray.width,gray.height);
  BufferedImage image;
  while ((image=webcam.getImage()) != null && !assisted.isFinished()) {
    ConvertBufferedImage.convertFrom(image,gray);
    try {
      assisted.process(gray,image);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      UtilImageIO.saveImage(image,""String_Node_Str"");
      throw e;
    }
  }
  webcam.close();
  if (assisted.isFinished()) {
    frame.setVisible(false);
    inputDirectory=AssistedCalibration.IMAGE_DIRECTORY;
    outputFileName=new File(inputDirectory,""String_Node_Str"").getPath();
    handleDirectory();
  }
}","/** 
 * Captures calibration data live using a webcam and a GUI to assist the user
 */
public void handleWebcam(){
  Webcam webcam=Webcam.getWebcams().get(cameraId);
  if (desiredWidth > 0 && desiredHeight > 0)   UtilWebcamCapture.adjustResolution(webcam,desiredWidth,desiredHeight);
  webcam.open();
  ComputeGeometryScore quality=new ComputeGeometryScore(zeroSkew,detector.getLayout());
  AssistedCalibrationGui gui=new AssistedCalibrationGui(webcam.getViewSize());
  JFrame frame=ShowImages.showWindow(gui,""String_Node_Str"",true);
  ImageFloat32 gray=new ImageFloat32(webcam.getViewSize().width,webcam.getViewSize().height);
  AssistedCalibration assisted=new AssistedCalibration(detector,quality,gui);
  assisted.init(gray.width,gray.height);
  BufferedImage image;
  while ((image=webcam.getImage()) != null && !assisted.isFinished()) {
    ConvertBufferedImage.convertFrom(image,gray);
    try {
      assisted.process(gray,image);
    }
 catch (    RuntimeException e) {
      System.err.println(""String_Node_Str"");
      UtilImageIO.saveImage(image,""String_Node_Str"");
      throw e;
    }
  }
  webcam.close();
  if (assisted.isFinished()) {
    frame.setVisible(false);
    inputDirectory=AssistedCalibration.IMAGE_DIRECTORY;
    outputFileName=new File(AssistedCalibration.OUTPUT_DIRECTORY,""String_Node_Str"").getPath();
    handleDirectory();
  }
}",0.9821958456973294
150879,"private void handleClearDots(boolean detected){
  String message=""String_Node_Str"";
  drawPadding();
  if (detected) {
    gui.getInfoPanel().updateView(saver.getCurrentView());
    gui.getInfoPanel().updateFocusScore(saver.getFocusScore());
    double stationaryTime=actions.getStationaryTime();
    CalibrationObservation points=detector.getDetectedPoints();
    view.getSides(points,sides);
    boolean closeToMagnet=false;
    for (int i=0; i < magnets.size(); i++) {
      closeToMagnet|=magnets.get(i).handleDetection();
    }
    boolean resetImageSelector=true;
    if (pictureTaken) {
      if (stationaryTime >= STILL_THRESHOLD) {
        message=""String_Node_Str"";
      }
 else {
        pictureTaken=false;
      }
    }
 else     if (stationaryTime >= STILL_THRESHOLD) {
      if (checkMagnetCapturePicture()) {
        saver.save();
        pictureTaken=true;
        message=""String_Node_Str"";
        captureFiducialPoints();
        gui.getInfoPanel().updateEdgeFill(1.0 - (magnets.size() / (double)totalMagnets));
        if (magnets.isEmpty()) {
          state=State.FILL_SCREEN;
        }
      }
    }
 else     if (stationaryTime > DISPLAY_TIME) {
      if (closeToMagnet) {
        message=String.format(""String_Node_Str"",stationaryTime);
        resetImageSelector=false;
      }
 else {
        message=""String_Node_Str"";
      }
    }
    if (resetImageSelector) {
      saver.clearHistory();
      saver.updateScore(input,sides);
    }
 else {
      saver.process(inputBuffered,input,sides);
    }
    renderMagnets();
    renderArrows();
    renderCalibrationPoints(stationaryTime,points.points);
  }
 else {
    saver.clearHistory();
    for (int i=0; i < magnets.size(); i++) {
      magnets.get(i).handleNoDetection();
    }
    renderMagnets();
  }
  renderFillPolygons();
  gui.setMessage(message);
}","private void handleClearDots(boolean detected){
  String message=""String_Node_Str"";
  if (detected) {
    gui.getInfoPanel().updateView(saver.getCurrentView());
    gui.getInfoPanel().updateFocusScore(saver.getFocusScore());
    double stationaryTime=actions.getStationaryTime();
    CalibrationObservation points=detector.getDetectedPoints();
    view.getSides(points,sides);
    boolean closeToMagnet=false;
    for (int i=0; i < magnets.size(); i++) {
      closeToMagnet|=magnets.get(i).handleDetection();
    }
    boolean resetImageSelector=true;
    if (pictureTaken) {
      if (stationaryTime >= STILL_THRESHOLD) {
        message=""String_Node_Str"";
      }
 else {
        pictureTaken=false;
      }
    }
 else     if (stationaryTime >= STILL_THRESHOLD) {
      if (checkMagnetCapturePicture()) {
        saver.save();
        pictureTaken=true;
        message=""String_Node_Str"";
        captureFiducialPoints();
        gui.getInfoPanel().updateEdgeFill(1.0 - (magnets.size() / (double)totalMagnets));
        if (magnets.isEmpty()) {
          state=State.FILL_SCREEN;
        }
      }
    }
 else     if (stationaryTime > DISPLAY_TIME) {
      if (closeToMagnet) {
        message=String.format(""String_Node_Str"",stationaryTime);
        resetImageSelector=false;
      }
 else {
        message=""String_Node_Str"";
      }
    }
    if (resetImageSelector) {
      saver.clearHistory();
      saver.updateScore(input,sides);
    }
 else {
      saver.process(inputBuffered,input,sides);
    }
    drawPadding();
    renderMagnets();
    renderArrows();
    renderCalibrationPoints(stationaryTime,points.points);
  }
 else {
    drawPadding();
    saver.clearHistory();
    for (int i=0; i < magnets.size(); i++) {
      magnets.get(i).handleNoDetection();
    }
    renderMagnets();
  }
  renderFillPolygons();
  gui.setMessage(message);
}",0.9850988891899214
150880,"/** 
 * Finds the point between indexStart and the end point which is the greater distance from the line (set up prior to calling).  Returns the index 0f the distance is less than tolerance, otherwise -1
 */
protected int selectSplitOffset(int indexStart,int length){
  int bestOffset=-1;
  int indexEnd=(indexStart + length) % N;
  Point2D_I32 startPt=contour.get(indexStart);
  Point2D_I32 endPt=contour.get(indexEnd);
  line.p.set(startPt.x,startPt.y);
  line.slope.set(endPt.x - startPt.x,endPt.y - startPt.y);
  double bestDistanceSq=0;
  double toleranceSplitSq=splitThresholdSq(contour.get(indexStart),contour.get(indexEnd));
  length-=minimumSideLengthPixel;
  for (int i=1 + minimumSideLengthPixel; i < length; i++) {
    Point2D_I32 b=contour.get((indexStart + i) % N);
    point2D.set(b.x,b.y);
    double dist=Distance2D_F64.distanceSq(line,point2D);
    if (dist > bestDistanceSq) {
      bestDistanceSq=dist;
      bestOffset=i;
    }
  }
  if (bestDistanceSq > toleranceSplitSq) {
    return bestOffset;
  }
 else {
    return -1;
  }
}","/** 
 * Finds the point between indexStart and the end point which is the greater distance from the line (set up prior to calling).  Returns the index 0f the distance is less than tolerance, otherwise -1
 */
protected int selectSplitOffset(int indexStart,int length){
  int bestOffset=-1;
  int indexEnd=(indexStart + length) % N;
  Point2D_I32 startPt=contour.get(indexStart);
  Point2D_I32 endPt=contour.get(indexEnd);
  line.p.set(startPt.x,startPt.y);
  line.slope.set(endPt.x - startPt.x,endPt.y - startPt.y);
  double bestDistanceSq=0;
  double toleranceSplitSq=splitThresholdSq(contour.get(indexStart),contour.get(indexEnd));
  length-=2 * minimumSideLengthPixel;
  for (int i=1 + minimumSideLengthPixel; i < length; i++) {
    Point2D_I32 b=contour.get((indexStart + i) % N);
    point2D.set(b.x,b.y);
    double dist=Distance2D_F64.distanceSq(line,point2D);
    if (dist > bestDistanceSq) {
      bestDistanceSq=dist;
      bestOffset=i;
    }
  }
  if (bestDistanceSq > toleranceSplitSq) {
    return bestOffset;
  }
 else {
    return -1;
  }
}",0.9981006647673314
150881,"private void findContour(boolean black){
  ImageUInt8 binary=new ImageUInt8(image.width,image.height);
  GThresholdImageOps.threshold(image,binary,40,black);
  contour=BinaryImageOps.contour(binary,ConnectRule.FOUR,null).get(0).external;
  List<PointIndex_I32> corners=ShapeFittingOps.fitPolygon(contour,true,0.05,5.0,10);
  split=new GrowQueue_I32(corners.size());
  for (int i=0; i < corners.size(); i++) {
    split.add(corners.get(i).index);
  }
}","private void findContour(boolean black){
  ImageUInt8 binary=new ImageUInt8(image.width,image.height);
  GThresholdImageOps.threshold(image,binary,40,black);
  contour=BinaryImageOps.contour(binary,ConnectRule.FOUR,null).get(0).external;
  List<PointIndex_I32> corners=ShapeFittingOps.fitPolygon(contour,true,0.05,0.1,10);
  split=new GrowQueue_I32(corners.size());
  for (int i=0; i < corners.size(); i++) {
    split.add(corners.get(i).index);
  }
}",0.9933481152993348
150882,"@Test public void mergeLines(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.05,0,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(9 - i,1));
  alg.N=alg.contour.size();
  alg.splits.add(0);
  alg.splits.add(5);
  alg.splits.add(9);
  alg.splits.add(10);
  alg.splits.add(15);
  alg.splits.add(19);
  assertTrue(alg.mergeSegments());
  assertTrue(matchSplitsToExpected(new int[]{0,9,10,19},alg.splits));
  alg.splits.reset();
  alg.splits.add(5);
  alg.splits.add(9);
  alg.splits.add(10);
  alg.splits.add(15);
  alg.splits.add(19);
  alg.splits.add(0);
  assertTrue(alg.mergeSegments());
  assertTrue(matchSplitsToExpected(new int[]{9,10,19,0},alg.splits));
}","@Test public void mergeLines(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.05,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(9 - i,3));
  alg.N=alg.contour.size();
  alg.splits.add(0);
  alg.splits.add(5);
  alg.splits.add(9);
  alg.splits.add(10);
  alg.splits.add(15);
  alg.splits.add(19);
  assertTrue(alg.mergeSegments());
  assertTrue(matchSplitsToExpected(new int[]{0,9,10,19},alg.splits));
  alg.splits.reset();
  alg.splits.add(5);
  alg.splits.add(9);
  alg.splits.add(10);
  alg.splits.add(15);
  alg.splits.add(19);
  alg.splits.add(0);
  assertTrue(alg.mergeSegments());
  assertTrue(matchSplitsToExpected(new int[]{9,10,19,0},alg.splits));
}",0.9846907532149418
150883,"@Test public void splitSegments(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=5;
  alg.N=alg.contour.size();
  alg.splits.add(0);
  alg.splits.add(6);
  assertTrue(alg.splitSegments());
  assertTrue(matchSplitsToExpected(new int[]{0,4,6},alg.splits));
}","@Test public void splitSegments(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=5;
  alg.N=alg.contour.size();
  alg.splits.add(0);
  alg.splits.add(6);
  assertTrue(alg.splitSegments());
  assertTrue(matchSplitsToExpected(new int[]{0,4,6},alg.splits));
}",0.972972972972973
150884,"@Test public void selectFarthest(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,1,100);
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(i,0));
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(9 - i,1));
  int found=alg.selectFarthest(contour);
  assertEquals(0,found);
  for (int offset=1; offset < 5; offset++) {
    List<Point2D_I32> adjusted=shiftContour(contour,offset);
    found=alg.selectFarthest(adjusted);
    assertEquals(9 - offset,found);
  }
}","@Test public void selectFarthest(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,MINIMUM_SPLIT_FRACTION,100);
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(i,0));
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(9 - i,1));
  int found=alg.selectFarthest(contour);
  assertEquals(0,found);
  for (int offset=1; offset < 5; offset++) {
    List<Point2D_I32> adjusted=shiftContour(contour,offset);
    found=alg.selectFarthest(adjusted);
    assertEquals(9 - offset,found);
  }
}",0.9794826048171276
150885,"@Test public void selectSplitOffset(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=10;
  alg.N=alg.contour.size();
  alg.line.slope.x=1;
  int found=alg.selectSplitOffset(0,9);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,5);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,4);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(0,3);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(3,5);
  assertEquals(1,found);
  found=alg.selectSplitOffset(5,6);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,8);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,10);
  assertEquals(9,found);
  found=alg.selectSplitOffset(9,8);
  assertEquals(5,found);
  fail(""String_Node_Str"");
}","@Test public void selectSplitOffset(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=10;
  alg.N=alg.contour.size();
  alg.line.slope.x=1;
  int found=alg.selectSplitOffset(0,9);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,5);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,4);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(0,3);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(3,5);
  assertEquals(1,found);
  found=alg.selectSplitOffset(5,6);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,8);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,10);
  assertEquals(9,found);
  found=alg.selectSplitOffset(9,8);
  assertEquals(5,found);
  fail(""String_Node_Str"");
}",0.9871436556735608
150886,"/** 
 * Multiple splits are required
 */
@Test public void splitPixels_multiple(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  alg.contour.add(new Point2D_I32(0,0));
  alg.contour.add(new Point2D_I32(10,10));
  alg.contour.add(new Point2D_I32(20,20));
  alg.contour.add(new Point2D_I32(30,30));
  alg.contour.add(new Point2D_I32(50,20));
  alg.contour.add(new Point2D_I32(60,10));
  alg.contour.add(new Point2D_I32(70,0));
  alg.N=alg.contour.size();
  alg.splitPixels(0,alg.N - 1);
  assertEquals(2,alg.splits.size);
  assertEquals(3,alg.splits.data[0]);
  assertEquals(4,alg.splits.data[1]);
  alg.contour=shiftContour(alg.contour,2);
  alg.splits.reset();
  alg.splitPixels(alg.N - 2,alg.N - 1);
  assertEquals(2,alg.splits.size);
  assertEquals(1,alg.splits.data[0]);
  assertEquals(2,alg.splits.data[1]);
}","/** 
 * Multiple splits are required
 */
@Test public void splitPixels_multiple(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  alg.contour.add(new Point2D_I32(0,0));
  alg.contour.add(new Point2D_I32(10,10));
  alg.contour.add(new Point2D_I32(20,20));
  alg.contour.add(new Point2D_I32(30,30));
  alg.contour.add(new Point2D_I32(50,20));
  alg.contour.add(new Point2D_I32(60,10));
  alg.contour.add(new Point2D_I32(70,0));
  alg.N=alg.contour.size();
  alg.splitPixels(0,alg.N - 1);
  assertEquals(2,alg.splits.size);
  assertEquals(3,alg.splits.data[0]);
  assertEquals(4,alg.splits.data[1]);
  alg.contour=shiftContour(alg.contour,2);
  alg.splits.reset();
  alg.splitPixels(alg.N - 2,alg.N - 1);
  assertEquals(2,alg.splits.size);
  assertEquals(1,alg.splits.data[0]);
  assertEquals(2,alg.splits.data[1]);
}",0.9871003925967472
150887,"/** 
 * Tests contours with zero and one points in them
 */
@Test public void checkZeroOne(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,5,100);
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
  contour.add(new Point2D_I32(2,3));
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
}","/** 
 * Tests contours with zero and one points in them
 */
@Test public void checkZeroOne(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,MINIMUM_SPLIT_FRACTION,100);
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
  contour.add(new Point2D_I32(2,3));
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
}",0.9709228824273072
150888,"/** 
 * Basic tests with a single split
 */
@Test public void splitPixels(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.01,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.N=alg.contour.size();
  alg.contour.get(4).y=6;
  alg.splitPixels(0,3);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(0,4);
  assertEquals(1,alg.splits.size);
  assertEquals(3,alg.splits.data[0]);
  alg.splits.reset();
  alg.splitPixels(0,9);
  assertEquals(3,alg.splits.size);
  assertEquals(3,alg.splits.data[0]);
  assertEquals(4,alg.splits.data[1]);
  assertEquals(5,alg.splits.data[2]);
  alg.splits.reset();
  alg.splitPixels(0,1);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(9,1);
  assertEquals(0,alg.splits.size);
}","/** 
 * Basic tests with a single split
 */
@Test public void splitPixels(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.01,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.N=alg.contour.size();
  alg.contour.get(4).y=6;
  alg.splitPixels(0,3);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(0,4);
  assertEquals(1,alg.splits.size);
  assertEquals(3,alg.splits.data[0]);
  alg.splits.reset();
  alg.splitPixels(0,9);
  assertEquals(3,alg.splits.size);
  assertEquals(3,alg.splits.data[0]);
  assertEquals(4,alg.splits.data[1]);
  assertEquals(5,alg.splits.data[2]);
  alg.splits.reset();
  alg.splitPixels(0,1);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(9,1);
  assertEquals(0,alg.splits.size);
}",0.9858809085328424
150889,"/** 
 * Sees if it can segment a square.
 */
@Test public void simpleSquareAll(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(i,0));
  for (int i=1; i < 5; i++)   contour.add(new Point2D_I32(9,i));
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(9 - i,4));
  for (int i=2; i < 5; i++)   contour.add(new Point2D_I32(0,5 - i));
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,1,100);
  alg.process(contour);
  GrowQueue_I32 splits=alg.getSplits();
  matchSplitsToExpected(new int[]{0,9,13,23},splits);
}","/** 
 * Sees if it can segment a square.
 */
@Test public void simpleSquareAll(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(i,0));
  for (int i=1; i < 5; i++)   contour.add(new Point2D_I32(9,i));
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(9 - i,4));
  for (int i=2; i < 5; i++)   contour.add(new Point2D_I32(0,5 - i));
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,MINIMUM_SPLIT_FRACTION,100);
  alg.process(contour);
  GrowQueue_I32 splits=alg.getSplits();
  matchSplitsToExpected(new int[]{0,9,13,23},splits);
}",0.9810387469084914
150890,"/** 
 * Segment where no splitting is required
 */
@Test public void splitPixels_nosplit(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,5,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.N=alg.contour.size();
  alg.splitPixels(0,5);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(0,9);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(5,1);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(5,9);
  assertEquals(0,alg.splits.size);
}","/** 
 * Segment where no splitting is required
 */
@Test public void splitPixels_nosplit(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,5 * MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.N=alg.contour.size();
  alg.splitPixels(0,5);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(0,9);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(5,1);
  assertEquals(0,alg.splits.size);
  alg.splitPixels(5,9);
  assertEquals(0,alg.splits.size);
}",0.977293369663942
150891,"@Test public void circularDistance(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,5,100);
  alg.N=15;
  assertEquals(0,alg.circularDistance(0,0));
  assertEquals(1,alg.circularDistance(0,1));
  assertEquals(14,alg.circularDistance(0,14));
  assertEquals(0,alg.circularDistance(5,5));
  assertEquals(1,alg.circularDistance(5,6));
  assertEquals(14,alg.circularDistance(5,4));
}","@Test public void circularDistance(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.15,5 * MINIMUM_SPLIT_FRACTION,100);
  alg.N=15;
  assertEquals(0,alg.circularDistance(0,0));
  assertEquals(1,alg.circularDistance(0,1));
  assertEquals(14,alg.circularDistance(0,14));
  assertEquals(0,alg.circularDistance(5,5));
  assertEquals(1,alg.circularDistance(5,6));
  assertEquals(14,alg.circularDistance(5,4));
}",0.9690210656753409
150892,"/** 
 * Simple case with a zig-zag pattern
 */
@Test public void simpleCase(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(i,0));
  for (int i=1; i < 5; i++)   contour.add(new Point2D_I32(9,i));
  for (int i=1; i < 10; i++)   contour.add(new Point2D_I32(9 + i,4));
  for (int i=2; i < 5; i++)   contour.add(new Point2D_I32(18,5 - i));
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,1,100);
  alg.process(contour);
  GrowQueue_I32 splits=alg.getSplits();
  assertEquals(5,splits.size);
  assertEquals(0,alg.splits.data[0]);
  assertEquals(9,alg.splits.data[1]);
  assertEquals(13,alg.splits.data[2]);
  assertEquals(22,alg.splits.data[3]);
  assertEquals(25,alg.splits.data[4]);
}","/** 
 * Simple case with a zig-zag pattern
 */
@Test public void simpleCase(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   contour.add(new Point2D_I32(i,0));
  for (int i=1; i < 5; i++)   contour.add(new Point2D_I32(9,i));
  for (int i=1; i < 10; i++)   contour.add(new Point2D_I32(9 + i,4));
  for (int i=2; i < 5; i++)   contour.add(new Point2D_I32(18,5 - i));
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,MIN_SPLIT,100);
  alg.process(contour);
  GrowQueue_I32 splits=alg.getSplits();
  assertEquals(5,splits.size);
  assertEquals(0,alg.splits.data[0]);
  assertEquals(9,alg.splits.data[1]);
  assertEquals(13,alg.splits.data[2]);
  assertEquals(22,alg.splits.data[3]);
  assertEquals(25,alg.splits.data[4]);
}",0.9935400516795866
150893,"@Test public void splitSegments(){
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=5;
  alg.splits.add(0);
  alg.splits.add(9);
  assertTrue(alg.splitSegments());
  assertEquals(3,alg.splits.size);
  assertEquals(0,alg.splits.data[0]);
  assertEquals(4,alg.splits.data[1]);
  assertEquals(9,alg.splits.data[2]);
}","@Test public void splitSegments(){
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,MIN_SPLIT,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=5;
  alg.splits.add(0);
  alg.splits.add(9);
  assertTrue(alg.splitSegments());
  assertEquals(3,alg.splits.size);
  assertEquals(0,alg.splits.data[0]);
  assertEquals(4,alg.splits.data[1]);
  assertEquals(9,alg.splits.data[2]);
}",0.9895615866388308
150894,"@Test public void mergeSegments(){
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.001,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  alg.contour.add(new Point2D_I32(0,0));
  alg.contour.add(new Point2D_I32(1,0));
  alg.contour.add(new Point2D_I32(3,0));
  alg.contour.add(new Point2D_I32(3,4));
  alg.contour.add(new Point2D_I32(4,4));
  alg.contour.add(new Point2D_I32(5,4));
  for (int i=0; i < alg.contour.size(); i++) {
    alg.splits.add(i);
  }
  assertTrue(alg.mergeSegments());
  assertEquals(3,alg.splits.size);
  assertEquals(0,alg.splits.data[0]);
  assertEquals(2,alg.splits.data[1]);
  assertEquals(5,alg.splits.data[2]);
}","@Test public void mergeSegments(){
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.001,MIN_SPLIT,100);
  alg.contour=new ArrayList<Point2D_I32>();
  alg.contour.add(new Point2D_I32(0,0));
  alg.contour.add(new Point2D_I32(1,0));
  alg.contour.add(new Point2D_I32(3,0));
  alg.contour.add(new Point2D_I32(3,4));
  alg.contour.add(new Point2D_I32(4,4));
  alg.contour.add(new Point2D_I32(5,4));
  for (int i=0; i < alg.contour.size(); i++) {
    alg.splits.add(i);
  }
  assertTrue(alg.mergeSegments());
  assertEquals(3,alg.splits.size);
  assertEquals(0,alg.splits.data[0]);
  assertEquals(2,alg.splits.data[1]);
  assertEquals(5,alg.splits.data[2]);
}",0.9924471299093656
150895,"@Test public void selectSplitOffset(){
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,1,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=10;
  alg.line.slope.x=5;
  int found=alg.selectSplitBetween(0,9);
  assertEquals(4,found);
  found=alg.selectSplitBetween(0,5);
  assertEquals(4,found);
  found=alg.selectSplitBetween(0,4);
  assertTrue(found < 4);
  found=alg.selectSplitBetween(0,3);
  assertEquals(-1,found);
  found=alg.selectSplitBetween(5,9);
  assertEquals(-1,found);
  found=alg.selectSplitBetween(1,6);
  assertEquals(4,found);
}","@Test public void selectSplitOffset(){
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,MIN_SPLIT,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=10;
  alg.line.slope.x=5;
  int found=alg.selectSplitBetween(0,9);
  assertEquals(4,found);
  found=alg.selectSplitBetween(0,5);
  assertEquals(4,found);
  found=alg.selectSplitBetween(0,4);
  assertTrue(found < 4);
  found=alg.selectSplitBetween(0,3);
  assertEquals(-1,found);
  found=alg.selectSplitBetween(5,9);
  assertEquals(-1,found);
  found=alg.selectSplitBetween(1,6);
  assertEquals(4,found);
}",0.9924012158054712
150896,"/** 
 * Tests contours with zero and one points in them
 */
@Test public void checkZeroOne(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,1,100);
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
  contour.add(new Point2D_I32(2,3));
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
}","/** 
 * Tests contours with zero and one points in them
 */
@Test public void checkZeroOne(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  SplitMergeLineFitSegment alg=new SplitMergeLineFitSegment(0.15,MIN_SPLIT,100);
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
  contour.add(new Point2D_I32(2,3));
  alg.process(contour);
  assertEquals(0,alg.getSplits().size);
}",0.9873417721518988
150897,"/** 
 * Finds the point between indexStart and the end point which is the greater distance from the line (set up prior to calling).  Returns the index 0f the distance is less than tolerance, otherwise -1
 */
protected int selectSplitOffset(int indexStart,int length){
  int bestOffset=-1;
  int indexEnd=(indexStart + length) % N;
  Point2D_I32 startPt=contour.get(indexStart);
  Point2D_I32 endPt=contour.get(indexEnd);
  line.p.set(startPt.x,startPt.y);
  line.slope.set(endPt.x - startPt.x,endPt.y - startPt.y);
  double bestDistanceSq=0;
  double toleranceSplitSq=splitThresholdSq(contour.get(indexStart),contour.get(indexEnd));
  length-=2 * minimumSideLengthPixel;
  for (int i=1 + minimumSideLengthPixel; i < length; i++) {
    Point2D_I32 b=contour.get((indexStart + i) % N);
    point2D.set(b.x,b.y);
    double dist=Distance2D_F64.distanceSq(line,point2D);
    if (dist > bestDistanceSq) {
      bestDistanceSq=dist;
      bestOffset=i;
    }
  }
  if (bestDistanceSq > toleranceSplitSq) {
    return bestOffset;
  }
 else {
    return -1;
  }
}","/** 
 * Finds the point between indexStart and the end point which is the greater distance from the line (set up prior to calling).  Returns the index of the element with a distances greater than tolerance, otherwise -1
 */
protected int selectSplitOffset(int indexStart,int length){
  int bestOffset=-1;
  int indexEnd=(indexStart + length) % N;
  Point2D_I32 startPt=contour.get(indexStart);
  Point2D_I32 endPt=contour.get(indexEnd);
  line.p.set(startPt.x,startPt.y);
  line.slope.set(endPt.x - startPt.x,endPt.y - startPt.y);
  double bestDistanceSq=splitThresholdSq(contour.get(indexStart),contour.get(indexEnd));
  int minLength=Math.max(1,minimumSideLengthPixel);
  length-=minLength;
  for (int i=minLength; i <= length; i++) {
    Point2D_I32 b=contour.get((indexStart + i) % N);
    point2D.set(b.x,b.y);
    double dist=Distance2D_F64.distanceSq(line,point2D);
    if (dist > bestDistanceSq) {
      bestDistanceSq=dist;
      bestOffset=i;
    }
  }
  return bestOffset;
}",0.8392156862745098
150898,"@Test public void selectSplitOffset(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(0.001,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=10;
  alg.N=alg.contour.size();
  alg.line.slope.x=1;
  int found=alg.selectSplitOffset(0,9);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,5);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,4);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(0,3);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(3,5);
  assertEquals(1,found);
  found=alg.selectSplitOffset(5,6);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,8);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,10);
  assertEquals(9,found);
  found=alg.selectSplitOffset(9,8);
  assertEquals(5,found);
  fail(""String_Node_Str"");
}","@Test public void selectSplitOffset(){
  SplitMergeLineFitLoop alg=new SplitMergeLineFitLoop(9.0 / 9.0,MINIMUM_SPLIT_FRACTION,100);
  alg.contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 10; i++)   alg.contour.add(new Point2D_I32(i,0));
  alg.contour.get(4).y=10;
  alg.N=alg.contour.size();
  alg.line.slope.x=1;
  int found=alg.selectSplitOffset(0,9);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,5);
  assertEquals(4,found);
  found=alg.selectSplitOffset(0,4);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(0,3);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(3,5);
  assertEquals(1,found);
  found=alg.selectSplitOffset(5,6);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(5,8);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(9,8);
  assertEquals(5,found);
  alg.setSplitFraction(10.1 / 9.00);
  found=alg.selectSplitOffset(0,9);
  assertEquals(-1,found);
  alg.setSplitFraction(9.9 / 9.00);
  found=alg.selectSplitOffset(0,9);
  assertEquals(4,found);
}",0.8547631441957314
150899,"/** 
 * Makes sure the selectSplitOffset is obeying the minimumSideLengthPixel parameter
 */
@Test public void selectSplitOffset_minimumSideLengthPixel(){
  fail(""String_Node_Str"");
}","private void selectSplitOffset_minimumSideLengthPixel(SplitMergeLineFitLoop alg,int minimum){
  int found=alg.selectSplitOffset(5 - minimum,9);
  assertEquals(minimum,found);
  found=alg.selectSplitOffset(0,5 + minimum);
  assertEquals(5,found);
  found=alg.selectSplitOffset(5 - minimum + 1,9);
  assertEquals(-1,found);
  found=alg.selectSplitOffset(0,5 + minimum - 1);
  assertEquals(-1,found);
}",0.1134020618556701
150900,"public PlanarDetectorChessboard(ConfigChessboard config){
  RefineBinaryPolygon<ImageFloat32> refineLine=FactoryShapeDetector.refinePolygon(config.configRefineLines,ImageFloat32.class);
  RefineBinaryPolygon<ImageFloat32> refineCorner=FactoryShapeDetector.refinePolygon(config.configRefineLines,ImageFloat32.class);
  config.square.refine=null;
  BinaryPolygonDetector<ImageFloat32> detectorSquare=FactoryShapeDetector.polygon(config.square,ImageFloat32.class);
  InputToBinary<ImageFloat32> inputToBinary=FactoryThresholdBinary.threshold(config.thresholding,ImageFloat32.class);
  alg=new DetectChessboardFiducial<ImageFloat32>(config.numCols,config.numRows,config.maximumCornerDistance,detectorSquare,refineLine,refineCorner,inputToBinary);
  layoutPoints=gridChess(config.numCols,config.numRows,config.squareWidth);
}","public PlanarDetectorChessboard(ConfigChessboard config){
  RefineBinaryPolygon<ImageFloat32> refineLine=FactoryShapeDetector.refinePolygon(config.configRefineLines,ImageFloat32.class);
  RefineBinaryPolygon<ImageFloat32> refineCorner=config.refineWithCorners ? FactoryShapeDetector.refinePolygon(config.configRefineLines,ImageFloat32.class) : null;
  config.square.refine=null;
  BinaryPolygonDetector<ImageFloat32> detectorSquare=FactoryShapeDetector.polygon(config.square,ImageFloat32.class);
  InputToBinary<ImageFloat32> inputToBinary=FactoryThresholdBinary.threshold(config.thresholding,ImageFloat32.class);
  alg=new DetectChessboardFiducial<ImageFloat32>(config.numCols,config.numRows,config.maximumCornerDistance,detectorSquare,refineLine,refineCorner,inputToBinary);
  layoutPoints=gridChess(config.numCols,config.numRows,config.squareWidth);
}",0.9796893667861408
150901,"@Override public void adjustBeforeOptimize(Polygon2D_F64 polygon){
  center.x=0;
  center.y=0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    center.x+=p.x;
    center.y+=p.y;
  }
  center.x/=4.0;
  center.y/=4.0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    double dx=p.x - center.x;
    double dy=p.y - center.y;
    double r=Math.sqrt(dx * dx + dy * dy);
    if (r > 0) {
      p.x+=1.4 * dx / r;
      p.y+=1.4 * dy / r;
    }
  }
  if (refineCorner != null) {
    double area=polygon.areaSimple();
    if (area < threshold) {
      detectorSquare.setRefinePolygon(refineLine);
    }
 else {
      detectorSquare.setRefinePolygon(refineCorner);
    }
  }
}","@Override public void adjustBeforeOptimize(Polygon2D_F64 polygon){
  center.x=0;
  center.y=0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    center.x+=p.x;
    center.y+=p.y;
  }
  center.x/=4.0;
  center.y/=4.0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    double dx=p.x - center.x;
    double dy=p.y - center.y;
    double r=Math.sqrt(dx * dx + dy * dy);
    if (r > 0) {
      p.x+=1.4 * dx / r;
      p.y+=1.4 * dy / r;
    }
  }
  if (refineCorner != null) {
    double area=polygon.areaSimple();
    if (area < threshold) {
      detectorSquare.setRefinePolygon(refineLine);
    }
 else {
      detectorSquare.setRefinePolygon(refineCorner);
    }
  }
 else {
    detectorSquare.setRefinePolygon(refineLine);
  }
}",0.9584751531654186
150902,"/** 
 * Finds blobs in the binary image.  Then looks for blobs that meet size and shape requirements.  See code below for the requirements.  Those that remain are considered to be target candidates.
 */
private void findCandidateShapes(T gray,ImageUInt8 binary){
  int maxSidesConsider=(int)Math.ceil(maxSides * 1.2);
  fitPolygon.setAbortSplits(2 * maxSides);
  contourFinder.process(binary,labeled);
  FastQueue<Contour> blobs=contourFinder.getContours();
  for (int i=0; i < blobs.size; i++) {
    Contour c=blobs.get(i);
    if (c.external.size() >= minimumContour) {
      if (touchesBorder(c.external))       continue;
      if (toUndistorted != null) {
        removeDistortionFromContour(c.external);
      }
      if (!fitPolygon.process(c.external)) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
        continue;
      }
      GrowQueue_I32 splits=fitPolygon.getSplits();
      if (splits.size() > maxSidesConsider) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
      }
      if (!improveContour.fit(c.external,splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
        continue;
      }
      boolean wasPruned=pruner.fit(c.external,splits,pruned);
      splits=pruned;
      if (!expectedNumberOfSides(splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + splits.size() + ""String_Node_Str""+ c.external.size());
        continue;
      }
      if (wasPruned && !improveContour.fit(c.external,splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
        continue;
      }
      if (helper != null) {
        if (!helper.filterPolygon(c.external,splits)) {
          if (verbose)           System.out.println(""String_Node_Str"");
          continue;
        }
      }
      workPoly.vertexes.resize(splits.size());
      for (int j=0; j < splits.size(); j++) {
        Point2D_I32 p=c.external.get(splits.get(j));
        workPoly.get(j).set(p.x,p.y);
      }
      if (helper != null) {
        helper.adjustBeforeOptimize(workPoly);
      }
      if (convex && !UtilPolygons2D_F64.isConvex(workPoly)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      double area=Area2D_F64.polygonSimple(workPoly);
      if (area < minimumArea) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      if (checkEdgeBefore && differenceScore != null && !differenceScore.validate(workPoly)) {
        if (verbose)         System.out.println(""String_Node_Str"" + differenceScore.getAverageEdgeIntensity());
        continue;
      }
      Polygon2D_F64 refined=found.grow();
      refined.vertexes.resize(splits.size);
      boolean success;
      if (refinePolygon != null) {
        refinePolygon.setImage(gray);
        success=refinePolygon.refine(workPoly,c.external,splits,refined);
        if (verbose)         System.out.println(""String_Node_Str"");
      }
 else {
        refined.set(workPoly);
        success=true;
      }
      if (!checkEdgeBefore && differenceScore != null && !differenceScore.validate(refined)) {
        if (verbose)         System.out.println(""String_Node_Str"" + differenceScore.getAverageEdgeIntensity());
        continue;
      }
      if (outputClockwise == refined.isCCW())       refined.flip();
      if (success) {
        c.id=found.size();
        foundContours.add(c);
      }
 else {
        found.removeTail();
      }
    }
  }
}","/** 
 * Finds blobs in the binary image.  Then looks for blobs that meet size and shape requirements.  See code below for the requirements.  Those that remain are considered to be target candidates.
 */
private void findCandidateShapes(T gray,ImageUInt8 binary){
  int maxSidesConsider=(int)Math.ceil(maxSides * 1.5);
  fitPolygon.setAbortSplits(2 * maxSides);
  contourFinder.process(binary,labeled);
  FastQueue<Contour> blobs=contourFinder.getContours();
  for (int i=0; i < blobs.size; i++) {
    Contour c=blobs.get(i);
    if (c.external.size() >= minimumContour) {
      System.out.println(""String_Node_Str"" + c.external.size());
      if (touchesBorder(c.external)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      if (toUndistorted != null) {
        removeDistortionFromContour(c.external);
      }
      if (!fitPolygon.process(c.external)) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
        continue;
      }
      GrowQueue_I32 splits=fitPolygon.getSplits();
      if (splits.size() > maxSidesConsider) {
        if (verbose)         System.out.println(""String_Node_Str"" + splits.size() + ""String_Node_Str""+ c.external.size());
        continue;
      }
      if (!improveContour.fit(c.external,splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
        continue;
      }
      boolean wasPruned=pruner.fit(c.external,splits,pruned);
      splits=pruned;
      if (!expectedNumberOfSides(splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + splits.size() + ""String_Node_Str""+ c.external.size());
        continue;
      }
      if (wasPruned && !improveContour.fit(c.external,splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + c.external.size());
        continue;
      }
      if (helper != null) {
        if (!helper.filterPolygon(c.external,splits)) {
          if (verbose)           System.out.println(""String_Node_Str"");
          continue;
        }
      }
      workPoly.vertexes.resize(splits.size());
      for (int j=0; j < splits.size(); j++) {
        Point2D_I32 p=c.external.get(splits.get(j));
        workPoly.get(j).set(p.x,p.y);
      }
      if (helper != null) {
        helper.adjustBeforeOptimize(workPoly);
      }
      if (convex && !UtilPolygons2D_F64.isConvex(workPoly)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      double area=Area2D_F64.polygonSimple(workPoly);
      if (area < minimumArea) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      if (checkEdgeBefore && differenceScore != null && !differenceScore.validate(workPoly)) {
        if (verbose)         System.out.println(""String_Node_Str"" + differenceScore.getAverageEdgeIntensity());
        continue;
      }
      Polygon2D_F64 refined=found.grow();
      refined.vertexes.resize(splits.size);
      boolean success;
      if (refinePolygon != null) {
        refinePolygon.setImage(gray);
        success=refinePolygon.refine(workPoly,c.external,splits,refined);
        if (verbose && !success)         System.out.println(""String_Node_Str"");
      }
 else {
        refined.set(workPoly);
        success=true;
      }
      if (!checkEdgeBefore && differenceScore != null && !differenceScore.validate(refined)) {
        if (verbose)         System.out.println(""String_Node_Str"" + differenceScore.getAverageEdgeIntensity());
        continue;
      }
      if (outputClockwise == refined.isCCW())       refined.flip();
      if (success) {
        System.out.println(""String_Node_Str"");
        c.id=found.size();
        foundContours.add(c);
      }
 else {
        found.removeTail();
      }
    }
  }
}",0.9609406676577916
150903,"void sanityCheckCornerOrder(int anchor0,int numLines,int contourAnchor0){
  int previous=0;
  for (int i=1; i <= numLines; i++) {
    int contourIndex=workCorners.get(CircularIndex.addOffset(anchor0,i,workCorners.size()));
    int pixelsFromAnchor0=CircularIndex.distanceP(contourAnchor0,contourIndex,contour.size());
    if (pixelsFromAnchor0 < previous) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      previous=pixelsFromAnchor0;
    }
  }
}","/** 
 * All the corners should be in increasing order from the first anchor.
 */
boolean sanityCheckCornerOrder(int numLines,GrowQueue_I32 corners){
  int contourAnchor0=corners.get(anchor0);
  int previous=0;
  for (int i=1; i < numLines; i++) {
    int contourIndex=corners.get(CircularIndex.addOffset(anchor0,i,corners.size()));
    int pixelsFromAnchor0=CircularIndex.distanceP(contourAnchor0,contourIndex,contour.size());
    if (pixelsFromAnchor0 < previous) {
      return false;
    }
 else {
      previous=pixelsFromAnchor0;
    }
  }
  return true;
}",0.7468477206595538
150904,"int closestPoint(Point2D_F64 target){
  double bestDistance=Double.MAX_VALUE;
  int bestIndex=-1;
  for (int i=0; i < contour.size(); i++) {
    Point2D_I32 c=contour.get(i);
    double d=UtilPoint2D_F64.distanceSq(target.x,target.y,c.x,c.y);
    if (d < bestDistance) {
      bestDistance=d;
      bestIndex=i;
    }
  }
  return bestIndex;
}","/** 
 * Returns the closest point on the contour to the provided point in space
 * @return index of closest point
 */
int closestPoint(Point2D_F64 target){
  double bestDistance=Double.MAX_VALUE;
  int bestIndex=-1;
  for (int i=0; i < contour.size(); i++) {
    Point2D_I32 c=contour.get(i);
    double d=UtilPoint2D_F64.distanceSq(target.x,target.y,c.x,c.y);
    if (d < bestDistance) {
      bestDistance=d;
      bestIndex=i;
    }
  }
  return bestIndex;
}",0.8532338308457711
150905,"void fitLinesUsingCorners(int anchor0,int numLines){
  for (int i=1; i <= numLines; i++) {
    int index0=workCorners.get(CircularIndex.addOffset(anchor0,i - 1,workCorners.size));
    int index1=workCorners.get(CircularIndex.addOffset(anchor0,i,workCorners.size));
    if (!fitLine(workCorners.get(index0),workCorners.get(index1),lines.get(i - 1))) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
}","/** 
 * Fits lines across the sequence of corners
 * @param numLines number of lines it will fit
 */
boolean fitLinesUsingCorners(int numLines,GrowQueue_I32 cornerIndexes){
  for (int i=1; i <= numLines; i++) {
    int index0=cornerIndexes.get(CircularIndex.addOffset(anchor0,i - 1,cornerIndexes.size));
    int index1=cornerIndexes.get(CircularIndex.addOffset(anchor0,i,cornerIndexes.size));
    if (index0 == index1)     return false;
    if (!fitLine(index0,index1,lines.get(i - 1))) {
      throw new RuntimeException(""String_Node_Str"");
    }
    LineGeneral2D_F64 l=lines.get(i - 1);
    if (Double.isNaN(l.A) || Double.isNaN(l.B) || Double.isNaN(l.C)) {
      Point2D_I32 c0=contour.get(index0);
      Point2D_I32 c1=contour.get(index1);
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return true;
}",0.2744148506860371
150906,"boolean fitLine(int contourIndex0,int contourIndex1,LineGeneral2D_F64 line){
  int numPixels=CircularIndex.distanceP(contourIndex0,contourIndex1,contour.size());
  Point2D_I32 c0=contour.get(contourIndex0);
  Point2D_I32 c1=contour.get(contourIndex1);
  double scale=c0.distance(c1);
  double centerX=(c1.x + c0.x) / 2.0;
  double centerY=(c1.y + c0.y) / 2.0;
  pointsFit.reset();
  for (int i=0; i < numPixels; i++) {
    Point2D_I32 c=contour.get(CircularIndex.addOffset(contourIndex0,i,contour.size()));
    Point2D_F64 p=pointsFit.grow();
    p.x=(c.x - centerX) / scale;
    p.y=(c.y - centerY) / scale;
  }
  if (null == FitLine_F64.polar(pointsFit.toList(),linePolar)) {
    return false;
  }
  UtilLine2D_F64.convert(linePolar,line);
  line.C=scale * line.C - centerX * line.A - centerY * line.B;
  return true;
}","/** 
 * Given a sequence of points on the contour find the best fit line.
 * @param contourIndex0 contour index of first point in the sequence
 * @param contourIndex1 contour index of last point (exclusive) in the sequence
 * @param line storage for the found line
 * @return true if successful or false if it failed
 */
boolean fitLine(int contourIndex0,int contourIndex1,LineGeneral2D_F64 line){
  int numPixels=CircularIndex.distanceP(contourIndex0,contourIndex1,contour.size());
  Point2D_I32 c0=contour.get(contourIndex0);
  Point2D_I32 c1=contour.get(contourIndex1);
  double scale=c0.distance(c1);
  double centerX=(c1.x + c0.x) / 2.0;
  double centerY=(c1.y + c0.y) / 2.0;
  pointsFit.reset();
  for (int i=0; i < numPixels; i++) {
    Point2D_I32 c=contour.get(CircularIndex.addOffset(contourIndex0,i,contour.size()));
    Point2D_F64 p=pointsFit.grow();
    p.x=(c.x - centerX) / scale;
    p.y=(c.y - centerY) / scale;
  }
  if (null == FitLine_F64.polar(pointsFit.toList(),linePolar)) {
    return false;
  }
  UtilLine2D_F64.convert(linePolar,line);
  line.C=scale * line.C - centerX * line.A - centerY * line.B;
  return true;
}",0.8364747834946511
150907,"void linesIntoCorners(int anchor0,int numLines){
  for (int i=1; i < numLines; i++) {
    LineGeneral2D_F64 line0=lines.get(i - 1);
    LineGeneral2D_F64 line1=lines.get(i);
    if (null == Intersection2D_F64.intersection(line0,line1,intersection)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int contourIndex=closestPoint(intersection);
    int cornerIndex=CircularIndex.addOffset(anchor0,i,workCorners.size);
    workCorners.set(contourIndex,cornerIndex);
  }
}","/** 
 * finds the intersection of a line and update the corner index
 */
boolean linesIntoCorners(int numLines,GrowQueue_I32 contourCorners){
  GrowQueue_I32 skippedCorners=new GrowQueue_I32();
  int contourIndexPrevious=contourCorners.get(anchor0);
  for (int i=1; i < numLines; i++) {
    LineGeneral2D_F64 line0=lines.get(i - 1);
    LineGeneral2D_F64 line1=lines.get(i);
    int cornerIndex=CircularIndex.addOffset(anchor0,i,contourCorners.size);
    boolean skipped=false;
    if (null == Intersection2D_F64.intersection(line0,line1,intersection)) {
      if (verbose)       System.out.println(""String_Node_Str"");
      skipped=true;
    }
 else {
      int contourIndex=closestPoint(intersection);
      if (contourIndex != contourIndexPrevious) {
        Point2D_I32 a=contour.get(contourIndexPrevious);
        Point2D_I32 b=contour.get(contourIndex);
        if (a.x == b.x && a.y == b.y) {
          if (verbose)           System.out.println(""String_Node_Str"");
          skipped=true;
        }
 else {
          contourCorners.set(cornerIndex,contourIndex);
          contourIndexPrevious=contourIndex;
        }
      }
 else {
        if (verbose)         System.out.println(""String_Node_Str"");
        skipped=true;
      }
    }
    if (skipped) {
      skippedCorners.add(cornerIndex);
    }
  }
  int cornerIndex=CircularIndex.addOffset(anchor0,numLines,contourCorners.size);
  Point2D_I32 a=contour.get(contourIndexPrevious);
  Point2D_I32 b=contour.get(contourCorners.get(cornerIndex));
  if (a.x == b.x && a.y == b.y) {
    skippedCorners.add(cornerIndex);
  }
  Arrays.sort(skippedCorners.data,0,skippedCorners.size);
  for (int i=skippedCorners.size - 1; i >= 0; i--) {
    int index=skippedCorners.get(i);
    contourCorners.remove(index);
    if (anchor0 >= index) {
      anchor0--;
    }
    if (anchor1 >= index) {
      anchor1--;
    }
  }
  for (int i=0; i < contourCorners.size(); i++) {
    int j=(i + 1) % contourCorners.size();
    a=contour.get(contourCorners.get(i));
    b=contour.get(contourCorners.get(j));
    if (a.x == b.x && a.y == b.y) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return contourCorners.size() >= 3;
}",0.2893553223388306
150908,"/** 
 * Fits line segments along the contour with the first and last corner fixed at the original corners.  The output will be a new set of corner indexes.  Since the corner list is circular, it is assumed that anchor1 comes after anchor0.  The same index can be specified for an anchor, it will just go around the entire circle
 * @param anchor0 corner index of the first end point
 * @param anchor1 corner index of the second end point.
 * @param corners Initial location of the corners
 * @param output Optimized location of the corners
 */
public void fitAnchored(int anchor0,int anchor1,GrowQueue_I32 corners,GrowQueue_I32 output){
  int numLines=anchor0 == anchor1 ? corners.size() : CircularIndex.distanceP(anchor0,anchor1,corners.size);
  if (numLines < 2) {
    throw new RuntimeException(""String_Node_Str"");
  }
  int contourAnchor0=corners.get(anchor0);
  workCorners.setTo(corners);
  for (int iteration=0; iteration < maxIterations; iteration++) {
    fitLinesUsingCorners(anchor0,numLines);
    linesIntoCorners(anchor0,numLines);
    sanityCheckCornerOrder(anchor0,numLines,contourAnchor0);
  }
  output.setTo(workCorners);
}","/** 
 * Fits line segments along the contour with the first and last corner fixed at the original corners.  The output will be a new set of corner indexes.  Since the corner list is circular, it is assumed that anchor1 comes after anchor0.  The same index can be specified for an anchor, it will just go around the entire circle
 * @param anchor0 corner index of the first end point
 * @param anchor1 corner index of the second end point.
 * @param corners Initial location of the corners
 * @param output Optimized location of the corners
 */
public boolean fitAnchored(int anchor0,int anchor1,GrowQueue_I32 corners,GrowQueue_I32 output){
  this.anchor0=anchor0;
  this.anchor1=anchor1;
  int numLines=anchor0 == anchor1 ? corners.size() : CircularIndex.distanceP(anchor0,anchor1,corners.size);
  if (numLines < 2) {
    throw new RuntimeException(""String_Node_Str"");
  }
  lines.resize(numLines);
  Point2D_I32 hack=contour.get(corners.get(0));
  verbose=hack.x == 52 && hack.y == 61;
  if (verbose)   System.out.println(""String_Node_Str"");
  for (int i=0; i < corners.size(); ) {
    int j=(i + 1) % corners.size();
    int index0=corners.get(i);
    int index1=corners.get(j);
    Point2D_I32 a=contour.get(index0);
    Point2D_I32 b=contour.get(index1);
    if (a.x == b.x && a.y == b.y) {
      throw new RuntimeException(""String_Node_Str"");
    }
 else {
      i++;
    }
  }
  workCorners.setTo(corners);
  for (int iteration=0; iteration < maxIterations; iteration++) {
    if (!fitLinesUsingCorners(numLines,workCorners)) {
      return false;
    }
    if (!linesIntoCorners(numLines,workCorners)) {
      return false;
    }
    if (!sanityCheckCornerOrder(numLines,workCorners)) {
      return false;
    }
  }
  if (verbose)   System.out.println(""String_Node_Str"" + corners.size() + ""String_Node_Str""+ workCorners.size());
  output.setTo(workCorners);
  return true;
}",0.6604897418927862
150909,"public void execute(String[] args,BaseFiducialSquareEPS app) throws IOException {
  try {
    parseArguments(args);
  }
 catch (  IllegalArgumentException e) {
    printHelp();
    System.out.println();
    System.out.println(e.getMessage());
    System.exit(-1);
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + outputName);
  System.out.println(""String_Node_Str"" + units);
  System.out.println(""String_Node_Str"" + fiducialWidth);
  if (whiteBorder > -1)   System.out.println(""String_Node_Str"" + whiteBorder);
  System.out.println(""String_Node_Str"" + printInfo);
  System.out.println(""String_Node_Str"" + printGrid);
  System.out.println(""String_Node_Str"" + (!noBoundaryHack));
  if (isBinary)   System.out.println(""String_Node_Str"" + binaryGridSize + ""String_Node_Str""+ binaryGridSize);
  if (paper != null)   System.out.println(""String_Node_Str"" + paper);
  if (gridX < 0)   System.out.println(""String_Node_Str"");
 else   if (gridX > 1 && gridY > 1)   System.out.printf(""String_Node_Str"",gridY,gridX);
  if (autoCenter)   System.out.println(""String_Node_Str"");
 else   System.out.printf(""String_Node_Str"",offsetX,offsetY);
  if (!Double.isNaN(borderX))   System.out.printf(""String_Node_Str"",borderX,borderY);
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (  String p : patternNames) {
    System.out.println(""String_Node_Str"" + p);
  }
  System.out.println(""String_Node_Str"");
  for (  String path : patternNames) {
    app.addPattern(path);
  }
  if (app instanceof CreateFiducialSquareBinaryEPS) {
switch (binaryGridSize) {
case 3:
      ((CreateFiducialSquareBinaryEPS)app).setGridSize(BinaryFiducialGridSize.THREE_BY_THREE);
    break;
case 5:
  ((CreateFiducialSquareBinaryEPS)app).setGridSize(BinaryFiducialGridSize.FIVE_BY_FIVE);
break;
default :
System.out.println(""String_Node_Str"");
case 4:
((CreateFiducialSquareBinaryEPS)app).setGridSize(BinaryFiducialGridSize.FOUR_BY_FOUR);
break;
}
}
app.setOutputFileName(outputName);
app.setPrintInfo(printInfo);
app.setPrintGrid(printGrid);
app.setBoundaryHack(!noBoundaryHack);
app.setUnit(units);
if (!autoCenter) {
app.setCentering(false);
app.setOffset(offsetX,offsetY,units);
}
if (!Double.isNaN(borderX)) {
app.setPageBorder(borderX,borderY,units);
}
 else {
app.setPageBorder(0,0,units);
}
app.generateGrid(fiducialWidth,whiteBorder,gridX,gridY,paper);
System.out.println(""String_Node_Str"");
}","public void execute(String[] args,BaseFiducialSquareEPS app) throws IOException {
  try {
    parseArguments(args);
  }
 catch (  IllegalArgumentException e) {
    printHelp();
    System.out.println();
    System.out.println(e.getMessage());
    System.exit(-1);
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + outputName);
  System.out.println(""String_Node_Str"" + units);
  System.out.println(""String_Node_Str"" + fiducialWidth);
  if (whiteBorder > -1)   System.out.println(""String_Node_Str"" + whiteBorder);
  System.out.println(""String_Node_Str"" + printInfo);
  System.out.println(""String_Node_Str"" + printGrid);
  System.out.println(""String_Node_Str"" + (!noBoundaryHack));
  if (isBinary)   System.out.println(""String_Node_Str"" + binaryGridSize + ""String_Node_Str""+ binaryGridSize);
  if (paper != null)   System.out.println(""String_Node_Str"" + paper);
  if (gridX < 0)   System.out.println(""String_Node_Str"");
 else   if (gridX > 1 && gridY > 1)   System.out.printf(""String_Node_Str"",gridY,gridX);
  if (autoCenter)   System.out.println(""String_Node_Str"");
 else   System.out.printf(""String_Node_Str"",offsetX,offsetY);
  if (!Double.isNaN(borderX))   System.out.printf(""String_Node_Str"",borderX,borderY);
  System.out.println();
  System.out.println(""String_Node_Str"");
  for (  String p : patternNames) {
    System.out.println(""String_Node_Str"" + p);
  }
  System.out.println(""String_Node_Str"");
  if (app instanceof CreateFiducialSquareBinaryEPS) {
switch (binaryGridSize) {
case 3:
      ((CreateFiducialSquareBinaryEPS)app).setGridSize(BinaryFiducialGridSize.THREE_BY_THREE);
    break;
case 5:
  ((CreateFiducialSquareBinaryEPS)app).setGridSize(BinaryFiducialGridSize.FIVE_BY_FIVE);
break;
default :
System.out.println(""String_Node_Str"");
case 4:
((CreateFiducialSquareBinaryEPS)app).setGridSize(BinaryFiducialGridSize.FOUR_BY_FOUR);
break;
}
}
for (String path : patternNames) {
app.addPattern(path);
}
app.setOutputFileName(outputName);
app.setPrintInfo(printInfo);
app.setPrintGrid(printGrid);
app.setBoundaryHack(!noBoundaryHack);
app.setUnit(units);
if (!autoCenter) {
app.setCentering(false);
app.setOffset(offsetX,offsetY,units);
}
if (!Double.isNaN(borderX)) {
app.setPageBorder(borderX,borderY,units);
}
 else {
app.setPageBorder(0,0,units);
}
app.generateGrid(fiducialWidth,whiteBorder,gridX,gridY,paper);
System.out.println(""String_Node_Str"");
}",0.9734439834024896
150910,"private void box(PrintStream out,final int bit){
  final int transitionBits[];
switch (gridSize) {
case THREE_BY_THREE:
    transitionBits=new int[]{0,3,4};
  break;
case FOUR_BY_FOUR:
transitionBits=new int[]{1,9,11};
break;
case FIVE_BY_FIVE:
transitionBits=new int[]{1,17,20};
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
final int adjustedBit;
if (bit < transitionBits[0]) adjustedBit=bit + 1;
 else if (bit < transitionBits[1]) adjustedBit=bit + 2;
 else if (bit < transitionBits[2]) adjustedBit=bit + 3;
 else throw new RuntimeException(""String_Node_Str"" + transitionBits[2]);
int x=adjustedBit % gridSize.getWidth();
int y=adjustedBit / gridSize.getWidth();
out.print(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
}","private void box(PrintStream out,final int bit){
  final int transitionBits[];
switch (gridSize) {
case THREE_BY_THREE:
    transitionBits=new int[]{0,3,4};
  break;
case FOUR_BY_FOUR:
transitionBits=new int[]{1,9,11};
break;
case FIVE_BY_FIVE:
transitionBits=new int[]{1,17,20};
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
final int adjustedBit;
if (bit <= transitionBits[0]) adjustedBit=bit + 1;
 else if (bit <= transitionBits[1]) adjustedBit=bit + 2;
 else if (bit <= transitionBits[2]) adjustedBit=bit + 3;
 else throw new RuntimeException(""String_Node_Str"" + transitionBits[2]);
int x=adjustedBit % gridSize.getWidth();
int y=adjustedBit / gridSize.getWidth();
out.print(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
}",0.998037933289732
150911,"/** 
 * Configures the fiducial detector, specifying the grid type.
 * @param inputType Type of image it's processing
 */
public DetectFiducialSquareBinary(final BinaryFiducialGridSize gridSize,final InputToBinary<T> inputToBinary,final BinaryPolygonDetector<T> quadDetector,Class<T> inputType){
  super(inputToBinary,quadDetector,(w * gridSize.getWidth() + 4 * w),inputType);
  this.gridSize=gridSize;
  final int elCount=gridSize.getWidth();
  binaryInner.reshape(w * elCount,w * elCount);
  counts=new int[elCount];
  classified=new int[elCount];
  tmp=new int[elCount];
}","/** 
 * Configures the fiducial detector, specifying the grid type.
 * @param inputType Type of image it's processing
 */
public DetectFiducialSquareBinary(final BinaryFiducialGridSize gridSize,final InputToBinary<T> inputToBinary,final BinaryPolygonDetector<T> quadDetector,Class<T> inputType){
  super(inputToBinary,quadDetector,(w * gridSize.getWidth() + 4 * w),inputType);
  this.gridSize=gridSize;
  binaryInner.reshape(w * gridSize.getWidth(),w * gridSize.getWidth());
  counts=new int[gridSize.getNumberOfElements()];
  classified=new int[gridSize.getNumberOfElements()];
  tmp=new int[gridSize.getNumberOfElements()];
}",0.7520798668885191
150912,"private void box(PrintStream out,final int bit){
  final int transitionBits[];
switch (gridSize) {
case THREE_BY_THREE:
    transitionBits=new int[]{0,3,4};
  break;
case FOUR_BY_FOUR:
transitionBits=new int[]{1,9,11};
break;
case FIVE_BY_FIVE:
transitionBits=new int[]{1,17,20};
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
final int adjustedBit;
if (bit <= transitionBits[0]) adjustedBit=bit + 1;
 else if (bit <= transitionBits[1]) adjustedBit=bit + 2;
 else if (bit <= transitionBits[2]) adjustedBit=bit + 3;
 else throw new RuntimeException(""String_Node_Str"" + transitionBits[2]);
int x=adjustedBit % gridSize.getWidth();
int y=adjustedBit / gridSize.getWidth();
out.print(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
}","private void box(PrintStream out,final int bit){
  final int transitionBits[];
switch (gridSize) {
case THREE_BY_THREE:
    transitionBits=new int[]{0,3,4};
  break;
case FOUR_BY_FOUR:
transitionBits=new int[]{1,9,11};
break;
case FIVE_BY_FIVE:
transitionBits=new int[]{2,17,20};
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
final int adjustedBit;
if (bit <= transitionBits[0]) adjustedBit=bit + 1;
 else if (bit <= transitionBits[1]) adjustedBit=bit + 2;
 else if (bit <= transitionBits[2]) adjustedBit=bit + 3;
 else throw new RuntimeException(""String_Node_Str"" + transitionBits[2]);
int x=adjustedBit % gridSize.getWidth();
int y=adjustedBit / gridSize.getWidth();
out.print(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
}",0.9986945169712794
150913,"@Override public void adjustBeforeOptimize(Polygon2D_F64 polygon){
  center.x=0;
  center.y=0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    center.x+=p.x;
    center.y+=p.y;
  }
  center.x/=4.0;
  center.y/=4.0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    double dx=p.x - center.x;
    double dy=p.y - center.y;
    double r=Math.sqrt(dx * dx + dy * dy);
    p.x+=1.4 * dx / r;
    p.y+=1.4 * dy / r;
  }
}","@Override public void adjustBeforeOptimize(Polygon2D_F64 polygon){
  center.x=0;
  center.y=0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    center.x+=p.x;
    center.y+=p.y;
  }
  center.x/=4.0;
  center.y/=4.0;
  for (int j=0; j < 4; j++) {
    Point2D_F64 p=polygon.get(j);
    double dx=p.x - center.x;
    double dy=p.y - center.y;
    double r=Math.sqrt(dx * dx + dy * dy);
    if (r > 0) {
      p.x+=1.4 * dx / r;
      p.y+=1.4 * dy / r;
    }
  }
}",0.9710610932475884
150914,"public static void main(String args[]){
  String directory=""String_Node_Str"";
  BufferedImage orig=UtilImageIO.loadImage(directory + ""String_Node_Str"");
  ImageFloat32 input=ConvertBufferedImage.convertFrom(orig,(ImageFloat32)null);
  PlanarCalibrationDetector detector;
  detector=FactoryPlanarCalibrationTarget.detectorChessboard(new ConfigChessboard(5,7,30));
  if (!detector.process(input))   throw new RuntimeException(""String_Node_Str"");
  List<Point2D_F64> points=detector.getDetectedPoints();
  Graphics2D g2=orig.createGraphics();
  for (  Point2D_F64 p : points)   VisualizeFeatures.drawPoint(g2,(int)p.x,(int)p.y,3,Color.RED);
  ShowImages.showWindow(orig,""String_Node_Str"");
}","public static void main(String args[]){
  String directory=""String_Node_Str"";
  BufferedImage orig=UtilImageIO.loadImage(directory + ""String_Node_Str"");
  ImageFloat32 input=ConvertBufferedImage.convertFrom(orig,(ImageFloat32)null);
  PlanarCalibrationDetector detector;
  detector=FactoryPlanarCalibrationTarget.detectorChessboard(new ConfigChessboard(5,7,30));
  if (!detector.process(input))   throw new RuntimeException(""String_Node_Str"");
  List<Point2D_F64> points=detector.getDetectedPoints();
  Graphics2D g2=orig.createGraphics();
  for (  Point2D_F64 p : points)   VisualizeFeatures.drawPoint(g2,(int)p.x,(int)p.y,3,Color.RED);
  ShowImages.showWindow(orig,""String_Node_Str"",true);
}",0.99637943519189
150915,"public static void main(String args[]){
  IntrinsicParameters intrinsic=UtilIO.loadXML(""String_Node_Str"");
  String fileName=""String_Node_Str"";
  SimpleImageSequence<ImageFloat32> video=DefaultMediaManager.INSTANCE.openVideo(fileName,ImageType.single(ImageFloat32.class));
  CalibrationFiducialDetector<ImageFloat32> detector=FactoryFiducial.calibChessboard(new ConfigChessboard(5,4,0.03),ImageFloat32.class);
  detector.setIntrinsic(intrinsic);
  List<Point2D_F64> calibPts=detector.getCalibrationPoints();
  JPanel gui=new JPanel();
  PointCloudViewer viewer=new PointCloudViewer(intrinsic,0.01);
  DenseMatrix64F rotY=RotationMatrixGenerator.rotY(-Math.PI / 2.0,null);
  viewer.setWorldToCamera(new Se3_F64(rotY,new Vector3D_F64(0.75,0,1.25)));
  ImagePanel imagePanel=new ImagePanel(intrinsic.width,intrinsic.height);
  gui.add(BorderLayout.WEST,imagePanel);
  gui.add(BorderLayout.CENTER,viewer);
  ShowImages.showWindow(gui,""String_Node_Str"",true);
  MousePauseHelper pauseHelper=new MousePauseHelper(gui);
  List<Point3D_F64> path=new ArrayList<Point3D_F64>();
  Se3_F64 targetToCamera=new Se3_F64();
  while (video.hasNext()) {
    detector.detect(video.next());
    if (detector.totalFound() == 0)     throw new RuntimeException(""String_Node_Str"");
    detector.getFiducialToCamera(0,targetToCamera);
    viewer.reset();
    Point3D_F64 center=new Point3D_F64();
    SePointOps_F64.transform(targetToCamera,center,center);
    path.add(center);
    for (    Point3D_F64 p : path) {
      viewer.addPoint(p.x,p.y,p.z,0x00FF00);
    }
    for (int j=0; j < calibPts.size(); j++) {
      Point2D_F64 p=calibPts.get(j);
      Point3D_F64 p3=new Point3D_F64(p.x,p.y,0);
      SePointOps_F64.transform(targetToCamera,p3,p3);
      viewer.addPoint(p3.x,p3.y,p3.z,0);
    }
    imagePanel.setBufferedImage((BufferedImage)video.getGuiImage());
    viewer.repaint();
    imagePanel.repaint();
    BoofMiscOps.pause(30);
    while (pauseHelper.isPaused()) {
      BoofMiscOps.pause(30);
    }
  }
}","public static void main(String args[]){
  IntrinsicParameters intrinsic=UtilIO.loadXML(""String_Node_Str"");
  String fileName=""String_Node_Str"";
  SimpleImageSequence<ImageFloat32> video=DefaultMediaManager.INSTANCE.openVideo(fileName,ImageType.single(ImageFloat32.class));
  CalibrationFiducialDetector<ImageFloat32> detector=FactoryFiducial.calibChessboard(new ConfigChessboard(5,4,0.03),ImageFloat32.class);
  detector.setIntrinsic(intrinsic);
  List<Point2D_F64> calibPts=detector.getCalibrationPoints();
  JPanel gui=new JPanel();
  PointCloudViewer viewer=new PointCloudViewer(intrinsic,0.01);
  DenseMatrix64F rotY=RotationMatrixGenerator.rotY(-Math.PI / 2.0,null);
  viewer.setWorldToCamera(new Se3_F64(rotY,new Vector3D_F64(0.75,0,1.25)));
  ImagePanel imagePanel=new ImagePanel(intrinsic.width,intrinsic.height);
  gui.add(BorderLayout.WEST,imagePanel);
  gui.add(BorderLayout.CENTER,viewer);
  ShowImages.showWindow(gui,""String_Node_Str"",true);
  MousePauseHelper pauseHelper=new MousePauseHelper(gui);
  List<Point3D_F64> path=new ArrayList<Point3D_F64>();
  Se3_F64 targetToCamera=new Se3_F64();
  while (video.hasNext()) {
    detector.detect(video.next());
    if (detector.totalFound() == 0)     continue;
    detector.getFiducialToCamera(0,targetToCamera);
    viewer.reset();
    Point3D_F64 center=new Point3D_F64();
    SePointOps_F64.transform(targetToCamera,center,center);
    path.add(center);
    for (    Point3D_F64 p : path) {
      viewer.addPoint(p.x,p.y,p.z,0x00FF00);
    }
    for (int j=0; j < calibPts.size(); j++) {
      Point2D_F64 p=calibPts.get(j);
      Point3D_F64 p3=new Point3D_F64(p.x,p.y,0);
      SePointOps_F64.transform(targetToCamera,p3,p3);
      viewer.addPoint(p3.x,p3.y,p3.z,0);
    }
    imagePanel.setBufferedImage((BufferedImage)video.getGuiImage());
    viewer.repaint();
    imagePanel.repaint();
    BoofMiscOps.pause(30);
    while (pauseHelper.isPaused()) {
      BoofMiscOps.pause(30);
    }
  }
}",0.986599241466498
150916,"/** 
 * Renders and displays the stitched together images
 */
public static void renderStitching(BufferedImage imageA,BufferedImage imageB,Homography2D_F64 fromAtoB){
  double scale=0.5;
  MultiSpectral<ImageFloat32> colorA=ConvertBufferedImage.convertFromMulti(imageA,null,true,ImageFloat32.class);
  MultiSpectral<ImageFloat32> colorB=ConvertBufferedImage.convertFromMulti(imageB,null,true,ImageFloat32.class);
  MultiSpectral<ImageFloat32> work=colorA.createSameShape();
  Homography2D_F64 fromAToWork=new Homography2D_F64(scale,0,colorA.width / 4,0,scale,colorA.height / 4,0,0,1);
  Homography2D_F64 fromWorkToA=fromAToWork.invert(null);
  PixelTransformHomography_F32 model=new PixelTransformHomography_F32();
  ImageDistort<MultiSpectral<ImageFloat32>,MultiSpectral<ImageFloat32>> distort=DistortSupport.createDistortMS(ImageFloat32.class,model,new ImplBilinearPixel_F32(),false);
  model.set(fromWorkToA);
  distort.apply(colorA,work);
  Homography2D_F64 fromWorkToB=fromWorkToA.concat(fromAtoB,null);
  model.set(fromWorkToB);
  distort.apply(colorB,work);
  BufferedImage output=new BufferedImage(work.width,work.height,imageA.getType());
  ConvertBufferedImage.convertTo(work,output,true);
  Graphics2D g2=output.createGraphics();
  Homography2D_F64 fromBtoWork=fromWorkToB.invert(null);
  Point2D_I32 corners[]=new Point2D_I32[4];
  corners[0]=renderPoint(0,0,fromBtoWork);
  corners[1]=renderPoint(colorB.width,0,fromBtoWork);
  corners[2]=renderPoint(colorB.width,colorB.height,fromBtoWork);
  corners[3]=renderPoint(0,colorB.height,fromBtoWork);
  g2.setColor(Color.ORANGE);
  g2.setStroke(new BasicStroke(4));
  g2.drawLine(corners[0].x,corners[0].y,corners[1].x,corners[1].y);
  g2.drawLine(corners[1].x,corners[1].y,corners[2].x,corners[2].y);
  g2.drawLine(corners[2].x,corners[2].y,corners[3].x,corners[3].y);
  g2.drawLine(corners[3].x,corners[3].y,corners[0].x,corners[0].y);
  ShowImages.showWindow(output,""String_Node_Str"");
}","/** 
 * Renders and displays the stitched together images
 */
public static void renderStitching(BufferedImage imageA,BufferedImage imageB,Homography2D_F64 fromAtoB){
  double scale=0.5;
  MultiSpectral<ImageFloat32> colorA=ConvertBufferedImage.convertFromMulti(imageA,null,true,ImageFloat32.class);
  MultiSpectral<ImageFloat32> colorB=ConvertBufferedImage.convertFromMulti(imageB,null,true,ImageFloat32.class);
  MultiSpectral<ImageFloat32> work=colorA.createSameShape();
  Homography2D_F64 fromAToWork=new Homography2D_F64(scale,0,colorA.width / 4,0,scale,colorA.height / 4,0,0,1);
  Homography2D_F64 fromWorkToA=fromAToWork.invert(null);
  PixelTransformHomography_F32 model=new PixelTransformHomography_F32();
  InterpolatePixelS<ImageFloat32> interp=FactoryInterpolation.bilinearPixelS(ImageFloat32.class,BorderType.VALUE);
  ImageDistort<MultiSpectral<ImageFloat32>,MultiSpectral<ImageFloat32>> distort=DistortSupport.createDistortMS(ImageFloat32.class,model,interp,false);
  distort.setRenderAll(false);
  model.set(fromWorkToA);
  distort.apply(colorA,work);
  Homography2D_F64 fromWorkToB=fromWorkToA.concat(fromAtoB,null);
  model.set(fromWorkToB);
  distort.apply(colorB,work);
  BufferedImage output=new BufferedImage(work.width,work.height,imageA.getType());
  ConvertBufferedImage.convertTo(work,output,true);
  Graphics2D g2=output.createGraphics();
  Homography2D_F64 fromBtoWork=fromWorkToB.invert(null);
  Point2D_I32 corners[]=new Point2D_I32[4];
  corners[0]=renderPoint(0,0,fromBtoWork);
  corners[1]=renderPoint(colorB.width,0,fromBtoWork);
  corners[2]=renderPoint(colorB.width,colorB.height,fromBtoWork);
  corners[3]=renderPoint(0,colorB.height,fromBtoWork);
  g2.setColor(Color.ORANGE);
  g2.setStroke(new BasicStroke(4));
  g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  g2.drawLine(corners[0].x,corners[0].y,corners[1].x,corners[1].y);
  g2.drawLine(corners[1].x,corners[1].y,corners[2].x,corners[2].y);
  g2.drawLine(corners[2].x,corners[2].y,corners[3].x,corners[3].y);
  g2.drawLine(corners[3].x,corners[3].y,corners[0].x,corners[0].y);
  ShowImages.showWindow(output,""String_Node_Str"",true);
}",0.9329771733851384
150917,"public static void main(String args[]){
  BufferedImage input=UtilImageIO.loadImage(""String_Node_Str"");
  MultiSpectral<ImageUInt8> imageRGB=ConvertBufferedImage.convertFromMulti(input,null,true,ImageUInt8.class);
  StereoParameters stereoParam=UtilIO.loadXML(""String_Node_Str"");
  Se3_F64 groundToLeft=UtilIO.loadXML(""String_Node_Str"");
  CreateSyntheticOverheadView<MultiSpectral<ImageUInt8>> generateOverhead=new CreateSyntheticOverheadViewMS<ImageUInt8>(TypeInterpolate.BILINEAR,3,ImageUInt8.class);
  double cellSize=0.05;
  SelectOverheadParameters selectMapSize=new SelectOverheadParameters(cellSize,20,0.5);
  selectMapSize.process(stereoParam.left,groundToLeft);
  int overheadWidth=selectMapSize.getOverheadWidth();
  int overheadHeight=selectMapSize.getOverheadHeight();
  MultiSpectral<ImageUInt8> overheadRGB=new MultiSpectral<ImageUInt8>(ImageUInt8.class,overheadWidth,overheadHeight,3);
  generateOverhead.configure(stereoParam.left,groundToLeft,selectMapSize.getCenterX(),selectMapSize.getCenterY(),cellSize,overheadRGB.width,overheadRGB.height);
  generateOverhead.process(imageRGB,overheadRGB);
  BufferedImage output=ConvertBufferedImage.convertTo(overheadRGB,null,true);
  ShowImages.showWindow(input,""String_Node_Str"");
  ShowImages.showWindow(output,""String_Node_Str"");
}","public static void main(String args[]){
  BufferedImage input=UtilImageIO.loadImage(""String_Node_Str"");
  MultiSpectral<ImageUInt8> imageRGB=ConvertBufferedImage.convertFromMulti(input,null,true,ImageUInt8.class);
  StereoParameters stereoParam=UtilIO.loadXML(""String_Node_Str"");
  Se3_F64 groundToLeft=UtilIO.loadXML(""String_Node_Str"");
  CreateSyntheticOverheadView<MultiSpectral<ImageUInt8>> generateOverhead=new CreateSyntheticOverheadViewMS<ImageUInt8>(TypeInterpolate.BILINEAR,3,ImageUInt8.class);
  double cellSize=0.05;
  SelectOverheadParameters selectMapSize=new SelectOverheadParameters(cellSize,20,0.5);
  selectMapSize.process(stereoParam.left,groundToLeft);
  int overheadWidth=selectMapSize.getOverheadWidth();
  int overheadHeight=selectMapSize.getOverheadHeight();
  MultiSpectral<ImageUInt8> overheadRGB=new MultiSpectral<ImageUInt8>(ImageUInt8.class,overheadWidth,overheadHeight,3);
  generateOverhead.configure(stereoParam.left,groundToLeft,selectMapSize.getCenterX(),selectMapSize.getCenterY(),cellSize,overheadRGB.width,overheadRGB.height);
  generateOverhead.process(imageRGB,overheadRGB);
  BufferedImage output=ConvertBufferedImage.convertTo(overheadRGB,null,true);
  ShowImages.showWindow(input,""String_Node_Str"",true);
  ShowImages.showWindow(output,""String_Node_Str"",true);
}",0.9961479198767336
150918,"public static void main(String[] args){
  BufferedImage buffered=UtilImageIO.loadImage(""String_Node_Str"");
  MultiSpectral<ImageFloat32> input=ConvertBufferedImage.convertFromMulti(buffered,null,true,ImageFloat32.class);
  MultiSpectral<ImageFloat32> output=input._createNew(400,500);
  Estimate1ofEpipolar computeHomography=FactoryMultiView.computeHomography(true);
  ArrayList<AssociatedPair> associatedPairs=new ArrayList<AssociatedPair>();
  associatedPairs.add(new AssociatedPair(new Point2D_F64(0,0),new Point2D_F64(267,182)));
  associatedPairs.add(new AssociatedPair(new Point2D_F64(output.width - 1,0),new Point2D_F64(542,68)));
  associatedPairs.add(new AssociatedPair(new Point2D_F64(output.width - 1,output.height - 1),new Point2D_F64(519,736)));
  associatedPairs.add(new AssociatedPair(new Point2D_F64(0,output.height - 1),new Point2D_F64(276,570)));
  DenseMatrix64F H=new DenseMatrix64F(3,3);
  computeHomography.process(associatedPairs,H);
  PointTransformHomography_F32 homography=new PointTransformHomography_F32(H);
  PixelTransform_F32 pixelTransform=new PointToPixelTransform_F32(homography);
  DistortImageOps.distortMS(input,output,pixelTransform,null,TypeInterpolate.BILINEAR);
  BufferedImage flat=ConvertBufferedImage.convertTo_F32(output,null,true);
  ShowImages.showWindow(buffered,""String_Node_Str"");
  ShowImages.showWindow(flat,""String_Node_Str"");
}","public static void main(String[] args){
  BufferedImage buffered=UtilImageIO.loadImage(""String_Node_Str"");
  MultiSpectral<ImageFloat32> input=ConvertBufferedImage.convertFromMulti(buffered,null,true,ImageFloat32.class);
  MultiSpectral<ImageFloat32> output=input._createNew(400,500);
  Estimate1ofEpipolar computeHomography=FactoryMultiView.computeHomography(true);
  ArrayList<AssociatedPair> associatedPairs=new ArrayList<AssociatedPair>();
  associatedPairs.add(new AssociatedPair(new Point2D_F64(0,0),new Point2D_F64(267,182)));
  associatedPairs.add(new AssociatedPair(new Point2D_F64(output.width - 1,0),new Point2D_F64(542,68)));
  associatedPairs.add(new AssociatedPair(new Point2D_F64(output.width - 1,output.height - 1),new Point2D_F64(519,736)));
  associatedPairs.add(new AssociatedPair(new Point2D_F64(0,output.height - 1),new Point2D_F64(276,570)));
  DenseMatrix64F H=new DenseMatrix64F(3,3);
  computeHomography.process(associatedPairs,H);
  PointTransformHomography_F32 homography=new PointTransformHomography_F32(H);
  PixelTransform_F32 pixelTransform=new PointToPixelTransform_F32(homography);
  DistortImageOps.distortMS(input,output,pixelTransform,null,TypeInterpolate.BILINEAR);
  BufferedImage flat=ConvertBufferedImage.convertTo_F32(output,null,true);
  ShowImages.showWindow(buffered,""String_Node_Str"",true);
  ShowImages.showWindow(flat,""String_Node_Str"",true);
}",0.9963924963924964
150919,"@Override public <T extends ImageBase>SimpleImageSequence<T> load(String fileName,ImageType<T> imageType){
  if (xuggler != null) {
    return xuggler.load(fileName,imageType);
  }
 else   if (jcodec != null) {
    if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
      return jcodec.load(fileName,imageType);
    }
  }
  if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")) {
    try {
      VideoMjpegCodec codec=new VideoMjpegCodec();
      List<byte[]> data=codec.read(new FileInputStream(fileName));
      return new JpegByteImageSequence<T>(imageType,data,false);
    }
 catch (    FileNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
    try {
      return new ImageStreamSequence<T>(fileName,true,imageType);
    }
 catch (    FileNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","@Override public <T extends ImageBase>SimpleImageSequence<T> load(String fileName,ImageType<T> imageType){
  try {
    if (xuggler != null) {
      return xuggler.load(fileName,imageType);
    }
  }
 catch (  RuntimeException ignore) {
  }
  try {
    if (jcodec != null) {
      if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
        return jcodec.load(fileName,imageType);
      }
    }
  }
 catch (  RuntimeException ignore) {
  }
  if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")|| fileName.endsWith(""String_Node_Str"")) {
    try {
      VideoMjpegCodec codec=new VideoMjpegCodec();
      List<byte[]> data=codec.read(new FileInputStream(fileName));
      return new JpegByteImageSequence<T>(imageType,data,false);
    }
 catch (    FileNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
 else   if (fileName.endsWith(""String_Node_Str"") || fileName.endsWith(""String_Node_Str"")) {
    try {
      return new ImageStreamSequence<T>(fileName,true,imageType);
    }
 catch (    FileNotFoundException e) {
      throw new RuntimeException(e);
    }
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}",0.9441151566469094
150920,"/** 
 * Finds blobs in the binary image.  Then looks for blobs that meet size and shape requirements.  See code below for the requirements.  Those that remain are considered to be target candidates.
 */
private void findCandidateShapes(T gray,ImageUInt8 binary){
  contourFinder.process(binary,labeled);
  FastQueue<Contour> blobs=contourFinder.getContours();
  for (int i=0; i < blobs.size; i++) {
    Contour c=blobs.get(i);
    if (c.external.size() >= minimumContour) {
      if (touchesBorder(c.external))       continue;
      if (toUndistorted != null) {
        removeDistortionFromContour(c.external);
      }
      double splitTolerance=splitDistanceFraction * c.external.size();
      fitPolygon.setToleranceSplit(splitTolerance);
      fitPolygon.process(c.external);
      GrowQueue_I32 splits=fitPolygon.getSplits();
      if (!expectedNumberOfSides(splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + splits.size());
        continue;
      }
      if (!improveContour.fit(c.external,splits)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      workPoly.vertexes.resize(splits.size());
      for (int j=0; j < splits.size(); j++) {
        Point2D_I32 p=c.external.get(splits.get(j));
        workPoly.get(j).set(p.x,p.y);
      }
      boolean workOrigCCW=workPoly.isCCW();
      if (workOrigCCW) {
        workPoly.flip();
      }
      if (!UtilPolygons2D_F64.isConvex(workPoly)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      double area=Area2D_F64.polygonConvex(workPoly);
      if (area < minimumArea) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      Polygon2D_F64 refined=found.grow();
      refined.vertexes.resize(splits.size);
      boolean success;
      if (refineCorner != null) {
        refineCorner.setImage(gray);
        success=refineCorner.refine(c.external,splits,refined) >= 3;
        if (workOrigCCW) {
          refined.flip();
        }
      }
 else       if (refineLine != null) {
        refineLine.setImage(gray);
        success=refineLine.refine(workPoly,refined);
      }
 else {
        refined.set(workPoly);
        success=true;
      }
      if (!outputClockwise)       refined.flip();
      if (success) {
        c.id=found.size();
        foundContours.add(c);
      }
 else {
        found.removeTail();
        if (verbose)         System.out.println(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Finds blobs in the binary image.  Then looks for blobs that meet size and shape requirements.  See code below for the requirements.  Those that remain are considered to be target candidates.
 */
private void findCandidateShapes(T gray,ImageUInt8 binary){
  contourFinder.process(binary,labeled);
  FastQueue<Contour> blobs=contourFinder.getContours();
  for (int i=0; i < blobs.size; i++) {
    Contour c=blobs.get(i);
    if (c.external.size() >= minimumContour) {
      if (touchesBorder(c.external))       continue;
      if (toUndistorted != null) {
        removeDistortionFromContour(c.external);
      }
      double splitTolerance=splitDistanceFraction * c.external.size();
      fitPolygon.setToleranceSplit(splitTolerance);
      fitPolygon.process(c.external);
      GrowQueue_I32 splits=fitPolygon.getSplits();
      if (!expectedNumberOfSides(splits)) {
        if (verbose)         System.out.println(""String_Node_Str"" + splits.size());
        continue;
      }
      if (!improveContour.fit(c.external,splits)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      workPoly.vertexes.resize(splits.size());
      for (int j=0; j < splits.size(); j++) {
        Point2D_I32 p=c.external.get(splits.get(j));
        workPoly.get(j).set(p.x,p.y);
      }
      if (!UtilPolygons2D_F64.isConvex(workPoly)) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      double area=Area2D_F64.polygonConvex(workPoly);
      if (area < minimumArea) {
        if (verbose)         System.out.println(""String_Node_Str"");
        continue;
      }
      boolean workOrigCCW=workPoly.isCCW();
      if (workOrigCCW) {
        workPoly.flip();
        if (workPoly.isCCW()) {
          throw new RuntimeException(""String_Node_Str"");
        }
      }
      Polygon2D_F64 refined=found.grow();
      refined.vertexes.resize(splits.size);
      boolean success;
      if (refineCorner != null) {
        refineCorner.setImage(gray);
        success=refineCorner.refine(c.external,splits,refined) >= 3;
        if (workOrigCCW) {
          refined.flip();
        }
      }
 else       if (refineLine != null) {
        refineLine.setImage(gray);
        success=refineLine.refine(workPoly,refined);
      }
 else {
        refined.set(workPoly);
        success=true;
      }
      if (!outputClockwise)       refined.flip();
      if (success) {
        c.id=found.size();
        foundContours.add(c);
      }
 else {
        found.removeTail();
        if (verbose)         System.out.println(""String_Node_Str"");
      }
    }
  }
}",0.9413359148112296
150921,"@Override protected void updateBackground(int x0,int y0,int x1,int y1,T frame){
  transform.setModel(worldToCurrent);
  interpolationInput.setImage(frame);
  final int numBands=frame.getNumBands();
  float minusLearn=1.0f - learnRate;
  for (int y=y0; y < y1; y++) {
    int indexBG=background.startIndex + y * background.stride + x0 * numBands;
    for (int x=x0; x < x1; x++) {
      transform.compute(x,y,work);
      if (work.x >= 0 && work.x < frame.width && work.y >= 0 && work.y < frame.height) {
        interpolationInput.get(work.x,work.y,pixelInput);
        for (int band=0; band < numBands; band++, indexBG++) {
          float value=pixelInput[band];
          float bg=background.data[indexBG];
          if (bg == Float.MAX_VALUE) {
            background.data[indexBG]=value;
          }
 else {
            background.data[indexBG]=minusLearn * bg + learnRate * value;
          }
        }
      }
    }
  }
}","@Override protected void updateBackground(int x0,int y0,int x1,int y1,T frame){
  transform.setModel(worldToCurrent);
  interpolationInput.setImage(frame);
  final int numBands=frame.getNumBands();
  float minusLearn=1.0f - learnRate;
  for (int y=y0; y < y1; y++) {
    int indexBG=background.startIndex + y * background.stride + x0 * numBands;
    for (int x=x0; x < x1; x++) {
      transform.compute(x,y,work);
      if (work.x >= 0 && work.x < frame.width && work.y >= 0 && work.y < frame.height) {
        interpolationInput.get(work.x,work.y,pixelInput);
        for (int band=0; band < numBands; band++, indexBG++) {
          float value=pixelInput[band];
          float bg=background.data[indexBG];
          if (bg == Float.MAX_VALUE) {
            background.data[indexBG]=value;
          }
 else {
            background.data[indexBG]=minusLearn * bg + learnRate * value;
          }
        }
      }
 else {
        indexBG+=numBands;
      }
    }
  }
}",0.9773565034228542
150922,"private <T extends ImageBase>void currentOutsideBackground(ImageType<T> imageType){
  T frame=imageType.createImage(width,height);
  ImageUInt8 segmented=new ImageUInt8(width,height);
  BackgroundModelMoving<T,Homography2D_F32> alg=create(frame.getImageType());
  Homography2D_F32 homeToWorld=new Homography2D_F32();
  alg.initialize(width,height,homeToWorld);
  Homography2D_F32 homeToCurrent=new Homography2D_F32();
  homeToCurrent.a13=5;
  alg.updateBackground(homeToCurrent,frame);
  alg.segment(homeToCurrent,frame,segmented);
  homeToCurrent.a13=-5;
  alg.updateBackground(homeToCurrent,frame);
  alg.segment(homeToCurrent,frame,segmented);
  homeToCurrent.a13=0;
  homeToCurrent.a23=5;
  alg.updateBackground(homeToCurrent,frame);
  alg.segment(homeToCurrent,frame,segmented);
  homeToCurrent.a23=-5;
  alg.updateBackground(homeToCurrent,frame);
  alg.segment(homeToCurrent,frame,segmented);
}","private <T extends ImageBase>void currentOutsideBackground(ImageType<T> imageType){
  T frame=imageType.createImage(width,height);
  ImageUInt8 segmented=new ImageUInt8(width,height);
  BackgroundModelMoving<T,Homography2D_F32> alg=create(frame.getImageType());
  Homography2D_F32 homeToWorld=new Homography2D_F32();
  alg.initialize(width,height,homeToWorld);
  alg.setUnknownValue(2);
  double translationTol=backgroundOutsideTol / 2;
  Homography2D_F32 homeToCurrent=new Homography2D_F32();
  homeToCurrent.a13=5;
  checkTransform(frame,segmented,alg,homeToCurrent,translationTol);
  homeToCurrent.a13=-5;
  checkTransform(frame,segmented,alg,homeToCurrent,translationTol);
  homeToCurrent.a13=0;
  homeToCurrent.a23=5;
  checkTransform(frame,segmented,alg,homeToCurrent,translationTol);
  homeToCurrent.a23=-5;
  checkTransform(frame,segmented,alg,homeToCurrent,translationTol);
  homeToCurrent.set(1.5f,0.1f,4,-0.05f,0.9f,-1f,0,0,1);
  checkTransform(frame,segmented,alg,homeToCurrent,backgroundOutsideTol);
}",0.5893416927899686
150923,"public static void convertFromInterleaved(BufferedImage src,ImageInterleaved dst,boolean orderRgb){
  if (src == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (src.getWidth() != dst.getWidth() || src.getHeight() != dst.getHeight()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    WritableRaster raster=src.getRaster();
    int numBands;
    if (src.getType() == BufferedImage.TYPE_BYTE_INDEXED)     numBands=3;
 else     numBands=raster.getNumBands();
    if (dst.getNumBands() != numBands)     throw new IllegalArgumentException(""String_Node_Str"" + numBands + ""String_Node_Str""+ dst.getNumBands());
    if (dst instanceof InterleavedU8) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          ConvertRaster.bufferedToGray(src,(InterleavedU8)dst);
        }
 else {
          ConvertRaster.bufferedToInterleaved((ByteInterleavedRaster)src.getRaster(),(InterleavedU8)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToInterleaved((IntegerInterleavedRaster)src.getRaster(),(InterleavedU8)dst);
      }
 else {
        ConvertRaster.bufferedToInterleaved(src,(InterleavedU8)dst);
      }
    }
 else     if (dst instanceof InterleavedF32) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          ConvertRaster.bufferedToGray(src,(InterleavedF32)dst);
        }
 else {
          ConvertRaster.bufferedToInterleaved((ByteInterleavedRaster)src.getRaster(),(InterleavedF32)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToInterleaved((IntegerInterleavedRaster)src.getRaster(),(InterleavedF32)dst);
      }
 else {
        ConvertRaster.bufferedToInterleaved(src,(InterleavedF32)dst);
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 catch (  java.security.AccessControlException e) {
    if (dst instanceof InterleavedU8) {
      ConvertRaster.bufferedToInterleaved(src,(InterleavedU8)dst);
    }
 else     if (dst instanceof InterleavedF32) {
      ConvertRaster.bufferedToInterleaved(src,(InterleavedF32)dst);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (orderRgb) {
    orderBandsIntoRGB(dst,src);
  }
}","public static void convertFromInterleaved(BufferedImage src,ImageInterleaved dst,boolean orderRgb){
  if (src == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (src.getWidth() != dst.getWidth() || src.getHeight() != dst.getHeight()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    WritableRaster raster=src.getRaster();
    int numBands;
    if (src.getType() == BufferedImage.TYPE_BYTE_INDEXED)     numBands=3;
 else     numBands=raster.getNumBands();
    if (dst.getNumBands() != numBands)     throw new IllegalArgumentException(""String_Node_Str"" + numBands + ""String_Node_Str""+ dst.getNumBands());
    if (dst instanceof InterleavedU8) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          ConvertRaster.bufferedToGray(src,(InterleavedU8)dst);
        }
 else {
          ConvertRaster.bufferedToInterleaved((ByteInterleavedRaster)src.getRaster(),(InterleavedU8)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToInterleaved((IntegerInterleavedRaster)src.getRaster(),(InterleavedU8)dst);
      }
 else       if (src.getRaster() instanceof SunWritableRaster) {
        ConvertRaster.bufferedToInterleaved((SunWritableRaster)src.getRaster(),(InterleavedU8)dst);
      }
 else {
        ConvertRaster.bufferedToInterleaved(src,(InterleavedU8)dst);
      }
    }
 else     if (dst instanceof InterleavedF32) {
      if (src.getRaster() instanceof ByteInterleavedRaster && src.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
        if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {
          ConvertRaster.bufferedToGray(src,(InterleavedF32)dst);
        }
 else {
          ConvertRaster.bufferedToInterleaved((ByteInterleavedRaster)src.getRaster(),(InterleavedF32)dst);
        }
      }
 else       if (src.getRaster() instanceof IntegerInterleavedRaster) {
        ConvertRaster.bufferedToInterleaved((IntegerInterleavedRaster)src.getRaster(),(InterleavedF32)dst);
      }
 else       if (src.getRaster() instanceof SunWritableRaster) {
        ConvertRaster.bufferedToInterleaved((SunWritableRaster)src.getRaster(),(InterleavedF32)dst);
      }
 else {
        ConvertRaster.bufferedToInterleaved(src,(InterleavedF32)dst);
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 catch (  java.security.AccessControlException e) {
    if (dst instanceof InterleavedU8) {
      ConvertRaster.bufferedToInterleaved(src,(InterleavedU8)dst);
    }
 else     if (dst instanceof InterleavedF32) {
      ConvertRaster.bufferedToInterleaved(src,(InterleavedF32)dst);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (orderRgb) {
    orderBandsIntoRGB(dst,src);
  }
}",0.853636197105697
150924,"private static void from_NBU8_to_IF32(InterleavedF32 dst,byte[] srcData,int srcOffset,int srcStrideDiff){
  int length=dst.width * dst.numBands;
  for (int y=0; y < dst.height; y++) {
    int indexDst=dst.startIndex + dst.stride * y;
    int indexSrc=srcOffset + y * (dst.stride + srcStrideDiff);
    int indexDstEnd=indexDst + length;
    while (indexDst < indexDstEnd) {
      dst.data[indexDst]=srcData[indexSrc] & 0xFF;
      indexDst++;
      indexSrc++;
    }
  }
}","private static void from_NBU8_to_IF32(InterleavedF32 dst,byte[] srcData,int srcOffset,int srcStrideDiff){
  int length=dst.width * dst.numBands;
  for (int y=0; y < dst.height; y++) {
    int indexDst=dst.startIndex + dst.stride * y;
    int indexSrc=srcOffset + y * (length + srcStrideDiff);
    int indexDstEnd=indexDst + length;
    while (indexDst < indexDstEnd) {
      dst.data[indexDst]=srcData[indexSrc] & 0xFF;
      indexDst++;
      indexSrc++;
    }
  }
}",0.9829424307036247
150925,"private static void from_NBU8_to_IU8(InterleavedU8 dst,byte[] srcData,int srcOffset,int srcStrideDiff){
  int length=dst.width * dst.numBands;
  for (int y=0; y < dst.height; y++) {
    int indexDst=dst.startIndex + dst.stride * y;
    int indexSrc=srcOffset + y * (dst.stride + srcStrideDiff);
    System.arraycopy(srcData,indexSrc,dst.data,indexDst,length);
  }
}","private static void from_NBU8_to_IU8(InterleavedU8 dst,byte[] srcData,int srcOffset,int srcStrideDiff){
  int length=dst.width * dst.numBands;
  for (int y=0; y < dst.height; y++) {
    int indexDst=dst.startIndex + dst.stride * y;
    int indexSrc=srcOffset + y * (length + srcStrideDiff);
    System.arraycopy(srcData,indexSrc,dst.data,indexDst,length);
  }
}",0.977961432506887
150926,"/** 
 * Use reflections to test all the functions.
 */
@Test public void performTests(){
  Method methods[]=ConvertRaster.class.getMethods();
  int numFound=0;
  for (  Method m : methods) {
    if (!isTestMethod(m))     continue;
    System.out.println(""String_Node_Str"" + m.getName());
    if (m.getName().contains(""String_Node_Str""))     testBufferedTo(m);
 else     if (m.getName().contains(""String_Node_Str""))     testImageTo(m);
 else     throw new RuntimeException(""String_Node_Str"");
    numFound++;
  }
  if (numMethods != numFound)   throw new RuntimeException(""String_Node_Str"" + numFound + ""String_Node_Str""+ numMethods);
}","/** 
 * Use reflections to test all the functions.
 */
@Test public void performTests(){
  Method methods[]=ConvertRaster.class.getMethods();
  int numFound=0;
  for (  Method m : methods) {
    if (!isTestMethod(m))     continue;
    if (m.getName().contains(""String_Node_Str""))     testBufferedTo(m);
 else     if (m.getName().contains(""String_Node_Str""))     testImageTo(m);
 else     throw new RuntimeException(""String_Node_Str"");
    numFound++;
  }
  if (numMethods != numFound)   throw new RuntimeException(""String_Node_Str"" + numFound + ""String_Node_Str""+ numMethods);
}",0.9530090684253916
150927,"private ImageBase createImage(Method m,Class imageType,BufferedImage inputBuff){
  int numBands=inputBuff.getRaster().getNumBands();
  ImageBase output;
  if (ImageSingleBand.class.isAssignableFrom(imageType)) {
    output=GeneralizedImageOps.createSingleBand(imageType,inputBuff.getWidth(),inputBuff.getHeight());
  }
 else {
    Class type;
    if (m.getName().contains(""String_Node_Str"")) {
      type=ImageUInt8.class;
    }
 else     if (m.getName().contains(""String_Node_Str"")) {
      type=ImageFloat32.class;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + m.getName());
    }
    output=new MultiSpectral(type,inputBuff.getWidth(),inputBuff.getHeight(),numBands);
  }
  return output;
}","private ImageBase createImage(Method m,Class imageType,BufferedImage inputBuff){
  int numBands=inputBuff.getRaster().getNumBands();
  ImageBase output;
  if (ImageSingleBand.class.isAssignableFrom(imageType)) {
    output=GeneralizedImageOps.createSingleBand(imageType,inputBuff.getWidth(),inputBuff.getHeight());
  }
 else   if (ImageInterleaved.class.isAssignableFrom(imageType)) {
    if (m.getName().contains(""String_Node_Str"")) {
      output=GeneralizedImageOps.createInterleaved(imageType,inputBuff.getWidth(),inputBuff.getHeight(),1);
    }
 else {
      output=GeneralizedImageOps.createInterleaved(imageType,inputBuff.getWidth(),inputBuff.getHeight(),numBands);
    }
  }
 else {
    Class type;
    if (m.getName().contains(""String_Node_Str"")) {
      type=ImageUInt8.class;
    }
 else     if (m.getName().contains(""String_Node_Str"")) {
      type=ImageFloat32.class;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + m.getName());
    }
    output=new MultiSpectral(type,inputBuff.getWidth(),inputBuff.getHeight(),numBands);
  }
  return output;
}",0.7566371681415929
150928,"public void performBufferedTo(Method m,BufferedImage input,ImageBase output){
  try {
    if (Raster.class.isAssignableFrom(m.getParameterTypes()[0])) {
      m.invoke(null,input.getRaster(),output);
      if (ImageMultiBand.class.isAssignableFrom(output.getClass()))       BoofTesting.checkEquals(input.getRaster(),(MultiSpectral)output,1);
 else       BoofTesting.checkEquals(input,output,false,1f);
    }
 else {
      m.invoke(null,input,output);
      BoofTesting.checkEquals(input,output,false,1f);
    }
  }
 catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(e);
  }
}","public void performBufferedTo(Method m,BufferedImage input,ImageBase output){
  try {
    if (Raster.class.isAssignableFrom(m.getParameterTypes()[0])) {
      m.invoke(null,input.getRaster(),output);
      if (ImageMultiBand.class.isAssignableFrom(output.getClass()))       BoofTesting.checkEquals(input.getRaster(),(ImageMultiBand)output,1);
 else       BoofTesting.checkEquals(input,output,false,1f);
    }
 else {
      m.invoke(null,input,output);
      BoofTesting.checkEquals(input,output,false,1f);
    }
  }
 catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(e);
  }
}",0.9873605947955392
150929,"private void testBufferedTo(Method m){
  Class paramTypes[]=m.getParameterTypes();
  BufferedImage input[];
  input=createBufferedTestImages(paramTypes[0]);
  for (int i=0; i < input.length; i++) {
    ImageBase output=createImage(m,paramTypes[1],input[i]);
    BoofTesting.checkSubImage(this,""String_Node_Str"",true,m,input[i],output);
    BufferedImage subimage=input[i].getSubimage(1,2,imgWidth - 1,imgHeight - 2);
    output=createImage(m,paramTypes[1],subimage);
    BoofTesting.checkSubImage(this,""String_Node_Str"",true,m,subimage,output);
  }
}","private void testBufferedTo(Method m){
  Class paramTypes[]=m.getParameterTypes();
  BufferedImage input[];
  input=createBufferedTestImages(paramTypes[0]);
  boolean canSubImage=true;
  if (paramTypes[0] == SunWritableRaster.class) {
    canSubImage=false;
  }
  for (int i=0; i < input.length; i++) {
    ImageBase output=createImage(m,paramTypes[1],input[i]);
    BoofTesting.checkSubImage(this,""String_Node_Str"",true,m,input[i],output);
    if (canSubImage) {
      BufferedImage subimage=input[i].getSubimage(1,2,imgWidth - 1,imgHeight - 2);
      output=createImage(m,paramTypes[1],subimage);
      BoofTesting.checkSubImage(this,""String_Node_Str"",true,m,subimage,output);
    }
  }
}",0.8870967741935484
150930,"public static void checkEquals(BufferedImage imgA,ImageMultiBand imgB,boolean boofcvBandOrder,float tol){
  GImageMultiBand genericB=FactoryGImageMultiBand.wrap(imgB);
  float pixelB[]=new float[imgB.getNumBands()];
  if (imgA.getRaster() instanceof ByteInterleavedRaster && imgA.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
    ByteInterleavedRaster raster=(ByteInterleavedRaster)imgA.getRaster();
    if (raster.getNumBands() == 1) {
      int strideA=raster.getScanlineStride();
      int offsetA=raster.getDataOffset(0) - raster.getPixelStride() + 1;
      for (int i=0; i < imgA.getHeight(); i++) {
        for (int j=0; j < imgA.getWidth(); j++) {
          genericB.get(j,i,pixelB);
          double valB=pixelB[0];
          int valA=raster.getDataStorage()[offsetA + i * strideA + j];
          valA&=0xFF;
          if (Math.abs(valA - valB) > tol)           throw new RuntimeException(""String_Node_Str"" + valA + ""String_Node_Str""+ valB);
        }
      }
      return;
    }
  }
  int bandOrder[];
  if (boofcvBandOrder) {
    if (imgB.getNumBands() == 4) {
      bandOrder=new int[]{1,2,3,0};
    }
 else {
      bandOrder=new int[]{0,1,2};
    }
  }
 else {
    if (imgA.getType() == BufferedImage.TYPE_INT_RGB) {
      bandOrder=new int[]{0,1,2};
    }
 else     if (imgA.getType() == BufferedImage.TYPE_INT_BGR || imgA.getType() == BufferedImage.TYPE_3BYTE_BGR) {
      bandOrder=new int[]{2,1,0};
    }
 else     if (imgA.getType() == BufferedImage.TYPE_4BYTE_ABGR) {
      bandOrder=new int[]{0,3,2,1};
    }
 else     if (imgA.getType() == BufferedImage.TYPE_INT_ARGB) {
      bandOrder=new int[]{0,1,2,3};
    }
 else {
      bandOrder=new int[]{0,1,2};
    }
  }
  int expected[]=new int[4];
  for (int y=0; y < imgA.getHeight(); y++) {
    for (int x=0; x < imgA.getWidth(); x++) {
      int rgb=imgA.getRGB(x,y);
      expected[0]=((rgb >>> 24) & 0xFF);
      expected[1]=((rgb >>> 16) & 0xFF);
      expected[2]=((rgb >>> 8) & 0xFF);
      expected[3]=(rgb & 0xFF);
      if (imgB.getNumBands() == 4) {
        genericB.get(x,y,pixelB);
        for (int i=0; i < 4; i++) {
          double found=pixelB[bandOrder[i]];
          if (Math.abs(Math.exp(expected[i] - found)) > tol) {
            for (int j=0; j < 4; j++) {
              System.out.println(expected[j] + ""String_Node_Str"" + pixelB[bandOrder[j]]);
            }
            throw new RuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ imgA.getType());
          }
        }
      }
 else       if (imgB.getNumBands() == 3) {
        genericB.get(x,y,pixelB);
        for (int i=0; i < 3; i++) {
          double found=pixelB[bandOrder[i]];
          if (Math.abs(expected[i + 1] - found) > tol) {
            for (int j=0; j < 3; j++) {
              System.out.println(expected[j + 1] + ""String_Node_Str"" + pixelB[bandOrder[j]]);
            }
            throw new RuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ imgA.getType());
          }
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}","public static void checkEquals(BufferedImage imgA,ImageMultiBand imgB,boolean boofcvBandOrder,float tol){
  GImageMultiBand genericB=FactoryGImageMultiBand.wrap(imgB);
  float pixelB[]=new float[imgB.getNumBands()];
  if (imgA.getRaster() instanceof ByteInterleavedRaster && imgA.getType() != BufferedImage.TYPE_BYTE_INDEXED) {
    ByteInterleavedRaster raster=(ByteInterleavedRaster)imgA.getRaster();
    if (raster.getNumBands() == 1) {
      int strideA=raster.getScanlineStride();
      int offsetA=raster.getDataOffset(0) - raster.getPixelStride() + 1;
      for (int i=0; i < imgA.getHeight(); i++) {
        for (int j=0; j < imgA.getWidth(); j++) {
          genericB.get(j,i,pixelB);
          double valB=pixelB[0];
          int valA=raster.getDataStorage()[offsetA + i * strideA + j];
          valA&=0xFF;
          if (Math.abs(valA - valB) > tol)           throw new RuntimeException(""String_Node_Str"" + valA + ""String_Node_Str""+ valB);
        }
      }
      return;
    }
  }
  int bandOrder[];
  if (boofcvBandOrder) {
    if (imgB.getNumBands() == 4) {
      bandOrder=new int[]{1,2,3,0};
    }
 else {
      bandOrder=new int[]{0,1,2};
    }
  }
 else {
    if (imgA.getType() == BufferedImage.TYPE_INT_RGB) {
      bandOrder=new int[]{0,1,2};
    }
 else     if (imgA.getType() == BufferedImage.TYPE_INT_BGR || imgA.getType() == BufferedImage.TYPE_3BYTE_BGR) {
      bandOrder=new int[]{2,1,0};
    }
 else     if (imgA.getType() == BufferedImage.TYPE_4BYTE_ABGR) {
      bandOrder=new int[]{0,3,2,1};
    }
 else     if (imgA.getType() == BufferedImage.TYPE_INT_ARGB) {
      bandOrder=new int[]{0,1,2,3};
    }
 else {
      bandOrder=new int[]{0,1,2};
    }
  }
  int expected[]=new int[4];
  for (int y=0; y < imgA.getHeight(); y++) {
    for (int x=0; x < imgA.getWidth(); x++) {
      int rgb=imgA.getRGB(x,y);
      expected[0]=((rgb >>> 24) & 0xFF);
      expected[1]=((rgb >>> 16) & 0xFF);
      expected[2]=((rgb >>> 8) & 0xFF);
      expected[3]=(rgb & 0xFF);
      if (imgB.getNumBands() == 4) {
        genericB.get(x,y,pixelB);
        for (int i=0; i < 4; i++) {
          double found=pixelB[bandOrder[i]];
          if (Math.abs(Math.exp(expected[i] - found)) > tol) {
            for (int j=0; j < 4; j++) {
              System.out.println(expected[j] + ""String_Node_Str"" + pixelB[bandOrder[j]]);
            }
            throw new RuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ imgA.getType());
          }
        }
      }
 else       if (imgB.getNumBands() == 3) {
        genericB.get(x,y,pixelB);
        for (int i=0; i < 3; i++) {
          double found=pixelB[bandOrder[i]];
          if (Math.abs(expected[i + 1] - found) > tol) {
            for (int j=0; j < 3; j++) {
              System.out.println(expected[j + 1] + ""String_Node_Str"" + pixelB[bandOrder[j]]);
            }
            throw new RuntimeException(""String_Node_Str"" + i + ""String_Node_Str""+ imgA.getType());
          }
        }
      }
 else       if (imgB.getNumBands() == 1) {
        genericB.get(x,y,pixelB);
        double expectedGray=(expected[1] + expected[2] + expected[3]) / 3.0;
        if (Math.abs(expectedGray - pixelB[0]) > tol) {
          throw new RuntimeException(""String_Node_Str"" + imgA.getType() + ""String_Node_Str"");
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
}",0.949004975124378
150931,"/** 
 * Change the image being displayed.
 * @param image The new image which will be displayed.
 */
public void setBufferedImage(BufferedImage image){
  this.img=image;
  Dimension prev=getPreferredSize();
  int w=0, h=0;
  if (img != null) {
    w=(int)Math.ceil(img.getWidth() * scale);
    h=(int)Math.ceil(img.getHeight() * scale);
  }
  if (prev.getWidth() != w || prev.getHeight() != h) {
    panel.setPreferredSize(new Dimension(w,h));
    getViewport().setView(panel);
  }
}","/** 
 * Change the image being displayed.
 * @param image The new image which will be displayed.
 */
public synchronized void setBufferedImage(BufferedImage image){
  this.img=image;
  Dimension prev=getPreferredSize();
  int w=0, h=0;
  if (img != null) {
    w=(int)Math.ceil(img.getWidth() * scale);
    h=(int)Math.ceil(img.getHeight() * scale);
  }
  if (prev.getWidth() != w || prev.getHeight() != h) {
    panel.setPreferredSize(new Dimension(w,h));
    getViewport().setView(panel);
  }
}",0.9867211440245148
150932,"public void setScale(double scale){
  Rectangle r=panel.getVisibleRect();
  double centerX=(r.x + r.width / 2.0) / this.scale;
  double centerY=(r.y + r.height / 2.0) / this.scale;
  this.scale=scale;
  int w=0, h=0;
  if (img != null) {
    w=(int)Math.ceil(img.getWidth() * scale);
    h=(int)Math.ceil(img.getHeight() * scale);
  }
  panel.setPreferredSize(new Dimension(w,h));
  getViewport().setView(panel);
  centerView(centerX,centerY);
}","public synchronized void setScale(double scale){
  Rectangle r=panel.getVisibleRect();
  double centerX=(r.x + r.width / 2.0) / this.scale;
  double centerY=(r.y + r.height / 2.0) / this.scale;
  this.scale=scale;
  int w=0, h=0;
  if (img != null) {
    w=(int)Math.ceil(img.getWidth() * scale);
    h=(int)Math.ceil(img.getHeight() * scale);
  }
  panel.setPreferredSize(new Dimension(w,h));
  getViewport().setView(panel);
  centerView(centerX,centerY);
}",0.9856035437430788
150933,"@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  if (img == null)   return;
  Graphics2D g2=(Graphics2D)g;
  AffineTransform tran=AffineTransform.getScaleInstance(scale,scale);
  g2.drawImage(img,tran,null);
  paintInPanel(tran,g2);
}","@Override public void paintComponent(Graphics g){
  super.paintComponent(g);
  if (img == null)   return;
  Graphics2D g2=(Graphics2D)g;
synchronized (ImageZoomPanel.this) {
    AffineTransform tran=AffineTransform.getScaleInstance(scale,scale);
    g2.drawImage(img,tran,null);
    paintInPanel(tran,g2);
  }
}",0.9182608695652174
150934,"public void centerView(double cx,double cy){
  Rectangle r=panel.getVisibleRect();
  int x=(int)(cx * scale - r.width / 2);
  int y=(int)(cy * scale - r.height / 2);
  getHorizontalScrollBar().setValue(x);
  getVerticalScrollBar().setValue(y);
}","public synchronized void centerView(double cx,double cy){
  Rectangle r=panel.getVisibleRect();
  int x=(int)(cx * scale - r.width / 2);
  int y=(int)(cy * scale - r.height / 2);
  getHorizontalScrollBar().setValue(x);
  getVerticalScrollBar().setValue(y);
}",0.974155069582505
150935,"@Override public void changeInput(String name,int index){
  stopWorker();
  processedInputImage=false;
  String videoName=inputRefs.get(index).getPath();
  String path=videoName.substring(0,videoName.lastIndexOf('/'));
  if (name.compareTo(SQUARE_NUMBER) == 0) {
    detector=FactoryFiducial.squareBinaryFast(new ConfigFiducialBinary(0.1),100,imageClass);
  }
 else   if (name.compareTo(SQUARE_PICTURE) == 0) {
    double length=0.1;
    detector=FactoryFiducial.squareImageFast(new ConfigFiducialImage(),100,imageClass);
    SquareImage_to_FiducialDetector<I> d=(SquareImage_to_FiducialDetector<I>)detector;
    String pathImg=new File(path,""String_Node_Str"").getPath();
    List<String> names=new ArrayList<String>();
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    for (    String foo : names) {
      BufferedImage img=media.openImage(new File(pathImg,foo).getPath());
      if (img == null)       throw new RuntimeException(""String_Node_Str"" + new File(pathImg,foo).getPath());
      d.addPatternImage(ConvertBufferedImage.convertFromSingle(img,null,imageClass),125,length);
    }
  }
 else   if (name.compareTo(CALIB_CHESS) == 0) {
    detector=FactoryFiducial.calibChessboard(new ConfigChessboard(5,7,0.03),imageClass);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  intrinsic=UtilIO.loadXML(media.openFile(path + ""String_Node_Str""));
  detector.setIntrinsic(intrinsic);
  SimpleImageSequence<MultiSpectral<I>> video=media.openVideo(videoName,ImageType.ms(3,imageClass));
  process(video);
}","@Override public void changeInput(String name,int index){
  stopWorker();
  processedInputImage=false;
  String videoName=inputRefs.get(index).getPath();
  String path=videoName.substring(0,videoName.lastIndexOf('/'));
  if (name.compareTo(SQUARE_NUMBER) == 0) {
    detector=FactoryFiducial.squareBinaryFast(new ConfigFiducialBinary(0.1),100,imageClass);
  }
 else   if (name.compareTo(SQUARE_PICTURE) == 0) {
    double length=0.1;
    detector=FactoryFiducial.squareImageFast(new ConfigFiducialImage(),100,imageClass);
    SquareImage_to_FiducialDetector<I> d=(SquareImage_to_FiducialDetector<I>)detector;
    String pathImg=new File(path,""String_Node_Str"").getPath();
    List<String> names=new ArrayList<String>();
    names.add(""String_Node_Str"");
    names.add(""String_Node_Str"");
    for (    String foo : names) {
      BufferedImage img=media.openImage(new File(pathImg,foo).getPath());
      if (img == null)       throw new RuntimeException(""String_Node_Str"" + new File(pathImg,foo).getPath());
      d.addPatternImage(ConvertBufferedImage.convertFromSingle(img,null,imageClass),125,length);
    }
  }
 else   if (name.compareTo(CALIB_CHESS) == 0) {
    detector=FactoryFiducial.calibChessboard(new ConfigChessboard(5,7,0.03),imageClass);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  intrinsic=UtilIO.loadXML(media.openFile(path + ""String_Node_Str""));
  detector.setIntrinsic(intrinsic);
  SimpleImageSequence<MultiSpectral<I>> video=media.openVideo(videoName,ImageType.ms(3,imageClass));
  process(video);
}",0.9008168028004668
150936,"@Override protected void updateAlg(MultiSpectral<I> frame,BufferedImage buffImage){
  undistorter.apply(frame,undistorted);
  GConvertImage.average(undistorted,gray);
  detector.process(gray);
  System.out.println(count + ""String_Node_Str"" + detector.getFound().size);
  if (count == 212) {
    UtilImageIO.saveImage(buffImage,""String_Node_Str"");
  }
  count++;
  processedInputImage=true;
}","@Override protected void updateAlg(MultiSpectral<I> frame,BufferedImage buffImage){
  GConvertImage.average(frame,gray);
  detector.process(gray);
  System.out.println(count + ""String_Node_Str"" + detector.getFound().size);
  if (count == 212) {
    UtilImageIO.saveImage(buffImage,""String_Node_Str"");
  }
  count++;
  processedInputImage=true;
}",0.9239130434782608
150937,"public static void main(String[] args){
  Class type=ImageUInt8.class;
  VideoPolygonDetectionApp app=new VideoPolygonDetectionApp(type);
  app.setBaseDirectory(""String_Node_Str"");
  app.loadInputData(""String_Node_Str"");
  while (!app.getHasProcessedImage()) {
    Thread.yield();
  }
  ShowImages.showWindow(app,""String_Node_Str"");
}","public static void main(String[] args){
  Class type=ImageUInt8.class;
  VideoPolygonDetectionApp app=new VideoPolygonDetectionApp(type);
  app.setBaseDirectory(""String_Node_Str"");
  app.loadInputData(""String_Node_Str"");
  while (!app.getHasProcessedImage()) {
    Thread.yield();
  }
  ShowImages.showWindow(app,""String_Node_Str"",true);
}",0.9925705794947994
150938,"@Override protected void updateAlgGUI(MultiSpectral<I> frame,BufferedImage imageGUI,double fps){
  if (firstFrame) {
    panel.setPreferredSize(new Dimension(imageGUI.getWidth(),imageGUI.getHeight()));
    firstFrame=false;
  }
  ConvertBufferedImage.convertTo(undistorted,imageGUI,true);
  Graphics2D g2=imageGUI.createGraphics();
  FastQueue<Polygon2D_F64> found=detector.getFound();
  g2.setColor(new Color(255,0,0,200));
  g2.setStroke(new BasicStroke(4));
  for (int i=0; i < found.size(); i++) {
    VisualizeShapes.drawPolygon(found.get(i),true,g2);
  }
  panel.setBufferedImageSafe(imageGUI);
  panel.repaint();
}","@Override protected void updateAlgGUI(MultiSpectral<I> frame,BufferedImage imageGUI,double fps){
  if (firstFrame) {
    panel.setPreferredSize(new Dimension(imageGUI.getWidth(),imageGUI.getHeight()));
    firstFrame=false;
  }
  Graphics2D g2=imageGUI.createGraphics();
  FastQueue<Polygon2D_F64> found=detector.getFound();
  g2.setColor(new Color(255,0,0,200));
  g2.setStroke(new BasicStroke(4));
  for (int i=0; i < found.size(); i++) {
    Polygon2D_F64 poly=found.get(i);
    for (int j=0; j < poly.size(); j++) {
      Point2D_F64 p=poly.get(j);
      pointUndistToDist.compute(p.x,p.y,p);
    }
    VisualizeShapes.drawPolygon(found.get(i),true,g2);
  }
  panel.setBufferedImageSafe(imageGUI);
  panel.repaint();
}",0.8339538346984363
150939,"@Override public void changeInput(String name,int index){
  stopWorker();
  processedInputImage=false;
  String videoName=inputRefs.get(index).getPath();
  String path=videoName.substring(0,videoName.lastIndexOf('/'));
  intrinsic=UtilIO.loadXML(media.openFile(path + ""String_Node_Str""));
  undistorted.reshape(intrinsic.width,intrinsic.height);
  undistorter=LensDistortionOps.imageRemoveDistortion(AdjustmentType.EXPAND,BorderType.EXTENDED,intrinsic,intrinsicUndist,undistorted.getImageType());
  undistorted.reshape(intrinsic.width,intrinsic.height);
  gray.reshape(intrinsic.width,intrinsic.height);
  SimpleImageSequence<MultiSpectral<I>> video=media.openVideo(videoName,ImageType.ms(3,imageClass));
  process(video);
}","@Override public void changeInput(String name,int index){
  stopWorker();
  processedInputImage=false;
  String videoName=inputRefs.get(index).getPath();
  String path=videoName.substring(0,videoName.lastIndexOf('/'));
  intrinsic=UtilIO.loadXML(media.openFile(path + ""String_Node_Str""));
  gray.reshape(intrinsic.width,intrinsic.height);
  this.pointUndistToDist=LensDistortionOps.transform_F64(AdjustmentType.FULL_VIEW,intrinsic,null,true);
  PointTransform_F32 pointDistToUndist=LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW,intrinsic,null,false);
  PointTransform_F32 pointUndistToDist=LensDistortionOps.transform_F32(AdjustmentType.FULL_VIEW,intrinsic,null,true);
  PixelTransform_F32 distToUndist=new PointToPixelTransform_F32(pointDistToUndist);
  PixelTransform_F32 undistToDist=new PointToPixelTransform_F32(pointUndistToDist);
  distToUndist=new PixelTransformCached_F32(intrinsic.width,intrinsic.height,distToUndist);
  undistToDist=new PixelTransformCached_F32(intrinsic.width,intrinsic.height,undistToDist);
  detector.setLensDistortion(intrinsic.width,intrinsic.height,distToUndist,undistToDist);
  SimpleImageSequence<MultiSpectral<I>> video=media.openVideo(videoName,ImageType.ms(3,imageClass));
  process(video);
}",0.5544252288911495
150940,"public VideoPolygonDetectionApp(Class<I> imageType){
  super(0,ImageType.ms(3,imageType));
  this.imageClass=imageType;
  gray=GeneralizedImageOps.createSingleBand(imageType,1,1);
  panel.setPreferredSize(new Dimension(640,480));
  panel.setFocusable(true);
  panel.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
      isPaused=!isPaused;
    }
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
  }
);
  setMainGUI(panel);
  periodSpinner.setValue(33);
  undistorted=new MultiSpectral<I>(imageType,1,1,3);
  ConfigPolygonDetector config=new ConfigPolygonDetector(4);
  config.refineWithLines=true;
  config.refineWithCorners=false;
  InputToBinary<I> inputToBinary=FactoryThresholdBinary.globalOtsu(0,256,true,imageType);
  detector=FactoryShapeDetector.polygon(inputToBinary,config,imageType);
}","public VideoPolygonDetectionApp(Class<I> imageType){
  super(0,ImageType.ms(3,imageType));
  this.imageClass=imageType;
  gray=GeneralizedImageOps.createSingleBand(imageType,1,1);
  panel.setPreferredSize(new Dimension(640,480));
  panel.setFocusable(true);
  panel.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
      isPaused=!isPaused;
    }
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
  }
);
  setMainGUI(panel);
  periodSpinner.setValue(33);
  ConfigPolygonDetector config=new ConfigPolygonDetector(4);
  config.refineWithLines=true;
  config.refineWithCorners=false;
  InputToBinary<I> inputToBinary=FactoryThresholdBinary.globalOtsu(0,256,true,imageType);
  detector=FactoryShapeDetector.polygon(inputToBinary,config,imageType);
}",0.9741337237676916
150941,"public static void convertFromRGB(PImage input,ImageBase output){
  if (output instanceof ImageUInt8) {
    convert_RGB_U8(input,(ImageUInt8)output);
  }
 else   if (output instanceof ImageFloat32) {
    convert_RGB_F32(input,(ImageFloat32)output);
  }
 else   if (output instanceof MultiSpectral) {
    Class bandType=((MultiSpectral)output).getType();
    if (bandType == ImageFloat32.class) {
      convert_RGB_MSF32(input,(MultiSpectral)output);
    }
 else     if (bandType == ImageUInt8.class) {
      convert_RGB_MSU8(input,(MultiSpectral)output);
    }
  }
}","public static void convertFromRGB(PImage input,ImageBase output){
  if (output instanceof ImageUInt8) {
    convert_RGB_U8(input,(ImageUInt8)output);
  }
 else   if (output instanceof ImageFloat32) {
    convert_RGB_F32(input,(ImageFloat32)output);
  }
 else   if (output instanceof MultiSpectral) {
    Class bandType=((MultiSpectral)output).getBandType();
    if (bandType == ImageFloat32.class) {
      convert_RGB_MSF32(input,(MultiSpectral)output);
    }
 else     if (bandType == ImageUInt8.class) {
      convert_RGB_MSU8(input,(MultiSpectral)output);
    }
  }
}",0.9964788732394366
150942,"public PImage convert(){
  PImage out=new PImage(image.width,image.height,PConstants.RGB);
  if (image.getType() == ImageFloat32.class) {
    ConvertProcessing.convert_MSF32_RGB(image,out);
  }
 else   if (image.getType() == ImageUInt8.class) {
    ConvertProcessing.convert_MSU8_RGB(image,out);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return out;
}","public PImage convert(){
  PImage out=new PImage(image.width,image.height,PConstants.RGB);
  if (image.getBandType() == ImageFloat32.class) {
    ConvertProcessing.convert_MSF32_RGB(image,out);
  }
 else   if (image.getBandType() == ImageUInt8.class) {
    ConvertProcessing.convert_MSU8_RGB(image,out);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return out;
}",0.9895287958115184
150943,"/** 
 * <p>Specifies transforms which can be used to change coordinates from distorted to undistorted and the opposite coordinates.  The undistorted image is never explicitly created.</p> <p> WARNING: The undistorted image must have the same bounds as the distorted input image.  This is because several of the bounds checks use the image shape.  This are simplified greatly by this assumption. </p>
 * @param width Input image width.  Used in sanity check only.
 * @param height Input image height.  Used in sanity check only.
 * @param toUndistorted Transform from undistorted to distorted image.
 * @param toDistorted Transform from distorted to undistorted image.
 */
public void setLensDistortion(int width,int height,PixelTransform_F32 toUndistorted,PixelTransform_F32 toDistorted){
  this.toUndistorted=toUndistorted;
  this.toDistorted=toDistorted;
  RectangleLength2D_F32 rect=DistortImageOps.boundBox_F32(width,height,toUndistorted);
  float x1=rect.x0 + rect.width;
  float y1=rect.y0 + rect.height;
  float tol=1e-4f;
  if (rect.getX() < -tol || rect.getY() < -tol || x1 > width + tol || y1 > height + tol) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (refineLine != null) {
    refineLine.getSnapToEdge().setTransform(toDistorted);
  }
}","/** 
 * <p>Specifies transforms which can be used to change coordinates from distorted to undistorted and the opposite coordinates.  The undistorted image is never explicitly created.</p> <p> WARNING: The undistorted image must have the same bounds as the distorted input image.  This is because several of the bounds checks use the image shape.  This are simplified greatly by this assumption. </p>
 * @param width Input image width.  Used in sanity check only.
 * @param height Input image height.  Used in sanity check only.
 * @param toUndistorted Transform from undistorted to distorted image.
 * @param toDistorted Transform from distorted to undistorted image.
 */
public void setLensDistortion(int width,int height,PixelTransform_F32 toUndistorted,PixelTransform_F32 toDistorted){
  this.toUndistorted=toUndistorted;
  this.toDistorted=toDistorted;
  RectangleLength2D_F32 rect=DistortImageOps.boundBox_F32(width,height,toUndistorted);
  float x1=rect.x0 + rect.width;
  float y1=rect.y0 + rect.height;
  float tol=1e-4f;
  if (rect.getX() < -tol || rect.getY() < -tol || x1 > width + tol || y1 > height + tol) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (refineLine != null) {
    refineLine.getSnapToEdge().setTransform(toDistorted);
  }
  if (refineCorner != null) {
    refineCorner.getSnapToEdge().setTransform(toDistorted);
  }
}",0.964977645305514
150944,"/** 
 * See if it uses the provided lens distortion transforms correctly.  The distortion applied is actually the affine transform instead of lens distortion.  It should find the original rectangles.
 */
@Test public void usingSetLensDistortion(){
  rectangles.add(new Rectangle2D_I32(30,30,60,60));
  rectangles.add(new Rectangle2D_I32(90,30,120,60));
  rectangles.add(new Rectangle2D_I32(30,90,60,120));
  rectangles.add(new Rectangle2D_I32(90,90,120,120));
  transform.set(0.8,0,0,0.8,1,2);
  transform=transform.invert(null);
  for (  Class imageType : imageTypes) {
    checkDetected_LensDistortion(imageType,0.5);
  }
}","/** 
 * See if it uses the provided lens distortion transforms correctly.  The distortion applied is actually the affine transform instead of lens distortion.  It should find the original rectangles.
 */
@Test public void usingSetLensDistortion(){
  rectangles.add(new Rectangle2D_I32(30,30,60,60));
  rectangles.add(new Rectangle2D_I32(90,30,120,60));
  rectangles.add(new Rectangle2D_I32(30,90,60,120));
  rectangles.add(new Rectangle2D_I32(90,90,120,120));
  transform.set(0.8,0,0,0.8,1,2);
  transform=transform.invert(null);
  for (  Class imageType : imageTypes) {
    checkDetected_LensDistortion(imageType,true,0.5);
    checkDetected_LensDistortion(imageType,false,0.5);
  }
}",0.9541984732824428
150945,"@Test public void rejectShapes_circle(){
  BufferedImage work=new BufferedImage(200,220,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2=work.createGraphics();
  g2.setColor(Color.WHITE);
  g2.fillRect(0,0,200,220);
  g2.setColor(Color.BLACK);
  g2.fillOval(30,30,40,50);
  ImageUInt8 gray=ConvertBufferedImage.convertFrom(work,(ImageUInt8)null);
  for (int i=3; i <= 6; i++) {
    BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,i);
    alg.process(gray);
    assertEquals(""String_Node_Str"" + i,0,alg.getFound().size());
  }
}","@Test public void rejectShapes_circle(){
  BufferedImage work=new BufferedImage(200,220,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2=work.createGraphics();
  g2.setColor(Color.WHITE);
  g2.fillRect(0,0,200,220);
  g2.setColor(Color.BLACK);
  g2.fillOval(30,30,40,50);
  ImageUInt8 gray=ConvertBufferedImage.convertFrom(work,(ImageUInt8)null);
  for (int i=3; i <= 6; i++) {
    BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,i,true);
    alg.process(gray);
    assertEquals(""String_Node_Str"" + i,0,alg.getFound().size());
  }
}",0.9953831948291784
150946,"/** 
 * Should sanity check transforms to make sure they don't go outside the image
 */
@Test public void setTransform_input(){
  Affine2D_F32 a=new Affine2D_F32();
  transform.set(1.2,0,0,1.2,0,0);
  UtilAffine.convert(transform,a);
  PixelTransform_F32 tranFrom=new PixelTransformAffine_F32(a);
  PixelTransform_F32 tranTo=new PixelTransformAffine_F32(a.invert(null));
  BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,4);
  alg.setLensDistortion(width,height,tranTo,tranFrom);
  try {
    alg.setLensDistortion(width,height,tranFrom,tranTo);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ignore) {
  }
}","/** 
 * Should sanity check transforms to make sure they don't go outside the image
 */
@Test public void setTransform_input(){
  Affine2D_F32 a=new Affine2D_F32();
  transform.set(1.2,0,0,1.2,0,0);
  UtilAffine.convert(transform,a);
  PixelTransform_F32 tranFrom=new PixelTransformAffine_F32(a);
  PixelTransform_F32 tranTo=new PixelTransformAffine_F32(a.invert(null));
  BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,4,true);
  alg.setLensDistortion(width,height,tranTo,tranFrom);
  try {
    alg.setLensDistortion(width,height,tranFrom,tranTo);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ignore) {
  }
}",0.9961330239752514
150947,"private void checkDetected(Class imageType,double tol){
  renderDistortedRectangle(imageType);
  int numberOfSides=4;
  BinaryPolygonConvexDetector alg=createDetector(imageType,numberOfSides);
  alg.process(dist);
  FastQueue<Polygon2D_F64> found=alg.getFound();
  assertEquals(rectangles.size(),found.size);
  for (int i=0; i < found.size; i++) {
    assertEquals(1,findMatches(found.get(i),tol));
  }
}","private void checkDetected(Class imageType,boolean useLines,double tol){
  renderDistortedRectangle(imageType);
  int numberOfSides=4;
  BinaryPolygonConvexDetector alg=createDetector(imageType,numberOfSides,useLines);
  alg.process(dist);
  FastQueue<Polygon2D_F64> found=alg.getFound();
  assertEquals(rectangles.size(),found.size);
  for (int i=0; i < found.size; i++) {
    assertEquals(1,findMatches(found.get(i),tol));
  }
}",0.9688249400479616
150948,"@Test public void rejectShapes_triangle(){
  BufferedImage work=new BufferedImage(200,220,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2=work.createGraphics();
  g2.setColor(Color.WHITE);
  g2.fillRect(0,0,200,220);
  g2.setColor(Color.BLACK);
  g2.fillPolygon(new int[]{10,50,30},new int[]{10,10,40},3);
  ImageUInt8 gray=ConvertBufferedImage.convertFrom(work,(ImageUInt8)null);
  for (int i=3; i <= 6; i++) {
    BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,i);
    alg.process(gray);
    if (i == 3) {
      double tol=0.5;
      assertEquals(1,alg.getFound().size());
      Polygon2D_F64 found=(Polygon2D_F64)alg.getFound().get(0);
      assertEquals(10,found.get(0).x,tol);
      assertEquals(10,found.get(0).y,tol);
      assertEquals(30,found.get(1).x,tol);
      assertEquals(40,found.get(1).y,tol);
      assertEquals(50,found.get(2).x,tol);
      assertEquals(10,found.get(2).y,tol);
    }
 else     assertEquals(0,alg.getFound().size());
  }
}","@Test public void rejectShapes_triangle(){
  BufferedImage work=new BufferedImage(200,220,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2=work.createGraphics();
  g2.setColor(Color.WHITE);
  g2.fillRect(0,0,200,220);
  g2.setColor(Color.BLACK);
  g2.fillPolygon(new int[]{10,50,30},new int[]{10,10,40},3);
  ImageUInt8 gray=ConvertBufferedImage.convertFrom(work,(ImageUInt8)null);
  for (int i=3; i <= 6; i++) {
    BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,i,true);
    alg.process(gray);
    if (i == 3) {
      double tol=0.5;
      assertEquals(1,alg.getFound().size());
      Polygon2D_F64 found=(Polygon2D_F64)alg.getFound().get(0);
      assertEquals(10,found.get(0).x,tol);
      assertEquals(10,found.get(0).y,tol);
      assertEquals(30,found.get(1).x,tol);
      assertEquals(40,found.get(1).y,tol);
      assertEquals(50,found.get(2).x,tol);
      assertEquals(10,found.get(2).y,tol);
    }
 else     assertEquals(0,alg.getFound().size());
  }
}",0.997431946584489
150949,"@Test public void easyTestNoDistortion(){
  rectangles.add(new Rectangle2D_I32(30,30,60,60));
  rectangles.add(new Rectangle2D_I32(90,30,120,60));
  rectangles.add(new Rectangle2D_I32(30,90,60,120));
  rectangles.add(new Rectangle2D_I32(90,90,120,120));
  for (  Class imageType : imageTypes) {
    checkDetected(imageType,1e-8);
  }
}","@Test public void easyTestNoDistortion(){
  rectangles.add(new Rectangle2D_I32(30,30,60,60));
  rectangles.add(new Rectangle2D_I32(90,30,120,60));
  rectangles.add(new Rectangle2D_I32(30,90,60,120));
  rectangles.add(new Rectangle2D_I32(90,90,120,120));
  for (  Class imageType : imageTypes) {
    checkDetected(imageType,true,1e-8);
    checkDetected(imageType,false,1e-8);
  }
}",0.935754189944134
150950,"@Test public void touchesBorder_false(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,4);
  alg.getBinary().reshape(20,30);
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(10,1));
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(10,28));
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(1,15));
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(18,15));
  assertFalse(alg.touchesBorder(contour));
}","@Test public void touchesBorder_false(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,4,true);
  alg.getBinary().reshape(20,30);
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(10,1));
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(10,28));
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(1,15));
  assertFalse(alg.touchesBorder(contour));
  contour.add(new Point2D_I32(18,15));
  assertFalse(alg.touchesBorder(contour));
}",0.9956559513466552
150951,"private void checkDetected_LensDistortion(Class imageType,double tol){
  renderDistortedRectangle(imageType);
  Affine2D_F32 a=new Affine2D_F32();
  UtilAffine.convert(transform,a);
  PixelTransform_F32 tranFrom=new PixelTransformAffine_F32(a);
  PixelTransform_F32 tranTo=new PixelTransformAffine_F32(a.invert(null));
  int numberOfSides=4;
  BinaryPolygonConvexDetector alg=createDetector(imageType,numberOfSides);
  alg.setLensDistortion(dist.width,dist.height,tranTo,tranFrom);
  alg.process(dist);
  FastQueue<Polygon2D_F64> found=alg.getFound();
  assertEquals(rectangles.size(),found.size);
  for (int i=0; i < found.size; i++) {
    assertEquals(1,findMatchesOriginal(found.get(i),tol));
  }
}","private void checkDetected_LensDistortion(Class imageType,boolean useLines,double tol){
  renderDistortedRectangle(imageType);
  Affine2D_F32 a=new Affine2D_F32();
  UtilAffine.convert(transform,a);
  PixelTransform_F32 tranFrom=new PixelTransformAffine_F32(a);
  PixelTransform_F32 tranTo=new PixelTransformAffine_F32(a.invert(null));
  int numberOfSides=4;
  BinaryPolygonConvexDetector alg=createDetector(imageType,numberOfSides,useLines);
  alg.setLensDistortion(dist.width,dist.height,tranTo,tranFrom);
  alg.process(dist);
  FastQueue<Polygon2D_F64> found=alg.getFound();
  assertEquals(rectangles.size(),found.size);
  for (int i=0; i < found.size; i++) {
    assertEquals(1,findMatchesOriginal(found.get(i),tol));
  }
}",0.9817927170868348
150952,"private BinaryPolygonConvexDetector createDetector(Class imageType,int numberOfSides){
  InputToBinary inputToBinary=FactoryThresholdBinary.globalFixed(100,true,imageType);
  return FactoryShapeDetector.polygon(inputToBinary,new ConfigPolygonDetector(numberOfSides),imageType);
}","private BinaryPolygonConvexDetector createDetector(Class imageType,int numberOfSides,boolean useLines){
  InputToBinary inputToBinary=FactoryThresholdBinary.globalFixed(100,true,imageType);
  ConfigPolygonDetector config=new ConfigPolygonDetector(numberOfSides);
  config.refineWithLines=useLines;
  config.refineWithCorners=!useLines;
  return FactoryShapeDetector.polygon(inputToBinary,config,imageType);
}",0.6957787481804949
150953,"@Test public void someAffineDistortion(){
  rectangles.add(new Rectangle2D_I32(30,30,60,60));
  rectangles.add(new Rectangle2D_I32(90,30,120,60));
  rectangles.add(new Rectangle2D_I32(30,90,60,120));
  rectangles.add(new Rectangle2D_I32(90,90,120,120));
  transform.set(1.1,0.2,0.12,1.3,10.2,20.3);
  for (  Class imageType : imageTypes) {
    checkDetected(imageType,0.3);
  }
}","@Test public void someAffineDistortion(){
  rectangles.add(new Rectangle2D_I32(30,30,60,60));
  rectangles.add(new Rectangle2D_I32(90,30,120,60));
  rectangles.add(new Rectangle2D_I32(30,90,60,120));
  rectangles.add(new Rectangle2D_I32(90,90,120,120));
  transform.set(1.1,0.2,0.12,1.3,10.2,20.3);
  for (  Class imageType : imageTypes) {
    checkDetected(imageType,true,0.3);
    checkDetected(imageType,false,0.35);
  }
}",0.9353233830845772
150954,"@Test public void touchesBorder_true(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,4);
  alg.getBinary().reshape(20,30);
  contour.add(new Point2D_I32(10,0));
  assertTrue(alg.touchesBorder(contour));
  contour.clear();
  contour.add(new Point2D_I32(10,29));
  assertTrue(alg.touchesBorder(contour));
  contour.clear();
  contour.add(new Point2D_I32(0,15));
  assertTrue(alg.touchesBorder(contour));
  contour.clear();
  contour.add(new Point2D_I32(19,15));
  assertTrue(alg.touchesBorder(contour));
}","@Test public void touchesBorder_true(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  BinaryPolygonConvexDetector alg=createDetector(ImageUInt8.class,4,true);
  alg.getBinary().reshape(20,30);
  contour.add(new Point2D_I32(10,0));
  assertTrue(alg.touchesBorder(contour));
  contour.clear();
  contour.add(new Point2D_I32(10,29));
  assertTrue(alg.touchesBorder(contour));
  contour.clear();
  contour.add(new Point2D_I32(0,15));
  assertTrue(alg.touchesBorder(contour));
  contour.clear();
  contour.add(new Point2D_I32(19,15));
  assertTrue(alg.touchesBorder(contour));
}",0.9957228400342172
150955,"public static void main(String[] args){
  String nameIntrinsic=null;
  int cameraId=0;
  if (args.length >= 1) {
    cameraId=Integer.parseInt(args[0]);
  }
  if (args.length >= 2) {
    nameIntrinsic=args[1];
  }
 else {
    System.out.println();
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println();
  }
  System.out.println();
  System.out.println(""String_Node_Str"" + cameraId);
  System.out.println(""String_Node_Str"" + nameIntrinsic);
  System.out.println();
  Webcam webcam=Webcam.getWebcams().get(cameraId);
  UtilWebcamCapture.adjustResolution(webcam,640,480);
  webcam.open();
  IntrinsicParameters param;
  if (nameIntrinsic == null) {
    param=new IntrinsicParameters();
    Dimension d=webcam.getDevice().getResolution();
    param.width=d.width;
    param.height=d.height;
    param.cx=d.width / 2;
    param.cy=d.height / 2;
    param.fx=param.cx / Math.tan(UtilAngle.degreeToRadian(35));
    param.fy=param.cx / Math.tan(UtilAngle.degreeToRadian(35));
  }
 else {
    param=UtilIO.loadXML(nameIntrinsic);
  }
  String patternPath=UtilIO.getPathToBase() + ""String_Node_Str"";
  SquareImage_to_FiducialDetector<ImageFloat32> detector=FactoryFiducial.squareImageRobust(new ConfigFiducialImage(),6,ImageFloat32.class);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.setIntrinsic(param);
  ImageFloat32 gray=new ImageFloat32(param.width,param.height);
  ImagePanel gui=new ImagePanel(param.width,param.height);
  ShowImages.showWindow(gui,""String_Node_Str"").setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  Font font=new Font(""String_Node_Str"",Font.BOLD,24);
  while (true) {
    BufferedImage frame=webcam.getImage();
    ConvertBufferedImage.convertFrom(frame,gray);
    detector.detect(gray);
    Graphics2D g2=frame.createGraphics();
    Se3_F64 targetToSensor=new Se3_F64();
    for (int i=0; i < detector.totalFound(); i++) {
      detector.getFiducialToCamera(i,targetToSensor);
      double width=detector.getWidth(i);
      int id=detector.getId(i);
      Point2D_F64 p=new Point2D_F64();
      Point3D_F64 c=new Point3D_F64();
      SePointOps_F64.transform(targetToSensor,c,c);
      PerspectiveOps.convertNormToPixel(param,c.x / c.z,c.y / c.z,p);
      FontMetrics metrics=g2.getFontMetrics(font);
      String text=Integer.toString(id);
      Rectangle2D r=metrics.getStringBounds(text,null);
      g2.setColor(Color.ORANGE);
      g2.setFont(font);
      g2.drawString(text,(float)(p.x - r.getWidth() / 2),(float)(p.y + r.getHeight() / 2));
      VisualizeFiducial.drawCube(targetToSensor,param,width,g2);
    }
    if (nameIntrinsic == null) {
      g2.setColor(Color.RED);
      g2.setFont(font);
      g2.drawString(""String_Node_Str"",10,20);
    }
    gui.setBufferedImageSafe(frame);
    gui.repaint();
  }
}","public static void main(String[] args){
  String nameIntrinsic=null;
  int cameraId=0;
  if (args.length >= 1) {
    cameraId=Integer.parseInt(args[0]);
  }
  if (args.length >= 2) {
    nameIntrinsic=args[1];
  }
 else {
    System.out.println();
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println();
  }
  System.out.println();
  System.out.println(""String_Node_Str"" + cameraId);
  System.out.println(""String_Node_Str"" + nameIntrinsic);
  System.out.println();
  Webcam webcam=Webcam.getWebcams().get(cameraId);
  UtilWebcamCapture.adjustResolution(webcam,640,480);
  webcam.open();
  IntrinsicParameters param;
  if (nameIntrinsic == null) {
    param=new IntrinsicParameters();
    Dimension d=webcam.getDevice().getResolution();
    param.width=d.width;
    param.height=d.height;
    param.cx=d.width / 2;
    param.cy=d.height / 2;
    param.fx=param.cx / Math.tan(UtilAngle.degreeToRadian(35));
    param.fy=param.cx / Math.tan(UtilAngle.degreeToRadian(35));
  }
 else {
    param=UtilIO.loadXML(nameIntrinsic);
  }
  String patternPath=UtilIO.getPathToBase() + ""String_Node_Str"";
  SquareImage_to_FiducialDetector<ImageFloat32> detector=FactoryFiducial.squareImageFast(new ConfigFiducialImage(),100,ImageFloat32.class);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.addTarget(loadImage(patternPath + ""String_Node_Str"",ImageFloat32.class),100,2.5);
  detector.setIntrinsic(param);
  ImageFloat32 gray=new ImageFloat32(param.width,param.height);
  ImagePanel gui=new ImagePanel(param.width,param.height);
  ShowImages.showWindow(gui,""String_Node_Str"").setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  Font font=new Font(""String_Node_Str"",Font.BOLD,24);
  while (true) {
    BufferedImage frame=webcam.getImage();
    ConvertBufferedImage.convertFrom(frame,gray);
    detector.detect(gray);
    Graphics2D g2=frame.createGraphics();
    Se3_F64 targetToSensor=new Se3_F64();
    for (int i=0; i < detector.totalFound(); i++) {
      detector.getFiducialToCamera(i,targetToSensor);
      double width=detector.getWidth(i);
      int id=detector.getId(i);
      Point2D_F64 p=new Point2D_F64();
      Point3D_F64 c=new Point3D_F64();
      SePointOps_F64.transform(targetToSensor,c,c);
      PerspectiveOps.convertNormToPixel(param,c.x / c.z,c.y / c.z,p);
      FontMetrics metrics=g2.getFontMetrics(font);
      String text=Integer.toString(id);
      Rectangle2D r=metrics.getStringBounds(text,null);
      g2.setColor(Color.ORANGE);
      g2.setFont(font);
      g2.drawString(text,(float)(p.x - r.getWidth() / 2),(float)(p.y + r.getHeight() / 2));
      VisualizeFiducial.drawCube(targetToSensor,param,width,g2);
    }
    if (nameIntrinsic == null) {
      g2.setColor(Color.RED);
      g2.setFont(font);
      g2.drawString(""String_Node_Str"",10,20);
    }
    gui.setBufferedImageSafe(frame);
    gui.repaint();
  }
}",0.9915014164305948
150956,"public void process(double width,String inputPath,String outputName) throws FileNotFoundException {
  String inputName=new File(inputPath).getName();
  System.out.println(""String_Node_Str"" + width + ""String_Node_Str""+ inputName);
  System.out.println(""String_Node_Str"" + inputPath);
  ImageUInt8 image=UtilImageIO.loadImage(inputPath,ImageUInt8.class);
  if (image == null) {
    System.err.println(""String_Node_Str"" + inputPath);
    System.exit(0);
  }
  int s=image.width - (image.width % 8);
  if (image.width != s || image.height != s) {
    ImageUInt8 tmp=new ImageUInt8(s,s);
    new FDistort(image,tmp).scaleExt().apply();
    image=tmp;
  }
  out=new PrintStream(outputName);
  targetLength=width * CM_TO_POINTS;
  whiteBorder=Math.max(2 * CM_TO_POINTS,targetLength / 4.0);
  blackBorder=targetLength / 4.0;
  innerWidth=targetLength / 2.0;
  pageLength=targetLength + whiteBorder * 2;
  scale=image.width / innerWidth;
  ImageUInt8 binary=ThresholdImageOps.threshold(image,null,threshold,false);
  if (showPreview)   ShowImages.showWindow(VisualizeBinaryData.renderBinary(binary,false,null),""String_Node_Str"");
  printHeader(inputName);
  out.println();
  out.print(""String_Node_Str"" + ""String_Node_Str"" + binary.width + ""String_Node_Str""+ binary.height+ ""String_Node_Str""+ scale+ ""String_Node_Str""+ scale+ ""String_Node_Str""+ ""String_Node_Str""+ binaryToHex(binary)+ ""String_Node_Str""+ ""String_Node_Str"");
  out.println();
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  for (int row=0; row < numRows; row++) {
    for (int col=0; col < numCols; col++) {
      insertFiducial(row,col,binary,inputName);
    }
  }
  out.print(""String_Node_Str"" + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + new File(outputName).getAbsolutePath());
}","public void process(double width,String inputPath,String outputName) throws FileNotFoundException {
  this.width=width;
  String inputName=new File(inputPath).getName();
  System.out.println(""String_Node_Str"" + width + ""String_Node_Str""+ inputName);
  System.out.println(""String_Node_Str"" + inputPath);
  ImageUInt8 image=UtilImageIO.loadImage(inputPath,ImageUInt8.class);
  if (image == null) {
    System.err.println(""String_Node_Str"" + inputPath);
    System.exit(0);
  }
  int s=image.width - (image.width % 8);
  if (image.width != s || image.height != s) {
    ImageUInt8 tmp=new ImageUInt8(s,s);
    new FDistort(image,tmp).scaleExt().apply();
    image=tmp;
  }
  out=new PrintStream(outputName);
  targetLength=width * CM_TO_POINTS;
  whiteBorder=Math.max(2 * CM_TO_POINTS,targetLength / 4.0);
  blackBorder=targetLength / 4.0;
  innerWidth=targetLength / 2.0;
  pageLength=targetLength + whiteBorder * 2;
  scale=image.width / innerWidth;
  ImageUInt8 binary=ThresholdImageOps.threshold(image,null,threshold,false);
  if (showPreview)   ShowImages.showWindow(VisualizeBinaryData.renderBinary(binary,false,null),""String_Node_Str"");
  printHeader(inputName);
  out.println();
  out.print(""String_Node_Str"" + ""String_Node_Str"" + binary.width + ""String_Node_Str""+ binary.height+ ""String_Node_Str""+ scale+ ""String_Node_Str""+ scale+ ""String_Node_Str""+ ""String_Node_Str""+ binaryToHex(binary)+ ""String_Node_Str""+ ""String_Node_Str"");
  out.println();
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  for (int row=0; row < numRows; row++) {
    for (int col=0; col < numCols; col++) {
      insertFiducial(row,col,inputName);
    }
  }
  out.print(""String_Node_Str"" + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + new File(outputName).getAbsolutePath());
}",0.9927633342267488
150957,"private void insertFiducial(int row,int col,ImageUInt8 binary,String inputName){
  System.out.println(""String_Node_Str"" + row + ""String_Node_Str""+ col);
  out.print(""String_Node_Str"" + (col * pageLength) + ""String_Node_Str""+ ""String_Node_Str""+ (row * pageLength)+ ""String_Node_Str""+ ""String_Node_Str"");
  out.println();
  out.println(""String_Node_Str"");
  if (displayInfo) {
    out.print(""String_Node_Str"" + ""String_Node_Str"" + (pageLength - 10) + ""String_Node_Str""+ inputName+ ""String_Node_Str""+ width+ ""String_Node_Str"");
  }
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
}","private void insertFiducial(int row,int col,String inputName){
  out.print(""String_Node_Str"" + (col * pageLength) + ""String_Node_Str""+ ""String_Node_Str""+ (row * pageLength)+ ""String_Node_Str""+ ""String_Node_Str"");
  out.println();
  out.println(""String_Node_Str"");
  if (displayInfo) {
    out.print(""String_Node_Str"" + ""String_Node_Str"" + (pageLength - 10) + ""String_Node_Str""+ inputName+ ""String_Node_Str""+ width+ ""String_Node_Str"");
  }
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
  out.println(""String_Node_Str"");
}",0.9143686502177067
150958,"/** 
 * Performs bubble sort on the first 4 lines to ensure they are in a contour order
 */
protected static void bubbleSortLines(FastQueue<Segment> segments){
  for (int i=0; i < 4; i++) {
    int bestValue=segments.get(i).index0;
    int bestIndex=i;
    for (int j=i + 1; j < 4; j++) {
      Segment b=segments.get(j);
      if (b.index0 < bestValue) {
        bestIndex=j;
        bestValue=b.index0;
      }
    }
    if (bestIndex != i) {
      Segment tmp=segments.data[i];
      segments.data[i]=segments.data[bestIndex];
      segments.data[bestIndex]=tmp;
    }
  }
}","/** 
 * Performs bubble sort on the first 4 lines to ensure they are in a contour order
 */
protected static void bubbleSortLines(FastQueue<Segment> segments){
  for (int i=0; i < 4; i++) {
    int bestValue=segments.get(i).index0;
    int bestIndex=i;
    for (int j=i + 1; j < segments.size; j++) {
      Segment b=segments.get(j);
      if (b.index0 < bestValue) {
        bestIndex=j;
        bestValue=b.index0;
      }
    }
    if (bestIndex != i) {
      Segment tmp=segments.data[i];
      segments.data[i]=segments.data[bestIndex];
      segments.data[bestIndex]=tmp;
    }
  }
}",0.9879931389365352
150959,"@Test public void bubbleSortLines(){
  fail(""String_Node_Str"");
}","@Test public void bubbleSortLines(){
  ReduceCornersInContourPolygon alg=new ReduceCornersInContourPolygon(4,10,true);
  List<Integer> indexes=new ArrayList<Integer>();
  for (int i=0; i < 10; i++) {
    indexes.add(i);
  }
  for (int i=0; i < 20; i++) {
    Collections.shuffle(indexes,rand);
    alg.segments.reset();
    for (    Integer index : indexes) {
      alg.segments.grow().index0=index;
    }
    ReduceCornersInContourPolygon.bubbleSortLines(alg.segments);
    assertEquals(0,alg.segments.get(0).index0);
    assertEquals(1,alg.segments.get(1).index0);
    assertEquals(2,alg.segments.get(2).index0);
    assertEquals(3,alg.segments.get(3).index0);
  }
}",0.1145975443383356
150960,"@Test public void checkPolygonCornerDistance(){
  fail(""String_Node_Str"");
}","@Test public void checkPolygonCornerDistance(){
  List<Point2D_I32> contour=new ArrayList<Point2D_I32>();
  for (int i=0; i < 20; i++) {
    contour.add(new Point2D_I32(rand.nextInt(),rand.nextInt()));
  }
  contour.get(3).set(10,10);
  contour.get(4).set(13,10);
  contour.get(8).set(20,10);
  contour.get(12).set(20,20);
  contour.get(18).set(10,20);
  GrowQueue_I32 corners=new GrowQueue_I32();
  corners.add(3);
  corners.add(4);
  corners.add(8);
  corners.add(12);
  corners.add(18);
  Polygon2D_F64 poly=new Polygon2D_F64(10,10,20,10,20,20,10,20);
  ReduceCornersInContourPolygon alg=new ReduceCornersInContourPolygon(4,2,true);
  assertTrue(alg.checkPolygonCornerDistance(poly,contour,corners));
  contour.get(3).set(8,10);
  assertTrue(alg.checkPolygonCornerDistance(poly,contour,corners));
  contour.get(3).set(7,10);
  assertFalse(alg.checkPolygonCornerDistance(poly,contour,corners));
}",0.1190965092402464
150961,"private void createFile(AutoTypeImage imageType) throws FileNotFoundException {
  String suffix=imageType.getAbbreviatedType();
  suffix=suffix.compareTo(""String_Node_Str"") == 0 ? ""String_Node_Str"" : suffix;
  className=""String_Node_Str"" + suffix;
  String sumType=imageType.getSumType();
  setOutputFile(className);
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ imageType.isInteger()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (imageType.isInteger())   out.print(""String_Node_Str"");
 else   if (imageType.isInteger())   out.print(""String_Node_Str"");
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","private void createFile(AutoTypeImage imageType) throws FileNotFoundException {
  String suffix=imageType.getAbbreviatedType();
  suffix=suffix.compareTo(""String_Node_Str"") == 0 ? ""String_Node_Str"" : suffix;
  className=""String_Node_Str"" + suffix;
  String sumType=imageType.getSumType();
  setOutputFile(className);
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ imageType.isInteger()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (imageType.isInteger())   out.print(""String_Node_Str"");
 else   out.print(""String_Node_Str"");
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}",0.9930575643621636
150962,"private void createFile(AutoTypeImage imageType) throws FileNotFoundException {
  String suffix=imageType.getAbbreviatedType();
  suffix=suffix.compareTo(""String_Node_Str"") == 0 ? ""String_Node_Str"" : suffix;
  className=""String_Node_Str"" + suffix;
  String sumType=imageType.getSumType();
  setOutputFile(className);
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","private void createFile(AutoTypeImage imageType) throws FileNotFoundException {
  String suffix=imageType.getAbbreviatedType();
  suffix=suffix.compareTo(""String_Node_Str"") == 0 ? ""String_Node_Str"" : suffix;
  className=""String_Node_Str"" + suffix;
  String sumType=imageType.getSumType();
  setOutputFile(className);
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ imageType.isInteger()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sumType+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  if (imageType.isInteger())   out.print(""String_Node_Str"");
 else   out.print(""String_Node_Str"");
  out.print(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ className+ ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.9304008103024164
150963,"public void print(){
  for (int i=0; i < width; i++) {
  }
  System.out.println();
}","public void print(){
  for (int i=0; i < width; i++) {
    System.out.printf(""String_Node_Str"",data[i]);
  }
  System.out.println();
}",0.7706422018348624
150964,"/** 
 * Creates a kernel whose elements are the specified data array and has the specified width.
 * @param data  The array who will be the kernel's data.  Reference is saved.
 * @param width The kernel's width.
 * @return A new kernel.
 */
public static Kernel1D_F32 wrap(float data[],int width){
  Kernel1D_F32 ret=new Kernel1D_F32();
  ret.data=data;
  ret.width=width;
  ret.offset=width / 2;
  return ret;
}","/** 
 * Creates a kernel whose elements are the specified data array and has the specified width.
 * @param data  The array who will be the kernel's data.  Reference is saved.
 * @param width The kernel's width.
 * @param offset Location of the origin in the array
 * @return A new kernel.
 */
public static Kernel1D_F32 wrap(float data[],int width,int offset){
  Kernel1D_F32 ret=new Kernel1D_F32();
  ret.data=data;
  ret.width=width;
  ret.offset=offset;
  return ret;
}",0.9107344632768362
150965,"public void print(){
  for (int i=0; i < width; i++) {
  }
  System.out.println();
}","public void print(){
  for (int i=0; i < width; i++) {
    System.out.printf(""String_Node_Str"",data[i]);
  }
  System.out.println();
}",0.7706422018348624
150966,"/** 
 * Creates a kernel whose elements are the specified data array and has the specified width.
 * @param data  The array who will be the kernel's data.  Reference is saved.
 * @param width The kernel's width.
 * @return A new kernel.
 */
public static Kernel1D_F64 wrap(double data[],int width){
  Kernel1D_F64 ret=new Kernel1D_F64();
  ret.data=data;
  ret.width=width;
  ret.offset=width / 2;
  return ret;
}","/** 
 * Creates a kernel whose elements are the specified data array and has the specified width.
 * @param data  The array who will be the kernel's data.  Reference is saved.
 * @param width The kernel's width.
 * @param offset Location of the origin in the array
 * @return A new kernel.
 */
public static Kernel1D_F64 wrap(double data[],int width,int offset){
  Kernel1D_F64 ret=new Kernel1D_F64();
  ret.data=data;
  ret.width=width;
  ret.offset=offset;
  return ret;
}",0.910935738444194
150967,"/** 
 * Creates a kernel whose elements are the specified data array and has the specified width.
 * @param data  The array who will be the kernel's data.  Reference is saved.
 * @param width The kernel's width.
 * @return A new kernel.
 */
public static Kernel1D_I32 wrap(int data[],int width){
  Kernel1D_I32 ret=new Kernel1D_I32();
  ret.data=data;
  ret.width=width;
  ret.offset=width / 2;
  return ret;
}","/** 
 * Creates a kernel whose elements are the specified data array and has the specified width.
 * @param data  The array who will be the kernel's data.  Reference is saved.
 * @param width The kernel's width.
 * @param offset Location of the origin in the array
 * @return A new kernel.
 */
public static Kernel1D_I32 wrap(int data[],int width,int offset){
  Kernel1D_I32 ret=new Kernel1D_I32();
  ret.data=data;
  ret.width=width;
  ret.offset=offset;
  return ret;
}",0.9103291713961408
150968,"@Override public boolean isInteger(){
  return false;
}","@Override public boolean isInteger(){
  return true;
}",0.9357798165137616
150969,"public void compareMethod(Method target,String validationName,int radius,int offset){
  this.kernelWidth=radius * 2 + 1;
  this.kernelRadius=radius;
  this.offset=offset;
  super.compareMethod(target,validationName);
}","public void compareMethod(Method target,String validationName,int width,int offset){
  this.kernelWidth=width;
  this.offset=offset;
  super.compareMethod(target,validationName);
}",0.8743718592964824
150970,"private KernelBase createKernel(Class<?> paramType){
  KernelBase kernel;
  if (Kernel1D_F32.class == paramType) {
    kernel=FactoryKernel.random1D_F32(kernelWidth,kernelRadius,-1,1,rand);
  }
 else   if (Kernel1D_F64.class == paramType) {
    kernel=FactoryKernel.random1D_F64(kernelWidth,kernelRadius,0,5,rand);
  }
 else   if (Kernel1D_I32.class == paramType) {
    kernel=FactoryKernel.random1D_I32(kernelWidth,kernelRadius,0,5,rand);
  }
 else   if (Kernel2D_I32.class == paramType) {
    kernel=FactoryKernel.random2D_I32(kernelWidth,kernelRadius,-1,1,rand);
  }
 else   if (Kernel2D_F32.class == paramType) {
    kernel=FactoryKernel.random2D_F32(kernelWidth,kernelRadius,0,5,rand);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  kernel.offset=offset;
  return kernel;
}","private KernelBase createKernel(Class<?> paramType){
  KernelBase kernel;
  if (Kernel1D_F32.class == paramType) {
    kernel=FactoryKernel.random1D_F32(kernelWidth,offset,-1,1,rand);
  }
 else   if (Kernel1D_F64.class == paramType) {
    kernel=FactoryKernel.random1D_F64(kernelWidth,offset,0,5,rand);
  }
 else   if (Kernel1D_I32.class == paramType) {
    kernel=FactoryKernel.random1D_I32(kernelWidth,offset,0,5,rand);
  }
 else   if (Kernel2D_I32.class == paramType) {
    kernel=FactoryKernel.random2D_I32(kernelWidth,offset,-1,1,rand);
  }
 else   if (Kernel2D_F32.class == paramType) {
    kernel=FactoryKernel.random2D_F32(kernelWidth,offset,0,5,rand);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return kernel;
}",0.9094437257438552
150971,"@Test public void compareToStandard_symmetric(){
  CompareToStandardConvolution a=new CompareToStandardConvolution(ConvolveImageNoBorder.class);
  a.setKernelRadius(2);
  a.setOffset(2);
  a.performTests(22);
}","@Test public void compareToStandard_symmetric(){
  CompareToStandardConvolution a=new CompareToStandardConvolution(ConvolveImageNoBorder.class);
  a.setKernelWidth(5);
  a.setOffset(2);
  a.performTests(22);
}",0.964200477326969
150972,"@Test public void compareToStandard_UNsymmetric(){
  CompareToStandardConvolution a=new CompareToStandardConvolution(ConvolveImageNoBorder.class);
  a.setKernelRadius(2);
  a.setOffset(1);
  a.performTests(22);
}","@Test public void compareToStandard_UNsymmetric(){
  CompareToStandardConvolution a=new CompareToStandardConvolution(ConvolveImageNoBorder.class);
  a.setKernelWidth(5);
  a.setOffset(1);
  a.performTests(22);
}",0.9645390070921984
150973,"public static void main(String args[]){
  String calibDir=""String_Node_Str"";
  String imageDir=""String_Node_Str"";
  IntrinsicParameters param=UtilIO.loadXML(calibDir + ""String_Node_Str"");
  BufferedImage orig=UtilImageIO.loadImage(imageDir + ""String_Node_Str"");
  MultiSpectral<ImageFloat32> distortedImg=ConvertBufferedImage.convertFromMulti(orig,null,true,ImageFloat32.class);
  int numBands=distortedImg.getNumBands();
  ImageDistort allInside=LensDistortionOps.removeDistortion(true,null,param,null,ImageType.ms(numBands,ImageFloat32.class));
  ImageDistort fullView=LensDistortionOps.removeDistortion(false,null,param,null,ImageType.ms(numBands,ImageFloat32.class));
  displayResults(orig,distortedImg,allInside,fullView);
}","public static void main(String args[]){
  String calibDir=""String_Node_Str"";
  String imageDir=""String_Node_Str"";
  IntrinsicParameters param=UtilIO.loadXML(calibDir + ""String_Node_Str"");
  BufferedImage orig=UtilImageIO.loadImage(imageDir + ""String_Node_Str"");
  MultiSpectral<ImageFloat32> distortedImg=ConvertBufferedImage.convertFromMulti(orig,null,true,ImageFloat32.class);
  int numBands=distortedImg.getNumBands();
  ImageDistort allInside=LensDistortionOps.removeDistortion(true,BorderType.VALUE,param,null,ImageType.ms(numBands,ImageFloat32.class));
  ImageDistort fullView=LensDistortionOps.removeDistortion(false,BorderType.VALUE,param,null,ImageType.ms(numBands,ImageFloat32.class));
  displayResults(orig,distortedImg,allInside,fullView);
}",0.9500674763832658
150974,"public static void threshold(String imageName){
  BufferedImage image=UtilImageIO.loadImage(imageName);
  ImageFloat32 input=ConvertBufferedImage.convertFromSingle(image,null,ImageFloat32.class);
  ImageUInt8 binary=new ImageUInt8(input.width,input.height);
  ListDisplayPanel gui=new ListDisplayPanel();
  GThresholdImageOps.threshold(input,binary,ImageStatistics.mean(input),true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.threshold(input,binary,GThresholdImageOps.computeOtsu(input,0,256),true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.threshold(input,binary,GThresholdImageOps.computeEntropy(input,0,256),true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.adaptiveSquare(input,binary,28,0,true,null,null);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.adaptiveGaussian(input,binary,42,0,true,null,null);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.adaptiveSauvola(input,binary,5,0.50f,true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  gui.addImage(ConvertBufferedImage.convertTo(input,null),""String_Node_Str"");
  String fileName=imageName.substring(imageName.lastIndexOf('/') + 1);
  ShowImages.showWindow(gui,fileName);
}","public static void threshold(String imageName){
  BufferedImage image=UtilImageIO.loadImage(imageName);
  ImageFloat32 input=ConvertBufferedImage.convertFromSingle(image,null,ImageFloat32.class);
  ImageUInt8 binary=new ImageUInt8(input.width,input.height);
  ListDisplayPanel gui=new ListDisplayPanel();
  GThresholdImageOps.threshold(input,binary,ImageStatistics.mean(input),true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.threshold(input,binary,GThresholdImageOps.computeOtsu(input,0,256),true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.threshold(input,binary,GThresholdImageOps.computeEntropy(input,0,256),true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.adaptiveSquare(input,binary,28,0,true,null,null);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.adaptiveGaussian(input,binary,42,0,true,null,null);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  GThresholdImageOps.adaptiveSauvola(input,binary,5,0.30f,true);
  gui.addImage(VisualizeBinaryData.renderBinary(binary,null),""String_Node_Str"");
  gui.addImage(ConvertBufferedImage.convertTo(input,null),""String_Node_Str"");
  String fileName=imageName.substring(imageName.lastIndexOf('/') + 1);
  ShowImages.showWindow(gui,fileName);
}",0.999315537303217
150975,"/** 
 * Applies   {@link boofcv.alg.filter.binary.impl.ThresholdSauvola Sauvola} thresholding to the input image.Intended for use with text image.
 * @see boofcv.alg.filter.binary.impl.ThresholdSauvola
 * @param input Input image.
 * @param output (optional) Output binary image.  If null it will be declared internally.
 * @param radius Radius of local region.  Try 15
 * @param k Positive parameter used to tune threshold.  Try 0.5
 * @param down Should it threshold up or down.
 * @return binary image
 */
public static <T extends ImageSingleBand>ImageUInt8 adaptiveSauvola(T input,ImageUInt8 output,int radius,float k,boolean down){
  ThresholdSauvola alg=new ThresholdSauvola(radius,k,down);
  if (output == null)   output=new ImageUInt8(input.width,input.height);
  if (input instanceof ImageFloat32) {
    alg.process((ImageFloat32)input,output);
  }
 else {
    ImageFloat32 conv=new ImageFloat32(input.width,input.height);
    GConvertImage.convert(input,conv);
    alg.process(conv,output);
  }
  return output;
}","/** 
 * Applies   {@link boofcv.alg.filter.binary.impl.ThresholdSauvola Sauvola} thresholding to the input image.Intended for use with text image.
 * @see boofcv.alg.filter.binary.impl.ThresholdSauvola
 * @param input Input image.
 * @param output (optional) Output binary image.  If null it will be declared internally.
 * @param radius Radius of local region.  Try 15
 * @param k Positive parameter used to tune threshold.  Try 0.3
 * @param down Should it threshold up or down.
 * @return binary image
 */
public static <T extends ImageSingleBand>ImageUInt8 adaptiveSauvola(T input,ImageUInt8 output,int radius,float k,boolean down){
  ThresholdSauvola alg=new ThresholdSauvola(radius,k,down);
  if (output == null)   output=new ImageUInt8(input.width,input.height);
  if (input instanceof ImageFloat32) {
    alg.process((ImageFloat32)input,output);
  }
 else {
    ImageFloat32 conv=new ImageFloat32(input.width,input.height);
    GConvertImage.convert(input,conv);
    alg.process(conv,output);
  }
  return output;
}",0.9990224828934506
150976,"/** 
 * Configures the algorithm.
 * @param radius size of local radius.  Try 15
 * @param k User specified threshold adjustment factor.  Must be positive. Try 0.5
 * @param down Threshold down or up
 */
public ThresholdSauvola(int radius,float k,boolean down){
  this.k=k;
  this.radius=radius;
  this.down=down;
}","/** 
 * Configures the algorithm.
 * @param radius size of local radius.  Try 15
 * @param k User specified threshold adjustment factor.  Must be positive. Try 0.3
 * @param down Threshold down or up
 */
public ThresholdSauvola(int radius,float k,boolean down){
  this.k=k;
  this.radius=radius;
  this.down=down;
}",0.9968253968253968
150977,"/** 
 * Converts the input image into a binary image.
 * @param input Input image.  Not modified.
 * @param output Output binary image.  Modified.
 */
public void process(ImageFloat32 input,ImageUInt8 output){
  inputPow2.reshape(input.width,input.height);
  inputMean.reshape(input.width,input.height);
  inputMeanPow2.reshape(input.width,input.height);
  inputPow2Mean.reshape(input.width,input.height);
  stdev.reshape(input.width,input.height);
  tmp.reshape(input.width,input.height);
  inputPow2.reshape(input.width,input.height);
  BlurImageOps.mean(input,inputMean,radius,tmp);
  PixelMath.pow2(input,inputPow2);
  BlurImageOps.mean(inputPow2,inputPow2Mean,radius,tmp);
  PixelMath.pow2(inputMean,inputMeanPow2);
  PixelMath.subtract(inputPow2Mean,inputMeanPow2,stdev);
  PixelMath.sqrt(stdev,stdev);
  float R=ImageStatistics.max(stdev);
  if (down) {
    for (int y=0; y < input.height; y++) {
      int i=y * stdev.width;
      int indexIn=input.startIndex + y * input.stride;
      int indexOut=output.startIndex + y * output.stride;
      for (int x=0; x < input.width; x++) {
        float threshold=inputMean.data[i] * (1.0f + k * (stdev.data[i] / R - 1.0f));
        output.data[indexOut++]=(byte)(input.data[indexIn++] <= threshold ? 1 : 0);
      }
    }
  }
 else {
    for (int y=0; y < input.height; y++) {
      int i=y * stdev.width;
      int indexIn=input.startIndex + y * input.stride;
      int indexOut=output.startIndex + y * output.stride;
      for (int x=0; x < input.width; x++) {
        float threshold=inputMean.data[i] * (1.0f + k * (stdev.data[i] / R - 1.0f));
        output.data[indexOut++]=(byte)(input.data[indexIn++] >= threshold ? 1 : 0);
      }
    }
  }
}","/** 
 * Converts the input image into a binary image.
 * @param input Input image.  Not modified.
 * @param output Output binary image.  Modified.
 */
public void process(ImageFloat32 input,ImageUInt8 output){
  inputPow2.reshape(input.width,input.height);
  inputMean.reshape(input.width,input.height);
  inputMeanPow2.reshape(input.width,input.height);
  inputPow2Mean.reshape(input.width,input.height);
  stdev.reshape(input.width,input.height);
  tmp.reshape(input.width,input.height);
  inputPow2.reshape(input.width,input.height);
  BlurImageOps.mean(input,inputMean,radius,tmp);
  PixelMath.pow2(input,inputPow2);
  BlurImageOps.mean(inputPow2,inputPow2Mean,radius,tmp);
  PixelMath.pow2(inputMean,inputMeanPow2);
  PixelMath.subtract(inputPow2Mean,inputMeanPow2,stdev);
  PixelMath.sqrt(stdev,stdev);
  float R=ImageStatistics.max(stdev);
  if (down) {
    for (int y=0; y < input.height; y++) {
      int i=y * stdev.width;
      int indexIn=input.startIndex + y * input.stride;
      int indexOut=output.startIndex + y * output.stride;
      for (int x=0; x < input.width; x++, i++) {
        float threshold=inputMean.data[i] * (1.0f + k * (stdev.data[i] / R - 1.0f));
        output.data[indexOut++]=(byte)(input.data[indexIn++] <= threshold ? 1 : 0);
      }
    }
  }
 else {
    for (int y=0; y < input.height; y++) {
      int i=y * stdev.width;
      int indexIn=input.startIndex + y * input.stride;
      int indexOut=output.startIndex + y * output.stride;
      for (int x=0; x < input.width; x++, i++) {
        float threshold=inputMean.data[i] * (1.0f + k * (stdev.data[i] / R - 1.0f));
        output.data[indexOut++]=(byte)(input.data[indexIn++] >= threshold ? 1 : 0);
      }
    }
  }
}",0.997070884592853
150978,"@Override protected Object[][] createInputParam(Method candidate,Method validation){
  Class c[]=candidate.getParameterTypes();
  ImageSingleBand input=GeneralizedImageOps.createSingleBand(c[0],width,height);
  ImageSingleBand output=GeneralizedImageOps.createSingleBand(c[1],width,height);
  GImageMiscOps.fillUniform(input,rand,0,20);
  Object[][] ret=new Object[1][];
  ret[0]=new Object[]{input,output,kernelRadius};
  return ret;
}","@Override protected Object[][] createInputParam(Method candidate,Method validation){
  Class c[]=candidate.getParameterTypes();
  ImageSingleBand input=GeneralizedImageOps.createSingleBand(c[0],width,height);
  ImageSingleBand output=GeneralizedImageOps.createSingleBand(c[1],width,height);
  GImageMiscOps.fillUniform(input,rand,0,20);
  Object[][] ret=new Object[2][];
  ret[0]=new Object[]{input,output,kernelRadius};
  ret[1]=new Object[]{input,output,kernelRadius2};
  return ret;
}",0.9230769230769232
150979,"public static <T extends ImageBase>SegmentFelzenszwalbHuttenlocher04<T> fh04(ConfigFh04 config,ImageType<T> imageType){
  if (config == null)   config=new ConfigFh04();
  FhEdgeWeights<T> edgeWeights=weightsFelzenszwalb04(config.connectRule,imageType);
  SegmentFelzenszwalbHuttenlocher04<T> alg=new SegmentFelzenszwalbHuttenlocher04<T>(config.K,config.minimumRegionSize,edgeWeights);
  if (config.minimumRegionSize > 0) {
    alg.configureApproximateSort(config.approximateSortBins);
  }
  return alg;
}","public static <T extends ImageBase>SegmentFelzenszwalbHuttenlocher04<T> fh04(ConfigFh04 config,ImageType<T> imageType){
  if (config == null)   config=new ConfigFh04();
  FhEdgeWeights<T> edgeWeights=weightsFelzenszwalb04(config.connectRule,imageType);
  SegmentFelzenszwalbHuttenlocher04<T> alg=new SegmentFelzenszwalbHuttenlocher04<T>(config.K,config.minimumRegionSize,edgeWeights);
  if (config.approximateSortBins > 0) {
    alg.configureApproximateSort(config.approximateSortBins);
  }
  return alg;
}",0.9643564356435644
150980,"public SURF(){
  detector=FactoryDetectDescribe.surfFast(new ConfigFastHessian(20,2,-1,1,9,4,4),null,null,ImageType.single(imageType));
}","public SURF(){
  detector=FactoryDetectDescribe.surfFast(new ConfigFastHessian(20,2,-1,1,9,4,4),null,null,imageType);
}",0.9296875
150981,"public VisualizeAssociationAlgorithmsApp(Class<T> imageType){
  super(1);
  this.imageType=imageType;
  detector=(DetectDescribePoint)FactoryDetectDescribe.surfStable(new ConfigFastHessian(5,4,200,1,9,4,4),null,null,ImageType.single(ImageFloat32.class));
  int DOF=detector.createDescription().size();
  ScoreAssociation<TupleDesc_F64> score=FactoryAssociation.scoreEuclidean(TupleDesc_F64.class,true);
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.greedy(score,Double.MAX_VALUE,false));
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.greedy(score,Double.MAX_VALUE,true));
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.kdtree(DOF,75));
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.kdRandomForest(DOF,75,10,5,1233445565));
  image0=GeneralizedImageOps.createSingleBand(imageType,1,1);
  image1=GeneralizedImageOps.createSingleBand(imageType,1,1);
  setMainGUI(panel);
}","public VisualizeAssociationAlgorithmsApp(Class<T> imageType){
  super(1);
  this.imageType=imageType;
  detector=(DetectDescribePoint)FactoryDetectDescribe.surfStable(new ConfigFastHessian(5,4,200,1,9,4,4),null,null,ImageFloat32.class);
  int DOF=detector.createDescription().size();
  ScoreAssociation<TupleDesc_F64> score=FactoryAssociation.scoreEuclidean(TupleDesc_F64.class,true);
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.greedy(score,Double.MAX_VALUE,false));
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.greedy(score,Double.MAX_VALUE,true));
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.kdtree(DOF,75));
  addAlgorithm(0,""String_Node_Str"",FactoryAssociation.kdRandomForest(DOF,75,10,5,1233445565));
  image0=GeneralizedImageOps.createSingleBand(imageType,1,1);
  image1=GeneralizedImageOps.createSingleBand(imageType,1,1);
  setMainGUI(panel);
}",0.98989898989899
150982,"public static void main(String args[]){
  Class imageType=ImageFloat32.class;
  DetectDescribePoint detDesc=FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,ImageType.single(imageType));
  ScoreAssociation scorer=FactoryAssociation.defaultScore(detDesc.getDescriptionType());
  AssociateDescription associate=FactoryAssociation.greedy(scorer,Double.MAX_VALUE,true);
  ExampleAssociatePoints app=new ExampleAssociatePoints(detDesc,associate,imageType);
  BufferedImage imageA=UtilImageIO.loadImage(""String_Node_Str"");
  BufferedImage imageB=UtilImageIO.loadImage(""String_Node_Str"");
  app.associate(imageA,imageB);
}","public static void main(String args[]){
  Class imageType=ImageFloat32.class;
  DetectDescribePoint detDesc=FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,imageType);
  ScoreAssociation scorer=FactoryAssociation.defaultScore(detDesc.getDescriptionType());
  AssociateDescription associate=FactoryAssociation.greedy(scorer,Double.MAX_VALUE,true);
  ExampleAssociatePoints app=new ExampleAssociatePoints(detDesc,associate,imageType);
  BufferedImage imageA=UtilImageIO.loadImage(""String_Node_Str"");
  BufferedImage imageB=UtilImageIO.loadImage(""String_Node_Str"");
  app.associate(imageA,imageB);
}",0.9843505477308294
150983,"/** 
 * For some features, there are pre-made implementations of DetectDescribePoint.  This has only been done in situations where there was a performance advantage or that it was a very common combination.
 */
public static <T extends ImageSingleBand,TD extends TupleDesc>DetectDescribePoint<T,TD> createFromPremade(Class<T> imageType){
  return (DetectDescribePoint)FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,ImageType.single(imageType));
}","/** 
 * For some features, there are pre-made implementations of DetectDescribePoint.  This has only been done in situations where there was a performance advantage or that it was a very common combination.
 */
public static <T extends ImageSingleBand,TD extends TupleDesc>DetectDescribePoint<T,TD> createFromPremade(Class<T> imageType){
  return (DetectDescribePoint)FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,imageType);
}",0.9788135593220338
150984,"/** 
 * Use generalized interfaces for working with SURF.  This removes much of the drudgery, but also reduces flexibility and slightly increases memory and computational requirements.
 * @param image Input image type. DOES NOT NEED TO BE ImageFloat32, ImageUInt8 works too
 */
public static void easy(ImageFloat32 image){
  DetectDescribePoint<ImageFloat32,SurfFeature> surf=FactoryDetectDescribe.surfStable(new ConfigFastHessian(0,2,200,2,9,4,4),null,null,ImageType.single(ImageFloat32.class));
  surf.detect(image);
  System.out.println(""String_Node_Str"" + surf.getNumberOfFeatures());
  System.out.println(""String_Node_Str"" + surf.getDescription(0).value[0]);
}","/** 
 * Use generalized interfaces for working with SURF.  This removes much of the drudgery, but also reduces flexibility and slightly increases memory and computational requirements.
 * @param image Input image type. DOES NOT NEED TO BE ImageFloat32, ImageUInt8 works too
 */
public static void easy(ImageFloat32 image){
  DetectDescribePoint<ImageFloat32,SurfFeature> surf=FactoryDetectDescribe.surfStable(new ConfigFastHessian(0,2,200,2,9,4,4),null,null,ImageFloat32.class);
  surf.detect(image);
  System.out.println(""String_Node_Str"" + surf.getNumberOfFeatures());
  System.out.println(""String_Node_Str"" + surf.getDescription(0).value[0]);
}",0.986280487804878
150985,"/** 
 * Given two input images create and display an image where the two have been overlayed on top of each other.
 */
public static <T extends ImageSingleBand>void stitch(BufferedImage imageA,BufferedImage imageB,Class<T> imageType){
  T inputA=ConvertBufferedImage.convertFromSingle(imageA,null,imageType);
  T inputB=ConvertBufferedImage.convertFromSingle(imageB,null,imageType);
  DetectDescribePoint detDesc=FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,ImageType.single(imageType));
  ScoreAssociation<SurfFeature> scorer=FactoryAssociation.scoreEuclidean(SurfFeature.class,true);
  AssociateDescription<SurfFeature> associate=FactoryAssociation.greedy(scorer,2,true);
  ModelManager<Homography2D_F64> manager=new ModelManagerHomography2D_F64();
  GenerateHomographyLinear modelFitter=new GenerateHomographyLinear(true);
  DistanceHomographySq distance=new DistanceHomographySq();
  ModelMatcher<Homography2D_F64,AssociatedPair> modelMatcher=new Ransac<Homography2D_F64,AssociatedPair>(123,manager,modelFitter,distance,60,9);
  Homography2D_F64 H=computeTransform(inputA,inputB,detDesc,associate,modelMatcher);
  renderStitching(imageA,imageB,H);
}","/** 
 * Given two input images create and display an image where the two have been overlayed on top of each other.
 */
public static <T extends ImageSingleBand>void stitch(BufferedImage imageA,BufferedImage imageB,Class<T> imageType){
  T inputA=ConvertBufferedImage.convertFromSingle(imageA,null,imageType);
  T inputB=ConvertBufferedImage.convertFromSingle(imageB,null,imageType);
  DetectDescribePoint detDesc=FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,imageType);
  ScoreAssociation<SurfFeature> scorer=FactoryAssociation.scoreEuclidean(SurfFeature.class,true);
  AssociateDescription<SurfFeature> associate=FactoryAssociation.greedy(scorer,2,true);
  ModelManager<Homography2D_F64> manager=new ModelManagerHomography2D_F64();
  GenerateHomographyLinear modelFitter=new GenerateHomographyLinear(true);
  DistanceHomographySq distance=new DistanceHomographySq();
  ModelMatcher<Homography2D_F64,AssociatedPair> modelMatcher=new Ransac<Homography2D_F64,AssociatedPair>(123,manager,modelFitter,distance,60,9);
  Homography2D_F64 H=computeTransform(inputA,inputB,detDesc,associate,modelMatcher);
  renderStitching(imageA,imageB,H);
}",0.991532599491956
150986,"/** 
 * Use the associate point feature example to create a list of   {@link AssociatedPair} for use in computing thefundamental matrix.
 */
public static List<AssociatedPair> computeMatches(BufferedImage left,BufferedImage right){
  DetectDescribePoint detDesc=FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,ImageType.single(ImageFloat32.class));
  ScoreAssociation<SurfFeature> scorer=FactoryAssociation.scoreEuclidean(SurfFeature.class,true);
  AssociateDescription<SurfFeature> associate=FactoryAssociation.greedy(scorer,1,true);
  ExampleAssociatePoints<ImageFloat32,SurfFeature> findMatches=new ExampleAssociatePoints<ImageFloat32,SurfFeature>(detDesc,associate,ImageFloat32.class);
  findMatches.associate(left,right);
  List<AssociatedPair> matches=new ArrayList<AssociatedPair>();
  FastQueue<AssociatedIndex> matchIndexes=associate.getMatches();
  for (int i=0; i < matchIndexes.size; i++) {
    AssociatedIndex a=matchIndexes.get(i);
    AssociatedPair p=new AssociatedPair(findMatches.pointsA.get(a.src),findMatches.pointsB.get(a.dst));
    matches.add(p);
  }
  return matches;
}","/** 
 * Use the associate point feature example to create a list of   {@link AssociatedPair} for use in computing thefundamental matrix.
 */
public static List<AssociatedPair> computeMatches(BufferedImage left,BufferedImage right){
  DetectDescribePoint detDesc=FactoryDetectDescribe.surfStable(new ConfigFastHessian(1,2,200,1,9,4,4),null,null,ImageFloat32.class);
  ScoreAssociation<SurfFeature> scorer=FactoryAssociation.scoreEuclidean(SurfFeature.class,true);
  AssociateDescription<SurfFeature> associate=FactoryAssociation.greedy(scorer,1,true);
  ExampleAssociatePoints<ImageFloat32,SurfFeature> findMatches=new ExampleAssociatePoints<ImageFloat32,SurfFeature>(detDesc,associate,ImageFloat32.class);
  findMatches.associate(left,right);
  List<AssociatedPair> matches=new ArrayList<AssociatedPair>();
  FastQueue<AssociatedIndex> matchIndexes=associate.getMatches();
  for (int i=0; i < matchIndexes.size; i++) {
    AssociatedIndex a=matchIndexes.get(i);
    AssociatedPair p=new AssociatedPair(findMatches.pointsA.get(a.src),findMatches.pointsB.get(a.dst));
    matches.add(p);
  }
  return matches;
}",0.9919499105545616
150987,"/** 
 * Creates a non-linear optimizer for refining estimates of homography matrices.
 * @param tol Tolerance for convergence.  Try 1e-8
 * @param maxIterations Maximum number of iterations it will perform.  Try 100 or more.
 * @return Homography refinement
 */
public static RefineEpipolar refineHomography(double tol,int maxIterations,EpipolarError type){
  ModelObservationResidualN residuals;
switch (type) {
case SIMPLE:
    residuals=new HomographyResidualSampson();
  break;
case SAMPSON:
residuals=new HomographyResidualTransfer();
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
return new LeastSquaresHomography(tol,maxIterations,residuals);
}","/** 
 * Creates a non-linear optimizer for refining estimates of homography matrices.
 * @see HomographyResidualSampson
 * @see HomographyResidualTransfer
 * @param tol Tolerance for convergence.  Try 1e-8
 * @param maxIterations Maximum number of iterations it will perform.  Try 100 or more.
 * @return Homography refinement
 */
public static RefineEpipolar refineHomography(double tol,int maxIterations,EpipolarError type){
  ModelObservationResidualN residuals;
switch (type) {
case SIMPLE:
    residuals=new HomographyResidualSampson();
  break;
case SAMPSON:
residuals=new HomographyResidualTransfer();
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
return new LeastSquaresHomography(tol,maxIterations,residuals);
}",0.952116585704372
150988,"/** 
 * Returns an algorithm for estimating a homography matrix given a set of  {@link AssociatedPair}.
 * @param normalize If input is in pixel coordinates set to true.  False if in normalized image coordinates.
 * @return Homography estimator.
 */
public static Estimate1ofEpipolar computeHomography(boolean normalize){
  HomographyLinear4 alg=new HomographyLinear4(normalize);
  return new WrapHomographyLinear(alg);
}","/** 
 * Returns an algorithm for estimating a homography matrix given a set of  {@link AssociatedPair}.
 * @see HomographyLinear4
 * @param normalize If input is in pixel coordinates set to true.  False if in normalized image coordinates.
 * @return Homography estimator.
 */
public static Estimate1ofEpipolar computeHomography(boolean normalize){
  HomographyLinear4 alg=new HomographyLinear4(normalize);
  return new WrapHomographyLinear(alg);
}",0.9700460829493088
150989,"/** 
 * Computes the value of the specified fern at the specified location in the image.
 */
protected int computeFernValue(float c_x,float c_y,float rectWidth,float rectHeight,TldFernDescription fern){
  int desc=0;
  for (int i=0; i < fern.pairs.length; i++) {
    Point2D_F32 p_a=fern.pairs[i].a;
    Point2D_F32 p_b=fern.pairs[i].b;
    float valA=interpolate.get_fast(c_x + p_a.x * rectWidth,c_y + p_a.y * rectHeight);
    float valB=interpolate.get_fast(c_x + p_b.x * rectWidth,c_y + p_b.y * rectHeight);
    desc*=2;
    if (valA < valB) {
      desc+=1;
    }
  }
  return desc;
}","/** 
 * Computes the value of the specified fern at the specified location in the image.
 */
protected int computeFernValue(float c_x,float c_y,float rectWidth,float rectHeight,TldFernDescription fern){
  rectWidth-=1;
  rectHeight-=1;
  int desc=0;
  for (int i=0; i < fern.pairs.length; i++) {
    Point2D_F32 p_a=fern.pairs[i].a;
    Point2D_F32 p_b=fern.pairs[i].b;
    float valA=interpolate.get_fast(c_x + p_a.x * rectWidth,c_y + p_a.y * rectHeight);
    float valB=interpolate.get_fast(c_x + p_b.x * rectWidth,c_y + p_b.y * rectHeight);
    desc*=2;
    if (valA < valB) {
      desc+=1;
    }
  }
  return desc;
}",0.9727047146401984
150990,"/** 
 * Computes the value of a fern after adding noise to the image being sampled.
 */
protected int computeFernValueRand(float c_x,float c_y,float rectWidth,float rectHeight,TldFernDescription fern){
  int desc=0;
  for (int i=0; i < fern.pairs.length; i++) {
    Point2D_F32 p_a=fern.pairs[i].a;
    Point2D_F32 p_b=fern.pairs[i].b;
    float valA=interpolate.get_fast(c_x + p_a.x * rectWidth,c_y + p_a.y * rectHeight);
    float valB=interpolate.get_fast(c_x + p_b.x * rectWidth,c_y + p_b.y * rectHeight);
    valA+=rand.nextGaussian() * fernLearnNoise;
    valB+=rand.nextGaussian() * fernLearnNoise;
    desc*=2;
    if (valA < valB) {
      desc+=1;
    }
  }
  return desc;
}","/** 
 * Computes the value of a fern after adding noise to the image being sampled.
 */
protected int computeFernValueRand(float c_x,float c_y,float rectWidth,float rectHeight,TldFernDescription fern){
  rectWidth-=1;
  rectHeight-=1;
  int desc=0;
  for (int i=0; i < fern.pairs.length; i++) {
    Point2D_F32 p_a=fern.pairs[i].a;
    Point2D_F32 p_b=fern.pairs[i].b;
    float valA=interpolate.get_fast(c_x + p_a.x * rectWidth,c_y + p_a.y * rectHeight);
    float valB=interpolate.get_fast(c_x + p_b.x * rectWidth,c_y + p_b.y * rectHeight);
    valA+=rand.nextGaussian() * fernLearnNoise;
    valB+=rand.nextGaussian() * fernLearnNoise;
    desc*=2;
    if (valA < valB) {
      desc+=1;
    }
  }
  return desc;
}",0.9764117226590422
150991,"/** 
 * Call for the first image being tracked
 * @param image Most recent video image.
 */
public void initialize(PyramidDiscrete<Image> image){
  if (previousDerivX == null || previousDerivX.length != image.getNumLayers()) {
    declareDataStructures(image);
  }
  for (int i=0; i < image.getNumLayers(); i++) {
    gradient.process(image.getLayer(i),previousDerivX[i],previousDerivY[i]);
  }
  previousImage.setTo(image);
}","/** 
 * Call for the first image being tracked
 * @param image Most recent video image.
 */
public void initialize(PyramidDiscrete<Image> image){
  if (previousDerivX == null || previousDerivX.length != image.getNumLayers() || previousImage.getInputWidth() != image.getInputWidth() || previousImage.getInputHeight() != image.getInputHeight()) {
    declareDataStructures(image);
  }
  for (int i=0; i < image.getNumLayers(); i++) {
    gradient.process(image.getLayer(i),previousDerivX[i],previousDerivY[i]);
  }
  previousImage.setTo(image);
}",0.8783505154639175
150992,"/** 
 * Starts tracking the rectangular region.
 * @param image First image in the sequence.
 * @param x0 Top-left corner of rectangle. x-axis
 * @param y0 Top-left corner of rectangle. y-axis
 * @param x1 Bottom-right corner of rectangle. x-axis
 * @param y1 Bottom-right corner of rectangle. y-axis
 */
public void initialize(T image,int x0,int y0,int x1,int y1){
  if (imagePyramid == null) {
    int minSize=(config.trackerFeatureRadius * 2 + 1) * 5;
    int scales[]=selectPyramidScale(image.width,image.height,minSize);
    imagePyramid=FactoryPyramid.discreteGaussian(scales,-1,1,true,(Class<T>)image.getClass());
  }
  imagePyramid.process(image);
  reacquiring=false;
  targetRegion.set(x0,y0,x1,y1);
  createCascadeRegion(image.width,image.height);
  template.reset();
  fern.reset();
  tracking.initialize(imagePyramid);
  variance.setImage(image);
  template.setImage(image);
  fern.setImage(image);
  adjustRegion.init(image.width,image.height);
  learning.initialLearning(targetRegion,cascadeRegions);
  strongMatch=true;
  previousTrackArea=targetRegion.area();
}","/** 
 * Starts tracking the rectangular region.
 * @param image First image in the sequence.
 * @param x0 Top-left corner of rectangle. x-axis
 * @param y0 Top-left corner of rectangle. y-axis
 * @param x1 Bottom-right corner of rectangle. x-axis
 * @param y1 Bottom-right corner of rectangle. y-axis
 */
public void initialize(T image,int x0,int y0,int x1,int y1){
  if (imagePyramid == null || imagePyramid.getInputWidth() != image.width || imagePyramid.getInputHeight() != image.height) {
    int minSize=(config.trackerFeatureRadius * 2 + 1) * 5;
    int scales[]=selectPyramidScale(image.width,image.height,minSize);
    imagePyramid=FactoryPyramid.discreteGaussian(scales,-1,1,true,(Class<T>)image.getClass());
  }
  imagePyramid.process(image);
  reacquiring=false;
  targetRegion.set(x0,y0,x1,y1);
  createCascadeRegion(image.width,image.height);
  template.reset();
  fern.reset();
  tracking.initialize(imagePyramid);
  variance.setImage(image);
  template.setImage(image);
  fern.setImage(image);
  adjustRegion.init(image.width,image.height);
  learning.initialLearning(targetRegion,cascadeRegions);
  strongMatch=true;
  previousTrackArea=targetRegion.area();
}",0.9573712255772646
150993,"/** 
 * Returns true if the features is entirely outside of the image.
 */
public boolean isFullyOutside(float x,float y){
  if (x < outsideLeft || x >= outsideRight)   return true;
  if (y < outsideTop || y >= outsideBottom)   return true;
  return false;
}","/** 
 * Returns true if the features is entirely outside of the image.  A region is entirely outside if not an entire pixel is contained inside the image.  So if only  0.999 of a pixel is inside then the whole region is considered to be outside.  Can't interpolate nothing...
 */
public boolean isFullyOutside(float x,float y){
  if (x < outsideLeft || x > outsideRight)   return true;
  if (y < outsideTop || y > outsideBottom)   return true;
  return false;
}",0.7121001390820584
150994,"private void computeE(KltFeature feature,float x,float y){
  interpInput.region(x - feature.radius,y - feature.radius,descFeature);
  Ex=0;
  Ey=0;
  for (int i=0; i < lengthFeature; i++) {
    float d=feature.desc.data[i] - descFeature.data[i];
    Ex+=d * feature.derivX.data[i];
    Ey+=d * feature.derivY.data[i];
  }
}","protected void computeE(KltFeature feature,float x,float y){
  interpInput.region(x - feature.radius,y - feature.radius,descFeature);
  Ex=0;
  Ey=0;
  for (int i=0; i < lengthFeature; i++) {
    float d=feature.desc.data[i] - descFeature.data[i];
    Ex+=d * feature.derivX.data[i];
    Ey+=d * feature.derivY.data[i];
  }
}",0.9814814814814816
150995,"/** 
 * Sets the features description using the current image and the location of the feature stored in the feature. If the feature is an illegal location and cannot be set then false is returned.
 * @param feature Feature description which is to be set.  Location must be specified.
 * @return true if the feature's description was modified.
 */
@SuppressWarnings({""String_Node_Str""}) public boolean setDescription(KltFeature feature){
  if (derivX == null || derivY == null)   throw new IllegalArgumentException(""String_Node_Str"");
  setAllowedBounds(feature);
  if (!isFullyInside(feature.x,feature.y)) {
    if (isFullyOutside(feature.x,feature.y))     return false;
 else     return internalSetDescriptionBorder(feature);
  }
  return internalSetDescription(feature);
}","/** 
 * Sets the features description using the current image and the location of the feature stored in the feature. If the feature is an illegal location and cannot be set then false is returned.
 * @param feature Feature description which is to be set.  Location must be specified.
 * @return true if the feature's description was modified.
 */
@SuppressWarnings({""String_Node_Str""}) public boolean setDescription(KltFeature feature){
  setAllowedBounds(feature);
  if (!isFullyInside(feature.x,feature.y)) {
    if (isFullyOutside(feature.x,feature.y))     return false;
 else     return internalSetDescriptionBorder(feature);
  }
  return internalSetDescription(feature);
}",0.9331495520330806
150996,"/** 
 * When part of the region is outside the image G and E need to be recomputed
 */
private int computeGandE_border(KltFeature feature,float cx,float cy){
  int total=0;
  Gxx=0;
  Gyy=0;
  Gxy=0;
  Ex=0;
  Ey=0;
  int i=0;
  for (int y=0; y < widthFeature; y++) {
    float pixelY=cy - feature.radius + y;
    for (int x=0; x < widthFeature; x++, i++) {
      if (Float.isNaN(feature.desc.data[i]))       continue;
      float pixelX=cx - feature.radius + x;
      float dX, dY, value;
      if (interpPixelDX.isInFastBounds(pixelX,pixelY)) {
        value=interpPixelI.get_fast(pixelX,pixelY);
        dX=interpPixelDX.get_fast(pixelX,pixelY);
        dY=interpPixelDY.get_fast(pixelX,pixelY);
      }
 else       if (image.isInBounds((int)pixelX,(int)pixelY)) {
        value=interpPixelI.get(pixelX,pixelY);
        dX=interpPixelDX.get(pixelX,pixelY);
        dY=interpPixelDY.get(pixelX,pixelY);
      }
 else {
        descFeature.data[i]=Float.NaN;
        continue;
      }
      descFeature.data[i]=value;
      total++;
      float d=feature.desc.data[i] - value;
      Ex+=d * feature.derivX.data[i];
      Ey+=d * feature.derivY.data[i];
      Gxx+=dX * dX;
      Gyy+=dY * dY;
      Gxy+=dX * dY;
    }
  }
  return total;
}","/** 
 * When part of the region is outside the image G and E need to be recomputed
 */
protected int computeGandE_border(KltFeature feature,float cx,float cy){
  int total=0;
  Gxx=0;
  Gyy=0;
  Gxy=0;
  Ex=0;
  Ey=0;
  int i=0;
  for (int y=0; y < widthFeature; y++) {
    float pixelY=cy - feature.radius + y;
    for (int x=0; x < widthFeature; x++, i++) {
      if (Float.isNaN(feature.desc.data[i]))       continue;
      float pixelX=cx - feature.radius + x;
      float dX, dY, value;
      if (interpPixelI.isInFastBounds(pixelX,pixelY)) {
        value=interpPixelI.get_fast(pixelX,pixelY);
      }
 else       if (image.isInBounds((int)pixelX,(int)pixelY)) {
        value=interpPixelI.get(pixelX,pixelY);
      }
 else {
        descFeature.data[i]=Float.NaN;
        continue;
      }
      descFeature.data[i]=value;
      total++;
      dX=feature.derivX.data[i];
      dY=feature.derivY.data[i];
      float d=feature.desc.data[i] - value;
      Ex+=d * dX;
      Ey+=d * dY;
      Gxx+=dX * dX;
      Gyy+=dY * dY;
      Gxy+=dX * dY;
    }
  }
  return total;
}",0.5778352738249245
150997,"private void setAllowedBounds(KltFeature feature){
  allowedLeft=feature.radius + config.forbiddenBorder;
  allowedTop=feature.radius + config.forbiddenBorder;
  allowedRight=image.width - (feature.radius + config.forbiddenBorder);
  allowedBottom=image.height - (feature.radius + config.forbiddenBorder);
  outsideLeft=-feature.radius + config.forbiddenBorder;
  outsideTop=-feature.radius + config.forbiddenBorder;
  outsideRight=image.width + (feature.radius - config.forbiddenBorder);
  outsideBottom=image.height + (feature.radius - config.forbiddenBorder);
}","/** 
 * Precompute image bounds that the feature is allowed inside of
 */
protected void setAllowedBounds(KltFeature feature){
  widthFeature=feature.radius * 2 + 1;
  lengthFeature=widthFeature * widthFeature;
  allowedLeft=feature.radius;
  allowedTop=feature.radius;
  allowedRight=image.width - feature.radius - 1;
  allowedBottom=image.height - feature.radius - 1;
  outsideLeft=-feature.radius;
  outsideTop=-feature.radius;
  outsideRight=image.width + feature.radius - 1;
  outsideBottom=image.height + feature.radius - 1;
}",0.1532846715328467
150998,"/** 
 * Returns true if the features is entirely enclosed inside of the image.
 */
public boolean isFullyInside(float x,float y){
  if (x < allowedLeft || x >= allowedRight)   return false;
  if (y < allowedTop || y >= allowedBottom)   return false;
  return true;
}","/** 
 * Returns true if the features is entirely enclosed inside of the image.
 */
public boolean isFullyInside(float x,float y){
  if (x < allowedLeft || x > allowedRight)   return false;
  if (y < allowedTop || y > allowedBottom)   return false;
  return true;
}",0.9962264150943396
150999,"/** 
 * Computes the descriptor for border features.  All it needs to do is save the pixel value, but derivative information is also computed so that it can reject bad features immediately.
 */
private boolean internalSetDescriptionBorder(KltFeature feature){
  int total=0;
  Gxx=Gyy=Gxy=0;
  int i=0;
  for (int y=0; y < widthFeature; y++) {
    float pixelY=feature.y - feature.radius + y;
    for (int x=0; x < widthFeature; x++, i++) {
      float pixelX=feature.x - feature.radius + x;
      float dX, dY, value;
      if (interpPixelDX.isInFastBounds(pixelX,pixelY)) {
        value=interpPixelI.get_fast(pixelX,pixelY);
        dX=interpPixelDX.get_fast(pixelX,pixelY);
        dY=interpPixelDY.get_fast(pixelX,pixelY);
      }
 else       if (image.isInBounds((int)pixelX,(int)pixelY)) {
        value=interpPixelI.get(pixelX,pixelY);
        dX=interpPixelDX.get(pixelX,pixelY);
        dY=interpPixelDY.get(pixelX,pixelY);
      }
 else {
        feature.desc.data[i]=Float.NaN;
        continue;
      }
      total++;
      feature.desc.data[i]=value;
      Gxx+=dX * dX;
      Gyy+=dY * dY;
      Gxy+=dX * dY;
    }
  }
  feature.Gxx=Gxx;
  feature.Gyy=Gyy;
  feature.Gxy=Gxy;
  float det=Gxx * Gyy - Gxy * Gxy;
  return (det >= config.minDeterminant * total);
}","/** 
 * Computes the descriptor for border features.  All it needs to do is save the pixel value, but derivative information is also computed so that it can reject bad features immediately.
 */
private boolean internalSetDescriptionBorder(KltFeature feature){
  int total=0;
  Gxx=Gyy=Gxy=0;
  int i=0;
  for (int y=0; y < widthFeature; y++) {
    float pixelY=feature.y - feature.radius + y;
    for (int x=0; x < widthFeature; x++, i++) {
      float pixelX=feature.x - feature.radius + x;
      float dX, dY, value;
      if (interpPixelI.isInFastBounds(pixelX,pixelY)) {
        value=interpPixelI.get_fast(pixelX,pixelY);
        dX=interpPixelDX.get_fast(pixelX,pixelY);
        dY=interpPixelDY.get_fast(pixelX,pixelY);
      }
 else       if (image.isInBounds((int)pixelX,(int)pixelY)) {
        value=interpPixelI.get(pixelX,pixelY);
        dX=interpPixelDX.get(pixelX,pixelY);
        dY=interpPixelDY.get(pixelX,pixelY);
      }
 else {
        feature.desc.data[i]=Float.NaN;
        continue;
      }
      total++;
      feature.desc.data[i]=value;
      feature.derivX.data[i]=dX;
      feature.derivY.data[i]=dY;
      Gxx+=dX * dX;
      Gyy+=dY * dY;
      Gxy+=dX * dY;
    }
  }
  feature.Gxx=Gxx;
  feature.Gyy=Gyy;
  feature.Gxy=Gxy;
  float det=Gxx * Gyy - Gxy * Gxy;
  return (det >= config.minDeterminant * total);
}",0.9736540664375716
151000,"/** 
 * <p> Updates the feature's location inside the image.  The feature's position can be modified even if tracking fails. </p>
 * @param feature Feature being tracked.
 * @return If the tracking was successful or not.
 */
public KltTrackFault track(KltFeature feature){
  widthFeature=feature.radius * 2 + 1;
  lengthFeature=widthFeature * widthFeature;
  boolean startedOutside;
  if (descFeature.data.length < lengthFeature)   descFeature.reshape(widthFeature,widthFeature);
  float origX=feature.x, origY=feature.y;
  setAllowedBounds(feature);
  float det=0;
  if (isFullyInside(feature.x,feature.y)) {
    startedOutside=false;
    Gxx=feature.Gxx;
    Gyy=feature.Gyy;
    Gxy=feature.Gxy;
    det=Gxx * Gyy - Gxy * Gxy;
    if (det < config.minDeterminant * lengthFeature) {
      return KltTrackFault.FAILED;
    }
  }
 else {
    startedOutside=true;
  }
  for (int iter=0; iter < config.maxIterations; iter++) {
    float dx, dy;
    if (!startedOutside && isFullyInside(feature.x,feature.y)) {
      computeE(feature,feature.x,feature.y);
    }
 else {
      int length=computeGandE_border(feature,feature.x,feature.y);
      det=Gxx * Gyy - Gxy * Gxy;
      if (det < config.minDeterminant * length) {
        return KltTrackFault.FAILED;
      }
    }
    dx=(Gyy * Ex - Gxy * Ey) / det;
    dy=(Gxx * Ey - Gxy * Ex) / det;
    feature.x+=dx;
    feature.y+=dy;
    if (isFullyOutside(feature.x,feature.y))     return KltTrackFault.OUT_OF_BOUNDS;
    if (Math.abs(feature.x - origX) > widthFeature || Math.abs(feature.y - origY) > widthFeature)     return KltTrackFault.DRIFTED;
    if (Math.abs(dx) < config.minPositionDelta && Math.abs(dy) < config.minPositionDelta) {
      break;
    }
  }
  if (computeError(feature) > config.maxPerPixelError)   return KltTrackFault.LARGE_ERROR;
  return KltTrackFault.SUCCESS;
}","/** 
 * <p> Updates the feature's location inside the image.  The feature's position can be modified even if tracking fails. </p>
 * @param feature Feature being tracked.
 * @return If the tracking was successful or not.
 */
public KltTrackFault track(KltFeature feature){
  setAllowedBounds(feature);
  if (descFeature.data.length < lengthFeature)   descFeature.reshape(widthFeature,widthFeature);
  float origX=feature.x, origY=feature.y;
  boolean complete=isDescriptionComplete(feature);
  float det=0;
  if (complete) {
    Gxx=feature.Gxx;
    Gyy=feature.Gyy;
    Gxy=feature.Gxy;
    det=Gxx * Gyy - Gxy * Gxy;
    if (det < config.minDeterminant * lengthFeature) {
      return KltTrackFault.FAILED;
    }
  }
  for (int iter=0; iter < config.maxIterations; iter++) {
    float dx, dy;
    if (complete && isFullyInside(feature.x,feature.y)) {
      computeE(feature,feature.x,feature.y);
    }
 else {
      int length=computeGandE_border(feature,feature.x,feature.y);
      det=Gxx * Gyy - Gxy * Gxy;
      if (det < config.minDeterminant * length) {
        return KltTrackFault.FAILED;
      }
    }
    dx=(Gyy * Ex - Gxy * Ey) / det;
    dy=(Gxx * Ey - Gxy * Ex) / det;
    feature.x+=dx;
    feature.y+=dy;
    if (isFullyOutside(feature.x,feature.y))     return KltTrackFault.OUT_OF_BOUNDS;
    if (Math.abs(feature.x - origX) > widthFeature || Math.abs(feature.y - origY) > widthFeature)     return KltTrackFault.DRIFTED;
    if (Math.abs(dx) < config.minPositionDelta && Math.abs(dy) < config.minPositionDelta) {
      break;
    }
  }
  if (computeError(feature) > config.maxPerPixelError)   return KltTrackFault.LARGE_ERROR;
  return KltTrackFault.SUCCESS;
}",0.9120409906063194
