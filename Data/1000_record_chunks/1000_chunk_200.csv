record_number,buggy_code,fixed_code,code_similarity
199001,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (Console.Enabled) {
    Console.logDivider(Constants.Log.App.SystemUIHandshake);
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
    Console.logTraceTime(Constants.Log.App.TimeRecentsStartup,Constants.Log.App.TimeRecentsStartupKey,""String_Node_Str"");
  }
  RecentsTaskLoader.initialize(this);
  mConfig=RecentsConfiguration.reinitialize(this);
  Intent homeIntent=new Intent(Intent.ACTION_MAIN,null);
  homeIntent.addCategory(Intent.CATEGORY_HOME);
  homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mFinishLaunchHomeRunnable=new FinishRecentsRunnable(homeIntent,ActivityOptions.makeCustomAnimation(this,R.anim.recents_to_launcher_enter,R.anim.recents_to_launcher_exit));
  mAppWidgetHost=new RecentsAppWidgetHost(this,Constants.Values.App.AppWidgetHostId);
  setContentView(R.layout.recents);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setCallbacks(this);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mEmptyViewStub=(ViewStub)findViewById(R.id.empty_view_stub);
  mFullscreenOverlayStub=(ViewStub)findViewById(R.id.fullscreen_overlay_stub);
  mScrimViews=new SystemBarScrimViews(this,mConfig);
  updateRecentsTasks(getIntent());
  if (Constants.DebugFlags.App.EnableScreenshotAppTransition) {
    mFullScreenOverlayView=(FullscreenTransitionOverlayView)mFullscreenOverlayStub.inflate();
    mFullScreenOverlayView.setCallbacks(this);
    mFullScreenOverlayView.prepareAnimateOnEnterRecents(AlternateRecentsComponent.getLastScreenshot());
  }
  bindSearchBarAppWidget();
  addSearchBarAppWidgetView();
  if (savedInstanceState != null) {
    onConfigurationChange();
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED);
  registerReceiver(mSystemBroadcastReceiver,filter);
  RecentsTaskLoader.getInstance().registerReceivers(this,mRecentsView);
  try {
    Utilities.setShadowProperty(""String_Node_Str"",String.valueOf(35f));
    Utilities.setShadowProperty(""String_Node_Str"",String.valueOf(0.5f));
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (Console.Enabled) {
    Console.logDivider(Constants.Log.App.SystemUIHandshake);
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
    Console.logTraceTime(Constants.Log.App.TimeRecentsStartup,Constants.Log.App.TimeRecentsStartupKey,""String_Node_Str"");
  }
  RecentsTaskLoader.initialize(this);
  mConfig=RecentsConfiguration.reinitialize(this);
  Intent homeIntent=new Intent(Intent.ACTION_MAIN,null);
  homeIntent.addCategory(Intent.CATEGORY_HOME);
  homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mFinishLaunchHomeRunnable=new FinishRecentsRunnable(homeIntent,ActivityOptions.makeCustomAnimation(this,R.anim.recents_to_launcher_enter,R.anim.recents_to_launcher_exit));
  mAppWidgetHost=new RecentsAppWidgetHost(this,Constants.Values.App.AppWidgetHostId);
  setContentView(R.layout.recents);
  mRecentsView=(RecentsView)findViewById(R.id.recents_view);
  mRecentsView.setCallbacks(this);
  mRecentsView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mEmptyViewStub=(ViewStub)findViewById(R.id.empty_view_stub);
  mFullscreenOverlayStub=(ViewStub)findViewById(R.id.fullscreen_overlay_stub);
  mScrimViews=new SystemBarScrimViews(this,mConfig);
  updateRecentsTasks(getIntent());
  bindSearchBarAppWidget();
  addSearchBarAppWidgetView();
  if (savedInstanceState != null) {
    onConfigurationChange();
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED);
  registerReceiver(mSystemBroadcastReceiver,filter);
  RecentsTaskLoader.getInstance().registerReceivers(this,mRecentsView);
  try {
    Utilities.setShadowProperty(""String_Node_Str"",String.valueOf(35f));
    Utilities.setShadowProperty(""String_Node_Str"",String.valueOf(0.5f));
  }
 catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
  if (Constants.DebugFlags.App.EnableScreenshotAppTransition) {
    mFullScreenOverlayView=(FullscreenTransitionOverlayView)mFullscreenOverlayStub.inflate();
    mFullScreenOverlayView.setCallbacks(this);
    mFullScreenOverlayView.prepareAnimateOnEnterRecents(AlternateRecentsComponent.getLastScreenshot());
  }
}",0.8796616685890042
199002,"/** 
 * Updates the set of recent tasks 
 */
void updateRecentsTasks(Intent launchIntent){
  RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
  SpaceNode root=loader.reload(this,Constants.Values.RecentsTaskLoader.PreloadFirstTasksCount);
  ArrayList<TaskStack> stacks=root.getStacks();
  if (!stacks.isEmpty()) {
    mRecentsView.setBSP(root);
  }
  mConfig.launchedFromHome=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_HOME,false);
  mConfig.launchedFromAppWithThumbnail=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_APP_THUMBNAIL,false);
  mConfig.launchedFromAppWithScreenshot=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_APP_FULL_SCREENSHOT,false);
  mConfig.launchedWithAltTab=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_TRIGGERED_FROM_ALT_TAB,false);
  mConfig.launchedWithNoRecentTasks=!root.hasTasks();
  mScrimViews.prepareEnterRecentsAnimation();
  if (mEmptyView == null) {
    mEmptyView=mEmptyViewStub.inflate();
  }
  if (mConfig.launchedWithNoRecentTasks) {
    mEmptyView.setVisibility(View.VISIBLE);
  }
 else {
    mEmptyView.setVisibility(View.GONE);
  }
}","/** 
 * Updates the set of recent tasks 
 */
void updateRecentsTasks(Intent launchIntent){
  RecentsTaskLoader loader=RecentsTaskLoader.getInstance();
  SpaceNode root=loader.reload(this,Constants.Values.RecentsTaskLoader.PreloadFirstTasksCount);
  ArrayList<TaskStack> stacks=root.getStacks();
  if (!stacks.isEmpty()) {
    mRecentsView.setBSP(root);
  }
  mConfig.launchedFromHome=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_HOME,false);
  mConfig.launchedFromAppWithThumbnail=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_APP_THUMBNAIL,false);
  mConfig.launchedFromAppWithScreenshot=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_FROM_APP_FULL_SCREENSHOT,false);
  mConfig.launchedWithAltTab=launchIntent.getBooleanExtra(AlternateRecentsComponent.EXTRA_TRIGGERED_FROM_ALT_TAB,false);
  mConfig.launchedWithNoRecentTasks=!root.hasTasks();
  if (mEmptyView == null) {
    mEmptyView=mEmptyViewStub.inflate();
  }
  if (mConfig.launchedWithNoRecentTasks) {
    mEmptyView.setVisibility(View.VISIBLE);
  }
 else {
    mEmptyView.setVisibility(View.GONE);
  }
  mScrimViews.prepareEnterRecentsAnimation();
}",0.9604471195184868
199003,"@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  if (Console.Enabled) {
    Console.logDivider(Constants.Log.App.SystemUIHandshake);
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
    Console.logTraceTime(Constants.Log.App.TimeRecentsStartup,Constants.Log.App.TimeRecentsStartupKey,""String_Node_Str"");
  }
  RecentsTaskLoader.initialize(this);
  mConfig=RecentsConfiguration.reinitialize(this);
  updateRecentsTasks(intent);
  if (Constants.DebugFlags.App.EnableScreenshotAppTransition) {
    mFullScreenOverlayView.prepareAnimateOnEnterRecents(AlternateRecentsComponent.getLastScreenshot());
  }
  addSearchBarAppWidgetView();
}","@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  if (Console.Enabled) {
    Console.logDivider(Constants.Log.App.SystemUIHandshake);
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
    Console.logTraceTime(Constants.Log.App.TimeRecentsStartup,Constants.Log.App.TimeRecentsStartupKey,""String_Node_Str"");
  }
  RecentsTaskLoader.initialize(this);
  mConfig=RecentsConfiguration.reinitialize(this);
  updateRecentsTasks(intent);
  if (Constants.DebugFlags.App.EnableScreenshotAppTransition) {
    mFullScreenOverlayView.prepareAnimateOnEnterRecents(AlternateRecentsComponent.getLastScreenshot());
  }
}",0.9640479360852195
199004,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  SharedPreferences settings=context.getSharedPreferences(context.getPackageName(),0);
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  debugModeEnabled=settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled,false);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_duration);
  filteringNewViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_duration);
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  isLandscape=res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
  transposeRecentsLayoutWithOrientation=res.getBoolean(R.bool.recents_transpose_layout_with_orientation);
  searchBarSpaceHeightPx=res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
  searchBarAppWidgetId=settings.getInt(Constants.Values.App.Key_SearchAppWidgetId,-1);
  TypedValue widthPaddingPctValue=new TypedValue();
  res.getValue(R.dimen.recents_stack_width_padding_percentage,widthPaddingPctValue,true);
  taskStackWidthPaddingPct=widthPaddingPctValue.getFloat();
  taskStackMaxDim=res.getInteger(R.integer.recents_max_task_stack_view_dim);
  taskStackTopPaddingPx=res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
  taskViewEnterFromHomeDuration=res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
  taskViewEnterFromHomeDelay=res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
  taskViewExitToHomeDuration=res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
  taskViewRemoveAnimDuration=res.getInteger(R.integer.recents_animate_task_view_remove_duration);
  taskViewRemoveAnimTranslationXPx=res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
  taskViewRoundedCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  taskViewHighlightPx=res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
  taskViewTranslationZMinPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  taskViewTranslationZIncrementPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_increment);
  taskViewShadowOutlineBottomInsetPx=res.getDimensionPixelSize(R.dimen.recents_task_view_shadow_outline_bottom_inset);
  taskBarViewDefaultBackgroundColor=res.getColor(R.color.recents_task_bar_default_background_color);
  taskBarViewLightTextColor=res.getColor(R.color.recents_task_bar_light_text_color);
  taskBarViewDarkTextColor=res.getColor(R.color.recents_task_bar_dark_text_color);
  taskBarViewHighlightColor=res.getColor(R.color.recents_task_bar_highlight_color);
  taskBarEnterAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
  taskBarEnterAnimDelay=res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
  taskBarExitAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
  taskBarDismissDozeDelaySeconds=res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  navBarScrimEnterDuration=res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",isLandscape ? ""String_Node_Str"" : ""String_Node_Str"",Console.AnsiGreen);
  }
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  SharedPreferences settings=context.getSharedPreferences(context.getPackageName(),0);
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  debugModeEnabled=settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled,false);
  if (debugModeEnabled) {
    Console.Enabled=true;
  }
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_duration);
  filteringNewViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_duration);
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  isLandscape=res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
  transposeRecentsLayoutWithOrientation=res.getBoolean(R.bool.recents_transpose_layout_with_orientation);
  searchBarSpaceHeightPx=res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
  searchBarAppWidgetId=settings.getInt(Constants.Values.App.Key_SearchAppWidgetId,-1);
  TypedValue widthPaddingPctValue=new TypedValue();
  res.getValue(R.dimen.recents_stack_width_padding_percentage,widthPaddingPctValue,true);
  taskStackWidthPaddingPct=widthPaddingPctValue.getFloat();
  taskStackMaxDim=res.getInteger(R.integer.recents_max_task_stack_view_dim);
  taskStackTopPaddingPx=res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
  taskViewEnterFromHomeDuration=res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
  taskViewEnterFromHomeDelay=res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
  taskViewExitToHomeDuration=res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
  taskViewRemoveAnimDuration=res.getInteger(R.integer.recents_animate_task_view_remove_duration);
  taskViewRemoveAnimTranslationXPx=res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
  taskViewRoundedCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  taskViewHighlightPx=res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
  taskViewTranslationZMinPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  taskViewTranslationZIncrementPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_increment);
  taskViewShadowOutlineBottomInsetPx=res.getDimensionPixelSize(R.dimen.recents_task_view_shadow_outline_bottom_inset);
  taskBarViewDefaultBackgroundColor=res.getColor(R.color.recents_task_bar_default_background_color);
  taskBarViewLightTextColor=res.getColor(R.color.recents_task_bar_light_text_color);
  taskBarViewDarkTextColor=res.getColor(R.color.recents_task_bar_dark_text_color);
  taskBarViewHighlightColor=res.getColor(R.color.recents_task_bar_highlight_color);
  taskBarEnterAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
  taskBarEnterAnimDelay=res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
  taskBarExitAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
  taskBarDismissDozeDelaySeconds=res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  navBarScrimEnterDuration=res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",isLandscape ? ""String_Node_Str"" : ""String_Node_Str"",Console.AnsiGreen);
  }
}",0.9920522282145898
199005,"@Override public void handleMessage(Message msg){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",msg);
  }
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == AlternateRecentsComponent.MSG_UPDATE_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration config=RecentsConfiguration.reinitialize(context);
    config.updateOnConfigurationChange();
    try {
      Bundle data=msg.getData();
      Rect windowRect=data.getParcelable(AlternateRecentsComponent.KEY_WINDOW_RECT);
      Rect systemInsets=data.getParcelable(AlternateRecentsComponent.KEY_SYSTEM_INSETS);
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      TaskStackViewLayoutAlgorithm algo=tsv.getStackAlgorithm();
      Bundle replyData=new Bundle();
      TaskViewTransform transform;
      Rect taskStackBounds=new Rect();
      config.getTaskStackBounds(windowRect.width(),windowRect.height(),taskStackBounds);
      stack.addTask(new Task());
      tsv.computeRects(taskStackBounds.width(),taskStackBounds.height() - systemInsets.top - systemInsets.bottom,0,0);
      tsv.setStackScrollToInitialState();
      transform=algo.getStackTransform(0,tsv.getStackScroll());
      transform.rect.offset(taskStackBounds.left,taskStackBounds.top);
      replyData.putParcelable(AlternateRecentsComponent.KEY_SINGLE_TASK_STACK_RECT,new Rect(transform.rect));
      stack.addTask(new Task());
      tsv.computeRects(taskStackBounds.width(),taskStackBounds.height() - systemInsets.top - systemInsets.bottom,0,0);
      tsv.setStackScrollToInitialState();
      transform=algo.getStackTransform(1,tsv.getStackScroll());
      transform.rect.offset(taskStackBounds.left,taskStackBounds.top);
      replyData.putParcelable(AlternateRecentsComponent.KEY_TWO_TASK_STACK_RECT,new Rect(transform.rect));
      stack.addTask(new Task());
      tsv.computeRects(taskStackBounds.width(),taskStackBounds.height() - systemInsets.top - systemInsets.bottom,0,0);
      tsv.setStackScrollToInitialState();
      transform=algo.getStackTransform(2,tsv.getStackScroll());
      transform.rect.offset(taskStackBounds.left,taskStackBounds.top);
      replyData.putParcelable(AlternateRecentsComponent.KEY_MULTIPLE_TASK_STACK_RECT,new Rect(transform.rect));
      data.putParcelable(AlternateRecentsComponent.KEY_CONFIGURATION_DATA,replyData);
      Message reply=Message.obtain(null,AlternateRecentsComponent.MSG_UPDATE_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == AlternateRecentsComponent.MSG_HIDE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_HIDE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (msg.arg1 != 0) {
      intent.putExtra(RecentsService.EXTRA_TRIGGERED_FROM_ALT_TAB,true);
    }
    context.sendBroadcast(intent);
  }
 else   if (msg.what == AlternateRecentsComponent.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    context.sendBroadcast(intent);
    if (Console.Enabled) {
      Console.logTraceTime(Constants.Log.App.TimeRecentsStartup,Constants.Log.App.TimeRecentsStartupKey,""String_Node_Str"");
      Console.logTraceTime(Constants.Log.App.TimeRecentsLaunchTask,Constants.Log.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
 else   if (msg.what == AlternateRecentsComponent.MSG_START_ENTER_ANIMATION) {
    Intent intent=new Intent(RecentsService.ACTION_START_ENTER_ANIMATION);
    intent.setPackage(context.getPackageName());
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",msg);
  }
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == AlternateRecentsComponent.MSG_UPDATE_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration config=RecentsConfiguration.reinitialize(context);
    config.updateOnConfigurationChange();
    try {
      Bundle data=msg.getData();
      Rect windowRect=data.getParcelable(AlternateRecentsComponent.KEY_WINDOW_RECT);
      Rect systemInsets=data.getParcelable(AlternateRecentsComponent.KEY_SYSTEM_INSETS);
      TaskStack stack=new TaskStack();
      TaskStackView tsv=new TaskStackView(context,stack);
      TaskStackViewLayoutAlgorithm algo=tsv.getStackAlgorithm();
      Bundle replyData=new Bundle();
      TaskViewTransform transform;
      Rect taskStackBounds=new Rect();
      config.getTaskStackBounds(windowRect.width(),windowRect.height(),taskStackBounds);
      stack.addTask(new Task());
      tsv.computeRects(taskStackBounds.width(),taskStackBounds.height() - systemInsets.top - systemInsets.bottom,0,0);
      tsv.setStackScrollToInitialState();
      transform=algo.getStackTransform(0,tsv.getStackScroll());
      transform.rect.offset(taskStackBounds.left,taskStackBounds.top);
      replyData.putParcelable(AlternateRecentsComponent.KEY_SINGLE_TASK_STACK_RECT,new Rect(transform.rect));
      stack.addTask(new Task());
      tsv.computeRects(taskStackBounds.width(),taskStackBounds.height() - systemInsets.top - systemInsets.bottom,0,0);
      tsv.setStackScrollToInitialState();
      transform=algo.getStackTransform(1,tsv.getStackScroll());
      transform.rect.offset(taskStackBounds.left,taskStackBounds.top);
      replyData.putParcelable(AlternateRecentsComponent.KEY_TWO_TASK_STACK_RECT,new Rect(transform.rect));
      stack.addTask(new Task());
      tsv.computeRects(taskStackBounds.width(),taskStackBounds.height() - systemInsets.top - systemInsets.bottom,0,0);
      tsv.setStackScrollToInitialState();
      transform=algo.getStackTransform(2,tsv.getStackScroll());
      transform.rect.offset(taskStackBounds.left,taskStackBounds.top);
      replyData.putParcelable(AlternateRecentsComponent.KEY_MULTIPLE_TASK_STACK_RECT,new Rect(transform.rect));
      data.putParcelable(AlternateRecentsComponent.KEY_CONFIGURATION_DATA,replyData);
      Message reply=Message.obtain(null,AlternateRecentsComponent.MSG_UPDATE_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == AlternateRecentsComponent.MSG_HIDE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_HIDE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (msg.arg1 != 0) {
      intent.putExtra(RecentsService.EXTRA_TRIGGERED_FROM_ALT_TAB,true);
    }
    context.sendBroadcast(intent);
  }
 else   if (msg.what == AlternateRecentsComponent.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    context.sendBroadcast(intent);
    if (Console.Enabled) {
      Console.logTraceTime(Constants.Log.App.TimeRecentsStartup,Constants.Log.App.TimeRecentsStartupKey,""String_Node_Str"");
      Console.logTraceTime(Constants.Log.App.TimeRecentsLaunchTask,Constants.Log.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
 else   if (msg.what == AlternateRecentsComponent.MSG_START_ENTER_ANIMATION) {
    Intent intent=new Intent(RecentsService.ACTION_START_ENTER_ANIMATION);
    intent.setPackage(context.getPackageName());
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    context.sendBroadcast(intent);
  }
}",0.9991235758106924
199006,"/** 
 * Private Constructor 
 */
private RecentsTaskLoader(Context context){
  int maxMemory=(int)(Runtime.getRuntime().maxMemory() / 1024);
  mMaxThumbnailCacheSize=maxMemory / 8;
  mMaxIconCacheSize=mMaxThumbnailCacheSize / 4;
  int iconCacheSize=Constants.DebugFlags.App.DisableBackgroundCache ? 1 : mMaxIconCacheSize;
  int thumbnailCacheSize=Constants.DebugFlags.App.DisableBackgroundCache ? 1 : mMaxThumbnailCacheSize;
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + thumbnailCacheSize + ""String_Node_Str""+ iconCacheSize);
  }
  mSystemServicesProxy=new SystemServicesProxy(context);
  mPackageMonitor=new RecentsPackageMonitor();
  mLoadQueue=new TaskResourceLoadQueue();
  mApplicationIconCache=new DrawableLruCache(iconCacheSize);
  mThumbnailCache=new BitmapLruCache(thumbnailCacheSize);
  mLoader=new TaskResourceLoader(mLoadQueue,mApplicationIconCache,mThumbnailCache,mDefaultThumbnail);
  Bitmap icon=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
  icon.eraseColor(0x00000000);
  mDefaultThumbnail=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
  mDefaultThumbnail.eraseColor(0xFFffffff);
  mLoadingThumbnail=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
  mLoadingThumbnail.eraseColor(0x00000000);
  mDefaultApplicationIcon=new BitmapDrawable(context.getResources(),icon);
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + mDefaultApplicationIcon + ""String_Node_Str""+ mDefaultThumbnail,Console.AnsiRed);
  }
}","/** 
 * Private Constructor 
 */
private RecentsTaskLoader(Context context){
  int maxMemory=(int)(Runtime.getRuntime().maxMemory() / 1024);
  mMaxThumbnailCacheSize=maxMemory / 8;
  mMaxIconCacheSize=mMaxThumbnailCacheSize / 4;
  int iconCacheSize=Constants.DebugFlags.App.DisableBackgroundCache ? 1 : mMaxIconCacheSize;
  int thumbnailCacheSize=Constants.DebugFlags.App.DisableBackgroundCache ? 1 : mMaxThumbnailCacheSize;
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + thumbnailCacheSize + ""String_Node_Str""+ iconCacheSize);
  }
  Bitmap icon=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
  icon.eraseColor(0x00000000);
  mDefaultThumbnail=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
  mDefaultThumbnail.setHasAlpha(false);
  mDefaultThumbnail.eraseColor(0xFFffffff);
  mLoadingThumbnail=Bitmap.createBitmap(1,1,Bitmap.Config.ARGB_8888);
  mLoadingThumbnail.setHasAlpha(false);
  mLoadingThumbnail.eraseColor(0xFFffffff);
  mDefaultApplicationIcon=new BitmapDrawable(context.getResources(),icon);
  mSystemServicesProxy=new SystemServicesProxy(context);
  mPackageMonitor=new RecentsPackageMonitor();
  mLoadQueue=new TaskResourceLoadQueue();
  mApplicationIconCache=new DrawableLruCache(iconCacheSize);
  mThumbnailCache=new BitmapLruCache(thumbnailCacheSize);
  mLoader=new TaskResourceLoader(mLoadQueue,mApplicationIconCache,mThumbnailCache,mDefaultThumbnail);
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + mDefaultApplicationIcon + ""String_Node_Str""+ mDefaultThumbnail,Console.AnsiRed);
  }
}",0.740625
199007,"/** 
 * Reload the set of recent tasks 
 */
public SpaceNode reload(Context context,int preloadCount){
  long t1=System.currentTimeMillis();
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
  }
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  SystemServicesProxy ssp=mSystemServicesProxy;
  List<ActivityManager.RecentTaskInfo> tasks=getRecentTasks();
  t1=System.currentTimeMillis();
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=tasks.get(i);
    ActivityInfo info=ssp.getActivityInfo(t.baseIntent.getComponent(),t.userId);
    if (info == null)     continue;
    ActivityManager.TaskDescription av=t.taskDescription;
    String activityLabel=null;
    Drawable activityIcon=null;
    int activityColor=config.taskBarViewDefaultBackgroundColor;
    if (av != null) {
      activityLabel=(av.getLabel() != null ? av.getLabel() : ssp.getActivityLabel(info));
      activityIcon=(av.getIcon() != null) ? ssp.getBadgedIcon(new BitmapDrawable(res,av.getIcon()),t.userId) : null;
      activityColor=av.getPrimaryColor();
    }
 else {
      activityLabel=ssp.getActivityLabel(info);
    }
    boolean isForemostTask=(i == (taskCount - 1));
    Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,activityLabel,activityIcon,activityColor,t.userId,t.lastActiveTime);
    if (i >= (taskCount - preloadCount)) {
      if (Console.Enabled) {
        Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
      }
      task.applicationIcon=mApplicationIconCache.getCheckLastActiveTime(task.key);
      if (task.applicationIcon == null) {
        if (isForemostTask) {
          task.applicationIcon=ssp.getActivityIcon(info,task.userId);
          if (task.applicationIcon != null) {
            mApplicationIconCache.put(task.key,task.applicationIcon);
          }
 else {
            task.applicationIcon=mDefaultApplicationIcon;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
      task.thumbnail=mThumbnailCache.getCheckLastActiveTime(task.key);
      if (task.thumbnail == null) {
        if (Console.Enabled) {
          Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
        }
        if (isForemostTask) {
          task.thumbnail=ssp.getTaskThumbnail(task.key.id);
          if (task.thumbnail != null) {
            task.thumbnail.setHasAlpha(false);
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
    }
    if (Console.Enabled) {
      Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
    }
    stack.addTask(task);
  }
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  mPackageMonitor.setTasks(tasks);
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
public SpaceNode reload(Context context,int preloadCount){
  long t1=System.currentTimeMillis();
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
  }
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack();
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  SystemServicesProxy ssp=mSystemServicesProxy;
  List<ActivityManager.RecentTaskInfo> tasks=getRecentTasks();
  t1=System.currentTimeMillis();
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=tasks.get(i);
    ActivityInfo info=ssp.getActivityInfo(t.baseIntent.getComponent(),t.userId);
    if (info == null)     continue;
    ActivityManager.TaskDescription av=t.taskDescription;
    String activityLabel=null;
    Drawable activityIcon=null;
    int activityColor=config.taskBarViewDefaultBackgroundColor;
    if (av != null) {
      activityLabel=(av.getLabel() != null ? av.getLabel() : ssp.getActivityLabel(info));
      activityIcon=(av.getIcon() != null) ? ssp.getBadgedIcon(new BitmapDrawable(res,av.getIcon()),t.userId) : null;
      if (av.getPrimaryColor() != 0) {
        activityColor=av.getPrimaryColor();
      }
    }
 else {
      activityLabel=ssp.getActivityLabel(info);
    }
    boolean isForemostTask=(i == (taskCount - 1));
    Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,activityLabel,activityIcon,activityColor,t.userId,t.lastActiveTime);
    if (i >= (taskCount - preloadCount)) {
      if (Console.Enabled) {
        Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
      }
      task.applicationIcon=mApplicationIconCache.getCheckLastActiveTime(task.key);
      if (task.applicationIcon == null) {
        if (isForemostTask) {
          task.applicationIcon=ssp.getActivityIcon(info,task.userId);
          if (task.applicationIcon != null) {
            mApplicationIconCache.put(task.key,task.applicationIcon);
          }
 else {
            task.applicationIcon=mDefaultApplicationIcon;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
      task.thumbnail=mThumbnailCache.getCheckLastActiveTime(task.key);
      if (task.thumbnail == null) {
        if (Console.Enabled) {
          Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
        }
        if (isForemostTask) {
          task.thumbnail=ssp.getTaskThumbnail(task.key.id);
          if (task.thumbnail != null) {
            task.thumbnail.setHasAlpha(false);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
          mThumbnailCache.put(task.key,task.thumbnail);
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
    }
    if (Console.Enabled) {
      Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
    }
    stack.addTask(task);
  }
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  mPackageMonitor.setTasks(tasks);
  return root;
}",0.9675380637747774
199008,"public TaskStack(Context context){
  mContext=context;
}","public TaskStack(){
}",0.5454545454545454
199009,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final boolean isRtl=getLayoutDirection() == LAYOUT_DIRECTION_RTL;
  final int width=getWidth();
  final int height=getHeight();
  final int paddingLeft=getPaddingLeft();
  final int paddingRight=getPaddingRight();
  final int paddingTop=getPaddingTop();
  final int paddingBottom=getPaddingBottom();
  int left=paddingLeft;
  int right=width - paddingRight;
  final int[] collapsingMargins=mTempMargins;
  collapsingMargins[0]=collapsingMargins[1]=0;
  if (shouldLayout(mNavButtonView)) {
    if (isRtl) {
      right=layoutChildRight(mNavButtonView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mNavButtonView,left,collapsingMargins);
    }
  }
  if (shouldLayout(mCollapseButtonView)) {
    if (isRtl) {
      right=layoutChildRight(mCollapseButtonView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mCollapseButtonView,left,collapsingMargins);
    }
  }
  if (shouldLayout(mMenuView)) {
    if (isRtl) {
      left=layoutChildLeft(mMenuView,left,collapsingMargins);
    }
 else {
      right=layoutChildRight(mMenuView,right,collapsingMargins);
    }
  }
  collapsingMargins[0]=Math.max(0,getContentInsetLeft() - left);
  collapsingMargins[1]=Math.max(0,getContentInsetRight() - (width - paddingRight - right));
  left=Math.max(left,getContentInsetLeft());
  right=Math.min(right,width - paddingRight - getContentInsetRight());
  if (shouldLayout(mExpandedActionView)) {
    if (isRtl) {
      right=layoutChildRight(mExpandedActionView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mExpandedActionView,left,collapsingMargins);
    }
  }
  if (shouldLayout(mLogoView)) {
    if (isRtl) {
      right=layoutChildRight(mLogoView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mLogoView,left,collapsingMargins);
    }
  }
  final boolean layoutTitle=shouldLayout(mTitleTextView);
  final boolean layoutSubtitle=shouldLayout(mSubtitleTextView);
  int titleHeight=0;
  if (layoutTitle) {
    final LayoutParams lp=(LayoutParams)mTitleTextView.getLayoutParams();
    titleHeight+=lp.topMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
  }
  if (layoutSubtitle) {
    final LayoutParams lp=(LayoutParams)mSubtitleTextView.getLayoutParams();
    titleHeight+=lp.bottomMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
  }
  if (layoutTitle || layoutSubtitle) {
    int titleTop;
    final View topChild=layoutTitle ? mTitleTextView : mSubtitleTextView;
    final View bottomChild=layoutSubtitle ? mSubtitleTextView : mTitleTextView;
    final LayoutParams toplp=(LayoutParams)topChild.getLayoutParams();
    final LayoutParams bottomlp=(LayoutParams)bottomChild.getLayoutParams();
switch (mGravity & Gravity.VERTICAL_GRAVITY_MASK) {
case Gravity.TOP:
      titleTop=getPaddingTop() + toplp.topMargin + mTitleMarginTop;
    break;
default :
case Gravity.CENTER_VERTICAL:
  final int space=height - paddingTop - paddingBottom;
int spaceAbove=(space - titleHeight) / 2;
if (spaceAbove < toplp.topMargin + mTitleMarginTop) {
spaceAbove=toplp.topMargin + mTitleMarginTop;
}
 else {
final int spaceBelow=height - paddingBottom - titleHeight- spaceAbove- paddingTop;
if (spaceBelow < toplp.bottomMargin + mTitleMarginBottom) {
  spaceAbove=Math.max(0,spaceAbove - (bottomlp.bottomMargin + mTitleMarginBottom - spaceBelow));
}
}
titleTop=paddingTop + spaceAbove;
break;
case Gravity.BOTTOM:
titleTop=height - paddingBottom - bottomlp.bottomMargin- mTitleMarginBottom- titleHeight;
break;
}
if (isRtl) {
final int rd=mTitleMarginStart - collapsingMargins[1];
right-=Math.max(0,rd);
collapsingMargins[1]=Math.max(0,-rd);
int titleRight=right;
int subtitleRight=right;
if (layoutTitle) {
final LayoutParams lp=(LayoutParams)mTitleTextView.getLayoutParams();
final int titleLeft=titleRight - mTitleTextView.getMeasuredWidth();
final int titleBottom=titleTop + mTitleTextView.getMeasuredHeight();
mTitleTextView.layout(titleLeft,titleTop,titleRight,titleBottom);
titleRight=titleLeft - mTitleMarginEnd;
titleTop=titleBottom + lp.bottomMargin;
}
if (layoutSubtitle) {
final LayoutParams lp=(LayoutParams)mSubtitleTextView.getLayoutParams();
titleTop+=lp.topMargin;
final int subtitleLeft=subtitleRight - mSubtitleTextView.getMeasuredWidth();
final int subtitleBottom=titleTop + mSubtitleTextView.getMeasuredHeight();
mSubtitleTextView.layout(subtitleLeft,titleTop,subtitleRight,subtitleBottom);
subtitleRight=subtitleRight - mTitleMarginEnd;
titleTop=subtitleBottom + lp.bottomMargin;
}
right=Math.max(titleRight,subtitleRight);
}
 else {
final int ld=mTitleMarginStart - collapsingMargins[0];
left+=Math.max(0,ld);
collapsingMargins[0]=Math.max(0,-ld);
int titleLeft=left;
int subtitleLeft=left;
if (layoutTitle) {
final LayoutParams lp=(LayoutParams)mTitleTextView.getLayoutParams();
final int titleRight=titleLeft + mTitleTextView.getMeasuredWidth();
final int titleBottom=titleTop + mTitleTextView.getMeasuredHeight();
mTitleTextView.layout(titleLeft,titleTop,titleRight,titleBottom);
titleLeft=titleRight + mTitleMarginEnd;
titleTop=titleBottom + lp.bottomMargin;
}
if (layoutSubtitle) {
final LayoutParams lp=(LayoutParams)mSubtitleTextView.getLayoutParams();
titleTop+=lp.topMargin;
final int subtitleRight=subtitleLeft + mSubtitleTextView.getMeasuredWidth();
final int subtitleBottom=titleTop + mSubtitleTextView.getMeasuredHeight();
mSubtitleTextView.layout(subtitleLeft,titleTop,subtitleRight,subtitleBottom);
subtitleLeft=subtitleRight + mTitleMarginEnd;
titleTop=subtitleBottom + lp.bottomMargin;
}
left=Math.max(titleLeft,subtitleLeft);
}
}
addCustomViewsWithGravity(mTempViews,Gravity.LEFT);
final int leftViewsCount=mTempViews.size();
for (int i=0; i < leftViewsCount; i++) {
left=layoutChildLeft(mTempViews.get(i),left,collapsingMargins);
}
addCustomViewsWithGravity(mTempViews,Gravity.RIGHT);
final int rightViewsCount=mTempViews.size();
for (int i=0; i < rightViewsCount; i++) {
right=layoutChildRight(mTempViews.get(i),right,collapsingMargins);
}
addCustomViewsWithGravity(mTempViews,Gravity.CENTER_HORIZONTAL);
final int centerViewsWidth=getViewListMeasuredWidth(mTempViews,collapsingMargins);
final int parentCenter=paddingLeft + (width - paddingLeft - paddingRight) / 2;
final int halfCenterViewsWidth=centerViewsWidth / 2;
int centerLeft=parentCenter - halfCenterViewsWidth;
final int centerRight=centerLeft + centerViewsWidth;
if (centerLeft < left) {
centerLeft=left;
}
 else if (centerRight > right) {
centerLeft-=centerRight - right;
}
final int centerViewsCount=mTempViews.size();
for (int i=0; i < centerViewsCount; i++) {
centerLeft=layoutChildLeft(mTempViews.get(i),centerLeft,collapsingMargins);
}
mTempViews.clear();
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  final boolean isRtl=getLayoutDirection() == LAYOUT_DIRECTION_RTL;
  final int width=getWidth();
  final int height=getHeight();
  final int paddingLeft=getPaddingLeft();
  final int paddingRight=getPaddingRight();
  final int paddingTop=getPaddingTop();
  final int paddingBottom=getPaddingBottom();
  int left=paddingLeft;
  int right=width - paddingRight;
  final int[] collapsingMargins=mTempMargins;
  collapsingMargins[0]=collapsingMargins[1]=0;
  if (shouldLayout(mNavButtonView)) {
    if (isRtl) {
      right=layoutChildRight(mNavButtonView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mNavButtonView,left,collapsingMargins);
    }
  }
  if (shouldLayout(mCollapseButtonView)) {
    if (isRtl) {
      right=layoutChildRight(mCollapseButtonView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mCollapseButtonView,left,collapsingMargins);
    }
  }
  if (shouldLayout(mMenuView)) {
    if (isRtl) {
      left=layoutChildLeft(mMenuView,left,collapsingMargins);
    }
 else {
      right=layoutChildRight(mMenuView,right,collapsingMargins);
    }
  }
  collapsingMargins[0]=Math.max(0,getContentInsetLeft() - left);
  collapsingMargins[1]=Math.max(0,getContentInsetRight() - (width - paddingRight - right));
  left=Math.max(left,getContentInsetLeft());
  right=Math.min(right,width - paddingRight - getContentInsetRight());
  if (shouldLayout(mExpandedActionView)) {
    if (isRtl) {
      right=layoutChildRight(mExpandedActionView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mExpandedActionView,left,collapsingMargins);
    }
  }
  if (shouldLayout(mLogoView)) {
    if (isRtl) {
      right=layoutChildRight(mLogoView,right,collapsingMargins);
    }
 else {
      left=layoutChildLeft(mLogoView,left,collapsingMargins);
    }
  }
  final boolean layoutTitle=shouldLayout(mTitleTextView);
  final boolean layoutSubtitle=shouldLayout(mSubtitleTextView);
  int titleHeight=0;
  if (layoutTitle) {
    final LayoutParams lp=(LayoutParams)mTitleTextView.getLayoutParams();
    titleHeight+=lp.topMargin + mTitleTextView.getMeasuredHeight() + lp.bottomMargin;
  }
  if (layoutSubtitle) {
    final LayoutParams lp=(LayoutParams)mSubtitleTextView.getLayoutParams();
    titleHeight+=lp.topMargin + mSubtitleTextView.getMeasuredHeight() + lp.bottomMargin;
  }
  if (layoutTitle || layoutSubtitle) {
    int titleTop;
    final View topChild=layoutTitle ? mTitleTextView : mSubtitleTextView;
    final View bottomChild=layoutSubtitle ? mSubtitleTextView : mTitleTextView;
    final LayoutParams toplp=(LayoutParams)topChild.getLayoutParams();
    final LayoutParams bottomlp=(LayoutParams)bottomChild.getLayoutParams();
switch (mGravity & Gravity.VERTICAL_GRAVITY_MASK) {
case Gravity.TOP:
      titleTop=getPaddingTop() + toplp.topMargin + mTitleMarginTop;
    break;
default :
case Gravity.CENTER_VERTICAL:
  final int space=height - paddingTop - paddingBottom;
int spaceAbove=(space - titleHeight) / 2;
if (spaceAbove < toplp.topMargin + mTitleMarginTop) {
spaceAbove=toplp.topMargin + mTitleMarginTop;
}
 else {
final int spaceBelow=height - paddingBottom - titleHeight- spaceAbove- paddingTop;
if (spaceBelow < toplp.bottomMargin + mTitleMarginBottom) {
  spaceAbove=Math.max(0,spaceAbove - (bottomlp.bottomMargin + mTitleMarginBottom - spaceBelow));
}
}
titleTop=paddingTop + spaceAbove;
break;
case Gravity.BOTTOM:
titleTop=height - paddingBottom - bottomlp.bottomMargin- mTitleMarginBottom- titleHeight;
break;
}
if (isRtl) {
final int rd=mTitleMarginStart - collapsingMargins[1];
right-=Math.max(0,rd);
collapsingMargins[1]=Math.max(0,-rd);
int titleRight=right;
int subtitleRight=right;
if (layoutTitle) {
final LayoutParams lp=(LayoutParams)mTitleTextView.getLayoutParams();
final int titleLeft=titleRight - mTitleTextView.getMeasuredWidth();
final int titleBottom=titleTop + mTitleTextView.getMeasuredHeight();
mTitleTextView.layout(titleLeft,titleTop,titleRight,titleBottom);
titleRight=titleLeft - mTitleMarginEnd;
titleTop=titleBottom + lp.bottomMargin;
}
if (layoutSubtitle) {
final LayoutParams lp=(LayoutParams)mSubtitleTextView.getLayoutParams();
titleTop+=lp.topMargin;
final int subtitleLeft=subtitleRight - mSubtitleTextView.getMeasuredWidth();
final int subtitleBottom=titleTop + mSubtitleTextView.getMeasuredHeight();
mSubtitleTextView.layout(subtitleLeft,titleTop,subtitleRight,subtitleBottom);
subtitleRight=subtitleRight - mTitleMarginEnd;
titleTop=subtitleBottom + lp.bottomMargin;
}
right=Math.max(titleRight,subtitleRight);
}
 else {
final int ld=mTitleMarginStart - collapsingMargins[0];
left+=Math.max(0,ld);
collapsingMargins[0]=Math.max(0,-ld);
int titleLeft=left;
int subtitleLeft=left;
if (layoutTitle) {
final LayoutParams lp=(LayoutParams)mTitleTextView.getLayoutParams();
final int titleRight=titleLeft + mTitleTextView.getMeasuredWidth();
final int titleBottom=titleTop + mTitleTextView.getMeasuredHeight();
mTitleTextView.layout(titleLeft,titleTop,titleRight,titleBottom);
titleLeft=titleRight + mTitleMarginEnd;
titleTop=titleBottom + lp.bottomMargin;
}
if (layoutSubtitle) {
final LayoutParams lp=(LayoutParams)mSubtitleTextView.getLayoutParams();
titleTop+=lp.topMargin;
final int subtitleRight=subtitleLeft + mSubtitleTextView.getMeasuredWidth();
final int subtitleBottom=titleTop + mSubtitleTextView.getMeasuredHeight();
mSubtitleTextView.layout(subtitleLeft,titleTop,subtitleRight,subtitleBottom);
subtitleLeft=subtitleRight + mTitleMarginEnd;
titleTop=subtitleBottom + lp.bottomMargin;
}
left=Math.max(titleLeft,subtitleLeft);
}
}
addCustomViewsWithGravity(mTempViews,Gravity.LEFT);
final int leftViewsCount=mTempViews.size();
for (int i=0; i < leftViewsCount; i++) {
left=layoutChildLeft(mTempViews.get(i),left,collapsingMargins);
}
addCustomViewsWithGravity(mTempViews,Gravity.RIGHT);
final int rightViewsCount=mTempViews.size();
for (int i=0; i < rightViewsCount; i++) {
right=layoutChildRight(mTempViews.get(i),right,collapsingMargins);
}
addCustomViewsWithGravity(mTempViews,Gravity.CENTER_HORIZONTAL);
final int centerViewsWidth=getViewListMeasuredWidth(mTempViews,collapsingMargins);
final int parentCenter=paddingLeft + (width - paddingLeft - paddingRight) / 2;
final int halfCenterViewsWidth=centerViewsWidth / 2;
int centerLeft=parentCenter - halfCenterViewsWidth;
final int centerRight=centerLeft + centerViewsWidth;
if (centerLeft < left) {
centerLeft=left;
}
 else if (centerRight > right) {
centerLeft-=centerRight - right;
}
final int centerViewsCount=mTempViews.size();
for (int i=0; i < centerViewsCount; i++) {
centerLeft=layoutChildLeft(mTempViews.get(i),centerLeft,collapsingMargins);
}
mTempViews.clear();
}",0.9989581783003424
199010,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_TAB) {
    final boolean backward=event.isShiftPressed();
    mRecentsView.focusNextTask(!backward);
    return true;
  }
  mDebugTrigger.onKeyEvent(keyCode);
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_TAB) {
    final boolean backward=event.isShiftPressed();
    mRecentsView.focusNextTask(!backward);
    return true;
  }
 else   if (keyCode == KeyEvent.KEYCODE_DPAD_UP) {
    mRecentsView.focusNextTask(true);
    return true;
  }
 else   if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
    mRecentsView.focusNextTask(false);
    return true;
  }
  mDebugTrigger.onKeyEvent(keyCode);
  return super.onKeyDown(keyCode,event);
}",0.728380024360536
199011,"void onConfigurationChange(){
  mRecentsView.startEnterRecentsAnimation(new ViewAnimation.TaskViewEnterContext(mFullScreenOverlayView));
  onEnterAnimationTriggered();
}","void onConfigurationChange(){
  ReferenceCountedTrigger t=new ReferenceCountedTrigger(this,null,null,null);
  mRecentsView.startEnterRecentsAnimation(new ViewAnimation.TaskViewEnterContext(mFullScreenOverlayView,t));
  onEnterAnimationTriggered();
}",0.8086124401913876
199012,"/** 
 * Requests all task stacks to start their enter-recents animation 
 */
public void startEnterRecentsAnimation(ViewAnimation.TaskViewEnterContext ctx){
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child instanceof TaskStackView) {
      TaskStackView stackView=(TaskStackView)child;
      stackView.startEnterRecentsAnimation(ctx);
    }
  }
}","/** 
 * Requests all task stacks to start their enter-recents animation 
 */
public void startEnterRecentsAnimation(ViewAnimation.TaskViewEnterContext ctx){
  ctx.postAnimationTrigger.increment();
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    if (child instanceof TaskStackView) {
      TaskStackView stackView=(TaskStackView)child;
      stackView.startEnterRecentsAnimation(ctx);
    }
  }
  ctx.postAnimationTrigger.decrement();
}",0.9118942731277532
199013,"/** 
 * This is called with the size of the space not including the top or right insets, or the search bar height in portrait (but including the search bar width in landscape, since we want to draw under it.
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + new Rect(left,top,right,bottom),Console.AnsiGreen);
  }
  if (Constants.Log.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mStackAlgorithm.mRect);
    Console.log(""String_Node_Str"" + mStackAlgorithm.mStackRect);
    Console.log(""String_Node_Str"" + mStackAlgorithm.mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mStackAlgorithm.mTaskRect);
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.layout(mStackAlgorithm.mTaskRect.left,mStackAlgorithm.mStackRectSansPeek.top,mStackAlgorithm.mTaskRect.right,mStackAlgorithm.mStackRectSansPeek.top + mStackAlgorithm.mTaskRect.height());
  }
  if (mAwaitingFirstLayout) {
    mAwaitingFirstLayout=false;
    mUIDozeTrigger.startDozing();
    int offsetTopAlign=-mStackAlgorithm.mTaskRect.top;
    int offscreenY=mStackAlgorithm.mRect.bottom - (mStackAlgorithm.mTaskRect.top - mStackAlgorithm.mRect.top);
    for (int i=childCount - 1; i >= 0; i--) {
      TaskView tv=(TaskView)getChildAt(i);
      tv.prepareEnterRecentsAnimation((i == (getChildCount() - 1)),offsetTopAlign,offscreenY,mStackAlgorithm.mTaskRect);
    }
    if (mStartEnterAnimationRequestedAfterLayout) {
      startEnterRecentsAnimation(mStartEnterAnimationContext);
      mStartEnterAnimationRequestedAfterLayout=false;
      mStartEnterAnimationContext=null;
    }
    if (mConfig.launchedWithAltTab) {
      focusTask(Math.max(0,mStack.getTaskCount() - 2),false);
    }
  }
}","/** 
 * This is called with the size of the space not including the top or right insets, or the search bar height in portrait (but including the search bar width in landscape, since we want to draw under it.
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + new Rect(left,top,right,bottom),Console.AnsiGreen);
  }
  if (Constants.Log.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mStackAlgorithm.mRect);
    Console.log(""String_Node_Str"" + mStackAlgorithm.mStackRect);
    Console.log(""String_Node_Str"" + mStackAlgorithm.mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mStackAlgorithm.mTaskRect);
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.layout(mStackAlgorithm.mTaskRect.left,mStackAlgorithm.mStackRectSansPeek.top,mStackAlgorithm.mTaskRect.right,mStackAlgorithm.mStackRectSansPeek.top + mStackAlgorithm.mTaskRect.height());
  }
  if (mAwaitingFirstLayout) {
    mAwaitingFirstLayout=false;
    int offsetTopAlign=-mStackAlgorithm.mTaskRect.top;
    int offscreenY=mStackAlgorithm.mRect.bottom - (mStackAlgorithm.mTaskRect.top - mStackAlgorithm.mRect.top);
    for (int i=childCount - 1; i >= 0; i--) {
      TaskView tv=(TaskView)getChildAt(i);
      tv.prepareEnterRecentsAnimation((i == (getChildCount() - 1)),offsetTopAlign,offscreenY,mStackAlgorithm.mTaskRect);
    }
    if (mStartEnterAnimationRequestedAfterLayout) {
      startEnterRecentsAnimation(mStartEnterAnimationContext);
      mStartEnterAnimationRequestedAfterLayout=false;
      mStartEnterAnimationContext=null;
    }
    if (mConfig.launchedWithAltTab) {
      focusTask(Math.max(0,mStack.getTaskCount() - 2),false);
    }
 else {
      focusTask(Math.max(0,mStack.getTaskCount() - 1),false);
    }
  }
}",0.9712793733681462
199014,"/** 
 * Requests this task stacks to start it's enter-recents animation 
 */
public void startEnterRecentsAnimation(ViewAnimation.TaskViewEnterContext ctx){
  if (mAwaitingFirstLayout) {
    mStartEnterAnimationRequestedAfterLayout=true;
    mStartEnterAnimationContext=ctx;
    return;
  }
  TaskViewTransform transform=mStackAlgorithm.getStackTransform(mStack.getTaskCount() - 1,getInitialStackScroll());
  ctx.taskRect=transform.rect;
  ctx.stackRectSansPeek=mStackAlgorithm.mStackRectSansPeek;
  int childCount=getChildCount();
  for (int i=childCount - 1; i >= 0; i--) {
    TaskView tv=(TaskView)getChildAt(i);
    ctx.stackViewIndex=i;
    ctx.stackViewCount=childCount;
    ctx.isFrontMost=(i == (getChildCount() - 1));
    ctx.transform=mStackAlgorithm.getStackTransform(mStack.indexOfTask(tv.getTask()),getStackScroll());
    tv.startEnterRecentsAnimation(ctx);
  }
}","/** 
 * Requests this task stacks to start it's enter-recents animation 
 */
public void startEnterRecentsAnimation(ViewAnimation.TaskViewEnterContext ctx){
  if (mAwaitingFirstLayout) {
    mStartEnterAnimationRequestedAfterLayout=true;
    mStartEnterAnimationContext=ctx;
    return;
  }
  TaskViewTransform transform=mStackAlgorithm.getStackTransform(mStack.getTaskCount() - 1,getInitialStackScroll());
  ctx.taskRect=transform.rect;
  ctx.stackRectSansPeek=mStackAlgorithm.mStackRectSansPeek;
  int childCount=getChildCount();
  for (int i=childCount - 1; i >= 0; i--) {
    TaskView tv=(TaskView)getChildAt(i);
    ctx.stackViewIndex=i;
    ctx.stackViewCount=childCount;
    ctx.isFrontMost=(i == (getChildCount() - 1));
    ctx.transform=mStackAlgorithm.getStackTransform(mStack.indexOfTask(tv.getTask()),getStackScroll());
    tv.startEnterRecentsAnimation(ctx);
  }
  ctx.postAnimationTrigger.addLastDecrementRunnable(new Runnable(){
    @Override public void run(){
      mUIDozeTrigger.startDozing();
    }
  }
);
}",0.921218487394958
199015,"/** 
 * Sets the focused task explicitly. We need a separate flag because requestFocus() won't happen if the view is not currently visible, or we are in touch state (where we still want to keep track of focus).
 */
public void setFocusedTask(){
  mIsFocused=true;
  requestFocus();
  invalidate();
  mCb.onTaskFocused(this);
}","/** 
 * Sets the focused task explicitly. We need a separate flag because requestFocus() won't happen if the view is not currently visible, or we are in touch state (where we still want to keep track of focus).
 */
public void setFocusedTask(){
  mIsFocused=true;
  setFocusableInTouchMode(true);
  requestFocus();
  setFocusableInTouchMode(false);
  invalidate();
  mCb.onTaskFocused(this);
}",0.9068150208623088
199016,"/** 
 * Animates this task view as it enters recents 
 */
public void startEnterRecentsAnimation(ViewAnimation.TaskViewEnterContext ctx){
  TaskViewTransform transform=ctx.transform;
  if (mConfig.launchedFromAppWithScreenshot) {
    if (ctx.isFrontMost) {
      ctx.fullScreenshot.animateOnEnterRecents(ctx,new Runnable(){
        @Override public void run(){
          mBarView.startEnterRecentsAnimation(0,mEnableThumbnailClip);
          setVisibility(View.VISIBLE);
        }
      }
);
    }
 else {
      animate().scaleX(transform.scale).scaleY(transform.scale).translationY(transform.translationY).setStartDelay(0).setUpdateListener(null).setInterpolator(mConfig.linearOutSlowInInterpolator).setDuration(475).withLayer().withEndAction(mEnableThumbnailClip).start();
    }
  }
 else   if (mConfig.launchedFromAppWithThumbnail) {
    if (ctx.isFrontMost) {
      mBarView.startEnterRecentsAnimation(mConfig.taskBarEnterAnimDelay,mEnableThumbnailClip);
      ObjectAnimator anim=ObjectAnimator.ofInt(this,""String_Node_Str"",getDimOverlayFromScale());
      anim.setStartDelay(mConfig.taskBarEnterAnimDelay);
      anim.setDuration(mConfig.taskBarEnterAnimDuration);
      anim.setInterpolator(mConfig.fastOutLinearInInterpolator);
      anim.start();
    }
 else {
      mEnableThumbnailClip.run();
    }
  }
 else   if (mConfig.launchedFromHome) {
    int frontIndex=(ctx.stackViewCount - ctx.stackViewIndex - 1);
    int delay=mConfig.taskBarEnterAnimDelay + frontIndex * mConfig.taskViewEnterFromHomeDelay;
    animate().scaleX(transform.scale).scaleY(transform.scale).translationY(transform.translationY).translationZ(transform.translationZ).setStartDelay(delay).setUpdateListener(null).setInterpolator(mConfig.quintOutInterpolator).setDuration(mConfig.taskViewEnterFromHomeDuration).withLayer().withEndAction(mEnableThumbnailClip).start();
  }
}","/** 
 * Animates this task view as it enters recents 
 */
public void startEnterRecentsAnimation(final ViewAnimation.TaskViewEnterContext ctx){
  TaskViewTransform transform=ctx.transform;
  if (mConfig.launchedFromAppWithScreenshot) {
    if (ctx.isFrontMost) {
      ctx.fullScreenshot.animateOnEnterRecents(ctx,new Runnable(){
        @Override public void run(){
          mBarView.startEnterRecentsAnimation(0,mEnableThumbnailClip);
          setVisibility(View.VISIBLE);
          ctx.postAnimationTrigger.decrement();
        }
      }
);
    }
 else {
      animate().scaleX(transform.scale).scaleY(transform.scale).translationY(transform.translationY).setStartDelay(0).setUpdateListener(null).setInterpolator(mConfig.linearOutSlowInInterpolator).setDuration(475).withLayer().withEndAction(new Runnable(){
        @Override public void run(){
          mEnableThumbnailClip.run();
          ctx.postAnimationTrigger.decrement();
        }
      }
).start();
    }
    ctx.postAnimationTrigger.increment();
  }
 else   if (mConfig.launchedFromAppWithThumbnail) {
    if (ctx.isFrontMost) {
      mBarView.startEnterRecentsAnimation(mConfig.taskBarEnterAnimDelay,mEnableThumbnailClip);
      ObjectAnimator anim=ObjectAnimator.ofInt(this,""String_Node_Str"",getDimOverlayFromScale());
      anim.setStartDelay(mConfig.taskBarEnterAnimDelay);
      anim.setDuration(mConfig.taskBarEnterAnimDuration);
      anim.setInterpolator(mConfig.fastOutLinearInInterpolator);
      anim.addListener(new AnimatorListenerAdapter(){
        @Override public void onAnimationEnd(        Animator animation){
          ctx.postAnimationTrigger.decrement();
        }
      }
);
      anim.start();
      ctx.postAnimationTrigger.increment();
    }
 else {
      mEnableThumbnailClip.run();
    }
  }
 else   if (mConfig.launchedFromHome) {
    int frontIndex=(ctx.stackViewCount - ctx.stackViewIndex - 1);
    int delay=mConfig.taskBarEnterAnimDelay + frontIndex * mConfig.taskViewEnterFromHomeDelay;
    animate().scaleX(transform.scale).scaleY(transform.scale).translationY(transform.translationY).translationZ(transform.translationZ).setStartDelay(delay).setUpdateListener(null).setInterpolator(mConfig.quintOutInterpolator).setDuration(mConfig.taskViewEnterFromHomeDuration).withLayer().withEndAction(new Runnable(){
      @Override public void run(){
        mEnableThumbnailClip.run();
        ctx.postAnimationTrigger.decrement();
      }
    }
).start();
    ctx.postAnimationTrigger.increment();
  }
}",0.8440156214105214
199017,"public TaskViewEnterContext(FullscreenTransitionOverlayView fss){
  fullScreenshot=fss;
}","public TaskViewEnterContext(FullscreenTransitionOverlayView fss,ReferenceCountedTrigger t){
  fullScreenshot=fss;
  postAnimationTrigger=t;
}",0.7739130434782608
199018,"/** 
 * {@inheritDoc} 
 */
@Override public long interceptKeyBeforeDispatching(WindowState win,KeyEvent event,int policyFlags){
  final boolean keyguardOn=keyguardOn();
  final int keyCode=event.getKeyCode();
  final int repeatCount=event.getRepeatCount();
  final int metaState=event.getMetaState();
  final int flags=event.getFlags();
  final boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
  final boolean canceled=event.isCanceled();
  if (DEBUG_INPUT) {
    Log.d(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ down+ ""String_Node_Str""+ repeatCount+ ""String_Node_Str""+ keyguardOn+ ""String_Node_Str""+ mHomePressed+ ""String_Node_Str""+ canceled);
  }
  if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
    if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
      final long now=SystemClock.uptimeMillis();
      final long timeoutTime=mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
      if (now < timeoutTime) {
        return timeoutTime - now;
      }
    }
    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
      if (!down) {
        mVolumeDownKeyConsumedByScreenshotChord=false;
      }
      return -1;
    }
  }
  if (mPendingMetaAction && keyCode != KeyEvent.KEYCODE_META_LEFT) {
    mPendingMetaAction=false;
  }
  if (keyCode == KeyEvent.KEYCODE_HOME) {
    if (!down) {
      cancelPreloadRecentApps();
      mHomePressed=false;
      if (mHomeConsumed) {
        mHomeConsumed=false;
        return -1;
      }
      if (canceled) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      TelecommManager telecommManager=getTelecommService();
      if (telecommManager != null && telecommManager.isRinging()) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        mHomeDoubleTapPending=true;
        mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,ViewConfiguration.getDoubleTapTimeout());
        return -1;
      }
      launchHomeFromHotKey();
      return -1;
    }
    WindowManager.LayoutParams attrs=win != null ? win.getAttrs() : null;
    if (attrs != null) {
      final int type=attrs.type;
      if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        return 0;
      }
      final int typeCount=WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
      for (int i=0; i < typeCount; i++) {
        if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
          return -1;
        }
      }
    }
    if (repeatCount == 0) {
      mHomePressed=true;
      if (mHomeDoubleTapPending) {
        mHomeDoubleTapPending=false;
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        handleDoubleTapOnHome();
      }
 else       if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        preloadRecentApps();
      }
    }
 else     if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
      if (!keyguardOn) {
        handleLongPressOnHome();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_MENU) {
    final int chordBug=KeyEvent.META_SHIFT_ON;
    if (down && repeatCount == 0) {
      if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
        Intent intent=new Intent(Intent.ACTION_BUG_REPORT);
        mContext.sendOrderedBroadcastAsUser(intent,UserHandle.CURRENT,null,null,null,0,null,null);
        return -1;
      }
 else       if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
        Intent service=new Intent();
        service.setClassName(mContext,""String_Node_Str"");
        ContentResolver res=mContext.getContentResolver();
        boolean shown=Settings.Global.getInt(res,Settings.Global.SHOW_PROCESSES,0) != 0;
        if (!shown) {
          mContext.startService(service);
        }
 else {
          mContext.stopService(service);
        }
        Settings.Global.putInt(res,Settings.Global.SHOW_PROCESSES,shown ? 0 : 1);
        return -1;
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    if (down) {
      if (repeatCount == 0) {
        mSearchKeyShortcutPending=true;
        mConsumeSearchKeyUp=false;
      }
    }
 else {
      mSearchKeyShortcutPending=false;
      if (mConsumeSearchKeyUp) {
        mConsumeSearchKeyUp=false;
        return -1;
      }
    }
    return 0;
  }
 else   if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (!keyguardOn) {
      if (down && repeatCount == 0) {
        preloadRecentApps();
      }
 else       if (!down) {
        toggleRecentApps();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_ASSIST) {
    if (down) {
      if (repeatCount == 0) {
        mAssistKeyLongPressed=false;
      }
 else       if (repeatCount == 1) {
        mAssistKeyLongPressed=true;
        if (!keyguardOn) {
          launchAssistLongPressAction();
        }
      }
    }
 else {
      if (mAssistKeyLongPressed) {
        mAssistKeyLongPressed=false;
      }
 else {
        if (!keyguardOn) {
          launchAssistAction();
        }
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
    if (down && repeatCount == 0) {
      mHandler.post(mScreenshotRunnable);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
    if (down) {
      int direction=keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
      int auto=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      if (auto != 0) {
        Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      }
      int min=mPowerManager.getMinimumScreenBrightnessSetting();
      int max=mPowerManager.getMaximumScreenBrightnessSetting();
      int step=(max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
      int brightness=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,mPowerManager.getDefaultScreenBrightnessSetting(),UserHandle.USER_CURRENT_OR_SELF);
      brightness+=step;
      brightness=Math.min(max,brightness);
      brightness=Math.max(min,brightness);
      Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,brightness,UserHandle.USER_CURRENT_OR_SELF);
      Intent intent=new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT_OR_SELF);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_META_LEFT) {
    if (down) {
      mPendingMetaAction=true;
    }
 else     if (mPendingMetaAction) {
      mPendingMetaAction=false;
      launchAssistAction();
    }
    return -1;
  }
  if (mSearchKeyShortcutPending) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      mConsumeSearchKeyUp=true;
      mSearchKeyShortcutPending=false;
      if (down && repeatCount == 0 && !keyguardOn) {
        Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState);
        if (shortcutIntent != null) {
          shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            mContext.startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
          }
 catch (          ActivityNotFoundException ex) {
            Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + KeyEvent.keyCodeToString(keyCode));
        }
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          mContext.startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
        }
 catch (        ActivityNotFoundException ex) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
        }
        return -1;
      }
    }
  }
  if (down && repeatCount == 0 && !keyguardOn) {
    String category=sApplicationLaunchKeyCategories.get(keyCode);
    if (category != null) {
      Intent intent=Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,category);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        mContext.startActivityAsUser(intent,UserHandle.CURRENT);
      }
 catch (      ActivityNotFoundException ex) {
        Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + keyCode + ""String_Node_Str""+ category,ex);
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
    if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
      final int shiftlessModifiers=event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
      if (KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_META_ON)) {
        mRecentAppsHeldModifiers=shiftlessModifiers;
        showRecentApps(true);
        return -1;
      }
    }
  }
 else   if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
    mRecentAppsHeldModifiers=0;
    hideRecentApps(true);
  }
  if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
    int direction=(metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
    mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(),direction);
    return -1;
  }
  if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
    mLanguageSwitchKeyPressed=false;
    return -1;
  }
  if (mGlobalKeyManager.handleGlobalKey(mContext,keyCode,event)) {
    return -1;
  }
  if ((metaState & KeyEvent.META_META_LEFT_ON) != 0) {
    return -1;
  }
  return 0;
}","/** 
 * {@inheritDoc} 
 */
@Override public long interceptKeyBeforeDispatching(WindowState win,KeyEvent event,int policyFlags){
  final boolean keyguardOn=keyguardOn();
  final int keyCode=event.getKeyCode();
  final int repeatCount=event.getRepeatCount();
  final int metaState=event.getMetaState();
  final int flags=event.getFlags();
  final boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
  final boolean canceled=event.isCanceled();
  if (DEBUG_INPUT) {
    Log.d(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ down+ ""String_Node_Str""+ repeatCount+ ""String_Node_Str""+ keyguardOn+ ""String_Node_Str""+ mHomePressed+ ""String_Node_Str""+ canceled);
  }
  if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
    if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
      final long now=SystemClock.uptimeMillis();
      final long timeoutTime=mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
      if (now < timeoutTime) {
        return timeoutTime - now;
      }
    }
    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
      if (!down) {
        mVolumeDownKeyConsumedByScreenshotChord=false;
      }
      return -1;
    }
  }
  if (mPendingMetaAction && keyCode != KeyEvent.KEYCODE_META_LEFT) {
    mPendingMetaAction=false;
  }
  if (keyCode == KeyEvent.KEYCODE_HOME) {
    if (!down) {
      cancelPreloadRecentApps();
      mHomePressed=false;
      if (mHomeConsumed) {
        mHomeConsumed=false;
        return -1;
      }
      if (canceled) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      TelecommManager telecommManager=getTelecommService();
      if (telecommManager != null && telecommManager.isRinging()) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        mHomeDoubleTapPending=true;
        mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,ViewConfiguration.getDoubleTapTimeout());
        return -1;
      }
      launchHomeFromHotKey();
      return -1;
    }
    WindowManager.LayoutParams attrs=win != null ? win.getAttrs() : null;
    if (attrs != null) {
      final int type=attrs.type;
      if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        return 0;
      }
      final int typeCount=WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
      for (int i=0; i < typeCount; i++) {
        if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
          return -1;
        }
      }
    }
    if (repeatCount == 0) {
      mHomePressed=true;
      if (mHomeDoubleTapPending) {
        mHomeDoubleTapPending=false;
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        handleDoubleTapOnHome();
      }
 else       if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        preloadRecentApps();
      }
    }
 else     if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
      if (!keyguardOn) {
        handleLongPressOnHome();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_MENU) {
    final int chordBug=KeyEvent.META_SHIFT_ON;
    if (down && repeatCount == 0) {
      if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
        Intent intent=new Intent(Intent.ACTION_BUG_REPORT);
        mContext.sendOrderedBroadcastAsUser(intent,UserHandle.CURRENT,null,null,null,0,null,null);
        return -1;
      }
 else       if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
        Intent service=new Intent();
        service.setClassName(mContext,""String_Node_Str"");
        ContentResolver res=mContext.getContentResolver();
        boolean shown=Settings.Global.getInt(res,Settings.Global.SHOW_PROCESSES,0) != 0;
        if (!shown) {
          mContext.startService(service);
        }
 else {
          mContext.stopService(service);
        }
        Settings.Global.putInt(res,Settings.Global.SHOW_PROCESSES,shown ? 0 : 1);
        return -1;
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    if (down) {
      if (repeatCount == 0) {
        mSearchKeyShortcutPending=true;
        mConsumeSearchKeyUp=false;
      }
    }
 else {
      mSearchKeyShortcutPending=false;
      if (mConsumeSearchKeyUp) {
        mConsumeSearchKeyUp=false;
        return -1;
      }
    }
    return 0;
  }
 else   if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (!keyguardOn) {
      if (down && repeatCount == 0) {
        preloadRecentApps();
      }
 else       if (!down) {
        toggleRecentApps();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_ASSIST) {
    if (down) {
      if (repeatCount == 0) {
        mAssistKeyLongPressed=false;
      }
 else       if (repeatCount == 1) {
        mAssistKeyLongPressed=true;
        if (!keyguardOn) {
          launchAssistLongPressAction();
        }
      }
    }
 else {
      if (mAssistKeyLongPressed) {
        mAssistKeyLongPressed=false;
      }
 else {
        if (!keyguardOn) {
          launchAssistAction();
        }
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
    if (down && repeatCount == 0) {
      mHandler.post(mScreenshotRunnable);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
    if (down) {
      int direction=keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
      int auto=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      if (auto != 0) {
        Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      }
      int min=mPowerManager.getMinimumScreenBrightnessSetting();
      int max=mPowerManager.getMaximumScreenBrightnessSetting();
      int step=(max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
      int brightness=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,mPowerManager.getDefaultScreenBrightnessSetting(),UserHandle.USER_CURRENT_OR_SELF);
      brightness+=step;
      brightness=Math.min(max,brightness);
      brightness=Math.max(min,brightness);
      Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,brightness,UserHandle.USER_CURRENT_OR_SELF);
      Intent intent=new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
      mContext.sendBroadcastAsUser(intent,UserHandle.CURRENT_OR_SELF);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_META_LEFT) {
    if (down) {
      mPendingMetaAction=true;
    }
 else     if (mPendingMetaAction) {
      mPendingMetaAction=false;
      launchAssistAction();
    }
    return -1;
  }
  if (mSearchKeyShortcutPending) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      mConsumeSearchKeyUp=true;
      mSearchKeyShortcutPending=false;
      if (down && repeatCount == 0 && !keyguardOn) {
        Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState);
        if (shortcutIntent != null) {
          shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            mContext.startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
          }
 catch (          ActivityNotFoundException ex) {
            Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + KeyEvent.keyCodeToString(keyCode));
        }
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          mContext.startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
        }
 catch (        ActivityNotFoundException ex) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
        }
        return -1;
      }
    }
  }
  if (down && repeatCount == 0 && !keyguardOn) {
    String category=sApplicationLaunchKeyCategories.get(keyCode);
    if (category != null) {
      Intent intent=Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,category);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        mContext.startActivityAsUser(intent,UserHandle.CURRENT);
      }
 catch (      ActivityNotFoundException ex) {
        Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + keyCode + ""String_Node_Str""+ category,ex);
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
    if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
      final int shiftlessModifiers=event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
      if (KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_ALT_ON)) {
        mRecentAppsHeldModifiers=shiftlessModifiers;
        showRecentApps(true);
        return -1;
      }
    }
  }
 else   if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
    mRecentAppsHeldModifiers=0;
    hideRecentApps(true);
  }
  if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
    int direction=(metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
    mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(),direction);
    return -1;
  }
  if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
    mLanguageSwitchKeyPressed=false;
    return -1;
  }
  if (mGlobalKeyManager.handleGlobalKey(mContext,keyCode,event)) {
    return -1;
  }
  if ((metaState & KeyEvent.META_META_LEFT_ON) != 0) {
    return -1;
  }
  return 0;
}",0.9964558850960642
199019,"@Override public void setMode(int code,int uid,String packageName,int mode){
  verifyIncomingUid(uid);
  verifyIncomingOp(code);
  ArrayList<Callback> repCbs=null;
  code=AppOpsManager.opToSwitch(code);
synchronized (this) {
    Op op=getOpLocked(code,uid,packageName,true);
    if (op != null) {
      if (op.mode != mode) {
        op.mode=mode;
        ArrayList<Callback> cbs=mOpModeWatchers.get(code);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        cbs=mPackageModeWatchers.get(packageName);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        if (mode == AppOpsManager.opToDefaultMode(op.op)) {
          pruneOp(op,uid,packageName);
        }
        scheduleWriteNowLocked();
      }
    }
  }
  if (repCbs != null) {
    for (int i=0; i < repCbs.size(); i++) {
      try {
        repCbs.get(i).mCallback.opChanged(code,packageName);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","@Override public void setMode(int code,int uid,String packageName,int mode){
  if (Binder.getCallingPid() == Process.myPid()) {
    return;
  }
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  verifyIncomingOp(code);
  ArrayList<Callback> repCbs=null;
  code=AppOpsManager.opToSwitch(code);
synchronized (this) {
    Op op=getOpLocked(code,uid,packageName,true);
    if (op != null) {
      if (op.mode != mode) {
        op.mode=mode;
        ArrayList<Callback> cbs=mOpModeWatchers.get(code);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        cbs=mPackageModeWatchers.get(packageName);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        if (mode == AppOpsManager.opToDefaultMode(op.op)) {
          pruneOp(op,uid,packageName);
        }
        scheduleWriteNowLocked();
      }
    }
  }
  if (repCbs != null) {
    for (int i=0; i < repCbs.size(); i++) {
      try {
        repCbs.get(i).mCallback.opChanged(code,packageName);
      }
 catch (      RemoteException e) {
      }
    }
  }
}",0.9083469721767594
199020,"@Override public void setMode(int code,int uid,String packageName,int mode){
  verifyIncomingUid(uid);
  verifyIncomingOp(code);
  ArrayList<Callback> repCbs=null;
  code=AppOpsManager.opToSwitch(code);
synchronized (this) {
    Op op=getOpLocked(code,uid,packageName,true);
    if (op != null) {
      if (op.mode != mode) {
        op.mode=mode;
        ArrayList<Callback> cbs=mOpModeWatchers.get(code);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        cbs=mPackageModeWatchers.get(packageName);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        if (mode == AppOpsManager.opToDefaultMode(op.op)) {
          pruneOp(op,uid,packageName);
        }
        scheduleWriteNowLocked();
      }
    }
  }
  if (repCbs != null) {
    for (int i=0; i < repCbs.size(); i++) {
      try {
        repCbs.get(i).mCallback.opChanged(code,packageName);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","@Override public void setMode(int code,int uid,String packageName,int mode){
  if (Binder.getCallingPid() == Process.myPid()) {
    return;
  }
  mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
  verifyIncomingOp(code);
  ArrayList<Callback> repCbs=null;
  code=AppOpsManager.opToSwitch(code);
synchronized (this) {
    Op op=getOpLocked(code,uid,packageName,true);
    if (op != null) {
      if (op.mode != mode) {
        op.mode=mode;
        ArrayList<Callback> cbs=mOpModeWatchers.get(code);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        cbs=mPackageModeWatchers.get(packageName);
        if (cbs != null) {
          if (repCbs == null) {
            repCbs=new ArrayList<Callback>();
          }
          repCbs.addAll(cbs);
        }
        if (mode == AppOpsManager.opToDefaultMode(op.op)) {
          pruneOp(op,uid,packageName);
        }
        scheduleWriteNowLocked();
      }
    }
  }
  if (repCbs != null) {
    for (int i=0; i < repCbs.size(); i++) {
      try {
        repCbs.get(i).mCallback.opChanged(code,packageName);
      }
 catch (      RemoteException e) {
      }
    }
  }
}",0.9083469721767594
199021,"@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight;
  }
}","@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight * HEADER_RUBBERBAND_FACTOR;
  }
}",0.9401330376940134
199022,"public void panelExpansionChanged(PanelView panel,float frac){
  boolean fullyClosed=true;
  PanelView fullyOpenedPanel=null;
  if (DEBUG)   LOG(""String_Node_Str"",mState,panel.getName());
  mPanelExpandedFractionSum=0f;
  for (  PanelView pv : mPanels) {
    boolean visible=pv.getExpandedHeight() > 0;
    pv.setVisibility(visible ? View.VISIBLE : View.GONE);
    if (pv.getExpandedHeight() > 0f) {
      if (mState == STATE_CLOSED) {
        go(STATE_OPENING);
        onPanelPeeked();
      }
      fullyClosed=false;
      final float thisFrac=pv.getExpandedFraction();
      mPanelExpandedFractionSum+=(visible ? thisFrac : 0);
      if (DEBUG)       LOG(""String_Node_Str"",pv.getName(),thisFrac);
      if (panel == pv) {
        if (thisFrac == 1f)         fullyOpenedPanel=panel;
      }
    }
  }
  mPanelExpandedFractionSum/=mPanels.size();
  if (fullyOpenedPanel != null && !mTracking) {
    go(STATE_OPEN);
    onPanelFullyOpened(fullyOpenedPanel);
  }
 else   if (fullyClosed && !mTracking && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
  if (DEBUG)   LOG(""String_Node_Str"",mState,(fullyOpenedPanel != null) ? ""String_Node_Str"" : ""String_Node_Str"",fullyClosed ? ""String_Node_Str"" : ""String_Node_Str"");
}","/** 
 * @param panel the panel which changed its expansion state
 * @param frac the fraction from the expansion in [0, 1]
 * @param expanded whether the panel is currently expanded; this is independent from thefraction as the panel also might be expanded if the fraction is 0
 */
public void panelExpansionChanged(PanelView panel,float frac,boolean expanded){
  boolean fullyClosed=true;
  PanelView fullyOpenedPanel=null;
  if (DEBUG)   LOG(""String_Node_Str"",mState,panel.getName());
  mPanelExpandedFractionSum=0f;
  for (  PanelView pv : mPanels) {
    boolean visible=pv.getExpandedHeight() > 0;
    pv.setVisibility(visible ? View.VISIBLE : View.GONE);
    if (expanded) {
      if (mState == STATE_CLOSED) {
        go(STATE_OPENING);
        onPanelPeeked();
      }
      fullyClosed=false;
      final float thisFrac=pv.getExpandedFraction();
      mPanelExpandedFractionSum+=(visible ? thisFrac : 0);
      if (DEBUG)       LOG(""String_Node_Str"",pv.getName(),thisFrac);
      if (panel == pv) {
        if (thisFrac == 1f)         fullyOpenedPanel=panel;
      }
    }
  }
  mPanelExpandedFractionSum/=mPanels.size();
  if (fullyOpenedPanel != null && !mTracking) {
    go(STATE_OPEN);
    onPanelFullyOpened(fullyOpenedPanel);
  }
 else   if (fullyClosed && !mTracking && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
  if (DEBUG)   LOG(""String_Node_Str"",mState,(fullyOpenedPanel != null) ? ""String_Node_Str"" : ""String_Node_Str"",fullyClosed ? ""String_Node_Str"" : ""String_Node_Str"");
}",0.8841726618705036
199023,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  boolean waitForTouchSlop=hasConflictingGestures();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
mInitialOffsetOnTouch=mExpandedHeight;
mTouchSlopExceeded=false;
if (mVelocityTracker == null) {
initVelocityTracker();
}
trackMovement(event);
if (!waitForTouchSlop || (mHeightAnimator != null && !mHintAnimationRunning)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mTouchSlopExceeded=(mHeightAnimator != null && !mHintAnimationRunning);
onTrackingStarted();
}
if (mExpandedHeight == 0) {
mJustPeeked=true;
runPeekAnimation();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
float h=y - mInitialTouchY;
if (Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)) {
mTouchSlopExceeded=true;
if (waitForTouchSlop && !mTracking) {
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchX=x;
mInitialTouchY=y;
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
onTrackingStarted();
h=0;
}
}
final float newHeight=h + mInitialOffsetOnTouch;
if (newHeight > mPeekHeight) {
if (mPeekAnimator != null && mPeekAnimator.isStarted()) {
mPeekAnimator.cancel();
}
mJustPeeked=false;
}
if (!mJustPeeked && (!waitForTouchSlop || mTracking)) {
setExpandedHeightInternal(newHeight);
mBar.panelExpansionChanged(PanelView.this,mExpandedFraction);
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mTrackingPointer=-1;
trackMovement(event);
if ((mTracking && mTouchSlopExceeded) || event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
float vel=getCurrentVelocity();
boolean expand=flingExpands(vel);
onTrackingStopped(expand);
fling(vel,expand);
}
 else {
boolean expands=onEmptySpaceClick(mInitialTouchX);
onTrackingStopped(expands);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
return !waitForTouchSlop || mTracking;
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  boolean waitForTouchSlop=hasConflictingGestures();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
mInitialOffsetOnTouch=mExpandedHeight;
mTouchSlopExceeded=false;
mJustPeeked=false;
if (mVelocityTracker == null) {
initVelocityTracker();
}
trackMovement(event);
if (!waitForTouchSlop || (mHeightAnimator != null && !mHintAnimationRunning)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mTouchSlopExceeded=(mHeightAnimator != null && !mHintAnimationRunning);
onTrackingStarted();
}
if (mExpandedHeight == 0) {
mJustPeeked=true;
runPeekAnimation();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
float h=y - mInitialTouchY;
if (Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)) {
mTouchSlopExceeded=true;
if (waitForTouchSlop && !mTracking) {
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchX=x;
mInitialTouchY=y;
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
onTrackingStarted();
h=0;
}
}
final float newHeight=h + mInitialOffsetOnTouch;
if (newHeight > mPeekHeight) {
if (mPeekAnimator != null && mPeekAnimator.isStarted()) {
mPeekAnimator.cancel();
}
mJustPeeked=false;
}
if (!mJustPeeked && (!waitForTouchSlop || mTracking)) {
setExpandedHeightInternal(newHeight);
mBar.panelExpansionChanged(PanelView.this,mExpandedFraction);
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mTrackingPointer=-1;
trackMovement(event);
if ((mTracking && mTouchSlopExceeded) || event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
float vel=getCurrentVelocity();
boolean expand=flingExpands(vel);
onTrackingStopped(expand);
fling(vel,expand);
}
 else {
boolean expands=onEmptySpaceClick(mInitialTouchX);
onTrackingStopped(expands);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
return !waitForTouchSlop || mTracking;
}",0.9964372773298332
199024,"@Override public boolean onInterceptTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float x=event.getX(pointerIndex);
  final float y=event.getY(pointerIndex);
  boolean scrolledToBottom=isScrolledToBottom();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    if (mHeightAnimator != null && !mHintAnimationRunning) {
      mHeightAnimator.cancel();
      mTouchSlopExceeded=true;
      return true;
    }
  mInitialTouchY=y;
mInitialTouchX=x;
mTouchSlopExceeded=false;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
mTrackingPointer=event.getPointerId(newIndex);
mInitialTouchX=event.getX(newIndex);
mInitialTouchY=event.getY(newIndex);
}
break;
case MotionEvent.ACTION_MOVE:
final float h=y - mInitialTouchY;
trackMovement(event);
if (scrolledToBottom) {
if (h < -mTouchSlop && h < -Math.abs(x - mInitialTouchX)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=y;
mInitialTouchX=x;
mTracking=true;
mTouchSlopExceeded=true;
onTrackingStarted();
return true;
}
}
break;
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float x=event.getX(pointerIndex);
  final float y=event.getY(pointerIndex);
  boolean scrolledToBottom=isScrolledToBottom();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    if (mHeightAnimator != null && !mHintAnimationRunning) {
      mHeightAnimator.cancel();
      mTouchSlopExceeded=true;
      return true;
    }
  mInitialTouchY=y;
mInitialTouchX=x;
mTouchSlopExceeded=false;
mJustPeeked=false;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
mTrackingPointer=event.getPointerId(newIndex);
mInitialTouchX=event.getX(newIndex);
mInitialTouchY=event.getY(newIndex);
}
break;
case MotionEvent.ACTION_MOVE:
final float h=y - mInitialTouchY;
trackMovement(event);
if (scrolledToBottom) {
if (h < -mTouchSlop && h < -Math.abs(x - mInitialTouchX)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=y;
mInitialTouchX=x;
mTracking=true;
mTouchSlopExceeded=true;
onTrackingStarted();
return true;
}
}
break;
}
return false;
}",0.9936305732484076
199025,"/** 
 * Start an animation to the given viewState
 */
private void startAnimations(final ExpandableView child,StackScrollState.ViewState viewState,StackScrollState finalState){
  int childVisibility=child.getVisibility();
  boolean wasVisible=childVisibility == View.VISIBLE;
  final float alpha=viewState.alpha;
  if (!wasVisible && alpha != 0 && !viewState.gone) {
    child.setVisibility(View.VISIBLE);
  }
  boolean yTranslationChanging=child.getTranslationY() != viewState.yTranslation;
  boolean zTranslationChanging=child.getTranslationZ() != viewState.zTranslation;
  boolean scaleChanging=child.getScaleX() != viewState.scale;
  boolean alphaChanging=alpha != child.getAlpha();
  boolean heightChanging=viewState.height != child.getActualHeight();
  boolean topInsetChanging=viewState.clipTopAmount != child.getClipTopAmount();
  boolean wasAdded=mNewAddChildren.contains(child);
  boolean hasDelays=mAnimationFilter.hasDelays;
  boolean isDelayRelevant=yTranslationChanging || zTranslationChanging || scaleChanging|| alphaChanging|| heightChanging|| topInsetChanging;
  long delay=0;
  if (hasDelays && isDelayRelevant || wasAdded) {
    delay=calculateChildAnimationDelay(viewState,finalState);
  }
  if (yTranslationChanging) {
    startYTranslationAnimation(child,viewState,delay);
  }
  if (zTranslationChanging) {
    startZTranslationAnimation(child,viewState,delay);
  }
  if (scaleChanging) {
    startScaleAnimation(child,viewState);
  }
  if (alphaChanging) {
    startAlphaAnimation(child,viewState,delay);
  }
  if (heightChanging) {
    startHeightAnimation(child,viewState,delay);
  }
  if (topInsetChanging) {
    startInsetAnimation(child,viewState,delay);
  }
  child.setDimmed(viewState.dimmed,mAnimationFilter.animateDimmed);
  child.setDark(viewState.dark,mAnimationFilter.animateDark);
  child.setScrimAmount(viewState.scrimAmount);
  if (wasAdded) {
    child.performAddAnimation(delay);
  }
}","/** 
 * Start an animation to the given viewState
 */
private void startAnimations(final ExpandableView child,StackScrollState.ViewState viewState,StackScrollState finalState){
  int childVisibility=child.getVisibility();
  boolean wasVisible=childVisibility == View.VISIBLE;
  final float alpha=viewState.alpha;
  if (!wasVisible && alpha != 0 && !viewState.gone) {
    child.setVisibility(View.VISIBLE);
  }
  boolean yTranslationChanging=child.getTranslationY() != viewState.yTranslation;
  boolean zTranslationChanging=child.getTranslationZ() != viewState.zTranslation;
  boolean scaleChanging=child.getScaleX() != viewState.scale;
  boolean alphaChanging=alpha != child.getAlpha();
  boolean heightChanging=viewState.height != child.getActualHeight();
  boolean topInsetChanging=viewState.clipTopAmount != child.getClipTopAmount();
  boolean wasAdded=mNewAddChildren.contains(child);
  boolean hasDelays=mAnimationFilter.hasDelays;
  boolean isDelayRelevant=yTranslationChanging || zTranslationChanging || scaleChanging|| alphaChanging|| heightChanging|| topInsetChanging;
  long delay=0;
  if (hasDelays && isDelayRelevant || wasAdded) {
    delay=calculateChildAnimationDelay(viewState,finalState);
  }
  if (yTranslationChanging) {
    startYTranslationAnimation(child,viewState,delay);
  }
  if (zTranslationChanging) {
    startZTranslationAnimation(child,viewState,delay);
  }
  if (scaleChanging) {
    startScaleAnimation(child,viewState);
  }
  if (alphaChanging) {
    startAlphaAnimation(child,viewState,delay);
  }
  if (heightChanging) {
    startHeightAnimation(child,viewState,delay);
  }
  if (topInsetChanging) {
    startInsetAnimation(child,viewState,delay);
  }
  child.setDimmed(viewState.dimmed,mAnimationFilter.animateDimmed && !wasAdded);
  child.setDark(viewState.dark,mAnimationFilter.animateDark);
  child.setScrimAmount(viewState.scrimAmount);
  if (wasAdded) {
    child.performAddAnimation(delay);
  }
}",0.996634739839503
199026,"/** 
 * Start an animation to the given viewState
 */
private void startAnimations(final ExpandableView child,StackScrollState.ViewState viewState,StackScrollState finalState){
  int childVisibility=child.getVisibility();
  boolean wasVisible=childVisibility == View.VISIBLE;
  final float alpha=viewState.alpha;
  if (!wasVisible && alpha != 0 && !viewState.gone) {
    child.setVisibility(View.VISIBLE);
  }
  boolean yTranslationChanging=child.getTranslationY() != viewState.yTranslation;
  boolean zTranslationChanging=child.getTranslationZ() != viewState.zTranslation;
  boolean scaleChanging=child.getScaleX() != viewState.scale;
  boolean alphaChanging=alpha != child.getAlpha();
  boolean heightChanging=viewState.height != child.getActualHeight();
  boolean topInsetChanging=viewState.clipTopAmount != child.getClipTopAmount();
  boolean wasAdded=mNewAddChildren.contains(child);
  boolean hasDelays=mAnimationFilter.hasDelays;
  boolean isDelayRelevant=yTranslationChanging || zTranslationChanging || scaleChanging|| alphaChanging|| heightChanging|| topInsetChanging;
  long delay=0;
  if (hasDelays && isDelayRelevant || wasAdded) {
    delay=calculateChildAnimationDelay(viewState,finalState);
  }
  if (yTranslationChanging) {
    startYTranslationAnimation(child,viewState,delay);
  }
  if (zTranslationChanging) {
    startZTranslationAnimation(child,viewState,delay);
  }
  if (scaleChanging) {
    startScaleAnimation(child,viewState);
  }
  if (alphaChanging) {
    startAlphaAnimation(child,viewState,delay);
  }
  if (heightChanging) {
    startHeightAnimation(child,viewState,delay);
  }
  if (topInsetChanging) {
    startInsetAnimation(child,viewState,delay);
  }
  child.setDimmed(viewState.dimmed,mAnimationFilter.animateDimmed);
  child.setDark(viewState.dark,mAnimationFilter.animateDark);
  child.setScrimAmount(viewState.scrimAmount);
  if (wasAdded) {
    child.performAddAnimation(delay);
  }
}","/** 
 * Start an animation to the given viewState
 */
private void startAnimations(final ExpandableView child,StackScrollState.ViewState viewState,StackScrollState finalState){
  int childVisibility=child.getVisibility();
  boolean wasVisible=childVisibility == View.VISIBLE;
  final float alpha=viewState.alpha;
  if (!wasVisible && alpha != 0 && !viewState.gone) {
    child.setVisibility(View.VISIBLE);
  }
  boolean yTranslationChanging=child.getTranslationY() != viewState.yTranslation;
  boolean zTranslationChanging=child.getTranslationZ() != viewState.zTranslation;
  boolean scaleChanging=child.getScaleX() != viewState.scale;
  boolean alphaChanging=alpha != child.getAlpha();
  boolean heightChanging=viewState.height != child.getActualHeight();
  boolean topInsetChanging=viewState.clipTopAmount != child.getClipTopAmount();
  boolean wasAdded=mNewAddChildren.contains(child);
  boolean hasDelays=mAnimationFilter.hasDelays;
  boolean isDelayRelevant=yTranslationChanging || zTranslationChanging || scaleChanging|| alphaChanging|| heightChanging|| topInsetChanging;
  long delay=0;
  if (hasDelays && isDelayRelevant || wasAdded) {
    delay=calculateChildAnimationDelay(viewState,finalState);
  }
  if (yTranslationChanging) {
    startYTranslationAnimation(child,viewState,delay);
  }
  if (zTranslationChanging) {
    startZTranslationAnimation(child,viewState,delay);
  }
  if (scaleChanging) {
    startScaleAnimation(child,viewState);
  }
  if (alphaChanging) {
    startAlphaAnimation(child,viewState,delay);
  }
  if (heightChanging) {
    startHeightAnimation(child,viewState,delay);
  }
  if (topInsetChanging) {
    startInsetAnimation(child,viewState,delay);
  }
  child.setDimmed(viewState.dimmed,mAnimationFilter.animateDimmed && !wasAdded);
  child.setDark(viewState.dark,mAnimationFilter.animateDark);
  child.setScrimAmount(viewState.scrimAmount);
  if (wasAdded) {
    child.performAddAnimation(delay);
  }
}",0.996634739839503
199027,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  boolean waitForTouchSlop=hasConflictingGestures();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
mInitialOffsetOnTouch=mExpandedHeight;
mTouchSlopExceeded=false;
if (mVelocityTracker == null) {
initVelocityTracker();
}
trackMovement(event);
if (!waitForTouchSlop || (mHeightAnimator != null && !mHintAnimationRunning)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mTouchSlopExceeded=(mHeightAnimator != null && !mHintAnimationRunning);
onTrackingStarted();
}
if (mExpandedHeight == 0) {
mJustPeeked=true;
runPeekAnimation();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
float h=y - mInitialTouchY;
if (Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)) {
mTouchSlopExceeded=true;
if (waitForTouchSlop && !mTracking) {
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchX=x;
mInitialTouchY=y;
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
onTrackingStarted();
h=0;
}
}
final float newHeight=h + mInitialOffsetOnTouch;
if (newHeight > mPeekHeight) {
if (mPeekAnimator != null && mPeekAnimator.isStarted()) {
mPeekAnimator.cancel();
}
mJustPeeked=false;
}
if (!mJustPeeked && (!waitForTouchSlop || mTracking)) {
setExpandedHeightInternal(newHeight);
mBar.panelExpansionChanged(PanelView.this,mExpandedFraction);
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mTrackingPointer=-1;
trackMovement(event);
if ((mTracking && mTouchSlopExceeded) || event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
float vel=getCurrentVelocity();
boolean expand=flingExpands(vel);
onTrackingStopped(expand);
fling(vel,expand);
}
 else {
boolean expands=onEmptySpaceClick(mInitialTouchX);
onTrackingStopped(expands);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
return !waitForTouchSlop || mTracking;
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  boolean waitForTouchSlop=hasConflictingGestures();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
mInitialOffsetOnTouch=mExpandedHeight;
mTouchSlopExceeded=false;
mJustPeeked=false;
if (mVelocityTracker == null) {
initVelocityTracker();
}
trackMovement(event);
if (!waitForTouchSlop || (mHeightAnimator != null && !mHintAnimationRunning)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mTouchSlopExceeded=(mHeightAnimator != null && !mHintAnimationRunning);
onTrackingStarted();
}
if (mExpandedHeight == 0) {
mJustPeeked=true;
runPeekAnimation();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
float h=y - mInitialTouchY;
if (Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)) {
mTouchSlopExceeded=true;
if (waitForTouchSlop && !mTracking) {
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchX=x;
mInitialTouchY=y;
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
onTrackingStarted();
h=0;
}
}
final float newHeight=h + mInitialOffsetOnTouch;
if (newHeight > mPeekHeight) {
if (mPeekAnimator != null && mPeekAnimator.isStarted()) {
mPeekAnimator.cancel();
}
mJustPeeked=false;
}
if (!mJustPeeked && (!waitForTouchSlop || mTracking)) {
setExpandedHeightInternal(newHeight);
mBar.panelExpansionChanged(PanelView.this,mExpandedFraction);
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mTrackingPointer=-1;
trackMovement(event);
if ((mTracking && mTouchSlopExceeded) || event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
float vel=getCurrentVelocity();
boolean expand=flingExpands(vel);
onTrackingStopped(expand);
fling(vel,expand);
}
 else {
boolean expands=onEmptySpaceClick(mInitialTouchX);
onTrackingStopped(expands);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
return !waitForTouchSlop || mTracking;
}",0.9964372773298332
199028,"@Override public boolean onInterceptTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float x=event.getX(pointerIndex);
  final float y=event.getY(pointerIndex);
  boolean scrolledToBottom=isScrolledToBottom();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    if (mHeightAnimator != null && !mHintAnimationRunning) {
      mHeightAnimator.cancel();
      mTouchSlopExceeded=true;
      return true;
    }
  mInitialTouchY=y;
mInitialTouchX=x;
mTouchSlopExceeded=false;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
mTrackingPointer=event.getPointerId(newIndex);
mInitialTouchX=event.getX(newIndex);
mInitialTouchY=event.getY(newIndex);
}
break;
case MotionEvent.ACTION_MOVE:
final float h=y - mInitialTouchY;
trackMovement(event);
if (scrolledToBottom) {
if (h < -mTouchSlop && h < -Math.abs(x - mInitialTouchX)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=y;
mInitialTouchX=x;
mTracking=true;
mTouchSlopExceeded=true;
onTrackingStarted();
return true;
}
}
break;
}
return false;
}","@Override public boolean onInterceptTouchEvent(MotionEvent event){
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float x=event.getX(pointerIndex);
  final float y=event.getY(pointerIndex);
  boolean scrolledToBottom=isScrolledToBottom();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    if (mHeightAnimator != null && !mHintAnimationRunning) {
      mHeightAnimator.cancel();
      mTouchSlopExceeded=true;
      return true;
    }
  mInitialTouchY=y;
mInitialTouchX=x;
mTouchSlopExceeded=false;
mJustPeeked=false;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
mTrackingPointer=event.getPointerId(newIndex);
mInitialTouchX=event.getX(newIndex);
mInitialTouchY=event.getY(newIndex);
}
break;
case MotionEvent.ACTION_MOVE:
final float h=y - mInitialTouchY;
trackMovement(event);
if (scrolledToBottom) {
if (h < -mTouchSlop && h < -Math.abs(x - mInitialTouchX)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=y;
mInitialTouchX=x;
mTracking=true;
mTouchSlopExceeded=true;
onTrackingStarted();
return true;
}
}
break;
}
return false;
}",0.9936305732484076
199029,"@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight;
  }
}","@Override protected float getPeekHeight(){
  if (mNotificationStackScroller.getNotGoneChildCount() > 0) {
    return mNotificationStackScroller.getPeekHeight();
  }
 else {
    return mQsMinExpansionHeight * HEADER_RUBBERBAND_FACTOR;
  }
}",0.9401330376940134
199030,"public void panelExpansionChanged(PanelView panel,float frac){
  boolean fullyClosed=true;
  PanelView fullyOpenedPanel=null;
  if (DEBUG)   LOG(""String_Node_Str"",mState,panel.getName());
  mPanelExpandedFractionSum=0f;
  for (  PanelView pv : mPanels) {
    boolean visible=pv.getExpandedHeight() > 0;
    pv.setVisibility(visible ? View.VISIBLE : View.GONE);
    if (pv.getExpandedHeight() > 0f) {
      if (mState == STATE_CLOSED) {
        go(STATE_OPENING);
        onPanelPeeked();
      }
      fullyClosed=false;
      final float thisFrac=pv.getExpandedFraction();
      mPanelExpandedFractionSum+=(visible ? thisFrac : 0);
      if (DEBUG)       LOG(""String_Node_Str"",pv.getName(),thisFrac);
      if (panel == pv) {
        if (thisFrac == 1f)         fullyOpenedPanel=panel;
      }
    }
  }
  mPanelExpandedFractionSum/=mPanels.size();
  if (fullyOpenedPanel != null && !mTracking) {
    go(STATE_OPEN);
    onPanelFullyOpened(fullyOpenedPanel);
  }
 else   if (fullyClosed && !mTracking && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
  if (DEBUG)   LOG(""String_Node_Str"",mState,(fullyOpenedPanel != null) ? ""String_Node_Str"" : ""String_Node_Str"",fullyClosed ? ""String_Node_Str"" : ""String_Node_Str"");
}","/** 
 * @param panel the panel which changed its expansion state
 * @param frac the fraction from the expansion in [0, 1]
 * @param expanded whether the panel is currently expanded; this is independent from thefraction as the panel also might be expanded if the fraction is 0
 */
public void panelExpansionChanged(PanelView panel,float frac,boolean expanded){
  boolean fullyClosed=true;
  PanelView fullyOpenedPanel=null;
  if (DEBUG)   LOG(""String_Node_Str"",mState,panel.getName());
  mPanelExpandedFractionSum=0f;
  for (  PanelView pv : mPanels) {
    boolean visible=pv.getExpandedHeight() > 0;
    pv.setVisibility(visible ? View.VISIBLE : View.GONE);
    if (expanded) {
      if (mState == STATE_CLOSED) {
        go(STATE_OPENING);
        onPanelPeeked();
      }
      fullyClosed=false;
      final float thisFrac=pv.getExpandedFraction();
      mPanelExpandedFractionSum+=(visible ? thisFrac : 0);
      if (DEBUG)       LOG(""String_Node_Str"",pv.getName(),thisFrac);
      if (panel == pv) {
        if (thisFrac == 1f)         fullyOpenedPanel=panel;
      }
    }
  }
  mPanelExpandedFractionSum/=mPanels.size();
  if (fullyOpenedPanel != null && !mTracking) {
    go(STATE_OPEN);
    onPanelFullyOpened(fullyOpenedPanel);
  }
 else   if (fullyClosed && !mTracking && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
  if (DEBUG)   LOG(""String_Node_Str"",mState,(fullyOpenedPanel != null) ? ""String_Node_Str"" : ""String_Node_Str"",fullyClosed ? ""String_Node_Str"" : ""String_Node_Str"");
}",0.8841726618705036
199031,"@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  Map<String,String> defaultPropMap=null;
  boolean isPlatformFile=true;
  if (set instanceof BridgeXmlBlockParser) {
    BridgeXmlBlockParser parser=null;
    parser=(BridgeXmlBlockParser)set;
    isPlatformFile=parser.isPlatformFile();
    Object key=parser.getViewCookie();
    if (key != null) {
      defaultPropMap=mDefaultPropMaps.get(key);
      if (defaultPropMap == null) {
        defaultPropMap=new HashMap<String,String>();
        mDefaultPropMaps.put(key,defaultPropMap);
      }
    }
  }
 else   if (set instanceof BridgeLayoutParamsMapAttributes) {
    isPlatformFile=false;
  }
 else   if (set != null) {
    Bridge.getLog().error(LayoutLog.TAG_BROKEN,""String_Node_Str"",null);
    return null;
  }
  List<Pair<String,Boolean>> attributeList=searchAttrs(attrs);
  BridgeTypedArray ta=((BridgeResources)mSystemResources).newTypeArray(attrs.length,isPlatformFile);
  String customStyle=null;
  if (set != null) {
    customStyle=set.getAttributeValue(null,""String_Node_Str"");
  }
  StyleResourceValue customStyleValues=null;
  if (customStyle != null) {
    ResourceValue item=mRenderResources.findResValue(customStyle,isPlatformFile);
    item=mRenderResources.resolveResValue(item);
    if (item instanceof StyleResourceValue) {
      customStyleValues=(StyleResourceValue)item;
    }
  }
  StyleResourceValue defStyleValues=null;
  if (defStyleAttr != 0) {
    Pair<String,Boolean> defStyleAttribute=searchAttr(defStyleAttr);
    if (defaultPropMap != null) {
      String defStyleName=defStyleAttribute.getFirst();
      if (defStyleAttribute.getSecond()) {
        defStyleName=""String_Node_Str"" + defStyleName;
      }
      defaultPropMap.put(""String_Node_Str"",defStyleName);
    }
    ResourceValue item=mRenderResources.findItemInTheme(defStyleAttribute.getFirst(),defStyleAttribute.getSecond());
    if (item != null) {
      item=mRenderResources.findResValue(item.getValue(),false);
      if (item instanceof StyleResourceValue) {
        defStyleValues=(StyleResourceValue)item;
      }
    }
 else {
      Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE_THEME_ATTR,String.format(""String_Node_Str"",defStyleAttribute.getFirst()),null);
    }
  }
 else   if (defStyleRes != 0) {
    boolean isFrameworkRes=true;
    Pair<ResourceType,String> value=Bridge.resolveResourceId(defStyleRes);
    if (value == null) {
      value=mProjectCallback.resolveResourceId(defStyleRes);
      isFrameworkRes=false;
    }
    if (value != null) {
      if ((value.getFirst() == ResourceType.STYLE) || (value.getFirst() == ResourceType.ATTR)) {
        ResourceValue item=mRenderResources.findItemInTheme(value.getSecond(),isFrameworkRes);
        if (item != null) {
          if (item instanceof StyleResourceValue) {
            if (defaultPropMap != null) {
              defaultPropMap.put(""String_Node_Str"",item.getName());
            }
            defStyleValues=(StyleResourceValue)item;
          }
        }
 else {
          Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getSecond()),null);
        }
      }
 else {
        Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getFirst().toString()),null);
      }
    }
 else {
      Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes),null);
    }
  }
  String appNamespace=mProjectCallback.getNamespace();
  if (attributeList != null) {
    for (int index=0; index < attributeList.size(); index++) {
      Pair<String,Boolean> attribute=attributeList.get(index);
      if (attribute == null) {
        continue;
      }
      String attrName=attribute.getFirst();
      boolean frameworkAttr=attribute.getSecond().booleanValue();
      String value=null;
      if (set != null) {
        value=set.getAttributeValue(frameworkAttr ? BridgeConstants.NS_RESOURCES : appNamespace,attrName);
        if (frameworkAttr == false && value == null) {
          value=set.getAttributeValue(BridgeConstants.NS_APP_RES_AUTO,attrName);
        }
      }
      if (value == null) {
        ResourceValue resValue=null;
        if (customStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(customStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null && defStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(defStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null) {
          resValue=mRenderResources.findItemInTheme(attrName,frameworkAttr);
        }
        if (resValue != null) {
          if (defaultPropMap != null) {
            defaultPropMap.put(attrName,resValue.getValue());
          }
          resValue=mRenderResources.resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,attrName,frameworkAttr,resValue);
      }
 else {
        ta.bridgeSetValue(index,attrName,frameworkAttr,mRenderResources.resolveValue(null,attrName,value,isPlatformFile));
      }
    }
  }
  ta.sealArray();
  return ta;
}","@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  Map<String,String> defaultPropMap=null;
  boolean isPlatformFile=true;
  if (set instanceof BridgeXmlBlockParser) {
    BridgeXmlBlockParser parser=null;
    parser=(BridgeXmlBlockParser)set;
    isPlatformFile=parser.isPlatformFile();
    Object key=parser.getViewCookie();
    if (key != null) {
      defaultPropMap=mDefaultPropMaps.get(key);
      if (defaultPropMap == null) {
        defaultPropMap=new HashMap<String,String>();
        mDefaultPropMaps.put(key,defaultPropMap);
      }
    }
  }
 else   if (set instanceof BridgeLayoutParamsMapAttributes) {
    isPlatformFile=false;
  }
 else   if (set != null) {
    Bridge.getLog().error(LayoutLog.TAG_BROKEN,""String_Node_Str"",null);
    return null;
  }
  List<Pair<String,Boolean>> attributeList=searchAttrs(attrs);
  BridgeTypedArray ta=((BridgeResources)mSystemResources).newTypeArray(attrs.length,isPlatformFile);
  String customStyle=null;
  if (set != null) {
    customStyle=set.getAttributeValue(null,""String_Node_Str"");
  }
  StyleResourceValue customStyleValues=null;
  if (customStyle != null) {
    ResourceValue item=mRenderResources.findResValue(customStyle,isPlatformFile);
    item=mRenderResources.resolveResValue(item);
    if (item instanceof StyleResourceValue) {
      customStyleValues=(StyleResourceValue)item;
    }
  }
  StyleResourceValue defStyleValues=null;
  if (defStyleAttr != 0) {
    Pair<String,Boolean> defStyleAttribute=searchAttr(defStyleAttr);
    if (defaultPropMap != null) {
      String defStyleName=defStyleAttribute.getFirst();
      if (defStyleAttribute.getSecond()) {
        defStyleName=""String_Node_Str"" + defStyleName;
      }
      defaultPropMap.put(""String_Node_Str"",defStyleName);
    }
    ResourceValue item=mRenderResources.findItemInTheme(defStyleAttribute.getFirst(),defStyleAttribute.getSecond());
    if (item != null) {
      item=mRenderResources.findResValue(item.getValue(),item.isFramework());
      if (item instanceof StyleResourceValue) {
        defStyleValues=(StyleResourceValue)item;
      }
    }
 else {
      Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE_THEME_ATTR,String.format(""String_Node_Str"",defStyleAttribute.getFirst()),null);
    }
  }
 else   if (defStyleRes != 0) {
    boolean isFrameworkRes=true;
    Pair<ResourceType,String> value=Bridge.resolveResourceId(defStyleRes);
    if (value == null) {
      value=mProjectCallback.resolveResourceId(defStyleRes);
      isFrameworkRes=false;
    }
    if (value != null) {
      if ((value.getFirst() == ResourceType.STYLE) || (value.getFirst() == ResourceType.ATTR)) {
        ResourceValue item=mRenderResources.findItemInTheme(value.getSecond(),isFrameworkRes);
        if (item != null) {
          if (item instanceof StyleResourceValue) {
            if (defaultPropMap != null) {
              defaultPropMap.put(""String_Node_Str"",item.getName());
            }
            defStyleValues=(StyleResourceValue)item;
          }
        }
 else {
          Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getSecond()),null);
        }
      }
 else {
        Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getFirst().toString()),null);
      }
    }
 else {
      Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes),null);
    }
  }
  String appNamespace=mProjectCallback.getNamespace();
  if (attributeList != null) {
    for (int index=0; index < attributeList.size(); index++) {
      Pair<String,Boolean> attribute=attributeList.get(index);
      if (attribute == null) {
        continue;
      }
      String attrName=attribute.getFirst();
      boolean frameworkAttr=attribute.getSecond().booleanValue();
      String value=null;
      if (set != null) {
        value=set.getAttributeValue(frameworkAttr ? BridgeConstants.NS_RESOURCES : appNamespace,attrName);
        if (frameworkAttr == false && value == null) {
          value=set.getAttributeValue(BridgeConstants.NS_APP_RES_AUTO,attrName);
        }
      }
      if (value == null) {
        ResourceValue resValue=null;
        if (customStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(customStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null && defStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(defStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null) {
          resValue=mRenderResources.findItemInTheme(attrName,frameworkAttr);
        }
        if (resValue != null) {
          if (defaultPropMap != null) {
            defaultPropMap.put(attrName,resValue.getValue());
          }
          resValue=mRenderResources.resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,attrName,frameworkAttr,resValue);
      }
 else {
        ta.bridgeSetValue(index,attrName,frameworkAttr,mRenderResources.resolveValue(null,attrName,value,isPlatformFile));
      }
    }
  }
  ta.sealArray();
  return ta;
}",0.9977377790892102
199032,"private InputStream getIconWithApi(String[] pathOut,String iconName){
  if (mSimulatedPlatformVersion == 0) {
    String path=pathOut[0];
    String dirName=path.substring(0,path.lastIndexOf('/'));
    pathOut[0]=dirName + ""String_Node_Str"" + ""String_Node_Str""+ iconName;
    InputStream stream=getClass().getResourceAsStream(pathOut[0]);
    if (stream != null) {
      return stream;
    }
  }
  return getClass().getResourceAsStream(pathOut[0]);
}","private InputStream getIconWithApi(String[] pathOut,String iconName){
  if (mSimulatedPlatformVersion == 0) {
    String path=pathOut[0];
    String dirName=path.substring(0,path.lastIndexOf('/'));
    path=dirName + ""String_Node_Str"" + ""String_Node_Str""+ iconName;
    InputStream stream=getClass().getResourceAsStream(path);
    if (stream != null) {
      pathOut[0]=path;
      return stream;
    }
  }
  return getClass().getResourceAsStream(pathOut[0]);
}",0.566410537870472
199033,"/** 
 * A new GATT descriptor has been discovered. Finally, add the descriptor to the related characteristic. This should conclude the remote device update.
 * @hide
 */
public void onGetDescriptor(String address,int srvcType,int srvcInstId,ParcelUuid srvcUuid,int charInstId,ParcelUuid charUuid,int descrInstId,ParcelUuid descUuid){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + address + ""String_Node_Str""+ descUuid);
  if (!address.equals(mDevice.getAddress())) {
    return;
  }
  BluetoothGattService service=getService(mDevice,srvcUuid.getUuid(),srvcInstId,srvcType);
  if (service == null)   return;
  BluetoothGattCharacteristic characteristic=service.getCharacteristic(charUuid.getUuid());
  if (characteristic == null)   return;
  characteristic.addDescriptor(new BluetoothGattDescriptor(characteristic,descUuid.getUuid(),descrInstId,0));
}","/** 
 * A new GATT descriptor has been discovered. Finally, add the descriptor to the related characteristic. This should conclude the remote device update.
 * @hide
 */
public void onGetDescriptor(String address,int srvcType,int srvcInstId,ParcelUuid srvcUuid,int charInstId,ParcelUuid charUuid,int descrInstId,ParcelUuid descUuid){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + address + ""String_Node_Str""+ descUuid);
  if (!address.equals(mDevice.getAddress())) {
    return;
  }
  BluetoothGattService service=getService(mDevice,srvcUuid.getUuid(),srvcInstId,srvcType);
  if (service == null)   return;
  BluetoothGattCharacteristic characteristic=service.getCharacteristic(charUuid.getUuid(),charInstId);
  if (characteristic == null)   return;
  characteristic.addDescriptor(new BluetoothGattDescriptor(characteristic,descUuid.getUuid(),descrInstId,0));
}",0.9935483870967742
199034,"private int[] collectStats(String statsFile,int parentPid,boolean first,int[] curPids,ArrayList<Stats> allProcs){
  int[] pids=Process.getPids(statsFile,curPids);
  int NP=(pids == null) ? 0 : pids.length;
  int NS=allProcs.size();
  int curStatsIndex=0;
  for (int i=0; i < NP; i++) {
    int pid=pids[i];
    if (pid < 0) {
      NP=pid;
      break;
    }
    Stats st=curStatsIndex < NS ? allProcs.get(curStatsIndex) : null;
    if (st != null && st.pid == pid) {
      st.added=false;
      st.working=false;
      curStatsIndex++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      if (st.interesting) {
        final long uptime=SystemClock.uptimeMillis();
        final long[] procStats=mProcessStatsData;
        if (!Process.readProcFile(st.statFile.toString(),PROCESS_STATS_FORMAT,null,procStats,null)) {
          continue;
        }
        final long minfaults=procStats[PROCESS_STAT_MINOR_FAULTS];
        final long majfaults=procStats[PROCESS_STAT_MAJOR_FAULTS];
        final long utime=procStats[PROCESS_STAT_UTIME];
        final long stime=procStats[PROCESS_STAT_STIME];
        if (utime == st.base_utime && stime == st.base_stime) {
          st.rel_utime=0;
          st.rel_stime=0;
          st.rel_minfaults=0;
          st.rel_majfaults=0;
          if (st.active) {
            st.active=false;
          }
          continue;
        }
        if (!st.active) {
          st.active=true;
        }
        if (parentPid < 0) {
          getName(st,st.cmdlineFile);
          if (st.threadStats != null) {
            mCurThreadPids=collectStats(st.threadsDir,pid,false,mCurThreadPids,st.threadStats);
          }
        }
        if (DEBUG)         Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ utime+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ stime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ minfaults+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ majfaults+ ""String_Node_Str""+ st.base_majfaults);
        st.rel_uptime=uptime - st.base_uptime;
        st.base_uptime=uptime;
        st.rel_utime=(int)(utime - st.base_utime);
        st.rel_stime=(int)(stime - st.base_stime);
        st.base_utime=utime;
        st.base_stime=stime;
        st.rel_minfaults=(int)(minfaults - st.base_minfaults);
        st.rel_majfaults=(int)(majfaults - st.base_majfaults);
        st.base_minfaults=minfaults;
        st.base_majfaults=majfaults;
        st.working=true;
      }
      continue;
    }
    if (st == null || st.pid > pid) {
      st=new Stats(pid,parentPid,mIncludeThreads);
      allProcs.add(curStatsIndex,st);
      curStatsIndex++;
      NS++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      final String[] procStatsString=mProcessFullStatsStringData;
      final long[] procStats=mProcessFullStatsData;
      st.base_uptime=SystemClock.uptimeMillis();
      if (Process.readProcFile(st.statFile.toString(),PROCESS_FULL_STATS_FORMAT,procStatsString,procStats,null)) {
        st.vsize=procStats[PROCESS_FULL_STAT_VSIZE];
        if (true || procStats[PROCESS_FULL_STAT_VSIZE] != 0) {
          st.interesting=true;
          st.baseName=procStatsString[0];
          st.base_minfaults=procStats[PROCESS_FULL_STAT_MINOR_FAULTS];
          st.base_majfaults=procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];
          st.base_utime=procStats[PROCESS_FULL_STAT_UTIME];
          st.base_stime=procStats[PROCESS_FULL_STAT_STIME];
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ procStatsString[0]);
          st.baseName=procStatsString[0];
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pid);
        st.baseName=""String_Node_Str"";
        st.base_utime=st.base_stime=0;
        st.base_minfaults=st.base_majfaults=0;
      }
      if (parentPid < 0) {
        getName(st,st.cmdlineFile);
        if (st.threadStats != null) {
          mCurThreadPids=collectStats(st.threadsDir,pid,true,mCurThreadPids,st.threadStats);
        }
      }
 else       if (st.interesting) {
        st.name=st.baseName;
        st.nameWidth=onMeasureProcessName(st.name);
      }
      if (DEBUG)       Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ st.base_majfaults);
      st.rel_utime=0;
      st.rel_stime=0;
      st.rel_minfaults=0;
      st.rel_majfaults=0;
      st.added=true;
      if (!first && st.interesting) {
        st.working=true;
      }
      continue;
    }
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
    i--;
    continue;
  }
  while (curStatsIndex < NS) {
    final Stats st=allProcs.get(curStatsIndex);
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + st.pid + ""String_Node_Str""+ st);
  }
  return pids;
}","private int[] collectStats(String statsFile,int parentPid,boolean first,int[] curPids,ArrayList<Stats> allProcs){
  int[] pids=Process.getPids(statsFile,curPids);
  int NP=(pids == null) ? 0 : pids.length;
  int NS=allProcs.size();
  int curStatsIndex=0;
  for (int i=0; i < NP; i++) {
    int pid=pids[i];
    if (pid < 0) {
      NP=pid;
      break;
    }
    Stats st=curStatsIndex < NS ? allProcs.get(curStatsIndex) : null;
    if (st != null && st.pid == pid) {
      st.added=false;
      st.working=false;
      curStatsIndex++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      if (st.interesting) {
        final long uptime=SystemClock.uptimeMillis();
        final long[] procStats=mProcessStatsData;
        if (!Process.readProcFile(st.statFile.toString(),PROCESS_STATS_FORMAT,null,procStats,null)) {
          continue;
        }
        final long minfaults=procStats[PROCESS_STAT_MINOR_FAULTS];
        final long majfaults=procStats[PROCESS_STAT_MAJOR_FAULTS];
        final long utime=procStats[PROCESS_STAT_UTIME];
        final long stime=procStats[PROCESS_STAT_STIME];
        if (utime == st.base_utime && stime == st.base_stime) {
          st.rel_utime=0;
          st.rel_stime=0;
          st.rel_minfaults=0;
          st.rel_majfaults=0;
          if (st.active) {
            st.active=false;
          }
          continue;
        }
        if (!st.active) {
          st.active=true;
        }
        if (parentPid < 0) {
          getName(st,st.cmdlineFile);
          if (st.threadStats != null) {
            mCurThreadPids=collectStats(st.threadsDir,pid,false,mCurThreadPids,st.threadStats);
          }
        }
        if (DEBUG)         Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ utime+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ stime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ minfaults+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ majfaults+ ""String_Node_Str""+ st.base_majfaults);
        st.rel_uptime=uptime - st.base_uptime;
        st.base_uptime=uptime;
        st.rel_utime=(int)(utime - st.base_utime);
        st.rel_stime=(int)(stime - st.base_stime);
        st.base_utime=utime;
        st.base_stime=stime;
        st.rel_minfaults=(int)(minfaults - st.base_minfaults);
        st.rel_majfaults=(int)(majfaults - st.base_majfaults);
        st.base_minfaults=minfaults;
        st.base_majfaults=majfaults;
        st.working=true;
      }
      continue;
    }
    if (st == null || st.pid > pid) {
      st=new Stats(pid,parentPid,mIncludeThreads);
      allProcs.add(curStatsIndex,st);
      curStatsIndex++;
      NS++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      final String[] procStatsString=mProcessFullStatsStringData;
      final long[] procStats=mProcessFullStatsData;
      st.base_uptime=SystemClock.uptimeMillis();
      String path=st.statFile.toString();
      if (Process.readProcFile(path,PROCESS_FULL_STATS_FORMAT,procStatsString,procStats,null)) {
        st.vsize=procStats[PROCESS_FULL_STAT_VSIZE];
        if (true || procStats[PROCESS_FULL_STAT_VSIZE] != 0) {
          st.interesting=true;
          st.baseName=procStatsString[0];
          st.base_minfaults=procStats[PROCESS_FULL_STAT_MINOR_FAULTS];
          st.base_majfaults=procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];
          st.base_utime=procStats[PROCESS_FULL_STAT_UTIME];
          st.base_stime=procStats[PROCESS_FULL_STAT_STIME];
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ procStatsString[0]);
          st.baseName=procStatsString[0];
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pid);
        st.baseName=""String_Node_Str"";
        st.base_utime=st.base_stime=0;
        st.base_minfaults=st.base_majfaults=0;
      }
      if (parentPid < 0) {
        getName(st,st.cmdlineFile);
        if (st.threadStats != null) {
          mCurThreadPids=collectStats(st.threadsDir,pid,true,mCurThreadPids,st.threadStats);
        }
      }
 else       if (st.interesting) {
        st.name=st.baseName;
        st.nameWidth=onMeasureProcessName(st.name);
      }
      if (DEBUG)       Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ st.base_majfaults);
      st.rel_utime=0;
      st.rel_stime=0;
      st.rel_minfaults=0;
      st.rel_majfaults=0;
      st.added=true;
      if (!first && st.interesting) {
        st.working=true;
      }
      continue;
    }
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
    i--;
    continue;
  }
  while (curStatsIndex < NS) {
    final Stats st=allProcs.get(curStatsIndex);
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + st.pid + ""String_Node_Str""+ st);
  }
  return pids;
}",0.9938859917281064
199035,"private int[] collectStats(String statsFile,int parentPid,boolean first,int[] curPids,ArrayList<Stats> allProcs){
  int[] pids=Process.getPids(statsFile,curPids);
  int NP=(pids == null) ? 0 : pids.length;
  int NS=allProcs.size();
  int curStatsIndex=0;
  for (int i=0; i < NP; i++) {
    int pid=pids[i];
    if (pid < 0) {
      NP=pid;
      break;
    }
    Stats st=curStatsIndex < NS ? allProcs.get(curStatsIndex) : null;
    if (st != null && st.pid == pid) {
      st.added=false;
      st.working=false;
      curStatsIndex++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      if (st.interesting) {
        final long uptime=SystemClock.uptimeMillis();
        final long[] procStats=mProcessStatsData;
        if (!Process.readProcFile(st.statFile.toString(),PROCESS_STATS_FORMAT,null,procStats,null)) {
          continue;
        }
        final long minfaults=procStats[PROCESS_STAT_MINOR_FAULTS];
        final long majfaults=procStats[PROCESS_STAT_MAJOR_FAULTS];
        final long utime=procStats[PROCESS_STAT_UTIME];
        final long stime=procStats[PROCESS_STAT_STIME];
        if (utime == st.base_utime && stime == st.base_stime) {
          st.rel_utime=0;
          st.rel_stime=0;
          st.rel_minfaults=0;
          st.rel_majfaults=0;
          if (st.active) {
            st.active=false;
          }
          continue;
        }
        if (!st.active) {
          st.active=true;
        }
        if (parentPid < 0) {
          getName(st,st.cmdlineFile);
          if (st.threadStats != null) {
            mCurThreadPids=collectStats(st.threadsDir,pid,false,mCurThreadPids,st.threadStats);
          }
        }
        if (DEBUG)         Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ utime+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ stime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ minfaults+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ majfaults+ ""String_Node_Str""+ st.base_majfaults);
        st.rel_uptime=uptime - st.base_uptime;
        st.base_uptime=uptime;
        st.rel_utime=(int)(utime - st.base_utime);
        st.rel_stime=(int)(stime - st.base_stime);
        st.base_utime=utime;
        st.base_stime=stime;
        st.rel_minfaults=(int)(minfaults - st.base_minfaults);
        st.rel_majfaults=(int)(majfaults - st.base_majfaults);
        st.base_minfaults=minfaults;
        st.base_majfaults=majfaults;
        st.working=true;
      }
      continue;
    }
    if (st == null || st.pid > pid) {
      st=new Stats(pid,parentPid,mIncludeThreads);
      allProcs.add(curStatsIndex,st);
      curStatsIndex++;
      NS++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      final String[] procStatsString=mProcessFullStatsStringData;
      final long[] procStats=mProcessFullStatsData;
      st.base_uptime=SystemClock.uptimeMillis();
      if (Process.readProcFile(st.statFile.toString(),PROCESS_FULL_STATS_FORMAT,procStatsString,procStats,null)) {
        st.vsize=procStats[PROCESS_FULL_STAT_VSIZE];
        if (true || procStats[PROCESS_FULL_STAT_VSIZE] != 0) {
          st.interesting=true;
          st.baseName=procStatsString[0];
          st.base_minfaults=procStats[PROCESS_FULL_STAT_MINOR_FAULTS];
          st.base_majfaults=procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];
          st.base_utime=procStats[PROCESS_FULL_STAT_UTIME];
          st.base_stime=procStats[PROCESS_FULL_STAT_STIME];
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ procStatsString[0]);
          st.baseName=procStatsString[0];
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pid);
        st.baseName=""String_Node_Str"";
        st.base_utime=st.base_stime=0;
        st.base_minfaults=st.base_majfaults=0;
      }
      if (parentPid < 0) {
        getName(st,st.cmdlineFile);
        if (st.threadStats != null) {
          mCurThreadPids=collectStats(st.threadsDir,pid,true,mCurThreadPids,st.threadStats);
        }
      }
 else       if (st.interesting) {
        st.name=st.baseName;
        st.nameWidth=onMeasureProcessName(st.name);
      }
      if (DEBUG)       Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ st.base_majfaults);
      st.rel_utime=0;
      st.rel_stime=0;
      st.rel_minfaults=0;
      st.rel_majfaults=0;
      st.added=true;
      if (!first && st.interesting) {
        st.working=true;
      }
      continue;
    }
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
    i--;
    continue;
  }
  while (curStatsIndex < NS) {
    final Stats st=allProcs.get(curStatsIndex);
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + st.pid + ""String_Node_Str""+ st);
  }
  return pids;
}","private int[] collectStats(String statsFile,int parentPid,boolean first,int[] curPids,ArrayList<Stats> allProcs){
  int[] pids=Process.getPids(statsFile,curPids);
  int NP=(pids == null) ? 0 : pids.length;
  int NS=allProcs.size();
  int curStatsIndex=0;
  for (int i=0; i < NP; i++) {
    int pid=pids[i];
    if (pid < 0) {
      NP=pid;
      break;
    }
    Stats st=curStatsIndex < NS ? allProcs.get(curStatsIndex) : null;
    if (st != null && st.pid == pid) {
      st.added=false;
      st.working=false;
      curStatsIndex++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      if (st.interesting) {
        final long uptime=SystemClock.uptimeMillis();
        final long[] procStats=mProcessStatsData;
        if (!Process.readProcFile(st.statFile.toString(),PROCESS_STATS_FORMAT,null,procStats,null)) {
          continue;
        }
        final long minfaults=procStats[PROCESS_STAT_MINOR_FAULTS];
        final long majfaults=procStats[PROCESS_STAT_MAJOR_FAULTS];
        final long utime=procStats[PROCESS_STAT_UTIME];
        final long stime=procStats[PROCESS_STAT_STIME];
        if (utime == st.base_utime && stime == st.base_stime) {
          st.rel_utime=0;
          st.rel_stime=0;
          st.rel_minfaults=0;
          st.rel_majfaults=0;
          if (st.active) {
            st.active=false;
          }
          continue;
        }
        if (!st.active) {
          st.active=true;
        }
        if (parentPid < 0) {
          getName(st,st.cmdlineFile);
          if (st.threadStats != null) {
            mCurThreadPids=collectStats(st.threadsDir,pid,false,mCurThreadPids,st.threadStats);
          }
        }
        if (DEBUG)         Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ utime+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ stime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ minfaults+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ majfaults+ ""String_Node_Str""+ st.base_majfaults);
        st.rel_uptime=uptime - st.base_uptime;
        st.base_uptime=uptime;
        st.rel_utime=(int)(utime - st.base_utime);
        st.rel_stime=(int)(stime - st.base_stime);
        st.base_utime=utime;
        st.base_stime=stime;
        st.rel_minfaults=(int)(minfaults - st.base_minfaults);
        st.rel_majfaults=(int)(majfaults - st.base_majfaults);
        st.base_minfaults=minfaults;
        st.base_majfaults=majfaults;
        st.working=true;
      }
      continue;
    }
    if (st == null || st.pid > pid) {
      st=new Stats(pid,parentPid,mIncludeThreads);
      allProcs.add(curStatsIndex,st);
      curStatsIndex++;
      NS++;
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
      final String[] procStatsString=mProcessFullStatsStringData;
      final long[] procStats=mProcessFullStatsData;
      st.base_uptime=SystemClock.uptimeMillis();
      String path=st.statFile.toString();
      if (Process.readProcFile(path,PROCESS_FULL_STATS_FORMAT,procStatsString,procStats,null)) {
        st.vsize=procStats[PROCESS_FULL_STAT_VSIZE];
        if (true || procStats[PROCESS_FULL_STAT_VSIZE] != 0) {
          st.interesting=true;
          st.baseName=procStatsString[0];
          st.base_minfaults=procStats[PROCESS_FULL_STAT_MINOR_FAULTS];
          st.base_majfaults=procStats[PROCESS_FULL_STAT_MAJOR_FAULTS];
          st.base_utime=procStats[PROCESS_FULL_STAT_UTIME];
          st.base_stime=procStats[PROCESS_FULL_STAT_STIME];
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ procStatsString[0]);
          st.baseName=procStatsString[0];
        }
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + pid);
        st.baseName=""String_Node_Str"";
        st.base_utime=st.base_stime=0;
        st.base_minfaults=st.base_majfaults=0;
      }
      if (parentPid < 0) {
        getName(st,st.cmdlineFile);
        if (st.threadStats != null) {
          mCurThreadPids=collectStats(st.threadsDir,pid,true,mCurThreadPids,st.threadStats);
        }
      }
 else       if (st.interesting) {
        st.name=st.baseName;
        st.nameWidth=onMeasureProcessName(st.name);
      }
      if (DEBUG)       Slog.v(""String_Node_Str"",""String_Node_Str"" + st.name + ""String_Node_Str""+ st.pid+ ""String_Node_Str""+ st.base_utime+ ""String_Node_Str""+ st.base_stime+ ""String_Node_Str""+ st.base_minfaults+ ""String_Node_Str""+ st.base_majfaults);
      st.rel_utime=0;
      st.rel_stime=0;
      st.rel_minfaults=0;
      st.rel_majfaults=0;
      st.added=true;
      if (!first && st.interesting) {
        st.working=true;
      }
      continue;
    }
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + (parentPid < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ pid+ ""String_Node_Str""+ st);
    i--;
    continue;
  }
  while (curStatsIndex < NS) {
    final Stats st=allProcs.get(curStatsIndex);
    st.rel_utime=0;
    st.rel_stime=0;
    st.rel_minfaults=0;
    st.rel_majfaults=0;
    st.removed=true;
    st.working=true;
    allProcs.remove(curStatsIndex);
    NS--;
    if (localLOGV)     Slog.v(TAG,""String_Node_Str"" + st.pid + ""String_Node_Str""+ st);
  }
  return pids;
}",0.9938859917281064
199036,"/** 
 * A new GATT descriptor has been discovered. Finally, add the descriptor to the related characteristic. This should conclude the remote device update.
 * @hide
 */
public void onGetDescriptor(String address,int srvcType,int srvcInstId,ParcelUuid srvcUuid,int charInstId,ParcelUuid charUuid,int descrInstId,ParcelUuid descUuid){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + address + ""String_Node_Str""+ descUuid);
  if (!address.equals(mDevice.getAddress())) {
    return;
  }
  BluetoothGattService service=getService(mDevice,srvcUuid.getUuid(),srvcInstId,srvcType);
  if (service == null)   return;
  BluetoothGattCharacteristic characteristic=service.getCharacteristic(charUuid.getUuid());
  if (characteristic == null)   return;
  characteristic.addDescriptor(new BluetoothGattDescriptor(characteristic,descUuid.getUuid(),descrInstId,0));
}","/** 
 * A new GATT descriptor has been discovered. Finally, add the descriptor to the related characteristic. This should conclude the remote device update.
 * @hide
 */
public void onGetDescriptor(String address,int srvcType,int srvcInstId,ParcelUuid srvcUuid,int charInstId,ParcelUuid charUuid,int descrInstId,ParcelUuid descUuid){
  if (DBG)   Log.d(TAG,""String_Node_Str"" + address + ""String_Node_Str""+ descUuid);
  if (!address.equals(mDevice.getAddress())) {
    return;
  }
  BluetoothGattService service=getService(mDevice,srvcUuid.getUuid(),srvcInstId,srvcType);
  if (service == null)   return;
  BluetoothGattCharacteristic characteristic=service.getCharacteristic(charUuid.getUuid(),charInstId);
  if (characteristic == null)   return;
  characteristic.addDescriptor(new BluetoothGattDescriptor(characteristic,descUuid.getUuid(),descrInstId,0));
}",0.9935483870967742
199037,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_TAB) {
    final boolean backward=event.isShiftPressed();
    mRecentsView.focusNextTask(!backward);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_TAB) {
    final boolean backward=event.isShiftPressed();
    mRecentsView.focusNextTask(!backward);
    return true;
  }
  mDebugTrigger.onKeyEvent(keyCode);
  return super.onKeyDown(keyCode,event);
}",0.9340463458110516
199038,"public void onEnterAnimationTriggered(){
  mScrimViews.startEnterRecentsAnimation();
}","/** 
 * Called when the enter recents animation is triggered. 
 */
public void onEnterAnimationTriggered(){
  mScrimViews.startEnterRecentsAnimation();
}",0.7196652719665272
199039,"@Override public void run(){
  AlternateRecentsComponent.notifyVisibilityChanged(false);
  if (mLaunchIntent != null) {
    if (mLaunchOpts != null) {
      startActivityAsUser(mLaunchIntent,new UserHandle(UserHandle.USER_CURRENT));
    }
 else {
      startActivityAsUser(mLaunchIntent,mLaunchOpts.toBundle(),new UserHandle(UserHandle.USER_CURRENT));
    }
  }
 else {
    finish();
    if (mUseCustomFinishTransition) {
      overridePendingTransition(R.anim.recents_to_launcher_enter,R.anim.recents_to_launcher_exit);
    }
  }
}","@Override public void run(){
  onDebugModeTriggered();
}",0.1360544217687075
199040,"@Override public void onAttachedToWindow(){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",""String_Node_Str"",Console.AnsiRed);
  }
  super.onAttachedToWindow();
  IntentFilter filter=new IntentFilter();
  filter.addAction(RecentsService.ACTION_HIDE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_START_ENTER_ANIMATION);
  registerReceiver(mServiceBroadcastReceiver,filter);
  filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenOffReceiver,filter);
  RecentsTaskLoader.getInstance().registerReceivers(this,mRecentsView);
  if (mConfig.searchBarAppWidgetId >= 0) {
    mAppWidgetHost.startListening(this);
  }
}","@Override public void onAttachedToWindow(){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",""String_Node_Str"",Console.AnsiRed);
  }
  super.onAttachedToWindow();
  IntentFilter filter=new IntentFilter();
  filter.addAction(RecentsService.ACTION_HIDE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_START_ENTER_ANIMATION);
  filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED);
  registerReceiver(mServiceBroadcastReceiver,filter);
  filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenOffReceiver,filter);
  RecentsTaskLoader.getInstance().registerReceivers(this,mRecentsView);
  if (mConfig.searchBarAppWidgetId >= 0) {
    mAppWidgetHost.startListening(this);
  }
}",0.9555690809494828
199041,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_duration);
  filteringNewViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_duration);
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  isLandscape=res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
  transposeRecentsLayoutWithOrientation=res.getBoolean(R.bool.recents_transpose_layout_with_orientation);
  searchBarSpaceHeightPx=res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
  SharedPreferences settings=context.getSharedPreferences(context.getPackageName(),0);
  searchBarAppWidgetId=settings.getInt(Constants.Values.App.Key_SearchAppWidgetId,-1);
  TypedValue widthPaddingPctValue=new TypedValue();
  res.getValue(R.dimen.recents_stack_width_padding_percentage,widthPaddingPctValue,true);
  taskStackWidthPaddingPct=widthPaddingPctValue.getFloat();
  taskStackMaxDim=res.getInteger(R.integer.recents_max_task_stack_view_dim);
  taskStackTopPaddingPx=res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
  taskViewEnterFromHomeDuration=res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
  taskViewEnterFromHomeDelay=res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
  taskViewExitToHomeDuration=res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
  taskViewRemoveAnimDuration=res.getInteger(R.integer.recents_animate_task_view_remove_duration);
  taskViewRemoveAnimTranslationXPx=res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
  taskViewRoundedCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  taskViewHighlightPx=res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
  taskViewTranslationZMinPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  taskViewTranslationZIncrementPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_increment);
  taskViewShadowOutlineBottomInsetPx=res.getDimensionPixelSize(R.dimen.recents_task_view_shadow_outline_bottom_inset);
  taskBarViewDefaultBackgroundColor=res.getColor(R.color.recents_task_bar_default_background_color);
  taskBarViewLightTextColor=res.getColor(R.color.recents_task_bar_light_text_color);
  taskBarViewDarkTextColor=res.getColor(R.color.recents_task_bar_dark_text_color);
  taskBarViewHighlightColor=res.getColor(R.color.recents_task_bar_highlight_color);
  taskBarEnterAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
  taskBarEnterAnimDelay=res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
  taskBarExitAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
  taskBarDismissDozeDelaySeconds=res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  navBarScrimEnterDuration=res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",isLandscape ? ""String_Node_Str"" : ""String_Node_Str"",Console.AnsiGreen);
  }
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  SharedPreferences settings=context.getSharedPreferences(context.getPackageName(),0);
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  debugModeEnabled=settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled,false);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_duration);
  filteringNewViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_duration);
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  isLandscape=res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
  transposeRecentsLayoutWithOrientation=res.getBoolean(R.bool.recents_transpose_layout_with_orientation);
  searchBarSpaceHeightPx=res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
  searchBarAppWidgetId=settings.getInt(Constants.Values.App.Key_SearchAppWidgetId,-1);
  TypedValue widthPaddingPctValue=new TypedValue();
  res.getValue(R.dimen.recents_stack_width_padding_percentage,widthPaddingPctValue,true);
  taskStackWidthPaddingPct=widthPaddingPctValue.getFloat();
  taskStackMaxDim=res.getInteger(R.integer.recents_max_task_stack_view_dim);
  taskStackTopPaddingPx=res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
  taskViewEnterFromHomeDuration=res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
  taskViewEnterFromHomeDelay=res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
  taskViewExitToHomeDuration=res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
  taskViewRemoveAnimDuration=res.getInteger(R.integer.recents_animate_task_view_remove_duration);
  taskViewRemoveAnimTranslationXPx=res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
  taskViewRoundedCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  taskViewHighlightPx=res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
  taskViewTranslationZMinPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  taskViewTranslationZIncrementPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_increment);
  taskViewShadowOutlineBottomInsetPx=res.getDimensionPixelSize(R.dimen.recents_task_view_shadow_outline_bottom_inset);
  taskBarViewDefaultBackgroundColor=res.getColor(R.color.recents_task_bar_default_background_color);
  taskBarViewLightTextColor=res.getColor(R.color.recents_task_bar_light_text_color);
  taskBarViewDarkTextColor=res.getColor(R.color.recents_task_bar_dark_text_color);
  taskBarViewHighlightColor=res.getColor(R.color.recents_task_bar_highlight_color);
  taskBarEnterAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
  taskBarEnterAnimDelay=res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
  taskBarExitAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
  taskBarDismissDozeDelaySeconds=res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  navBarScrimEnterDuration=res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",isLandscape ? ""String_Node_Str"" : ""String_Node_Str"",Console.AnsiGreen);
  }
}",0.961889581220113
199042,"/** 
 * Calculates the luminance-preserved greyscale of a given color. 
 */
private static int colorToGreyscale(int color){
  return Math.round(0.2126f * Color.red(color) + 0.7152f * Color.green(color) + 0.0722f * Color.blue(color));
}","/** 
 * Calculates the luminance-preserved greyscale of a given color. 
 */
public static int colorToGreyscale(int color){
  return Math.round(0.2126f * Color.red(color) + 0.7152f * Color.green(color) + 0.0722f * Color.blue(color));
}",0.976545842217484
199043,"@Override public void run(){
  t.notifyTaskDataLoaded(newThumbnail,newIcon,forceLoadTask);
}","@Override public void run(){
  t.notifyTaskDataLoaded(newThumbnail,newIcon);
}",0.9176470588235294
199044,"/** 
 * Reload the set of recent tasks 
 */
public SpaceNode reload(Context context,int preloadCount){
  long t1=System.currentTimeMillis();
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
  }
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  SystemServicesProxy ssp=mSystemServicesProxy;
  List<ActivityManager.RecentTaskInfo> tasks=getRecentTasks();
  t1=System.currentTimeMillis();
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=tasks.get(i);
    ActivityInfo info=ssp.getActivityInfo(t.baseIntent.getComponent(),t.userId);
    if (info == null)     continue;
    ActivityManager.TaskDescription av=t.taskDescription;
    String activityLabel=null;
    BitmapDrawable activityIcon=null;
    int activityColor=0;
    if (av != null) {
      activityLabel=(av.getLabel() != null ? av.getLabel() : ssp.getActivityLabel(info));
      activityIcon=(av.getIcon() != null) ? new BitmapDrawable(res,av.getIcon()) : null;
      activityColor=av.getPrimaryColor();
    }
 else {
      activityLabel=ssp.getActivityLabel(info);
    }
    boolean isForemostTask=(i == (taskCount - 1));
    Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,activityLabel,activityIcon,activityColor,t.userId,t.lastActiveTime);
    if (i >= (taskCount - preloadCount)) {
      if (Console.Enabled) {
        Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
      }
      task.applicationIcon=mApplicationIconCache.getCheckLastActiveTime(task.key);
      if (task.applicationIcon == null) {
        if (isForemostTask) {
          task.applicationIcon=ssp.getActivityIcon(info,task.userId);
          if (task.applicationIcon != null) {
            mApplicationIconCache.put(task.key,task.applicationIcon);
          }
 else {
            task.applicationIcon=mDefaultApplicationIcon;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
      task.thumbnail=mThumbnailCache.getCheckLastActiveTime(task.key);
      if (task.thumbnail == null) {
        if (Console.Enabled) {
          Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
        }
        if (isForemostTask) {
          task.thumbnail=ssp.getTaskThumbnail(task.key.id);
          if (task.thumbnail != null) {
            task.thumbnail.setHasAlpha(false);
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
    }
    if (Console.Enabled) {
      Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
    }
    stack.addTask(task);
  }
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  mPackageMonitor.setTasks(tasks);
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
public SpaceNode reload(Context context,int preloadCount){
  long t1=System.currentTimeMillis();
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
  }
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  SystemServicesProxy ssp=mSystemServicesProxy;
  List<ActivityManager.RecentTaskInfo> tasks=getRecentTasks();
  t1=System.currentTimeMillis();
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=tasks.get(i);
    ActivityInfo info=ssp.getActivityInfo(t.baseIntent.getComponent(),t.userId);
    if (info == null)     continue;
    ActivityManager.TaskDescription av=t.taskDescription;
    String activityLabel=null;
    BitmapDrawable activityIcon=null;
    int activityColor=config.taskBarViewDefaultBackgroundColor;
    if (av != null) {
      activityLabel=(av.getLabel() != null ? av.getLabel() : ssp.getActivityLabel(info));
      activityIcon=(av.getIcon() != null) ? new BitmapDrawable(res,av.getIcon()) : null;
      activityColor=av.getPrimaryColor();
    }
 else {
      activityLabel=ssp.getActivityLabel(info);
    }
    boolean isForemostTask=(i == (taskCount - 1));
    Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,activityLabel,activityIcon,activityColor,t.userId,t.lastActiveTime);
    if (i >= (taskCount - preloadCount)) {
      if (Console.Enabled) {
        Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
      }
      task.applicationIcon=mApplicationIconCache.getCheckLastActiveTime(task.key);
      if (task.applicationIcon == null) {
        if (isForemostTask) {
          task.applicationIcon=ssp.getActivityIcon(info,task.userId);
          if (task.applicationIcon != null) {
            mApplicationIconCache.put(task.key,task.applicationIcon);
          }
 else {
            task.applicationIcon=mDefaultApplicationIcon;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
      task.thumbnail=mThumbnailCache.getCheckLastActiveTime(task.key);
      if (task.thumbnail == null) {
        if (Console.Enabled) {
          Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
        }
        if (isForemostTask) {
          task.thumbnail=ssp.getTaskThumbnail(task.key.id);
          if (task.thumbnail != null) {
            task.thumbnail.setHasAlpha(false);
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
    }
    if (Console.Enabled) {
      Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
    }
    stack.addTask(task);
  }
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  mPackageMonitor.setTasks(tasks);
  return root;
}",0.9842019784438212
199045,"/** 
 * Acquires the task resource data from the pool. 
 */
public void loadTaskData(Task t){
  Drawable applicationIcon=mApplicationIconCache.get(t.key);
  Bitmap thumbnail=mThumbnailCache.get(t.key);
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t + ""String_Node_Str"" + applicationIcon+ ""String_Node_Str""+ thumbnail+ ""String_Node_Str""+ mThumbnailCache.size());
  }
  boolean requiresLoad=false;
  if (applicationIcon == null) {
    applicationIcon=mDefaultApplicationIcon;
    requiresLoad=true;
  }
  if (thumbnail == null) {
    thumbnail=mLoadingThumbnail;
    requiresLoad=true;
  }
  if (requiresLoad) {
    mLoadQueue.addTask(t,false);
  }
  t.notifyTaskDataLoaded(thumbnail,applicationIcon,false);
}","/** 
 * Acquires the task resource data directly from the pool. 
 */
public void loadTaskData(Task t){
  Drawable applicationIcon=mApplicationIconCache.get(t.key);
  Bitmap thumbnail=mThumbnailCache.get(t.key);
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t + ""String_Node_Str"" + applicationIcon+ ""String_Node_Str""+ thumbnail+ ""String_Node_Str""+ mThumbnailCache.size());
  }
  boolean requiresLoad=false;
  if (applicationIcon == null) {
    applicationIcon=mDefaultApplicationIcon;
    requiresLoad=true;
  }
  if (thumbnail == null) {
    thumbnail=mLoadingThumbnail;
    requiresLoad=true;
  }
  if (requiresLoad) {
    mLoadQueue.addTask(t,false);
  }
  t.notifyTaskDataLoaded(thumbnail,applicationIcon);
}",0.9900727994705492
199046,"public Task(int id,boolean isActive,Intent intent,String activityTitle,BitmapDrawable activityIcon,int colorPrimary,int userId,long lastActiveTime){
  this.key=new TaskKey(id,intent,userId,lastActiveTime);
  this.activityLabel=activityTitle;
  this.activityIcon=activityIcon;
  this.colorPrimary=colorPrimary;
  this.isActive=isActive;
  this.userId=userId;
}","public Task(int id,boolean isActive,Intent intent,String activityTitle,BitmapDrawable activityIcon,int colorPrimary,int userId,long lastActiveTime){
  this.key=new TaskKey(id,intent,userId,lastActiveTime);
  this.activityLabel=activityTitle;
  this.activityIcon=activityIcon;
  this.colorPrimary=colorPrimary;
  this.colorPrimaryGreyscale=Utilities.colorToGreyscale(colorPrimary);
  this.isActive=isActive;
  this.userId=userId;
}",0.9100126742712294
199047,public void onTaskDataLoaded(boolean reloadingTaskData);,public void onTaskDataLoaded();,0.7126436781609196
199048,"/** 
 * Notifies the callback listeners that this task has been loaded 
 */
public void notifyTaskDataLoaded(Bitmap thumbnail,Drawable applicationIcon,boolean reloadingTaskData){
  this.applicationIcon=applicationIcon;
  this.thumbnail=thumbnail;
  if (mCb != null) {
    mCb.onTaskDataLoaded(reloadingTaskData);
  }
}","/** 
 * Notifies the callback listeners that this task has been loaded 
 */
public void notifyTaskDataLoaded(Bitmap thumbnail,Drawable applicationIcon){
  this.applicationIcon=applicationIcon;
  this.thumbnail=thumbnail;
  if (mCb != null) {
    mCb.onTaskDataLoaded();
  }
}",0.927487352445194
199049,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_TAB) {
    final boolean backward=event.isShiftPressed();
    mRecentsView.focusNextTask(!backward);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_TAB) {
    final boolean backward=event.isShiftPressed();
    mRecentsView.focusNextTask(!backward);
    return true;
  }
  mDebugTrigger.onKeyEvent(keyCode);
  return super.onKeyDown(keyCode,event);
}",0.9340463458110516
199050,"public void onEnterAnimationTriggered(){
  mScrimViews.startEnterRecentsAnimation();
}","/** 
 * Called when the enter recents animation is triggered. 
 */
public void onEnterAnimationTriggered(){
  mScrimViews.startEnterRecentsAnimation();
}",0.7196652719665272
199051,"@Override public void run(){
  AlternateRecentsComponent.notifyVisibilityChanged(false);
  if (mLaunchIntent != null) {
    if (mLaunchOpts != null) {
      startActivityAsUser(mLaunchIntent,new UserHandle(UserHandle.USER_CURRENT));
    }
 else {
      startActivityAsUser(mLaunchIntent,mLaunchOpts.toBundle(),new UserHandle(UserHandle.USER_CURRENT));
    }
  }
 else {
    finish();
    if (mUseCustomFinishTransition) {
      overridePendingTransition(R.anim.recents_to_launcher_enter,R.anim.recents_to_launcher_exit);
    }
  }
}","@Override public void run(){
  onDebugModeTriggered();
}",0.1360544217687075
199052,"@Override public void onAttachedToWindow(){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",""String_Node_Str"",Console.AnsiRed);
  }
  super.onAttachedToWindow();
  IntentFilter filter=new IntentFilter();
  filter.addAction(RecentsService.ACTION_HIDE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_START_ENTER_ANIMATION);
  registerReceiver(mServiceBroadcastReceiver,filter);
  filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenOffReceiver,filter);
  RecentsTaskLoader.getInstance().registerReceivers(this,mRecentsView);
  if (mConfig.searchBarAppWidgetId >= 0) {
    mAppWidgetHost.startListening(this);
  }
}","@Override public void onAttachedToWindow(){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.SystemUIHandshake,""String_Node_Str"",""String_Node_Str"",Console.AnsiRed);
  }
  super.onAttachedToWindow();
  IntentFilter filter=new IntentFilter();
  filter.addAction(RecentsService.ACTION_HIDE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
  filter.addAction(RecentsService.ACTION_START_ENTER_ANIMATION);
  filter.addAction(SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED);
  registerReceiver(mServiceBroadcastReceiver,filter);
  filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenOffReceiver,filter);
  RecentsTaskLoader.getInstance().registerReceivers(this,mRecentsView);
  if (mConfig.searchBarAppWidgetId >= 0) {
    mAppWidgetHost.startListening(this);
  }
}",0.9555690809494828
199053,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_duration);
  filteringNewViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_duration);
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  isLandscape=res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
  transposeRecentsLayoutWithOrientation=res.getBoolean(R.bool.recents_transpose_layout_with_orientation);
  searchBarSpaceHeightPx=res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
  SharedPreferences settings=context.getSharedPreferences(context.getPackageName(),0);
  searchBarAppWidgetId=settings.getInt(Constants.Values.App.Key_SearchAppWidgetId,-1);
  TypedValue widthPaddingPctValue=new TypedValue();
  res.getValue(R.dimen.recents_stack_width_padding_percentage,widthPaddingPctValue,true);
  taskStackWidthPaddingPct=widthPaddingPctValue.getFloat();
  taskStackMaxDim=res.getInteger(R.integer.recents_max_task_stack_view_dim);
  taskStackTopPaddingPx=res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
  taskViewEnterFromHomeDuration=res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
  taskViewEnterFromHomeDelay=res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
  taskViewExitToHomeDuration=res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
  taskViewRemoveAnimDuration=res.getInteger(R.integer.recents_animate_task_view_remove_duration);
  taskViewRemoveAnimTranslationXPx=res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
  taskViewRoundedCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  taskViewHighlightPx=res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
  taskViewTranslationZMinPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  taskViewTranslationZIncrementPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_increment);
  taskViewShadowOutlineBottomInsetPx=res.getDimensionPixelSize(R.dimen.recents_task_view_shadow_outline_bottom_inset);
  taskBarViewDefaultBackgroundColor=res.getColor(R.color.recents_task_bar_default_background_color);
  taskBarViewLightTextColor=res.getColor(R.color.recents_task_bar_light_text_color);
  taskBarViewDarkTextColor=res.getColor(R.color.recents_task_bar_dark_text_color);
  taskBarViewHighlightColor=res.getColor(R.color.recents_task_bar_highlight_color);
  taskBarEnterAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
  taskBarEnterAnimDelay=res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
  taskBarExitAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
  taskBarDismissDozeDelaySeconds=res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  navBarScrimEnterDuration=res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",isLandscape ? ""String_Node_Str"" : ""String_Node_Str"",Console.AnsiGreen);
  }
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  SharedPreferences settings=context.getSharedPreferences(context.getPackageName(),0);
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  debugModeEnabled=settings.getBoolean(Constants.Values.App.Key_DebugModeEnabled,false);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_duration);
  filteringNewViewsAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_duration);
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  isLandscape=res.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
  transposeRecentsLayoutWithOrientation=res.getBoolean(R.bool.recents_transpose_layout_with_orientation);
  searchBarSpaceHeightPx=res.getDimensionPixelSize(R.dimen.recents_search_bar_space_height);
  searchBarAppWidgetId=settings.getInt(Constants.Values.App.Key_SearchAppWidgetId,-1);
  TypedValue widthPaddingPctValue=new TypedValue();
  res.getValue(R.dimen.recents_stack_width_padding_percentage,widthPaddingPctValue,true);
  taskStackWidthPaddingPct=widthPaddingPctValue.getFloat();
  taskStackMaxDim=res.getInteger(R.integer.recents_max_task_stack_view_dim);
  taskStackTopPaddingPx=res.getDimensionPixelSize(R.dimen.recents_stack_top_padding);
  taskViewEnterFromHomeDuration=res.getInteger(R.integer.recents_animate_task_enter_from_home_duration);
  taskViewEnterFromHomeDelay=res.getInteger(R.integer.recents_animate_task_enter_from_home_delay);
  taskViewExitToHomeDuration=res.getInteger(R.integer.recents_animate_task_exit_to_home_duration);
  taskViewRemoveAnimDuration=res.getInteger(R.integer.recents_animate_task_view_remove_duration);
  taskViewRemoveAnimTranslationXPx=res.getDimensionPixelSize(R.dimen.recents_task_view_remove_anim_translation_x);
  taskViewRoundedCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  taskViewHighlightPx=res.getDimensionPixelSize(R.dimen.recents_task_view_highlight);
  taskViewTranslationZMinPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  taskViewTranslationZIncrementPx=res.getDimensionPixelSize(R.dimen.recents_task_view_z_increment);
  taskViewShadowOutlineBottomInsetPx=res.getDimensionPixelSize(R.dimen.recents_task_view_shadow_outline_bottom_inset);
  taskBarViewDefaultBackgroundColor=res.getColor(R.color.recents_task_bar_default_background_color);
  taskBarViewLightTextColor=res.getColor(R.color.recents_task_bar_light_text_color);
  taskBarViewDarkTextColor=res.getColor(R.color.recents_task_bar_dark_text_color);
  taskBarViewHighlightColor=res.getColor(R.color.recents_task_bar_highlight_color);
  taskBarEnterAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_enter_duration);
  taskBarEnterAnimDelay=res.getInteger(R.integer.recents_animate_task_bar_enter_delay);
  taskBarExitAnimDuration=res.getInteger(R.integer.recents_animate_task_bar_exit_duration);
  taskBarDismissDozeDelaySeconds=res.getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  navBarScrimEnterDuration=res.getInteger(R.integer.recents_nav_bar_scrim_enter_duration);
  if (Console.Enabled) {
    Console.log(Constants.Log.UI.MeasureAndLayout,""String_Node_Str"",isLandscape ? ""String_Node_Str"" : ""String_Node_Str"",Console.AnsiGreen);
  }
}",0.961889581220113
199054,"/** 
 * Calculates the luminance-preserved greyscale of a given color. 
 */
private static int colorToGreyscale(int color){
  return Math.round(0.2126f * Color.red(color) + 0.7152f * Color.green(color) + 0.0722f * Color.blue(color));
}","/** 
 * Calculates the luminance-preserved greyscale of a given color. 
 */
public static int colorToGreyscale(int color){
  return Math.round(0.2126f * Color.red(color) + 0.7152f * Color.green(color) + 0.0722f * Color.blue(color));
}",0.976545842217484
199055,"@Override public void run(){
  t.notifyTaskDataLoaded(newThumbnail,newIcon,forceLoadTask);
}","@Override public void run(){
  t.notifyTaskDataLoaded(newThumbnail,newIcon);
}",0.9176470588235294
199056,"/** 
 * Reload the set of recent tasks 
 */
public SpaceNode reload(Context context,int preloadCount){
  long t1=System.currentTimeMillis();
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
  }
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  SystemServicesProxy ssp=mSystemServicesProxy;
  List<ActivityManager.RecentTaskInfo> tasks=getRecentTasks();
  t1=System.currentTimeMillis();
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=tasks.get(i);
    ActivityInfo info=ssp.getActivityInfo(t.baseIntent.getComponent(),t.userId);
    if (info == null)     continue;
    ActivityManager.TaskDescription av=t.taskDescription;
    String activityLabel=null;
    BitmapDrawable activityIcon=null;
    int activityColor=0;
    if (av != null) {
      activityLabel=(av.getLabel() != null ? av.getLabel() : ssp.getActivityLabel(info));
      activityIcon=(av.getIcon() != null) ? new BitmapDrawable(res,av.getIcon()) : null;
      activityColor=av.getPrimaryColor();
    }
 else {
      activityLabel=ssp.getActivityLabel(info);
    }
    boolean isForemostTask=(i == (taskCount - 1));
    Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,activityLabel,activityIcon,activityColor,t.userId,t.lastActiveTime);
    if (i >= (taskCount - preloadCount)) {
      if (Console.Enabled) {
        Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
      }
      task.applicationIcon=mApplicationIconCache.getCheckLastActiveTime(task.key);
      if (task.applicationIcon == null) {
        if (isForemostTask) {
          task.applicationIcon=ssp.getActivityIcon(info,task.userId);
          if (task.applicationIcon != null) {
            mApplicationIconCache.put(task.key,task.applicationIcon);
          }
 else {
            task.applicationIcon=mDefaultApplicationIcon;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
      task.thumbnail=mThumbnailCache.getCheckLastActiveTime(task.key);
      if (task.thumbnail == null) {
        if (Console.Enabled) {
          Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
        }
        if (isForemostTask) {
          task.thumbnail=ssp.getTaskThumbnail(task.key.id);
          if (task.thumbnail != null) {
            task.thumbnail.setHasAlpha(false);
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
    }
    if (Console.Enabled) {
      Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
    }
    stack.addTask(task);
  }
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  mPackageMonitor.setTasks(tasks);
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
public SpaceNode reload(Context context,int preloadCount){
  long t1=System.currentTimeMillis();
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
  }
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  SystemServicesProxy ssp=mSystemServicesProxy;
  List<ActivityManager.RecentTaskInfo> tasks=getRecentTasks();
  t1=System.currentTimeMillis();
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    ActivityManager.RecentTaskInfo t=tasks.get(i);
    ActivityInfo info=ssp.getActivityInfo(t.baseIntent.getComponent(),t.userId);
    if (info == null)     continue;
    ActivityManager.TaskDescription av=t.taskDescription;
    String activityLabel=null;
    BitmapDrawable activityIcon=null;
    int activityColor=config.taskBarViewDefaultBackgroundColor;
    if (av != null) {
      activityLabel=(av.getLabel() != null ? av.getLabel() : ssp.getActivityLabel(info));
      activityIcon=(av.getIcon() != null) ? new BitmapDrawable(res,av.getIcon()) : null;
      activityColor=av.getPrimaryColor();
    }
 else {
      activityLabel=ssp.getActivityLabel(info);
    }
    boolean isForemostTask=(i == (taskCount - 1));
    Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,activityLabel,activityIcon,activityColor,t.userId,t.lastActiveTime);
    if (i >= (taskCount - preloadCount)) {
      if (Console.Enabled) {
        Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
      }
      task.applicationIcon=mApplicationIconCache.getCheckLastActiveTime(task.key);
      if (task.applicationIcon == null) {
        if (isForemostTask) {
          task.applicationIcon=ssp.getActivityIcon(info,task.userId);
          if (task.applicationIcon != null) {
            mApplicationIconCache.put(task.key,task.applicationIcon);
          }
 else {
            task.applicationIcon=mDefaultApplicationIcon;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
      task.thumbnail=mThumbnailCache.getCheckLastActiveTime(task.key);
      if (task.thumbnail == null) {
        if (Console.Enabled) {
          Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"");
        }
        if (isForemostTask) {
          task.thumbnail=ssp.getTaskThumbnail(task.key.id);
          if (task.thumbnail != null) {
            task.thumbnail.setHasAlpha(false);
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
 else {
          tasksToForceLoad.add(task);
        }
      }
    }
    if (Console.Enabled) {
      Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
    }
    stack.addTask(task);
  }
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  mPackageMonitor.setTasks(tasks);
  return root;
}",0.9842019784438212
199057,"/** 
 * Acquires the task resource data from the pool. 
 */
public void loadTaskData(Task t){
  Drawable applicationIcon=mApplicationIconCache.get(t.key);
  Bitmap thumbnail=mThumbnailCache.get(t.key);
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t + ""String_Node_Str"" + applicationIcon+ ""String_Node_Str""+ thumbnail+ ""String_Node_Str""+ mThumbnailCache.size());
  }
  boolean requiresLoad=false;
  if (applicationIcon == null) {
    applicationIcon=mDefaultApplicationIcon;
    requiresLoad=true;
  }
  if (thumbnail == null) {
    thumbnail=mLoadingThumbnail;
    requiresLoad=true;
  }
  if (requiresLoad) {
    mLoadQueue.addTask(t,false);
  }
  t.notifyTaskDataLoaded(thumbnail,applicationIcon,false);
}","/** 
 * Acquires the task resource data directly from the pool. 
 */
public void loadTaskData(Task t){
  Drawable applicationIcon=mApplicationIconCache.get(t.key);
  Bitmap thumbnail=mThumbnailCache.get(t.key);
  if (Console.Enabled) {
    Console.log(Constants.Log.App.TaskDataLoader,""String_Node_Str"",t + ""String_Node_Str"" + applicationIcon+ ""String_Node_Str""+ thumbnail+ ""String_Node_Str""+ mThumbnailCache.size());
  }
  boolean requiresLoad=false;
  if (applicationIcon == null) {
    applicationIcon=mDefaultApplicationIcon;
    requiresLoad=true;
  }
  if (thumbnail == null) {
    thumbnail=mLoadingThumbnail;
    requiresLoad=true;
  }
  if (requiresLoad) {
    mLoadQueue.addTask(t,false);
  }
  t.notifyTaskDataLoaded(thumbnail,applicationIcon);
}",0.9900727994705492
199058,"public Task(int id,boolean isActive,Intent intent,String activityTitle,BitmapDrawable activityIcon,int colorPrimary,int userId,long lastActiveTime){
  this.key=new TaskKey(id,intent,userId,lastActiveTime);
  this.activityLabel=activityTitle;
  this.activityIcon=activityIcon;
  this.colorPrimary=colorPrimary;
  this.isActive=isActive;
  this.userId=userId;
}","public Task(int id,boolean isActive,Intent intent,String activityTitle,BitmapDrawable activityIcon,int colorPrimary,int userId,long lastActiveTime){
  this.key=new TaskKey(id,intent,userId,lastActiveTime);
  this.activityLabel=activityTitle;
  this.activityIcon=activityIcon;
  this.colorPrimary=colorPrimary;
  this.colorPrimaryGreyscale=Utilities.colorToGreyscale(colorPrimary);
  this.isActive=isActive;
  this.userId=userId;
}",0.9100126742712294
199059,public void onTaskDataLoaded(boolean reloadingTaskData);,public void onTaskDataLoaded();,0.7126436781609196
199060,"/** 
 * Notifies the callback listeners that this task has been loaded 
 */
public void notifyTaskDataLoaded(Bitmap thumbnail,Drawable applicationIcon,boolean reloadingTaskData){
  this.applicationIcon=applicationIcon;
  this.thumbnail=thumbnail;
  if (mCb != null) {
    mCb.onTaskDataLoaded(reloadingTaskData);
  }
}","/** 
 * Notifies the callback listeners that this task has been loaded 
 */
public void notifyTaskDataLoaded(Bitmap thumbnail,Drawable applicationIcon){
  this.applicationIcon=applicationIcon;
  this.thumbnail=thumbnail;
  if (mCb != null) {
    mCb.onTaskDataLoaded();
  }
}",0.927487352445194
199061,"@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  Map<String,String> defaultPropMap=null;
  boolean isPlatformFile=true;
  if (set instanceof BridgeXmlBlockParser) {
    BridgeXmlBlockParser parser=null;
    parser=(BridgeXmlBlockParser)set;
    isPlatformFile=parser.isPlatformFile();
    Object key=parser.getViewCookie();
    if (key != null) {
      defaultPropMap=mDefaultPropMaps.get(key);
      if (defaultPropMap == null) {
        defaultPropMap=new HashMap<String,String>();
        mDefaultPropMaps.put(key,defaultPropMap);
      }
    }
  }
 else   if (set instanceof BridgeLayoutParamsMapAttributes) {
    isPlatformFile=false;
  }
 else   if (set != null) {
    Bridge.getLog().error(LayoutLog.TAG_BROKEN,""String_Node_Str"",null);
    return null;
  }
  List<Pair<String,Boolean>> attributeList=searchAttrs(attrs);
  BridgeTypedArray ta=((BridgeResources)mSystemResources).newTypeArray(attrs.length,isPlatformFile);
  String customStyle=null;
  if (set != null) {
    customStyle=set.getAttributeValue(null,""String_Node_Str"");
  }
  StyleResourceValue customStyleValues=null;
  if (customStyle != null) {
    ResourceValue item=mRenderResources.findResValue(customStyle,isPlatformFile);
    item=mRenderResources.resolveResValue(item);
    if (item instanceof StyleResourceValue) {
      customStyleValues=(StyleResourceValue)item;
    }
  }
  StyleResourceValue defStyleValues=null;
  if (defStyleAttr != 0) {
    Pair<String,Boolean> defStyleAttribute=searchAttr(defStyleAttr);
    if (defaultPropMap != null) {
      String defStyleName=defStyleAttribute.getFirst();
      if (defStyleAttribute.getSecond()) {
        defStyleName=""String_Node_Str"" + defStyleName;
      }
      defaultPropMap.put(""String_Node_Str"",defStyleName);
    }
    ResourceValue item=mRenderResources.findItemInTheme(defStyleAttribute.getFirst(),defStyleAttribute.getSecond());
    if (item != null) {
      item=mRenderResources.findResValue(item.getValue(),false);
      if (item instanceof StyleResourceValue) {
        defStyleValues=(StyleResourceValue)item;
      }
    }
 else {
      Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE_THEME_ATTR,String.format(""String_Node_Str"",defStyleAttribute.getFirst()),null);
    }
  }
 else   if (defStyleRes != 0) {
    boolean isFrameworkRes=true;
    Pair<ResourceType,String> value=Bridge.resolveResourceId(defStyleRes);
    if (value == null) {
      value=mProjectCallback.resolveResourceId(defStyleRes);
      isFrameworkRes=false;
    }
    if (value != null) {
      if ((value.getFirst() == ResourceType.STYLE) || (value.getFirst() == ResourceType.ATTR)) {
        ResourceValue item=mRenderResources.findItemInTheme(value.getSecond(),isFrameworkRes);
        if (item != null) {
          if (item instanceof StyleResourceValue) {
            if (defaultPropMap != null) {
              defaultPropMap.put(""String_Node_Str"",item.getName());
            }
            defStyleValues=(StyleResourceValue)item;
          }
        }
 else {
          Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getSecond()),null);
        }
      }
 else {
        Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getFirst().toString()),null);
      }
    }
 else {
      Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes),null);
    }
  }
  String appNamespace=mProjectCallback.getNamespace();
  if (attributeList != null) {
    for (int index=0; index < attributeList.size(); index++) {
      Pair<String,Boolean> attribute=attributeList.get(index);
      if (attribute == null) {
        continue;
      }
      String attrName=attribute.getFirst();
      boolean frameworkAttr=attribute.getSecond().booleanValue();
      String value=null;
      if (set != null) {
        value=set.getAttributeValue(frameworkAttr ? BridgeConstants.NS_RESOURCES : appNamespace,attrName);
        if (frameworkAttr == false && value == null) {
          value=set.getAttributeValue(BridgeConstants.NS_APP_RES_AUTO,attrName);
        }
      }
      if (value == null) {
        ResourceValue resValue=null;
        if (customStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(customStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null && defStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(defStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null) {
          resValue=mRenderResources.findItemInTheme(attrName,frameworkAttr);
        }
        if (resValue != null) {
          if (defaultPropMap != null) {
            defaultPropMap.put(attrName,resValue.getValue());
          }
          resValue=mRenderResources.resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,attrName,frameworkAttr,resValue);
      }
 else {
        ta.bridgeSetValue(index,attrName,frameworkAttr,mRenderResources.resolveValue(null,attrName,value,isPlatformFile));
      }
    }
  }
  ta.sealArray();
  return ta;
}","@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  Map<String,String> defaultPropMap=null;
  boolean isPlatformFile=true;
  if (set instanceof BridgeXmlBlockParser) {
    BridgeXmlBlockParser parser=null;
    parser=(BridgeXmlBlockParser)set;
    isPlatformFile=parser.isPlatformFile();
    Object key=parser.getViewCookie();
    if (key != null) {
      defaultPropMap=mDefaultPropMaps.get(key);
      if (defaultPropMap == null) {
        defaultPropMap=new HashMap<String,String>();
        mDefaultPropMaps.put(key,defaultPropMap);
      }
    }
  }
 else   if (set instanceof BridgeLayoutParamsMapAttributes) {
    isPlatformFile=false;
  }
 else   if (set != null) {
    Bridge.getLog().error(LayoutLog.TAG_BROKEN,""String_Node_Str"",null);
    return null;
  }
  List<Pair<String,Boolean>> attributeList=searchAttrs(attrs);
  BridgeTypedArray ta=((BridgeResources)mSystemResources).newTypeArray(attrs.length,isPlatformFile);
  String customStyle=null;
  if (set != null) {
    customStyle=set.getAttributeValue(null,""String_Node_Str"");
  }
  StyleResourceValue customStyleValues=null;
  if (customStyle != null) {
    ResourceValue item=mRenderResources.findResValue(customStyle,isPlatformFile);
    item=mRenderResources.resolveResValue(item);
    if (item instanceof StyleResourceValue) {
      customStyleValues=(StyleResourceValue)item;
    }
  }
  StyleResourceValue defStyleValues=null;
  if (defStyleAttr != 0) {
    Pair<String,Boolean> defStyleAttribute=searchAttr(defStyleAttr);
    if (defaultPropMap != null) {
      String defStyleName=defStyleAttribute.getFirst();
      if (defStyleAttribute.getSecond()) {
        defStyleName=""String_Node_Str"" + defStyleName;
      }
      defaultPropMap.put(""String_Node_Str"",defStyleName);
    }
    ResourceValue item=mRenderResources.findItemInTheme(defStyleAttribute.getFirst(),defStyleAttribute.getSecond());
    if (item != null) {
      item=mRenderResources.findResValue(item.getValue(),item.isFramework());
      if (item instanceof StyleResourceValue) {
        defStyleValues=(StyleResourceValue)item;
      }
    }
 else {
      Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE_THEME_ATTR,String.format(""String_Node_Str"",defStyleAttribute.getFirst()),null);
    }
  }
 else   if (defStyleRes != 0) {
    boolean isFrameworkRes=true;
    Pair<ResourceType,String> value=Bridge.resolveResourceId(defStyleRes);
    if (value == null) {
      value=mProjectCallback.resolveResourceId(defStyleRes);
      isFrameworkRes=false;
    }
    if (value != null) {
      if ((value.getFirst() == ResourceType.STYLE) || (value.getFirst() == ResourceType.ATTR)) {
        ResourceValue item=mRenderResources.findItemInTheme(value.getSecond(),isFrameworkRes);
        if (item != null) {
          if (item instanceof StyleResourceValue) {
            if (defaultPropMap != null) {
              defaultPropMap.put(""String_Node_Str"",item.getName());
            }
            defStyleValues=(StyleResourceValue)item;
          }
        }
 else {
          Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getSecond()),null);
        }
      }
 else {
        Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getFirst().toString()),null);
      }
    }
 else {
      Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes),null);
    }
  }
  String appNamespace=mProjectCallback.getNamespace();
  if (attributeList != null) {
    for (int index=0; index < attributeList.size(); index++) {
      Pair<String,Boolean> attribute=attributeList.get(index);
      if (attribute == null) {
        continue;
      }
      String attrName=attribute.getFirst();
      boolean frameworkAttr=attribute.getSecond().booleanValue();
      String value=null;
      if (set != null) {
        value=set.getAttributeValue(frameworkAttr ? BridgeConstants.NS_RESOURCES : appNamespace,attrName);
        if (frameworkAttr == false && value == null) {
          value=set.getAttributeValue(BridgeConstants.NS_APP_RES_AUTO,attrName);
        }
      }
      if (value == null) {
        ResourceValue resValue=null;
        if (customStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(customStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null && defStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(defStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null) {
          resValue=mRenderResources.findItemInTheme(attrName,frameworkAttr);
        }
        if (resValue != null) {
          if (defaultPropMap != null) {
            defaultPropMap.put(attrName,resValue.getValue());
          }
          resValue=mRenderResources.resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,attrName,frameworkAttr,resValue);
      }
 else {
        ta.bridgeSetValue(index,attrName,frameworkAttr,mRenderResources.resolveValue(null,attrName,value,isPlatformFile));
      }
    }
  }
  ta.sealArray();
  return ta;
}",0.9977377790892102
199062,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9829545454545454
199063,"@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  Map<String,String> defaultPropMap=null;
  boolean isPlatformFile=true;
  if (set instanceof BridgeXmlBlockParser) {
    BridgeXmlBlockParser parser=null;
    parser=(BridgeXmlBlockParser)set;
    isPlatformFile=parser.isPlatformFile();
    Object key=parser.getViewCookie();
    if (key != null) {
      defaultPropMap=mDefaultPropMaps.get(key);
      if (defaultPropMap == null) {
        defaultPropMap=new HashMap<String,String>();
        mDefaultPropMaps.put(key,defaultPropMap);
      }
    }
  }
 else   if (set instanceof BridgeLayoutParamsMapAttributes) {
    isPlatformFile=false;
  }
 else   if (set != null) {
    Bridge.getLog().error(LayoutLog.TAG_BROKEN,""String_Node_Str"",null);
    return null;
  }
  List<Pair<String,Boolean>> attributeList=searchAttrs(attrs);
  BridgeTypedArray ta=((BridgeResources)mSystemResources).newTypeArray(attrs.length,isPlatformFile);
  String customStyle=null;
  if (set != null) {
    customStyle=set.getAttributeValue(null,""String_Node_Str"");
  }
  StyleResourceValue customStyleValues=null;
  if (customStyle != null) {
    ResourceValue item=mRenderResources.findResValue(customStyle,isPlatformFile);
    item=mRenderResources.resolveResValue(item);
    if (item instanceof StyleResourceValue) {
      customStyleValues=(StyleResourceValue)item;
    }
  }
  StyleResourceValue defStyleValues=null;
  if (defStyleAttr != 0) {
    Pair<String,Boolean> defStyleAttribute=searchAttr(defStyleAttr);
    if (defaultPropMap != null) {
      String defStyleName=defStyleAttribute.getFirst();
      if (defStyleAttribute.getSecond()) {
        defStyleName=""String_Node_Str"" + defStyleName;
      }
      defaultPropMap.put(""String_Node_Str"",defStyleName);
    }
    ResourceValue item=mRenderResources.findItemInTheme(defStyleAttribute.getFirst(),defStyleAttribute.getSecond());
    if (item != null) {
      item=mRenderResources.findResValue(item.getValue(),false);
      if (item instanceof StyleResourceValue) {
        defStyleValues=(StyleResourceValue)item;
      }
    }
 else {
      Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE_THEME_ATTR,String.format(""String_Node_Str"",defStyleAttribute.getFirst()),null);
    }
  }
 else   if (defStyleRes != 0) {
    boolean isFrameworkRes=true;
    Pair<ResourceType,String> value=Bridge.resolveResourceId(defStyleRes);
    if (value == null) {
      value=mProjectCallback.resolveResourceId(defStyleRes);
      isFrameworkRes=false;
    }
    if (value != null) {
      if ((value.getFirst() == ResourceType.STYLE) || (value.getFirst() == ResourceType.ATTR)) {
        ResourceValue item=mRenderResources.findItemInTheme(value.getSecond(),isFrameworkRes);
        if (item != null) {
          if (item instanceof StyleResourceValue) {
            if (defaultPropMap != null) {
              defaultPropMap.put(""String_Node_Str"",item.getName());
            }
            defStyleValues=(StyleResourceValue)item;
          }
        }
 else {
          Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getSecond()),null);
        }
      }
 else {
        Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getFirst().toString()),null);
      }
    }
 else {
      Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes),null);
    }
  }
  String appNamespace=mProjectCallback.getNamespace();
  if (attributeList != null) {
    for (int index=0; index < attributeList.size(); index++) {
      Pair<String,Boolean> attribute=attributeList.get(index);
      if (attribute == null) {
        continue;
      }
      String attrName=attribute.getFirst();
      boolean frameworkAttr=attribute.getSecond().booleanValue();
      String value=null;
      if (set != null) {
        value=set.getAttributeValue(frameworkAttr ? BridgeConstants.NS_RESOURCES : appNamespace,attrName);
        if (frameworkAttr == false && value == null) {
          value=set.getAttributeValue(BridgeConstants.NS_APP_RES_AUTO,attrName);
        }
      }
      if (value == null) {
        ResourceValue resValue=null;
        if (customStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(customStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null && defStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(defStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null) {
          resValue=mRenderResources.findItemInTheme(attrName,frameworkAttr);
        }
        if (resValue != null) {
          if (defaultPropMap != null) {
            defaultPropMap.put(attrName,resValue.getValue());
          }
          resValue=mRenderResources.resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,attrName,frameworkAttr,resValue);
      }
 else {
        ta.bridgeSetValue(index,attrName,frameworkAttr,mRenderResources.resolveValue(null,attrName,value,isPlatformFile));
      }
    }
  }
  ta.sealArray();
  return ta;
}","@Override public TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs,int defStyleAttr,int defStyleRes){
  Map<String,String> defaultPropMap=null;
  boolean isPlatformFile=true;
  if (set instanceof BridgeXmlBlockParser) {
    BridgeXmlBlockParser parser=null;
    parser=(BridgeXmlBlockParser)set;
    isPlatformFile=parser.isPlatformFile();
    Object key=parser.getViewCookie();
    if (key != null) {
      defaultPropMap=mDefaultPropMaps.get(key);
      if (defaultPropMap == null) {
        defaultPropMap=new HashMap<String,String>();
        mDefaultPropMaps.put(key,defaultPropMap);
      }
    }
  }
 else   if (set instanceof BridgeLayoutParamsMapAttributes) {
    isPlatformFile=false;
  }
 else   if (set != null) {
    Bridge.getLog().error(LayoutLog.TAG_BROKEN,""String_Node_Str"",null);
    return null;
  }
  List<Pair<String,Boolean>> attributeList=searchAttrs(attrs);
  BridgeTypedArray ta=((BridgeResources)mSystemResources).newTypeArray(attrs.length,isPlatformFile);
  String customStyle=null;
  if (set != null) {
    customStyle=set.getAttributeValue(null,""String_Node_Str"");
  }
  StyleResourceValue customStyleValues=null;
  if (customStyle != null) {
    ResourceValue item=mRenderResources.findResValue(customStyle,isPlatformFile);
    item=mRenderResources.resolveResValue(item);
    if (item instanceof StyleResourceValue) {
      customStyleValues=(StyleResourceValue)item;
    }
  }
  StyleResourceValue defStyleValues=null;
  if (defStyleAttr != 0) {
    Pair<String,Boolean> defStyleAttribute=searchAttr(defStyleAttr);
    if (defaultPropMap != null) {
      String defStyleName=defStyleAttribute.getFirst();
      if (defStyleAttribute.getSecond()) {
        defStyleName=""String_Node_Str"" + defStyleName;
      }
      defaultPropMap.put(""String_Node_Str"",defStyleName);
    }
    ResourceValue item=mRenderResources.findItemInTheme(defStyleAttribute.getFirst(),defStyleAttribute.getSecond());
    if (item != null) {
      item=mRenderResources.findResValue(item.getValue(),item.isFramework());
      if (item instanceof StyleResourceValue) {
        defStyleValues=(StyleResourceValue)item;
      }
    }
 else {
      Bridge.getLog().error(LayoutLog.TAG_RESOURCES_RESOLVE_THEME_ATTR,String.format(""String_Node_Str"",defStyleAttribute.getFirst()),null);
    }
  }
 else   if (defStyleRes != 0) {
    boolean isFrameworkRes=true;
    Pair<ResourceType,String> value=Bridge.resolveResourceId(defStyleRes);
    if (value == null) {
      value=mProjectCallback.resolveResourceId(defStyleRes);
      isFrameworkRes=false;
    }
    if (value != null) {
      if ((value.getFirst() == ResourceType.STYLE) || (value.getFirst() == ResourceType.ATTR)) {
        ResourceValue item=mRenderResources.findItemInTheme(value.getSecond(),isFrameworkRes);
        if (item != null) {
          if (item instanceof StyleResourceValue) {
            if (defaultPropMap != null) {
              defaultPropMap.put(""String_Node_Str"",item.getName());
            }
            defStyleValues=(StyleResourceValue)item;
          }
        }
 else {
          Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getSecond()),null);
        }
      }
 else {
        Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes,value.getFirst().toString()),null);
      }
    }
 else {
      Bridge.getLog().error(null,String.format(""String_Node_Str"",defStyleRes),null);
    }
  }
  String appNamespace=mProjectCallback.getNamespace();
  if (attributeList != null) {
    for (int index=0; index < attributeList.size(); index++) {
      Pair<String,Boolean> attribute=attributeList.get(index);
      if (attribute == null) {
        continue;
      }
      String attrName=attribute.getFirst();
      boolean frameworkAttr=attribute.getSecond().booleanValue();
      String value=null;
      if (set != null) {
        value=set.getAttributeValue(frameworkAttr ? BridgeConstants.NS_RESOURCES : appNamespace,attrName);
        if (frameworkAttr == false && value == null) {
          value=set.getAttributeValue(BridgeConstants.NS_APP_RES_AUTO,attrName);
        }
      }
      if (value == null) {
        ResourceValue resValue=null;
        if (customStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(customStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null && defStyleValues != null) {
          resValue=mRenderResources.findItemInStyle(defStyleValues,attrName,frameworkAttr);
        }
        if (resValue == null) {
          resValue=mRenderResources.findItemInTheme(attrName,frameworkAttr);
        }
        if (resValue != null) {
          if (defaultPropMap != null) {
            defaultPropMap.put(attrName,resValue.getValue());
          }
          resValue=mRenderResources.resolveResValue(resValue);
        }
        ta.bridgeSetValue(index,attrName,frameworkAttr,resValue);
      }
 else {
        ta.bridgeSetValue(index,attrName,frameworkAttr,mRenderResources.resolveValue(null,attrName,value,isPlatformFile));
      }
    }
  }
  ta.sealArray();
  return ta;
}",0.9977377790892102
199064,"private InputStream getIconWithApi(String[] pathOut,String iconName){
  if (mSimulatedPlatformVersion == 0) {
    String path=pathOut[0];
    String dirName=path.substring(0,path.lastIndexOf('/'));
    pathOut[0]=dirName + ""String_Node_Str"" + ""String_Node_Str""+ iconName;
    InputStream stream=getClass().getResourceAsStream(pathOut[0]);
    if (stream != null) {
      return stream;
    }
  }
  return getClass().getResourceAsStream(pathOut[0]);
}","private InputStream getIconWithApi(String[] pathOut,String iconName){
  if (mSimulatedPlatformVersion == 0) {
    String path=pathOut[0];
    String dirName=path.substring(0,path.lastIndexOf('/'));
    path=dirName + ""String_Node_Str"" + ""String_Node_Str""+ iconName;
    InputStream stream=getClass().getResourceAsStream(path);
    if (stream != null) {
      pathOut[0]=path;
      return stream;
    }
  }
  return getClass().getResourceAsStream(pathOut[0]);
}",0.566410537870472
199065,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9829545454545454
199066,"private InputStream getIconWithApi(String[] pathOut,String iconName){
  if (mSimulatedPlatformVersion == 0) {
    String path=pathOut[0];
    String dirName=path.substring(0,path.lastIndexOf('/'));
    pathOut[0]=dirName + ""String_Node_Str"" + ""String_Node_Str""+ iconName;
    InputStream stream=getClass().getResourceAsStream(pathOut[0]);
    if (stream != null) {
      return stream;
    }
  }
  return getClass().getResourceAsStream(pathOut[0]);
}","private InputStream getIconWithApi(String[] pathOut,String iconName){
  if (mSimulatedPlatformVersion == 0) {
    String path=pathOut[0];
    String dirName=path.substring(0,path.lastIndexOf('/'));
    path=dirName + ""String_Node_Str"" + ""String_Node_Str""+ iconName;
    InputStream stream=getClass().getResourceAsStream(path);
    if (stream != null) {
      pathOut[0]=path;
      return stream;
    }
  }
  return getClass().getResourceAsStream(pathOut[0]);
}",0.566410537870472
199067,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9829545454545454
199068,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9829545454545454
199069,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9829545454545454
199070,"/** 
 * Terminate instrumentation of the application.  This will cause the application process to exit, removing this instrumentation from the next time the application is started. 
 * @param resultCode Overall success/failure of instrumentation. 
 * @param results Any results to send back to the code that started the instrumentation.
 */
public void finish(int resultCode,Bundle results){
  if (mAutomaticPerformanceSnapshots) {
    endPerformanceSnapshot();
  }
  if (mPerfMetrics != null) {
    results.putAll(mPerfMetrics);
  }
  if (mUiAutomation != null) {
    mUiAutomation.disconnect();
    mUiAutomation=null;
  }
  mThread.finishInstrumentation(resultCode,results);
}","/** 
 * Terminate instrumentation of the application.  This will cause the application process to exit, removing this instrumentation from the next time the application is started. 
 * @param resultCode Overall success/failure of instrumentation. 
 * @param results Any results to send back to the code that started the instrumentation.
 */
public void finish(int resultCode,Bundle results){
  if (mAutomaticPerformanceSnapshots) {
    endPerformanceSnapshot();
  }
  if (mPerfMetrics != null) {
    if (results == null) {
      results=new Bundle();
    }
    results.putAll(mPerfMetrics);
  }
  if (mUiAutomation != null) {
    mUiAutomation.disconnect();
    mUiAutomation=null;
  }
  mThread.finishInstrumentation(resultCode,results);
}",0.9570119802677942
199071,"/** 
 * Terminate instrumentation of the application.  This will cause the application process to exit, removing this instrumentation from the next time the application is started. 
 * @param resultCode Overall success/failure of instrumentation. 
 * @param results Any results to send back to the code that started the instrumentation.
 */
public void finish(int resultCode,Bundle results){
  if (mAutomaticPerformanceSnapshots) {
    endPerformanceSnapshot();
  }
  if (mPerfMetrics != null) {
    results.putAll(mPerfMetrics);
  }
  if (mUiAutomation != null) {
    mUiAutomation.disconnect();
    mUiAutomation=null;
  }
  mThread.finishInstrumentation(resultCode,results);
}","/** 
 * Terminate instrumentation of the application.  This will cause the application process to exit, removing this instrumentation from the next time the application is started. 
 * @param resultCode Overall success/failure of instrumentation. 
 * @param results Any results to send back to the code that started the instrumentation.
 */
public void finish(int resultCode,Bundle results){
  if (mAutomaticPerformanceSnapshots) {
    endPerformanceSnapshot();
  }
  if (mPerfMetrics != null) {
    if (results == null) {
      results=new Bundle();
    }
    results.putAll(mPerfMetrics);
  }
  if (mUiAutomation != null) {
    mUiAutomation.disconnect();
    mUiAutomation=null;
  }
  mThread.finishInstrumentation(resultCode,results);
}",0.9570119802677942
199072,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(Bundle options){
synchronized (KeyguardViewMediator.this) {
    if (!mSystemReady) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
 else {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
    }
    mStatusBarKeyguardViewManager.show(options);
    mShowing=true;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    userActivity();
    playSounds(true);
    mShowKeyguardWakeLock.release();
  }
  mKeyguardDisplayManager.show();
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(Bundle options){
synchronized (KeyguardViewMediator.this) {
    if (!mSystemReady) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
 else {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
    }
    mStatusBarKeyguardViewManager.show(options);
    mHiding=false;
    mShowing=true;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    userActivity();
    playSounds(true);
    mShowKeyguardWakeLock.release();
  }
  mKeyguardDisplayManager.show();
}",0.9292107404393816
199073,"private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
synchronized (KeyguardViewMediator.this) {
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    mShowing=false;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
  }
}","private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
synchronized (KeyguardViewMediator.this) {
    if (!mHiding) {
      return;
    }
    mHiding=false;
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    mShowing=false;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
  }
}",0.9333333333333332
199074,"/** 
 * Handle message sent by   {@link #hideLocked()}
 * @see #HIDE
 */
private void handleHide(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      if (mShowing) {
        mWM.keyguardGoingAway();
      }
 else {
        handleStartKeyguardExitAnimation(0,0);
      }
    }
 catch (    RemoteException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Handle message sent by   {@link #hideLocked()}
 * @see #HIDE
 */
private void handleHide(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      mHiding=true;
      if (mShowing) {
        mWM.keyguardGoingAway();
      }
 else {
        handleStartKeyguardExitAnimation(0,0);
      }
    }
 catch (    RemoteException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.976525821596244
199075,"private void updateWindowsLocked(final int displayId){
  ++mAnimTransactionSequence;
  final WindowList windows=mService.getWindowListLocked(displayId);
  ArrayList<WindowStateAnimator> unForceHiding=null;
  boolean wallpaperInUnForceHiding=false;
  if (mKeyguardGoingAway) {
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState win=windows.get(i);
      if (!mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        continue;
      }
      final WindowStateAnimator winAnimator=win.mWinAnimator;
      if ((win.mAttrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        if (!winAnimator.mAnimating) {
          winAnimator.mAnimation=new AlphaAnimation(1.0f,1.0f);
          winAnimator.mAnimation.setDuration(KEYGUARD_ANIM_TIMEOUT_MS);
          winAnimator.mAnimationIsEntrance=false;
        }
      }
 else {
        mKeyguardGoingAway=false;
        winAnimator.clearAnimation();
      }
      break;
    }
  }
  mForceHiding=KEYGUARD_NOT_SHOWN;
  for (int i=windows.size() - 1; i >= 0; i--) {
    WindowState win=windows.get(i);
    WindowStateAnimator winAnimator=win.mWinAnimator;
    final int flags=winAnimator.mAttrFlags;
    if (winAnimator.mSurfaceControl != null) {
      final boolean wasAnimating=winAnimator.mWasAnimating;
      final boolean nowAnimating=winAnimator.stepAnimationLocked(mCurrentTime);
      if (WindowManagerService.DEBUG_WALLPAPER) {
        Slog.v(TAG,win + ""String_Node_Str"" + wasAnimating+ ""String_Node_Str""+ nowAnimating);
      }
      if (wasAnimating && !winAnimator.mAnimating && mService.mWallpaperTarget == win) {
        mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
        setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
        if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
          mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
        }
      }
      if (mPolicy.isForceHiding(win.mAttrs)) {
        if (!wasAnimating && nowAnimating) {
          if (WindowManagerService.DEBUG_ANIM || WindowManagerService.DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          mBulkUpdateParams|=SET_FORCE_HIDING_CHANGED;
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
          mService.mFocusMayChange=true;
        }
 else         if (mKeyguardGoingAway && !nowAnimating) {
          Slog.e(TAG,""String_Node_Str"");
          mPolicy.startKeyguardExitAnimation(0,0);
          mKeyguardGoingAway=false;
        }
        if (win.isReadyForDisplay()) {
          if (nowAnimating) {
            if (winAnimator.mAnimationIsEntrance) {
              mForceHiding=KEYGUARD_ANIMATING_IN;
            }
 else {
              mForceHiding=KEYGUARD_ANIMATING_OUT;
            }
          }
 else {
            mForceHiding=win.isDrawnLw() ? KEYGUARD_SHOWN : KEYGUARD_NOT_SHOWN;
          }
        }
        if (WindowManagerService.DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + forceHidingToString() + ""String_Node_Str""+ win.mHasSurface+ ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDestroying+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ win.mViewVisibility+ ""String_Node_Str""+ win.mRootToken.hidden+ ""String_Node_Str""+ win.mWinAnimator.mAnimation);
      }
 else       if (mPolicy.canBeForceHidden(win,win.mAttrs)) {
        final boolean hideWhenLocked=(winAnimator.mAttrFlags & FLAG_SHOW_WHEN_LOCKED) == 0;
        final boolean changed;
        if (((mForceHiding == KEYGUARD_ANIMATING_IN) && (!winAnimator.isAnimating() || hideWhenLocked)) || ((mForceHiding == KEYGUARD_SHOWN) && hideWhenLocked)) {
          changed=win.hideLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
        }
 else {
          changed=win.showLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
          if (changed) {
            if ((mBulkUpdateParams & SET_FORCE_HIDING_CHANGED) != 0 && win.isVisibleNow()) {
              if (unForceHiding == null) {
                unForceHiding=new ArrayList<WindowStateAnimator>();
              }
              unForceHiding.add(winAnimator);
              if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
                wallpaperInUnForceHiding=true;
              }
            }
            final WindowState currentFocus=mService.mCurrentFocus;
            if (currentFocus == null || currentFocus.mLayer < win.mLayer) {
              if (WindowManagerService.DEBUG_FOCUS_LIGHT)               Slog.v(TAG,""String_Node_Str"");
              mService.mFocusMayChange=true;
            }
          }
        }
        if (changed && (flags & FLAG_SHOW_WALLPAPER) != 0) {
          mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
          setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
          }
        }
      }
    }
    final AppWindowToken atoken=win.mAppToken;
    if (winAnimator.mDrawState == WindowStateAnimator.READY_TO_SHOW) {
      if (atoken == null || atoken.allDrawn) {
        if (winAnimator.performShowLocked()) {
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
        }
      }
    }
    final AppWindowAnimator appAnimator=winAnimator.mAppAnimator;
    if (appAnimator != null && appAnimator.thumbnail != null) {
      if (appAnimator.thumbnailTransactionSeq != mAnimTransactionSequence) {
        appAnimator.thumbnailTransactionSeq=mAnimTransactionSequence;
        appAnimator.thumbnailLayer=0;
      }
      if (appAnimator.thumbnailLayer < winAnimator.mAnimLayer) {
        appAnimator.thumbnailLayer=winAnimator.mAnimLayer;
      }
    }
  }
  if (unForceHiding != null) {
    boolean startKeyguardExit=true;
    for (int i=unForceHiding.size() - 1; i >= 0; i--) {
      Animation a=mPolicy.createForceHideEnterAnimation(wallpaperInUnForceHiding);
      if (a != null) {
        final WindowStateAnimator winAnimator=unForceHiding.get(i);
        winAnimator.setAnimation(a);
        winAnimator.mAnimationIsEntrance=true;
        if (startKeyguardExit) {
          mPolicy.startKeyguardExitAnimation(mCurrentTime + a.getStartOffset(),a.getDuration());
          mKeyguardGoingAway=false;
          startKeyguardExit=false;
        }
      }
    }
  }
}","private void updateWindowsLocked(final int displayId){
  ++mAnimTransactionSequence;
  final WindowList windows=mService.getWindowListLocked(displayId);
  ArrayList<WindowStateAnimator> unForceHiding=null;
  boolean wallpaperInUnForceHiding=false;
  if (mKeyguardGoingAway) {
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState win=windows.get(i);
      if (!mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        continue;
      }
      final WindowStateAnimator winAnimator=win.mWinAnimator;
      if ((win.mAttrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        if (!winAnimator.mAnimating) {
          winAnimator.mAnimation=new AlphaAnimation(1.0f,1.0f);
          winAnimator.mAnimation.setDuration(KEYGUARD_ANIM_TIMEOUT_MS);
          winAnimator.mAnimationIsEntrance=false;
        }
      }
 else {
        mKeyguardGoingAway=false;
        winAnimator.clearAnimation();
      }
      break;
    }
  }
  mForceHiding=KEYGUARD_NOT_SHOWN;
  for (int i=windows.size() - 1; i >= 0; i--) {
    WindowState win=windows.get(i);
    WindowStateAnimator winAnimator=win.mWinAnimator;
    final int flags=winAnimator.mAttrFlags;
    if (winAnimator.mSurfaceControl != null) {
      final boolean wasAnimating=winAnimator.mWasAnimating;
      final boolean nowAnimating=winAnimator.stepAnimationLocked(mCurrentTime);
      if (WindowManagerService.DEBUG_WALLPAPER) {
        Slog.v(TAG,win + ""String_Node_Str"" + wasAnimating+ ""String_Node_Str""+ nowAnimating);
      }
      if (wasAnimating && !winAnimator.mAnimating && mService.mWallpaperTarget == win) {
        mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
        setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
        if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
          mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
        }
      }
      if (mPolicy.isForceHiding(win.mAttrs)) {
        if (!wasAnimating && nowAnimating) {
          if (WindowManagerService.DEBUG_ANIM || WindowManagerService.DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          mBulkUpdateParams|=SET_FORCE_HIDING_CHANGED;
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
          mService.mFocusMayChange=true;
        }
 else         if (mKeyguardGoingAway && !nowAnimating) {
          Slog.e(TAG,""String_Node_Str"");
          mPolicy.startKeyguardExitAnimation(0,0);
          mKeyguardGoingAway=false;
        }
        if (win.isReadyForDisplay()) {
          if (nowAnimating) {
            if (winAnimator.mAnimationIsEntrance) {
              mForceHiding=KEYGUARD_ANIMATING_IN;
            }
 else {
              mForceHiding=KEYGUARD_ANIMATING_OUT;
            }
          }
 else {
            mForceHiding=win.isDrawnLw() ? KEYGUARD_SHOWN : KEYGUARD_NOT_SHOWN;
          }
        }
        if (WindowManagerService.DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + forceHidingToString() + ""String_Node_Str""+ win.mHasSurface+ ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDestroying+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ win.mViewVisibility+ ""String_Node_Str""+ win.mRootToken.hidden+ ""String_Node_Str""+ win.mWinAnimator.mAnimation);
      }
 else       if (mPolicy.canBeForceHidden(win,win.mAttrs)) {
        final boolean hideWhenLocked=(winAnimator.mAttrFlags & FLAG_SHOW_WHEN_LOCKED) == 0;
        final boolean changed;
        if (((mForceHiding == KEYGUARD_ANIMATING_IN) && (!winAnimator.isAnimating() || hideWhenLocked)) || ((mForceHiding == KEYGUARD_SHOWN) && hideWhenLocked)) {
          changed=win.hideLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
        }
 else {
          changed=win.showLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
          if (changed) {
            if ((mBulkUpdateParams & SET_FORCE_HIDING_CHANGED) != 0 && win.isVisibleNow()) {
              if (unForceHiding == null) {
                unForceHiding=new ArrayList<WindowStateAnimator>();
              }
              unForceHiding.add(winAnimator);
              if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
                wallpaperInUnForceHiding=true;
              }
            }
            final WindowState currentFocus=mService.mCurrentFocus;
            if (currentFocus == null || currentFocus.mLayer < win.mLayer) {
              if (WindowManagerService.DEBUG_FOCUS_LIGHT)               Slog.v(TAG,""String_Node_Str"");
              mService.mFocusMayChange=true;
            }
          }
        }
        if (changed && (flags & FLAG_SHOW_WALLPAPER) != 0) {
          mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
          setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
          }
        }
      }
    }
    final AppWindowToken atoken=win.mAppToken;
    if (winAnimator.mDrawState == WindowStateAnimator.READY_TO_SHOW) {
      if (atoken == null || atoken.allDrawn) {
        if (winAnimator.performShowLocked()) {
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
        }
      }
    }
    final AppWindowAnimator appAnimator=winAnimator.mAppAnimator;
    if (appAnimator != null && appAnimator.thumbnail != null) {
      if (appAnimator.thumbnailTransactionSeq != mAnimTransactionSequence) {
        appAnimator.thumbnailTransactionSeq=mAnimTransactionSequence;
        appAnimator.thumbnailLayer=0;
      }
      if (appAnimator.thumbnailLayer < winAnimator.mAnimLayer) {
        appAnimator.thumbnailLayer=winAnimator.mAnimLayer;
      }
    }
  }
  if (unForceHiding != null) {
    boolean startKeyguardExit=true;
    for (int i=unForceHiding.size() - 1; i >= 0; i--) {
      Animation a=mPolicy.createForceHideEnterAnimation(wallpaperInUnForceHiding);
      if (a != null) {
        final WindowStateAnimator winAnimator=unForceHiding.get(i);
        winAnimator.setAnimation(a);
        winAnimator.mAnimationIsEntrance=true;
        if (startKeyguardExit && mKeyguardGoingAway) {
          mPolicy.startKeyguardExitAnimation(mCurrentTime + a.getStartOffset(),a.getDuration());
          mKeyguardGoingAway=false;
          startKeyguardExit=false;
        }
      }
    }
  }
}",0.9984108639121642
199076,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(Bundle options){
synchronized (KeyguardViewMediator.this) {
    if (!mSystemReady) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
 else {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
    }
    mStatusBarKeyguardViewManager.show(options);
    mShowing=true;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    userActivity();
    playSounds(true);
    mShowKeyguardWakeLock.release();
  }
  mKeyguardDisplayManager.show();
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(Bundle options){
synchronized (KeyguardViewMediator.this) {
    if (!mSystemReady) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      return;
    }
 else {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
    }
    mStatusBarKeyguardViewManager.show(options);
    mHiding=false;
    mShowing=true;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
    userActivity();
    playSounds(true);
    mShowKeyguardWakeLock.release();
  }
  mKeyguardDisplayManager.show();
}",0.9292107404393816
199077,"private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
synchronized (KeyguardViewMediator.this) {
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    mShowing=false;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
  }
}","private void handleStartKeyguardExitAnimation(long startTime,long fadeoutDuration){
synchronized (KeyguardViewMediator.this) {
    if (!mHiding) {
      return;
    }
    mHiding=false;
    if (TelephonyManager.EXTRA_STATE_IDLE.equals(mPhoneState)) {
      playSounds(false);
    }
    mStatusBarKeyguardViewManager.hide(startTime,fadeoutDuration);
    mShowing=false;
    mKeyguardDonePending=false;
    updateActivityLockScreenState();
    adjustStatusBarLocked();
  }
}",0.9333333333333332
199078,"/** 
 * Handle message sent by   {@link #hideLocked()}
 * @see #HIDE
 */
private void handleHide(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      if (mShowing) {
        mWM.keyguardGoingAway();
      }
 else {
        handleStartKeyguardExitAnimation(0,0);
      }
    }
 catch (    RemoteException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Handle message sent by   {@link #hideLocked()}
 * @see #HIDE
 */
private void handleHide(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    try {
      mHiding=true;
      if (mShowing) {
        mWM.keyguardGoingAway();
      }
 else {
        handleStartKeyguardExitAnimation(0,0);
      }
    }
 catch (    RemoteException e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
}",0.976525821596244
199079,"private void updateWindowsLocked(final int displayId){
  ++mAnimTransactionSequence;
  final WindowList windows=mService.getWindowListLocked(displayId);
  ArrayList<WindowStateAnimator> unForceHiding=null;
  boolean wallpaperInUnForceHiding=false;
  if (mKeyguardGoingAway) {
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState win=windows.get(i);
      if (!mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        continue;
      }
      final WindowStateAnimator winAnimator=win.mWinAnimator;
      if ((win.mAttrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        if (!winAnimator.mAnimating) {
          winAnimator.mAnimation=new AlphaAnimation(1.0f,1.0f);
          winAnimator.mAnimation.setDuration(KEYGUARD_ANIM_TIMEOUT_MS);
          winAnimator.mAnimationIsEntrance=false;
        }
      }
 else {
        mKeyguardGoingAway=false;
        winAnimator.clearAnimation();
      }
      break;
    }
  }
  mForceHiding=KEYGUARD_NOT_SHOWN;
  for (int i=windows.size() - 1; i >= 0; i--) {
    WindowState win=windows.get(i);
    WindowStateAnimator winAnimator=win.mWinAnimator;
    final int flags=winAnimator.mAttrFlags;
    if (winAnimator.mSurfaceControl != null) {
      final boolean wasAnimating=winAnimator.mWasAnimating;
      final boolean nowAnimating=winAnimator.stepAnimationLocked(mCurrentTime);
      if (WindowManagerService.DEBUG_WALLPAPER) {
        Slog.v(TAG,win + ""String_Node_Str"" + wasAnimating+ ""String_Node_Str""+ nowAnimating);
      }
      if (wasAnimating && !winAnimator.mAnimating && mService.mWallpaperTarget == win) {
        mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
        setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
        if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
          mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
        }
      }
      if (mPolicy.isForceHiding(win.mAttrs)) {
        if (!wasAnimating && nowAnimating) {
          if (WindowManagerService.DEBUG_ANIM || WindowManagerService.DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          mBulkUpdateParams|=SET_FORCE_HIDING_CHANGED;
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
          mService.mFocusMayChange=true;
        }
 else         if (mKeyguardGoingAway && !nowAnimating) {
          Slog.e(TAG,""String_Node_Str"");
          mPolicy.startKeyguardExitAnimation(0,0);
          mKeyguardGoingAway=false;
        }
        if (win.isReadyForDisplay()) {
          if (nowAnimating) {
            if (winAnimator.mAnimationIsEntrance) {
              mForceHiding=KEYGUARD_ANIMATING_IN;
            }
 else {
              mForceHiding=KEYGUARD_ANIMATING_OUT;
            }
          }
 else {
            mForceHiding=win.isDrawnLw() ? KEYGUARD_SHOWN : KEYGUARD_NOT_SHOWN;
          }
        }
        if (WindowManagerService.DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + forceHidingToString() + ""String_Node_Str""+ win.mHasSurface+ ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDestroying+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ win.mViewVisibility+ ""String_Node_Str""+ win.mRootToken.hidden+ ""String_Node_Str""+ win.mWinAnimator.mAnimation);
      }
 else       if (mPolicy.canBeForceHidden(win,win.mAttrs)) {
        final boolean hideWhenLocked=(winAnimator.mAttrFlags & FLAG_SHOW_WHEN_LOCKED) == 0;
        final boolean changed;
        if (((mForceHiding == KEYGUARD_ANIMATING_IN) && (!winAnimator.isAnimating() || hideWhenLocked)) || ((mForceHiding == KEYGUARD_SHOWN) && hideWhenLocked)) {
          changed=win.hideLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
        }
 else {
          changed=win.showLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
          if (changed) {
            if ((mBulkUpdateParams & SET_FORCE_HIDING_CHANGED) != 0 && win.isVisibleNow()) {
              if (unForceHiding == null) {
                unForceHiding=new ArrayList<WindowStateAnimator>();
              }
              unForceHiding.add(winAnimator);
              if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
                wallpaperInUnForceHiding=true;
              }
            }
            final WindowState currentFocus=mService.mCurrentFocus;
            if (currentFocus == null || currentFocus.mLayer < win.mLayer) {
              if (WindowManagerService.DEBUG_FOCUS_LIGHT)               Slog.v(TAG,""String_Node_Str"");
              mService.mFocusMayChange=true;
            }
          }
        }
        if (changed && (flags & FLAG_SHOW_WALLPAPER) != 0) {
          mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
          setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
          }
        }
      }
    }
    final AppWindowToken atoken=win.mAppToken;
    if (winAnimator.mDrawState == WindowStateAnimator.READY_TO_SHOW) {
      if (atoken == null || atoken.allDrawn) {
        if (winAnimator.performShowLocked()) {
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
        }
      }
    }
    final AppWindowAnimator appAnimator=winAnimator.mAppAnimator;
    if (appAnimator != null && appAnimator.thumbnail != null) {
      if (appAnimator.thumbnailTransactionSeq != mAnimTransactionSequence) {
        appAnimator.thumbnailTransactionSeq=mAnimTransactionSequence;
        appAnimator.thumbnailLayer=0;
      }
      if (appAnimator.thumbnailLayer < winAnimator.mAnimLayer) {
        appAnimator.thumbnailLayer=winAnimator.mAnimLayer;
      }
    }
  }
  if (unForceHiding != null) {
    boolean startKeyguardExit=true;
    for (int i=unForceHiding.size() - 1; i >= 0; i--) {
      Animation a=mPolicy.createForceHideEnterAnimation(wallpaperInUnForceHiding);
      if (a != null) {
        final WindowStateAnimator winAnimator=unForceHiding.get(i);
        winAnimator.setAnimation(a);
        winAnimator.mAnimationIsEntrance=true;
        if (startKeyguardExit) {
          mPolicy.startKeyguardExitAnimation(mCurrentTime + a.getStartOffset(),a.getDuration());
          mKeyguardGoingAway=false;
          startKeyguardExit=false;
        }
      }
    }
  }
}","private void updateWindowsLocked(final int displayId){
  ++mAnimTransactionSequence;
  final WindowList windows=mService.getWindowListLocked(displayId);
  ArrayList<WindowStateAnimator> unForceHiding=null;
  boolean wallpaperInUnForceHiding=false;
  if (mKeyguardGoingAway) {
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState win=windows.get(i);
      if (!mPolicy.isKeyguardHostWindow(win.mAttrs)) {
        continue;
      }
      final WindowStateAnimator winAnimator=win.mWinAnimator;
      if ((win.mAttrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        if (!winAnimator.mAnimating) {
          winAnimator.mAnimation=new AlphaAnimation(1.0f,1.0f);
          winAnimator.mAnimation.setDuration(KEYGUARD_ANIM_TIMEOUT_MS);
          winAnimator.mAnimationIsEntrance=false;
        }
      }
 else {
        mKeyguardGoingAway=false;
        winAnimator.clearAnimation();
      }
      break;
    }
  }
  mForceHiding=KEYGUARD_NOT_SHOWN;
  for (int i=windows.size() - 1; i >= 0; i--) {
    WindowState win=windows.get(i);
    WindowStateAnimator winAnimator=win.mWinAnimator;
    final int flags=winAnimator.mAttrFlags;
    if (winAnimator.mSurfaceControl != null) {
      final boolean wasAnimating=winAnimator.mWasAnimating;
      final boolean nowAnimating=winAnimator.stepAnimationLocked(mCurrentTime);
      if (WindowManagerService.DEBUG_WALLPAPER) {
        Slog.v(TAG,win + ""String_Node_Str"" + wasAnimating+ ""String_Node_Str""+ nowAnimating);
      }
      if (wasAnimating && !winAnimator.mAnimating && mService.mWallpaperTarget == win) {
        mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
        setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
        if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
          mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
        }
      }
      if (mPolicy.isForceHiding(win.mAttrs)) {
        if (!wasAnimating && nowAnimating) {
          if (WindowManagerService.DEBUG_ANIM || WindowManagerService.DEBUG_VISIBILITY)           Slog.v(TAG,""String_Node_Str"" + win);
          mBulkUpdateParams|=SET_FORCE_HIDING_CHANGED;
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
          mService.mFocusMayChange=true;
        }
 else         if (mKeyguardGoingAway && !nowAnimating) {
          Slog.e(TAG,""String_Node_Str"");
          mPolicy.startKeyguardExitAnimation(0,0);
          mKeyguardGoingAway=false;
        }
        if (win.isReadyForDisplay()) {
          if (nowAnimating) {
            if (winAnimator.mAnimationIsEntrance) {
              mForceHiding=KEYGUARD_ANIMATING_IN;
            }
 else {
              mForceHiding=KEYGUARD_ANIMATING_OUT;
            }
          }
 else {
            mForceHiding=win.isDrawnLw() ? KEYGUARD_SHOWN : KEYGUARD_NOT_SHOWN;
          }
        }
        if (WindowManagerService.DEBUG_VISIBILITY)         Slog.v(TAG,""String_Node_Str"" + forceHidingToString() + ""String_Node_Str""+ win.mHasSurface+ ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDestroying+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ win.mViewVisibility+ ""String_Node_Str""+ win.mRootToken.hidden+ ""String_Node_Str""+ win.mWinAnimator.mAnimation);
      }
 else       if (mPolicy.canBeForceHidden(win,win.mAttrs)) {
        final boolean hideWhenLocked=(winAnimator.mAttrFlags & FLAG_SHOW_WHEN_LOCKED) == 0;
        final boolean changed;
        if (((mForceHiding == KEYGUARD_ANIMATING_IN) && (!winAnimator.isAnimating() || hideWhenLocked)) || ((mForceHiding == KEYGUARD_SHOWN) && hideWhenLocked)) {
          changed=win.hideLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
        }
 else {
          changed=win.showLw(false,false);
          if (WindowManagerService.DEBUG_VISIBILITY && changed)           Slog.v(TAG,""String_Node_Str"" + win);
          if (changed) {
            if ((mBulkUpdateParams & SET_FORCE_HIDING_CHANGED) != 0 && win.isVisibleNow()) {
              if (unForceHiding == null) {
                unForceHiding=new ArrayList<WindowStateAnimator>();
              }
              unForceHiding.add(winAnimator);
              if ((flags & FLAG_SHOW_WALLPAPER) != 0) {
                wallpaperInUnForceHiding=true;
              }
            }
            final WindowState currentFocus=mService.mCurrentFocus;
            if (currentFocus == null || currentFocus.mLayer < win.mLayer) {
              if (WindowManagerService.DEBUG_FOCUS_LIGHT)               Slog.v(TAG,""String_Node_Str"");
              mService.mFocusMayChange=true;
            }
          }
        }
        if (changed && (flags & FLAG_SHOW_WALLPAPER) != 0) {
          mBulkUpdateParams|=SET_WALLPAPER_MAY_CHANGE;
          setPendingLayoutChanges(Display.DEFAULT_DISPLAY,WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(Display.DEFAULT_DISPLAY));
          }
        }
      }
    }
    final AppWindowToken atoken=win.mAppToken;
    if (winAnimator.mDrawState == WindowStateAnimator.READY_TO_SHOW) {
      if (atoken == null || atoken.allDrawn) {
        if (winAnimator.performShowLocked()) {
          setPendingLayoutChanges(displayId,WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
          if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
            mService.debugLayoutRepeats(""String_Node_Str"",getPendingLayoutChanges(displayId));
          }
        }
      }
    }
    final AppWindowAnimator appAnimator=winAnimator.mAppAnimator;
    if (appAnimator != null && appAnimator.thumbnail != null) {
      if (appAnimator.thumbnailTransactionSeq != mAnimTransactionSequence) {
        appAnimator.thumbnailTransactionSeq=mAnimTransactionSequence;
        appAnimator.thumbnailLayer=0;
      }
      if (appAnimator.thumbnailLayer < winAnimator.mAnimLayer) {
        appAnimator.thumbnailLayer=winAnimator.mAnimLayer;
      }
    }
  }
  if (unForceHiding != null) {
    boolean startKeyguardExit=true;
    for (int i=unForceHiding.size() - 1; i >= 0; i--) {
      Animation a=mPolicy.createForceHideEnterAnimation(wallpaperInUnForceHiding);
      if (a != null) {
        final WindowStateAnimator winAnimator=unForceHiding.get(i);
        winAnimator.setAnimation(a);
        winAnimator.mAnimationIsEntrance=true;
        if (startKeyguardExit && mKeyguardGoingAway) {
          mPolicy.startKeyguardExitAnimation(mCurrentTime + a.getStartOffset(),a.getDuration());
          mKeyguardGoingAway=false;
          startKeyguardExit=false;
        }
      }
    }
  }
}",0.9984108639121642
199080,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(""String_Node_Str"").append(bssid).append(""String_Node_Str"");
  if (venueName != null)   sb.append(""String_Node_Str"").append(""String_Node_Str"").append(venueName.replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
  if (networkAuthType != null) {
    sb.append(""String_Node_Str"");
    for (    NetworkAuthType auth : networkAuthType)     sb.append(""String_Node_Str"").append(auth.toString()).append(""String_Node_Str"");
  }
  if (roamingConsortium != null) {
    sb.append(""String_Node_Str"");
    for (    String oi : roamingConsortium)     sb.append(""String_Node_Str"").append(oi).append(""String_Node_Str"");
  }
  if (ipAddrTypeAvailability != null) {
    sb.append(""String_Node_Str"").append(""String_Node_Str"").append(ipAddrTypeAvailability.toString()).append(""String_Node_Str"");
  }
  if (naiRealm != null) {
    sb.append(""String_Node_Str"");
    for (    NaiRealm realm : naiRealm)     sb.append(""String_Node_Str"").append(realm.toString()).append(""String_Node_Str"");
  }
  if (cellularNetwork != null) {
    sb.append(""String_Node_Str"");
    for (    CellularNetwork plmn : cellularNetwork)     sb.append(""String_Node_Str"").append(plmn.toString()).append(""String_Node_Str"");
  }
  if (domainName != null) {
    sb.append(""String_Node_Str"");
    for (    String fqdn : domainName)     sb.append(""String_Node_Str"").append(fqdn).append(""String_Node_Str"");
  }
  if (operatorFriendlyName != null)   sb.append(""String_Node_Str"").append(""String_Node_Str"").append(operatorFriendlyName).append(""String_Node_Str"");
  if (wanMetrics != null)   sb.append(""String_Node_Str"").append(""String_Node_Str"").append(wanMetrics.toString()).append(""String_Node_Str"");
  if (connectionCapability != null) {
    sb.append(""String_Node_Str"");
    for (    IpProtoPort ip : connectionCapability)     sb.append(""String_Node_Str"").append(ip.toString()).append(""String_Node_Str"");
  }
  if (osuProviderList != null) {
    sb.append(""String_Node_Str"");
    for (    WifiPasspointOsuProvider osu : osuProviderList)     sb.append(""String_Node_Str"").append(osu.toString()).append(""String_Node_Str"");
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(""String_Node_Str"").append(bssid).append(""String_Node_Str"");
  if (venueName != null)   sb.append(""String_Node_Str"").append(""String_Node_Str"").append(venueName.replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
  if (networkAuthTypeList != null) {
    sb.append(""String_Node_Str"");
    for (    NetworkAuthType auth : networkAuthTypeList)     sb.append(""String_Node_Str"").append(auth.toString()).append(""String_Node_Str"");
  }
  if (roamingConsortiumList != null) {
    sb.append(""String_Node_Str"");
    for (    String oi : roamingConsortiumList)     sb.append(""String_Node_Str"").append(oi).append(""String_Node_Str"");
  }
  if (ipAddrTypeAvailability != null) {
    sb.append(""String_Node_Str"").append(""String_Node_Str"").append(ipAddrTypeAvailability.toString()).append(""String_Node_Str"");
  }
  if (naiRealmList != null) {
    sb.append(""String_Node_Str"");
    for (    NaiRealm realm : naiRealmList)     sb.append(""String_Node_Str"").append(realm.toString()).append(""String_Node_Str"");
  }
  if (cellularNetworkList != null) {
    sb.append(""String_Node_Str"");
    for (    CellularNetwork plmn : cellularNetworkList)     sb.append(""String_Node_Str"").append(plmn.toString()).append(""String_Node_Str"");
  }
  if (domainNameList != null) {
    sb.append(""String_Node_Str"");
    for (    String fqdn : domainNameList)     sb.append(""String_Node_Str"").append(fqdn).append(""String_Node_Str"");
  }
  if (operatorFriendlyName != null)   sb.append(""String_Node_Str"").append(""String_Node_Str"").append(operatorFriendlyName).append(""String_Node_Str"");
  if (wanMetrics != null)   sb.append(""String_Node_Str"").append(""String_Node_Str"").append(wanMetrics.toString()).append(""String_Node_Str"");
  if (connectionCapabilityList != null) {
    sb.append(""String_Node_Str"");
    for (    IpProtoPort ip : connectionCapabilityList)     sb.append(""String_Node_Str"").append(ip.toString()).append(""String_Node_Str"");
  }
  if (osuProviderList != null) {
    sb.append(""String_Node_Str"");
    for (    WifiPasspointOsuProvider osu : osuProviderList)     sb.append(""String_Node_Str"").append(osu.toString()).append(""String_Node_Str"");
  }
  return sb.toString();
}",0.9893333333333332
199081,"@Override public WifiPasspointInfo createFromParcel(Parcel in){
  WifiPasspointInfo p=new WifiPasspointInfo();
  int n;
  p.bssid=in.readString();
  p.venueName=in.readString();
  n=in.readInt();
  if (n > 0) {
    p.networkAuthType=new ArrayList<NetworkAuthType>();
    for (int i=0; i < n; i++) {
      NetworkAuthType auth=new NetworkAuthType();
      auth.type=in.readInt();
      auth.redirectUrl=in.readString();
      p.networkAuthType.add(auth);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.roamingConsortium=new ArrayList<String>();
    for (int i=0; i < n; i++)     p.roamingConsortium.add(in.readString());
  }
  n=in.readInt();
  if (n != IpAddressType.NULL_VALUE) {
    p.ipAddrTypeAvailability=new IpAddressType();
    p.ipAddrTypeAvailability.availability=n;
  }
  n=in.readInt();
  if (n > 0) {
    p.naiRealm=new ArrayList<NaiRealm>();
    for (int i=0; i < n; i++) {
      NaiRealm realm=new NaiRealm();
      realm.encoding=in.readInt();
      realm.realm=in.readString();
      p.naiRealm.add(realm);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.cellularNetwork=new ArrayList<CellularNetwork>();
    for (int i=0; i < n; i++) {
      CellularNetwork plmn=new CellularNetwork();
      plmn.mcc=in.readString();
      plmn.mnc=in.readString();
      p.cellularNetwork.add(plmn);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.domainName=new ArrayList<String>();
    for (int i=0; i < n; i++)     p.domainName.add(in.readString());
  }
  p.operatorFriendlyName=in.readString();
  n=in.readInt();
  if (n > 0) {
    p.wanMetrics=new WanMetrics();
    p.wanMetrics.wanInfo=in.readInt();
    p.wanMetrics.downlinkSpeed=in.readLong();
    p.wanMetrics.uplinkSpeed=in.readLong();
    p.wanMetrics.downlinkLoad=in.readInt();
    p.wanMetrics.uplinkLoad=in.readInt();
    p.wanMetrics.lmd=in.readInt();
  }
  n=in.readInt();
  if (n > 0) {
    p.connectionCapability=new ArrayList<IpProtoPort>();
    for (int i=0; i < n; i++) {
      IpProtoPort ip=new IpProtoPort();
      ip.proto=in.readInt();
      ip.port=in.readInt();
      ip.status=in.readInt();
      p.connectionCapability.add(ip);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.osuProviderList=new ArrayList<WifiPasspointOsuProvider>();
    for (int i=0; i < n; i++) {
      WifiPasspointOsuProvider osu=WifiPasspointOsuProvider.CREATOR.createFromParcel(in);
      p.osuProviderList.add(osu);
    }
  }
  return p;
}","@Override public WifiPasspointInfo createFromParcel(Parcel in){
  WifiPasspointInfo p=new WifiPasspointInfo();
  int n;
  p.bssid=in.readString();
  p.venueName=in.readString();
  n=in.readInt();
  if (n > 0) {
    p.networkAuthTypeList=new ArrayList<NetworkAuthType>();
    for (int i=0; i < n; i++) {
      NetworkAuthType auth=new NetworkAuthType();
      auth.type=in.readInt();
      auth.redirectUrl=in.readString();
      p.networkAuthTypeList.add(auth);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.roamingConsortiumList=new ArrayList<String>();
    for (int i=0; i < n; i++)     p.roamingConsortiumList.add(in.readString());
  }
  n=in.readInt();
  if (n != IpAddressType.NULL_VALUE) {
    p.ipAddrTypeAvailability=new IpAddressType();
    p.ipAddrTypeAvailability.availability=n;
  }
  n=in.readInt();
  if (n > 0) {
    p.naiRealmList=new ArrayList<NaiRealm>();
    for (int i=0; i < n; i++) {
      NaiRealm realm=new NaiRealm();
      realm.encoding=in.readInt();
      realm.realm=in.readString();
      p.naiRealmList.add(realm);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.cellularNetworkList=new ArrayList<CellularNetwork>();
    for (int i=0; i < n; i++) {
      CellularNetwork plmn=new CellularNetwork();
      plmn.mcc=in.readString();
      plmn.mnc=in.readString();
      p.cellularNetworkList.add(plmn);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.domainNameList=new ArrayList<String>();
    for (int i=0; i < n; i++)     p.domainNameList.add(in.readString());
  }
  p.operatorFriendlyName=in.readString();
  n=in.readInt();
  if (n > 0) {
    p.wanMetrics=new WanMetrics();
    p.wanMetrics.wanInfo=in.readInt();
    p.wanMetrics.downlinkSpeed=in.readLong();
    p.wanMetrics.uplinkSpeed=in.readLong();
    p.wanMetrics.downlinkLoad=in.readInt();
    p.wanMetrics.uplinkLoad=in.readInt();
    p.wanMetrics.lmd=in.readInt();
  }
  n=in.readInt();
  if (n > 0) {
    p.connectionCapabilityList=new ArrayList<IpProtoPort>();
    for (int i=0; i < n; i++) {
      IpProtoPort ip=new IpProtoPort();
      ip.proto=in.readInt();
      ip.port=in.readInt();
      ip.status=in.readInt();
      p.connectionCapabilityList.add(ip);
    }
  }
  n=in.readInt();
  if (n > 0) {
    p.osuProviderList=new ArrayList<WifiPasspointOsuProvider>();
    for (int i=0; i < n; i++) {
      WifiPasspointOsuProvider osu=WifiPasspointOsuProvider.CREATOR.createFromParcel(in);
      p.osuProviderList.add(osu);
    }
  }
  return p;
}",0.9901030927835052
199082,"/** 
 * Implement the Parcelable interface   {@hide} 
 */
@Override public void writeToParcel(Parcel out,int flags){
  out.writeString(bssid);
  out.writeString(venueName);
  if (networkAuthType == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(networkAuthType.size());
    for (    NetworkAuthType auth : networkAuthType) {
      out.writeInt(auth.type);
      out.writeString(auth.redirectUrl);
    }
  }
  if (roamingConsortium == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(roamingConsortium.size());
    for (    String oi : roamingConsortium)     out.writeString(oi);
  }
  if (ipAddrTypeAvailability == null) {
    out.writeInt(IpAddressType.NULL_VALUE);
  }
 else {
    out.writeInt(ipAddrTypeAvailability.availability);
  }
  if (naiRealm == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(naiRealm.size());
    for (    NaiRealm realm : naiRealm) {
      out.writeInt(realm.encoding);
      out.writeString(realm.realm);
    }
  }
  if (cellularNetwork == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(cellularNetwork.size());
    for (    CellularNetwork plmn : cellularNetwork) {
      out.writeString(plmn.mcc);
      out.writeString(plmn.mnc);
    }
  }
  if (domainName == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(domainName.size());
    for (    String fqdn : domainName)     out.writeString(fqdn);
  }
  out.writeString(operatorFriendlyName);
  if (wanMetrics == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(1);
    out.writeInt(wanMetrics.wanInfo);
    out.writeLong(wanMetrics.downlinkSpeed);
    out.writeLong(wanMetrics.uplinkSpeed);
    out.writeInt(wanMetrics.downlinkLoad);
    out.writeInt(wanMetrics.uplinkLoad);
    out.writeInt(wanMetrics.lmd);
  }
  if (connectionCapability == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(connectionCapability.size());
    for (    IpProtoPort ip : connectionCapability) {
      out.writeInt(ip.proto);
      out.writeInt(ip.port);
      out.writeInt(ip.status);
    }
  }
  if (osuProviderList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(osuProviderList.size());
    for (    WifiPasspointOsuProvider osu : osuProviderList)     osu.writeToParcel(out,flags);
  }
}","/** 
 * Implement the Parcelable interface   {@hide} 
 */
@Override public void writeToParcel(Parcel out,int flags){
  out.writeString(bssid);
  out.writeString(venueName);
  if (networkAuthTypeList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(networkAuthTypeList.size());
    for (    NetworkAuthType auth : networkAuthTypeList) {
      out.writeInt(auth.type);
      out.writeString(auth.redirectUrl);
    }
  }
  if (roamingConsortiumList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(roamingConsortiumList.size());
    for (    String oi : roamingConsortiumList)     out.writeString(oi);
  }
  if (ipAddrTypeAvailability == null) {
    out.writeInt(IpAddressType.NULL_VALUE);
  }
 else {
    out.writeInt(ipAddrTypeAvailability.availability);
  }
  if (naiRealmList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(naiRealmList.size());
    for (    NaiRealm realm : naiRealmList) {
      out.writeInt(realm.encoding);
      out.writeString(realm.realm);
    }
  }
  if (cellularNetworkList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(cellularNetworkList.size());
    for (    CellularNetwork plmn : cellularNetworkList) {
      out.writeString(plmn.mcc);
      out.writeString(plmn.mnc);
    }
  }
  if (domainNameList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(domainNameList.size());
    for (    String fqdn : domainNameList)     out.writeString(fqdn);
  }
  out.writeString(operatorFriendlyName);
  if (wanMetrics == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(1);
    out.writeInt(wanMetrics.wanInfo);
    out.writeLong(wanMetrics.downlinkSpeed);
    out.writeLong(wanMetrics.uplinkSpeed);
    out.writeInt(wanMetrics.downlinkLoad);
    out.writeInt(wanMetrics.uplinkLoad);
    out.writeInt(wanMetrics.lmd);
  }
  if (connectionCapabilityList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(connectionCapabilityList.size());
    for (    IpProtoPort ip : connectionCapabilityList) {
      out.writeInt(ip.proto);
      out.writeInt(ip.port);
      out.writeInt(ip.status);
    }
  }
  if (osuProviderList == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(osuProviderList.size());
    for (    WifiPasspointOsuProvider osu : osuProviderList)     osu.writeToParcel(out,flags);
  }
}",0.9841409691629956
199083,"@Override public void handleMessage(Message message){
  Object listener=null;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
    if (mChannelListener != null) {
      mChannelListener.onChannelDisconnected();
      mChannelListener=null;
    }
  break;
case REQUEST_ANQP_INFO_SUCCEEDED:
WifiPasspointInfo result=(WifiPasspointInfo)message.obj;
anqpRequestFinish(result);
listener=getListener(message.arg2,false);
if (listener != null) {
((ActionListener)listener).onSuccess();
}
break;
case REQUEST_ANQP_INFO_FAILED:
anqpRequestFinish((ScanResult)message.obj);
listener=getListener(message.arg2,false);
if (listener == null) getListener(message.arg2,true);
if (listener != null) {
((ActionListener)listener).onFailure(message.arg1);
}
break;
case START_OSU_SUCCEEDED:
listener=getListener(message.arg2,true);
if (listener != null) {
((OsuRemListener)listener).onSuccess();
}
break;
case START_OSU_FAILED:
listener=getListener(message.arg2,true);
if (listener != null) {
((OsuRemListener)listener).onFailure(message.arg1);
}
break;
case START_OSU_BROWSER:
listener=getListener(message.arg2,true);
if (listener != null) {
ParcelableString str=(ParcelableString)message.obj;
if (str.string == null) ((OsuRemListener)listener).onBrowserDismiss();
 else ((OsuRemListener)listener).onBrowserLaunch(str.string);
}
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
}","@Override public void handleMessage(Message message){
  Object listener=null;
switch (message.what) {
case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
    if (mChannelListener != null) {
      mChannelListener.onChannelDisconnected();
      mChannelListener=null;
    }
  break;
case REQUEST_ANQP_INFO_SUCCEEDED:
WifiPasspointInfo result=(WifiPasspointInfo)message.obj;
anqpRequestFinish(result);
listener=getListener(message.arg2,false);
if (listener != null) {
((ActionListener)listener).onSuccess();
}
break;
case REQUEST_ANQP_INFO_FAILED:
anqpRequestFinish((ScanResult)message.obj);
listener=getListener(message.arg2,false);
if (listener == null) getListener(message.arg2,true);
if (listener != null) {
((ActionListener)listener).onFailure(message.arg1);
}
break;
case START_OSU_SUCCEEDED:
listener=getListener(message.arg2,true);
if (listener != null) {
((OsuRemListener)listener).onSuccess();
}
break;
case START_OSU_FAILED:
listener=getListener(message.arg2,true);
if (listener != null) {
((OsuRemListener)listener).onFailure(message.arg1);
}
break;
case START_OSU_BROWSER:
listener=getListener(message.arg2,true);
if (listener != null) {
ParcelableString str=(ParcelableString)message.obj;
if (str == null || str.string == null) ((OsuRemListener)listener).onBrowserDismiss();
 else ((OsuRemListener)listener).onBrowserLaunch(str.string);
}
break;
default :
Log.d(TAG,""String_Node_Str"" + message);
break;
}
}",0.9946524064171124
199084,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor() * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor() * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(true) * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(false) * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}",0.9960194604157452
199085,"private void setOverScrollAmountInternal(float amount,boolean onTop,boolean animate){
  amount=Math.max(0,amount);
  if (animate) {
    mStateAnimator.animateOverScrollToAmount(amount,onTop);
  }
 else {
    setOverScrolledPixels(amount / getRubberBandFactor(),onTop);
    mAmbientState.setOverScrollAmount(amount,onTop);
    if (onTop) {
      notifyOverscrollTopListener(amount);
    }
    requestChildrenUpdate();
  }
}","private void setOverScrollAmountInternal(float amount,boolean onTop,boolean animate){
  amount=Math.max(0,amount);
  if (animate) {
    mStateAnimator.animateOverScrollToAmount(amount,onTop);
  }
 else {
    setOverScrolledPixels(amount / getRubberBandFactor(onTop),onTop);
    mAmbientState.setOverScrollAmount(amount,onTop);
    if (onTop) {
      notifyOverscrollTopListener(amount);
    }
    requestChildrenUpdate();
  }
}",0.994110718492344
199086,"private float getRubberBandFactor(){
  if (mExpandedInThisMotion) {
    return RUBBER_BAND_FACTOR_AFTER_EXPAND;
  }
 else   if (mIsExpansionChanging) {
    return RUBBER_BAND_FACTOR_ON_PANEL_EXPAND;
  }
 else   if (mScrolledToTopOnFirstDown) {
    return 1.0f;
  }
  return RUBBER_BAND_FACTOR_NORMAL;
}","private float getRubberBandFactor(boolean onTop){
  if (!onTop) {
    return RUBBER_BAND_FACTOR_NORMAL;
  }
  if (mExpandedInThisMotion) {
    return RUBBER_BAND_FACTOR_AFTER_EXPAND;
  }
 else   if (mIsExpansionChanging) {
    return RUBBER_BAND_FACTOR_ON_PANEL_EXPAND;
  }
 else   if (mScrolledToTopOnFirstDown) {
    return 1.0f;
  }
  return RUBBER_BAND_FACTOR_NORMAL;
}",0.8888888888888888
199087,"public int getCallingUidLocked(){
  return mCallingUid;
}","public Integer getCallingUidLocked(){
  return mCallingUid;
}",0.9491525423728814
199088,"/** 
 * Release the specified hardware.
 */
public void releaseHardware(int deviceId,ITvInputHardware hardware,int callingUid,int resolvedUserId){
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return;
    }
    if (connection.getHardwareLocked() != hardware || connection.getCallingUidLocked() != callingUid || connection.getResolvedUserIdLocked() != resolvedUserId) {
      return;
    }
    connection.resetLocked(null,null,null,null);
  }
}","/** 
 * Release the specified hardware.
 */
public void releaseHardware(int deviceId,ITvInputHardware hardware,int callingUid,int resolvedUserId){
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return;
    }
    if (connection.getHardwareLocked() != hardware || checkUidChangedLocked(connection,callingUid,resolvedUserId)) {
      return;
    }
    connection.resetLocked(null,null,null,null);
  }
}",0.7488328664799253
199089,"public int getResolvedUserIdLocked(){
  return mResolvedUserId;
}","public Integer getResolvedUserIdLocked(){
  return mResolvedUserId;
}",0.9552238805970148
199090,"/** 
 * Create a TvInputHardware object with a specific deviceId. One service at a time can access the object, and if more than one process attempts to create hardware with the same deviceId, the latest service will get the object and all the other hardware are released. The release is notified via ITvInputHardwareCallback.onReleased().
 */
public ITvInputHardware acquireHardware(int deviceId,ITvInputHardwareCallback callback,int callingUid,int resolvedUserId){
  if (callback == null) {
    throw new NullPointerException();
  }
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return null;
    }
    if (connection.getCallingUidLocked() != callingUid || connection.getResolvedUserIdLocked() != resolvedUserId) {
      TvInputHardwareImpl hardware=new TvInputHardwareImpl(connection.getInfoLocked());
      try {
        callback.asBinder().linkToDeath(connection,0);
      }
 catch (      RemoteException e) {
        hardware.release();
        return null;
      }
      connection.resetLocked(hardware,callback,callingUid,resolvedUserId);
    }
    return connection.getHardwareLocked();
  }
}","/** 
 * Create a TvInputHardware object with a specific deviceId. One service at a time can access the object, and if more than one process attempts to create hardware with the same deviceId, the latest service will get the object and all the other hardware are released. The release is notified via ITvInputHardwareCallback.onReleased().
 */
public ITvInputHardware acquireHardware(int deviceId,ITvInputHardwareCallback callback,int callingUid,int resolvedUserId){
  if (callback == null) {
    throw new NullPointerException();
  }
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return null;
    }
    if (checkUidChangedLocked(connection,callingUid,resolvedUserId)) {
      TvInputHardwareImpl hardware=new TvInputHardwareImpl(connection.getInfoLocked());
      try {
        callback.asBinder().linkToDeath(connection,0);
      }
 catch (      RemoteException e) {
        hardware.release();
        return null;
      }
      connection.resetLocked(hardware,callback,callingUid,resolvedUserId);
    }
    return connection.getHardwareLocked();
  }
}",0.6512798992866136
199091,"public int getCallingUidLocked(){
  return mCallingUid;
}","public Integer getCallingUidLocked(){
  return mCallingUid;
}",0.9491525423728814
199092,"/** 
 * Release the specified hardware.
 */
public void releaseHardware(int deviceId,ITvInputHardware hardware,int callingUid,int resolvedUserId){
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return;
    }
    if (connection.getHardwareLocked() != hardware || connection.getCallingUidLocked() != callingUid || connection.getResolvedUserIdLocked() != resolvedUserId) {
      return;
    }
    connection.resetLocked(null,null,null,null);
  }
}","/** 
 * Release the specified hardware.
 */
public void releaseHardware(int deviceId,ITvInputHardware hardware,int callingUid,int resolvedUserId){
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return;
    }
    if (connection.getHardwareLocked() != hardware || checkUidChangedLocked(connection,callingUid,resolvedUserId)) {
      return;
    }
    connection.resetLocked(null,null,null,null);
  }
}",0.7488328664799253
199093,"public int getResolvedUserIdLocked(){
  return mResolvedUserId;
}","public Integer getResolvedUserIdLocked(){
  return mResolvedUserId;
}",0.9552238805970148
199094,"/** 
 * Create a TvInputHardware object with a specific deviceId. One service at a time can access the object, and if more than one process attempts to create hardware with the same deviceId, the latest service will get the object and all the other hardware are released. The release is notified via ITvInputHardwareCallback.onReleased().
 */
public ITvInputHardware acquireHardware(int deviceId,ITvInputHardwareCallback callback,int callingUid,int resolvedUserId){
  if (callback == null) {
    throw new NullPointerException();
  }
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return null;
    }
    if (connection.getCallingUidLocked() != callingUid || connection.getResolvedUserIdLocked() != resolvedUserId) {
      TvInputHardwareImpl hardware=new TvInputHardwareImpl(connection.getInfoLocked());
      try {
        callback.asBinder().linkToDeath(connection,0);
      }
 catch (      RemoteException e) {
        hardware.release();
        return null;
      }
      connection.resetLocked(hardware,callback,callingUid,resolvedUserId);
    }
    return connection.getHardwareLocked();
  }
}","/** 
 * Create a TvInputHardware object with a specific deviceId. One service at a time can access the object, and if more than one process attempts to create hardware with the same deviceId, the latest service will get the object and all the other hardware are released. The release is notified via ITvInputHardwareCallback.onReleased().
 */
public ITvInputHardware acquireHardware(int deviceId,ITvInputHardwareCallback callback,int callingUid,int resolvedUserId){
  if (callback == null) {
    throw new NullPointerException();
  }
synchronized (mLock) {
    Connection connection=mConnections.get(deviceId);
    if (connection == null) {
      Slog.e(TAG,""String_Node_Str"" + deviceId);
      return null;
    }
    if (checkUidChangedLocked(connection,callingUid,resolvedUserId)) {
      TvInputHardwareImpl hardware=new TvInputHardwareImpl(connection.getInfoLocked());
      try {
        callback.asBinder().linkToDeath(connection,0);
      }
 catch (      RemoteException e) {
        hardware.release();
        return null;
      }
      connection.resetLocked(hardware,callback,callingUid,resolvedUserId);
    }
    return connection.getHardwareLocked();
  }
}",0.6512798992866136
199095,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor() * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor() * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(true) * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(false) * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}",0.9960194604157452
199096,"private void setOverScrollAmountInternal(float amount,boolean onTop,boolean animate){
  amount=Math.max(0,amount);
  if (animate) {
    mStateAnimator.animateOverScrollToAmount(amount,onTop);
  }
 else {
    setOverScrolledPixels(amount / getRubberBandFactor(),onTop);
    mAmbientState.setOverScrollAmount(amount,onTop);
    if (onTop) {
      notifyOverscrollTopListener(amount);
    }
    requestChildrenUpdate();
  }
}","private void setOverScrollAmountInternal(float amount,boolean onTop,boolean animate){
  amount=Math.max(0,amount);
  if (animate) {
    mStateAnimator.animateOverScrollToAmount(amount,onTop);
  }
 else {
    setOverScrolledPixels(amount / getRubberBandFactor(onTop),onTop);
    mAmbientState.setOverScrollAmount(amount,onTop);
    if (onTop) {
      notifyOverscrollTopListener(amount);
    }
    requestChildrenUpdate();
  }
}",0.994110718492344
199097,"private float getRubberBandFactor(){
  if (mExpandedInThisMotion) {
    return RUBBER_BAND_FACTOR_AFTER_EXPAND;
  }
 else   if (mIsExpansionChanging) {
    return RUBBER_BAND_FACTOR_ON_PANEL_EXPAND;
  }
 else   if (mScrolledToTopOnFirstDown) {
    return 1.0f;
  }
  return RUBBER_BAND_FACTOR_NORMAL;
}","private float getRubberBandFactor(boolean onTop){
  if (!onTop) {
    return RUBBER_BAND_FACTOR_NORMAL;
  }
  if (mExpandedInThisMotion) {
    return RUBBER_BAND_FACTOR_AFTER_EXPAND;
  }
 else   if (mIsExpansionChanging) {
    return RUBBER_BAND_FACTOR_ON_PANEL_EXPAND;
  }
 else   if (mScrolledToTopOnFirstDown) {
    return 1.0f;
  }
  return RUBBER_BAND_FACTOR_NORMAL;
}",0.8888888888888888
199098,"private boolean onScrollTouch(MotionEvent ev){
  if (!isScrollingEnabled()) {
    return false;
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0 || !isInContentBounds(ev)) {
        return false;
      }
      boolean isBeingDragged=!mScroller.isFinished();
      setIsBeingDragged(isBeingDragged);
      if (!mScroller.isFinished()) {
        mScroller.forceFinished(true);
      }
      mLastMotionY=(int)ev.getY();
      mDownX=(int)ev.getX();
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
final int x=(int)ev.getX(activePointerIndex);
int deltaY=mLastMotionY - y;
final int xDiff=Math.abs(x - mDownX);
final int yDiff=Math.abs(deltaY);
if (!mIsBeingDragged && yDiff > mTouchSlop && yDiff > xDiff) {
setIsBeingDragged(true);
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
int range=getScrollRange();
if (mExpandedInThisMotion) {
range=Math.min(range,mMaxScrollAfterExpand);
}
float scrollAmount;
if (deltaY < 0) {
scrollAmount=overScrollDown(deltaY);
}
 else {
scrollAmount=overScrollUp(deltaY,range);
}
if (scrollAmount != 0.0f) {
overScrollBy(0,(int)scrollAmount,0,mOwnScrollY,0,range,0,getHeight() / 2,true);
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (shouldOverScrollFling(initialVelocity)) {
onOverScrollFling(true,initialVelocity);
}
 else {
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
float currentOverScrollTop=getCurrentOverScrollAmount(true);
if (currentOverScrollTop == 0.0f || initialVelocity > 0) {
fling(-initialVelocity);
}
 else {
onOverScrollFling(false,initialVelocity);
}
}
 else {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
}
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mDownX=(int)ev.getX(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
mDownX=(int)ev.getX(ev.findPointerIndex(mActivePointerId));
break;
}
return true;
}","private boolean onScrollTouch(MotionEvent ev){
  if (!isScrollingEnabled()) {
    return false;
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0 || !isInContentBounds(ev)) {
        return false;
      }
      boolean isBeingDragged=!mScroller.isFinished();
      setIsBeingDragged(isBeingDragged);
      if (!mScroller.isFinished()) {
        mScroller.forceFinished(true);
      }
      mLastMotionY=(int)ev.getY();
      mDownX=(int)ev.getX();
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
final int x=(int)ev.getX(activePointerIndex);
int deltaY=mLastMotionY - y;
final int xDiff=Math.abs(x - mDownX);
final int yDiff=Math.abs(deltaY);
if (!mIsBeingDragged && yDiff > mTouchSlop && yDiff > xDiff) {
setIsBeingDragged(true);
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
int range=getScrollRange();
if (mExpandedInThisMotion) {
range=Math.min(range,mMaxScrollAfterExpand);
}
float scrollAmount;
if (deltaY < 0) {
scrollAmount=overScrollDown(deltaY);
}
 else {
scrollAmount=overScrollUp(deltaY,range);
}
if (scrollAmount != 0.0f) {
overScrollBy(0,(int)scrollAmount,0,mOwnScrollY,0,range,0,getHeight() / 2,true);
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (shouldOverScrollFling(initialVelocity)) {
onOverScrollFling(true,initialVelocity);
}
 else {
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
float currentOverScrollTop=getCurrentOverScrollAmount(true);
if (currentOverScrollTop == 0.0f || initialVelocity > 0) {
fling(-initialVelocity);
}
 else {
onOverScrollFling(false,initialVelocity);
}
}
 else {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
}
}
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mDownX=(int)ev.getX(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
mDownX=(int)ev.getX(ev.findPointerIndex(mActivePointerId));
break;
}
return true;
}",0.999347471451876
199099,"private boolean onScrollTouch(MotionEvent ev){
  if (!isScrollingEnabled()) {
    return false;
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0 || !isInContentBounds(ev)) {
        return false;
      }
      boolean isBeingDragged=!mScroller.isFinished();
      setIsBeingDragged(isBeingDragged);
      if (!mScroller.isFinished()) {
        mScroller.forceFinished(true);
      }
      mLastMotionY=(int)ev.getY();
      mDownX=(int)ev.getX();
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
final int x=(int)ev.getX(activePointerIndex);
int deltaY=mLastMotionY - y;
final int xDiff=Math.abs(x - mDownX);
final int yDiff=Math.abs(deltaY);
if (!mIsBeingDragged && yDiff > mTouchSlop && yDiff > xDiff) {
setIsBeingDragged(true);
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
int range=getScrollRange();
if (mExpandedInThisMotion) {
range=Math.min(range,mMaxScrollAfterExpand);
}
float scrollAmount;
if (deltaY < 0) {
scrollAmount=overScrollDown(deltaY);
}
 else {
scrollAmount=overScrollUp(deltaY,range);
}
if (scrollAmount != 0.0f) {
overScrollBy(0,(int)scrollAmount,0,mOwnScrollY,0,range,0,getHeight() / 2,true);
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (shouldOverScrollFling(initialVelocity)) {
onOverScrollFling(true,initialVelocity);
}
 else {
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
float currentOverScrollTop=getCurrentOverScrollAmount(true);
if (currentOverScrollTop == 0.0f || initialVelocity > 0) {
fling(-initialVelocity);
}
 else {
onOverScrollFling(false,initialVelocity);
}
}
 else {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
}
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mDownX=(int)ev.getX(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
mDownX=(int)ev.getX(ev.findPointerIndex(mActivePointerId));
break;
}
return true;
}","private boolean onScrollTouch(MotionEvent ev){
  if (!isScrollingEnabled()) {
    return false;
  }
  initVelocityTrackerIfNotExists();
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0 || !isInContentBounds(ev)) {
        return false;
      }
      boolean isBeingDragged=!mScroller.isFinished();
      setIsBeingDragged(isBeingDragged);
      if (!mScroller.isFinished()) {
        mScroller.forceFinished(true);
      }
      mLastMotionY=(int)ev.getY();
      mDownX=(int)ev.getX();
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
final int x=(int)ev.getX(activePointerIndex);
int deltaY=mLastMotionY - y;
final int xDiff=Math.abs(x - mDownX);
final int yDiff=Math.abs(deltaY);
if (!mIsBeingDragged && yDiff > mTouchSlop && yDiff > xDiff) {
setIsBeingDragged(true);
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
int range=getScrollRange();
if (mExpandedInThisMotion) {
range=Math.min(range,mMaxScrollAfterExpand);
}
float scrollAmount;
if (deltaY < 0) {
scrollAmount=overScrollDown(deltaY);
}
 else {
scrollAmount=overScrollUp(deltaY,range);
}
if (scrollAmount != 0.0f) {
overScrollBy(0,(int)scrollAmount,0,mOwnScrollY,0,range,0,getHeight() / 2,true);
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (shouldOverScrollFling(initialVelocity)) {
onOverScrollFling(true,initialVelocity);
}
 else {
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
float currentOverScrollTop=getCurrentOverScrollAmount(true);
if (currentOverScrollTop == 0.0f || initialVelocity > 0) {
fling(-initialVelocity);
}
 else {
onOverScrollFling(false,initialVelocity);
}
}
 else {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
}
}
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mOwnScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mDownX=(int)ev.getX(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
mDownX=(int)ev.getX(ev.findPointerIndex(mActivePointerId));
break;
}
return true;
}",0.999347471451876
199100,"@Override protected boolean isScrolledToBottom(){
  if (!isInSettings()) {
    return mNotificationStackScroller.isScrolledToBottom();
  }
  return super.isScrolledToBottom();
}","@Override protected boolean isScrolledToBottom(){
  if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
    return true;
  }
  if (!isInSettings()) {
    return mNotificationStackScroller.isScrolledToBottom();
  }
  return super.isScrolledToBottom();
}",0.8119266055045872
199101,"@Override protected boolean isScrolledToBottom(){
  if (!isInSettings()) {
    return mNotificationStackScroller.isScrolledToBottom();
  }
  return super.isScrolledToBottom();
}","@Override protected boolean isScrolledToBottom(){
  if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
    return true;
  }
  if (!isInSettings()) {
    return mNotificationStackScroller.isScrolledToBottom();
  }
  return super.isScrolledToBottom();
}",0.8119266055045872
199102,"@Override public void onDisplayAdded(int displayId){
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_ADDED,displayId,0));
}","@Override public void onDisplayAdded(int displayId){
  Slog.v(TAG,""String_Node_Str"" + displayId);
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_ADDED,displayId,0));
}",0.8580441640378549
199103,"@Override public void release(){
synchronized (mService) {
    if (mContainerState == CONTAINER_STATE_FINISHING) {
      return;
    }
    mContainerState=CONTAINER_STATE_FINISHING;
    final Message msg=mHandler.obtainMessage(CONTAINER_TASK_LIST_EMPTY_TIMEOUT,this);
    mHandler.sendMessageDelayed(msg,1000);
    mStack.finishAllActivitiesLocked();
  }
}","@Override public void release(){
synchronized (mService) {
    if (mContainerState == CONTAINER_STATE_FINISHING) {
      return;
    }
    mContainerState=CONTAINER_STATE_FINISHING;
    final Message msg=mHandler.obtainMessage(CONTAINER_TASK_LIST_EMPTY_TIMEOUT,this);
    mHandler.sendMessageDelayed(msg,1000);
    long origId=Binder.clearCallingIdentity();
    try {
      mStack.finishAllActivitiesLocked();
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.8476190476190476
199104,"@Override public void onDisplayRemoved(int displayId){
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_REMOVED,displayId,0));
}","@Override public void onDisplayRemoved(int displayId){
  Slog.v(TAG,""String_Node_Str"" + displayId);
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_REMOVED,displayId,0));
}",0.8615384615384616
199105,"@Override public void onDisplayChanged(int displayId){
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_CHANGED,displayId,0));
}","@Override public void onDisplayChanged(int displayId){
  Slog.v(TAG,""String_Node_Str"" + displayId);
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_CHANGED,displayId,0));
}",0.8615384615384616
199106,"public DisplayContent getDisplayContent(){
  return mAppToken == null ? mDisplayContent : getStack().getDisplayContent();
}","public DisplayContent getDisplayContent(){
  if (mAppToken == null) {
    return mDisplayContent;
  }
  final TaskStack stack=getStack();
  return stack == null ? mDisplayContent : stack.getDisplayContent();
}",0.6385542168674698
199107,"@Override public void onDisplayAdded(int displayId){
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_ADDED,displayId,0));
}","@Override public void onDisplayAdded(int displayId){
  Slog.v(TAG,""String_Node_Str"" + displayId);
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_ADDED,displayId,0));
}",0.8580441640378549
199108,"@Override public void release(){
synchronized (mService) {
    if (mContainerState == CONTAINER_STATE_FINISHING) {
      return;
    }
    mContainerState=CONTAINER_STATE_FINISHING;
    final Message msg=mHandler.obtainMessage(CONTAINER_TASK_LIST_EMPTY_TIMEOUT,this);
    mHandler.sendMessageDelayed(msg,1000);
    mStack.finishAllActivitiesLocked();
  }
}","@Override public void release(){
synchronized (mService) {
    if (mContainerState == CONTAINER_STATE_FINISHING) {
      return;
    }
    mContainerState=CONTAINER_STATE_FINISHING;
    final Message msg=mHandler.obtainMessage(CONTAINER_TASK_LIST_EMPTY_TIMEOUT,this);
    mHandler.sendMessageDelayed(msg,1000);
    long origId=Binder.clearCallingIdentity();
    try {
      mStack.finishAllActivitiesLocked();
    }
  finally {
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.8476190476190476
199109,"@Override public void onDisplayRemoved(int displayId){
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_REMOVED,displayId,0));
}","@Override public void onDisplayRemoved(int displayId){
  Slog.v(TAG,""String_Node_Str"" + displayId);
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_REMOVED,displayId,0));
}",0.8615384615384616
199110,"@Override public void onDisplayChanged(int displayId){
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_CHANGED,displayId,0));
}","@Override public void onDisplayChanged(int displayId){
  Slog.v(TAG,""String_Node_Str"" + displayId);
  mHandler.sendMessage(mHandler.obtainMessage(HANDLE_DISPLAY_CHANGED,displayId,0));
}",0.8615384615384616
199111,"public DisplayContent getDisplayContent(){
  return mAppToken == null ? mDisplayContent : getStack().getDisplayContent();
}","public DisplayContent getDisplayContent(){
  if (mAppToken == null) {
    return mDisplayContent;
  }
  final TaskStack stack=getStack();
  return stack == null ? mDisplayContent : stack.getDisplayContent();
}",0.6385542168674698
199112,"/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound && mBootCompleted) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.9902067464635472
199113,"/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestination()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}","/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestinationLinkAddress()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}",0.9890981169474728
199114,"/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound && mBootCompleted) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.9902067464635472
199115,"/** 
 * Returns a DisplayList. If the incoming displayList is null, one will be created. Otherwise, the same display list will be returned (after having been rendered into along the way, depending on the invalidation state of the view).
 * @param renderNode The previous version of this displayList, could be null.
 * @param isLayer Whether the requester of the display list is a layer. If so,the view will avoid creating a layer inside the resulting display list.
 * @return A new or reused DisplayList object.
 */
private void updateDisplayListIfDirty(@NonNull RenderNode renderNode,boolean isLayer){
  if (renderNode == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!canHaveDisplayList()) {
    return;
  }
  renderNode.setScrollPosition(mScrollX,mScrollY);
  if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.isValid() || (!isLayer && mRecreateDisplayList)) {
    if (renderNode.isValid() && !isLayer && !mRecreateDisplayList) {
      mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
      mPrivateFlags&=~PFLAG_DIRTY_MASK;
      dispatchGetDisplayList();
      return;
    }
    if (!isLayer) {
      mRecreateDisplayList=true;
    }
    boolean caching=false;
    int width=mRight - mLeft;
    int height=mBottom - mTop;
    int layerType=getLayerType();
    final HardwareCanvas canvas=renderNode.start(width,height);
    try {
      if (!isLayer && layerType != LAYER_TYPE_NONE) {
        if (layerType == LAYER_TYPE_HARDWARE) {
          final HardwareLayer layer=getHardwareLayer();
          if (layer != null && layer.isValid()) {
            canvas.drawHardwareLayer(layer,0,0,mLayerPaint);
          }
 else {
            canvas.saveLayer(0,0,mRight - mLeft,mBottom - mTop,mLayerPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
          }
          caching=true;
        }
 else {
          buildDrawingCache(true);
          Bitmap cache=getDrawingCache(true);
          if (cache != null) {
            canvas.drawBitmap(cache,0,0,mLayerPaint);
            caching=true;
          }
        }
      }
 else {
        computeScroll();
        canvas.translate(-mScrollX,-mScrollY);
        if (!isLayer) {
          mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
          mPrivateFlags&=~PFLAG_DIRTY_MASK;
        }
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
          dispatchDraw(canvas);
          if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
          }
        }
 else {
          draw(canvas);
        }
      }
    }
  finally {
      renderNode.end(canvas);
      renderNode.setCaching(caching);
      if (isLayer) {
        renderNode.setLeftTopRightBottom(0,0,width,height);
      }
 else {
        setDisplayListProperties(renderNode);
      }
    }
  }
 else   if (!isLayer) {
    mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags&=~PFLAG_DIRTY_MASK;
  }
}","/** 
 * Returns a DisplayList. If the incoming displayList is null, one will be created. Otherwise, the same display list will be returned (after having been rendered into along the way, depending on the invalidation state of the view).
 * @param renderNode The previous version of this displayList, could be null.
 * @param isLayer Whether the requester of the display list is a layer. If so,the view will avoid creating a layer inside the resulting display list.
 * @return A new or reused DisplayList object.
 */
private void updateDisplayListIfDirty(@NonNull RenderNode renderNode,boolean isLayer){
  if (renderNode == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!canHaveDisplayList()) {
    return;
  }
  if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.isValid() || (!isLayer && mRecreateDisplayList)) {
    if (renderNode.isValid() && !isLayer && !mRecreateDisplayList) {
      mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
      mPrivateFlags&=~PFLAG_DIRTY_MASK;
      dispatchGetDisplayList();
      return;
    }
    if (!isLayer) {
      mRecreateDisplayList=true;
    }
    boolean caching=false;
    int width=mRight - mLeft;
    int height=mBottom - mTop;
    int layerType=getLayerType();
    final HardwareCanvas canvas=renderNode.start(width,height);
    try {
      if (!isLayer && layerType != LAYER_TYPE_NONE) {
        if (layerType == LAYER_TYPE_HARDWARE) {
          final HardwareLayer layer=getHardwareLayer();
          if (layer != null && layer.isValid()) {
            canvas.drawHardwareLayer(layer,0,0,mLayerPaint);
          }
 else {
            canvas.saveLayer(0,0,mRight - mLeft,mBottom - mTop,mLayerPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
          }
          caching=true;
        }
 else {
          buildDrawingCache(true);
          Bitmap cache=getDrawingCache(true);
          if (cache != null) {
            canvas.drawBitmap(cache,0,0,mLayerPaint);
            caching=true;
          }
        }
      }
 else {
        computeScroll();
        canvas.translate(-mScrollX,-mScrollY);
        if (!isLayer) {
          mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
          mPrivateFlags&=~PFLAG_DIRTY_MASK;
        }
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
          dispatchDraw(canvas);
          if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
          }
        }
 else {
          draw(canvas);
        }
      }
    }
  finally {
      renderNode.end(canvas);
      renderNode.setCaching(caching);
      if (isLayer) {
        renderNode.setLeftTopRightBottom(0,0,width,height);
      }
 else {
        setDisplayListProperties(renderNode);
      }
    }
  }
 else   if (!isLayer) {
    mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags&=~PFLAG_DIRTY_MASK;
  }
}",0.991363251481795
199116,"@VisibleForTesting public void onReceiveInternal(Intent intent){
  final String action=intent.getAction();
  if (Intent.ACTION_BATTERY_LOW.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=false;
  }
 else   if (Intent.ACTION_BATTERY_OKAY.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=true;
    maybeReportNewChargingState();
  }
 else   if (Intent.ACTION_POWER_CONNECTED.equals(action)) {
    mAlarm.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + STABLE_CHARGING_THRESHOLD_MILLIS,mStableChargingTriggerIntent);
    mCharging=true;
  }
 else   if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
    mAlarm.cancel(mStableChargingTriggerIntent);
    mCharging=false;
    maybeReportNewChargingState();
  }
 else   if (ACTION_CHARGING_STABLE.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    if (mCharging) {
      maybeReportNewChargingState();
    }
  }
}","@VisibleForTesting public void onReceiveInternal(Intent intent){
  final String action=intent.getAction();
  if (Intent.ACTION_BATTERY_LOW.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=false;
  }
 else   if (Intent.ACTION_BATTERY_OKAY.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=true;
    maybeReportNewChargingState();
  }
 else   if (Intent.ACTION_POWER_CONNECTED.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + STABLE_CHARGING_THRESHOLD_MILLIS);
    }
    mAlarm.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + STABLE_CHARGING_THRESHOLD_MILLIS,mStableChargingTriggerIntent);
    mCharging=true;
  }
 else   if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"");
    }
    mAlarm.cancel(mStableChargingTriggerIntent);
    mCharging=false;
    maybeReportNewChargingState();
  }
 else   if (ACTION_CHARGING_STABLE.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime() + ""String_Node_Str""+ mCharging);
    }
    if (mCharging) {
      maybeReportNewChargingState();
    }
  }
}",0.8614107883817428
199117,"public ChargingTracker(){
  mAlarm=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent intent=new Intent(ACTION_CHARGING_STABLE).setComponent(new ComponentName(mContext,this.getClass()));
  mStableChargingTriggerIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
}","public ChargingTracker(){
  mAlarm=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent intent=new Intent(ACTION_CHARGING_STABLE);
  mStableChargingTriggerIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
}",0.8888888888888888
199118,"private void maybeReportNewChargingState(){
  final boolean stablePower=mChargeTracker.isOnStablePower();
  boolean reportChange=false;
synchronized (mTrackedTasks) {
    for (    JobStatus ts : mTrackedTasks) {
      boolean previous=ts.chargingConstraintSatisfied.getAndSet(stablePower);
      if (previous != stablePower) {
        reportChange=true;
      }
    }
  }
  if (reportChange) {
    mStateChangedListener.onControllerStateChanged();
  }
}","private void maybeReportNewChargingState(){
  final boolean stablePower=mChargeTracker.isOnStablePower();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + stablePower);
  }
  boolean reportChange=false;
synchronized (mTrackedTasks) {
    for (    JobStatus ts : mTrackedTasks) {
      boolean previous=ts.chargingConstraintSatisfied.getAndSet(stablePower);
      if (previous != stablePower) {
        reportChange=true;
      }
    }
  }
  if (reportChange) {
    mStateChangedListener.onControllerStateChanged();
  }
}",0.9301848049281314
199119,"public void startTracking(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_BATTERY_LOW);
  filter.addAction(Intent.ACTION_BATTERY_OKAY);
  filter.addAction(Intent.ACTION_POWER_CONNECTED);
  filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  mContext.registerReceiver(this,filter);
  BatteryService batteryService=(BatteryService)ServiceManager.getService(""String_Node_Str"");
  if (batteryService != null) {
    mBatteryHealthy=!batteryService.getBatteryLevelLow();
    mCharging=batteryService.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);
  }
 else {
  }
}","public void startTracking(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_BATTERY_LOW);
  filter.addAction(Intent.ACTION_BATTERY_OKAY);
  filter.addAction(Intent.ACTION_POWER_CONNECTED);
  filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  filter.addAction(ACTION_CHARGING_STABLE);
  mContext.registerReceiver(this,filter);
  BatteryService batteryService=(BatteryService)ServiceManager.getService(""String_Node_Str"");
  if (batteryService != null) {
    mBatteryHealthy=!batteryService.getBatteryLevelLow();
    mCharging=batteryService.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);
  }
 else {
  }
}",0.9640522875816994
199120,"@Override public void dumpControllerState(PrintWriter pw){
}","@Override public void dumpControllerState(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
synchronized (mTrackedTasks) {
    Iterator<JobStatus> it=mTrackedTasks.iterator();
    if (it.hasNext()) {
      pw.print(String.valueOf(it.next().hashCode()));
    }
    while (it.hasNext()) {
      pw.print(""String_Node_Str"" + String.valueOf(it.next().hashCode()));
    }
    pw.println();
  }
}",0.2316602316602316
199121,"@Override public void maybeStartTrackingJob(JobStatus taskStatus){
  if (taskStatus.hasChargingConstraint()) {
synchronized (mTrackedTasks) {
      mTrackedTasks.add(taskStatus);
      taskStatus.chargingConstraintSatisfied.set(mChargeTracker.isOnStablePower());
    }
  }
}","@Override public void maybeStartTrackingJob(JobStatus taskStatus){
  if (taskStatus.hasChargingConstraint()) {
    final boolean isOnStablePower=mChargeTracker.isOnStablePower();
synchronized (mTrackedTasks) {
      mTrackedTasks.add(taskStatus);
      taskStatus.chargingConstraintSatisfied.set(isOnStablePower);
    }
    if (isOnStablePower) {
      mStateChangedListener.onControllerStateChanged();
    }
  }
}",0.7063953488372093
199122,"public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestination()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}","public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestinationLinkAddress()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}",0.9830508474576272
199123,"@VisibleForTesting public void onReceiveInternal(Intent intent){
  final String action=intent.getAction();
  if (Intent.ACTION_BATTERY_LOW.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=false;
  }
 else   if (Intent.ACTION_BATTERY_OKAY.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=true;
    maybeReportNewChargingState();
  }
 else   if (Intent.ACTION_POWER_CONNECTED.equals(action)) {
    mAlarm.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + STABLE_CHARGING_THRESHOLD_MILLIS,mStableChargingTriggerIntent);
    mCharging=true;
  }
 else   if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
    mAlarm.cancel(mStableChargingTriggerIntent);
    mCharging=false;
    maybeReportNewChargingState();
  }
 else   if (ACTION_CHARGING_STABLE.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    if (mCharging) {
      maybeReportNewChargingState();
    }
  }
}","@VisibleForTesting public void onReceiveInternal(Intent intent){
  final String action=intent.getAction();
  if (Intent.ACTION_BATTERY_LOW.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=false;
  }
 else   if (Intent.ACTION_BATTERY_OKAY.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=true;
    maybeReportNewChargingState();
  }
 else   if (Intent.ACTION_POWER_CONNECTED.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + STABLE_CHARGING_THRESHOLD_MILLIS);
    }
    mAlarm.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + STABLE_CHARGING_THRESHOLD_MILLIS,mStableChargingTriggerIntent);
    mCharging=true;
  }
 else   if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"");
    }
    mAlarm.cancel(mStableChargingTriggerIntent);
    mCharging=false;
    maybeReportNewChargingState();
  }
 else   if (ACTION_CHARGING_STABLE.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime() + ""String_Node_Str""+ mCharging);
    }
    if (mCharging) {
      maybeReportNewChargingState();
    }
  }
}",0.8614107883817428
199124,"public ChargingTracker(){
  mAlarm=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent intent=new Intent(ACTION_CHARGING_STABLE).setComponent(new ComponentName(mContext,this.getClass()));
  mStableChargingTriggerIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
}","public ChargingTracker(){
  mAlarm=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent intent=new Intent(ACTION_CHARGING_STABLE);
  mStableChargingTriggerIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
}",0.8888888888888888
199125,"private void maybeReportNewChargingState(){
  final boolean stablePower=mChargeTracker.isOnStablePower();
  boolean reportChange=false;
synchronized (mTrackedTasks) {
    for (    JobStatus ts : mTrackedTasks) {
      boolean previous=ts.chargingConstraintSatisfied.getAndSet(stablePower);
      if (previous != stablePower) {
        reportChange=true;
      }
    }
  }
  if (reportChange) {
    mStateChangedListener.onControllerStateChanged();
  }
}","private void maybeReportNewChargingState(){
  final boolean stablePower=mChargeTracker.isOnStablePower();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + stablePower);
  }
  boolean reportChange=false;
synchronized (mTrackedTasks) {
    for (    JobStatus ts : mTrackedTasks) {
      boolean previous=ts.chargingConstraintSatisfied.getAndSet(stablePower);
      if (previous != stablePower) {
        reportChange=true;
      }
    }
  }
  if (reportChange) {
    mStateChangedListener.onControllerStateChanged();
  }
}",0.9301848049281314
199126,"public void startTracking(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_BATTERY_LOW);
  filter.addAction(Intent.ACTION_BATTERY_OKAY);
  filter.addAction(Intent.ACTION_POWER_CONNECTED);
  filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  mContext.registerReceiver(this,filter);
  BatteryService batteryService=(BatteryService)ServiceManager.getService(""String_Node_Str"");
  if (batteryService != null) {
    mBatteryHealthy=!batteryService.getBatteryLevelLow();
    mCharging=batteryService.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);
  }
 else {
  }
}","public void startTracking(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_BATTERY_LOW);
  filter.addAction(Intent.ACTION_BATTERY_OKAY);
  filter.addAction(Intent.ACTION_POWER_CONNECTED);
  filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  filter.addAction(ACTION_CHARGING_STABLE);
  mContext.registerReceiver(this,filter);
  BatteryService batteryService=(BatteryService)ServiceManager.getService(""String_Node_Str"");
  if (batteryService != null) {
    mBatteryHealthy=!batteryService.getBatteryLevelLow();
    mCharging=batteryService.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);
  }
 else {
  }
}",0.9640522875816994
199127,"@Override public void dumpControllerState(PrintWriter pw){
}","@Override public void dumpControllerState(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
synchronized (mTrackedTasks) {
    Iterator<JobStatus> it=mTrackedTasks.iterator();
    if (it.hasNext()) {
      pw.print(String.valueOf(it.next().hashCode()));
    }
    while (it.hasNext()) {
      pw.print(""String_Node_Str"" + String.valueOf(it.next().hashCode()));
    }
    pw.println();
  }
}",0.2316602316602316
199128,"@Override public void maybeStartTrackingJob(JobStatus taskStatus){
  if (taskStatus.hasChargingConstraint()) {
synchronized (mTrackedTasks) {
      mTrackedTasks.add(taskStatus);
      taskStatus.chargingConstraintSatisfied.set(mChargeTracker.isOnStablePower());
    }
  }
}","@Override public void maybeStartTrackingJob(JobStatus taskStatus){
  if (taskStatus.hasChargingConstraint()) {
    final boolean isOnStablePower=mChargeTracker.isOnStablePower();
synchronized (mTrackedTasks) {
      mTrackedTasks.add(taskStatus);
      taskStatus.chargingConstraintSatisfied.set(isOnStablePower);
    }
    if (isOnStablePower) {
      mStateChangedListener.onControllerStateChanged();
    }
  }
}",0.7063953488372093
199129,"/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestination()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}","/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestinationLinkAddress()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}",0.9890981169474728
199130,"@VisibleForTesting public void onReceiveInternal(Intent intent){
  final String action=intent.getAction();
  if (Intent.ACTION_BATTERY_LOW.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=false;
  }
 else   if (Intent.ACTION_BATTERY_OKAY.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=true;
    maybeReportNewChargingState();
  }
 else   if (Intent.ACTION_POWER_CONNECTED.equals(action)) {
    mAlarm.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + STABLE_CHARGING_THRESHOLD_MILLIS,mStableChargingTriggerIntent);
    mCharging=true;
  }
 else   if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
    mAlarm.cancel(mStableChargingTriggerIntent);
    mCharging=false;
    maybeReportNewChargingState();
  }
 else   if (ACTION_CHARGING_STABLE.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    if (mCharging) {
      maybeReportNewChargingState();
    }
  }
}","@VisibleForTesting public void onReceiveInternal(Intent intent){
  final String action=intent.getAction();
  if (Intent.ACTION_BATTERY_LOW.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=false;
  }
 else   if (Intent.ACTION_BATTERY_OKAY.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime());
    }
    mBatteryHealthy=true;
    maybeReportNewChargingState();
  }
 else   if (Intent.ACTION_POWER_CONNECTED.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + STABLE_CHARGING_THRESHOLD_MILLIS);
    }
    mAlarm.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + STABLE_CHARGING_THRESHOLD_MILLIS,mStableChargingTriggerIntent);
    mCharging=true;
  }
 else   if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"");
    }
    mAlarm.cancel(mStableChargingTriggerIntent);
    mCharging=false;
    maybeReportNewChargingState();
  }
 else   if (ACTION_CHARGING_STABLE.equals(action)) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + SystemClock.elapsedRealtime() + ""String_Node_Str""+ mCharging);
    }
    if (mCharging) {
      maybeReportNewChargingState();
    }
  }
}",0.8614107883817428
199131,"public ChargingTracker(){
  mAlarm=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent intent=new Intent(ACTION_CHARGING_STABLE).setComponent(new ComponentName(mContext,this.getClass()));
  mStableChargingTriggerIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
}","public ChargingTracker(){
  mAlarm=(AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
  Intent intent=new Intent(ACTION_CHARGING_STABLE);
  mStableChargingTriggerIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
}",0.8888888888888888
199132,"private void maybeReportNewChargingState(){
  final boolean stablePower=mChargeTracker.isOnStablePower();
  boolean reportChange=false;
synchronized (mTrackedTasks) {
    for (    JobStatus ts : mTrackedTasks) {
      boolean previous=ts.chargingConstraintSatisfied.getAndSet(stablePower);
      if (previous != stablePower) {
        reportChange=true;
      }
    }
  }
  if (reportChange) {
    mStateChangedListener.onControllerStateChanged();
  }
}","private void maybeReportNewChargingState(){
  final boolean stablePower=mChargeTracker.isOnStablePower();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + stablePower);
  }
  boolean reportChange=false;
synchronized (mTrackedTasks) {
    for (    JobStatus ts : mTrackedTasks) {
      boolean previous=ts.chargingConstraintSatisfied.getAndSet(stablePower);
      if (previous != stablePower) {
        reportChange=true;
      }
    }
  }
  if (reportChange) {
    mStateChangedListener.onControllerStateChanged();
  }
}",0.9301848049281314
199133,"public void startTracking(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_BATTERY_LOW);
  filter.addAction(Intent.ACTION_BATTERY_OKAY);
  filter.addAction(Intent.ACTION_POWER_CONNECTED);
  filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  mContext.registerReceiver(this,filter);
  BatteryService batteryService=(BatteryService)ServiceManager.getService(""String_Node_Str"");
  if (batteryService != null) {
    mBatteryHealthy=!batteryService.getBatteryLevelLow();
    mCharging=batteryService.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);
  }
 else {
  }
}","public void startTracking(){
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_BATTERY_LOW);
  filter.addAction(Intent.ACTION_BATTERY_OKAY);
  filter.addAction(Intent.ACTION_POWER_CONNECTED);
  filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  filter.addAction(ACTION_CHARGING_STABLE);
  mContext.registerReceiver(this,filter);
  BatteryService batteryService=(BatteryService)ServiceManager.getService(""String_Node_Str"");
  if (batteryService != null) {
    mBatteryHealthy=!batteryService.getBatteryLevelLow();
    mCharging=batteryService.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);
  }
 else {
  }
}",0.9640522875816994
199134,"@Override public void dumpControllerState(PrintWriter pw){
}","@Override public void dumpControllerState(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + mChargeTracker.isOnStablePower());
synchronized (mTrackedTasks) {
    Iterator<JobStatus> it=mTrackedTasks.iterator();
    if (it.hasNext()) {
      pw.print(String.valueOf(it.next().hashCode()));
    }
    while (it.hasNext()) {
      pw.print(""String_Node_Str"" + String.valueOf(it.next().hashCode()));
    }
    pw.println();
  }
}",0.2316602316602316
199135,"@Override public void maybeStartTrackingJob(JobStatus taskStatus){
  if (taskStatus.hasChargingConstraint()) {
synchronized (mTrackedTasks) {
      mTrackedTasks.add(taskStatus);
      taskStatus.chargingConstraintSatisfied.set(mChargeTracker.isOnStablePower());
    }
  }
}","@Override public void maybeStartTrackingJob(JobStatus taskStatus){
  if (taskStatus.hasChargingConstraint()) {
    final boolean isOnStablePower=mChargeTracker.isOnStablePower();
synchronized (mTrackedTasks) {
      mTrackedTasks.add(taskStatus);
      taskStatus.chargingConstraintSatisfied.set(isOnStablePower);
    }
    if (isOnStablePower) {
      mStateChangedListener.onControllerStateChanged();
    }
  }
}",0.7063953488372093
199136,"/** 
 * Returns a DisplayList. If the incoming displayList is null, one will be created. Otherwise, the same display list will be returned (after having been rendered into along the way, depending on the invalidation state of the view).
 * @param renderNode The previous version of this displayList, could be null.
 * @param isLayer Whether the requester of the display list is a layer. If so,the view will avoid creating a layer inside the resulting display list.
 * @return A new or reused DisplayList object.
 */
private void updateDisplayListIfDirty(@NonNull RenderNode renderNode,boolean isLayer){
  if (renderNode == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!canHaveDisplayList()) {
    return;
  }
  renderNode.setScrollPosition(mScrollX,mScrollY);
  if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.isValid() || (!isLayer && mRecreateDisplayList)) {
    if (renderNode.isValid() && !isLayer && !mRecreateDisplayList) {
      mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
      mPrivateFlags&=~PFLAG_DIRTY_MASK;
      dispatchGetDisplayList();
      return;
    }
    if (!isLayer) {
      mRecreateDisplayList=true;
    }
    boolean caching=false;
    int width=mRight - mLeft;
    int height=mBottom - mTop;
    int layerType=getLayerType();
    final HardwareCanvas canvas=renderNode.start(width,height);
    try {
      if (!isLayer && layerType != LAYER_TYPE_NONE) {
        if (layerType == LAYER_TYPE_HARDWARE) {
          final HardwareLayer layer=getHardwareLayer();
          if (layer != null && layer.isValid()) {
            canvas.drawHardwareLayer(layer,0,0,mLayerPaint);
          }
 else {
            canvas.saveLayer(0,0,mRight - mLeft,mBottom - mTop,mLayerPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
          }
          caching=true;
        }
 else {
          buildDrawingCache(true);
          Bitmap cache=getDrawingCache(true);
          if (cache != null) {
            canvas.drawBitmap(cache,0,0,mLayerPaint);
            caching=true;
          }
        }
      }
 else {
        computeScroll();
        canvas.translate(-mScrollX,-mScrollY);
        if (!isLayer) {
          mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
          mPrivateFlags&=~PFLAG_DIRTY_MASK;
        }
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
          dispatchDraw(canvas);
          if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
          }
        }
 else {
          draw(canvas);
        }
      }
    }
  finally {
      renderNode.end(canvas);
      renderNode.setCaching(caching);
      if (isLayer) {
        renderNode.setLeftTopRightBottom(0,0,width,height);
      }
 else {
        setDisplayListProperties(renderNode);
      }
    }
  }
 else   if (!isLayer) {
    mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags&=~PFLAG_DIRTY_MASK;
  }
}","/** 
 * Returns a DisplayList. If the incoming displayList is null, one will be created. Otherwise, the same display list will be returned (after having been rendered into along the way, depending on the invalidation state of the view).
 * @param renderNode The previous version of this displayList, could be null.
 * @param isLayer Whether the requester of the display list is a layer. If so,the view will avoid creating a layer inside the resulting display list.
 * @return A new or reused DisplayList object.
 */
private void updateDisplayListIfDirty(@NonNull RenderNode renderNode,boolean isLayer){
  if (renderNode == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!canHaveDisplayList()) {
    return;
  }
  if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.isValid() || (!isLayer && mRecreateDisplayList)) {
    if (renderNode.isValid() && !isLayer && !mRecreateDisplayList) {
      mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
      mPrivateFlags&=~PFLAG_DIRTY_MASK;
      dispatchGetDisplayList();
      return;
    }
    if (!isLayer) {
      mRecreateDisplayList=true;
    }
    boolean caching=false;
    int width=mRight - mLeft;
    int height=mBottom - mTop;
    int layerType=getLayerType();
    final HardwareCanvas canvas=renderNode.start(width,height);
    try {
      if (!isLayer && layerType != LAYER_TYPE_NONE) {
        if (layerType == LAYER_TYPE_HARDWARE) {
          final HardwareLayer layer=getHardwareLayer();
          if (layer != null && layer.isValid()) {
            canvas.drawHardwareLayer(layer,0,0,mLayerPaint);
          }
 else {
            canvas.saveLayer(0,0,mRight - mLeft,mBottom - mTop,mLayerPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
          }
          caching=true;
        }
 else {
          buildDrawingCache(true);
          Bitmap cache=getDrawingCache(true);
          if (cache != null) {
            canvas.drawBitmap(cache,0,0,mLayerPaint);
            caching=true;
          }
        }
      }
 else {
        computeScroll();
        canvas.translate(-mScrollX,-mScrollY);
        if (!isLayer) {
          mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
          mPrivateFlags&=~PFLAG_DIRTY_MASK;
        }
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
          dispatchDraw(canvas);
          if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
          }
        }
 else {
          draw(canvas);
        }
      }
    }
  finally {
      renderNode.end(canvas);
      renderNode.setCaching(caching);
      if (isLayer) {
        renderNode.setLeftTopRightBottom(0,0,width,height);
      }
 else {
        setDisplayListProperties(renderNode);
      }
    }
  }
 else   if (!isLayer) {
    mPrivateFlags|=PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags&=~PFLAG_DIRTY_MASK;
  }
}",0.991363251481795
199137,"/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestination()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}","/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestinationLinkAddress()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}",0.9890981169474728
199138,"/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestination()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}","/** 
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */
public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!(obj instanceof RouteInfo))   return false;
  RouteInfo target=(RouteInfo)obj;
  return Objects.equals(mDestination,target.getDestinationLinkAddress()) && Objects.equals(mGateway,target.getGateway()) && Objects.equals(mInterface,target.getInterface());
}",0.9890981169474728
199139,"public boolean isShowingLayoutLayouted(){
  View showingLayout=mShowingPublic ? mPublicLayout : mPrivateLayout;
  return showingLayout.getWidth() != 0;
}","public boolean isShowingLayoutLayouted(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getWidth() != 0;
}",0.8040540540540541
199140,"@Override public void setActualHeight(int height,boolean notifyListeners){
  mPrivateLayout.setActualHeight(height);
  invalidate();
  super.setActualHeight(height,notifyListeners);
}","@Override public void setActualHeight(int height,boolean notifyListeners){
  mPrivateLayout.setActualHeight(height);
  mPublicLayout.setActualHeight(height);
  invalidate();
  super.setActualHeight(height,notifyListeners);
}",0.8992628992628993
199141,"@Override public boolean isContentExpandable(){
  return mPrivateLayout.isContentExpandable();
}","@Override public boolean isContentExpandable(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.isContentExpandable();
}",0.7091633466135459
199142,"@Override public int getMinHeight(){
  return mPrivateLayout.getMinHeight();
}","@Override public int getMinHeight(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getMinHeight();
}",0.6604651162790698
199143,"public void notifyContentUpdated(){
  mPrivateLayout.notifyContentUpdated();
}","public void notifyContentUpdated(){
  mPublicLayout.notifyContentUpdated();
  mPrivateLayout.notifyContentUpdated();
}",0.7959183673469388
199144,"public int getMaxExpandHeight(){
  return mMaxExpandHeight;
}","public int getMaxExpandHeight(){
  return mShowingPublic ? mRowMinHeight : mMaxExpandHeight;
}",0.7870967741935484
199145,"@Override public int getMaxHeight(){
  return mPrivateLayout.getMaxHeight();
}","@Override public int getMaxHeight(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getMaxHeight();
}",0.6604651162790698
199146,"@Override public void setClipTopAmount(int clipTopAmount){
  super.setClipTopAmount(clipTopAmount);
  mPrivateLayout.setClipTopAmount(clipTopAmount);
}","@Override public void setClipTopAmount(int clipTopAmount){
  super.setClipTopAmount(clipTopAmount);
  mPrivateLayout.setClipTopAmount(clipTopAmount);
  mPublicLayout.setClipTopAmount(clipTopAmount);
}",0.8603988603988604
199147,"private void selectLayout(){
  if (mActualHeight <= mSmallHeight || mExpandedChild == null) {
    if (mContractedChild.getVisibility() != View.VISIBLE) {
      mContractedChild.setVisibility(View.VISIBLE);
    }
    if (mExpandedChild != null && mExpandedChild.getVisibility() != View.INVISIBLE) {
      mExpandedChild.setVisibility(View.INVISIBLE);
    }
  }
 else {
    if (mExpandedChild.getVisibility() != View.VISIBLE) {
      mExpandedChild.setVisibility(View.VISIBLE);
    }
    if (mContractedChild.getVisibility() != View.INVISIBLE) {
      mContractedChild.setVisibility(View.INVISIBLE);
    }
  }
}","private void selectLayout(){
  if (mActualHeight <= mSmallHeight || mExpandedChild == null) {
    if (mContractedChild != null && mContractedChild.getVisibility() != View.VISIBLE) {
      mContractedChild.setVisibility(View.VISIBLE);
    }
    if (mExpandedChild != null && mExpandedChild.getVisibility() != View.INVISIBLE) {
      mExpandedChild.setVisibility(View.INVISIBLE);
    }
  }
 else {
    if (mExpandedChild.getVisibility() != View.VISIBLE) {
      mExpandedChild.setVisibility(View.VISIBLE);
    }
    if (mContractedChild != null && mContractedChild.getVisibility() != View.INVISIBLE) {
      mContractedChild.setVisibility(View.INVISIBLE);
    }
  }
}",0.956043956043956
199148,"private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=(ExpandableView)findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getActualHeight();
    }
 else {
      if (mFirstChildWhileExpanding.getWidth() == 0) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            if (mFirstChildWhileExpanding != null) {
              mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            }
 else {
              mFirstChildMaxHeight=0;
            }
            v.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}","private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=(ExpandableView)findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getActualHeight();
    }
 else {
      if (!isMaxSizeInitialized(mFirstChildWhileExpanding)) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            if (mFirstChildWhileExpanding != null) {
              mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            }
 else {
              mFirstChildMaxHeight=0;
            }
            v.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}",0.9828872312417728
199149,"private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=(ExpandableView)findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getActualHeight();
    }
 else {
      if (mFirstChildWhileExpanding.getWidth() == 0) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            if (mFirstChildWhileExpanding != null) {
              mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            }
 else {
              mFirstChildMaxHeight=0;
            }
            v.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}","private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=(ExpandableView)findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getActualHeight();
    }
 else {
      if (!isMaxSizeInitialized(mFirstChildWhileExpanding)) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            if (mFirstChildWhileExpanding != null) {
              mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            }
 else {
              mFirstChildMaxHeight=0;
            }
            v.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}",0.9828872312417728
199150,"public boolean isShowingLayoutLayouted(){
  View showingLayout=mShowingPublic ? mPublicLayout : mPrivateLayout;
  return showingLayout.getWidth() != 0;
}","public boolean isShowingLayoutLayouted(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getWidth() != 0;
}",0.8040540540540541
199151,"@Override public void setActualHeight(int height,boolean notifyListeners){
  mPrivateLayout.setActualHeight(height);
  invalidate();
  super.setActualHeight(height,notifyListeners);
}","@Override public void setActualHeight(int height,boolean notifyListeners){
  mPrivateLayout.setActualHeight(height);
  mPublicLayout.setActualHeight(height);
  invalidate();
  super.setActualHeight(height,notifyListeners);
}",0.8992628992628993
199152,"@Override public boolean isContentExpandable(){
  return mPrivateLayout.isContentExpandable();
}","@Override public boolean isContentExpandable(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.isContentExpandable();
}",0.7091633466135459
199153,"@Override public int getMinHeight(){
  return mPrivateLayout.getMinHeight();
}","@Override public int getMinHeight(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getMinHeight();
}",0.6604651162790698
199154,"public void notifyContentUpdated(){
  mPrivateLayout.notifyContentUpdated();
}","public void notifyContentUpdated(){
  mPublicLayout.notifyContentUpdated();
  mPrivateLayout.notifyContentUpdated();
}",0.7959183673469388
199155,"public int getMaxExpandHeight(){
  return mMaxExpandHeight;
}","public int getMaxExpandHeight(){
  return mShowingPublic ? mRowMinHeight : mMaxExpandHeight;
}",0.7870967741935484
199156,"@Override public int getMaxHeight(){
  return mPrivateLayout.getMaxHeight();
}","@Override public int getMaxHeight(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getMaxHeight();
}",0.6604651162790698
199157,"@Override public void setClipTopAmount(int clipTopAmount){
  super.setClipTopAmount(clipTopAmount);
  mPrivateLayout.setClipTopAmount(clipTopAmount);
}","@Override public void setClipTopAmount(int clipTopAmount){
  super.setClipTopAmount(clipTopAmount);
  mPrivateLayout.setClipTopAmount(clipTopAmount);
  mPublicLayout.setClipTopAmount(clipTopAmount);
}",0.8603988603988604
199158,"private void selectLayout(){
  if (mActualHeight <= mSmallHeight || mExpandedChild == null) {
    if (mContractedChild.getVisibility() != View.VISIBLE) {
      mContractedChild.setVisibility(View.VISIBLE);
    }
    if (mExpandedChild != null && mExpandedChild.getVisibility() != View.INVISIBLE) {
      mExpandedChild.setVisibility(View.INVISIBLE);
    }
  }
 else {
    if (mExpandedChild.getVisibility() != View.VISIBLE) {
      mExpandedChild.setVisibility(View.VISIBLE);
    }
    if (mContractedChild.getVisibility() != View.INVISIBLE) {
      mContractedChild.setVisibility(View.INVISIBLE);
    }
  }
}","private void selectLayout(){
  if (mActualHeight <= mSmallHeight || mExpandedChild == null) {
    if (mContractedChild != null && mContractedChild.getVisibility() != View.VISIBLE) {
      mContractedChild.setVisibility(View.VISIBLE);
    }
    if (mExpandedChild != null && mExpandedChild.getVisibility() != View.INVISIBLE) {
      mExpandedChild.setVisibility(View.INVISIBLE);
    }
  }
 else {
    if (mExpandedChild.getVisibility() != View.VISIBLE) {
      mExpandedChild.setVisibility(View.VISIBLE);
    }
    if (mContractedChild != null && mContractedChild.getVisibility() != View.INVISIBLE) {
      mContractedChild.setVisibility(View.INVISIBLE);
    }
  }
}",0.956043956043956
199159,"public boolean isShowingLayoutLayouted(){
  View showingLayout=mShowingPublic ? mPublicLayout : mPrivateLayout;
  return showingLayout.getWidth() != 0;
}","public boolean isShowingLayoutLayouted(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getWidth() != 0;
}",0.8040540540540541
199160,"@Override public void setActualHeight(int height,boolean notifyListeners){
  mPrivateLayout.setActualHeight(height);
  invalidate();
  super.setActualHeight(height,notifyListeners);
}","@Override public void setActualHeight(int height,boolean notifyListeners){
  mPrivateLayout.setActualHeight(height);
  mPublicLayout.setActualHeight(height);
  invalidate();
  super.setActualHeight(height,notifyListeners);
}",0.8992628992628993
199161,"@Override public boolean isContentExpandable(){
  return mPrivateLayout.isContentExpandable();
}","@Override public boolean isContentExpandable(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.isContentExpandable();
}",0.7091633466135459
199162,"@Override public int getMinHeight(){
  return mPrivateLayout.getMinHeight();
}","@Override public int getMinHeight(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getMinHeight();
}",0.6604651162790698
199163,"public void notifyContentUpdated(){
  mPrivateLayout.notifyContentUpdated();
}","public void notifyContentUpdated(){
  mPublicLayout.notifyContentUpdated();
  mPrivateLayout.notifyContentUpdated();
}",0.7959183673469388
199164,"public int getMaxExpandHeight(){
  return mMaxExpandHeight;
}","public int getMaxExpandHeight(){
  return mShowingPublic ? mRowMinHeight : mMaxExpandHeight;
}",0.7870967741935484
199165,"@Override public int getMaxHeight(){
  return mPrivateLayout.getMaxHeight();
}","@Override public int getMaxHeight(){
  NotificationContentView showingLayout=getShowingLayout();
  return showingLayout.getMaxHeight();
}",0.6604651162790698
199166,"@Override public void setClipTopAmount(int clipTopAmount){
  super.setClipTopAmount(clipTopAmount);
  mPrivateLayout.setClipTopAmount(clipTopAmount);
}","@Override public void setClipTopAmount(int clipTopAmount){
  super.setClipTopAmount(clipTopAmount);
  mPrivateLayout.setClipTopAmount(clipTopAmount);
  mPublicLayout.setClipTopAmount(clipTopAmount);
}",0.8603988603988604
199167,"private void selectLayout(){
  if (mActualHeight <= mSmallHeight || mExpandedChild == null) {
    if (mContractedChild.getVisibility() != View.VISIBLE) {
      mContractedChild.setVisibility(View.VISIBLE);
    }
    if (mExpandedChild != null && mExpandedChild.getVisibility() != View.INVISIBLE) {
      mExpandedChild.setVisibility(View.INVISIBLE);
    }
  }
 else {
    if (mExpandedChild.getVisibility() != View.VISIBLE) {
      mExpandedChild.setVisibility(View.VISIBLE);
    }
    if (mContractedChild.getVisibility() != View.INVISIBLE) {
      mContractedChild.setVisibility(View.INVISIBLE);
    }
  }
}","private void selectLayout(){
  if (mActualHeight <= mSmallHeight || mExpandedChild == null) {
    if (mContractedChild != null && mContractedChild.getVisibility() != View.VISIBLE) {
      mContractedChild.setVisibility(View.VISIBLE);
    }
    if (mExpandedChild != null && mExpandedChild.getVisibility() != View.INVISIBLE) {
      mExpandedChild.setVisibility(View.INVISIBLE);
    }
  }
 else {
    if (mExpandedChild.getVisibility() != View.VISIBLE) {
      mExpandedChild.setVisibility(View.VISIBLE);
    }
    if (mContractedChild != null && mContractedChild.getVisibility() != View.INVISIBLE) {
      mContractedChild.setVisibility(View.INVISIBLE);
    }
  }
}",0.956043956043956
199168,"private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=(ExpandableView)findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getActualHeight();
    }
 else {
      if (mFirstChildWhileExpanding.getWidth() == 0) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            if (mFirstChildWhileExpanding != null) {
              mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            }
 else {
              mFirstChildMaxHeight=0;
            }
            v.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}","private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=(ExpandableView)findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getActualHeight();
    }
 else {
      if (!isMaxSizeInitialized(mFirstChildWhileExpanding)) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            if (mFirstChildWhileExpanding != null) {
              mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            }
 else {
              mFirstChildMaxHeight=0;
            }
            v.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}",0.9828872312417728
199169,"@Override public void onUnconfigured(CameraDevice camera){
  mUnconfigureDrainer.taskFinished();
}","@Override public void onUnconfigured(CameraDevice camera){
synchronized (session) {
    if (mClosed) {
      mUnconfigureDrainer.taskFinished();
    }
  }
}",0.7716535433070866
199170,"/** 
 * Create an internal state listener, to be invoked on the mDeviceHandler <p>It has a few behaviors: <ul> <li>Convert device state changes into session state changes. <li>Keep track of async tasks that the session began (idle, abort). </ul> </p>
 */
CameraDevice.StateListener getDeviceStateListener(){
  final CameraCaptureSession session=this;
  return new CameraDevice.StateListener(){
    private boolean mBusy=false;
    private boolean mActive=false;
    @Override public void onOpened(    CameraDevice camera){
      throw new AssertionError(""String_Node_Str"");
    }
    @Override public void onDisconnected(    CameraDevice camera){
      close();
    }
    @Override public void onError(    CameraDevice camera,    int error){
      Log.wtf(TAG,""String_Node_Str"" + error);
    }
    @Override public void onActive(    CameraDevice camera){
      mIdleDrainer.taskStarted();
      mActive=true;
      mStateListener.onActive(session);
    }
    @Override public void onIdle(    CameraDevice camera){
      boolean isAborting;
synchronized (session) {
        isAborting=mAborting;
      }
      if (mBusy && isAborting) {
        mAbortDrainer.taskFinished();
synchronized (session) {
          mAborting=false;
        }
      }
      if (mActive) {
        mIdleDrainer.taskFinished();
      }
      mBusy=false;
      mActive=false;
      mStateListener.onReady(session);
    }
    @Override public void onBusy(    CameraDevice camera){
      mBusy=true;
      Log.w(TAG,""String_Node_Str"");
      mStateListener.onActive(session);
    }
    @Override public void onUnconfigured(    CameraDevice camera){
      mUnconfigureDrainer.taskFinished();
    }
  }
;
}","/** 
 * Create an internal state listener, to be invoked on the mDeviceHandler <p>It has a few behaviors: <ul> <li>Convert device state changes into session state changes. <li>Keep track of async tasks that the session began (idle, abort). </ul> </p>
 */
CameraDevice.StateListener getDeviceStateListener(){
  final CameraCaptureSession session=this;
  return new CameraDevice.StateListener(){
    private boolean mBusy=false;
    private boolean mActive=false;
    @Override public void onOpened(    CameraDevice camera){
      throw new AssertionError(""String_Node_Str"");
    }
    @Override public void onDisconnected(    CameraDevice camera){
      close();
    }
    @Override public void onError(    CameraDevice camera,    int error){
      Log.wtf(TAG,""String_Node_Str"" + error);
    }
    @Override public void onActive(    CameraDevice camera){
      mIdleDrainer.taskStarted();
      mActive=true;
      mStateListener.onActive(session);
    }
    @Override public void onIdle(    CameraDevice camera){
      boolean isAborting;
synchronized (session) {
        isAborting=mAborting;
      }
      if (mBusy && isAborting) {
        mAbortDrainer.taskFinished();
synchronized (session) {
          mAborting=false;
        }
      }
      if (mActive) {
        mIdleDrainer.taskFinished();
      }
      mBusy=false;
      mActive=false;
      mStateListener.onReady(session);
    }
    @Override public void onBusy(    CameraDevice camera){
      mBusy=true;
      Log.w(TAG,""String_Node_Str"");
      mStateListener.onActive(session);
    }
    @Override public void onUnconfigured(    CameraDevice camera){
synchronized (session) {
        if (mClosed) {
          mUnconfigureDrainer.taskFinished();
        }
      }
    }
  }
;
}",0.978375219170076
199171,"@Override public void onUnconfigured(CameraDevice camera){
  mUnconfigureDrainer.taskFinished();
}","@Override public void onUnconfigured(CameraDevice camera){
synchronized (session) {
    if (mClosed) {
      mUnconfigureDrainer.taskFinished();
    }
  }
}",0.7716535433070866
199172,"/** 
 * Create an internal state listener, to be invoked on the mDeviceHandler <p>It has a few behaviors: <ul> <li>Convert device state changes into session state changes. <li>Keep track of async tasks that the session began (idle, abort). </ul> </p>
 */
CameraDevice.StateListener getDeviceStateListener(){
  final CameraCaptureSession session=this;
  return new CameraDevice.StateListener(){
    private boolean mBusy=false;
    private boolean mActive=false;
    @Override public void onOpened(    CameraDevice camera){
      throw new AssertionError(""String_Node_Str"");
    }
    @Override public void onDisconnected(    CameraDevice camera){
      close();
    }
    @Override public void onError(    CameraDevice camera,    int error){
      Log.wtf(TAG,""String_Node_Str"" + error);
    }
    @Override public void onActive(    CameraDevice camera){
      mIdleDrainer.taskStarted();
      mActive=true;
      mStateListener.onActive(session);
    }
    @Override public void onIdle(    CameraDevice camera){
      boolean isAborting;
synchronized (session) {
        isAborting=mAborting;
      }
      if (mBusy && isAborting) {
        mAbortDrainer.taskFinished();
synchronized (session) {
          mAborting=false;
        }
      }
      if (mActive) {
        mIdleDrainer.taskFinished();
      }
      mBusy=false;
      mActive=false;
      mStateListener.onReady(session);
    }
    @Override public void onBusy(    CameraDevice camera){
      mBusy=true;
      Log.w(TAG,""String_Node_Str"");
      mStateListener.onActive(session);
    }
    @Override public void onUnconfigured(    CameraDevice camera){
      mUnconfigureDrainer.taskFinished();
    }
  }
;
}","/** 
 * Create an internal state listener, to be invoked on the mDeviceHandler <p>It has a few behaviors: <ul> <li>Convert device state changes into session state changes. <li>Keep track of async tasks that the session began (idle, abort). </ul> </p>
 */
CameraDevice.StateListener getDeviceStateListener(){
  final CameraCaptureSession session=this;
  return new CameraDevice.StateListener(){
    private boolean mBusy=false;
    private boolean mActive=false;
    @Override public void onOpened(    CameraDevice camera){
      throw new AssertionError(""String_Node_Str"");
    }
    @Override public void onDisconnected(    CameraDevice camera){
      close();
    }
    @Override public void onError(    CameraDevice camera,    int error){
      Log.wtf(TAG,""String_Node_Str"" + error);
    }
    @Override public void onActive(    CameraDevice camera){
      mIdleDrainer.taskStarted();
      mActive=true;
      mStateListener.onActive(session);
    }
    @Override public void onIdle(    CameraDevice camera){
      boolean isAborting;
synchronized (session) {
        isAborting=mAborting;
      }
      if (mBusy && isAborting) {
        mAbortDrainer.taskFinished();
synchronized (session) {
          mAborting=false;
        }
      }
      if (mActive) {
        mIdleDrainer.taskFinished();
      }
      mBusy=false;
      mActive=false;
      mStateListener.onReady(session);
    }
    @Override public void onBusy(    CameraDevice camera){
      mBusy=true;
      Log.w(TAG,""String_Node_Str"");
      mStateListener.onActive(session);
    }
    @Override public void onUnconfigured(    CameraDevice camera){
synchronized (session) {
        if (mClosed) {
          mUnconfigureDrainer.taskFinished();
        }
      }
    }
  }
;
}",0.978375219170076
199173,"@Override protected void onBootCompleted(){
  mBootCompleted=true;
}","@Override protected void onBootCompleted(){
  if (mUseAlternateRecents) {
    if (mAlternateRecents != null) {
      mAlternateRecents.onBootCompleted();
    }
  }
  mBootCompleted=true;
}",0.53125
199174,"/** 
 * Hides the recents 
 */
public void onHideRecents(boolean triggeredFromAltTab){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.RecentsComponent,""String_Node_Str"");
  }
  if (mServiceIsBound) {
    try {
      Bundle data=new Bundle();
      Message msg=Message.obtain(null,MSG_HIDE_RECENTS,triggeredFromAltTab ? 1 : 0,0);
      msg.setData(data);
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Hides the recents 
 */
public void onHideRecents(boolean triggeredFromAltTab){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.RecentsComponent,""String_Node_Str"");
  }
  if (mServiceIsBound && mBootCompleted) {
    try {
      Bundle data=new Bundle();
      Message msg=Message.obtain(null,MSG_HIDE_RECENTS,triggeredFromAltTab ? 1 : 0,0);
      msg.setData(data);
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.98125
199175,"/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound && mBootCompleted) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.9902067464635472
199176,"@Override protected void onBootCompleted(){
  mBootCompleted=true;
}","@Override protected void onBootCompleted(){
  if (mUseAlternateRecents) {
    if (mAlternateRecents != null) {
      mAlternateRecents.onBootCompleted();
    }
  }
  mBootCompleted=true;
}",0.53125
199177,"/** 
 * Hides the recents 
 */
public void onHideRecents(boolean triggeredFromAltTab){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.RecentsComponent,""String_Node_Str"");
  }
  if (mServiceIsBound) {
    try {
      Bundle data=new Bundle();
      Message msg=Message.obtain(null,MSG_HIDE_RECENTS,triggeredFromAltTab ? 1 : 0,0);
      msg.setData(data);
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Hides the recents 
 */
public void onHideRecents(boolean triggeredFromAltTab){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.RecentsComponent,""String_Node_Str"");
  }
  if (mServiceIsBound && mBootCompleted) {
    try {
      Bundle data=new Bundle();
      Message msg=Message.obtain(null,MSG_HIDE_RECENTS,triggeredFromAltTab ? 1 : 0,0);
      msg.setData(data);
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.98125
199178,"/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound && mBootCompleted) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.9902067464635472
199179,"@Override protected void onBootCompleted(){
  mBootCompleted=true;
}","@Override protected void onBootCompleted(){
  if (mUseAlternateRecents) {
    if (mAlternateRecents != null) {
      mAlternateRecents.onBootCompleted();
    }
  }
  mBootCompleted=true;
}",0.53125
199180,"/** 
 * Hides the recents 
 */
public void onHideRecents(boolean triggeredFromAltTab){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.RecentsComponent,""String_Node_Str"");
  }
  if (mServiceIsBound) {
    try {
      Bundle data=new Bundle();
      Message msg=Message.obtain(null,MSG_HIDE_RECENTS,triggeredFromAltTab ? 1 : 0,0);
      msg.setData(data);
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Hides the recents 
 */
public void onHideRecents(boolean triggeredFromAltTab){
  if (Console.Enabled) {
    Console.log(Constants.Log.App.RecentsComponent,""String_Node_Str"");
  }
  if (mServiceIsBound && mBootCompleted) {
    try {
      Bundle data=new Bundle();
      Message msg=Message.obtain(null,MSG_HIDE_RECENTS,triggeredFromAltTab ? 1 : 0,0);
      msg.setData(data);
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.98125
199181,"/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}","/** 
 * Updates each of the task animation rects. 
 */
void updateAnimationRects(){
  if (mServiceIsBound && mBootCompleted) {
    Resources res=mContext.getResources();
    int statusBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int navBarHeight=res.getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height);
    Rect rect=new Rect();
    WindowManager wm=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    wm.getDefaultDisplay().getRectSize(rect);
    try {
      Bundle data=new Bundle();
      data.putParcelable(KEY_WINDOW_RECT,rect);
      data.putParcelable(KEY_SYSTEM_INSETS,new Rect(0,statusBarHeight,0,0));
      Message msg=Message.obtain(null,MSG_UPDATE_FOR_CONFIGURATION,0,0);
      msg.setData(data);
      msg.replyTo=mMessenger;
      mService.send(msg);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
}",0.9902067464635472
199182,"/** 
 * Change the position of child to a new location
 * @param child the view to change the position for
 * @param newIndex the new index
 */
public void changeViewPosition(View child,int newIndex){
  if (child != null && child.getParent() == this) {
    mChildrenChangingPositions.add(child);
    removeView(child);
    addView(child,newIndex);
    mNeedsAnimation=true;
  }
}","/** 
 * Change the position of child to a new location
 * @param child the view to change the position for
 * @param newIndex the new index
 */
public void changeViewPosition(View child,int newIndex){
  if (child != null && child.getParent() == this) {
    mChangePositionInProgress=true;
    removeView(child);
    addView(child,newIndex);
    mChangePositionInProgress=false;
    if (mIsExpanded && mAnimationsEnabled) {
      mChildrenChangingPositions.add(child);
      mNeedsAnimation=true;
    }
  }
}",0.6839729119638827
199183,"/** 
 * Generate an animation for an added child view.
 * @param child The view to be added.
 */
public void generateAddAnimation(View child){
  if (mIsExpanded && mAnimationsEnabled && !mChildrenChangingPositions.contains(child)) {
    mChildrenToAddAnimated.add(child);
    mNeedsAnimation=true;
  }
}","/** 
 * Generate an animation for an added child view.
 * @param child The view to be added.
 */
public void generateAddAnimation(View child){
  if (mIsExpanded && mAnimationsEnabled && !mChangePositionInProgress) {
    mChildrenToAddAnimated.add(child);
    mNeedsAnimation=true;
  }
}",0.9100169779286928
199184,"@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  if (mChildrenChangingPositions.contains(child)) {
    return;
  }
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  updateScrollStateForRemovedChild(child);
  boolean animationGenerated=generateRemoveAnimation(child);
  if (animationGenerated && !mSwipedOutViews.contains(child)) {
    getOverlay().add(child);
  }
}","@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  if (mChangePositionInProgress) {
    return;
  }
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  updateScrollStateForRemovedChild(child);
  boolean animationGenerated=generateRemoveAnimation(child);
  if (animationGenerated && !mSwipedOutViews.contains(child)) {
    getOverlay().add(child);
  }
}",0.956268221574344
199185,"/** 
 * Change the position of child to a new location
 * @param child the view to change the position for
 * @param newIndex the new index
 */
public void changeViewPosition(View child,int newIndex){
  if (child != null && child.getParent() == this) {
    mChildrenChangingPositions.add(child);
    removeView(child);
    addView(child,newIndex);
    mNeedsAnimation=true;
  }
}","/** 
 * Change the position of child to a new location
 * @param child the view to change the position for
 * @param newIndex the new index
 */
public void changeViewPosition(View child,int newIndex){
  if (child != null && child.getParent() == this) {
    mChangePositionInProgress=true;
    removeView(child);
    addView(child,newIndex);
    mChangePositionInProgress=false;
    if (mIsExpanded && mAnimationsEnabled) {
      mChildrenChangingPositions.add(child);
      mNeedsAnimation=true;
    }
  }
}",0.6839729119638827
199186,"/** 
 * Generate an animation for an added child view.
 * @param child The view to be added.
 */
public void generateAddAnimation(View child){
  if (mIsExpanded && mAnimationsEnabled && !mChildrenChangingPositions.contains(child)) {
    mChildrenToAddAnimated.add(child);
    mNeedsAnimation=true;
  }
}","/** 
 * Generate an animation for an added child view.
 * @param child The view to be added.
 */
public void generateAddAnimation(View child){
  if (mIsExpanded && mAnimationsEnabled && !mChangePositionInProgress) {
    mChildrenToAddAnimated.add(child);
    mNeedsAnimation=true;
  }
}",0.9100169779286928
199187,"@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  if (mChildrenChangingPositions.contains(child)) {
    return;
  }
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  updateScrollStateForRemovedChild(child);
  boolean animationGenerated=generateRemoveAnimation(child);
  if (animationGenerated && !mSwipedOutViews.contains(child)) {
    getOverlay().add(child);
  }
}","@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  if (mChangePositionInProgress) {
    return;
  }
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  updateScrollStateForRemovedChild(child);
  boolean animationGenerated=generateRemoveAnimation(child);
  if (animationGenerated && !mSwipedOutViews.contains(child)) {
    getOverlay().add(child);
  }
}",0.956268221574344
199188,"/** 
 * Change the position of child to a new location
 * @param child the view to change the position for
 * @param newIndex the new index
 */
public void changeViewPosition(View child,int newIndex){
  if (child != null && child.getParent() == this) {
    mChildrenChangingPositions.add(child);
    removeView(child);
    addView(child,newIndex);
    mNeedsAnimation=true;
  }
}","/** 
 * Change the position of child to a new location
 * @param child the view to change the position for
 * @param newIndex the new index
 */
public void changeViewPosition(View child,int newIndex){
  if (child != null && child.getParent() == this) {
    mChangePositionInProgress=true;
    removeView(child);
    addView(child,newIndex);
    mChangePositionInProgress=false;
    if (mIsExpanded && mAnimationsEnabled) {
      mChildrenChangingPositions.add(child);
      mNeedsAnimation=true;
    }
  }
}",0.6839729119638827
199189,"/** 
 * Generate an animation for an added child view.
 * @param child The view to be added.
 */
public void generateAddAnimation(View child){
  if (mIsExpanded && mAnimationsEnabled && !mChildrenChangingPositions.contains(child)) {
    mChildrenToAddAnimated.add(child);
    mNeedsAnimation=true;
  }
}","/** 
 * Generate an animation for an added child view.
 * @param child The view to be added.
 */
public void generateAddAnimation(View child){
  if (mIsExpanded && mAnimationsEnabled && !mChangePositionInProgress) {
    mChildrenToAddAnimated.add(child);
    mNeedsAnimation=true;
  }
}",0.9100169779286928
199190,"@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  if (mChildrenChangingPositions.contains(child)) {
    return;
  }
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  updateScrollStateForRemovedChild(child);
  boolean animationGenerated=generateRemoveAnimation(child);
  if (animationGenerated && !mSwipedOutViews.contains(child)) {
    getOverlay().add(child);
  }
}","@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  if (mChangePositionInProgress) {
    return;
  }
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  updateScrollStateForRemovedChild(child);
  boolean animationGenerated=generateRemoveAnimation(child);
  if (animationGenerated && !mSwipedOutViews.contains(child)) {
    getOverlay().add(child);
  }
}",0.956268221574344
199191,"@Override public void setAlpha(int alpha){
  if (mAlpha != alpha) {
    mAlpha=alpha;
    invalidateSelf();
  }
}","@Override public void setAlpha(int alpha){
  if (mVectorState.mVPathRenderer.getRootAlpha() != alpha) {
    mVectorState.mVPathRenderer.setRootAlpha(alpha);
    invalidateSelf();
  }
}",0.7542087542087542
199192,"public void draw(Canvas canvas,int w,int h){
  drawGroupTree(mRootGroup,IDENTITY_MATRIX,canvas,w,h);
}","public void draw(Canvas canvas,int w,int h){
  drawGroupTree(mRootGroup,IDENTITY_MATRIX,((float)mRootAlpha) / 0xFF,canvas,w,h);
}",0.8831168831168831
199193,"private void drawGroupTree(VGroup currentGroup,Matrix currentMatrix,Canvas canvas,int w,int h){
  currentGroup.mStackedMatrix.set(currentMatrix);
  currentGroup.mStackedMatrix.preConcat(currentGroup.mLocalMatrix);
  drawPath(currentGroup,canvas,w,h);
  for (int i=0; i < currentGroup.mChildGroupList.size(); i++) {
    drawGroupTree(currentGroup.mChildGroupList.get(i),currentGroup.mStackedMatrix,canvas,w,h);
  }
}","private void drawGroupTree(VGroup currentGroup,Matrix currentMatrix,float currentAlpha,Canvas canvas,int w,int h){
  currentGroup.mStackedMatrix.set(currentMatrix);
  currentGroup.mStackedMatrix.preConcat(currentGroup.mLocalMatrix);
  float stackedAlpha=currentAlpha * currentGroup.mGroupAlpha;
  drawPath(currentGroup,stackedAlpha,canvas,w,h);
  for (int i=0; i < currentGroup.mChildGroupList.size(); i++) {
    drawGroupTree(currentGroup.mChildGroupList.get(i),currentGroup.mStackedMatrix,stackedAlpha,canvas,w,h);
  }
}",0.8858057630736392
199194,"private void updateColorAlphas(){
  if (!Float.isNaN(mFillOpacity)) {
    mFillColor&=0x00FFFFFF;
    mFillColor|=((int)(0xFF * mFillOpacity)) << 24;
  }
  if (!Float.isNaN(mStrokeOpacity)) {
    mStrokeColor&=0x00FFFFFF;
    mStrokeColor|=((int)(0xFF * mStrokeOpacity)) << 24;
  }
}","private void updateColorAlphas(){
  if (!Float.isNaN(mFillOpacity)) {
    mFillColor=applyAlpha(mFillColor,mFillOpacity);
  }
  if (!Float.isNaN(mStrokeOpacity)) {
    mStrokeColor=applyAlpha(mStrokeColor,mStrokeOpacity);
  }
}",0.3803921568627451
199195,"private void drawPath(VGroup vGroup,Canvas canvas,int w,int h){
  final float scale=Math.min(h / mViewportHeight,w / mViewportWidth);
  mFinalPathMatrix.set(vGroup.mStackedMatrix);
  mFinalPathMatrix.postScale(scale,scale,mViewportWidth / 2f,mViewportHeight / 2f);
  mFinalPathMatrix.postTranslate(w / 2f - mViewportWidth / 2f,h / 2f - mViewportHeight / 2f);
  ArrayList<VPath> paths=vGroup.getPaths();
  for (int i=0; i < paths.size(); i++) {
    VPath vPath=paths.get(i);
    vPath.toPath(mPath);
    final Path path=mPath;
    if (vPath.mTrimPathStart != 0.0f || vPath.mTrimPathEnd != 1.0f) {
      float start=(vPath.mTrimPathStart + vPath.mTrimPathOffset) % 1.0f;
      float end=(vPath.mTrimPathEnd + vPath.mTrimPathOffset) % 1.0f;
      if (mPathMeasure == null) {
        mPathMeasure=new PathMeasure();
      }
      mPathMeasure.setPath(mPath,false);
      float len=mPathMeasure.getLength();
      start=start * len;
      end=end * len;
      path.reset();
      if (start > end) {
        mPathMeasure.getSegment(start,len,path,true);
        mPathMeasure.getSegment(0f,end,path,true);
      }
 else {
        mPathMeasure.getSegment(start,end,path,true);
      }
      path.rLineTo(0,0);
    }
    mRenderPath.reset();
    mRenderPath.addPath(path,mFinalPathMatrix);
    if (vPath.mClip) {
      canvas.clipPath(mRenderPath,Region.Op.REPLACE);
    }
    if (vPath.mFillColor != 0) {
      if (mFillPaint == null) {
        mFillPaint=new Paint();
        mFillPaint.setColorFilter(mColorFilter);
        mFillPaint.setStyle(Paint.Style.FILL);
        mFillPaint.setAntiAlias(true);
      }
      mFillPaint.setColor(vPath.mFillColor);
      canvas.drawPath(mRenderPath,mFillPaint);
    }
    if (vPath.mStrokeColor != 0) {
      if (mStrokePaint == null) {
        mStrokePaint=new Paint();
        mStrokePaint.setColorFilter(mColorFilter);
        mStrokePaint.setStyle(Paint.Style.STROKE);
        mStrokePaint.setAntiAlias(true);
      }
      final Paint strokePaint=mStrokePaint;
      if (vPath.mStrokeLineJoin != null) {
        strokePaint.setStrokeJoin(vPath.mStrokeLineJoin);
      }
      if (vPath.mStrokeLineCap != null) {
        strokePaint.setStrokeCap(vPath.mStrokeLineCap);
      }
      strokePaint.setStrokeMiter(vPath.mStrokeMiterlimit * scale);
      strokePaint.setColor(vPath.mStrokeColor);
      strokePaint.setStrokeWidth(vPath.mStrokeWidth * scale);
      canvas.drawPath(mRenderPath,strokePaint);
    }
  }
}","private void drawPath(VGroup vGroup,float stackedAlpha,Canvas canvas,int w,int h){
  final float scale=Math.min(h / mViewportHeight,w / mViewportWidth);
  mFinalPathMatrix.set(vGroup.mStackedMatrix);
  mFinalPathMatrix.postScale(scale,scale,mViewportWidth / 2f,mViewportHeight / 2f);
  mFinalPathMatrix.postTranslate(w / 2f - mViewportWidth / 2f,h / 2f - mViewportHeight / 2f);
  ArrayList<VPath> paths=vGroup.getPaths();
  for (int i=0; i < paths.size(); i++) {
    VPath vPath=paths.get(i);
    vPath.toPath(mPath);
    final Path path=mPath;
    if (vPath.mTrimPathStart != 0.0f || vPath.mTrimPathEnd != 1.0f) {
      float start=(vPath.mTrimPathStart + vPath.mTrimPathOffset) % 1.0f;
      float end=(vPath.mTrimPathEnd + vPath.mTrimPathOffset) % 1.0f;
      if (mPathMeasure == null) {
        mPathMeasure=new PathMeasure();
      }
      mPathMeasure.setPath(mPath,false);
      float len=mPathMeasure.getLength();
      start=start * len;
      end=end * len;
      path.reset();
      if (start > end) {
        mPathMeasure.getSegment(start,len,path,true);
        mPathMeasure.getSegment(0f,end,path,true);
      }
 else {
        mPathMeasure.getSegment(start,end,path,true);
      }
      path.rLineTo(0,0);
    }
    mRenderPath.reset();
    mRenderPath.addPath(path,mFinalPathMatrix);
    if (vPath.mClip) {
      canvas.clipPath(mRenderPath,Region.Op.REPLACE);
    }
 else {
      if (vPath.mFillColor != 0) {
        if (mFillPaint == null) {
          mFillPaint=new Paint();
          mFillPaint.setColorFilter(mColorFilter);
          mFillPaint.setStyle(Paint.Style.FILL);
          mFillPaint.setAntiAlias(true);
        }
        mFillPaint.setColor(applyAlpha(vPath.mFillColor,stackedAlpha));
        canvas.drawPath(mRenderPath,mFillPaint);
      }
      if (vPath.mStrokeColor != 0) {
        if (mStrokePaint == null) {
          mStrokePaint=new Paint();
          mStrokePaint.setColorFilter(mColorFilter);
          mStrokePaint.setStyle(Paint.Style.STROKE);
          mStrokePaint.setAntiAlias(true);
        }
        final Paint strokePaint=mStrokePaint;
        if (vPath.mStrokeLineJoin != null) {
          strokePaint.setStrokeJoin(vPath.mStrokeLineJoin);
        }
        if (vPath.mStrokeLineCap != null) {
          strokePaint.setStrokeCap(vPath.mStrokeLineCap);
        }
        strokePaint.setStrokeMiter(vPath.mStrokeMiterlimit * scale);
        strokePaint.setColor(applyAlpha(vPath.mStrokeColor,stackedAlpha));
        strokePaint.setStrokeWidth(vPath.mStrokeWidth * scale);
        canvas.drawPath(mRenderPath,strokePaint);
      }
    }
  }
}",0.9672813801308744
199196,"@Override public void setAlpha(int alpha){
  if (mAlpha != alpha) {
    mAlpha=alpha;
    invalidateSelf();
  }
}","@Override public void setAlpha(int alpha){
  if (mVectorState.mVPathRenderer.getRootAlpha() != alpha) {
    mVectorState.mVPathRenderer.setRootAlpha(alpha);
    invalidateSelf();
  }
}",0.7542087542087542
199197,"public void draw(Canvas canvas,int w,int h){
  drawGroupTree(mRootGroup,IDENTITY_MATRIX,canvas,w,h);
}","public void draw(Canvas canvas,int w,int h){
  drawGroupTree(mRootGroup,IDENTITY_MATRIX,((float)mRootAlpha) / 0xFF,canvas,w,h);
}",0.8831168831168831
199198,"private void drawGroupTree(VGroup currentGroup,Matrix currentMatrix,Canvas canvas,int w,int h){
  currentGroup.mStackedMatrix.set(currentMatrix);
  currentGroup.mStackedMatrix.preConcat(currentGroup.mLocalMatrix);
  drawPath(currentGroup,canvas,w,h);
  for (int i=0; i < currentGroup.mChildGroupList.size(); i++) {
    drawGroupTree(currentGroup.mChildGroupList.get(i),currentGroup.mStackedMatrix,canvas,w,h);
  }
}","private void drawGroupTree(VGroup currentGroup,Matrix currentMatrix,float currentAlpha,Canvas canvas,int w,int h){
  currentGroup.mStackedMatrix.set(currentMatrix);
  currentGroup.mStackedMatrix.preConcat(currentGroup.mLocalMatrix);
  float stackedAlpha=currentAlpha * currentGroup.mGroupAlpha;
  drawPath(currentGroup,stackedAlpha,canvas,w,h);
  for (int i=0; i < currentGroup.mChildGroupList.size(); i++) {
    drawGroupTree(currentGroup.mChildGroupList.get(i),currentGroup.mStackedMatrix,stackedAlpha,canvas,w,h);
  }
}",0.8858057630736392
199199,"private void updateColorAlphas(){
  if (!Float.isNaN(mFillOpacity)) {
    mFillColor&=0x00FFFFFF;
    mFillColor|=((int)(0xFF * mFillOpacity)) << 24;
  }
  if (!Float.isNaN(mStrokeOpacity)) {
    mStrokeColor&=0x00FFFFFF;
    mStrokeColor|=((int)(0xFF * mStrokeOpacity)) << 24;
  }
}","private void updateColorAlphas(){
  if (!Float.isNaN(mFillOpacity)) {
    mFillColor=applyAlpha(mFillColor,mFillOpacity);
  }
  if (!Float.isNaN(mStrokeOpacity)) {
    mStrokeColor=applyAlpha(mStrokeColor,mStrokeOpacity);
  }
}",0.3803921568627451
199200,"private void drawPath(VGroup vGroup,Canvas canvas,int w,int h){
  final float scale=Math.min(h / mViewportHeight,w / mViewportWidth);
  mFinalPathMatrix.set(vGroup.mStackedMatrix);
  mFinalPathMatrix.postScale(scale,scale,mViewportWidth / 2f,mViewportHeight / 2f);
  mFinalPathMatrix.postTranslate(w / 2f - mViewportWidth / 2f,h / 2f - mViewportHeight / 2f);
  ArrayList<VPath> paths=vGroup.getPaths();
  for (int i=0; i < paths.size(); i++) {
    VPath vPath=paths.get(i);
    vPath.toPath(mPath);
    final Path path=mPath;
    if (vPath.mTrimPathStart != 0.0f || vPath.mTrimPathEnd != 1.0f) {
      float start=(vPath.mTrimPathStart + vPath.mTrimPathOffset) % 1.0f;
      float end=(vPath.mTrimPathEnd + vPath.mTrimPathOffset) % 1.0f;
      if (mPathMeasure == null) {
        mPathMeasure=new PathMeasure();
      }
      mPathMeasure.setPath(mPath,false);
      float len=mPathMeasure.getLength();
      start=start * len;
      end=end * len;
      path.reset();
      if (start > end) {
        mPathMeasure.getSegment(start,len,path,true);
        mPathMeasure.getSegment(0f,end,path,true);
      }
 else {
        mPathMeasure.getSegment(start,end,path,true);
      }
      path.rLineTo(0,0);
    }
    mRenderPath.reset();
    mRenderPath.addPath(path,mFinalPathMatrix);
    if (vPath.mClip) {
      canvas.clipPath(mRenderPath,Region.Op.REPLACE);
    }
    if (vPath.mFillColor != 0) {
      if (mFillPaint == null) {
        mFillPaint=new Paint();
        mFillPaint.setColorFilter(mColorFilter);
        mFillPaint.setStyle(Paint.Style.FILL);
        mFillPaint.setAntiAlias(true);
      }
      mFillPaint.setColor(vPath.mFillColor);
      canvas.drawPath(mRenderPath,mFillPaint);
    }
    if (vPath.mStrokeColor != 0) {
      if (mStrokePaint == null) {
        mStrokePaint=new Paint();
        mStrokePaint.setColorFilter(mColorFilter);
        mStrokePaint.setStyle(Paint.Style.STROKE);
        mStrokePaint.setAntiAlias(true);
      }
      final Paint strokePaint=mStrokePaint;
      if (vPath.mStrokeLineJoin != null) {
        strokePaint.setStrokeJoin(vPath.mStrokeLineJoin);
      }
      if (vPath.mStrokeLineCap != null) {
        strokePaint.setStrokeCap(vPath.mStrokeLineCap);
      }
      strokePaint.setStrokeMiter(vPath.mStrokeMiterlimit * scale);
      strokePaint.setColor(vPath.mStrokeColor);
      strokePaint.setStrokeWidth(vPath.mStrokeWidth * scale);
      canvas.drawPath(mRenderPath,strokePaint);
    }
  }
}","private void drawPath(VGroup vGroup,float stackedAlpha,Canvas canvas,int w,int h){
  final float scale=Math.min(h / mViewportHeight,w / mViewportWidth);
  mFinalPathMatrix.set(vGroup.mStackedMatrix);
  mFinalPathMatrix.postScale(scale,scale,mViewportWidth / 2f,mViewportHeight / 2f);
  mFinalPathMatrix.postTranslate(w / 2f - mViewportWidth / 2f,h / 2f - mViewportHeight / 2f);
  ArrayList<VPath> paths=vGroup.getPaths();
  for (int i=0; i < paths.size(); i++) {
    VPath vPath=paths.get(i);
    vPath.toPath(mPath);
    final Path path=mPath;
    if (vPath.mTrimPathStart != 0.0f || vPath.mTrimPathEnd != 1.0f) {
      float start=(vPath.mTrimPathStart + vPath.mTrimPathOffset) % 1.0f;
      float end=(vPath.mTrimPathEnd + vPath.mTrimPathOffset) % 1.0f;
      if (mPathMeasure == null) {
        mPathMeasure=new PathMeasure();
      }
      mPathMeasure.setPath(mPath,false);
      float len=mPathMeasure.getLength();
      start=start * len;
      end=end * len;
      path.reset();
      if (start > end) {
        mPathMeasure.getSegment(start,len,path,true);
        mPathMeasure.getSegment(0f,end,path,true);
      }
 else {
        mPathMeasure.getSegment(start,end,path,true);
      }
      path.rLineTo(0,0);
    }
    mRenderPath.reset();
    mRenderPath.addPath(path,mFinalPathMatrix);
    if (vPath.mClip) {
      canvas.clipPath(mRenderPath,Region.Op.REPLACE);
    }
 else {
      if (vPath.mFillColor != 0) {
        if (mFillPaint == null) {
          mFillPaint=new Paint();
          mFillPaint.setColorFilter(mColorFilter);
          mFillPaint.setStyle(Paint.Style.FILL);
          mFillPaint.setAntiAlias(true);
        }
        mFillPaint.setColor(applyAlpha(vPath.mFillColor,stackedAlpha));
        canvas.drawPath(mRenderPath,mFillPaint);
      }
      if (vPath.mStrokeColor != 0) {
        if (mStrokePaint == null) {
          mStrokePaint=new Paint();
          mStrokePaint.setColorFilter(mColorFilter);
          mStrokePaint.setStyle(Paint.Style.STROKE);
          mStrokePaint.setAntiAlias(true);
        }
        final Paint strokePaint=mStrokePaint;
        if (vPath.mStrokeLineJoin != null) {
          strokePaint.setStrokeJoin(vPath.mStrokeLineJoin);
        }
        if (vPath.mStrokeLineCap != null) {
          strokePaint.setStrokeCap(vPath.mStrokeLineCap);
        }
        strokePaint.setStrokeMiter(vPath.mStrokeMiterlimit * scale);
        strokePaint.setColor(applyAlpha(vPath.mStrokeColor,stackedAlpha));
        strokePaint.setStrokeWidth(vPath.mStrokeWidth * scale);
        canvas.drawPath(mRenderPath,strokePaint);
      }
    }
  }
}",0.9672813801308744
199201,"private void handleAllocateLogicalAddress(final int deviceType,int preferredAddress,final AllocateLogicalAddressCallback callback){
  assertRunOnIoThread();
  int startAddress=preferredAddress;
  if (preferredAddress == HdmiCec.ADDR_UNREGISTERED) {
    for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
      if (deviceType == HdmiCec.getTypeFromAddress(i)) {
        startAddress=i;
        break;
      }
    }
  }
  int logicalAddress=HdmiCec.ADDR_UNREGISTERED;
  for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
    int curAddress=(startAddress + i) % NUM_LOGICAL_ADDRESS;
    if (curAddress != HdmiCec.ADDR_UNREGISTERED && deviceType == HdmiCec.getTypeFromAddress(i)) {
      if (!sendPollMessage(curAddress,RETRY_COUNT_FOR_LOGICAL_ADDRESS_ALLOCATION)) {
        logicalAddress=curAddress;
        break;
      }
    }
  }
  final int assignedAddress=logicalAddress;
  if (callback != null) {
    runOnServiceThread(new Runnable(){
      @Override public void run(){
        callback.onAllocated(deviceType,assignedAddress);
      }
    }
);
  }
}","private void handleAllocateLogicalAddress(final int deviceType,int preferredAddress,final AllocateLogicalAddressCallback callback){
  assertRunOnIoThread();
  int startAddress=preferredAddress;
  if (preferredAddress == HdmiCec.ADDR_UNREGISTERED) {
    for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
      if (deviceType == HdmiCec.getTypeFromAddress(i)) {
        startAddress=i;
        break;
      }
    }
  }
  int logicalAddress=HdmiCec.ADDR_UNREGISTERED;
  for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
    int curAddress=(startAddress + i) % NUM_LOGICAL_ADDRESS;
    if (curAddress != HdmiCec.ADDR_UNREGISTERED && deviceType == HdmiCec.getTypeFromAddress(curAddress)) {
      if (!sendPollMessage(curAddress,RETRY_COUNT_FOR_LOGICAL_ADDRESS_ALLOCATION)) {
        logicalAddress=curAddress;
        break;
      }
    }
  }
  final int assignedAddress=logicalAddress;
  if (callback != null) {
    runOnServiceThread(new Runnable(){
      @Override public void run(){
        callback.onAllocated(deviceType,assignedAddress);
      }
    }
);
  }
}",0.9947594092424964
199202,"/** 
 * Constructor.
 */
public HdmiCecMessage(int source,int destination,int opcode,byte[] params){
  mSource=source;
  mDestination=destination;
  mOpcode=opcode;
  mParams=Arrays.copyOf(params,params.length);
}","/** 
 * Constructor.
 */
public HdmiCecMessage(int source,int destination,int opcode,byte[] params){
  mSource=source;
  mDestination=destination;
  mOpcode=opcode & 0xFF;
  mParams=Arrays.copyOf(params,params.length);
}",0.9838337182448036
199203,"@Override public void sendTimerMessage(int state,long delayMillis){
  sendMessageDelayed(obtainMessage(MSG_TIMEOUT,state),delayMillis);
}","@Override public void sendTimerMessage(int state,long delayMillis){
  sendMessageDelayed(obtainMessage(MSG_TIMEOUT,state,0),delayMillis);
}",0.9927536231884058
199204,"/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.oneTouchPlay(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.queryDisplayStatus(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9590163934426228
199205,"/** 
 * Constructor.
 */
public HdmiCecMessage(int source,int destination,int opcode,byte[] params){
  mSource=source;
  mDestination=destination;
  mOpcode=opcode;
  mParams=Arrays.copyOf(params,params.length);
}","/** 
 * Constructor.
 */
public HdmiCecMessage(int source,int destination,int opcode,byte[] params){
  mSource=source;
  mDestination=destination;
  mOpcode=opcode & 0xFF;
  mParams=Arrays.copyOf(params,params.length);
}",0.9838337182448036
199206,"@Override public void sendTimerMessage(int state,long delayMillis){
  sendMessageDelayed(obtainMessage(MSG_TIMEOUT,state),delayMillis);
}","@Override public void sendTimerMessage(int state,long delayMillis){
  sendMessageDelayed(obtainMessage(MSG_TIMEOUT,state,0),delayMillis);
}",0.9927536231884058
199207,"private void handleAllocateLogicalAddress(final int deviceType,int preferredAddress,final AllocateLogicalAddressCallback callback){
  assertRunOnIoThread();
  int startAddress=preferredAddress;
  if (preferredAddress == HdmiCec.ADDR_UNREGISTERED) {
    for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
      if (deviceType == HdmiCec.getTypeFromAddress(i)) {
        startAddress=i;
        break;
      }
    }
  }
  int logicalAddress=HdmiCec.ADDR_UNREGISTERED;
  for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
    int curAddress=(startAddress + i) % NUM_LOGICAL_ADDRESS;
    if (curAddress != HdmiCec.ADDR_UNREGISTERED && deviceType == HdmiCec.getTypeFromAddress(i)) {
      if (!sendPollMessage(curAddress,RETRY_COUNT_FOR_LOGICAL_ADDRESS_ALLOCATION)) {
        logicalAddress=curAddress;
        break;
      }
    }
  }
  final int assignedAddress=logicalAddress;
  if (callback != null) {
    runOnServiceThread(new Runnable(){
      @Override public void run(){
        callback.onAllocated(deviceType,assignedAddress);
      }
    }
);
  }
}","private void handleAllocateLogicalAddress(final int deviceType,int preferredAddress,final AllocateLogicalAddressCallback callback){
  assertRunOnIoThread();
  int startAddress=preferredAddress;
  if (preferredAddress == HdmiCec.ADDR_UNREGISTERED) {
    for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
      if (deviceType == HdmiCec.getTypeFromAddress(i)) {
        startAddress=i;
        break;
      }
    }
  }
  int logicalAddress=HdmiCec.ADDR_UNREGISTERED;
  for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
    int curAddress=(startAddress + i) % NUM_LOGICAL_ADDRESS;
    if (curAddress != HdmiCec.ADDR_UNREGISTERED && deviceType == HdmiCec.getTypeFromAddress(curAddress)) {
      if (!sendPollMessage(curAddress,RETRY_COUNT_FOR_LOGICAL_ADDRESS_ALLOCATION)) {
        logicalAddress=curAddress;
        break;
      }
    }
  }
  final int assignedAddress=logicalAddress;
  if (callback != null) {
    runOnServiceThread(new Runnable(){
      @Override public void run(){
        callback.onAllocated(deviceType,assignedAddress);
      }
    }
);
  }
}",0.9947594092424964
199208,"/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.oneTouchPlay(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.queryDisplayStatus(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9590163934426228
199209,"public void resetViews(){
  mBlockTouches=false;
  mPageSwiper.reset();
  closeQs();
}","@Override public void resetViews(){
  mBlockTouches=false;
  mPageSwiper.reset();
  closeQs();
}",0.945054945054945
199210,"public void collapseAllPanels(boolean animate){
  boolean waiting=false;
  for (  PanelView pv : mPanels) {
    if (animate && !pv.isFullyCollapsed()) {
      pv.collapse();
      waiting=true;
    }
 else {
      pv.setExpandedFraction(0);
      pv.setVisibility(View.GONE);
      pv.cancelPeek();
    }
  }
  if (DEBUG)   LOG(""String_Node_Str"",animate,waiting);
  if (!waiting && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
}","public void collapseAllPanels(boolean animate){
  boolean waiting=false;
  for (  PanelView pv : mPanels) {
    if (animate && !pv.isFullyCollapsed()) {
      pv.collapse();
      waiting=true;
    }
 else {
      pv.setExpandedFraction(0);
      pv.setVisibility(View.GONE);
      pv.cancelPeek();
      pv.resetViews();
    }
  }
  if (DEBUG)   LOG(""String_Node_Str"",animate,waiting);
  if (!waiting && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
}",0.975763962065332
199211,"public boolean isSyntheticEntry(Entry ent){
  return ent.key.equals(SYNTHETIC_KEY);
}","public boolean isSyntheticEntry(Entry ent){
  return ent.key.equals(mSynKey);
}",0.902439024390244
199212,"public void resetViews(){
  mBlockTouches=false;
  mPageSwiper.reset();
  closeQs();
}","@Override public void resetViews(){
  mBlockTouches=false;
  mPageSwiper.reset();
  closeQs();
}",0.945054945054945
199213,"public void collapseAllPanels(boolean animate){
  boolean waiting=false;
  for (  PanelView pv : mPanels) {
    if (animate && !pv.isFullyCollapsed()) {
      pv.collapse();
      waiting=true;
    }
 else {
      pv.setExpandedFraction(0);
      pv.setVisibility(View.GONE);
      pv.cancelPeek();
    }
  }
  if (DEBUG)   LOG(""String_Node_Str"",animate,waiting);
  if (!waiting && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
}","public void collapseAllPanels(boolean animate){
  boolean waiting=false;
  for (  PanelView pv : mPanels) {
    if (animate && !pv.isFullyCollapsed()) {
      pv.collapse();
      waiting=true;
    }
 else {
      pv.setExpandedFraction(0);
      pv.setVisibility(View.GONE);
      pv.cancelPeek();
      pv.resetViews();
    }
  }
  if (DEBUG)   LOG(""String_Node_Str"",animate,waiting);
  if (!waiting && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
}",0.975763962065332
199214,"/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.oneTouchPlay(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.queryDisplayStatus(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9590163934426228
199215,"public void resetViews(){
  mBlockTouches=false;
  mPageSwiper.reset();
  closeQs();
}","@Override public void resetViews(){
  mBlockTouches=false;
  mPageSwiper.reset();
  closeQs();
}",0.945054945054945
199216,"public void collapseAllPanels(boolean animate){
  boolean waiting=false;
  for (  PanelView pv : mPanels) {
    if (animate && !pv.isFullyCollapsed()) {
      pv.collapse();
      waiting=true;
    }
 else {
      pv.setExpandedFraction(0);
      pv.setVisibility(View.GONE);
      pv.cancelPeek();
    }
  }
  if (DEBUG)   LOG(""String_Node_Str"",animate,waiting);
  if (!waiting && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
}","public void collapseAllPanels(boolean animate){
  boolean waiting=false;
  for (  PanelView pv : mPanels) {
    if (animate && !pv.isFullyCollapsed()) {
      pv.collapse();
      waiting=true;
    }
 else {
      pv.setExpandedFraction(0);
      pv.setVisibility(View.GONE);
      pv.cancelPeek();
      pv.resetViews();
    }
  }
  if (DEBUG)   LOG(""String_Node_Str"",animate,waiting);
  if (!waiting && mState != STATE_CLOSED) {
    go(STATE_CLOSED);
    onAllPanelsCollapsed();
  }
}",0.975763962065332
199217,"public boolean isSyntheticEntry(Entry ent){
  return ent.key.equals(SYNTHETIC_KEY);
}","public boolean isSyntheticEntry(Entry ent){
  return ent.key.equals(mSynKey);
}",0.902439024390244
199218,"public void bindRemoteViewsService(int appWidgetId,Intent intent,IBinder connection){
synchronized (mAppWidgetIds) {
    if (!mHasFeature) {
      return;
    }
    ensureStateLoadedLocked();
    AppWidgetId id=lookupAppWidgetIdLocked(appWidgetId);
    if (id == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final ComponentName componentName=intent.getComponent();
    try {
      final ServiceInfo si=mPm.getServiceInfo(componentName,PackageManager.GET_PERMISSIONS,mUserId);
      if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(si.permission)) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.BIND_REMOTEVIEWS + ""String_Node_Str""+ componentName);
      }
    }
 catch (    RemoteException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + componentName);
    }
    ServiceConnectionProxy conn=null;
    FilterComparison fc=new FilterComparison(intent);
    Pair<Integer,FilterComparison> key=Pair.create(appWidgetId,fc);
    if (mBoundRemoteViewsServices.containsKey(key)) {
      conn=(ServiceConnectionProxy)mBoundRemoteViewsServices.get(key);
      conn.disconnect();
      mContext.unbindService(conn);
      mBoundRemoteViewsServices.remove(key);
    }
    int userId=UserHandle.getUserId(id.provider.uid);
    if (userId != mUserId) {
      Slog.w(TAG,""String_Node_Str"" + mUserId + ""String_Node_Str""+ userId);
    }
    final long token=Binder.clearCallingIdentity();
    try {
      conn=new ServiceConnectionProxy(key,connection);
      mContext.bindServiceAsUser(intent,conn,Context.BIND_AUTO_CREATE,new UserHandle(userId));
      mBoundRemoteViewsServices.put(key,conn);
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
    incrementAppWidgetServiceRefCount(appWidgetId,fc);
  }
}","public void bindRemoteViewsService(int appWidgetId,Intent intent,IBinder connection){
synchronized (mAppWidgetIds) {
    if (!mHasFeature) {
      return;
    }
    ensureStateLoadedLocked();
    AppWidgetId id=lookupAppWidgetIdLocked(appWidgetId);
    if (id == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final ComponentName componentName=intent.getComponent();
    try {
      final ServiceInfo si=mPm.getServiceInfo(componentName,PackageManager.GET_PERMISSIONS,mUserId);
      if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(si.permission)) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.BIND_REMOTEVIEWS + ""String_Node_Str""+ componentName);
      }
    }
 catch (    RemoteException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + componentName);
    }
    String widgetIdPackage=id.provider.info.provider.getPackageName();
    String servicePackage=componentName.getPackageName();
    if (!servicePackage.equals(widgetIdPackage)) {
      throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"");
    }
    ServiceConnectionProxy conn=null;
    FilterComparison fc=new FilterComparison(intent);
    Pair<Integer,FilterComparison> key=Pair.create(appWidgetId,fc);
    if (mBoundRemoteViewsServices.containsKey(key)) {
      conn=(ServiceConnectionProxy)mBoundRemoteViewsServices.get(key);
      conn.disconnect();
      mContext.unbindService(conn);
      mBoundRemoteViewsServices.remove(key);
    }
    int userId=UserHandle.getUserId(id.provider.uid);
    if (userId != mUserId) {
      Slog.w(TAG,""String_Node_Str"" + mUserId + ""String_Node_Str""+ userId);
    }
    final long token=Binder.clearCallingIdentity();
    try {
      conn=new ServiceConnectionProxy(key,connection);
      mContext.bindServiceAsUser(intent,conn,Context.BIND_AUTO_CREATE,new UserHandle(userId));
      mBoundRemoteViewsServices.put(key,conn);
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
    incrementAppWidgetServiceRefCount(appWidgetId,fc);
  }
}",0.9328859060402684
199219,"/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.oneTouchPlay(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Get the status of display device connected through HDMI bus.
 * @param callback {@link DisplayStatusCallback} object to get informedof the result
 */
public void queryDisplayStatus(DisplayStatusCallback callback){
  try {
    mService.queryDisplayStatus(getCallbackWrapper(callback));
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9590163934426228
199220,"public boolean isSyntheticEntry(Entry ent){
  return ent.key.equals(SYNTHETIC_KEY);
}","public boolean isSyntheticEntry(Entry ent){
  return ent.key.equals(mSynKey);
}",0.902439024390244
199221,"/** 
 * Constructor.
 */
public HdmiCecMessage(int source,int destination,int opcode,byte[] params){
  mSource=source;
  mDestination=destination;
  mOpcode=opcode;
  mParams=Arrays.copyOf(params,params.length);
}","/** 
 * Constructor.
 */
public HdmiCecMessage(int source,int destination,int opcode,byte[] params){
  mSource=source;
  mDestination=destination;
  mOpcode=opcode & 0xFF;
  mParams=Arrays.copyOf(params,params.length);
}",0.9838337182448036
199222,"@Override public void sendTimerMessage(int state,long delayMillis){
  sendMessageDelayed(obtainMessage(MSG_TIMEOUT,state),delayMillis);
}","@Override public void sendTimerMessage(int state,long delayMillis){
  sendMessageDelayed(obtainMessage(MSG_TIMEOUT,state,0),delayMillis);
}",0.9927536231884058
199223,"public void bindRemoteViewsService(int appWidgetId,Intent intent,IBinder connection){
synchronized (mAppWidgetIds) {
    if (!mHasFeature) {
      return;
    }
    ensureStateLoadedLocked();
    AppWidgetId id=lookupAppWidgetIdLocked(appWidgetId);
    if (id == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final ComponentName componentName=intent.getComponent();
    try {
      final ServiceInfo si=mPm.getServiceInfo(componentName,PackageManager.GET_PERMISSIONS,mUserId);
      if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(si.permission)) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.BIND_REMOTEVIEWS + ""String_Node_Str""+ componentName);
      }
    }
 catch (    RemoteException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + componentName);
    }
    ServiceConnectionProxy conn=null;
    FilterComparison fc=new FilterComparison(intent);
    Pair<Integer,FilterComparison> key=Pair.create(appWidgetId,fc);
    if (mBoundRemoteViewsServices.containsKey(key)) {
      conn=(ServiceConnectionProxy)mBoundRemoteViewsServices.get(key);
      conn.disconnect();
      mContext.unbindService(conn);
      mBoundRemoteViewsServices.remove(key);
    }
    int userId=UserHandle.getUserId(id.provider.uid);
    if (userId != mUserId) {
      Slog.w(TAG,""String_Node_Str"" + mUserId + ""String_Node_Str""+ userId);
    }
    final long token=Binder.clearCallingIdentity();
    try {
      conn=new ServiceConnectionProxy(key,connection);
      mContext.bindServiceAsUser(intent,conn,Context.BIND_AUTO_CREATE,new UserHandle(userId));
      mBoundRemoteViewsServices.put(key,conn);
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
    incrementAppWidgetServiceRefCount(appWidgetId,fc);
  }
}","public void bindRemoteViewsService(int appWidgetId,Intent intent,IBinder connection){
synchronized (mAppWidgetIds) {
    if (!mHasFeature) {
      return;
    }
    ensureStateLoadedLocked();
    AppWidgetId id=lookupAppWidgetIdLocked(appWidgetId);
    if (id == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    final ComponentName componentName=intent.getComponent();
    try {
      final ServiceInfo si=mPm.getServiceInfo(componentName,PackageManager.GET_PERMISSIONS,mUserId);
      if (!android.Manifest.permission.BIND_REMOTEVIEWS.equals(si.permission)) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.BIND_REMOTEVIEWS + ""String_Node_Str""+ componentName);
      }
    }
 catch (    RemoteException e) {
      throw new IllegalArgumentException(""String_Node_Str"" + componentName);
    }
    String widgetIdPackage=id.provider.info.provider.getPackageName();
    String servicePackage=componentName.getPackageName();
    if (!servicePackage.equals(widgetIdPackage)) {
      throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"");
    }
    ServiceConnectionProxy conn=null;
    FilterComparison fc=new FilterComparison(intent);
    Pair<Integer,FilterComparison> key=Pair.create(appWidgetId,fc);
    if (mBoundRemoteViewsServices.containsKey(key)) {
      conn=(ServiceConnectionProxy)mBoundRemoteViewsServices.get(key);
      conn.disconnect();
      mContext.unbindService(conn);
      mBoundRemoteViewsServices.remove(key);
    }
    int userId=UserHandle.getUserId(id.provider.uid);
    if (userId != mUserId) {
      Slog.w(TAG,""String_Node_Str"" + mUserId + ""String_Node_Str""+ userId);
    }
    final long token=Binder.clearCallingIdentity();
    try {
      conn=new ServiceConnectionProxy(key,connection);
      mContext.bindServiceAsUser(intent,conn,Context.BIND_AUTO_CREATE,new UserHandle(userId));
      mBoundRemoteViewsServices.put(key,conn);
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
    incrementAppWidgetServiceRefCount(appWidgetId,fc);
  }
}",0.9328859060402684
199224,"private void handleAllocateLogicalAddress(final int deviceType,int preferredAddress,final AllocateLogicalAddressCallback callback){
  assertRunOnIoThread();
  int startAddress=preferredAddress;
  if (preferredAddress == HdmiCec.ADDR_UNREGISTERED) {
    for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
      if (deviceType == HdmiCec.getTypeFromAddress(i)) {
        startAddress=i;
        break;
      }
    }
  }
  int logicalAddress=HdmiCec.ADDR_UNREGISTERED;
  for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
    int curAddress=(startAddress + i) % NUM_LOGICAL_ADDRESS;
    if (curAddress != HdmiCec.ADDR_UNREGISTERED && deviceType == HdmiCec.getTypeFromAddress(i)) {
      if (!sendPollMessage(curAddress,RETRY_COUNT_FOR_LOGICAL_ADDRESS_ALLOCATION)) {
        logicalAddress=curAddress;
        break;
      }
    }
  }
  final int assignedAddress=logicalAddress;
  if (callback != null) {
    runOnServiceThread(new Runnable(){
      @Override public void run(){
        callback.onAllocated(deviceType,assignedAddress);
      }
    }
);
  }
}","private void handleAllocateLogicalAddress(final int deviceType,int preferredAddress,final AllocateLogicalAddressCallback callback){
  assertRunOnIoThread();
  int startAddress=preferredAddress;
  if (preferredAddress == HdmiCec.ADDR_UNREGISTERED) {
    for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
      if (deviceType == HdmiCec.getTypeFromAddress(i)) {
        startAddress=i;
        break;
      }
    }
  }
  int logicalAddress=HdmiCec.ADDR_UNREGISTERED;
  for (int i=0; i < NUM_LOGICAL_ADDRESS; ++i) {
    int curAddress=(startAddress + i) % NUM_LOGICAL_ADDRESS;
    if (curAddress != HdmiCec.ADDR_UNREGISTERED && deviceType == HdmiCec.getTypeFromAddress(curAddress)) {
      if (!sendPollMessage(curAddress,RETRY_COUNT_FOR_LOGICAL_ADDRESS_ALLOCATION)) {
        logicalAddress=curAddress;
        break;
      }
    }
  }
  final int assignedAddress=logicalAddress;
  if (callback != null) {
    runOnServiceThread(new Runnable(){
      @Override public void run(){
        callback.onAllocated(deviceType,assignedAddress);
      }
    }
);
  }
}",0.9947594092424964
199225,"private void dumpHistoryLocked(PrintWriter pw,int flags,long histStart,boolean checkin){
  final HistoryPrinter hprinter=new HistoryPrinter();
  final HistoryItem rec=new HistoryItem();
  long lastTime=-1;
  long baseTime=-1;
  boolean printed=false;
  HistoryEventTracker tracker=null;
  while (getNextHistoryLocked(rec)) {
    lastTime=rec.time;
    if (baseTime < 0) {
      baseTime=lastTime;
    }
    if (rec.time >= histStart) {
      if (histStart >= 0 && !printed) {
        if (rec.cmd == HistoryItem.CMD_CURRENT_TIME || rec.cmd == HistoryItem.CMD_RESET) {
          printed=true;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=HistoryItem.CMD_UPDATE;
        }
 else         if (rec.currentTime != 0) {
          printed=true;
          byte cmd=rec.cmd;
          rec.cmd=HistoryItem.CMD_CURRENT_TIME;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=cmd;
        }
        if (tracker != null) {
          if (rec.cmd != HistoryItem.CMD_UPDATE) {
            hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
            rec.cmd=HistoryItem.CMD_UPDATE;
          }
          int oldEventCode=rec.eventCode;
          HistoryTag oldEventTag=rec.eventTag;
          rec.eventTag=new HistoryTag();
          for (int i=0; i < HistoryItem.EVENT_COUNT; i++) {
            HashMap<String,SparseIntArray> active=tracker.getStateForEvent(i);
            if (active == null) {
              continue;
            }
            for (            HashMap.Entry<String,SparseIntArray> ent : active.entrySet()) {
              SparseIntArray uids=ent.getValue();
              for (int j=0; j < uids.size(); j++) {
                rec.eventCode=i;
                rec.eventTag.string=ent.getKey();
                rec.eventTag.uid=uids.keyAt(j);
                rec.eventTag.poolIdx=uids.valueAt(j);
                hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
                rec.wakeReasonTag=null;
                rec.wakelockTag=null;
              }
            }
          }
          rec.eventCode=oldEventCode;
          rec.eventTag=oldEventTag;
          tracker=null;
        }
      }
      hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
    }
 else     if (rec.eventCode != HistoryItem.EVENT_NONE) {
      if (tracker == null) {
        tracker=new HistoryEventTracker();
      }
      tracker.updateState(rec.eventCode,rec.eventTag.string,rec.eventTag.uid,rec.eventTag.poolIdx);
    }
  }
  if (histStart >= 0) {
    pw.print(checkin ? ""String_Node_Str"" : ""String_Node_Str"");
    pw.println(lastTime + 1);
  }
}","private void dumpHistoryLocked(PrintWriter pw,int flags,long histStart,boolean checkin){
  final HistoryPrinter hprinter=new HistoryPrinter();
  final HistoryItem rec=new HistoryItem();
  long lastTime=-1;
  long baseTime=-1;
  boolean printed=false;
  HistoryEventTracker tracker=null;
  while (getNextHistoryLocked(rec)) {
    lastTime=rec.time;
    if (baseTime < 0) {
      baseTime=lastTime;
    }
    if (rec.time >= histStart) {
      if (histStart >= 0 && !printed) {
        if (rec.cmd == HistoryItem.CMD_CURRENT_TIME || rec.cmd == HistoryItem.CMD_RESET) {
          printed=true;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=HistoryItem.CMD_UPDATE;
        }
 else         if (rec.currentTime != 0) {
          printed=true;
          byte cmd=rec.cmd;
          rec.cmd=HistoryItem.CMD_CURRENT_TIME;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=cmd;
        }
        if (tracker != null) {
          if (rec.cmd != HistoryItem.CMD_UPDATE) {
            hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
            rec.cmd=HistoryItem.CMD_UPDATE;
          }
          int oldEventCode=rec.eventCode;
          HistoryTag oldEventTag=rec.eventTag;
          rec.eventTag=new HistoryTag();
          for (int i=0; i < HistoryItem.EVENT_COUNT; i++) {
            HashMap<String,SparseIntArray> active=tracker.getStateForEvent(i);
            if (active == null) {
              continue;
            }
            for (            HashMap.Entry<String,SparseIntArray> ent : active.entrySet()) {
              SparseIntArray uids=ent.getValue();
              for (int j=0; j < uids.size(); j++) {
                rec.eventCode=i;
                rec.eventTag.string=ent.getKey();
                rec.eventTag.uid=uids.keyAt(j);
                rec.eventTag.poolIdx=uids.valueAt(j);
                hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
                rec.wakeReasonTag=null;
                rec.wakelockTag=null;
              }
            }
          }
          rec.eventCode=oldEventCode;
          rec.eventTag=oldEventTag;
          tracker=null;
        }
      }
      hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
    }
 else     if (false && rec.eventCode != HistoryItem.EVENT_NONE) {
      if (tracker == null) {
        tracker=new HistoryEventTracker();
      }
      tracker.updateState(rec.eventCode,rec.eventTag.string,rec.eventTag.uid,rec.eventTag.poolIdx);
    }
  }
  if (histStart >= 0) {
    pw.print(checkin ? ""String_Node_Str"" : ""String_Node_Str"");
    pw.println(lastTime + 1);
  }
}",0.99835255354201
199226,"private void dumpHistoryLocked(PrintWriter pw,int flags,long histStart,boolean checkin){
  final HistoryPrinter hprinter=new HistoryPrinter();
  final HistoryItem rec=new HistoryItem();
  long lastTime=-1;
  long baseTime=-1;
  boolean printed=false;
  HistoryEventTracker tracker=null;
  while (getNextHistoryLocked(rec)) {
    lastTime=rec.time;
    if (baseTime < 0) {
      baseTime=lastTime;
    }
    if (rec.time >= histStart) {
      if (histStart >= 0 && !printed) {
        if (rec.cmd == HistoryItem.CMD_CURRENT_TIME || rec.cmd == HistoryItem.CMD_RESET) {
          printed=true;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=HistoryItem.CMD_UPDATE;
        }
 else         if (rec.currentTime != 0) {
          printed=true;
          byte cmd=rec.cmd;
          rec.cmd=HistoryItem.CMD_CURRENT_TIME;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=cmd;
        }
        if (tracker != null) {
          if (rec.cmd != HistoryItem.CMD_UPDATE) {
            hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
            rec.cmd=HistoryItem.CMD_UPDATE;
          }
          int oldEventCode=rec.eventCode;
          HistoryTag oldEventTag=rec.eventTag;
          rec.eventTag=new HistoryTag();
          for (int i=0; i < HistoryItem.EVENT_COUNT; i++) {
            HashMap<String,SparseIntArray> active=tracker.getStateForEvent(i);
            if (active == null) {
              continue;
            }
            for (            HashMap.Entry<String,SparseIntArray> ent : active.entrySet()) {
              SparseIntArray uids=ent.getValue();
              for (int j=0; j < uids.size(); j++) {
                rec.eventCode=i;
                rec.eventTag.string=ent.getKey();
                rec.eventTag.uid=uids.keyAt(j);
                rec.eventTag.poolIdx=uids.valueAt(j);
                hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
                rec.wakeReasonTag=null;
                rec.wakelockTag=null;
              }
            }
          }
          rec.eventCode=oldEventCode;
          rec.eventTag=oldEventTag;
          tracker=null;
        }
      }
      hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
    }
 else     if (rec.eventCode != HistoryItem.EVENT_NONE) {
      if (tracker == null) {
        tracker=new HistoryEventTracker();
      }
      tracker.updateState(rec.eventCode,rec.eventTag.string,rec.eventTag.uid,rec.eventTag.poolIdx);
    }
  }
  if (histStart >= 0) {
    pw.print(checkin ? ""String_Node_Str"" : ""String_Node_Str"");
    pw.println(lastTime + 1);
  }
}","private void dumpHistoryLocked(PrintWriter pw,int flags,long histStart,boolean checkin){
  final HistoryPrinter hprinter=new HistoryPrinter();
  final HistoryItem rec=new HistoryItem();
  long lastTime=-1;
  long baseTime=-1;
  boolean printed=false;
  HistoryEventTracker tracker=null;
  while (getNextHistoryLocked(rec)) {
    lastTime=rec.time;
    if (baseTime < 0) {
      baseTime=lastTime;
    }
    if (rec.time >= histStart) {
      if (histStart >= 0 && !printed) {
        if (rec.cmd == HistoryItem.CMD_CURRENT_TIME || rec.cmd == HistoryItem.CMD_RESET) {
          printed=true;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=HistoryItem.CMD_UPDATE;
        }
 else         if (rec.currentTime != 0) {
          printed=true;
          byte cmd=rec.cmd;
          rec.cmd=HistoryItem.CMD_CURRENT_TIME;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=cmd;
        }
        if (tracker != null) {
          if (rec.cmd != HistoryItem.CMD_UPDATE) {
            hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
            rec.cmd=HistoryItem.CMD_UPDATE;
          }
          int oldEventCode=rec.eventCode;
          HistoryTag oldEventTag=rec.eventTag;
          rec.eventTag=new HistoryTag();
          for (int i=0; i < HistoryItem.EVENT_COUNT; i++) {
            HashMap<String,SparseIntArray> active=tracker.getStateForEvent(i);
            if (active == null) {
              continue;
            }
            for (            HashMap.Entry<String,SparseIntArray> ent : active.entrySet()) {
              SparseIntArray uids=ent.getValue();
              for (int j=0; j < uids.size(); j++) {
                rec.eventCode=i;
                rec.eventTag.string=ent.getKey();
                rec.eventTag.uid=uids.keyAt(j);
                rec.eventTag.poolIdx=uids.valueAt(j);
                hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
                rec.wakeReasonTag=null;
                rec.wakelockTag=null;
              }
            }
          }
          rec.eventCode=oldEventCode;
          rec.eventTag=oldEventTag;
          tracker=null;
        }
      }
      hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
    }
 else     if (false && rec.eventCode != HistoryItem.EVENT_NONE) {
      if (tracker == null) {
        tracker=new HistoryEventTracker();
      }
      tracker.updateState(rec.eventCode,rec.eventTag.string,rec.eventTag.uid,rec.eventTag.poolIdx);
    }
  }
  if (histStart >= 0) {
    pw.print(checkin ? ""String_Node_Str"" : ""String_Node_Str"");
    pw.println(lastTime + 1);
  }
}",0.99835255354201
199227,"private void dumpHistoryLocked(PrintWriter pw,int flags,long histStart,boolean checkin){
  final HistoryPrinter hprinter=new HistoryPrinter();
  final HistoryItem rec=new HistoryItem();
  long lastTime=-1;
  long baseTime=-1;
  boolean printed=false;
  HistoryEventTracker tracker=null;
  while (getNextHistoryLocked(rec)) {
    lastTime=rec.time;
    if (baseTime < 0) {
      baseTime=lastTime;
    }
    if (rec.time >= histStart) {
      if (histStart >= 0 && !printed) {
        if (rec.cmd == HistoryItem.CMD_CURRENT_TIME || rec.cmd == HistoryItem.CMD_RESET) {
          printed=true;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=HistoryItem.CMD_UPDATE;
        }
 else         if (rec.currentTime != 0) {
          printed=true;
          byte cmd=rec.cmd;
          rec.cmd=HistoryItem.CMD_CURRENT_TIME;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=cmd;
        }
        if (tracker != null) {
          if (rec.cmd != HistoryItem.CMD_UPDATE) {
            hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
            rec.cmd=HistoryItem.CMD_UPDATE;
          }
          int oldEventCode=rec.eventCode;
          HistoryTag oldEventTag=rec.eventTag;
          rec.eventTag=new HistoryTag();
          for (int i=0; i < HistoryItem.EVENT_COUNT; i++) {
            HashMap<String,SparseIntArray> active=tracker.getStateForEvent(i);
            if (active == null) {
              continue;
            }
            for (            HashMap.Entry<String,SparseIntArray> ent : active.entrySet()) {
              SparseIntArray uids=ent.getValue();
              for (int j=0; j < uids.size(); j++) {
                rec.eventCode=i;
                rec.eventTag.string=ent.getKey();
                rec.eventTag.uid=uids.keyAt(j);
                rec.eventTag.poolIdx=uids.valueAt(j);
                hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
                rec.wakeReasonTag=null;
                rec.wakelockTag=null;
              }
            }
          }
          rec.eventCode=oldEventCode;
          rec.eventTag=oldEventTag;
          tracker=null;
        }
      }
      hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
    }
 else     if (rec.eventCode != HistoryItem.EVENT_NONE) {
      if (tracker == null) {
        tracker=new HistoryEventTracker();
      }
      tracker.updateState(rec.eventCode,rec.eventTag.string,rec.eventTag.uid,rec.eventTag.poolIdx);
    }
  }
  if (histStart >= 0) {
    pw.print(checkin ? ""String_Node_Str"" : ""String_Node_Str"");
    pw.println(lastTime + 1);
  }
}","private void dumpHistoryLocked(PrintWriter pw,int flags,long histStart,boolean checkin){
  final HistoryPrinter hprinter=new HistoryPrinter();
  final HistoryItem rec=new HistoryItem();
  long lastTime=-1;
  long baseTime=-1;
  boolean printed=false;
  HistoryEventTracker tracker=null;
  while (getNextHistoryLocked(rec)) {
    lastTime=rec.time;
    if (baseTime < 0) {
      baseTime=lastTime;
    }
    if (rec.time >= histStart) {
      if (histStart >= 0 && !printed) {
        if (rec.cmd == HistoryItem.CMD_CURRENT_TIME || rec.cmd == HistoryItem.CMD_RESET) {
          printed=true;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=HistoryItem.CMD_UPDATE;
        }
 else         if (rec.currentTime != 0) {
          printed=true;
          byte cmd=rec.cmd;
          rec.cmd=HistoryItem.CMD_CURRENT_TIME;
          hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
          rec.cmd=cmd;
        }
        if (tracker != null) {
          if (rec.cmd != HistoryItem.CMD_UPDATE) {
            hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
            rec.cmd=HistoryItem.CMD_UPDATE;
          }
          int oldEventCode=rec.eventCode;
          HistoryTag oldEventTag=rec.eventTag;
          rec.eventTag=new HistoryTag();
          for (int i=0; i < HistoryItem.EVENT_COUNT; i++) {
            HashMap<String,SparseIntArray> active=tracker.getStateForEvent(i);
            if (active == null) {
              continue;
            }
            for (            HashMap.Entry<String,SparseIntArray> ent : active.entrySet()) {
              SparseIntArray uids=ent.getValue();
              for (int j=0; j < uids.size(); j++) {
                rec.eventCode=i;
                rec.eventTag.string=ent.getKey();
                rec.eventTag.uid=uids.keyAt(j);
                rec.eventTag.poolIdx=uids.valueAt(j);
                hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
                rec.wakeReasonTag=null;
                rec.wakelockTag=null;
              }
            }
          }
          rec.eventCode=oldEventCode;
          rec.eventTag=oldEventTag;
          tracker=null;
        }
      }
      hprinter.printNextItem(pw,rec,baseTime,checkin,(flags & DUMP_VERBOSE) != 0);
    }
 else     if (false && rec.eventCode != HistoryItem.EVENT_NONE) {
      if (tracker == null) {
        tracker=new HistoryEventTracker();
      }
      tracker.updateState(rec.eventCode,rec.eventTag.string,rec.eventTag.uid,rec.eventTag.poolIdx);
    }
  }
  if (histStart >= 0) {
    pw.print(checkin ? ""String_Node_Str"" : ""String_Node_Str"");
    pw.println(lastTime + 1);
  }
}",0.99835255354201
199228,"public RankingFuture process(NotificationRecord record){
  if (record == null || record.getNotification() == null) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    return null;
  }
  final Notification notification=record.getNotification();
  if ((notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.vibrate != null || (notification.defaults & Notification.DEFAULT_SOUND) != 0 || notification.sound != null || notification.fullScreenIntent != null) {
    record.setRecentlyIntusive(true);
  }
  return new RankingFuture(record,HANG_TIME_MS){
    @Override public void work(){
      mRecord.setRecentlyIntusive(false);
    }
  }
;
}","public RankingReconsideration process(NotificationRecord record){
  if (record == null || record.getNotification() == null) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    return null;
  }
  final Notification notification=record.getNotification();
  if ((notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.vibrate != null || (notification.defaults & Notification.DEFAULT_SOUND) != 0 || notification.sound != null || notification.fullScreenIntent != null) {
    record.setRecentlyIntusive(true);
  }
  return new RankingReconsideration(record.getKey(),HANG_TIME_MS){
    @Override public void work(){
    }
    @Override public void applyChangesLocked(    NotificationRecord record){
      record.setRecentlyIntusive(false);
    }
  }
;
}",0.8913805185704274
199229,"@Override public void work(){
  mRecord.setRecentlyIntusive(false);
}","@Override public void work(){
}",0.62
199230,"private void handleRankingReconsideration(Message message){
  if (!(message.obj instanceof RankingFuture))   return;
  RankingFuture future=(RankingFuture)message.obj;
  future.run();
  try {
    NotificationRecord record=future.get();
synchronized (mNotificationList) {
      int before=mNotificationList.indexOf(record);
      if (before != -1) {
        Collections.sort(mNotificationList,mRankingComparator);
        int after=mNotificationList.indexOf(record);
        if (before != after) {
          scheduleSendRankingUpdate();
        }
      }
    }
  }
 catch (  InterruptedException e) {
  }
catch (  ExecutionException e) {
  }
}","private void handleRankingReconsideration(Message message){
  if (!(message.obj instanceof RankingReconsideration))   return;
  RankingReconsideration recon=(RankingReconsideration)message.obj;
  recon.run();
  boolean orderChanged;
synchronized (mNotificationList) {
    final NotificationRecord record=mNotificationsByKey.get(recon.getKey());
    if (record == null) {
      return;
    }
    int before=findNotificationRecordIndexLocked(record);
    recon.applyChangesLocked(record);
    Collections.sort(mNotificationList,mRankingComparator);
    int after=findNotificationRecordIndexLocked(record);
    orderChanged=before != after;
  }
  if (orderChanged) {
    scheduleSendRankingUpdate();
  }
}",0.3541666666666667
199231,"void enqueueNotificationInternal(final String pkg,final String opPkg,final int callingUid,final int callingPid,final String tag,final int id,final Notification notification,int[] idOut,int incomingUserId){
  if (DBG) {
    Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=isUidSystem(callingUid) || (""String_Node_Str"".equals(pkg));
  final int userId=ActivityManager.handleIncomingUser(callingPid,callingUid,incomingUserId,true,false,""String_Node_Str"",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,""String_Node_Str"" + count + ""String_Node_Str""+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals(""String_Node_Str"") || Log.isLoggable(""String_Node_Str"",Log.VERBOSE)) {
    EventLogTags.writeNotificationEnqueue(callingUid,callingPid,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
    }
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
      if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
        if (notification.priority < Notification.PRIORITY_MAX) {
          notification.priority=Notification.PRIORITY_MAX;
        }
      }
 else       if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
        if (notification.priority < Notification.PRIORITY_HIGH) {
          notification.priority=Notification.PRIORITY_HIGH;
        }
      }
      int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
      final StatusBarNotification n=new StatusBarNotification(pkg,opPkg,id,tag,callingUid,callingPid,score,notification,user);
      NotificationRecord r=new NotificationRecord(n);
      if (!mSignalExtractors.isEmpty()) {
        for (        NotificationSignalExtractor extractor : mSignalExtractors) {
          try {
            RankingFuture future=extractor.process(r);
            scheduleRankingReconsideration(future);
          }
 catch (          Throwable t) {
            Slog.w(TAG,""String_Node_Str"",t);
          }
        }
      }
      if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
        if (!isSystemNotification) {
          score=JUNK_SCORE;
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
        }
      }
      if (score < SCORE_DISPLAY_THRESHOLD) {
        return;
      }
      final boolean intercept=mZenModeHelper.shouldIntercept(pkg,notification);
      notification.extras.putBoolean(EXTRA_INTERCEPT,intercept);
      final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD) && !intercept;
      if (DBG || intercept)       Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ canInterrupt+ ""String_Node_Str""+ intercept);
synchronized (mNotificationList) {
        NotificationRecord old=null;
        int index=indexOfNotificationLocked(n.getKey());
        if (index < 0) {
          mNotificationList.add(r);
          mUsageStats.registerPostedByApp(r);
        }
 else {
          old=mNotificationList.get(index);
          mNotificationList.set(index,r);
          mUsageStats.registerUpdatedByApp(r,old);
          notification.flags|=old.getNotification().flags & Notification.FLAG_FOREGROUND_SERVICE;
          mNotificationsByKey.remove(old.sbn.getKey());
        }
        mNotificationsByKey.put(n.getKey(),r);
        Collections.sort(mNotificationList,mRankingComparator);
        if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
          notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
        }
        final int currentUser;
        final long token=Binder.clearCallingIdentity();
        try {
          currentUser=ActivityManager.getCurrentUser();
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        if (notification.icon != 0) {
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.updateNotification(n);
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
 else {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.addNotification(n);
              if ((n.getNotification().flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
                mAttentionLight.pulse();
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
          if (currentUser == userId) {
            sendAccessibilityEvent(notification,pkg);
          }
          mListeners.notifyPostedLocked(r.sbn,cloneNotificationListLocked());
        }
 else {
          Slog.e(TAG,""String_Node_Str"" + notification);
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.removeNotification(r.getKey());
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
            mListeners.notifyRemovedLocked(r.sbn,cloneNotificationListLocked());
          }
          Slog.e(TAG,""String_Node_Str"" + n.getPackageName());
        }
        if (!mDisableNotificationAlerts && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.getUserId() == UserHandle.USER_ALL || (r.getUserId() == userId && r.getUserId() == currentUser) || mUserProfiles.isCurrentProfile(r.getUserId()))&& canInterrupt&& mSystemReady&& mAudioManager != null) {
          if (DBG)           Slog.v(TAG,""String_Node_Str"");
          final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
          Uri soundUri=null;
          boolean hasValidSound=false;
          if (useDefaultSound) {
            soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
            ContentResolver resolver=getContext().getContentResolver();
            hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
          }
 else           if (notification.sound != null) {
            soundUri=notification.sound;
            hasValidSound=(soundUri != null);
          }
          if (hasValidSound) {
            boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
            int audioStreamType;
            if (notification.audioStreamType >= 0) {
              audioStreamType=notification.audioStreamType;
            }
 else {
              audioStreamType=DEFAULT_STREAM_TYPE;
            }
            mSoundNotification=r;
            if ((mAudioManager.getStreamVolume(audioStreamType) != 0) && !mAudioManager.isAudioFocusExclusive()) {
              final long identity=Binder.clearCallingIdentity();
              try {
                final IRingtonePlayer player=mAudioManager.getRingtonePlayer();
                if (player != null) {
                  if (DBG)                   Slog.v(TAG,""String_Node_Str"" + soundUri + ""String_Node_Str""+ audioStreamType);
                  player.playAsync(soundUri,user,looping,audioStreamType);
                }
              }
 catch (              RemoteException e) {
              }
 finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
          }
          final boolean hasCustomVibrate=notification.vibrate != null;
          final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
          final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
          if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotification=r;
            if (useDefaultVibrate || convertSoundToVibration) {
              long identity=Binder.clearCallingIdentity();
              try {
                mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
              }
  finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
 else             if (notification.vibrate.length > 1) {
              mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
            }
          }
        }
        mLights.remove(old);
        if (mLedNotification == old) {
          mLedNotification=null;
        }
        if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
          mLights.add(r);
          updateLightsLocked();
        }
 else {
          if (old != null && ((old.getFlags() & Notification.FLAG_SHOW_LIGHTS) != 0)) {
            updateLightsLocked();
          }
        }
      }
    }
  }
);
  idOut[0]=id;
}","void enqueueNotificationInternal(final String pkg,final String opPkg,final int callingUid,final int callingPid,final String tag,final int id,final Notification notification,int[] idOut,int incomingUserId){
  if (DBG) {
    Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=isUidSystem(callingUid) || (""String_Node_Str"".equals(pkg));
  final int userId=ActivityManager.handleIncomingUser(callingPid,callingUid,incomingUserId,true,false,""String_Node_Str"",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,""String_Node_Str"" + count + ""String_Node_Str""+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals(""String_Node_Str"") || Log.isLoggable(""String_Node_Str"",Log.VERBOSE)) {
    EventLogTags.writeNotificationEnqueue(callingUid,callingPid,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
    }
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
      if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
        if (notification.priority < Notification.PRIORITY_MAX) {
          notification.priority=Notification.PRIORITY_MAX;
        }
      }
 else       if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
        if (notification.priority < Notification.PRIORITY_HIGH) {
          notification.priority=Notification.PRIORITY_HIGH;
        }
      }
      int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
      final StatusBarNotification n=new StatusBarNotification(pkg,opPkg,id,tag,callingUid,callingPid,score,notification,user);
      NotificationRecord r=new NotificationRecord(n);
      if (!mSignalExtractors.isEmpty()) {
        for (        NotificationSignalExtractor extractor : mSignalExtractors) {
          try {
            RankingReconsideration recon=extractor.process(r);
            scheduleRankingReconsideration(recon);
          }
 catch (          Throwable t) {
            Slog.w(TAG,""String_Node_Str"",t);
          }
        }
      }
      if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
        if (!isSystemNotification) {
          score=JUNK_SCORE;
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
        }
      }
      if (score < SCORE_DISPLAY_THRESHOLD) {
        return;
      }
      final boolean intercept=mZenModeHelper.shouldIntercept(pkg,notification);
      notification.extras.putBoolean(EXTRA_INTERCEPT,intercept);
      final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD) && !intercept;
      if (DBG || intercept)       Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ canInterrupt+ ""String_Node_Str""+ intercept);
synchronized (mNotificationList) {
        NotificationRecord old=null;
        int index=indexOfNotificationLocked(n.getKey());
        if (index < 0) {
          mNotificationList.add(r);
          mUsageStats.registerPostedByApp(r);
        }
 else {
          old=mNotificationList.get(index);
          mNotificationList.set(index,r);
          mUsageStats.registerUpdatedByApp(r,old);
          notification.flags|=old.getNotification().flags & Notification.FLAG_FOREGROUND_SERVICE;
          mNotificationsByKey.remove(old.sbn.getKey());
        }
        mNotificationsByKey.put(n.getKey(),r);
        Collections.sort(mNotificationList,mRankingComparator);
        if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
          notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
        }
        final int currentUser;
        final long token=Binder.clearCallingIdentity();
        try {
          currentUser=ActivityManager.getCurrentUser();
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        if (notification.icon != 0) {
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.updateNotification(n);
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
 else {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.addNotification(n);
              if ((n.getNotification().flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
                mAttentionLight.pulse();
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
          if (currentUser == userId) {
            sendAccessibilityEvent(notification,pkg);
          }
          mListeners.notifyPostedLocked(r.sbn,cloneNotificationListLocked());
        }
 else {
          Slog.e(TAG,""String_Node_Str"" + notification);
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.removeNotification(r.getKey());
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
            mListeners.notifyRemovedLocked(r.sbn,cloneNotificationListLocked());
          }
          Slog.e(TAG,""String_Node_Str"" + n.getPackageName());
        }
        if (!mDisableNotificationAlerts && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.getUserId() == UserHandle.USER_ALL || (r.getUserId() == userId && r.getUserId() == currentUser) || mUserProfiles.isCurrentProfile(r.getUserId()))&& canInterrupt&& mSystemReady&& mAudioManager != null) {
          if (DBG)           Slog.v(TAG,""String_Node_Str"");
          final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
          Uri soundUri=null;
          boolean hasValidSound=false;
          if (useDefaultSound) {
            soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
            ContentResolver resolver=getContext().getContentResolver();
            hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
          }
 else           if (notification.sound != null) {
            soundUri=notification.sound;
            hasValidSound=(soundUri != null);
          }
          if (hasValidSound) {
            boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
            int audioStreamType;
            if (notification.audioStreamType >= 0) {
              audioStreamType=notification.audioStreamType;
            }
 else {
              audioStreamType=DEFAULT_STREAM_TYPE;
            }
            mSoundNotification=r;
            if ((mAudioManager.getStreamVolume(audioStreamType) != 0) && !mAudioManager.isAudioFocusExclusive()) {
              final long identity=Binder.clearCallingIdentity();
              try {
                final IRingtonePlayer player=mAudioManager.getRingtonePlayer();
                if (player != null) {
                  if (DBG)                   Slog.v(TAG,""String_Node_Str"" + soundUri + ""String_Node_Str""+ audioStreamType);
                  player.playAsync(soundUri,user,looping,audioStreamType);
                }
              }
 catch (              RemoteException e) {
              }
 finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
          }
          final boolean hasCustomVibrate=notification.vibrate != null;
          final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
          final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
          if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotification=r;
            if (useDefaultVibrate || convertSoundToVibration) {
              long identity=Binder.clearCallingIdentity();
              try {
                mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
              }
  finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
 else             if (notification.vibrate.length > 1) {
              mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
            }
          }
        }
        mLights.remove(old);
        if (mLedNotification == old) {
          mLedNotification=null;
        }
        if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
          mLights.add(r);
          updateLightsLocked();
        }
 else {
          if (old != null && ((old.getFlags() & Notification.FLAG_SHOW_LIGHTS) != 0)) {
            updateLightsLocked();
          }
        }
      }
    }
  }
);
  idOut[0]=id;
}",0.997768189257551
199232,"private void scheduleRankingReconsideration(RankingFuture future){
  if (future != null) {
    Message m=Message.obtain(mRankingHandler,MESSAGE_RECONSIDER_RANKING,future);
    long delay=future.getDelay(TimeUnit.MILLISECONDS);
    mRankingHandler.sendMessageDelayed(m,delay);
  }
}","private void scheduleRankingReconsideration(RankingReconsideration recon){
  if (recon != null) {
    Message m=Message.obtain(mRankingHandler,MESSAGE_RECONSIDER_RANKING,recon);
    long delay=recon.getDelay(TimeUnit.MILLISECONDS);
    mRankingHandler.sendMessageDelayed(m,delay);
  }
}",0.8536155202821869
199233,"/** 
 * Called once per notification that is posted or updated.
 * @return null if the work is done, or a future if there is more to do. The{@link RankingFuture} will be run on a worker thread, and if notifications are re-orderedby that execution, the  {@link NotificationManagerService} may send order updateevents to the  {@link android.service.notification.NotificationListenerService}s.
 */
public RankingFuture process(NotificationManagerService.NotificationRecord notification);","/** 
 * Called once per notification that is posted or updated.
 * @return null if the work is done, or a future if there is more to do. The{@link RankingReconsideration} will be run on a worker thread, and if notificationsare re-ordered by that execution, the  {@link NotificationManagerService} may send orderupdate events to the  {@link android.service.notification.NotificationListenerService}s.
 */
public RankingReconsideration process(NotificationRecord notification);",0.9113660062565172
199234,"public RankingFuture process(NotificationManagerService.NotificationRecord record){
  if (!mEnabled) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  if (record == null || record.getNotification() == null) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  return validatePeople(record);
}","public RankingReconsideration process(NotificationRecord record){
  if (!mEnabled) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  if (record == null || record.getNotification() == null) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  return validatePeople(record);
}",0.926829268292683
199235,"@Override public void work(){
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + mRecord.sbn.getKey());
  float affinity=NONE;
  for (  final String handle : pendingLookups) {
    LookupResult lookupResult=null;
    final Uri uri=Uri.parse(handle);
    if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
    }
 else     if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
    }
 else     if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=searchContacts(uri);
    }
 else {
      lookupResult=new LookupResult();
      Slog.w(TAG,""String_Node_Str"" + handle);
    }
    if (lookupResult != null) {
synchronized (mPeopleCache) {
        mPeopleCache.put(handle,lookupResult);
      }
      affinity=Math.max(affinity,lookupResult.getAffinity());
    }
  }
  float affinityBound=mRecord.getContactAffinity();
  affinity=Math.max(affinity,affinityBound);
  mRecord.setContactAffinity(affinity);
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + affinity);
}","@Override public void work(){
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.getKey());
  for (  final String handle : pendingLookups) {
    LookupResult lookupResult=null;
    final Uri uri=Uri.parse(handle);
    if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
    }
 else     if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
    }
 else     if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=searchContacts(uri);
    }
 else {
      lookupResult=new LookupResult();
      Slog.w(TAG,""String_Node_Str"" + handle);
    }
    if (lookupResult != null) {
synchronized (mPeopleCache) {
        mPeopleCache.put(handle,lookupResult);
      }
      mContactAffinity=Math.max(mContactAffinity,lookupResult.getAffinity());
    }
  }
}",0.8940979489326077
199236,"private RankingFuture validatePeople(NotificationRecord record){
  float affinity=NONE;
  Bundle extras=record.getNotification().extras;
  if (extras == null) {
    return null;
  }
  final String[] people=getExtraPeople(extras);
  if (people == null || people.length == 0) {
    return null;
  }
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.sbn.getKey());
  final LinkedList<String> pendingLookups=new LinkedList<String>();
  for (int personIdx=0; personIdx < people.length && personIdx < MAX_PEOPLE; personIdx++) {
    final String handle=people[personIdx];
    if (TextUtils.isEmpty(handle))     continue;
synchronized (mPeopleCache) {
      LookupResult lookupResult=mPeopleCache.get(handle);
      if (lookupResult == null || lookupResult.isExpired()) {
        pendingLookups.add(handle);
      }
 else {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + lookupResult.mId);
      }
      if (lookupResult != null) {
        affinity=Math.max(affinity,lookupResult.getAffinity());
      }
    }
  }
  record.setContactAffinity(affinity);
  if (pendingLookups.isEmpty()) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"" + affinity);
    return null;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + record.sbn.getKey());
  return new RankingFuture(record){
    @Override public void work(){
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + mRecord.sbn.getKey());
      float affinity=NONE;
      for (      final String handle : pendingLookups) {
        LookupResult lookupResult=null;
        final Uri uri=Uri.parse(handle);
        if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
        }
 else         if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
        }
 else         if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=searchContacts(uri);
        }
 else {
          lookupResult=new LookupResult();
          Slog.w(TAG,""String_Node_Str"" + handle);
        }
        if (lookupResult != null) {
synchronized (mPeopleCache) {
            mPeopleCache.put(handle,lookupResult);
          }
          affinity=Math.max(affinity,lookupResult.getAffinity());
        }
      }
      float affinityBound=mRecord.getContactAffinity();
      affinity=Math.max(affinity,affinityBound);
      mRecord.setContactAffinity(affinity);
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + affinity);
    }
  }
;
}","private RankingReconsideration validatePeople(final NotificationRecord record){
  float affinity=NONE;
  Bundle extras=record.getNotification().extras;
  if (extras == null) {
    return null;
  }
  final String[] people=getExtraPeople(extras);
  if (people == null || people.length == 0) {
    return null;
  }
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.sbn.getKey());
  final LinkedList<String> pendingLookups=new LinkedList<String>();
  for (int personIdx=0; personIdx < people.length && personIdx < MAX_PEOPLE; personIdx++) {
    final String handle=people[personIdx];
    if (TextUtils.isEmpty(handle))     continue;
synchronized (mPeopleCache) {
      LookupResult lookupResult=mPeopleCache.get(handle);
      if (lookupResult == null || lookupResult.isExpired()) {
        pendingLookups.add(handle);
      }
 else {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + lookupResult.mId);
      }
      if (lookupResult != null) {
        affinity=Math.max(affinity,lookupResult.getAffinity());
      }
    }
  }
  record.setContactAffinity(affinity);
  if (pendingLookups.isEmpty()) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"" + affinity);
    return null;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + record.sbn.getKey());
  return new RankingReconsideration(record.getKey()){
    float mContactAffinity=NONE;
    @Override public void work(){
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + record.getKey());
      for (      final String handle : pendingLookups) {
        LookupResult lookupResult=null;
        final Uri uri=Uri.parse(handle);
        if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
        }
 else         if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
        }
 else         if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=searchContacts(uri);
        }
 else {
          lookupResult=new LookupResult();
          Slog.w(TAG,""String_Node_Str"" + handle);
        }
        if (lookupResult != null) {
synchronized (mPeopleCache) {
            mPeopleCache.put(handle,lookupResult);
          }
          mContactAffinity=Math.max(mContactAffinity,lookupResult.getAffinity());
        }
      }
    }
    @Override public void applyChangesLocked(    NotificationRecord operand){
      float affinityBound=operand.getContactAffinity();
      operand.setContactAffinity(Math.max(mContactAffinity,affinityBound));
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + operand.getContactAffinity());
    }
  }
;
}",0.8938447814451382
199237,"/** 
 * Removes a user and all data directories created for that user. This method should be called after the user's processes have been terminated.
 * @param userHandle the user's id
 */
public boolean removeUser(int userHandle){
  checkManageUsersPermission(""String_Node_Str"");
  final UserInfo user;
synchronized (mPackagesLock) {
    user=mUsers.get(userHandle);
    if (userHandle == 0 || user == null) {
      return false;
    }
    mRemovingUserIds.put(userHandle,true);
    try {
      mAppOpsService.removeUser(userHandle);
    }
 catch (    RemoteException e) {
      Log.w(LOG_TAG,""String_Node_Str"",e);
    }
    user.partial=true;
    user.flags|=UserInfo.FLAG_DISABLED;
    writeUserLocked(user);
  }
  if (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID && user.isManagedProfile()) {
    sendProfileRemovedBroadcast(user.profileGroupId,user.id);
  }
  if (DBG)   Slog.i(LOG_TAG,""String_Node_Str"" + userHandle);
  int res;
  try {
    res=ActivityManagerNative.getDefault().stopUser(userHandle,new IStopUserCallback.Stub(){
      @Override public void userStopped(      int userId){
        finishRemoveUser(userId);
      }
      @Override public void userStopAborted(      int userId){
      }
    }
);
  }
 catch (  RemoteException e) {
    return false;
  }
  return res == ActivityManager.USER_OP_SUCCESS;
}","/** 
 * Removes a user and all data directories created for that user. This method should be called after the user's processes have been terminated.
 * @param userHandle the user's id
 */
public boolean removeUser(int userHandle){
  checkManageUsersPermission(""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    final UserInfo user;
synchronized (mPackagesLock) {
      user=mUsers.get(userHandle);
      if (userHandle == 0 || user == null) {
        return false;
      }
      mRemovingUserIds.put(userHandle,true);
      try {
        mAppOpsService.removeUser(userHandle);
      }
 catch (      RemoteException e) {
        Log.w(LOG_TAG,""String_Node_Str"",e);
      }
      user.partial=true;
      user.flags|=UserInfo.FLAG_DISABLED;
      writeUserLocked(user);
    }
    if (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID && user.isManagedProfile()) {
      sendProfileRemovedBroadcast(user.profileGroupId,user.id);
    }
    if (DBG)     Slog.i(LOG_TAG,""String_Node_Str"" + userHandle);
    int res;
    try {
      res=ActivityManagerNative.getDefault().stopUser(userHandle,new IStopUserCallback.Stub(){
        @Override public void userStopped(        int userId){
          finishRemoveUser(userId);
        }
        @Override public void userStopAborted(        int userId){
        }
      }
);
    }
 catch (    RemoteException e) {
      return false;
    }
    return res == ActivityManager.USER_OP_SUCCESS;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.908005617977528
199238,"public RankingFuture process(NotificationRecord record){
  if (record == null || record.getNotification() == null) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    return null;
  }
  final Notification notification=record.getNotification();
  if ((notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.vibrate != null || (notification.defaults & Notification.DEFAULT_SOUND) != 0 || notification.sound != null || notification.fullScreenIntent != null) {
    record.setRecentlyIntusive(true);
  }
  return new RankingFuture(record,HANG_TIME_MS){
    @Override public void work(){
      mRecord.setRecentlyIntusive(false);
    }
  }
;
}","public RankingReconsideration process(NotificationRecord record){
  if (record == null || record.getNotification() == null) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    return null;
  }
  final Notification notification=record.getNotification();
  if ((notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.vibrate != null || (notification.defaults & Notification.DEFAULT_SOUND) != 0 || notification.sound != null || notification.fullScreenIntent != null) {
    record.setRecentlyIntusive(true);
  }
  return new RankingReconsideration(record.getKey(),HANG_TIME_MS){
    @Override public void work(){
    }
    @Override public void applyChangesLocked(    NotificationRecord record){
      record.setRecentlyIntusive(false);
    }
  }
;
}",0.8913805185704274
199239,"@Override public void work(){
  mRecord.setRecentlyIntusive(false);
}","@Override public void work(){
}",0.62
199240,"private void handleRankingReconsideration(Message message){
  if (!(message.obj instanceof RankingFuture))   return;
  RankingFuture future=(RankingFuture)message.obj;
  future.run();
  try {
    NotificationRecord record=future.get();
synchronized (mNotificationList) {
      int before=mNotificationList.indexOf(record);
      if (before != -1) {
        Collections.sort(mNotificationList,mRankingComparator);
        int after=mNotificationList.indexOf(record);
        if (before != after) {
          scheduleSendRankingUpdate();
        }
      }
    }
  }
 catch (  InterruptedException e) {
  }
catch (  ExecutionException e) {
  }
}","private void handleRankingReconsideration(Message message){
  if (!(message.obj instanceof RankingReconsideration))   return;
  RankingReconsideration recon=(RankingReconsideration)message.obj;
  recon.run();
  boolean orderChanged;
synchronized (mNotificationList) {
    final NotificationRecord record=mNotificationsByKey.get(recon.getKey());
    if (record == null) {
      return;
    }
    int before=findNotificationRecordIndexLocked(record);
    recon.applyChangesLocked(record);
    Collections.sort(mNotificationList,mRankingComparator);
    int after=findNotificationRecordIndexLocked(record);
    orderChanged=before != after;
  }
  if (orderChanged) {
    scheduleSendRankingUpdate();
  }
}",0.3541666666666667
199241,"void enqueueNotificationInternal(final String pkg,final String opPkg,final int callingUid,final int callingPid,final String tag,final int id,final Notification notification,int[] idOut,int incomingUserId){
  if (DBG) {
    Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=isUidSystem(callingUid) || (""String_Node_Str"".equals(pkg));
  final int userId=ActivityManager.handleIncomingUser(callingPid,callingUid,incomingUserId,true,false,""String_Node_Str"",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,""String_Node_Str"" + count + ""String_Node_Str""+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals(""String_Node_Str"") || Log.isLoggable(""String_Node_Str"",Log.VERBOSE)) {
    EventLogTags.writeNotificationEnqueue(callingUid,callingPid,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
    }
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
      if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
        if (notification.priority < Notification.PRIORITY_MAX) {
          notification.priority=Notification.PRIORITY_MAX;
        }
      }
 else       if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
        if (notification.priority < Notification.PRIORITY_HIGH) {
          notification.priority=Notification.PRIORITY_HIGH;
        }
      }
      int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
      final StatusBarNotification n=new StatusBarNotification(pkg,opPkg,id,tag,callingUid,callingPid,score,notification,user);
      NotificationRecord r=new NotificationRecord(n);
      if (!mSignalExtractors.isEmpty()) {
        for (        NotificationSignalExtractor extractor : mSignalExtractors) {
          try {
            RankingFuture future=extractor.process(r);
            scheduleRankingReconsideration(future);
          }
 catch (          Throwable t) {
            Slog.w(TAG,""String_Node_Str"",t);
          }
        }
      }
      if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
        if (!isSystemNotification) {
          score=JUNK_SCORE;
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
        }
      }
      if (score < SCORE_DISPLAY_THRESHOLD) {
        return;
      }
      final boolean intercept=mZenModeHelper.shouldIntercept(pkg,notification);
      notification.extras.putBoolean(EXTRA_INTERCEPT,intercept);
      final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD) && !intercept;
      if (DBG || intercept)       Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ canInterrupt+ ""String_Node_Str""+ intercept);
synchronized (mNotificationList) {
        NotificationRecord old=null;
        int index=indexOfNotificationLocked(n.getKey());
        if (index < 0) {
          mNotificationList.add(r);
          mUsageStats.registerPostedByApp(r);
        }
 else {
          old=mNotificationList.get(index);
          mNotificationList.set(index,r);
          mUsageStats.registerUpdatedByApp(r,old);
          notification.flags|=old.getNotification().flags & Notification.FLAG_FOREGROUND_SERVICE;
          mNotificationsByKey.remove(old.sbn.getKey());
        }
        mNotificationsByKey.put(n.getKey(),r);
        Collections.sort(mNotificationList,mRankingComparator);
        if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
          notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
        }
        final int currentUser;
        final long token=Binder.clearCallingIdentity();
        try {
          currentUser=ActivityManager.getCurrentUser();
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        if (notification.icon != 0) {
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.updateNotification(n);
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
 else {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.addNotification(n);
              if ((n.getNotification().flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
                mAttentionLight.pulse();
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
          if (currentUser == userId) {
            sendAccessibilityEvent(notification,pkg);
          }
          mListeners.notifyPostedLocked(r.sbn,cloneNotificationListLocked());
        }
 else {
          Slog.e(TAG,""String_Node_Str"" + notification);
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.removeNotification(r.getKey());
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
            mListeners.notifyRemovedLocked(r.sbn,cloneNotificationListLocked());
          }
          Slog.e(TAG,""String_Node_Str"" + n.getPackageName());
        }
        if (!mDisableNotificationAlerts && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.getUserId() == UserHandle.USER_ALL || (r.getUserId() == userId && r.getUserId() == currentUser) || mUserProfiles.isCurrentProfile(r.getUserId()))&& canInterrupt&& mSystemReady&& mAudioManager != null) {
          if (DBG)           Slog.v(TAG,""String_Node_Str"");
          final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
          Uri soundUri=null;
          boolean hasValidSound=false;
          if (useDefaultSound) {
            soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
            ContentResolver resolver=getContext().getContentResolver();
            hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
          }
 else           if (notification.sound != null) {
            soundUri=notification.sound;
            hasValidSound=(soundUri != null);
          }
          if (hasValidSound) {
            boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
            int audioStreamType;
            if (notification.audioStreamType >= 0) {
              audioStreamType=notification.audioStreamType;
            }
 else {
              audioStreamType=DEFAULT_STREAM_TYPE;
            }
            mSoundNotification=r;
            if ((mAudioManager.getStreamVolume(audioStreamType) != 0) && !mAudioManager.isAudioFocusExclusive()) {
              final long identity=Binder.clearCallingIdentity();
              try {
                final IRingtonePlayer player=mAudioManager.getRingtonePlayer();
                if (player != null) {
                  if (DBG)                   Slog.v(TAG,""String_Node_Str"" + soundUri + ""String_Node_Str""+ audioStreamType);
                  player.playAsync(soundUri,user,looping,audioStreamType);
                }
              }
 catch (              RemoteException e) {
              }
 finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
          }
          final boolean hasCustomVibrate=notification.vibrate != null;
          final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
          final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
          if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotification=r;
            if (useDefaultVibrate || convertSoundToVibration) {
              long identity=Binder.clearCallingIdentity();
              try {
                mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
              }
  finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
 else             if (notification.vibrate.length > 1) {
              mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
            }
          }
        }
        mLights.remove(old);
        if (mLedNotification == old) {
          mLedNotification=null;
        }
        if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
          mLights.add(r);
          updateLightsLocked();
        }
 else {
          if (old != null && ((old.getFlags() & Notification.FLAG_SHOW_LIGHTS) != 0)) {
            updateLightsLocked();
          }
        }
      }
    }
  }
);
  idOut[0]=id;
}","void enqueueNotificationInternal(final String pkg,final String opPkg,final int callingUid,final int callingPid,final String tag,final int id,final Notification notification,int[] idOut,int incomingUserId){
  if (DBG) {
    Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=isUidSystem(callingUid) || (""String_Node_Str"".equals(pkg));
  final int userId=ActivityManager.handleIncomingUser(callingPid,callingUid,incomingUserId,true,false,""String_Node_Str"",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,""String_Node_Str"" + count + ""String_Node_Str""+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals(""String_Node_Str"") || Log.isLoggable(""String_Node_Str"",Log.VERBOSE)) {
    EventLogTags.writeNotificationEnqueue(callingUid,callingPid,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
    }
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
      if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
        if (notification.priority < Notification.PRIORITY_MAX) {
          notification.priority=Notification.PRIORITY_MAX;
        }
      }
 else       if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
        if (notification.priority < Notification.PRIORITY_HIGH) {
          notification.priority=Notification.PRIORITY_HIGH;
        }
      }
      int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
      final StatusBarNotification n=new StatusBarNotification(pkg,opPkg,id,tag,callingUid,callingPid,score,notification,user);
      NotificationRecord r=new NotificationRecord(n);
      if (!mSignalExtractors.isEmpty()) {
        for (        NotificationSignalExtractor extractor : mSignalExtractors) {
          try {
            RankingReconsideration recon=extractor.process(r);
            scheduleRankingReconsideration(recon);
          }
 catch (          Throwable t) {
            Slog.w(TAG,""String_Node_Str"",t);
          }
        }
      }
      if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
        if (!isSystemNotification) {
          score=JUNK_SCORE;
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
        }
      }
      if (score < SCORE_DISPLAY_THRESHOLD) {
        return;
      }
      final boolean intercept=mZenModeHelper.shouldIntercept(pkg,notification);
      notification.extras.putBoolean(EXTRA_INTERCEPT,intercept);
      final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD) && !intercept;
      if (DBG || intercept)       Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ canInterrupt+ ""String_Node_Str""+ intercept);
synchronized (mNotificationList) {
        NotificationRecord old=null;
        int index=indexOfNotificationLocked(n.getKey());
        if (index < 0) {
          mNotificationList.add(r);
          mUsageStats.registerPostedByApp(r);
        }
 else {
          old=mNotificationList.get(index);
          mNotificationList.set(index,r);
          mUsageStats.registerUpdatedByApp(r,old);
          notification.flags|=old.getNotification().flags & Notification.FLAG_FOREGROUND_SERVICE;
          mNotificationsByKey.remove(old.sbn.getKey());
        }
        mNotificationsByKey.put(n.getKey(),r);
        Collections.sort(mNotificationList,mRankingComparator);
        if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
          notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
        }
        final int currentUser;
        final long token=Binder.clearCallingIdentity();
        try {
          currentUser=ActivityManager.getCurrentUser();
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        if (notification.icon != 0) {
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.updateNotification(n);
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
 else {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.addNotification(n);
              if ((n.getNotification().flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
                mAttentionLight.pulse();
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
          if (currentUser == userId) {
            sendAccessibilityEvent(notification,pkg);
          }
          mListeners.notifyPostedLocked(r.sbn,cloneNotificationListLocked());
        }
 else {
          Slog.e(TAG,""String_Node_Str"" + notification);
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.removeNotification(r.getKey());
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
            mListeners.notifyRemovedLocked(r.sbn,cloneNotificationListLocked());
          }
          Slog.e(TAG,""String_Node_Str"" + n.getPackageName());
        }
        if (!mDisableNotificationAlerts && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.getUserId() == UserHandle.USER_ALL || (r.getUserId() == userId && r.getUserId() == currentUser) || mUserProfiles.isCurrentProfile(r.getUserId()))&& canInterrupt&& mSystemReady&& mAudioManager != null) {
          if (DBG)           Slog.v(TAG,""String_Node_Str"");
          final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
          Uri soundUri=null;
          boolean hasValidSound=false;
          if (useDefaultSound) {
            soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
            ContentResolver resolver=getContext().getContentResolver();
            hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
          }
 else           if (notification.sound != null) {
            soundUri=notification.sound;
            hasValidSound=(soundUri != null);
          }
          if (hasValidSound) {
            boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
            int audioStreamType;
            if (notification.audioStreamType >= 0) {
              audioStreamType=notification.audioStreamType;
            }
 else {
              audioStreamType=DEFAULT_STREAM_TYPE;
            }
            mSoundNotification=r;
            if ((mAudioManager.getStreamVolume(audioStreamType) != 0) && !mAudioManager.isAudioFocusExclusive()) {
              final long identity=Binder.clearCallingIdentity();
              try {
                final IRingtonePlayer player=mAudioManager.getRingtonePlayer();
                if (player != null) {
                  if (DBG)                   Slog.v(TAG,""String_Node_Str"" + soundUri + ""String_Node_Str""+ audioStreamType);
                  player.playAsync(soundUri,user,looping,audioStreamType);
                }
              }
 catch (              RemoteException e) {
              }
 finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
          }
          final boolean hasCustomVibrate=notification.vibrate != null;
          final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
          final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
          if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotification=r;
            if (useDefaultVibrate || convertSoundToVibration) {
              long identity=Binder.clearCallingIdentity();
              try {
                mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
              }
  finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
 else             if (notification.vibrate.length > 1) {
              mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
            }
          }
        }
        mLights.remove(old);
        if (mLedNotification == old) {
          mLedNotification=null;
        }
        if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
          mLights.add(r);
          updateLightsLocked();
        }
 else {
          if (old != null && ((old.getFlags() & Notification.FLAG_SHOW_LIGHTS) != 0)) {
            updateLightsLocked();
          }
        }
      }
    }
  }
);
  idOut[0]=id;
}",0.997768189257551
199242,"private void scheduleRankingReconsideration(RankingFuture future){
  if (future != null) {
    Message m=Message.obtain(mRankingHandler,MESSAGE_RECONSIDER_RANKING,future);
    long delay=future.getDelay(TimeUnit.MILLISECONDS);
    mRankingHandler.sendMessageDelayed(m,delay);
  }
}","private void scheduleRankingReconsideration(RankingReconsideration recon){
  if (recon != null) {
    Message m=Message.obtain(mRankingHandler,MESSAGE_RECONSIDER_RANKING,recon);
    long delay=recon.getDelay(TimeUnit.MILLISECONDS);
    mRankingHandler.sendMessageDelayed(m,delay);
  }
}",0.8536155202821869
199243,"/** 
 * Called once per notification that is posted or updated.
 * @return null if the work is done, or a future if there is more to do. The{@link RankingFuture} will be run on a worker thread, and if notifications are re-orderedby that execution, the  {@link NotificationManagerService} may send order updateevents to the  {@link android.service.notification.NotificationListenerService}s.
 */
public RankingFuture process(NotificationManagerService.NotificationRecord notification);","/** 
 * Called once per notification that is posted or updated.
 * @return null if the work is done, or a future if there is more to do. The{@link RankingReconsideration} will be run on a worker thread, and if notificationsare re-ordered by that execution, the  {@link NotificationManagerService} may send orderupdate events to the  {@link android.service.notification.NotificationListenerService}s.
 */
public RankingReconsideration process(NotificationRecord notification);",0.9113660062565172
199244,"public RankingFuture process(NotificationManagerService.NotificationRecord record){
  if (!mEnabled) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  if (record == null || record.getNotification() == null) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  return validatePeople(record);
}","public RankingReconsideration process(NotificationRecord record){
  if (!mEnabled) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  if (record == null || record.getNotification() == null) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  return validatePeople(record);
}",0.926829268292683
199245,"@Override public void work(){
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + mRecord.sbn.getKey());
  float affinity=NONE;
  for (  final String handle : pendingLookups) {
    LookupResult lookupResult=null;
    final Uri uri=Uri.parse(handle);
    if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
    }
 else     if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
    }
 else     if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=searchContacts(uri);
    }
 else {
      lookupResult=new LookupResult();
      Slog.w(TAG,""String_Node_Str"" + handle);
    }
    if (lookupResult != null) {
synchronized (mPeopleCache) {
        mPeopleCache.put(handle,lookupResult);
      }
      affinity=Math.max(affinity,lookupResult.getAffinity());
    }
  }
  float affinityBound=mRecord.getContactAffinity();
  affinity=Math.max(affinity,affinityBound);
  mRecord.setContactAffinity(affinity);
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + affinity);
}","@Override public void work(){
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.getKey());
  for (  final String handle : pendingLookups) {
    LookupResult lookupResult=null;
    final Uri uri=Uri.parse(handle);
    if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
    }
 else     if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
    }
 else     if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=searchContacts(uri);
    }
 else {
      lookupResult=new LookupResult();
      Slog.w(TAG,""String_Node_Str"" + handle);
    }
    if (lookupResult != null) {
synchronized (mPeopleCache) {
        mPeopleCache.put(handle,lookupResult);
      }
      mContactAffinity=Math.max(mContactAffinity,lookupResult.getAffinity());
    }
  }
}",0.8940979489326077
199246,"private RankingFuture validatePeople(NotificationRecord record){
  float affinity=NONE;
  Bundle extras=record.getNotification().extras;
  if (extras == null) {
    return null;
  }
  final String[] people=getExtraPeople(extras);
  if (people == null || people.length == 0) {
    return null;
  }
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.sbn.getKey());
  final LinkedList<String> pendingLookups=new LinkedList<String>();
  for (int personIdx=0; personIdx < people.length && personIdx < MAX_PEOPLE; personIdx++) {
    final String handle=people[personIdx];
    if (TextUtils.isEmpty(handle))     continue;
synchronized (mPeopleCache) {
      LookupResult lookupResult=mPeopleCache.get(handle);
      if (lookupResult == null || lookupResult.isExpired()) {
        pendingLookups.add(handle);
      }
 else {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + lookupResult.mId);
      }
      if (lookupResult != null) {
        affinity=Math.max(affinity,lookupResult.getAffinity());
      }
    }
  }
  record.setContactAffinity(affinity);
  if (pendingLookups.isEmpty()) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"" + affinity);
    return null;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + record.sbn.getKey());
  return new RankingFuture(record){
    @Override public void work(){
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + mRecord.sbn.getKey());
      float affinity=NONE;
      for (      final String handle : pendingLookups) {
        LookupResult lookupResult=null;
        final Uri uri=Uri.parse(handle);
        if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
        }
 else         if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
        }
 else         if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=searchContacts(uri);
        }
 else {
          lookupResult=new LookupResult();
          Slog.w(TAG,""String_Node_Str"" + handle);
        }
        if (lookupResult != null) {
synchronized (mPeopleCache) {
            mPeopleCache.put(handle,lookupResult);
          }
          affinity=Math.max(affinity,lookupResult.getAffinity());
        }
      }
      float affinityBound=mRecord.getContactAffinity();
      affinity=Math.max(affinity,affinityBound);
      mRecord.setContactAffinity(affinity);
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + affinity);
    }
  }
;
}","private RankingReconsideration validatePeople(final NotificationRecord record){
  float affinity=NONE;
  Bundle extras=record.getNotification().extras;
  if (extras == null) {
    return null;
  }
  final String[] people=getExtraPeople(extras);
  if (people == null || people.length == 0) {
    return null;
  }
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.sbn.getKey());
  final LinkedList<String> pendingLookups=new LinkedList<String>();
  for (int personIdx=0; personIdx < people.length && personIdx < MAX_PEOPLE; personIdx++) {
    final String handle=people[personIdx];
    if (TextUtils.isEmpty(handle))     continue;
synchronized (mPeopleCache) {
      LookupResult lookupResult=mPeopleCache.get(handle);
      if (lookupResult == null || lookupResult.isExpired()) {
        pendingLookups.add(handle);
      }
 else {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + lookupResult.mId);
      }
      if (lookupResult != null) {
        affinity=Math.max(affinity,lookupResult.getAffinity());
      }
    }
  }
  record.setContactAffinity(affinity);
  if (pendingLookups.isEmpty()) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"" + affinity);
    return null;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + record.sbn.getKey());
  return new RankingReconsideration(record.getKey()){
    float mContactAffinity=NONE;
    @Override public void work(){
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + record.getKey());
      for (      final String handle : pendingLookups) {
        LookupResult lookupResult=null;
        final Uri uri=Uri.parse(handle);
        if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
        }
 else         if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
        }
 else         if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=searchContacts(uri);
        }
 else {
          lookupResult=new LookupResult();
          Slog.w(TAG,""String_Node_Str"" + handle);
        }
        if (lookupResult != null) {
synchronized (mPeopleCache) {
            mPeopleCache.put(handle,lookupResult);
          }
          mContactAffinity=Math.max(mContactAffinity,lookupResult.getAffinity());
        }
      }
    }
    @Override public void applyChangesLocked(    NotificationRecord operand){
      float affinityBound=operand.getContactAffinity();
      operand.setContactAffinity(Math.max(mContactAffinity,affinityBound));
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + operand.getContactAffinity());
    }
  }
;
}",0.8938447814451382
199247,"public RankingFuture process(NotificationRecord record){
  if (record == null || record.getNotification() == null) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    return null;
  }
  final Notification notification=record.getNotification();
  if ((notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.vibrate != null || (notification.defaults & Notification.DEFAULT_SOUND) != 0 || notification.sound != null || notification.fullScreenIntent != null) {
    record.setRecentlyIntusive(true);
  }
  return new RankingFuture(record,HANG_TIME_MS){
    @Override public void work(){
      mRecord.setRecentlyIntusive(false);
    }
  }
;
}","public RankingReconsideration process(NotificationRecord record){
  if (record == null || record.getNotification() == null) {
    if (DBG)     Slog.d(TAG,""String_Node_Str"");
    return null;
  }
  final Notification notification=record.getNotification();
  if ((notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.vibrate != null || (notification.defaults & Notification.DEFAULT_SOUND) != 0 || notification.sound != null || notification.fullScreenIntent != null) {
    record.setRecentlyIntusive(true);
  }
  return new RankingReconsideration(record.getKey(),HANG_TIME_MS){
    @Override public void work(){
    }
    @Override public void applyChangesLocked(    NotificationRecord record){
      record.setRecentlyIntusive(false);
    }
  }
;
}",0.8913805185704274
199248,"@Override public void work(){
  mRecord.setRecentlyIntusive(false);
}","@Override public void work(){
}",0.62
199249,"private void handleRankingReconsideration(Message message){
  if (!(message.obj instanceof RankingFuture))   return;
  RankingFuture future=(RankingFuture)message.obj;
  future.run();
  try {
    NotificationRecord record=future.get();
synchronized (mNotificationList) {
      int before=mNotificationList.indexOf(record);
      if (before != -1) {
        Collections.sort(mNotificationList,mRankingComparator);
        int after=mNotificationList.indexOf(record);
        if (before != after) {
          scheduleSendRankingUpdate();
        }
      }
    }
  }
 catch (  InterruptedException e) {
  }
catch (  ExecutionException e) {
  }
}","private void handleRankingReconsideration(Message message){
  if (!(message.obj instanceof RankingReconsideration))   return;
  RankingReconsideration recon=(RankingReconsideration)message.obj;
  recon.run();
  boolean orderChanged;
synchronized (mNotificationList) {
    final NotificationRecord record=mNotificationsByKey.get(recon.getKey());
    if (record == null) {
      return;
    }
    int before=findNotificationRecordIndexLocked(record);
    recon.applyChangesLocked(record);
    Collections.sort(mNotificationList,mRankingComparator);
    int after=findNotificationRecordIndexLocked(record);
    orderChanged=before != after;
  }
  if (orderChanged) {
    scheduleSendRankingUpdate();
  }
}",0.3541666666666667
199250,"void enqueueNotificationInternal(final String pkg,final String opPkg,final int callingUid,final int callingPid,final String tag,final int id,final Notification notification,int[] idOut,int incomingUserId){
  if (DBG) {
    Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=isUidSystem(callingUid) || (""String_Node_Str"".equals(pkg));
  final int userId=ActivityManager.handleIncomingUser(callingPid,callingUid,incomingUserId,true,false,""String_Node_Str"",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,""String_Node_Str"" + count + ""String_Node_Str""+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals(""String_Node_Str"") || Log.isLoggable(""String_Node_Str"",Log.VERBOSE)) {
    EventLogTags.writeNotificationEnqueue(callingUid,callingPid,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
    }
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
      if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
        if (notification.priority < Notification.PRIORITY_MAX) {
          notification.priority=Notification.PRIORITY_MAX;
        }
      }
 else       if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
        if (notification.priority < Notification.PRIORITY_HIGH) {
          notification.priority=Notification.PRIORITY_HIGH;
        }
      }
      int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
      final StatusBarNotification n=new StatusBarNotification(pkg,opPkg,id,tag,callingUid,callingPid,score,notification,user);
      NotificationRecord r=new NotificationRecord(n);
      if (!mSignalExtractors.isEmpty()) {
        for (        NotificationSignalExtractor extractor : mSignalExtractors) {
          try {
            RankingFuture future=extractor.process(r);
            scheduleRankingReconsideration(future);
          }
 catch (          Throwable t) {
            Slog.w(TAG,""String_Node_Str"",t);
          }
        }
      }
      if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
        if (!isSystemNotification) {
          score=JUNK_SCORE;
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
        }
      }
      if (score < SCORE_DISPLAY_THRESHOLD) {
        return;
      }
      final boolean intercept=mZenModeHelper.shouldIntercept(pkg,notification);
      notification.extras.putBoolean(EXTRA_INTERCEPT,intercept);
      final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD) && !intercept;
      if (DBG || intercept)       Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ canInterrupt+ ""String_Node_Str""+ intercept);
synchronized (mNotificationList) {
        NotificationRecord old=null;
        int index=indexOfNotificationLocked(n.getKey());
        if (index < 0) {
          mNotificationList.add(r);
          mUsageStats.registerPostedByApp(r);
        }
 else {
          old=mNotificationList.get(index);
          mNotificationList.set(index,r);
          mUsageStats.registerUpdatedByApp(r,old);
          notification.flags|=old.getNotification().flags & Notification.FLAG_FOREGROUND_SERVICE;
          mNotificationsByKey.remove(old.sbn.getKey());
        }
        mNotificationsByKey.put(n.getKey(),r);
        Collections.sort(mNotificationList,mRankingComparator);
        if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
          notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
        }
        final int currentUser;
        final long token=Binder.clearCallingIdentity();
        try {
          currentUser=ActivityManager.getCurrentUser();
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        if (notification.icon != 0) {
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.updateNotification(n);
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
 else {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.addNotification(n);
              if ((n.getNotification().flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
                mAttentionLight.pulse();
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
          if (currentUser == userId) {
            sendAccessibilityEvent(notification,pkg);
          }
          mListeners.notifyPostedLocked(r.sbn,cloneNotificationListLocked());
        }
 else {
          Slog.e(TAG,""String_Node_Str"" + notification);
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.removeNotification(r.getKey());
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
            mListeners.notifyRemovedLocked(r.sbn,cloneNotificationListLocked());
          }
          Slog.e(TAG,""String_Node_Str"" + n.getPackageName());
        }
        if (!mDisableNotificationAlerts && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.getUserId() == UserHandle.USER_ALL || (r.getUserId() == userId && r.getUserId() == currentUser) || mUserProfiles.isCurrentProfile(r.getUserId()))&& canInterrupt&& mSystemReady&& mAudioManager != null) {
          if (DBG)           Slog.v(TAG,""String_Node_Str"");
          final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
          Uri soundUri=null;
          boolean hasValidSound=false;
          if (useDefaultSound) {
            soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
            ContentResolver resolver=getContext().getContentResolver();
            hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
          }
 else           if (notification.sound != null) {
            soundUri=notification.sound;
            hasValidSound=(soundUri != null);
          }
          if (hasValidSound) {
            boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
            int audioStreamType;
            if (notification.audioStreamType >= 0) {
              audioStreamType=notification.audioStreamType;
            }
 else {
              audioStreamType=DEFAULT_STREAM_TYPE;
            }
            mSoundNotification=r;
            if ((mAudioManager.getStreamVolume(audioStreamType) != 0) && !mAudioManager.isAudioFocusExclusive()) {
              final long identity=Binder.clearCallingIdentity();
              try {
                final IRingtonePlayer player=mAudioManager.getRingtonePlayer();
                if (player != null) {
                  if (DBG)                   Slog.v(TAG,""String_Node_Str"" + soundUri + ""String_Node_Str""+ audioStreamType);
                  player.playAsync(soundUri,user,looping,audioStreamType);
                }
              }
 catch (              RemoteException e) {
              }
 finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
          }
          final boolean hasCustomVibrate=notification.vibrate != null;
          final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
          final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
          if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotification=r;
            if (useDefaultVibrate || convertSoundToVibration) {
              long identity=Binder.clearCallingIdentity();
              try {
                mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
              }
  finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
 else             if (notification.vibrate.length > 1) {
              mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
            }
          }
        }
        mLights.remove(old);
        if (mLedNotification == old) {
          mLedNotification=null;
        }
        if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
          mLights.add(r);
          updateLightsLocked();
        }
 else {
          if (old != null && ((old.getFlags() & Notification.FLAG_SHOW_LIGHTS) != 0)) {
            updateLightsLocked();
          }
        }
      }
    }
  }
);
  idOut[0]=id;
}","void enqueueNotificationInternal(final String pkg,final String opPkg,final int callingUid,final int callingPid,final String tag,final int id,final Notification notification,int[] idOut,int incomingUserId){
  if (DBG) {
    Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=isUidSystem(callingUid) || (""String_Node_Str"".equals(pkg));
  final int userId=ActivityManager.handleIncomingUser(callingPid,callingUid,incomingUserId,true,false,""String_Node_Str"",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.sbn.getPackageName().equals(pkg) && r.sbn.getUserId() == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,""String_Node_Str"" + count + ""String_Node_Str""+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals(""String_Node_Str"") || Log.isLoggable(""String_Node_Str"",Log.VERBOSE)) {
    EventLogTags.writeNotificationEnqueue(callingUid,callingPid,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + pkg + ""String_Node_Str""+ id+ ""String_Node_Str""+ notification);
    }
  }
  mHandler.post(new Runnable(){
    @Override public void run(){
      notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
      if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
        if (notification.priority < Notification.PRIORITY_MAX) {
          notification.priority=Notification.PRIORITY_MAX;
        }
      }
 else       if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
        if (notification.priority < Notification.PRIORITY_HIGH) {
          notification.priority=Notification.PRIORITY_HIGH;
        }
      }
      int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
      final StatusBarNotification n=new StatusBarNotification(pkg,opPkg,id,tag,callingUid,callingPid,score,notification,user);
      NotificationRecord r=new NotificationRecord(n);
      if (!mSignalExtractors.isEmpty()) {
        for (        NotificationSignalExtractor extractor : mSignalExtractors) {
          try {
            RankingReconsideration recon=extractor.process(r);
            scheduleRankingReconsideration(recon);
          }
 catch (          Throwable t) {
            Slog.w(TAG,""String_Node_Str"",t);
          }
        }
      }
      if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
        if (!isSystemNotification) {
          score=JUNK_SCORE;
          Slog.e(TAG,""String_Node_Str"" + pkg + ""String_Node_Str"");
        }
      }
      if (score < SCORE_DISPLAY_THRESHOLD) {
        return;
      }
      final boolean intercept=mZenModeHelper.shouldIntercept(pkg,notification);
      notification.extras.putBoolean(EXTRA_INTERCEPT,intercept);
      final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD) && !intercept;
      if (DBG || intercept)       Slog.v(TAG,""String_Node_Str"" + pkg + ""String_Node_Str""+ canInterrupt+ ""String_Node_Str""+ intercept);
synchronized (mNotificationList) {
        NotificationRecord old=null;
        int index=indexOfNotificationLocked(n.getKey());
        if (index < 0) {
          mNotificationList.add(r);
          mUsageStats.registerPostedByApp(r);
        }
 else {
          old=mNotificationList.get(index);
          mNotificationList.set(index,r);
          mUsageStats.registerUpdatedByApp(r,old);
          notification.flags|=old.getNotification().flags & Notification.FLAG_FOREGROUND_SERVICE;
          mNotificationsByKey.remove(old.sbn.getKey());
        }
        mNotificationsByKey.put(n.getKey(),r);
        Collections.sort(mNotificationList,mRankingComparator);
        if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
          notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
        }
        final int currentUser;
        final long token=Binder.clearCallingIdentity();
        try {
          currentUser=ActivityManager.getCurrentUser();
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        if (notification.icon != 0) {
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.updateNotification(n);
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
 else {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.addNotification(n);
              if ((n.getNotification().flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
                mAttentionLight.pulse();
              }
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
          }
          if (currentUser == userId) {
            sendAccessibilityEvent(notification,pkg);
          }
          mListeners.notifyPostedLocked(r.sbn,cloneNotificationListLocked());
        }
 else {
          Slog.e(TAG,""String_Node_Str"" + notification);
          if (old != null && !old.isCanceled) {
            final long identity=Binder.clearCallingIdentity();
            try {
              mStatusBar.removeNotification(r.getKey());
            }
  finally {
              Binder.restoreCallingIdentity(identity);
            }
            mListeners.notifyRemovedLocked(r.sbn,cloneNotificationListLocked());
          }
          Slog.e(TAG,""String_Node_Str"" + n.getPackageName());
        }
        if (!mDisableNotificationAlerts && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.getUserId() == UserHandle.USER_ALL || (r.getUserId() == userId && r.getUserId() == currentUser) || mUserProfiles.isCurrentProfile(r.getUserId()))&& canInterrupt&& mSystemReady&& mAudioManager != null) {
          if (DBG)           Slog.v(TAG,""String_Node_Str"");
          final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
          Uri soundUri=null;
          boolean hasValidSound=false;
          if (useDefaultSound) {
            soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
            ContentResolver resolver=getContext().getContentResolver();
            hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
          }
 else           if (notification.sound != null) {
            soundUri=notification.sound;
            hasValidSound=(soundUri != null);
          }
          if (hasValidSound) {
            boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
            int audioStreamType;
            if (notification.audioStreamType >= 0) {
              audioStreamType=notification.audioStreamType;
            }
 else {
              audioStreamType=DEFAULT_STREAM_TYPE;
            }
            mSoundNotification=r;
            if ((mAudioManager.getStreamVolume(audioStreamType) != 0) && !mAudioManager.isAudioFocusExclusive()) {
              final long identity=Binder.clearCallingIdentity();
              try {
                final IRingtonePlayer player=mAudioManager.getRingtonePlayer();
                if (player != null) {
                  if (DBG)                   Slog.v(TAG,""String_Node_Str"" + soundUri + ""String_Node_Str""+ audioStreamType);
                  player.playAsync(soundUri,user,looping,audioStreamType);
                }
              }
 catch (              RemoteException e) {
              }
 finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
          }
          final boolean hasCustomVibrate=notification.vibrate != null;
          final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
          final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
          if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotification=r;
            if (useDefaultVibrate || convertSoundToVibration) {
              long identity=Binder.clearCallingIdentity();
              try {
                mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
              }
  finally {
                Binder.restoreCallingIdentity(identity);
              }
            }
 else             if (notification.vibrate.length > 1) {
              mVibrator.vibrate(r.sbn.getUid(),r.sbn.getOpPkg(),notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1,notification.audioStreamType);
            }
          }
        }
        mLights.remove(old);
        if (mLedNotification == old) {
          mLedNotification=null;
        }
        if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
          mLights.add(r);
          updateLightsLocked();
        }
 else {
          if (old != null && ((old.getFlags() & Notification.FLAG_SHOW_LIGHTS) != 0)) {
            updateLightsLocked();
          }
        }
      }
    }
  }
);
  idOut[0]=id;
}",0.997768189257551
199251,"private void scheduleRankingReconsideration(RankingFuture future){
  if (future != null) {
    Message m=Message.obtain(mRankingHandler,MESSAGE_RECONSIDER_RANKING,future);
    long delay=future.getDelay(TimeUnit.MILLISECONDS);
    mRankingHandler.sendMessageDelayed(m,delay);
  }
}","private void scheduleRankingReconsideration(RankingReconsideration recon){
  if (recon != null) {
    Message m=Message.obtain(mRankingHandler,MESSAGE_RECONSIDER_RANKING,recon);
    long delay=recon.getDelay(TimeUnit.MILLISECONDS);
    mRankingHandler.sendMessageDelayed(m,delay);
  }
}",0.8536155202821869
199252,"/** 
 * Called once per notification that is posted or updated.
 * @return null if the work is done, or a future if there is more to do. The{@link RankingFuture} will be run on a worker thread, and if notifications are re-orderedby that execution, the  {@link NotificationManagerService} may send order updateevents to the  {@link android.service.notification.NotificationListenerService}s.
 */
public RankingFuture process(NotificationManagerService.NotificationRecord notification);","/** 
 * Called once per notification that is posted or updated.
 * @return null if the work is done, or a future if there is more to do. The{@link RankingReconsideration} will be run on a worker thread, and if notificationsare re-ordered by that execution, the  {@link NotificationManagerService} may send orderupdate events to the  {@link android.service.notification.NotificationListenerService}s.
 */
public RankingReconsideration process(NotificationRecord notification);",0.9113660062565172
199253,"public RankingFuture process(NotificationManagerService.NotificationRecord record){
  if (!mEnabled) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  if (record == null || record.getNotification() == null) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  return validatePeople(record);
}","public RankingReconsideration process(NotificationRecord record){
  if (!mEnabled) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  if (record == null || record.getNotification() == null) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"");
    return null;
  }
  return validatePeople(record);
}",0.926829268292683
199254,"@Override public void work(){
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + mRecord.sbn.getKey());
  float affinity=NONE;
  for (  final String handle : pendingLookups) {
    LookupResult lookupResult=null;
    final Uri uri=Uri.parse(handle);
    if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
    }
 else     if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
    }
 else     if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=searchContacts(uri);
    }
 else {
      lookupResult=new LookupResult();
      Slog.w(TAG,""String_Node_Str"" + handle);
    }
    if (lookupResult != null) {
synchronized (mPeopleCache) {
        mPeopleCache.put(handle,lookupResult);
      }
      affinity=Math.max(affinity,lookupResult.getAffinity());
    }
  }
  float affinityBound=mRecord.getContactAffinity();
  affinity=Math.max(affinity,affinityBound);
  mRecord.setContactAffinity(affinity);
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + affinity);
}","@Override public void work(){
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.getKey());
  for (  final String handle : pendingLookups) {
    LookupResult lookupResult=null;
    final Uri uri=Uri.parse(handle);
    if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
    }
 else     if (""String_Node_Str"".equals(uri.getScheme())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
    }
 else     if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
      if (DEBUG)       Slog.d(TAG,""String_Node_Str"" + handle);
      lookupResult=searchContacts(uri);
    }
 else {
      lookupResult=new LookupResult();
      Slog.w(TAG,""String_Node_Str"" + handle);
    }
    if (lookupResult != null) {
synchronized (mPeopleCache) {
        mPeopleCache.put(handle,lookupResult);
      }
      mContactAffinity=Math.max(mContactAffinity,lookupResult.getAffinity());
    }
  }
}",0.8940979489326077
199255,"private RankingFuture validatePeople(NotificationRecord record){
  float affinity=NONE;
  Bundle extras=record.getNotification().extras;
  if (extras == null) {
    return null;
  }
  final String[] people=getExtraPeople(extras);
  if (people == null || people.length == 0) {
    return null;
  }
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.sbn.getKey());
  final LinkedList<String> pendingLookups=new LinkedList<String>();
  for (int personIdx=0; personIdx < people.length && personIdx < MAX_PEOPLE; personIdx++) {
    final String handle=people[personIdx];
    if (TextUtils.isEmpty(handle))     continue;
synchronized (mPeopleCache) {
      LookupResult lookupResult=mPeopleCache.get(handle);
      if (lookupResult == null || lookupResult.isExpired()) {
        pendingLookups.add(handle);
      }
 else {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + lookupResult.mId);
      }
      if (lookupResult != null) {
        affinity=Math.max(affinity,lookupResult.getAffinity());
      }
    }
  }
  record.setContactAffinity(affinity);
  if (pendingLookups.isEmpty()) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"" + affinity);
    return null;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + record.sbn.getKey());
  return new RankingFuture(record){
    @Override public void work(){
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + mRecord.sbn.getKey());
      float affinity=NONE;
      for (      final String handle : pendingLookups) {
        LookupResult lookupResult=null;
        final Uri uri=Uri.parse(handle);
        if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
        }
 else         if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
        }
 else         if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=searchContacts(uri);
        }
 else {
          lookupResult=new LookupResult();
          Slog.w(TAG,""String_Node_Str"" + handle);
        }
        if (lookupResult != null) {
synchronized (mPeopleCache) {
            mPeopleCache.put(handle,lookupResult);
          }
          affinity=Math.max(affinity,lookupResult.getAffinity());
        }
      }
      float affinityBound=mRecord.getContactAffinity();
      affinity=Math.max(affinity,affinityBound);
      mRecord.setContactAffinity(affinity);
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + affinity);
    }
  }
;
}","private RankingReconsideration validatePeople(final NotificationRecord record){
  float affinity=NONE;
  Bundle extras=record.getNotification().extras;
  if (extras == null) {
    return null;
  }
  final String[] people=getExtraPeople(extras);
  if (people == null || people.length == 0) {
    return null;
  }
  if (INFO)   Slog.i(TAG,""String_Node_Str"" + record.sbn.getKey());
  final LinkedList<String> pendingLookups=new LinkedList<String>();
  for (int personIdx=0; personIdx < people.length && personIdx < MAX_PEOPLE; personIdx++) {
    final String handle=people[personIdx];
    if (TextUtils.isEmpty(handle))     continue;
synchronized (mPeopleCache) {
      LookupResult lookupResult=mPeopleCache.get(handle);
      if (lookupResult == null || lookupResult.isExpired()) {
        pendingLookups.add(handle);
      }
 else {
        if (DEBUG)         Slog.d(TAG,""String_Node_Str"" + lookupResult.mId);
      }
      if (lookupResult != null) {
        affinity=Math.max(affinity,lookupResult.getAffinity());
      }
    }
  }
  record.setContactAffinity(affinity);
  if (pendingLookups.isEmpty()) {
    if (INFO)     Slog.i(TAG,""String_Node_Str"" + affinity);
    return null;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + record.sbn.getKey());
  return new RankingReconsideration(record.getKey()){
    float mContactAffinity=NONE;
    @Override public void work(){
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + record.getKey());
      for (      final String handle : pendingLookups) {
        LookupResult lookupResult=null;
        final Uri uri=Uri.parse(handle);
        if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolvePhoneContact(uri.getSchemeSpecificPart());
        }
 else         if (""String_Node_Str"".equals(uri.getScheme())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=resolveEmailContact(uri.getSchemeSpecificPart());
        }
 else         if (handle.startsWith(Contacts.CONTENT_LOOKUP_URI.toString())) {
          if (DEBUG)           Slog.d(TAG,""String_Node_Str"" + handle);
          lookupResult=searchContacts(uri);
        }
 else {
          lookupResult=new LookupResult();
          Slog.w(TAG,""String_Node_Str"" + handle);
        }
        if (lookupResult != null) {
synchronized (mPeopleCache) {
            mPeopleCache.put(handle,lookupResult);
          }
          mContactAffinity=Math.max(mContactAffinity,lookupResult.getAffinity());
        }
      }
    }
    @Override public void applyChangesLocked(    NotificationRecord operand){
      float affinityBound=operand.getContactAffinity();
      operand.setContactAffinity(Math.max(mContactAffinity,affinityBound));
      if (INFO)       Slog.i(TAG,""String_Node_Str"" + operand.getContactAffinity());
    }
  }
;
}",0.8938447814451382
199256,"/** 
 * Removes a user and all data directories created for that user. This method should be called after the user's processes have been terminated.
 * @param userHandle the user's id
 */
public boolean removeUser(int userHandle){
  checkManageUsersPermission(""String_Node_Str"");
  final UserInfo user;
synchronized (mPackagesLock) {
    user=mUsers.get(userHandle);
    if (userHandle == 0 || user == null) {
      return false;
    }
    mRemovingUserIds.put(userHandle,true);
    try {
      mAppOpsService.removeUser(userHandle);
    }
 catch (    RemoteException e) {
      Log.w(LOG_TAG,""String_Node_Str"",e);
    }
    user.partial=true;
    user.flags|=UserInfo.FLAG_DISABLED;
    writeUserLocked(user);
  }
  if (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID && user.isManagedProfile()) {
    sendProfileRemovedBroadcast(user.profileGroupId,user.id);
  }
  if (DBG)   Slog.i(LOG_TAG,""String_Node_Str"" + userHandle);
  int res;
  try {
    res=ActivityManagerNative.getDefault().stopUser(userHandle,new IStopUserCallback.Stub(){
      @Override public void userStopped(      int userId){
        finishRemoveUser(userId);
      }
      @Override public void userStopAborted(      int userId){
      }
    }
);
  }
 catch (  RemoteException e) {
    return false;
  }
  return res == ActivityManager.USER_OP_SUCCESS;
}","/** 
 * Removes a user and all data directories created for that user. This method should be called after the user's processes have been terminated.
 * @param userHandle the user's id
 */
public boolean removeUser(int userHandle){
  checkManageUsersPermission(""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    final UserInfo user;
synchronized (mPackagesLock) {
      user=mUsers.get(userHandle);
      if (userHandle == 0 || user == null) {
        return false;
      }
      mRemovingUserIds.put(userHandle,true);
      try {
        mAppOpsService.removeUser(userHandle);
      }
 catch (      RemoteException e) {
        Log.w(LOG_TAG,""String_Node_Str"",e);
      }
      user.partial=true;
      user.flags|=UserInfo.FLAG_DISABLED;
      writeUserLocked(user);
    }
    if (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID && user.isManagedProfile()) {
      sendProfileRemovedBroadcast(user.profileGroupId,user.id);
    }
    if (DBG)     Slog.i(LOG_TAG,""String_Node_Str"" + userHandle);
    int res;
    try {
      res=ActivityManagerNative.getDefault().stopUser(userHandle,new IStopUserCallback.Stub(){
        @Override public void userStopped(        int userId){
          finishRemoveUser(userId);
        }
        @Override public void userStopAborted(        int userId){
        }
      }
);
    }
 catch (    RemoteException e) {
      return false;
    }
    return res == ActivityManager.USER_OP_SUCCESS;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.908005617977528
199257,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mBackground=findViewById(R.id.background);
  mSystemIconsContainer=(ViewGroup)findViewById(R.id.system_icons_container);
  mDateTime=findViewById(R.id.datetime);
  mKeyguardCarrierText=findViewById(R.id.keyguard_carrier_text);
  mMultiUserSwitch=(MultiUserSwitch)findViewById(R.id.multi_user_switch);
  mDate=findViewById(R.id.date);
  mSettingsButton=findViewById(R.id.settings_button);
  mSettingsButton.setOnClickListener(this);
  mBrightnessContainer=findViewById(R.id.brightness_container);
  mBrightnessController=new BrightnessController(getContext(),(ImageView)findViewById(R.id.brightness_icon),(ToggleSlider)findViewById(R.id.brightness_slider));
  loadDimens();
  updateVisibilities();
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mBackground=findViewById(R.id.background);
  mSystemIconsContainer=(ViewGroup)findViewById(R.id.system_icons_container);
  mDateTime=findViewById(R.id.datetime);
  mKeyguardCarrierText=findViewById(R.id.keyguard_carrier_text);
  mMultiUserSwitch=(MultiUserSwitch)findViewById(R.id.multi_user_switch);
  mDate=findViewById(R.id.date);
  mSettingsButton=findViewById(R.id.settings_button);
  mSettingsButton.setOnClickListener(this);
  mBrightnessContainer=findViewById(R.id.brightness_container);
  mBrightnessController=new BrightnessController(getContext(),(ImageView)findViewById(R.id.brightness_icon),(ToggleSlider)findViewById(R.id.brightness_slider));
  loadDimens();
  updateVisibilities();
  addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      if ((right - left) != (oldRight - oldLeft)) {
        setClipping(getHeight());
      }
    }
  }
);
}",0.8176033934252386
199258,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mBackground=findViewById(R.id.background);
  mSystemIconsContainer=(ViewGroup)findViewById(R.id.system_icons_container);
  mDateTime=findViewById(R.id.datetime);
  mKeyguardCarrierText=findViewById(R.id.keyguard_carrier_text);
  mMultiUserSwitch=(MultiUserSwitch)findViewById(R.id.multi_user_switch);
  mDate=findViewById(R.id.date);
  mSettingsButton=findViewById(R.id.settings_button);
  mSettingsButton.setOnClickListener(this);
  mBrightnessContainer=findViewById(R.id.brightness_container);
  mBrightnessController=new BrightnessController(getContext(),(ImageView)findViewById(R.id.brightness_icon),(ToggleSlider)findViewById(R.id.brightness_slider));
  loadDimens();
  updateVisibilities();
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mBackground=findViewById(R.id.background);
  mSystemIconsContainer=(ViewGroup)findViewById(R.id.system_icons_container);
  mDateTime=findViewById(R.id.datetime);
  mKeyguardCarrierText=findViewById(R.id.keyguard_carrier_text);
  mMultiUserSwitch=(MultiUserSwitch)findViewById(R.id.multi_user_switch);
  mDate=findViewById(R.id.date);
  mSettingsButton=findViewById(R.id.settings_button);
  mSettingsButton.setOnClickListener(this);
  mBrightnessContainer=findViewById(R.id.brightness_container);
  mBrightnessController=new BrightnessController(getContext(),(ImageView)findViewById(R.id.brightness_icon),(ToggleSlider)findViewById(R.id.brightness_slider));
  loadDimens();
  updateVisibilities();
  addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
    @Override public void onLayoutChange(    View v,    int left,    int top,    int right,    int bottom,    int oldLeft,    int oldTop,    int oldRight,    int oldBottom){
      if ((right - left) != (oldRight - oldLeft)) {
        setClipping(getHeight());
      }
    }
  }
);
}",0.8176033934252386
199259,"/** 
 * Creates a new AccessibilityAction. For adding a standard action without a specific label, use the static constants. You can also override the description for one the standard actions. Below is an example how to override the standard click action by adding a custom label: <pre> AccessibilityAction action = new AccessibilityAction( AccessibilityAction.ACTION_ACTION_CLICK, getLocalizedLabel()); node.addAction(action); </pre>
 * @param actionId The id for this action. This should either be one of thestandard actions or a specific action for your app. In that case it is required to use a resource identifier.
 * @param label The label for the new AccessibilityAction.
 */
public AccessibilityAction(int actionId,@Nullable CharSequence label){
  if ((actionId & ACTION_TYPE_MASK) == 0 && Integer.bitCount(actionId) > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((actionId & STANDARD_NON_LEGACY_ACTION_MASK) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mActionId=actionId;
  mLabel=label;
}","/** 
 * Creates a new AccessibilityAction. For adding a standard action without a specific label, use the static constants. You can also override the description for one the standard actions. Below is an example how to override the standard click action by adding a custom label: <pre> AccessibilityAction action = new AccessibilityAction( AccessibilityAction.ACTION_ACTION_CLICK, getLocalizedLabel()); node.addAction(action); </pre>
 * @param actionId The id for this action. This should either be one of thestandard actions or a specific action for your app. In that case it is required to use a resource identifier.
 * @param label The label for the new AccessibilityAction.
 */
public AccessibilityAction(int actionId,@Nullable CharSequence label){
  if ((actionId & ACTION_TYPE_MASK) == 0 && Integer.bitCount(actionId) != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mActionId=actionId;
  mLabel=label;
}",0.9371543489190548
199260,"@Override public boolean performAccessibilityAction(int accessibilityWindowId,long accessibilityNodeId,int action,Bundle arguments,int interactionId,IAccessibilityInteractionConnectionCallback callback,long interrogatingTid) throws RemoteException {
  final int resolvedWindowId;
  IAccessibilityInteractionConnection connection=null;
synchronized (mLock) {
    final int resolvedUserId=mSecurityPolicy.resolveCallingUserIdEnforcingPermissionsLocked(UserHandle.getCallingUserId());
    if (resolvedUserId != mCurrentUserId) {
      return false;
    }
    resolvedWindowId=resolveAccessibilityWindowIdLocked(accessibilityWindowId);
    final boolean permissionGranted=mSecurityPolicy.canPerformActionLocked(this,resolvedWindowId,action,arguments);
    if (!permissionGranted) {
      return false;
    }
 else {
      connection=getConnectionLocked(resolvedWindowId);
      if (connection == null) {
        return false;
      }
    }
  }
  final int interrogatingPid=Binder.getCallingPid();
  final long identityToken=Binder.clearCallingIdentity();
  try {
    connection.performAccessibilityAction(accessibilityNodeId,action,arguments,interactionId,callback,mFetchFlags,interrogatingPid,interrogatingTid);
  }
 catch (  RemoteException re) {
    if (DEBUG) {
      Slog.e(LOG_TAG,""String_Node_Str"");
    }
  }
 finally {
    Binder.restoreCallingIdentity(identityToken);
  }
  return true;
}","@Override public boolean performAccessibilityAction(int accessibilityWindowId,long accessibilityNodeId,int action,Bundle arguments,int interactionId,IAccessibilityInteractionConnectionCallback callback,long interrogatingTid) throws RemoteException {
  final int resolvedWindowId;
  IAccessibilityInteractionConnection connection=null;
synchronized (mLock) {
    final int resolvedUserId=mSecurityPolicy.resolveCallingUserIdEnforcingPermissionsLocked(UserHandle.getCallingUserId());
    if (resolvedUserId != mCurrentUserId) {
      return false;
    }
    resolvedWindowId=resolveAccessibilityWindowIdLocked(accessibilityWindowId);
    final boolean permissionGranted=mSecurityPolicy.canGetAccessibilityNodeInfoLocked(this,resolvedWindowId);
    if (!permissionGranted) {
      return false;
    }
 else {
      connection=getConnectionLocked(resolvedWindowId);
      if (connection == null) {
        return false;
      }
    }
  }
  final int interrogatingPid=Binder.getCallingPid();
  final long identityToken=Binder.clearCallingIdentity();
  try {
    connection.performAccessibilityAction(accessibilityNodeId,action,arguments,interactionId,callback,mFetchFlags,interrogatingPid,interrogatingTid);
  }
 catch (  RemoteException re) {
    if (DEBUG) {
      Slog.e(LOG_TAG,""String_Node_Str"");
    }
  }
 finally {
    Binder.restoreCallingIdentity(identityToken);
  }
  return true;
}",0.9820273184759166
199261,"/** 
 * Creates a new AccessibilityAction. For adding a standard action without a specific label, use the static constants. You can also override the description for one the standard actions. Below is an example how to override the standard click action by adding a custom label: <pre> AccessibilityAction action = new AccessibilityAction( AccessibilityAction.ACTION_ACTION_CLICK, getLocalizedLabel()); node.addAction(action); </pre>
 * @param actionId The id for this action. This should either be one of thestandard actions or a specific action for your app. In that case it is required to use a resource identifier.
 * @param label The label for the new AccessibilityAction.
 */
public AccessibilityAction(int actionId,@Nullable CharSequence label){
  if ((actionId & ACTION_TYPE_MASK) == 0 && Integer.bitCount(actionId) > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((actionId & STANDARD_NON_LEGACY_ACTION_MASK) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mActionId=actionId;
  mLabel=label;
}","/** 
 * Creates a new AccessibilityAction. For adding a standard action without a specific label, use the static constants. You can also override the description for one the standard actions. Below is an example how to override the standard click action by adding a custom label: <pre> AccessibilityAction action = new AccessibilityAction( AccessibilityAction.ACTION_ACTION_CLICK, getLocalizedLabel()); node.addAction(action); </pre>
 * @param actionId The id for this action. This should either be one of thestandard actions or a specific action for your app. In that case it is required to use a resource identifier.
 * @param label The label for the new AccessibilityAction.
 */
public AccessibilityAction(int actionId,@Nullable CharSequence label){
  if ((actionId & ACTION_TYPE_MASK) == 0 && Integer.bitCount(actionId) != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mActionId=actionId;
  mLabel=label;
}",0.9371543489190548
199262,"@Override public boolean performAccessibilityAction(int accessibilityWindowId,long accessibilityNodeId,int action,Bundle arguments,int interactionId,IAccessibilityInteractionConnectionCallback callback,long interrogatingTid) throws RemoteException {
  final int resolvedWindowId;
  IAccessibilityInteractionConnection connection=null;
synchronized (mLock) {
    final int resolvedUserId=mSecurityPolicy.resolveCallingUserIdEnforcingPermissionsLocked(UserHandle.getCallingUserId());
    if (resolvedUserId != mCurrentUserId) {
      return false;
    }
    resolvedWindowId=resolveAccessibilityWindowIdLocked(accessibilityWindowId);
    final boolean permissionGranted=mSecurityPolicy.canPerformActionLocked(this,resolvedWindowId,action,arguments);
    if (!permissionGranted) {
      return false;
    }
 else {
      connection=getConnectionLocked(resolvedWindowId);
      if (connection == null) {
        return false;
      }
    }
  }
  final int interrogatingPid=Binder.getCallingPid();
  final long identityToken=Binder.clearCallingIdentity();
  try {
    connection.performAccessibilityAction(accessibilityNodeId,action,arguments,interactionId,callback,mFetchFlags,interrogatingPid,interrogatingTid);
  }
 catch (  RemoteException re) {
    if (DEBUG) {
      Slog.e(LOG_TAG,""String_Node_Str"");
    }
  }
 finally {
    Binder.restoreCallingIdentity(identityToken);
  }
  return true;
}","@Override public boolean performAccessibilityAction(int accessibilityWindowId,long accessibilityNodeId,int action,Bundle arguments,int interactionId,IAccessibilityInteractionConnectionCallback callback,long interrogatingTid) throws RemoteException {
  final int resolvedWindowId;
  IAccessibilityInteractionConnection connection=null;
synchronized (mLock) {
    final int resolvedUserId=mSecurityPolicy.resolveCallingUserIdEnforcingPermissionsLocked(UserHandle.getCallingUserId());
    if (resolvedUserId != mCurrentUserId) {
      return false;
    }
    resolvedWindowId=resolveAccessibilityWindowIdLocked(accessibilityWindowId);
    final boolean permissionGranted=mSecurityPolicy.canGetAccessibilityNodeInfoLocked(this,resolvedWindowId);
    if (!permissionGranted) {
      return false;
    }
 else {
      connection=getConnectionLocked(resolvedWindowId);
      if (connection == null) {
        return false;
      }
    }
  }
  final int interrogatingPid=Binder.getCallingPid();
  final long identityToken=Binder.clearCallingIdentity();
  try {
    connection.performAccessibilityAction(accessibilityNodeId,action,arguments,interactionId,callback,mFetchFlags,interrogatingPid,interrogatingTid);
  }
 catch (  RemoteException re) {
    if (DEBUG) {
      Slog.e(LOG_TAG,""String_Node_Str"");
    }
  }
 finally {
    Binder.restoreCallingIdentity(identityToken);
  }
  return true;
}",0.9820273184759166
199263,"/** 
 * Creates a new AccessibilityAction. For adding a standard action without a specific label, use the static constants. You can also override the description for one the standard actions. Below is an example how to override the standard click action by adding a custom label: <pre> AccessibilityAction action = new AccessibilityAction( AccessibilityAction.ACTION_ACTION_CLICK, getLocalizedLabel()); node.addAction(action); </pre>
 * @param actionId The id for this action. This should either be one of thestandard actions or a specific action for your app. In that case it is required to use a resource identifier.
 * @param label The label for the new AccessibilityAction.
 */
public AccessibilityAction(int actionId,@Nullable CharSequence label){
  if ((actionId & ACTION_TYPE_MASK) == 0 && Integer.bitCount(actionId) > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((actionId & STANDARD_NON_LEGACY_ACTION_MASK) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mActionId=actionId;
  mLabel=label;
}","/** 
 * Creates a new AccessibilityAction. For adding a standard action without a specific label, use the static constants. You can also override the description for one the standard actions. Below is an example how to override the standard click action by adding a custom label: <pre> AccessibilityAction action = new AccessibilityAction( AccessibilityAction.ACTION_ACTION_CLICK, getLocalizedLabel()); node.addAction(action); </pre>
 * @param actionId The id for this action. This should either be one of thestandard actions or a specific action for your app. In that case it is required to use a resource identifier.
 * @param label The label for the new AccessibilityAction.
 */
public AccessibilityAction(int actionId,@Nullable CharSequence label){
  if ((actionId & ACTION_TYPE_MASK) == 0 && Integer.bitCount(actionId) != 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mActionId=actionId;
  mLabel=label;
}",0.9371543489190548
199264,"@Override public boolean performAccessibilityAction(int accessibilityWindowId,long accessibilityNodeId,int action,Bundle arguments,int interactionId,IAccessibilityInteractionConnectionCallback callback,long interrogatingTid) throws RemoteException {
  final int resolvedWindowId;
  IAccessibilityInteractionConnection connection=null;
synchronized (mLock) {
    final int resolvedUserId=mSecurityPolicy.resolveCallingUserIdEnforcingPermissionsLocked(UserHandle.getCallingUserId());
    if (resolvedUserId != mCurrentUserId) {
      return false;
    }
    resolvedWindowId=resolveAccessibilityWindowIdLocked(accessibilityWindowId);
    final boolean permissionGranted=mSecurityPolicy.canPerformActionLocked(this,resolvedWindowId,action,arguments);
    if (!permissionGranted) {
      return false;
    }
 else {
      connection=getConnectionLocked(resolvedWindowId);
      if (connection == null) {
        return false;
      }
    }
  }
  final int interrogatingPid=Binder.getCallingPid();
  final long identityToken=Binder.clearCallingIdentity();
  try {
    connection.performAccessibilityAction(accessibilityNodeId,action,arguments,interactionId,callback,mFetchFlags,interrogatingPid,interrogatingTid);
  }
 catch (  RemoteException re) {
    if (DEBUG) {
      Slog.e(LOG_TAG,""String_Node_Str"");
    }
  }
 finally {
    Binder.restoreCallingIdentity(identityToken);
  }
  return true;
}","@Override public boolean performAccessibilityAction(int accessibilityWindowId,long accessibilityNodeId,int action,Bundle arguments,int interactionId,IAccessibilityInteractionConnectionCallback callback,long interrogatingTid) throws RemoteException {
  final int resolvedWindowId;
  IAccessibilityInteractionConnection connection=null;
synchronized (mLock) {
    final int resolvedUserId=mSecurityPolicy.resolveCallingUserIdEnforcingPermissionsLocked(UserHandle.getCallingUserId());
    if (resolvedUserId != mCurrentUserId) {
      return false;
    }
    resolvedWindowId=resolveAccessibilityWindowIdLocked(accessibilityWindowId);
    final boolean permissionGranted=mSecurityPolicy.canGetAccessibilityNodeInfoLocked(this,resolvedWindowId);
    if (!permissionGranted) {
      return false;
    }
 else {
      connection=getConnectionLocked(resolvedWindowId);
      if (connection == null) {
        return false;
      }
    }
  }
  final int interrogatingPid=Binder.getCallingPid();
  final long identityToken=Binder.clearCallingIdentity();
  try {
    connection.performAccessibilityAction(accessibilityNodeId,action,arguments,interactionId,callback,mFetchFlags,interrogatingPid,interrogatingTid);
  }
 catch (  RemoteException re) {
    if (DEBUG) {
      Slog.e(LOG_TAG,""String_Node_Str"");
    }
  }
 finally {
    Binder.restoreCallingIdentity(identityToken);
  }
  return true;
}",0.9820273184759166
199265,"protected void verifyPasswordAndUnlock(){
  String entry=mPasswordEntry.getText().toString();
  if (mLockPatternUtils.checkPassword(entry)) {
    mCallback.reportUnlockAttempt(true);
    mCallback.dismiss(true);
  }
 else   if (entry.length() > MINIMUM_PASSWORD_LENGTH_BEFORE_REPORT) {
    mCallback.reportUnlockAttempt(false);
    int attempts=KeyguardUpdateMonitor.getInstance(mContext).getFailedUnlockAttempts();
    if (0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
    mSecurityMessageDisplay.setMessage(getWrongPasswordStringId(),true);
  }
  mPasswordEntry.setText(""String_Node_Str"");
}","protected void verifyPasswordAndUnlock(){
  String entry=mPasswordEntry.getText().toString();
  if (mLockPatternUtils.checkPassword(entry)) {
    mCallback.reportUnlockAttempt(true);
    mCallback.dismiss(true);
  }
 else {
    if (entry.length() > MINIMUM_PASSWORD_LENGTH_BEFORE_REPORT) {
      mCallback.reportUnlockAttempt(false);
      int attempts=KeyguardUpdateMonitor.getInstance(mContext).getFailedUnlockAttempts();
      if (0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
        handleAttemptLockout(deadline);
      }
    }
    mSecurityMessageDisplay.setMessage(getWrongPasswordStringId(),true);
  }
  mPasswordEntry.setText(""String_Node_Str"");
}",0.9850948509485096
199266,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=(int)getLayoutHeight();
    int bottom=getContentHeight();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    postInvalidateOnAnimation();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}",0.9347925216598268
199267,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int height=(int)getLayoutHeight();
    int bottom=getContentHeight();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,bottom - height),0,height / 2);
    postInvalidateOnAnimation();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * RUBBER_BAND_FACTOR * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}",0.9347925216598268
199268,"protected void verifyPasswordAndUnlock(){
  String entry=mPasswordEntry.getText().toString();
  if (mLockPatternUtils.checkPassword(entry)) {
    mCallback.reportUnlockAttempt(true);
    mCallback.dismiss(true);
  }
 else   if (entry.length() > MINIMUM_PASSWORD_LENGTH_BEFORE_REPORT) {
    mCallback.reportUnlockAttempt(false);
    int attempts=KeyguardUpdateMonitor.getInstance(mContext).getFailedUnlockAttempts();
    if (0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
    mSecurityMessageDisplay.setMessage(getWrongPasswordStringId(),true);
  }
  mPasswordEntry.setText(""String_Node_Str"");
}","protected void verifyPasswordAndUnlock(){
  String entry=mPasswordEntry.getText().toString();
  if (mLockPatternUtils.checkPassword(entry)) {
    mCallback.reportUnlockAttempt(true);
    mCallback.dismiss(true);
  }
 else {
    if (entry.length() > MINIMUM_PASSWORD_LENGTH_BEFORE_REPORT) {
      mCallback.reportUnlockAttempt(false);
      int attempts=KeyguardUpdateMonitor.getInstance(mContext).getFailedUnlockAttempts();
      if (0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
        handleAttemptLockout(deadline);
      }
    }
    mSecurityMessageDisplay.setMessage(getWrongPasswordStringId(),true);
  }
  mPasswordEntry.setText(""String_Node_Str"");
}",0.9850948509485096
199269,"/** 
 * Returns ""true"" if the UID belongs to a bound location provider.
 * @param uid the uid
 * @return true if uid belongs to a bound location provider
 */
private boolean isUidALocationProvider(int uid){
  if (uid == Process.SYSTEM_UID) {
    return true;
  }
  if (mGeocodeProvider != null) {
    if (doesPackageHaveUid(uid,mGeocodeProvider.getConnectedPackageName()))     return true;
  }
  for (  LocationProviderProxy proxy : mProxyProviders) {
    if (doesPackageHaveUid(uid,proxy.getConnectedPackageName()))     return true;
  }
  return false;
}","/** 
 * Returns ""true"" if the UID belongs to a bound location provider.
 * @param uid the uid
 * @return true if uid belongs to a bound location provider
 */
private boolean isUidALocationProvider(int uid){
  if (uid == Process.SYSTEM_UID) {
    return true;
  }
  if (mGeocodeProvider != null) {
    if (doesUidHavePackage(uid,mGeocodeProvider.getConnectedPackageName()))     return true;
  }
  for (  LocationProviderProxy proxy : mProxyProviders) {
    if (doesUidHavePackage(uid,proxy.getConnectedPackageName()))     return true;
  }
  return false;
}",0.9747747747747748
199270,"/** 
 * Returns ""true"" if the UID belongs to a bound location provider.
 * @param uid the uid
 * @return true if uid belongs to a bound location provider
 */
private boolean isUidALocationProvider(int uid){
  if (uid == Process.SYSTEM_UID) {
    return true;
  }
  if (mGeocodeProvider != null) {
    if (doesPackageHaveUid(uid,mGeocodeProvider.getConnectedPackageName()))     return true;
  }
  for (  LocationProviderProxy proxy : mProxyProviders) {
    if (doesPackageHaveUid(uid,proxy.getConnectedPackageName()))     return true;
  }
  return false;
}","/** 
 * Returns ""true"" if the UID belongs to a bound location provider.
 * @param uid the uid
 * @return true if uid belongs to a bound location provider
 */
private boolean isUidALocationProvider(int uid){
  if (uid == Process.SYSTEM_UID) {
    return true;
  }
  if (mGeocodeProvider != null) {
    if (doesUidHavePackage(uid,mGeocodeProvider.getConnectedPackageName()))     return true;
  }
  for (  LocationProviderProxy proxy : mProxyProviders) {
    if (doesUidHavePackage(uid,proxy.getConnectedPackageName()))     return true;
  }
  return false;
}",0.9747747747747748
199271,"public void updatePowerState(DisplayManagerInternal.DisplayPowerRequest request){
  if (setScreenAutoBrightnessAdjustment(request.screenAutoBrightnessAdjustment) || setLightSensorEnabled(request.wantLightSensorEnabled())) {
    updateAutoBrightness(false);
  }
}","public void updatePowerState(DisplayManagerInternal.DisplayPowerRequest request){
  if (setScreenAutoBrightnessAdjustment(request.screenAutoBrightnessAdjustment) | setLightSensorEnabled(request.wantLightSensorEnabled())) {
    updateAutoBrightness(false);
  }
}",0.9980879541108988
199272,"public void systemReady(){
synchronized (mLock) {
    mSystemReady=true;
    mDreamManager=LocalServices.getService(DreamManagerInternal.class);
    PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mScreenBrightnessSettingMinimum=pm.getMinimumScreenBrightnessSetting();
    mScreenBrightnessSettingMaximum=pm.getMaximumScreenBrightnessSetting();
    mScreenBrightnessSettingDefault=pm.getDefaultScreenBrightnessSetting();
    SensorManager sensorManager=new SystemSensorManager(mContext,mHandler.getLooper());
    mNotifier=new Notifier(Looper.getMainLooper(),mContext,mBatteryStats,mAppOps,createSuspendBlockerLocked(""String_Node_Str""),mScreenOnBlocker,mPolicy);
    mWirelessChargerDetector=new WirelessChargerDetector(sensorManager,createSuspendBlockerLocked(""String_Node_Str""),mHandler);
    mSettingsObserver=new SettingsObserver(mHandler);
    mAttentionLight=mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks,mHandler,sensorManager);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    mContext.registerReceiver(new BatteryReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BOOT_COMPLETED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BootCompletedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(),filter,null,mHandler);
    final ContentResolver resolver=mContext.getContentResolver();
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    readConfigurationLocked();
    updateSettingsLocked();
    mDirty|=DIRTY_BATTERY_STATE;
    updatePowerStateLocked();
  }
}","public void systemReady(){
synchronized (mLock) {
    mSystemReady=true;
    mDreamManager=LocalServices.getService(DreamManagerInternal.class);
    PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mScreenBrightnessSettingMinimum=pm.getMinimumScreenBrightnessSetting();
    mScreenBrightnessSettingMaximum=pm.getMaximumScreenBrightnessSetting();
    mScreenBrightnessSettingDefault=pm.getDefaultScreenBrightnessSetting();
    SensorManager sensorManager=new SystemSensorManager(mContext,mHandler.getLooper());
    mNotifier=new Notifier(Looper.getMainLooper(),mContext,mBatteryStats,mAppOps,createSuspendBlockerLocked(""String_Node_Str""),mScreenOnBlocker,mPolicy);
    mWirelessChargerDetector=new WirelessChargerDetector(sensorManager,createSuspendBlockerLocked(""String_Node_Str""),mHandler);
    mSettingsObserver=new SettingsObserver(mHandler);
    mAttentionLight=mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks,mHandler,sensorManager);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    mContext.registerReceiver(new BatteryReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BOOT_COMPLETED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BootCompletedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(),filter,null,mHandler);
    final ContentResolver resolver=mContext.getContentResolver();
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    readConfigurationLocked();
    updateSettingsLocked();
    mDirty|=DIRTY_BATTERY_STATE;
    updatePowerStateLocked();
  }
}",0.977713037144938
199273,"public void updatePowerState(DisplayManagerInternal.DisplayPowerRequest request){
  if (setScreenAutoBrightnessAdjustment(request.screenAutoBrightnessAdjustment) || setLightSensorEnabled(request.wantLightSensorEnabled())) {
    updateAutoBrightness(false);
  }
}","public void updatePowerState(DisplayManagerInternal.DisplayPowerRequest request){
  if (setScreenAutoBrightnessAdjustment(request.screenAutoBrightnessAdjustment) | setLightSensorEnabled(request.wantLightSensorEnabled())) {
    updateAutoBrightness(false);
  }
}",0.9980879541108988
199274,"public void systemReady(){
synchronized (mLock) {
    mSystemReady=true;
    mDreamManager=LocalServices.getService(DreamManagerInternal.class);
    PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mScreenBrightnessSettingMinimum=pm.getMinimumScreenBrightnessSetting();
    mScreenBrightnessSettingMaximum=pm.getMaximumScreenBrightnessSetting();
    mScreenBrightnessSettingDefault=pm.getDefaultScreenBrightnessSetting();
    SensorManager sensorManager=new SystemSensorManager(mContext,mHandler.getLooper());
    mNotifier=new Notifier(Looper.getMainLooper(),mContext,mBatteryStats,mAppOps,createSuspendBlockerLocked(""String_Node_Str""),mScreenOnBlocker,mPolicy);
    mWirelessChargerDetector=new WirelessChargerDetector(sensorManager,createSuspendBlockerLocked(""String_Node_Str""),mHandler);
    mSettingsObserver=new SettingsObserver(mHandler);
    mAttentionLight=mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks,mHandler,sensorManager);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    mContext.registerReceiver(new BatteryReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BOOT_COMPLETED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BootCompletedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(),filter,null,mHandler);
    final ContentResolver resolver=mContext.getContentResolver();
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    readConfigurationLocked();
    updateSettingsLocked();
    mDirty|=DIRTY_BATTERY_STATE;
    updatePowerStateLocked();
  }
}","public void systemReady(){
synchronized (mLock) {
    mSystemReady=true;
    mDreamManager=LocalServices.getService(DreamManagerInternal.class);
    PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
    mScreenBrightnessSettingMinimum=pm.getMinimumScreenBrightnessSetting();
    mScreenBrightnessSettingMaximum=pm.getMaximumScreenBrightnessSetting();
    mScreenBrightnessSettingDefault=pm.getDefaultScreenBrightnessSetting();
    SensorManager sensorManager=new SystemSensorManager(mContext,mHandler.getLooper());
    mNotifier=new Notifier(Looper.getMainLooper(),mContext,mBatteryStats,mAppOps,createSuspendBlockerLocked(""String_Node_Str""),mScreenOnBlocker,mPolicy);
    mWirelessChargerDetector=new WirelessChargerDetector(sensorManager,createSuspendBlockerLocked(""String_Node_Str""),mHandler);
    mSettingsObserver=new SettingsObserver(mHandler);
    mAttentionLight=mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks,mHandler,sensorManager);
    IntentFilter filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    mContext.registerReceiver(new BatteryReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_BOOT_COMPLETED);
    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
    mContext.registerReceiver(new BootCompletedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    mContext.registerReceiver(new DreamReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(new UserSwitchedReceiver(),filter,null,mHandler);
    filter=new IntentFilter();
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    mContext.registerReceiver(new DockReceiver(),filter,null,mHandler);
    final ContentResolver resolver=mContext.getContentResolver();
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ENABLED),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ),false,mSettingsObserver,UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE),false,mSettingsObserver,UserHandle.USER_ALL);
    readConfigurationLocked();
    updateSettingsLocked();
    mDirty|=DIRTY_BATTERY_STATE;
    updatePowerStateLocked();
  }
}",0.977713037144938
199275,"private void handleConnect(NetworkInfo info){
  final int newNetType=info.getType();
  boolean isFailover=info.isFailover();
  final NetworkStateTracker thisNet=mNetTrackers[newNetType];
  final String thisIface=thisNet.getLinkProperties().getInterfaceName();
  if (VDBG) {
    log(""String_Node_Str"" + newNetType + ""String_Node_Str""+ thisIface+ ""String_Node_Str""+ isFailover);
  }
  if (mNetConfigs[newNetType].isDefault()) {
    if (mActiveDefaultNetwork != -1 && mActiveDefaultNetwork != newNetType) {
      if (isNewNetTypePreferredOverCurrentNetType(newNetType)) {
        String teardownPolicy=SystemProperties.get(""String_Node_Str"");
        if (TextUtils.equals(teardownPolicy,""String_Node_Str"") == false) {
          NetworkStateTracker otherNet=mNetTrackers[mActiveDefaultNetwork];
          if (DBG) {
            log(""String_Node_Str"" + otherNet.getNetworkInfo().getTypeName() + ""String_Node_Str"");
          }
          if (!teardown(otherNet)) {
            loge(""String_Node_Str"");
            teardown(thisNet);
            return;
          }
        }
 else {
          loge(""String_Node_Str"");
        }
      }
 else {
        if (VDBG) {
          log(""String_Node_Str"" + ""String_Node_Str"" + info.getTypeName());
        }
        teardown(thisNet);
        return;
      }
    }
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
    setupDataActivityTracking(newNetType);
synchronized (ConnectivityService.this) {
      if (mNetTransitionWakeLock.isHeld()) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK,mNetTransitionWakeLockSerialNumber,0),1000);
      }
    }
    mActiveDefaultNetwork=newNetType;
    try {
      mNetd.setDefaultNetId(thisNetId);
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
    }
    mDefaultInetConditionPublished=0;
    mDefaultConnectionSequence++;
    mInetConditionChangeInFlight=false;
    updateNetworkSettings(thisNet);
  }
 else {
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
  }
  thisNet.setTeardownRequested(false);
  updateMtuSizeSettings(thisNet);
  handleConnectivityChange(newNetType,false);
  sendConnectedBroadcastDelayed(info,getConnectivityChangeDelay());
  if (thisIface != null) {
    try {
      BatteryStatsService.getService().noteNetworkInterfaceType(thisIface,newNetType);
    }
 catch (    RemoteException e) {
    }
  }
}","private void handleConnect(NetworkInfo info){
  final int newNetType=info.getType();
  boolean isFailover=info.isFailover();
  final NetworkStateTracker thisNet=mNetTrackers[newNetType];
  final String thisIface=thisNet.getLinkProperties().getInterfaceName();
  if (VDBG) {
    log(""String_Node_Str"" + newNetType + ""String_Node_Str""+ thisIface+ ""String_Node_Str""+ isFailover);
  }
  if (mNetConfigs[newNetType].isDefault()) {
    if (mActiveDefaultNetwork != -1 && mActiveDefaultNetwork != newNetType) {
      if (isNewNetTypePreferredOverCurrentNetType(newNetType)) {
        String teardownPolicy=SystemProperties.get(""String_Node_Str"");
        if (TextUtils.equals(teardownPolicy,""String_Node_Str"") == false) {
          NetworkStateTracker otherNet=mNetTrackers[mActiveDefaultNetwork];
          if (DBG) {
            log(""String_Node_Str"" + otherNet.getNetworkInfo().getTypeName() + ""String_Node_Str"");
          }
          if (!teardown(otherNet)) {
            loge(""String_Node_Str"");
            teardown(thisNet);
            return;
          }
        }
 else {
          loge(""String_Node_Str"");
        }
      }
 else {
        if (VDBG) {
          log(""String_Node_Str"" + ""String_Node_Str"" + info.getTypeName());
        }
        teardown(thisNet);
        return;
      }
    }
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
synchronized (ConnectivityService.this) {
      if (mNetTransitionWakeLock.isHeld()) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK,mNetTransitionWakeLockSerialNumber,0),1000);
      }
    }
    mActiveDefaultNetwork=newNetType;
    try {
      mNetd.setDefaultNetId(thisNetId);
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
    }
    mDefaultInetConditionPublished=0;
    mDefaultConnectionSequence++;
    mInetConditionChangeInFlight=false;
    updateNetworkSettings(thisNet);
  }
 else {
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
  }
  thisNet.setTeardownRequested(false);
  sendConnectedBroadcastDelayed(info,getConnectivityChangeDelay());
  if (thisIface != null) {
    try {
      BatteryStatsService.getService().noteNetworkInterfaceType(thisIface,newNetType);
    }
 catch (    RemoteException e) {
    }
  }
}",0.9761950841881168
199276,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  int thisNetId=mNetTrackers[prevNetType].getNetwork().netId;
  if (mNetConfigs[prevNetType].isDefault()) {
    removeDataActivityTracking(prevNetType);
  }
  if (!mNetConfigs[prevNetType].isDefault()) {
    List<Integer> pids=mNetRequestersPids[prevNetType];
    for (    Integer pid : pids) {
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,new NetworkInfo(info));
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE,info.getType());
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  if (mNetConfigs[prevNetType].isDefault()) {
    tryFailover(prevNetType);
    if (mActiveDefaultNetwork != -1) {
      NetworkInfo switchTo=mNetTrackers[mActiveDefaultNetwork].getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  boolean doReset=true;
  LinkProperties linkProperties=mNetTrackers[prevNetType].getLinkProperties();
  if (linkProperties != null) {
    String oldIface=linkProperties.getInterfaceName();
    if (TextUtils.isEmpty(oldIface) == false) {
      for (      NetworkStateTracker networkStateTracker : mNetTrackers) {
        if (networkStateTracker == null)         continue;
        NetworkInfo networkInfo=networkStateTracker.getNetworkInfo();
        if (networkInfo.isConnected() && networkInfo.getType() != prevNetType) {
          LinkProperties l=networkStateTracker.getLinkProperties();
          if (l == null)           continue;
          if (oldIface.equals(l.getInterfaceName())) {
            doReset=false;
            break;
          }
        }
      }
    }
  }
  handleConnectivityChange(prevNetType,doReset);
  final Intent immediateIntent=new Intent(intent);
  immediateIntent.setAction(CONNECTIVITY_ACTION_IMMEDIATE);
  sendStickyBroadcast(immediateIntent);
  sendStickyBroadcastDelayed(intent,getConnectivityChangeDelay());
  if (mActiveDefaultNetwork != -1) {
    sendConnectedBroadcastDelayed(mNetTrackers[mActiveDefaultNetwork].getNetworkInfo(),getConnectivityChangeDelay());
  }
  try {
  }
 catch (  Exception e) {
    loge(""String_Node_Str"" + e);
  }
 finally {
    mNetTrackers[prevNetType].setNetId(INVALID_NET_ID);
  }
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  int thisNetId=mNetTrackers[prevNetType].getNetwork().netId;
  if (!mNetConfigs[prevNetType].isDefault()) {
    List<Integer> pids=mNetRequestersPids[prevNetType];
    for (    Integer pid : pids) {
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,new NetworkInfo(info));
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE,info.getType());
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  if (mNetConfigs[prevNetType].isDefault()) {
    tryFailover(prevNetType);
    if (mActiveDefaultNetwork != -1) {
      NetworkInfo switchTo=mNetTrackers[mActiveDefaultNetwork].getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  boolean doReset=true;
  LinkProperties linkProperties=mNetTrackers[prevNetType].getLinkProperties();
  if (linkProperties != null) {
    String oldIface=linkProperties.getInterfaceName();
    if (TextUtils.isEmpty(oldIface) == false) {
      for (      NetworkStateTracker networkStateTracker : mNetTrackers) {
        if (networkStateTracker == null)         continue;
        NetworkInfo networkInfo=networkStateTracker.getNetworkInfo();
        if (networkInfo.isConnected() && networkInfo.getType() != prevNetType) {
          LinkProperties l=networkStateTracker.getLinkProperties();
          if (l == null)           continue;
          if (oldIface.equals(l.getInterfaceName())) {
            doReset=false;
            break;
          }
        }
      }
    }
  }
  final Intent immediateIntent=new Intent(intent);
  immediateIntent.setAction(CONNECTIVITY_ACTION_IMMEDIATE);
  sendStickyBroadcast(immediateIntent);
  sendStickyBroadcastDelayed(intent,getConnectivityChangeDelay());
  if (mActiveDefaultNetwork != -1) {
    sendConnectedBroadcastDelayed(mNetTrackers[mActiveDefaultNetwork].getNetworkInfo(),getConnectivityChangeDelay());
  }
  try {
  }
 catch (  Exception e) {
    loge(""String_Node_Str"" + e);
  }
 finally {
    mNetTrackers[prevNetType].setNetId(INVALID_NET_ID);
  }
}",0.9771501110758488
199277,"private void handleConnect(NetworkInfo info){
  final int newNetType=info.getType();
  boolean isFailover=info.isFailover();
  final NetworkStateTracker thisNet=mNetTrackers[newNetType];
  final String thisIface=thisNet.getLinkProperties().getInterfaceName();
  if (VDBG) {
    log(""String_Node_Str"" + newNetType + ""String_Node_Str""+ thisIface+ ""String_Node_Str""+ isFailover);
  }
  if (mNetConfigs[newNetType].isDefault()) {
    if (mActiveDefaultNetwork != -1 && mActiveDefaultNetwork != newNetType) {
      if (isNewNetTypePreferredOverCurrentNetType(newNetType)) {
        String teardownPolicy=SystemProperties.get(""String_Node_Str"");
        if (TextUtils.equals(teardownPolicy,""String_Node_Str"") == false) {
          NetworkStateTracker otherNet=mNetTrackers[mActiveDefaultNetwork];
          if (DBG) {
            log(""String_Node_Str"" + otherNet.getNetworkInfo().getTypeName() + ""String_Node_Str"");
          }
          if (!teardown(otherNet)) {
            loge(""String_Node_Str"");
            teardown(thisNet);
            return;
          }
        }
 else {
          loge(""String_Node_Str"");
        }
      }
 else {
        if (VDBG) {
          log(""String_Node_Str"" + ""String_Node_Str"" + info.getTypeName());
        }
        teardown(thisNet);
        return;
      }
    }
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
    setupDataActivityTracking(newNetType);
synchronized (ConnectivityService.this) {
      if (mNetTransitionWakeLock.isHeld()) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK,mNetTransitionWakeLockSerialNumber,0),1000);
      }
    }
    mActiveDefaultNetwork=newNetType;
    try {
      mNetd.setDefaultNetId(thisNetId);
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
    }
    mDefaultInetConditionPublished=0;
    mDefaultConnectionSequence++;
    mInetConditionChangeInFlight=false;
    updateNetworkSettings(thisNet);
  }
 else {
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
  }
  thisNet.setTeardownRequested(false);
  updateMtuSizeSettings(thisNet);
  handleConnectivityChange(newNetType,false);
  sendConnectedBroadcastDelayed(info,getConnectivityChangeDelay());
  if (thisIface != null) {
    try {
      BatteryStatsService.getService().noteNetworkInterfaceType(thisIface,newNetType);
    }
 catch (    RemoteException e) {
    }
  }
}","private void handleConnect(NetworkInfo info){
  final int newNetType=info.getType();
  boolean isFailover=info.isFailover();
  final NetworkStateTracker thisNet=mNetTrackers[newNetType];
  final String thisIface=thisNet.getLinkProperties().getInterfaceName();
  if (VDBG) {
    log(""String_Node_Str"" + newNetType + ""String_Node_Str""+ thisIface+ ""String_Node_Str""+ isFailover);
  }
  if (mNetConfigs[newNetType].isDefault()) {
    if (mActiveDefaultNetwork != -1 && mActiveDefaultNetwork != newNetType) {
      if (isNewNetTypePreferredOverCurrentNetType(newNetType)) {
        String teardownPolicy=SystemProperties.get(""String_Node_Str"");
        if (TextUtils.equals(teardownPolicy,""String_Node_Str"") == false) {
          NetworkStateTracker otherNet=mNetTrackers[mActiveDefaultNetwork];
          if (DBG) {
            log(""String_Node_Str"" + otherNet.getNetworkInfo().getTypeName() + ""String_Node_Str"");
          }
          if (!teardown(otherNet)) {
            loge(""String_Node_Str"");
            teardown(thisNet);
            return;
          }
        }
 else {
          loge(""String_Node_Str"");
        }
      }
 else {
        if (VDBG) {
          log(""String_Node_Str"" + ""String_Node_Str"" + info.getTypeName());
        }
        teardown(thisNet);
        return;
      }
    }
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
synchronized (ConnectivityService.this) {
      if (mNetTransitionWakeLock.isHeld()) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK,mNetTransitionWakeLockSerialNumber,0),1000);
      }
    }
    mActiveDefaultNetwork=newNetType;
    try {
      mNetd.setDefaultNetId(thisNetId);
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
    }
    mDefaultInetConditionPublished=0;
    mDefaultConnectionSequence++;
    mInetConditionChangeInFlight=false;
    updateNetworkSettings(thisNet);
  }
 else {
    int thisNetId=nextNetId();
    thisNet.setNetId(thisNetId);
    try {
    }
 catch (    Exception e) {
      loge(""String_Node_Str"" + e);
      teardown(thisNet);
      return;
    }
  }
  thisNet.setTeardownRequested(false);
  sendConnectedBroadcastDelayed(info,getConnectivityChangeDelay());
  if (thisIface != null) {
    try {
      BatteryStatsService.getService().noteNetworkInterfaceType(thisIface,newNetType);
    }
 catch (    RemoteException e) {
    }
  }
}",0.9761950841881168
199278,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  int thisNetId=mNetTrackers[prevNetType].getNetwork().netId;
  if (mNetConfigs[prevNetType].isDefault()) {
    removeDataActivityTracking(prevNetType);
  }
  if (!mNetConfigs[prevNetType].isDefault()) {
    List<Integer> pids=mNetRequestersPids[prevNetType];
    for (    Integer pid : pids) {
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,new NetworkInfo(info));
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE,info.getType());
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  if (mNetConfigs[prevNetType].isDefault()) {
    tryFailover(prevNetType);
    if (mActiveDefaultNetwork != -1) {
      NetworkInfo switchTo=mNetTrackers[mActiveDefaultNetwork].getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  boolean doReset=true;
  LinkProperties linkProperties=mNetTrackers[prevNetType].getLinkProperties();
  if (linkProperties != null) {
    String oldIface=linkProperties.getInterfaceName();
    if (TextUtils.isEmpty(oldIface) == false) {
      for (      NetworkStateTracker networkStateTracker : mNetTrackers) {
        if (networkStateTracker == null)         continue;
        NetworkInfo networkInfo=networkStateTracker.getNetworkInfo();
        if (networkInfo.isConnected() && networkInfo.getType() != prevNetType) {
          LinkProperties l=networkStateTracker.getLinkProperties();
          if (l == null)           continue;
          if (oldIface.equals(l.getInterfaceName())) {
            doReset=false;
            break;
          }
        }
      }
    }
  }
  handleConnectivityChange(prevNetType,doReset);
  final Intent immediateIntent=new Intent(intent);
  immediateIntent.setAction(CONNECTIVITY_ACTION_IMMEDIATE);
  sendStickyBroadcast(immediateIntent);
  sendStickyBroadcastDelayed(intent,getConnectivityChangeDelay());
  if (mActiveDefaultNetwork != -1) {
    sendConnectedBroadcastDelayed(mNetTrackers[mActiveDefaultNetwork].getNetworkInfo(),getConnectivityChangeDelay());
  }
  try {
  }
 catch (  Exception e) {
    loge(""String_Node_Str"" + e);
  }
 finally {
    mNetTrackers[prevNetType].setNetId(INVALID_NET_ID);
  }
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  int thisNetId=mNetTrackers[prevNetType].getNetwork().netId;
  if (!mNetConfigs[prevNetType].isDefault()) {
    List<Integer> pids=mNetRequestersPids[prevNetType];
    for (    Integer pid : pids) {
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,new NetworkInfo(info));
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE,info.getType());
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  if (mNetConfigs[prevNetType].isDefault()) {
    tryFailover(prevNetType);
    if (mActiveDefaultNetwork != -1) {
      NetworkInfo switchTo=mNetTrackers[mActiveDefaultNetwork].getNetworkInfo();
      intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
    }
 else {
      mDefaultInetConditionPublished=0;
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION,mDefaultInetConditionPublished);
  boolean doReset=true;
  LinkProperties linkProperties=mNetTrackers[prevNetType].getLinkProperties();
  if (linkProperties != null) {
    String oldIface=linkProperties.getInterfaceName();
    if (TextUtils.isEmpty(oldIface) == false) {
      for (      NetworkStateTracker networkStateTracker : mNetTrackers) {
        if (networkStateTracker == null)         continue;
        NetworkInfo networkInfo=networkStateTracker.getNetworkInfo();
        if (networkInfo.isConnected() && networkInfo.getType() != prevNetType) {
          LinkProperties l=networkStateTracker.getLinkProperties();
          if (l == null)           continue;
          if (oldIface.equals(l.getInterfaceName())) {
            doReset=false;
            break;
          }
        }
      }
    }
  }
  final Intent immediateIntent=new Intent(intent);
  immediateIntent.setAction(CONNECTIVITY_ACTION_IMMEDIATE);
  sendStickyBroadcast(immediateIntent);
  sendStickyBroadcastDelayed(intent,getConnectivityChangeDelay());
  if (mActiveDefaultNetwork != -1) {
    sendConnectedBroadcastDelayed(mNetTrackers[mActiveDefaultNetwork].getNetworkInfo(),getConnectivityChangeDelay());
  }
  try {
  }
 catch (  Exception e) {
    loge(""String_Node_Str"" + e);
  }
 finally {
    mNetTrackers[prevNetType].setNetId(INVALID_NET_ID);
  }
}",0.9771501110758488
199279,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199280,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199281,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199282,"private void scrollIfNeeded(int x,int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            final boolean atOverscrollEdge=overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (atOverscrollEdge && mVelocityTracker != null) {
              mVelocityTracker.clear();
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              if (!atOverscrollEdge) {
                mDirection=0;
                mTouchMode=TOUCH_MODE_OVERSCROLL;
              }
              if (incrementalDeltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight(),(float)x / getWidth());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
              }
 else               if (incrementalDeltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight(),1.f - (float)x / getWidth());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight(),(float)x / getWidth());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight(),1.f - (float)x / getWidth());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}","private void scrollIfNeeded(int x,int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  int scrollOffsetCorrection=0;
  int scrollConsumedCorrection=0;
  if (mLastY == Integer.MIN_VALUE) {
    rawDeltaY-=mMotionCorrection;
  }
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    scrollOffsetCorrection-=mScrollOffset[1];
    scrollConsumedCorrection-=mScrollConsumed[1];
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY - scrollConsumedCorrection : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            final boolean atOverscrollEdge=overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (atOverscrollEdge && mVelocityTracker != null) {
              mVelocityTracker.clear();
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              if (!atOverscrollEdge) {
                mDirection=0;
                mTouchMode=TOUCH_MODE_OVERSCROLL;
              }
              if (incrementalDeltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight(),(float)x / getWidth());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
              }
 else               if (incrementalDeltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight(),1.f - (float)x / getWidth());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
              }
            }
          }
        }
        mMotionY=y + scrollOffsetCorrection;
      }
      mLastY=y + lastYCorrection + scrollOffsetCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight(),(float)x / getWidth());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight(),1.f - (float)x / getWidth());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}",0.9360902255639098
199283,"/** 
 * Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to  {@link Adapter#getView(int,View,ViewGroup)}.
 * @param view The view whose scroll state is being reported
 * @param scrollState The current scroll state. One of {@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
 */
public void onScrollStateChanged(AbsListView view,int scrollState);","/** 
 * Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to  {@link Adapter#getView(int,View,ViewGroup)}.
 * @param view The view whose scroll state is being reported
 * @param scrollState The current scroll state. One of{@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
 */
public void onScrollStateChanged(AbsListView view,int scrollState);",0.9990884229717412
199284,"private void scrollIfNeeded(int x,int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            final boolean atOverscrollEdge=overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (atOverscrollEdge && mVelocityTracker != null) {
              mVelocityTracker.clear();
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              if (!atOverscrollEdge) {
                mDirection=0;
                mTouchMode=TOUCH_MODE_OVERSCROLL;
              }
              if (incrementalDeltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight(),(float)x / getWidth());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
              }
 else               if (incrementalDeltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight(),1.f - (float)x / getWidth());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight(),(float)x / getWidth());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight(),1.f - (float)x / getWidth());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}","private void scrollIfNeeded(int x,int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  int scrollOffsetCorrection=0;
  int scrollConsumedCorrection=0;
  if (mLastY == Integer.MIN_VALUE) {
    rawDeltaY-=mMotionCorrection;
  }
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    scrollOffsetCorrection-=mScrollOffset[1];
    scrollConsumedCorrection-=mScrollConsumed[1];
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY - scrollConsumedCorrection : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            final boolean atOverscrollEdge=overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (atOverscrollEdge && mVelocityTracker != null) {
              mVelocityTracker.clear();
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              if (!atOverscrollEdge) {
                mDirection=0;
                mTouchMode=TOUCH_MODE_OVERSCROLL;
              }
              if (incrementalDeltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight(),(float)x / getWidth());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
              }
 else               if (incrementalDeltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight(),1.f - (float)x / getWidth());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
              }
            }
          }
        }
        mMotionY=y + scrollOffsetCorrection;
      }
      mLastY=y + lastYCorrection + scrollOffsetCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight(),(float)x / getWidth());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(0,0,getWidth(),mEdgeGlowTop.getMaxHeight() + getPaddingTop());
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight(),1.f - (float)x / getWidth());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(0,getHeight() - getPaddingBottom() - mEdgeGlowBottom.getMaxHeight(),getWidth(),getHeight());
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}",0.9360902255639098
199285,"/** 
 * Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to  {@link Adapter#getView(int,View,ViewGroup)}.
 * @param view The view whose scroll state is being reported
 * @param scrollState The current scroll state. One of {@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
 */
public void onScrollStateChanged(AbsListView view,int scrollState);","/** 
 * Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to  {@link Adapter#getView(int,View,ViewGroup)}.
 * @param view The view whose scroll state is being reported
 * @param scrollState The current scroll state. One of{@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
 */
public void onScrollStateChanged(AbsListView view,int scrollState);",0.9990884229717412
199286,"private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}","private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  int scrollOffsetCorrection=0;
  int scrollConsumedCorrection=0;
  if (mLastY == Integer.MIN_VALUE) {
    rawDeltaY-=mMotionCorrection;
  }
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    scrollOffsetCorrection-=mScrollOffset[1];
    scrollConsumedCorrection-=mScrollConsumed[1];
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY - scrollConsumedCorrection : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y + scrollOffsetCorrection;
      }
      mLastY=y + lastYCorrection + scrollOffsetCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}",0.9323076923076924
199287,"/** 
 * Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to  {@link Adapter#getView(int,View,ViewGroup)}.
 * @param view The view whose scroll state is being reported
 * @param scrollState The current scroll state. One of {@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
 */
public void onScrollStateChanged(AbsListView view,int scrollState);","/** 
 * Callback method to be invoked while the list view or grid view is being scrolled. If the view is being scrolled, this method will be called before the next frame of the scroll is rendered. In particular, it will be called before any calls to  {@link Adapter#getView(int,View,ViewGroup)}.
 * @param view The view whose scroll state is being reported
 * @param scrollState The current scroll state. One of{@link #SCROLL_STATE_TOUCH_SCROLL} or {@link #SCROLL_STATE_IDLE}.
 */
public void onScrollStateChanged(AbsListView view,int scrollState);",0.9990884229717412
199288,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199289,"@Override public boolean onTouchEvent(MotionEvent ev){
  initVelocityTrackerIfNotExists();
  MotionEvent vtev=MotionEvent.obtain(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0) {
        return false;
      }
      if ((mIsBeingDragged=!mScroller.isFinished())) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        if (mFlingStrictSpan != null) {
          mFlingStrictSpan.finish();
          mFlingStrictSpan=null;
        }
      }
      mLastMotionY=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      startNestedScroll(SCROLL_AXIS_VERTICAL);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
int deltaY=mLastMotionY - y;
if (dispatchNestedPreScroll(0,deltaY,mScrollConsumed,mScrollOffset)) {
deltaY-=mScrollConsumed[1] + mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
final ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mIsBeingDragged=true;
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
final int oldY=mScrollY;
final int range=getScrollRange();
final int overscrollMode=getOverScrollMode();
boolean canOverscroll=overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
if (overScrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true) && !hasNestedScrollingParent()) {
mVelocityTracker.clear();
}
final int scrolledDeltaY=mScrollY - oldY;
final int unconsumedY=deltaY - scrolledDeltaY;
if (dispatchNestedScroll(0,scrolledDeltaY,0,unconsumedY,mScrollOffset)) {
mLastMotionY-=mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
 else if (canOverscroll) {
final int pulledToY=oldY + deltaY;
if (pulledToY < 0) {
mEdgeGlowTop.onPull((float)deltaY / getHeight());
if (!mEdgeGlowBottom.isFinished()) {
mEdgeGlowBottom.onRelease();
}
}
 else if (pulledToY > range) {
mEdgeGlowBottom.onPull((float)deltaY / getHeight());
if (!mEdgeGlowTop.isFinished()) {
mEdgeGlowTop.onRelease();
}
}
if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
postInvalidateOnAnimation();
}
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
flingWithNestedDispatch(-initialVelocity);
}
 else if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.addMovement(vtev);
}
vtev.recycle();
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  initVelocityTrackerIfNotExists();
  MotionEvent vtev=MotionEvent.obtain(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0) {
        return false;
      }
      if ((mIsBeingDragged=!mScroller.isFinished())) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        if (mFlingStrictSpan != null) {
          mFlingStrictSpan.finish();
          mFlingStrictSpan=null;
        }
      }
      mLastMotionY=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      startNestedScroll(SCROLL_AXIS_VERTICAL);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
int deltaY=mLastMotionY - y;
if (dispatchNestedPreScroll(0,deltaY,mScrollConsumed,mScrollOffset)) {
deltaY-=mScrollConsumed[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
final ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mIsBeingDragged=true;
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y - mScrollOffset[1];
final int oldY=mScrollY;
final int range=getScrollRange();
final int overscrollMode=getOverScrollMode();
boolean canOverscroll=overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
if (overScrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true) && !hasNestedScrollingParent()) {
mVelocityTracker.clear();
}
final int scrolledDeltaY=mScrollY - oldY;
final int unconsumedY=deltaY - scrolledDeltaY;
if (dispatchNestedScroll(0,scrolledDeltaY,0,unconsumedY,mScrollOffset)) {
mLastMotionY-=mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
 else if (canOverscroll) {
final int pulledToY=oldY + deltaY;
if (pulledToY < 0) {
mEdgeGlowTop.onPull((float)deltaY / getHeight());
if (!mEdgeGlowBottom.isFinished()) {
mEdgeGlowBottom.onRelease();
}
}
 else if (pulledToY > range) {
mEdgeGlowBottom.onPull((float)deltaY / getHeight());
if (!mEdgeGlowTop.isFinished()) {
mEdgeGlowTop.onRelease();
}
}
if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
postInvalidateOnAnimation();
}
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
flingWithNestedDispatch(-initialVelocity);
}
 else if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.addMovement(vtev);
}
vtev.recycle();
return true;
}",0.9142335766423356
199290,"@Override public boolean onTouchEvent(MotionEvent ev){
  initVelocityTrackerIfNotExists();
  MotionEvent vtev=MotionEvent.obtain(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0) {
        return false;
      }
      if ((mIsBeingDragged=!mScroller.isFinished())) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        if (mFlingStrictSpan != null) {
          mFlingStrictSpan.finish();
          mFlingStrictSpan=null;
        }
      }
      mLastMotionY=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      startNestedScroll(SCROLL_AXIS_VERTICAL);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
int deltaY=mLastMotionY - y;
if (dispatchNestedPreScroll(0,deltaY,mScrollConsumed,mScrollOffset)) {
deltaY-=mScrollConsumed[1] + mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
final ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mIsBeingDragged=true;
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
final int oldY=mScrollY;
final int range=getScrollRange();
final int overscrollMode=getOverScrollMode();
boolean canOverscroll=overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
if (overScrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true) && !hasNestedScrollingParent()) {
mVelocityTracker.clear();
}
final int scrolledDeltaY=mScrollY - oldY;
final int unconsumedY=deltaY - scrolledDeltaY;
if (dispatchNestedScroll(0,scrolledDeltaY,0,unconsumedY,mScrollOffset)) {
mLastMotionY-=mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
 else if (canOverscroll) {
final int pulledToY=oldY + deltaY;
if (pulledToY < 0) {
mEdgeGlowTop.onPull((float)deltaY / getHeight());
if (!mEdgeGlowBottom.isFinished()) {
mEdgeGlowBottom.onRelease();
}
}
 else if (pulledToY > range) {
mEdgeGlowBottom.onPull((float)deltaY / getHeight());
if (!mEdgeGlowTop.isFinished()) {
mEdgeGlowTop.onRelease();
}
}
if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
postInvalidateOnAnimation();
}
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
flingWithNestedDispatch(-initialVelocity);
}
 else if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.addMovement(vtev);
}
vtev.recycle();
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  initVelocityTrackerIfNotExists();
  MotionEvent vtev=MotionEvent.obtain(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0) {
        return false;
      }
      if ((mIsBeingDragged=!mScroller.isFinished())) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        if (mFlingStrictSpan != null) {
          mFlingStrictSpan.finish();
          mFlingStrictSpan=null;
        }
      }
      mLastMotionY=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      startNestedScroll(SCROLL_AXIS_VERTICAL);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
int deltaY=mLastMotionY - y;
if (dispatchNestedPreScroll(0,deltaY,mScrollConsumed,mScrollOffset)) {
deltaY-=mScrollConsumed[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
final ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mIsBeingDragged=true;
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y - mScrollOffset[1];
final int oldY=mScrollY;
final int range=getScrollRange();
final int overscrollMode=getOverScrollMode();
boolean canOverscroll=overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
if (overScrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true) && !hasNestedScrollingParent()) {
mVelocityTracker.clear();
}
final int scrolledDeltaY=mScrollY - oldY;
final int unconsumedY=deltaY - scrolledDeltaY;
if (dispatchNestedScroll(0,scrolledDeltaY,0,unconsumedY,mScrollOffset)) {
mLastMotionY-=mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
 else if (canOverscroll) {
final int pulledToY=oldY + deltaY;
if (pulledToY < 0) {
mEdgeGlowTop.onPull((float)deltaY / getHeight());
if (!mEdgeGlowBottom.isFinished()) {
mEdgeGlowBottom.onRelease();
}
}
 else if (pulledToY > range) {
mEdgeGlowBottom.onPull((float)deltaY / getHeight());
if (!mEdgeGlowTop.isFinished()) {
mEdgeGlowTop.onRelease();
}
}
if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
postInvalidateOnAnimation();
}
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
flingWithNestedDispatch(-initialVelocity);
}
 else if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.addMovement(vtev);
}
vtev.recycle();
return true;
}",0.9142335766423356
199291,"@Override public boolean onTouchEvent(MotionEvent ev){
  initVelocityTrackerIfNotExists();
  MotionEvent vtev=MotionEvent.obtain(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0) {
        return false;
      }
      if ((mIsBeingDragged=!mScroller.isFinished())) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        if (mFlingStrictSpan != null) {
          mFlingStrictSpan.finish();
          mFlingStrictSpan=null;
        }
      }
      mLastMotionY=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      startNestedScroll(SCROLL_AXIS_VERTICAL);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
int deltaY=mLastMotionY - y;
if (dispatchNestedPreScroll(0,deltaY,mScrollConsumed,mScrollOffset)) {
deltaY-=mScrollConsumed[1] + mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
final ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mIsBeingDragged=true;
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y;
final int oldY=mScrollY;
final int range=getScrollRange();
final int overscrollMode=getOverScrollMode();
boolean canOverscroll=overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
if (overScrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true) && !hasNestedScrollingParent()) {
mVelocityTracker.clear();
}
final int scrolledDeltaY=mScrollY - oldY;
final int unconsumedY=deltaY - scrolledDeltaY;
if (dispatchNestedScroll(0,scrolledDeltaY,0,unconsumedY,mScrollOffset)) {
mLastMotionY-=mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
 else if (canOverscroll) {
final int pulledToY=oldY + deltaY;
if (pulledToY < 0) {
mEdgeGlowTop.onPull((float)deltaY / getHeight());
if (!mEdgeGlowBottom.isFinished()) {
mEdgeGlowBottom.onRelease();
}
}
 else if (pulledToY > range) {
mEdgeGlowBottom.onPull((float)deltaY / getHeight());
if (!mEdgeGlowTop.isFinished()) {
mEdgeGlowTop.onRelease();
}
}
if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
postInvalidateOnAnimation();
}
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
flingWithNestedDispatch(-initialVelocity);
}
 else if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.addMovement(vtev);
}
vtev.recycle();
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  initVelocityTrackerIfNotExists();
  MotionEvent vtev=MotionEvent.obtain(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (getChildCount() == 0) {
        return false;
      }
      if ((mIsBeingDragged=!mScroller.isFinished())) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        if (mFlingStrictSpan != null) {
          mFlingStrictSpan.finish();
          mFlingStrictSpan=null;
        }
      }
      mLastMotionY=(int)ev.getY();
      mActivePointerId=ev.getPointerId(0);
      startNestedScroll(SCROLL_AXIS_VERTICAL);
      break;
    }
case MotionEvent.ACTION_MOVE:
  final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
if (activePointerIndex == -1) {
  Log.e(TAG,""String_Node_Str"" + mActivePointerId + ""String_Node_Str"");
  break;
}
final int y=(int)ev.getY(activePointerIndex);
int deltaY=mLastMotionY - y;
if (dispatchNestedPreScroll(0,deltaY,mScrollConsumed,mScrollOffset)) {
deltaY-=mScrollConsumed[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
final ViewParent parent=getParent();
if (parent != null) {
parent.requestDisallowInterceptTouchEvent(true);
}
mIsBeingDragged=true;
if (deltaY > 0) {
deltaY-=mTouchSlop;
}
 else {
deltaY+=mTouchSlop;
}
}
if (mIsBeingDragged) {
mLastMotionY=y - mScrollOffset[1];
final int oldY=mScrollY;
final int range=getScrollRange();
final int overscrollMode=getOverScrollMode();
boolean canOverscroll=overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
if (overScrollBy(0,deltaY,0,mScrollY,0,range,0,mOverscrollDistance,true) && !hasNestedScrollingParent()) {
mVelocityTracker.clear();
}
final int scrolledDeltaY=mScrollY - oldY;
final int unconsumedY=deltaY - scrolledDeltaY;
if (dispatchNestedScroll(0,scrolledDeltaY,0,unconsumedY,mScrollOffset)) {
mLastMotionY-=mScrollOffset[1];
vtev.offsetLocation(0,mScrollOffset[1]);
}
 else if (canOverscroll) {
final int pulledToY=oldY + deltaY;
if (pulledToY < 0) {
mEdgeGlowTop.onPull((float)deltaY / getHeight());
if (!mEdgeGlowBottom.isFinished()) {
mEdgeGlowBottom.onRelease();
}
}
 else if (pulledToY > range) {
mEdgeGlowBottom.onPull((float)deltaY / getHeight());
if (!mEdgeGlowTop.isFinished()) {
mEdgeGlowTop.onRelease();
}
}
if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
postInvalidateOnAnimation();
}
}
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
flingWithNestedDispatch(-initialVelocity);
}
 else if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged && getChildCount() > 0) {
if (mScroller.springBack(mScrollX,mScrollY,0,0,0,getScrollRange())) {
postInvalidateOnAnimation();
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
{
final int index=ev.getActionIndex();
mLastMotionY=(int)ev.getY(index);
mActivePointerId=ev.getPointerId(index);
break;
}
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
mLastMotionY=(int)ev.getY(ev.findPointerIndex(mActivePointerId));
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.addMovement(vtev);
}
vtev.recycle();
return true;
}",0.9142335766423356
199292,"private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            vtev.offsetLocation(0,mScrollOffset[1]);
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}","private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}",0.9955947136563876
199293,"private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            vtev.offsetLocation(0,mScrollOffset[1]);
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}","private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}",0.9955947136563876
199294,"private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            vtev.offsetLocation(0,mScrollOffset[1]);
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}","private void scrollIfNeeded(int y,MotionEvent vtev){
  int rawDeltaY=y - mMotionY;
  if (dispatchNestedPreScroll(0,rawDeltaY,mScrollConsumed,mScrollOffset)) {
    rawDeltaY-=mScrollConsumed[1];
    mMotionCorrection-=mScrollOffset[1];
    if (mLastY != Integer.MIN_VALUE) {
      mLastY-=mScrollOffset[1] + mScrollConsumed[1];
    }
    if (vtev != null) {
      vtev.offsetLocation(0,mScrollOffset[1]);
    }
  }
  final int deltaY=rawDeltaY - mMotionCorrection;
  int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
  int lastYCorrection=0;
  if (mTouchMode == TOUCH_MODE_SCROLL) {
    if (PROFILE_SCROLLING) {
      if (!mScrollProfilingStarted) {
        Debug.startMethodTracing(""String_Node_Str"");
        mScrollProfilingStarted=true;
      }
    }
    if (mScrollStrictSpan == null) {
      mScrollStrictSpan=StrictMode.enterCriticalSpan(""String_Node_Str"");
    }
    if (y != mLastY) {
      if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > mTouchSlop) {
        final ViewParent parent=getParent();
        if (parent != null) {
          parent.requestDisallowInterceptTouchEvent(true);
        }
      }
      final int motionIndex;
      if (mMotionPosition >= 0) {
        motionIndex=mMotionPosition - mFirstPosition;
      }
 else {
        motionIndex=getChildCount() / 2;
      }
      int motionViewPrevTop=0;
      View motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        motionViewPrevTop=motionView.getTop();
      }
      boolean atEdge=false;
      if (incrementalDeltaY != 0) {
        atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
      }
      motionView=this.getChildAt(motionIndex);
      if (motionView != null) {
        final int motionViewRealTop=motionView.getTop();
        if (atEdge) {
          int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
          if (dispatchNestedScroll(0,overscroll - incrementalDeltaY,0,overscroll,mScrollOffset)) {
            mMotionCorrection-=mScrollOffset[1];
            lastYCorrection-=mScrollOffset[1];
            if (vtev != null) {
              vtev.offsetLocation(0,mScrollOffset[1]);
            }
          }
 else {
            overScrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
            if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
              if (mVelocityTracker != null) {
                mVelocityTracker.clear();
              }
            }
            final int overscrollMode=getOverScrollMode();
            if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
              mDirection=0;
              mTouchMode=TOUCH_MODE_OVERSCROLL;
              if (deltaY > 0) {
                mEdgeGlowTop.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowBottom.isFinished()) {
                  mEdgeGlowBottom.onRelease();
                }
                invalidate(mEdgeGlowTop.getBounds(false));
              }
 else               if (deltaY < 0) {
                mEdgeGlowBottom.onPull((float)overscroll / getHeight());
                if (!mEdgeGlowTop.isFinished()) {
                  mEdgeGlowTop.onRelease();
                }
                invalidate(mEdgeGlowBottom.getBounds(true));
              }
            }
          }
        }
        mMotionY=y;
      }
      mLastY=y + lastYCorrection;
    }
  }
 else   if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
    if (y != mLastY) {
      final int oldScroll=mScrollY;
      final int newScroll=oldScroll - incrementalDeltaY;
      int newDirection=y > mLastY ? 1 : -1;
      if (mDirection == 0) {
        mDirection=newDirection;
      }
      int overScrollDistance=-incrementalDeltaY;
      if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
        overScrollDistance=-oldScroll;
        incrementalDeltaY+=overScrollDistance;
      }
 else {
        incrementalDeltaY=0;
      }
      if (overScrollDistance != 0) {
        overScrollBy(0,overScrollDistance,0,mScrollY,0,0,0,mOverscrollDistance,true);
        final int overscrollMode=getOverScrollMode();
        if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
          if (rawDeltaY > 0) {
            mEdgeGlowTop.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowBottom.isFinished()) {
              mEdgeGlowBottom.onRelease();
            }
            invalidate(mEdgeGlowTop.getBounds(false));
          }
 else           if (rawDeltaY < 0) {
            mEdgeGlowBottom.onPull((float)overScrollDistance / getHeight());
            if (!mEdgeGlowTop.isFinished()) {
              mEdgeGlowTop.onRelease();
            }
            invalidate(mEdgeGlowBottom.getBounds(true));
          }
        }
      }
      if (incrementalDeltaY != 0) {
        if (mScrollY != 0) {
          mScrollY=0;
          invalidateParentIfNeeded();
        }
        trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
        mTouchMode=TOUCH_MODE_SCROLL;
        final int motionPosition=findClosestMotionRow(y);
        mMotionCorrection=0;
        View motionView=getChildAt(motionPosition - mFirstPosition);
        mMotionViewOriginalTop=motionView != null ? motionView.getTop() : 0;
        mMotionY=y;
        mMotionPosition=motionPosition;
      }
      mLastY=y;
      mDirection=newDirection;
    }
  }
}",0.9955947136563876
199295,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
app.keeping=true;
}
adj=app.modifyRawOomAdj(adj);
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
app.keeping=true;
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9989431289097088
199296,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
app.keeping=true;
}
adj=app.modifyRawOomAdj(adj);
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
app.keeping=true;
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9989431289097088
199297,"public int getActionBarHideOffset(){
  return -((int)mActionBarTop.getTranslationY());
}","public int getActionBarHideOffset(){
  return mActionBarTop != null ? -((int)mActionBarTop.getTranslationY()) : 0;
}",0.8627450980392157
199298,"private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
app.keeping=true;
}
adj=app.modifyRawOomAdj(adj);
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}","private final int computeOomAdjLocked(ProcessRecord app,int cachedAdj,ProcessRecord TOP_APP,boolean doingAll,long now){
  if (mAdjSeq == app.adjSeq) {
    return app.curRawAdj;
  }
  if (app.thread == null) {
    app.adjSeq=mAdjSeq;
    app.curSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.curProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);
  }
  app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
  app.adjSource=null;
  app.adjTarget=null;
  app.empty=false;
  app.cached=false;
  final int activitiesSize=app.activities.size();
  if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
    app.adjType=""String_Node_Str"";
    app.adjSeq=mAdjSeq;
    app.curRawAdj=app.maxAdj;
    app.foregroundActivities=false;
    app.keeping=true;
    app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
    app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT;
    app.systemNoUi=true;
    if (app == TOP_APP) {
      app.systemNoUi=false;
    }
 else     if (activitiesSize > 0) {
      for (int j=0; j < activitiesSize; j++) {
        final ActivityRecord r=app.activities.get(j);
        if (r.visible) {
          app.systemNoUi=false;
        }
      }
    }
    if (!app.systemNoUi) {
      app.curProcState=ActivityManager.PROCESS_STATE_PERSISTENT_UI;
    }
    return (app.curAdj=app.maxAdj);
  }
  app.keeping=false;
  app.systemNoUi=false;
  int adj;
  int schedGroup;
  int procState;
  boolean foregroundActivities=false;
  boolean interesting=false;
  BroadcastQueue queue;
  if (app == TOP_APP) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    foregroundActivities=true;
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_TOP;
  }
 else   if (app.instrumentationClass != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=Process.THREAD_GROUP_DEFAULT;
    app.adjType=""String_Node_Str"";
    interesting=true;
    procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
  }
 else   if ((queue=isReceivingBroadcast(app)) != null) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=(queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_RECEIVER;
  }
 else   if (app.executingServices.size() > 0) {
    adj=ProcessList.FOREGROUND_APP_ADJ;
    schedGroup=app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
    app.adjType=""String_Node_Str"";
    procState=ActivityManager.PROCESS_STATE_SERVICE;
  }
 else {
    schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
    adj=cachedAdj;
    procState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
    app.cached=true;
    app.empty=true;
    app.adjType=""String_Node_Str"";
  }
  if (!foregroundActivities && activitiesSize > 0) {
    for (int j=0; j < activitiesSize; j++) {
      final ActivityRecord r=app.activities.get(j);
      if (r.app != app) {
        Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ app+ ""String_Node_Str"");
        continue;
      }
      if (r.visible) {
        if (adj > ProcessList.VISIBLE_APP_ADJ) {
          adj=ProcessList.VISIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
        break;
      }
 else       if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (procState > ActivityManager.PROCESS_STATE_TOP) {
          procState=ActivityManager.PROCESS_STATE_TOP;
        }
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else       if (r.state == ActivityState.STOPPING) {
        if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          adj=ProcessList.PERCEPTIBLE_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        if (!r.finishing) {
          if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          }
        }
        app.cached=false;
        app.empty=false;
        foregroundActivities=true;
      }
 else {
        if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
          procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
          app.adjType=""String_Node_Str"";
        }
      }
    }
  }
  if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
    if (app.foregroundServices) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
 else     if (app.forcingToForeground != null) {
      adj=ProcessList.PERCEPTIBLE_APP_ADJ;
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      app.cached=false;
      app.adjType=""String_Node_Str"";
      app.adjSource=app.forcingToForeground;
      schedGroup=Process.THREAD_GROUP_DEFAULT;
    }
  }
  if (app.foregroundServices) {
    interesting=true;
  }
  if (app == mHeavyWeightProcess) {
    if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
      adj=ProcessList.HEAVY_WEIGHT_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
      procState=ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
    }
  }
  if (app == mHomeProcess) {
    if (adj > ProcessList.HOME_APP_ADJ) {
      adj=ProcessList.HOME_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_HOME) {
      procState=ActivityManager.PROCESS_STATE_HOME;
    }
  }
  if (app == mPreviousProcess && app.activities.size() > 0) {
    if (adj > ProcessList.PREVIOUS_APP_ADJ) {
      adj=ProcessList.PREVIOUS_APP_ADJ;
      schedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      app.cached=false;
      app.adjType=""String_Node_Str"";
    }
    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
      procState=ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
    }
  }
  if (false)   Slog.i(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ adj+ ""String_Node_Str""+ app.adjType);
  app.adjSeq=mAdjSeq;
  app.curRawAdj=adj;
  app.hasStartedServices=false;
  if (mBackupTarget != null && app == mBackupTarget.app) {
    if (adj > ProcessList.BACKUP_APP_ADJ) {
      if (DEBUG_BACKUP)       Slog.v(TAG,""String_Node_Str"" + app);
      adj=ProcessList.BACKUP_APP_ADJ;
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
      }
      app.adjType=""String_Node_Str"";
      app.cached=false;
    }
    if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
      procState=ActivityManager.PROCESS_STATE_BACKUP;
    }
  }
  boolean mayBeTop=false;
  for (int is=app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
    ServiceRecord s=app.services.valueAt(is);
    if (s.startRequested) {
      app.hasStartedServices=true;
      if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
        procState=ActivityManager.PROCESS_STATE_SERVICE;
      }
      if (app.hasShownUi && app != mHomeProcess) {
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
 else {
        if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
          if (adj > ProcessList.SERVICE_ADJ) {
            adj=ProcessList.SERVICE_ADJ;
            app.adjType=""String_Node_Str"";
            app.cached=false;
          }
        }
        if (adj > ProcessList.SERVICE_ADJ) {
          app.adjType=""String_Node_Str"";
        }
      }
      app.keeping=true;
    }
    for (int conni=s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
      ArrayList<ConnectionRecord> clist=s.connections.valueAt(conni);
      for (int i=0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
        ConnectionRecord cr=clist.get(i);
        if (cr.binding.client == app) {
          continue;
        }
        if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
          ProcessRecord client=cr.binding.client;
          int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
          int clientProcState=client.curProcState;
          if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
            clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
          }
          String adjType=null;
          if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
            if (app.hasShownUi && app != mHomeProcess) {
              if (adj > clientAdj) {
                adjType=""String_Node_Str"";
              }
              app.cached=false;
              clientAdj=adj;
              clientProcState=procState;
            }
 else {
              if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                if (adj > clientAdj) {
                  adjType=""String_Node_Str"";
                }
                clientAdj=adj;
              }
            }
          }
          if (adj > clientAdj) {
            if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
              adjType=""String_Node_Str"";
            }
 else {
              if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                adj=clientAdj;
              }
 else               if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj=ProcessList.PERCEPTIBLE_APP_ADJ;
              }
 else               if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                adj=clientAdj;
              }
 else {
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                  adj=ProcessList.VISIBLE_APP_ADJ;
                }
              }
              if (!client.cached) {
                app.cached=false;
              }
              if (client.keeping) {
                app.keeping=true;
              }
              adjType=""String_Node_Str"";
            }
          }
          if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
              if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                mayBeTop=true;
                clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
              }
 else {
                clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
              }
            }
          }
 else {
            if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
              clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
          }
          if (procState > clientProcState) {
            procState=clientProcState;
          }
          if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
            app.pendingUiClean=true;
          }
          if (adjType != null) {
            app.adjType=adjType;
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=cr.binding.client;
            app.adjSourceOom=clientAdj;
            app.adjTarget=s.name;
          }
        }
        if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
          app.treatLikeActivity=true;
        }
        final ActivityRecord a=cr.activity;
        if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
          if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
            adj=ProcessList.FOREGROUND_APP_ADJ;
            if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
              schedGroup=Process.THREAD_GROUP_DEFAULT;
            }
            app.cached=false;
            app.adjType=""String_Node_Str"";
            app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
            app.adjSource=a;
            app.adjSourceOom=adj;
            app.adjTarget=s.name;
          }
        }
      }
    }
  }
  for (int provi=app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(provi);
    for (int i=cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
      ContentProviderConnection conn=cpr.connections.get(i);
      ProcessRecord client=conn.client;
      if (client == app) {
        continue;
      }
      int clientAdj=computeOomAdjLocked(client,cachedAdj,TOP_APP,doingAll,now);
      int clientProcState=client.curProcState;
      if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
        clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
      }
      if (adj > clientAdj) {
        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
          app.adjType=""String_Node_Str"";
        }
 else {
          adj=clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
          app.adjType=""String_Node_Str"";
        }
        app.cached&=client.cached;
        app.keeping|=client.keeping;
        app.adjTypeCode=ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
        app.adjSource=client;
        app.adjSourceOom=clientAdj;
        app.adjTarget=cpr.name;
      }
      if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
        if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
          mayBeTop=true;
          clientProcState=ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        }
 else {
          clientProcState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
        }
      }
      if (procState > clientProcState) {
        procState=clientProcState;
      }
      if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
        schedGroup=Process.THREAD_GROUP_DEFAULT;
      }
    }
    if (cpr.hasExternalProcessHandles()) {
      if (adj > ProcessList.FOREGROUND_APP_ADJ) {
        adj=ProcessList.FOREGROUND_APP_ADJ;
        schedGroup=Process.THREAD_GROUP_DEFAULT;
        app.cached=false;
        app.keeping=true;
        app.adjType=""String_Node_Str"";
        app.adjTarget=cpr.name;
      }
      if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
      }
    }
  }
  if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
switch (procState) {
case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
case ActivityManager.PROCESS_STATE_SERVICE:
      procState=ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
    break;
default :
  procState=ActivityManager.PROCESS_STATE_TOP;
break;
}
}
if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
if (app.hasClientActivities) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
app.adjType=""String_Node_Str"";
}
 else if (app.treatLikeActivity) {
procState=ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
app.adjType=""String_Node_Str"";
}
}
if (adj == ProcessList.SERVICE_ADJ) {
if (doingAll) {
app.serviceb=mNewNumAServiceProcs > (mNumServiceProcs / 3);
mNewNumServiceProcs++;
if (!app.serviceb) {
if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
  app.serviceHighRam=true;
  app.serviceb=true;
}
 else {
  mNewNumAServiceProcs++;
}
}
 else {
app.serviceHighRam=false;
}
}
if (app.serviceb) {
adj=ProcessList.SERVICE_B_ADJ;
}
}
app.curRawAdj=adj;
if (adj > app.maxAdj) {
adj=app.maxAdj;
if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
schedGroup=Process.THREAD_GROUP_DEFAULT;
}
}
if (adj < ProcessList.CACHED_APP_MIN_ADJ) {
app.keeping=true;
}
app.curAdj=app.modifyRawOomAdj(adj);
app.curSchedGroup=schedGroup;
app.curProcState=procState;
app.foregroundActivities=foregroundActivities;
return app.curRawAdj;
}",0.9989431289097088
199299,"public int getActionBarHideOffset(){
  return -((int)mActionBarTop.getTranslationY());
}","public int getActionBarHideOffset(){
  return mActionBarTop != null ? -((int)mActionBarTop.getTranslationY()) : 0;
}",0.8627450980392157
199300,"public int getActionBarHideOffset(){
  return -((int)mActionBarTop.getTranslationY());
}","public int getActionBarHideOffset(){
  return mActionBarTop != null ? -((int)mActionBarTop.getTranslationY()) : 0;
}",0.8627450980392157
199301,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199302,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199303,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199304,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199305,"@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  updateScrollStateForRemovedChild(child);
  if (mIsExpanded) {
    mChildrenToRemoveAnimated.add(child);
    mChildHierarchyDirty=true;
  }
}","@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  updateScrollStateForRemovedChild(child);
  if (mIsExpanded) {
    if (!mChildrenToAddAnimated.contains(child)) {
      mChildrenToRemoveAnimated.add(child);
      mChildHierarchyDirty=true;
    }
 else {
      mChildrenToAddAnimated.remove(child);
    }
  }
}",0.8690869086908691
199306,"/** 
 * Updates the children views according to the stack scroll algorithm. Call this whenever modifications to   {@link #mOwnScrollY} are performed to reflect it in the view layout.
 */
private void updateChildren(){
  mCurrentStackScrollState.setScrollY(mOwnScrollY);
  mStackScrollAlgorithm.getStackScrollState(mCurrentStackScrollState);
  if (!isCurrentlyAnimating() && !mChildHierarchyDirty) {
    applyCurrentState();
    if (mListener != null) {
      mListener.onChildLocationsChanged(this);
    }
  }
 else {
    startAnimationToState(mCurrentStackScrollState);
  }
}","/** 
 * Updates the children views according to the stack scroll algorithm. Call this whenever modifications to   {@link #mOwnScrollY} are performed to reflect it in the view layout.
 */
private void updateChildren(){
  mCurrentStackScrollState.setScrollY(mOwnScrollY);
  mStackScrollAlgorithm.getStackScrollState(mCurrentStackScrollState);
  if (!isCurrentlyAnimating() && !mChildHierarchyDirty) {
    applyCurrentState();
  }
 else {
    startAnimationToState();
  }
}",0.8432122370936902
199307,"private void startAnimationToState(StackScrollState finalState){
  if (mChildHierarchyDirty) {
    generateChildHierarchyEvents();
    mChildHierarchyDirty=false;
  }
  mStateAnimator.startAnimationForEvents(mAnimationEvents,finalState);
}","private void startAnimationToState(){
  if (mChildHierarchyDirty) {
    generateChildHierarchyEvents();
    mChildHierarchyDirty=false;
  }
  if (!mAnimationEvents.isEmpty()) {
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState);
  }
 else {
    applyCurrentState();
  }
}",0.7119266055045872
199308,"private void applyCurrentState(){
  mListenForHeightChanges=false;
  mCurrentStackScrollState.apply();
  mListenForHeightChanges=true;
}","private void applyCurrentState(){
  mListenForHeightChanges=false;
  mCurrentStackScrollState.apply();
  mListenForHeightChanges=true;
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}",0.7816091954022989
199309,"public void onChildAnimationFinished(){
  applyCurrentState();
  mAnimationEvents.clear();
}","public void onChildAnimationFinished(){
  updateChildren();
  mAnimationEvents.clear();
}",0.8839779005524862
199310,"public void onChildAnimationFinished(){
  applyCurrentState();
  mAnimationEvents.clear();
}","public void onChildAnimationFinished(){
  updateChildren();
  mAnimationEvents.clear();
}",0.8839779005524862
199311,"@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  updateScrollStateForRemovedChild(child);
  if (mIsExpanded) {
    mChildrenToRemoveAnimated.add(child);
    mChildHierarchyDirty=true;
  }
}","@Override protected void onViewRemoved(View child){
  super.onViewRemoved(child);
  ((ExpandableView)child).setOnHeightChangedListener(null);
  mCurrentStackScrollState.removeViewStateForView(child);
  mStackScrollAlgorithm.notifyChildrenChanged(this);
  updateScrollStateForRemovedChild(child);
  if (mIsExpanded) {
    if (!mChildrenToAddAnimated.contains(child)) {
      mChildrenToRemoveAnimated.add(child);
      mChildHierarchyDirty=true;
    }
 else {
      mChildrenToAddAnimated.remove(child);
    }
  }
}",0.8690869086908691
199312,"/** 
 * Updates the children views according to the stack scroll algorithm. Call this whenever modifications to   {@link #mOwnScrollY} are performed to reflect it in the view layout.
 */
private void updateChildren(){
  mCurrentStackScrollState.setScrollY(mOwnScrollY);
  mStackScrollAlgorithm.getStackScrollState(mCurrentStackScrollState);
  if (!isCurrentlyAnimating() && !mChildHierarchyDirty) {
    applyCurrentState();
    if (mListener != null) {
      mListener.onChildLocationsChanged(this);
    }
  }
 else {
    startAnimationToState(mCurrentStackScrollState);
  }
}","/** 
 * Updates the children views according to the stack scroll algorithm. Call this whenever modifications to   {@link #mOwnScrollY} are performed to reflect it in the view layout.
 */
private void updateChildren(){
  mCurrentStackScrollState.setScrollY(mOwnScrollY);
  mStackScrollAlgorithm.getStackScrollState(mCurrentStackScrollState);
  if (!isCurrentlyAnimating() && !mChildHierarchyDirty) {
    applyCurrentState();
  }
 else {
    startAnimationToState();
  }
}",0.8432122370936902
199313,"private void startAnimationToState(StackScrollState finalState){
  if (mChildHierarchyDirty) {
    generateChildHierarchyEvents();
    mChildHierarchyDirty=false;
  }
  mStateAnimator.startAnimationForEvents(mAnimationEvents,finalState);
}","private void startAnimationToState(){
  if (mChildHierarchyDirty) {
    generateChildHierarchyEvents();
    mChildHierarchyDirty=false;
  }
  if (!mAnimationEvents.isEmpty()) {
    mStateAnimator.startAnimationForEvents(mAnimationEvents,mCurrentStackScrollState);
  }
 else {
    applyCurrentState();
  }
}",0.7119266055045872
199314,"private void applyCurrentState(){
  mListenForHeightChanges=false;
  mCurrentStackScrollState.apply();
  mListenForHeightChanges=true;
}","private void applyCurrentState(){
  mListenForHeightChanges=false;
  mCurrentStackScrollState.apply();
  mListenForHeightChanges=true;
  if (mListener != null) {
    mListener.onChildLocationsChanged(this);
  }
}",0.7816091954022989
199315,"public void onChildAnimationFinished(){
  applyCurrentState();
  mAnimationEvents.clear();
}","public void onChildAnimationFinished(){
  updateChildren();
  mAnimationEvents.clear();
}",0.8839779005524862
199316,"public void onChildAnimationFinished(){
  applyCurrentState();
  mAnimationEvents.clear();
}","public void onChildAnimationFinished(){
  updateChildren();
  mAnimationEvents.clear();
}",0.8839779005524862
199317,"private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize);
    if (scrollRange > 0 && getChildCount() > 0) {
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - mCollapsedSize);
    }
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize);
    if (scrollRange > 0) {
      View lastChild=getLastChildNotGone();
      if (isViewExpanded(lastChild)) {
        scrollRange+=mCollapsedSize + mPaddingBetweenElements;
      }
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - mCollapsedSize);
    }
  }
  return scrollRange;
}",0.6375545851528385
199318,"public int getEmptyBottomMargin(){
  return Math.max(getHeight() - mContentHeight,0);
}","public int getEmptyBottomMargin(){
  int emptyMargin=mMaxLayoutHeight - mContentHeight;
  if (needsHeightAdaption()) {
    emptyMargin=emptyMargin - mCollapsedSize - mBottomStackPeekSize;
  }
  return Math.max(emptyMargin,0);
}",0.3566878980891719
199319,"/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently inand which will be updated
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState){
  float bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mCollapsedSize;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackScrollState.ViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampYTranslation(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging) {
        childViewState.height=mCollapsedSize;
      }
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackScrollState.ViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=0;
      childViewState.location=StackScrollState.ViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackScrollState.ViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    childViewState.yTranslation+=mTopPadding;
  }
}","/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently inand which will be updated
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState){
  float bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mCollapsedSize;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackScrollState.ViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampYTranslation(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging && i != 0) {
        childViewState.height=mCollapsedSize;
      }
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackScrollState.ViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=0;
      childViewState.location=StackScrollState.ViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackScrollState.ViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    childViewState.yTranslation+=mTopPadding;
  }
}",0.9983016304347826
199320,"private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize);
    if (scrollRange > 0 && getChildCount() > 0) {
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - mCollapsedSize);
    }
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize);
    if (scrollRange > 0) {
      View lastChild=getLastChildNotGone();
      if (isViewExpanded(lastChild)) {
        scrollRange+=mCollapsedSize + mPaddingBetweenElements;
      }
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - mCollapsedSize);
    }
  }
  return scrollRange;
}",0.6375545851528385
199321,"public int getEmptyBottomMargin(){
  return Math.max(getHeight() - mContentHeight,0);
}","public int getEmptyBottomMargin(){
  int emptyMargin=mMaxLayoutHeight - mContentHeight;
  if (needsHeightAdaption()) {
    emptyMargin=emptyMargin - mCollapsedSize - mBottomStackPeekSize;
  }
  return Math.max(emptyMargin,0);
}",0.3566878980891719
199322,"/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently inand which will be updated
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState){
  float bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mCollapsedSize;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackScrollState.ViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampYTranslation(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging) {
        childViewState.height=mCollapsedSize;
      }
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackScrollState.ViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=0;
      childViewState.location=StackScrollState.ViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackScrollState.ViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    childViewState.yTranslation+=mTopPadding;
  }
}","/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently inand which will be updated
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState){
  float bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mCollapsedSize;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackScrollState.ViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampYTranslation(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging && i != 0) {
        childViewState.height=mCollapsedSize;
      }
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackScrollState.ViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=0;
      childViewState.location=StackScrollState.ViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackScrollState.ViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    childViewState.yTranslation+=mTopPadding;
  }
}",0.9983016304347826
199323,"private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize);
    if (scrollRange > 0 && getChildCount() > 0) {
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - mCollapsedSize);
    }
  }
  return scrollRange;
}","private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize);
    if (scrollRange > 0) {
      View lastChild=getLastChildNotGone();
      if (isViewExpanded(lastChild)) {
        scrollRange+=mCollapsedSize + mPaddingBetweenElements;
      }
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - mCollapsedSize);
    }
  }
  return scrollRange;
}",0.6375545851528385
199324,"public int getEmptyBottomMargin(){
  return Math.max(getHeight() - mContentHeight,0);
}","public int getEmptyBottomMargin(){
  int emptyMargin=mMaxLayoutHeight - mContentHeight;
  if (needsHeightAdaption()) {
    emptyMargin=emptyMargin - mCollapsedSize - mBottomStackPeekSize;
  }
  return Math.max(emptyMargin,0);
}",0.3566878980891719
199325,"/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently inand which will be updated
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState){
  float bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mCollapsedSize;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackScrollState.ViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampYTranslation(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging) {
        childViewState.height=mCollapsedSize;
      }
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackScrollState.ViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=0;
      childViewState.location=StackScrollState.ViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackScrollState.ViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    childViewState.yTranslation+=mTopPadding;
  }
}","/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently inand which will be updated
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState){
  float bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mCollapsedSize;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackScrollState.ViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampYTranslation(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging && i != 0) {
        childViewState.height=mCollapsedSize;
      }
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackScrollState.ViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=0;
      childViewState.location=StackScrollState.ViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackScrollState.ViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    childViewState.yTranslation+=mTopPadding;
  }
}",0.9983016304347826
199326,"private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}","private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getOemDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}",0.9964556962025316
199327,"private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}","private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getOemDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}",0.9964556962025316
199328,"private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}","private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getOemDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}",0.9964556962025316
199329,"private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}","private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getOemDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}",0.9964556962025316
199330,"static void preload(){
  preloadClasses();
  preloadResources();
  preloadOpenGL();
}","static void preload(){
  Log.d(TAG,""String_Node_Str"");
  preloadClasses();
  preloadResources();
  preloadOpenGL();
  Log.d(TAG,""String_Node_Str"");
}",0.7264957264957265
199331,"/** 
 * Close and clean up zygote sockets. Called on shutdown and on the child's exit path.
 */
static void closeServerSocket(){
  try {
    if (sServerSocket != null) {
      FileDescriptor fd=sServerSocket.getFileDescriptor();
      sServerSocket.close();
      if (fd != null) {
        Libcore.os.close(fd);
      }
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
catch (  libcore.io.ErrnoException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
  sServerSocket=null;
}","/** 
 * Close and clean up zygote sockets. Called on shutdown and on the child's exit path.
 */
static void closeServerSocket(){
  try {
    if (sServerSocket != null) {
      FileDescriptor fd=sServerSocket.getFileDescriptor();
      sServerSocket.close();
      if (fd != null) {
        Os.close(fd);
      }
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
  sServerSocket=null;
}",0.9787664307381192
199332,"static void preload(){
  preloadClasses();
  preloadResources();
  preloadOpenGL();
}","static void preload(){
  Log.d(TAG,""String_Node_Str"");
  preloadClasses();
  preloadResources();
  preloadOpenGL();
  Log.d(TAG,""String_Node_Str"");
}",0.7264957264957265
199333,"/** 
 * Close and clean up zygote sockets. Called on shutdown and on the child's exit path.
 */
static void closeServerSocket(){
  try {
    if (sServerSocket != null) {
      FileDescriptor fd=sServerSocket.getFileDescriptor();
      sServerSocket.close();
      if (fd != null) {
        Libcore.os.close(fd);
      }
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
catch (  libcore.io.ErrnoException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
  sServerSocket=null;
}","/** 
 * Close and clean up zygote sockets. Called on shutdown and on the child's exit path.
 */
static void closeServerSocket(){
  try {
    if (sServerSocket != null) {
      FileDescriptor fd=sServerSocket.getFileDescriptor();
      sServerSocket.close();
      if (fd != null) {
        Os.close(fd);
      }
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    Log.e(TAG,""String_Node_Str"",ex);
  }
  sServerSocket=null;
}",0.9787664307381192
199334,"/** 
 * Sets the outline of the view, which defines the shape of the shadow it casts. <p> If the outline is not set or is null, shadows will be cast from the bounds of the View.
 * @param outline The new outline of the view.Must be  {@link android.graphics.Outline#isValid() valid.}
 */
public void setOutline(@Nullable Outline outline){
  if (outline != null && !outline.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mPrivateFlags3|=PFLAG3_OUTLINE_DEFINED;
  if (outline == null) {
    mOutline=null;
  }
 else {
    if (mOutline == null) {
      mOutline=new Outline(outline);
    }
  }
  mRenderNode.setOutline(mOutline);
}","/** 
 * Sets the outline of the view, which defines the shape of the shadow it casts. <p> If the outline is not set or is null, shadows will be cast from the bounds of the View.
 * @param outline The new outline of the view.Must be  {@link android.graphics.Outline#isValid() valid.}
 */
public void setOutline(@Nullable Outline outline){
  if (outline != null && !outline.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mPrivateFlags3|=PFLAG3_OUTLINE_DEFINED;
  if (outline == null) {
    mOutline=null;
  }
 else {
    if (mOutline == null) {
      mOutline=new Outline();
    }
    mOutline.set(outline);
  }
  mRenderNode.setOutline(mOutline);
}",0.9745508982035928
199335,"/** 
 * Sets the outline of the view, which defines the shape of the shadow it casts. <p> If the outline is not set or is null, shadows will be cast from the bounds of the View.
 * @param outline The new outline of the view.Must be  {@link android.graphics.Outline#isValid() valid.}
 */
public void setOutline(@Nullable Outline outline){
  if (outline != null && !outline.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mPrivateFlags3|=PFLAG3_OUTLINE_DEFINED;
  if (outline == null) {
    mOutline=null;
  }
 else {
    if (mOutline == null) {
      mOutline=new Outline(outline);
    }
  }
  mRenderNode.setOutline(mOutline);
}","/** 
 * Sets the outline of the view, which defines the shape of the shadow it casts. <p> If the outline is not set or is null, shadows will be cast from the bounds of the View.
 * @param outline The new outline of the view.Must be  {@link android.graphics.Outline#isValid() valid.}
 */
public void setOutline(@Nullable Outline outline){
  if (outline != null && !outline.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mPrivateFlags3|=PFLAG3_OUTLINE_DEFINED;
  if (outline == null) {
    mOutline=null;
  }
 else {
    if (mOutline == null) {
      mOutline=new Outline();
    }
    mOutline.set(outline);
  }
  mRenderNode.setOutline(mOutline);
}",0.9745508982035928
199336,"/** 
 * Sets the outline of the view, which defines the shape of the shadow it casts. <p> If the outline is not set or is null, shadows will be cast from the bounds of the View.
 * @param outline The new outline of the view.Must be  {@link android.graphics.Outline#isValid() valid.}
 */
public void setOutline(@Nullable Outline outline){
  if (outline != null && !outline.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mPrivateFlags3|=PFLAG3_OUTLINE_DEFINED;
  if (outline == null) {
    mOutline=null;
  }
 else {
    if (mOutline == null) {
      mOutline=new Outline(outline);
    }
  }
  mRenderNode.setOutline(mOutline);
}","/** 
 * Sets the outline of the view, which defines the shape of the shadow it casts. <p> If the outline is not set or is null, shadows will be cast from the bounds of the View.
 * @param outline The new outline of the view.Must be  {@link android.graphics.Outline#isValid() valid.}
 */
public void setOutline(@Nullable Outline outline){
  if (outline != null && !outline.isValid()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mPrivateFlags3|=PFLAG3_OUTLINE_DEFINED;
  if (outline == null) {
    mOutline=null;
  }
 else {
    if (mOutline == null) {
      mOutline=new Outline();
    }
    mOutline.set(outline);
  }
  mRenderNode.setOutline(mOutline);
}",0.9745508982035928
199337,"@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<TaskRecord> recentTasks=new ArrayList<TaskRecord>();
  final ArrayList<TaskRecord> tasksToRemove=new ArrayList<TaskRecord>();
synchronized (ActivityManagerService.this) {
    recentTasks.addAll(mRecentTasks);
  }
  Intent tmpI=new Intent();
  for (int i=recentTasks.size() - 1; i >= 0; i--) {
    TaskRecord tr=recentTasks.get(i);
    ComponentName cn=tr.intent.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(tr);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      TaskRecord tr=tasksToRemove.get(i);
      removeTaskByIdLocked(tr.taskId,0);
    }
  }
  return true;
}","@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<Pair<Intent,Integer>> recentTaskIntents=new ArrayList<Pair<Intent,Integer>>();
  final ArrayList<Integer> tasksToRemove=new ArrayList<Integer>();
synchronized (ActivityManagerService.this) {
    for (int i=mRecentTasks.size() - 1; i >= 0; i--) {
      TaskRecord tr=mRecentTasks.get(i);
      recentTaskIntents.add(new Pair<Intent,Integer>(tr.intent,tr.taskId));
    }
  }
  Intent tmpI=new Intent();
  for (int i=recentTaskIntents.size() - 1; i >= 0; i--) {
    Pair<Intent,Integer> p=recentTaskIntents.get(i);
    ComponentName cn=p.first.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(p.second);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      removeTaskByIdLocked(tasksToRemove.get(i),0);
    }
  }
  return true;
}",0.7548845470692718
199338,"private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    mService.setFocusedActivityLocked(mStackSupervisor.topRunningActivityLocked());
  }
}","private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    ActivityRecord top=mStackSupervisor.topRunningActivityLocked();
    if (top != null) {
      mService.setFocusedActivityLocked(top);
    }
  }
}",0.8536831483350151
199339,"@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<TaskRecord> recentTasks=new ArrayList<TaskRecord>();
  final ArrayList<TaskRecord> tasksToRemove=new ArrayList<TaskRecord>();
synchronized (ActivityManagerService.this) {
    recentTasks.addAll(mRecentTasks);
  }
  Intent tmpI=new Intent();
  for (int i=recentTasks.size() - 1; i >= 0; i--) {
    TaskRecord tr=recentTasks.get(i);
    ComponentName cn=tr.intent.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(tr);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      TaskRecord tr=tasksToRemove.get(i);
      removeTaskByIdLocked(tr.taskId,0);
    }
  }
  return true;
}","@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<Pair<Intent,Integer>> recentTaskIntents=new ArrayList<Pair<Intent,Integer>>();
  final ArrayList<Integer> tasksToRemove=new ArrayList<Integer>();
synchronized (ActivityManagerService.this) {
    for (int i=mRecentTasks.size() - 1; i >= 0; i--) {
      TaskRecord tr=mRecentTasks.get(i);
      recentTaskIntents.add(new Pair<Intent,Integer>(tr.intent,tr.taskId));
    }
  }
  Intent tmpI=new Intent();
  for (int i=recentTaskIntents.size() - 1; i >= 0; i--) {
    Pair<Intent,Integer> p=recentTaskIntents.get(i);
    ComponentName cn=p.first.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(p.second);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      removeTaskByIdLocked(tasksToRemove.get(i),0);
    }
  }
  return true;
}",0.7548845470692718
199340,"private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    mService.setFocusedActivityLocked(mStackSupervisor.topRunningActivityLocked());
  }
}","private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    ActivityRecord top=mStackSupervisor.topRunningActivityLocked();
    if (top != null) {
      mService.setFocusedActivityLocked(top);
    }
  }
}",0.8536831483350151
199341,"@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<TaskRecord> recentTasks=new ArrayList<TaskRecord>();
  final ArrayList<TaskRecord> tasksToRemove=new ArrayList<TaskRecord>();
synchronized (ActivityManagerService.this) {
    recentTasks.addAll(mRecentTasks);
  }
  Intent tmpI=new Intent();
  for (int i=recentTasks.size() - 1; i >= 0; i--) {
    TaskRecord tr=recentTasks.get(i);
    ComponentName cn=tr.intent.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(tr);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      TaskRecord tr=tasksToRemove.get(i);
      removeTaskByIdLocked(tr.taskId,0);
    }
  }
  return true;
}","@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<Pair<Intent,Integer>> recentTaskIntents=new ArrayList<Pair<Intent,Integer>>();
  final ArrayList<Integer> tasksToRemove=new ArrayList<Integer>();
synchronized (ActivityManagerService.this) {
    for (int i=mRecentTasks.size() - 1; i >= 0; i--) {
      TaskRecord tr=mRecentTasks.get(i);
      recentTaskIntents.add(new Pair<Intent,Integer>(tr.intent,tr.taskId));
    }
  }
  Intent tmpI=new Intent();
  for (int i=recentTaskIntents.size() - 1; i >= 0; i--) {
    Pair<Intent,Integer> p=recentTaskIntents.get(i);
    ComponentName cn=p.first.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(p.second);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      removeTaskByIdLocked(tasksToRemove.get(i),0);
    }
  }
  return true;
}",0.7548845470692718
199342,"private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    mService.setFocusedActivityLocked(mStackSupervisor.topRunningActivityLocked());
  }
}","private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    ActivityRecord top=mStackSupervisor.topRunningActivityLocked();
    if (top != null) {
      mService.setFocusedActivityLocked(top);
    }
  }
}",0.8536831483350151
199343,"private boolean handleNativeEvent(int code,String raw,String[] cooked){
  boolean handled=true;
  NsdServiceInfo servInfo;
  int id=Integer.parseInt(cooked[1]);
  ClientInfo clientInfo=mIdToClientInfoMap.get(id);
  if (clientInfo == null) {
    Slog.e(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
  int clientId=-1;
  int keyId=clientInfo.mClientIds.indexOfValue(id);
  if (keyId != -1) {
    clientId=clientInfo.mClientIds.keyAt(keyId);
  }
 else {
    Slog.d(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
switch (code) {
case NativeResponseCode.SERVICE_FOUND:
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + raw);
  servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_FOUND,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_LOST:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_LOST,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_DISCOVERY_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.DISCOVER_SERVICES_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_REGISTERED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],null);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_SUCCEEDED,id,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_REGISTRATION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_UPDATED:
break;
case NativeResponseCode.SERVICE_UPDATE_FAILED:
break;
case NativeResponseCode.SERVICE_RESOLVED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
int index=cooked[2].indexOf(""String_Node_Str"");
if (index == -1) {
Slog.e(TAG,""String_Node_Str"" + raw);
break;
}
String name=cooked[2].substring(0,index);
String rest=cooked[2].substring(index);
String type=rest.replace(""String_Node_Str"",""String_Node_Str"");
clientInfo.mResolvedService.setServiceName(name);
clientInfo.mResolvedService.setServiceType(type);
clientInfo.mResolvedService.setPort(Integer.parseInt(cooked[4]));
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
int id2=getUniqueId();
if (getAddrInfo(id2,cooked[3])) {
storeRequestMap(clientId,id2,clientInfo,NsdManager.RESOLVE_SERVICE);
}
 else {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
clientInfo.mResolvedService=null;
}
break;
case NativeResponseCode.SERVICE_RESOLUTION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_FAILED:
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_SUCCESS:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
try {
clientInfo.mResolvedService.setHost(InetAddress.getByName(cooked[4]));
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_SUCCEEDED,0,clientId,clientInfo.mResolvedService);
}
 catch (java.net.UnknownHostException e) {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
}
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
break;
default :
handled=false;
break;
}
return handled;
}","private boolean handleNativeEvent(int code,String raw,String[] cooked){
  boolean handled=true;
  NsdServiceInfo servInfo;
  int id=Integer.parseInt(cooked[1]);
  ClientInfo clientInfo=mIdToClientInfoMap.get(id);
  if (clientInfo == null) {
    Slog.e(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
  int clientId=clientInfo.getClientId(id);
  if (clientId < 0) {
    Slog.d(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
switch (code) {
case NativeResponseCode.SERVICE_FOUND:
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + raw);
  servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_FOUND,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_LOST:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_LOST,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_DISCOVERY_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.DISCOVER_SERVICES_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_REGISTERED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],null);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_SUCCEEDED,id,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_REGISTRATION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_UPDATED:
break;
case NativeResponseCode.SERVICE_UPDATE_FAILED:
break;
case NativeResponseCode.SERVICE_RESOLVED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
int index=cooked[2].indexOf(""String_Node_Str"");
if (index == -1) {
Slog.e(TAG,""String_Node_Str"" + raw);
break;
}
String name=cooked[2].substring(0,index);
String rest=cooked[2].substring(index);
String type=rest.replace(""String_Node_Str"",""String_Node_Str"");
clientInfo.mResolvedService.setServiceName(name);
clientInfo.mResolvedService.setServiceType(type);
clientInfo.mResolvedService.setPort(Integer.parseInt(cooked[4]));
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
int id2=getUniqueId();
if (getAddrInfo(id2,cooked[3])) {
storeRequestMap(clientId,id2,clientInfo,NsdManager.RESOLVE_SERVICE);
}
 else {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
clientInfo.mResolvedService=null;
}
break;
case NativeResponseCode.SERVICE_RESOLUTION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_FAILED:
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_SUCCESS:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
try {
clientInfo.mResolvedService.setHost(InetAddress.getByName(cooked[4]));
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_SUCCEEDED,0,clientId,clientInfo.mResolvedService);
}
 catch (java.net.UnknownHostException e) {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
}
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
break;
default :
handled=false;
break;
}
return handled;
}",0.976314419573139
199344,"@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<TaskRecord> recentTasks=new ArrayList<TaskRecord>();
  final ArrayList<TaskRecord> tasksToRemove=new ArrayList<TaskRecord>();
synchronized (ActivityManagerService.this) {
    recentTasks.addAll(mRecentTasks);
  }
  Intent tmpI=new Intent();
  for (int i=recentTasks.size() - 1; i >= 0; i--) {
    TaskRecord tr=recentTasks.get(i);
    ComponentName cn=tr.intent.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(tr);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      TaskRecord tr=tasksToRemove.get(i);
      removeTaskByIdLocked(tr.taskId,0);
    }
  }
  return true;
}","@Override public boolean onPackageChanged(String packageName,int uid,String[] components){
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<Pair<Intent,Integer>> recentTaskIntents=new ArrayList<Pair<Intent,Integer>>();
  final ArrayList<Integer> tasksToRemove=new ArrayList<Integer>();
synchronized (ActivityManagerService.this) {
    for (int i=mRecentTasks.size() - 1; i >= 0; i--) {
      TaskRecord tr=mRecentTasks.get(i);
      recentTaskIntents.add(new Pair<Intent,Integer>(tr.intent,tr.taskId));
    }
  }
  Intent tmpI=new Intent();
  for (int i=recentTaskIntents.size() - 1; i >= 0; i--) {
    Pair<Intent,Integer> p=recentTaskIntents.get(i);
    ComponentName cn=p.first.getComponent();
    if (cn != null && cn.getPackageName().equals(packageName)) {
      try {
        tmpI.setComponent(cn);
        if (pm.queryIntentActivities(tmpI,PackageManager.MATCH_DEFAULT_ONLY).isEmpty()) {
          tasksToRemove.add(p.second);
        }
      }
 catch (      Exception e) {
      }
    }
  }
synchronized (ActivityManagerService.this) {
    for (int i=tasksToRemove.size() - 1; i >= 0; i--) {
      removeTaskByIdLocked(tasksToRemove.get(i),0);
    }
  }
  return true;
}",0.7548845470692718
199345,"private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    mService.setFocusedActivityLocked(mStackSupervisor.topRunningActivityLocked());
  }
}","private void adjustFocusedActivityLocked(ActivityRecord r){
  if (mStackSupervisor.isFrontStack(this) && mService.mFocusedActivity == r) {
    ActivityRecord next=topRunningActivityLocked(null);
    if (next != r) {
      final TaskRecord task=r.task;
      if (r.frontOfTask && task == topTask() && task.mOnTopOfHome) {
        mStackSupervisor.moveHomeToTop();
      }
    }
    ActivityRecord top=mStackSupervisor.topRunningActivityLocked();
    if (top != null) {
      mService.setFocusedActivityLocked(top);
    }
  }
}",0.8536831483350151
199346,"private boolean handleNativeEvent(int code,String raw,String[] cooked){
  boolean handled=true;
  NsdServiceInfo servInfo;
  int id=Integer.parseInt(cooked[1]);
  ClientInfo clientInfo=mIdToClientInfoMap.get(id);
  if (clientInfo == null) {
    Slog.e(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
  int clientId=-1;
  int keyId=clientInfo.mClientIds.indexOfValue(id);
  if (keyId != -1) {
    clientId=clientInfo.mClientIds.keyAt(keyId);
  }
 else {
    Slog.d(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
switch (code) {
case NativeResponseCode.SERVICE_FOUND:
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + raw);
  servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_FOUND,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_LOST:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_LOST,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_DISCOVERY_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.DISCOVER_SERVICES_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_REGISTERED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],null);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_SUCCEEDED,id,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_REGISTRATION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_UPDATED:
break;
case NativeResponseCode.SERVICE_UPDATE_FAILED:
break;
case NativeResponseCode.SERVICE_RESOLVED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
int index=cooked[2].indexOf(""String_Node_Str"");
if (index == -1) {
Slog.e(TAG,""String_Node_Str"" + raw);
break;
}
String name=cooked[2].substring(0,index);
String rest=cooked[2].substring(index);
String type=rest.replace(""String_Node_Str"",""String_Node_Str"");
clientInfo.mResolvedService.setServiceName(name);
clientInfo.mResolvedService.setServiceType(type);
clientInfo.mResolvedService.setPort(Integer.parseInt(cooked[4]));
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
int id2=getUniqueId();
if (getAddrInfo(id2,cooked[3])) {
storeRequestMap(clientId,id2,clientInfo,NsdManager.RESOLVE_SERVICE);
}
 else {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
clientInfo.mResolvedService=null;
}
break;
case NativeResponseCode.SERVICE_RESOLUTION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_FAILED:
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_SUCCESS:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
try {
clientInfo.mResolvedService.setHost(InetAddress.getByName(cooked[4]));
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_SUCCEEDED,0,clientId,clientInfo.mResolvedService);
}
 catch (java.net.UnknownHostException e) {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
}
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
break;
default :
handled=false;
break;
}
return handled;
}","private boolean handleNativeEvent(int code,String raw,String[] cooked){
  boolean handled=true;
  NsdServiceInfo servInfo;
  int id=Integer.parseInt(cooked[1]);
  ClientInfo clientInfo=mIdToClientInfoMap.get(id);
  if (clientInfo == null) {
    Slog.e(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
  int clientId=clientInfo.getClientId(id);
  if (clientId < 0) {
    Slog.d(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
switch (code) {
case NativeResponseCode.SERVICE_FOUND:
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + raw);
  servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_FOUND,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_LOST:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_LOST,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_DISCOVERY_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.DISCOVER_SERVICES_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_REGISTERED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],null);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_SUCCEEDED,id,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_REGISTRATION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_UPDATED:
break;
case NativeResponseCode.SERVICE_UPDATE_FAILED:
break;
case NativeResponseCode.SERVICE_RESOLVED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
int index=cooked[2].indexOf(""String_Node_Str"");
if (index == -1) {
Slog.e(TAG,""String_Node_Str"" + raw);
break;
}
String name=cooked[2].substring(0,index);
String rest=cooked[2].substring(index);
String type=rest.replace(""String_Node_Str"",""String_Node_Str"");
clientInfo.mResolvedService.setServiceName(name);
clientInfo.mResolvedService.setServiceType(type);
clientInfo.mResolvedService.setPort(Integer.parseInt(cooked[4]));
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
int id2=getUniqueId();
if (getAddrInfo(id2,cooked[3])) {
storeRequestMap(clientId,id2,clientInfo,NsdManager.RESOLVE_SERVICE);
}
 else {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
clientInfo.mResolvedService=null;
}
break;
case NativeResponseCode.SERVICE_RESOLUTION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_FAILED:
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_SUCCESS:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
try {
clientInfo.mResolvedService.setHost(InetAddress.getByName(cooked[4]));
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_SUCCEEDED,0,clientId,clientInfo.mResolvedService);
}
 catch (java.net.UnknownHostException e) {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
}
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
break;
default :
handled=false;
break;
}
return handled;
}",0.976314419573139
199347,"private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}","private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getOemDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}",0.9964556962025316
199348,"private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}","private String calculateApkRoot(final String codePathString){
  final File codePath=new File(codePathString);
  final File codeRoot;
  if (FileUtils.contains(Environment.getRootDirectory(),codePath)) {
    codeRoot=Environment.getRootDirectory();
  }
 else   if (FileUtils.contains(Environment.getOemDirectory(),codePath)) {
    codeRoot=Environment.getOemDirectory();
  }
 else   if (FileUtils.contains(Environment.getVendorDirectory(),codePath)) {
    codeRoot=Environment.getVendorDirectory();
  }
 else {
    try {
      File f=codePath.getCanonicalFile();
      File parent=f.getParentFile();
      File tmp;
      while ((tmp=parent.getParentFile()) != null) {
        f=parent;
        parent=tmp;
      }
      codeRoot=f;
      Slog.w(TAG,""String_Node_Str"" + codePath + ""String_Node_Str""+ codeRoot);
    }
 catch (    IOException e) {
      Slog.w(TAG,""String_Node_Str"" + codePath);
      return Environment.getRootDirectory().getPath();
    }
  }
  return codeRoot.getPath();
}",0.9964556962025316
199349,"private boolean handleNativeEvent(int code,String raw,String[] cooked){
  boolean handled=true;
  NsdServiceInfo servInfo;
  int id=Integer.parseInt(cooked[1]);
  ClientInfo clientInfo=mIdToClientInfoMap.get(id);
  if (clientInfo == null) {
    Slog.e(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
  int clientId=-1;
  int keyId=clientInfo.mClientIds.indexOfValue(id);
  if (keyId != -1) {
    clientId=clientInfo.mClientIds.keyAt(keyId);
  }
 else {
    Slog.d(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
switch (code) {
case NativeResponseCode.SERVICE_FOUND:
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + raw);
  servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_FOUND,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_LOST:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_LOST,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_DISCOVERY_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.DISCOVER_SERVICES_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_REGISTERED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],null);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_SUCCEEDED,id,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_REGISTRATION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_UPDATED:
break;
case NativeResponseCode.SERVICE_UPDATE_FAILED:
break;
case NativeResponseCode.SERVICE_RESOLVED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
int index=cooked[2].indexOf(""String_Node_Str"");
if (index == -1) {
Slog.e(TAG,""String_Node_Str"" + raw);
break;
}
String name=cooked[2].substring(0,index);
String rest=cooked[2].substring(index);
String type=rest.replace(""String_Node_Str"",""String_Node_Str"");
clientInfo.mResolvedService.setServiceName(name);
clientInfo.mResolvedService.setServiceType(type);
clientInfo.mResolvedService.setPort(Integer.parseInt(cooked[4]));
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
int id2=getUniqueId();
if (getAddrInfo(id2,cooked[3])) {
storeRequestMap(clientId,id2,clientInfo,NsdManager.RESOLVE_SERVICE);
}
 else {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
clientInfo.mResolvedService=null;
}
break;
case NativeResponseCode.SERVICE_RESOLUTION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_FAILED:
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_SUCCESS:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
try {
clientInfo.mResolvedService.setHost(InetAddress.getByName(cooked[4]));
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_SUCCEEDED,0,clientId,clientInfo.mResolvedService);
}
 catch (java.net.UnknownHostException e) {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
}
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
break;
default :
handled=false;
break;
}
return handled;
}","private boolean handleNativeEvent(int code,String raw,String[] cooked){
  boolean handled=true;
  NsdServiceInfo servInfo;
  int id=Integer.parseInt(cooked[1]);
  ClientInfo clientInfo=mIdToClientInfoMap.get(id);
  if (clientInfo == null) {
    Slog.e(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
  int clientId=clientInfo.getClientId(id);
  if (clientId < 0) {
    Slog.d(TAG,""String_Node_Str"" + id);
    handled=false;
    return handled;
  }
switch (code) {
case NativeResponseCode.SERVICE_FOUND:
    if (DBG)     Slog.d(TAG,""String_Node_Str"" + raw);
  servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_FOUND,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_LOST:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],cooked[3]);
clientInfo.mChannel.sendMessage(NsdManager.SERVICE_LOST,0,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_DISCOVERY_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.DISCOVER_SERVICES_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_REGISTERED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
servInfo=new NsdServiceInfo(cooked[2],null);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_SUCCEEDED,id,clientId,servInfo);
break;
case NativeResponseCode.SERVICE_REGISTRATION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.REGISTER_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_UPDATED:
break;
case NativeResponseCode.SERVICE_UPDATE_FAILED:
break;
case NativeResponseCode.SERVICE_RESOLVED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
int index=cooked[2].indexOf(""String_Node_Str"");
if (index == -1) {
Slog.e(TAG,""String_Node_Str"" + raw);
break;
}
String name=cooked[2].substring(0,index);
String rest=cooked[2].substring(index);
String type=rest.replace(""String_Node_Str"",""String_Node_Str"");
clientInfo.mResolvedService.setServiceName(name);
clientInfo.mResolvedService.setServiceType(type);
clientInfo.mResolvedService.setPort(Integer.parseInt(cooked[4]));
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
int id2=getUniqueId();
if (getAddrInfo(id2,cooked[3])) {
storeRequestMap(clientId,id2,clientInfo,NsdManager.RESOLVE_SERVICE);
}
 else {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
clientInfo.mResolvedService=null;
}
break;
case NativeResponseCode.SERVICE_RESOLUTION_FAILED:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
stopResolveService(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_FAILED:
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
break;
case NativeResponseCode.SERVICE_GET_ADDR_SUCCESS:
if (DBG) Slog.d(TAG,""String_Node_Str"" + raw);
try {
clientInfo.mResolvedService.setHost(InetAddress.getByName(cooked[4]));
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_SUCCEEDED,0,clientId,clientInfo.mResolvedService);
}
 catch (java.net.UnknownHostException e) {
clientInfo.mChannel.sendMessage(NsdManager.RESOLVE_SERVICE_FAILED,NsdManager.FAILURE_INTERNAL_ERROR,clientId);
}
stopGetAddrInfo(id);
removeRequestMap(clientId,id,clientInfo);
clientInfo.mResolvedService=null;
break;
default :
handled=false;
break;
}
return handled;
}",0.976314419573139
199350,"private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    Directions[] grow2=ArrayUtils.newUnpaddedArray(Directions.class,GrowingArrayUtils.growSize(want));
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
    int[] grow=new int[grow2.length];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}","private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    Directions[] grow2=ArrayUtils.newUnpaddedArray(Directions.class,GrowingArrayUtils.growSize(want));
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
    int[] grow=new int[grow2.length];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply && end != bufEnd) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}",0.9972514147130154
199351,"private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}","private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply && end != bufEnd) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}",0.9972398116577368
199352,"private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}","private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply && end != bufEnd) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}",0.9972398116577368
199353,"private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    Directions[] grow2=ArrayUtils.newUnpaddedArray(Directions.class,GrowingArrayUtils.growSize(want));
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
    int[] grow=new int[grow2.length];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}","private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    Directions[] grow2=ArrayUtils.newUnpaddedArray(Directions.class,GrowingArrayUtils.growSize(want));
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
    int[] grow=new int[grow2.length];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply && end != bufEnd) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}",0.9972514147130154
199354,"@Override public List<ResolveInfo> getLauncherActivities(String packageName,UserHandle user) throws RemoteException {
  ensureInUserProfiles(user,""String_Node_Str"" + user);
  final Intent mainIntent=new Intent(Intent.ACTION_MAIN,null);
  mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
  long ident=Binder.clearCallingIdentity();
  try {
    List<ResolveInfo> apps=mPm.queryIntentActivitiesAsUser(mainIntent,0,user.getIdentifier());
    return apps;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@Override public List<ResolveInfo> getLauncherActivities(String packageName,UserHandle user) throws RemoteException {
  ensureInUserProfiles(user,""String_Node_Str"" + user);
  final Intent mainIntent=new Intent(Intent.ACTION_MAIN,null);
  mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
  mainIntent.setPackage(packageName);
  long ident=Binder.clearCallingIdentity();
  try {
    List<ResolveInfo> apps=mPm.queryIntentActivitiesAsUser(mainIntent,0,user.getIdentifier());
    return apps;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9644194756554308
199355,"@Override public List<ResolveInfo> getLauncherActivities(String packageName,UserHandle user) throws RemoteException {
  ensureInUserProfiles(user,""String_Node_Str"" + user);
  final Intent mainIntent=new Intent(Intent.ACTION_MAIN,null);
  mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
  long ident=Binder.clearCallingIdentity();
  try {
    List<ResolveInfo> apps=mPm.queryIntentActivitiesAsUser(mainIntent,0,user.getIdentifier());
    return apps;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@Override public List<ResolveInfo> getLauncherActivities(String packageName,UserHandle user) throws RemoteException {
  ensureInUserProfiles(user,""String_Node_Str"" + user);
  final Intent mainIntent=new Intent(Intent.ACTION_MAIN,null);
  mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
  mainIntent.setPackage(packageName);
  long ident=Binder.clearCallingIdentity();
  try {
    List<ResolveInfo> apps=mPm.queryIntentActivitiesAsUser(mainIntent,0,user.getIdentifier());
    return apps;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9644194756554308
199356,"@Override public List<ResolveInfo> getLauncherActivities(String packageName,UserHandle user) throws RemoteException {
  ensureInUserProfiles(user,""String_Node_Str"" + user);
  final Intent mainIntent=new Intent(Intent.ACTION_MAIN,null);
  mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
  long ident=Binder.clearCallingIdentity();
  try {
    List<ResolveInfo> apps=mPm.queryIntentActivitiesAsUser(mainIntent,0,user.getIdentifier());
    return apps;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","@Override public List<ResolveInfo> getLauncherActivities(String packageName,UserHandle user) throws RemoteException {
  ensureInUserProfiles(user,""String_Node_Str"" + user);
  final Intent mainIntent=new Intent(Intent.ACTION_MAIN,null);
  mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
  mainIntent.setPackage(packageName);
  long ident=Binder.clearCallingIdentity();
  try {
    List<ResolveInfo> apps=mPm.queryIntentActivitiesAsUser(mainIntent,0,user.getIdentifier());
    return apps;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9644194756554308
199357,"private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}","private int out(CharSequence text,int start,int end,int above,int below,int top,int bottom,int v,float spacingmult,float spacingadd,LineHeightSpan[] chooseHt,int[] chooseHtv,Paint.FontMetricsInt fm,boolean hasTabOrEmoji,boolean needMultiply,byte[] chdirs,int dir,boolean easy,int bufEnd,boolean includePad,boolean trackPad,char[] chs,float[] widths,int widthStart,TextUtils.TruncateAt ellipsize,float ellipsisWidth,float textWidth,TextPaint paint,boolean moreChars){
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseHt != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseHt.length; i++) {
      if (chooseHt[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseHt[i]).chooseHeight(text,start,end,chooseHtv[i],v,fm,paint);
      }
 else {
        chooseHt[i].chooseHeight(text,start,end,chooseHtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackPad) {
      mTopPadding=top - above;
    }
    if (includePad) {
      above=top;
    }
  }
  if (end == bufEnd) {
    if (trackPad) {
      mBottomPadding=bottom - below;
    }
    if (includePad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply && end != bufEnd) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + EXTRA_ROUNDING);
    }
 else {
      extra=-(int)(-ex + EXTRA_ROUNDING);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (hasTabOrEmoji)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    mLineDirections[j]=AndroidBidi.directions(dir,chdirs,start - widthStart,chs,start - widthStart,end - start);
  }
  if (ellipsize != null) {
    boolean firstLine=(j == 0);
    boolean currentLineIsTheLastVisibleOne=(j + 1 == mMaximumVisibleLineCount);
    boolean forceEllipsis=moreChars && (mLineCount + 1 == mMaximumVisibleLineCount);
    boolean doEllipsis=(((mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
    if (doEllipsis) {
      calculateEllipsis(start,end,widths,widthStart,ellipsisWidth,ellipsize,j,textWidth,paint,forceEllipsis);
    }
  }
  mLineCount++;
  return v;
}",0.9972398116577368
199358,"private void updateMaxExpandHeight(){
  mSelfInitiatedLayout=true;
  ViewGroup.LayoutParams lp=getLayoutParams();
  int oldHeight=lp.height;
  lp.height=ViewGroup.LayoutParams.WRAP_CONTENT;
  setLayoutParams(lp);
  measure(View.MeasureSpec.makeMeasureSpec(getMeasuredWidth(),View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mRowMaxHeight,View.MeasureSpec.AT_MOST));
  lp.height=oldHeight;
  setLayoutParams(lp);
  mMaxExpandHeight=getMeasuredHeight();
  mSelfInitiatedLayout=false;
}","private void updateMaxExpandHeight(){
  mSelfInitiatedLayout=true;
  ViewGroup.LayoutParams lp=getLayoutParams();
  int oldHeight=lp.height;
  lp.height=ViewGroup.LayoutParams.WRAP_CONTENT;
  setLayoutParams(lp);
  measure(View.MeasureSpec.makeMeasureSpec(getWidth(),View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mRowMaxHeight,View.MeasureSpec.AT_MOST));
  lp.height=oldHeight;
  setLayoutParams(lp);
  mMaxExpandHeight=getMeasuredHeight();
  mSelfInitiatedLayout=false;
}",0.9918200408997956
199359,"private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getHeight();
    }
 else {
      mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}","private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getHeight();
    }
 else {
      if (mFirstChildWhileExpanding.getWidth() == 0) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            mFirstChildWhileExpanding.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}",0.5818692902319045
199360,"private void updateMaxExpandHeight(){
  mSelfInitiatedLayout=true;
  ViewGroup.LayoutParams lp=getLayoutParams();
  int oldHeight=lp.height;
  lp.height=ViewGroup.LayoutParams.WRAP_CONTENT;
  setLayoutParams(lp);
  measure(View.MeasureSpec.makeMeasureSpec(getMeasuredWidth(),View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mRowMaxHeight,View.MeasureSpec.AT_MOST));
  lp.height=oldHeight;
  setLayoutParams(lp);
  mMaxExpandHeight=getMeasuredHeight();
  mSelfInitiatedLayout=false;
}","private void updateMaxExpandHeight(){
  mSelfInitiatedLayout=true;
  ViewGroup.LayoutParams lp=getLayoutParams();
  int oldHeight=lp.height;
  lp.height=ViewGroup.LayoutParams.WRAP_CONTENT;
  setLayoutParams(lp);
  measure(View.MeasureSpec.makeMeasureSpec(getWidth(),View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mRowMaxHeight,View.MeasureSpec.AT_MOST));
  lp.height=oldHeight;
  setLayoutParams(lp);
  mMaxExpandHeight=getMeasuredHeight();
  mSelfInitiatedLayout=false;
}",0.9918200408997956
199361,"private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getHeight();
    }
 else {
      mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}","private void updateFirstChildHeightWhileExpanding(ViewGroup hostView){
  mFirstChildWhileExpanding=findFirstVisibleChild(hostView);
  if (mFirstChildWhileExpanding != null) {
    if (mExpandedOnStart) {
      mFirstChildMaxHeight=mFirstChildWhileExpanding.getHeight();
    }
 else {
      if (mFirstChildWhileExpanding.getWidth() == 0) {
        mFirstChildWhileExpanding.addOnLayoutChangeListener(new View.OnLayoutChangeListener(){
          @Override public void onLayoutChange(          View v,          int left,          int top,          int right,          int bottom,          int oldLeft,          int oldTop,          int oldRight,          int oldBottom){
            mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
            mFirstChildWhileExpanding.removeOnLayoutChangeListener(this);
          }
        }
);
      }
 else {
        mFirstChildMaxHeight=getMaxAllowedChildHeight(mFirstChildWhileExpanding);
      }
    }
  }
 else {
    mFirstChildMaxHeight=0;
  }
}",0.5818692902319045
199362,"private int submitCaptureRequest(List<CaptureRequest> requestList,CaptureListener listener,Handler handler,boolean repeating) throws CameraAccessException {
  if (listener != null) {
    handler=checkHandler(handler);
  }
synchronized (mLock) {
    checkIfCameraClosed();
    int requestId;
    if (repeating) {
      stopRepeating();
    }
    LongParcelable lastFrameNumberRef=new LongParcelable();
    try {
      requestId=mRemoteDevice.submitRequestList(requestList,repeating,lastFrameNumberRef);
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + lastFrameNumberRef.getNumber());
      }
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return -1;
    }
    if (listener != null) {
      mCaptureListenerMap.put(requestId,new CaptureListenerHolder(listener,requestList,handler,repeating));
    }
    long lastFrameNumber=lastFrameNumberRef.getNumber();
    if (repeating) {
      if (mRepeatingRequestId != REQUEST_ID_NONE) {
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId,lastFrameNumber);
      }
      mRepeatingRequestId=requestId;
    }
 else {
      mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
    }
    if (mIdle) {
      mDeviceHandler.post(mCallOnActive);
    }
    mIdle=false;
    return requestId;
  }
}","private int submitCaptureRequest(List<CaptureRequest> requestList,CaptureListener listener,Handler handler,boolean repeating) throws CameraAccessException {
  if (listener != null) {
    handler=checkHandler(handler);
  }
synchronized (mLock) {
    checkIfCameraClosed();
    int requestId;
    if (repeating) {
      stopRepeating();
    }
    LongParcelable lastFrameNumberRef=new LongParcelable();
    try {
      requestId=mRemoteDevice.submitRequestList(requestList,repeating,lastFrameNumberRef);
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + lastFrameNumberRef.getNumber());
      }
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return -1;
    }
    if (listener != null) {
      mCaptureListenerMap.put(requestId,new CaptureListenerHolder(listener,requestList,handler,repeating));
    }
 else {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
    }
    long lastFrameNumber=lastFrameNumberRef.getNumber();
    if (repeating) {
      if (mRepeatingRequestId != REQUEST_ID_NONE) {
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId,lastFrameNumber);
      }
      mRepeatingRequestId=requestId;
    }
 else {
      mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
    }
    if (mIdle) {
      mDeviceHandler.post(mCallOnActive);
    }
    mIdle=false;
    return requestId;
  }
}",0.9606243348705216
199363,"/** 
 * This method checks lastFrameNumber returned from ICameraDeviceUser methods for starting and stopping repeating request and flushing. <p>If lastFrameNumber is NO_FRAMES_CAPTURED, it means that the request was never sent to HAL. Then onCaptureSequenceCompleted is immediately triggered. If lastFrameNumber is non-negative, then the requestId and lastFrameNumber pair is added to the list mFrameNumberRequestPairs.</p>
 * @param requestId the request ID of the current repeating request.
 * @param lastFrameNumber last frame number returned from binder.
 */
private void checkEarlyTriggerSequenceComplete(final int requestId,final long lastFrameNumber){
  if (lastFrameNumber == CaptureListener.NO_FRAMES_CAPTURED) {
    final CaptureListenerHolder holder;
    int index=mCaptureListenerMap.indexOfKey(requestId);
    holder=(index >= 0) ? mCaptureListenerMap.valueAt(index) : null;
    if (holder != null) {
      mCaptureListenerMap.removeAt(index);
    }
    if (holder != null) {
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      }
      Runnable resultDispatch=new Runnable(){
        @Override public void run(){
          if (!CameraDevice.this.isClosed()) {
            if (DEBUG) {
              Log.d(TAG,String.format(""String_Node_Str"",requestId));
            }
            if (lastFrameNumber < Integer.MIN_VALUE || lastFrameNumber > Integer.MAX_VALUE) {
              throw new AssertionError(lastFrameNumber + ""String_Node_Str"");
            }
            holder.getListener().onCaptureSequenceCompleted(CameraDevice.this,requestId,(int)lastFrameNumber);
          }
        }
      }
;
      holder.getHandler().post(resultDispatch);
    }
 else {
      Log.w(TAG,String.format(""String_Node_Str"",requestId));
    }
  }
 else {
    mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
  }
}","/** 
 * This method checks lastFrameNumber returned from ICameraDeviceUser methods for starting and stopping repeating request and flushing. <p>If lastFrameNumber is NO_FRAMES_CAPTURED, it means that the request was never sent to HAL. Then onCaptureSequenceCompleted is immediately triggered. If lastFrameNumber is non-negative, then the requestId and lastFrameNumber pair is added to the list mFrameNumberRequestPairs.</p>
 * @param requestId the request ID of the current repeating request.
 * @param lastFrameNumber last frame number returned from binder.
 */
private void checkEarlyTriggerSequenceComplete(final int requestId,final long lastFrameNumber){
  if (lastFrameNumber == CaptureListener.NO_FRAMES_CAPTURED) {
    final CaptureListenerHolder holder;
    int index=mCaptureListenerMap.indexOfKey(requestId);
    holder=(index >= 0) ? mCaptureListenerMap.valueAt(index) : null;
    if (holder != null) {
      mCaptureListenerMap.removeAt(index);
      if (DEBUG) {
        Log.v(TAG,String.format(""String_Node_Str"" + ""String_Node_Str"",requestId,lastFrameNumber));
      }
    }
    if (holder != null) {
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      }
      Runnable resultDispatch=new Runnable(){
        @Override public void run(){
          if (!CameraDevice.this.isClosed()) {
            if (DEBUG) {
              Log.d(TAG,String.format(""String_Node_Str"",requestId));
            }
            if (lastFrameNumber < Integer.MIN_VALUE || lastFrameNumber > Integer.MAX_VALUE) {
              throw new AssertionError(lastFrameNumber + ""String_Node_Str"");
            }
            holder.getListener().onCaptureSequenceCompleted(CameraDevice.this,requestId,(int)lastFrameNumber);
          }
        }
      }
;
      holder.getHandler().post(resultDispatch);
    }
 else {
      Log.w(TAG,String.format(""String_Node_Str"",requestId));
    }
  }
 else {
    mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
  }
}",0.9675425038639875
199364,"@Override public void onResultReceived(CameraMetadataNative result,CaptureResultExtras resultExtras) throws RemoteException {
  int requestId=resultExtras.getRequestId();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + requestId);
  }
  final CaptureListenerHolder holder;
synchronized (mLock) {
    holder=CameraDevice.this.mCaptureListenerMap.get(requestId);
  }
  Boolean quirkPartial=result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
  boolean quirkIsPartialResult=(quirkPartial != null && quirkPartial);
  if (holder == null) {
    if (DEBUG) {
      Log.v(TAG,""String_Node_Str"");
    }
    return;
  }
  if (isClosed()) {
    if (DEBUG) {
      Log.v(TAG,""String_Node_Str"");
    }
    return;
  }
  final CaptureRequest request=holder.getRequest(resultExtras.getSubsequenceId());
  final CaptureResult resultAsCapture=new CaptureResult(result,request,requestId);
  Runnable resultDispatch=null;
  if (quirkIsPartialResult) {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCapturePartial(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
 else {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCaptureCompleted(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
  holder.getHandler().post(resultDispatch);
  if (!quirkIsPartialResult) {
    mFrameNumberTracker.updateTracker(resultExtras.getFrameNumber(),false);
    checkAndFireSequenceComplete();
  }
}","@Override public void onResultReceived(CameraMetadataNative result,CaptureResultExtras resultExtras) throws RemoteException {
  int requestId=resultExtras.getRequestId();
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + resultExtras.getFrameNumber() + ""String_Node_Str""+ requestId);
  }
  final CaptureListenerHolder holder;
synchronized (mLock) {
    holder=CameraDevice.this.mCaptureListenerMap.get(requestId);
  }
  Boolean quirkPartial=result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
  boolean quirkIsPartialResult=(quirkPartial != null && quirkPartial);
  if (!quirkIsPartialResult) {
    mFrameNumberTracker.updateTracker(resultExtras.getFrameNumber(),false);
  }
  if (holder == null) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + resultExtras.getFrameNumber());
    }
    return;
  }
  if (isClosed()) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + resultExtras.getFrameNumber());
    }
    return;
  }
  final CaptureRequest request=holder.getRequest(resultExtras.getSubsequenceId());
  final CaptureResult resultAsCapture=new CaptureResult(result,request,requestId);
  Runnable resultDispatch=null;
  if (quirkIsPartialResult) {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCapturePartial(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
 else {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCaptureCompleted(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
  holder.getHandler().post(resultDispatch);
  if (!quirkIsPartialResult) {
    checkAndFireSequenceComplete();
  }
}",0.9084423305588584
199365,"private int submitCaptureRequest(List<CaptureRequest> requestList,CaptureListener listener,Handler handler,boolean repeating) throws CameraAccessException {
  if (listener != null) {
    handler=checkHandler(handler);
  }
synchronized (mLock) {
    checkIfCameraClosed();
    int requestId;
    if (repeating) {
      stopRepeating();
    }
    LongParcelable lastFrameNumberRef=new LongParcelable();
    try {
      requestId=mRemoteDevice.submitRequestList(requestList,repeating,lastFrameNumberRef);
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + lastFrameNumberRef.getNumber());
      }
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return -1;
    }
    if (listener != null) {
      mCaptureListenerMap.put(requestId,new CaptureListenerHolder(listener,requestList,handler,repeating));
    }
    long lastFrameNumber=lastFrameNumberRef.getNumber();
    if (repeating) {
      if (mRepeatingRequestId != REQUEST_ID_NONE) {
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId,lastFrameNumber);
      }
      mRepeatingRequestId=requestId;
    }
 else {
      mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
    }
    if (mIdle) {
      mDeviceHandler.post(mCallOnActive);
    }
    mIdle=false;
    return requestId;
  }
}","private int submitCaptureRequest(List<CaptureRequest> requestList,CaptureListener listener,Handler handler,boolean repeating) throws CameraAccessException {
  if (listener != null) {
    handler=checkHandler(handler);
  }
synchronized (mLock) {
    checkIfCameraClosed();
    int requestId;
    if (repeating) {
      stopRepeating();
    }
    LongParcelable lastFrameNumberRef=new LongParcelable();
    try {
      requestId=mRemoteDevice.submitRequestList(requestList,repeating,lastFrameNumberRef);
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + lastFrameNumberRef.getNumber());
      }
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return -1;
    }
    if (listener != null) {
      mCaptureListenerMap.put(requestId,new CaptureListenerHolder(listener,requestList,handler,repeating));
    }
 else {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
    }
    long lastFrameNumber=lastFrameNumberRef.getNumber();
    if (repeating) {
      if (mRepeatingRequestId != REQUEST_ID_NONE) {
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId,lastFrameNumber);
      }
      mRepeatingRequestId=requestId;
    }
 else {
      mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
    }
    if (mIdle) {
      mDeviceHandler.post(mCallOnActive);
    }
    mIdle=false;
    return requestId;
  }
}",0.9606243348705216
199366,"/** 
 * This method checks lastFrameNumber returned from ICameraDeviceUser methods for starting and stopping repeating request and flushing. <p>If lastFrameNumber is NO_FRAMES_CAPTURED, it means that the request was never sent to HAL. Then onCaptureSequenceCompleted is immediately triggered. If lastFrameNumber is non-negative, then the requestId and lastFrameNumber pair is added to the list mFrameNumberRequestPairs.</p>
 * @param requestId the request ID of the current repeating request.
 * @param lastFrameNumber last frame number returned from binder.
 */
private void checkEarlyTriggerSequenceComplete(final int requestId,final long lastFrameNumber){
  if (lastFrameNumber == CaptureListener.NO_FRAMES_CAPTURED) {
    final CaptureListenerHolder holder;
    int index=mCaptureListenerMap.indexOfKey(requestId);
    holder=(index >= 0) ? mCaptureListenerMap.valueAt(index) : null;
    if (holder != null) {
      mCaptureListenerMap.removeAt(index);
    }
    if (holder != null) {
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      }
      Runnable resultDispatch=new Runnable(){
        @Override public void run(){
          if (!CameraDevice.this.isClosed()) {
            if (DEBUG) {
              Log.d(TAG,String.format(""String_Node_Str"",requestId));
            }
            if (lastFrameNumber < Integer.MIN_VALUE || lastFrameNumber > Integer.MAX_VALUE) {
              throw new AssertionError(lastFrameNumber + ""String_Node_Str"");
            }
            holder.getListener().onCaptureSequenceCompleted(CameraDevice.this,requestId,(int)lastFrameNumber);
          }
        }
      }
;
      holder.getHandler().post(resultDispatch);
    }
 else {
      Log.w(TAG,String.format(""String_Node_Str"",requestId));
    }
  }
 else {
    mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
  }
}","/** 
 * This method checks lastFrameNumber returned from ICameraDeviceUser methods for starting and stopping repeating request and flushing. <p>If lastFrameNumber is NO_FRAMES_CAPTURED, it means that the request was never sent to HAL. Then onCaptureSequenceCompleted is immediately triggered. If lastFrameNumber is non-negative, then the requestId and lastFrameNumber pair is added to the list mFrameNumberRequestPairs.</p>
 * @param requestId the request ID of the current repeating request.
 * @param lastFrameNumber last frame number returned from binder.
 */
private void checkEarlyTriggerSequenceComplete(final int requestId,final long lastFrameNumber){
  if (lastFrameNumber == CaptureListener.NO_FRAMES_CAPTURED) {
    final CaptureListenerHolder holder;
    int index=mCaptureListenerMap.indexOfKey(requestId);
    holder=(index >= 0) ? mCaptureListenerMap.valueAt(index) : null;
    if (holder != null) {
      mCaptureListenerMap.removeAt(index);
      if (DEBUG) {
        Log.v(TAG,String.format(""String_Node_Str"" + ""String_Node_Str"",requestId,lastFrameNumber));
      }
    }
    if (holder != null) {
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      }
      Runnable resultDispatch=new Runnable(){
        @Override public void run(){
          if (!CameraDevice.this.isClosed()) {
            if (DEBUG) {
              Log.d(TAG,String.format(""String_Node_Str"",requestId));
            }
            if (lastFrameNumber < Integer.MIN_VALUE || lastFrameNumber > Integer.MAX_VALUE) {
              throw new AssertionError(lastFrameNumber + ""String_Node_Str"");
            }
            holder.getListener().onCaptureSequenceCompleted(CameraDevice.this,requestId,(int)lastFrameNumber);
          }
        }
      }
;
      holder.getHandler().post(resultDispatch);
    }
 else {
      Log.w(TAG,String.format(""String_Node_Str"",requestId));
    }
  }
 else {
    mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
  }
}",0.9675425038639875
199367,"@Override public void onResultReceived(CameraMetadataNative result,CaptureResultExtras resultExtras) throws RemoteException {
  int requestId=resultExtras.getRequestId();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + requestId);
  }
  final CaptureListenerHolder holder;
synchronized (mLock) {
    holder=CameraDevice.this.mCaptureListenerMap.get(requestId);
  }
  Boolean quirkPartial=result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
  boolean quirkIsPartialResult=(quirkPartial != null && quirkPartial);
  if (holder == null) {
    if (DEBUG) {
      Log.v(TAG,""String_Node_Str"");
    }
    return;
  }
  if (isClosed()) {
    if (DEBUG) {
      Log.v(TAG,""String_Node_Str"");
    }
    return;
  }
  final CaptureRequest request=holder.getRequest(resultExtras.getSubsequenceId());
  final CaptureResult resultAsCapture=new CaptureResult(result,request,requestId);
  Runnable resultDispatch=null;
  if (quirkIsPartialResult) {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCapturePartial(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
 else {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCaptureCompleted(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
  holder.getHandler().post(resultDispatch);
  if (!quirkIsPartialResult) {
    mFrameNumberTracker.updateTracker(resultExtras.getFrameNumber(),false);
    checkAndFireSequenceComplete();
  }
}","@Override public void onResultReceived(CameraMetadataNative result,CaptureResultExtras resultExtras) throws RemoteException {
  int requestId=resultExtras.getRequestId();
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + resultExtras.getFrameNumber() + ""String_Node_Str""+ requestId);
  }
  final CaptureListenerHolder holder;
synchronized (mLock) {
    holder=CameraDevice.this.mCaptureListenerMap.get(requestId);
  }
  Boolean quirkPartial=result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
  boolean quirkIsPartialResult=(quirkPartial != null && quirkPartial);
  if (!quirkIsPartialResult) {
    mFrameNumberTracker.updateTracker(resultExtras.getFrameNumber(),false);
  }
  if (holder == null) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + resultExtras.getFrameNumber());
    }
    return;
  }
  if (isClosed()) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + resultExtras.getFrameNumber());
    }
    return;
  }
  final CaptureRequest request=holder.getRequest(resultExtras.getSubsequenceId());
  final CaptureResult resultAsCapture=new CaptureResult(result,request,requestId);
  Runnable resultDispatch=null;
  if (quirkIsPartialResult) {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCapturePartial(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
 else {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCaptureCompleted(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
  holder.getHandler().post(resultDispatch);
  if (!quirkIsPartialResult) {
    checkAndFireSequenceComplete();
  }
}",0.9084423305588584
199368,"private int submitCaptureRequest(List<CaptureRequest> requestList,CaptureListener listener,Handler handler,boolean repeating) throws CameraAccessException {
  if (listener != null) {
    handler=checkHandler(handler);
  }
synchronized (mLock) {
    checkIfCameraClosed();
    int requestId;
    if (repeating) {
      stopRepeating();
    }
    LongParcelable lastFrameNumberRef=new LongParcelable();
    try {
      requestId=mRemoteDevice.submitRequestList(requestList,repeating,lastFrameNumberRef);
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + lastFrameNumberRef.getNumber());
      }
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return -1;
    }
    if (listener != null) {
      mCaptureListenerMap.put(requestId,new CaptureListenerHolder(listener,requestList,handler,repeating));
    }
    long lastFrameNumber=lastFrameNumberRef.getNumber();
    if (repeating) {
      if (mRepeatingRequestId != REQUEST_ID_NONE) {
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId,lastFrameNumber);
      }
      mRepeatingRequestId=requestId;
    }
 else {
      mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
    }
    if (mIdle) {
      mDeviceHandler.post(mCallOnActive);
    }
    mIdle=false;
    return requestId;
  }
}","private int submitCaptureRequest(List<CaptureRequest> requestList,CaptureListener listener,Handler handler,boolean repeating) throws CameraAccessException {
  if (listener != null) {
    handler=checkHandler(handler);
  }
synchronized (mLock) {
    checkIfCameraClosed();
    int requestId;
    if (repeating) {
      stopRepeating();
    }
    LongParcelable lastFrameNumberRef=new LongParcelable();
    try {
      requestId=mRemoteDevice.submitRequestList(requestList,repeating,lastFrameNumberRef);
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + lastFrameNumberRef.getNumber());
      }
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return -1;
    }
    if (listener != null) {
      mCaptureListenerMap.put(requestId,new CaptureListenerHolder(listener,requestList,handler,repeating));
    }
 else {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
    }
    long lastFrameNumber=lastFrameNumberRef.getNumber();
    if (repeating) {
      if (mRepeatingRequestId != REQUEST_ID_NONE) {
        checkEarlyTriggerSequenceComplete(mRepeatingRequestId,lastFrameNumber);
      }
      mRepeatingRequestId=requestId;
    }
 else {
      mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
    }
    if (mIdle) {
      mDeviceHandler.post(mCallOnActive);
    }
    mIdle=false;
    return requestId;
  }
}",0.9606243348705216
199369,"/** 
 * This method checks lastFrameNumber returned from ICameraDeviceUser methods for starting and stopping repeating request and flushing. <p>If lastFrameNumber is NO_FRAMES_CAPTURED, it means that the request was never sent to HAL. Then onCaptureSequenceCompleted is immediately triggered. If lastFrameNumber is non-negative, then the requestId and lastFrameNumber pair is added to the list mFrameNumberRequestPairs.</p>
 * @param requestId the request ID of the current repeating request.
 * @param lastFrameNumber last frame number returned from binder.
 */
private void checkEarlyTriggerSequenceComplete(final int requestId,final long lastFrameNumber){
  if (lastFrameNumber == CaptureListener.NO_FRAMES_CAPTURED) {
    final CaptureListenerHolder holder;
    int index=mCaptureListenerMap.indexOfKey(requestId);
    holder=(index >= 0) ? mCaptureListenerMap.valueAt(index) : null;
    if (holder != null) {
      mCaptureListenerMap.removeAt(index);
    }
    if (holder != null) {
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      }
      Runnable resultDispatch=new Runnable(){
        @Override public void run(){
          if (!CameraDevice.this.isClosed()) {
            if (DEBUG) {
              Log.d(TAG,String.format(""String_Node_Str"",requestId));
            }
            if (lastFrameNumber < Integer.MIN_VALUE || lastFrameNumber > Integer.MAX_VALUE) {
              throw new AssertionError(lastFrameNumber + ""String_Node_Str"");
            }
            holder.getListener().onCaptureSequenceCompleted(CameraDevice.this,requestId,(int)lastFrameNumber);
          }
        }
      }
;
      holder.getHandler().post(resultDispatch);
    }
 else {
      Log.w(TAG,String.format(""String_Node_Str"",requestId));
    }
  }
 else {
    mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
  }
}","/** 
 * This method checks lastFrameNumber returned from ICameraDeviceUser methods for starting and stopping repeating request and flushing. <p>If lastFrameNumber is NO_FRAMES_CAPTURED, it means that the request was never sent to HAL. Then onCaptureSequenceCompleted is immediately triggered. If lastFrameNumber is non-negative, then the requestId and lastFrameNumber pair is added to the list mFrameNumberRequestPairs.</p>
 * @param requestId the request ID of the current repeating request.
 * @param lastFrameNumber last frame number returned from binder.
 */
private void checkEarlyTriggerSequenceComplete(final int requestId,final long lastFrameNumber){
  if (lastFrameNumber == CaptureListener.NO_FRAMES_CAPTURED) {
    final CaptureListenerHolder holder;
    int index=mCaptureListenerMap.indexOfKey(requestId);
    holder=(index >= 0) ? mCaptureListenerMap.valueAt(index) : null;
    if (holder != null) {
      mCaptureListenerMap.removeAt(index);
      if (DEBUG) {
        Log.v(TAG,String.format(""String_Node_Str"" + ""String_Node_Str"",requestId,lastFrameNumber));
      }
    }
    if (holder != null) {
      if (DEBUG) {
        Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      }
      Runnable resultDispatch=new Runnable(){
        @Override public void run(){
          if (!CameraDevice.this.isClosed()) {
            if (DEBUG) {
              Log.d(TAG,String.format(""String_Node_Str"",requestId));
            }
            if (lastFrameNumber < Integer.MIN_VALUE || lastFrameNumber > Integer.MAX_VALUE) {
              throw new AssertionError(lastFrameNumber + ""String_Node_Str"");
            }
            holder.getListener().onCaptureSequenceCompleted(CameraDevice.this,requestId,(int)lastFrameNumber);
          }
        }
      }
;
      holder.getHandler().post(resultDispatch);
    }
 else {
      Log.w(TAG,String.format(""String_Node_Str"",requestId));
    }
  }
 else {
    mFrameNumberRequestPairs.add(new SimpleEntry<Long,Integer>(lastFrameNumber,requestId));
  }
}",0.9675425038639875
199370,"@Override public void onResultReceived(CameraMetadataNative result,CaptureResultExtras resultExtras) throws RemoteException {
  int requestId=resultExtras.getRequestId();
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + requestId);
  }
  final CaptureListenerHolder holder;
synchronized (mLock) {
    holder=CameraDevice.this.mCaptureListenerMap.get(requestId);
  }
  Boolean quirkPartial=result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
  boolean quirkIsPartialResult=(quirkPartial != null && quirkPartial);
  if (holder == null) {
    if (DEBUG) {
      Log.v(TAG,""String_Node_Str"");
    }
    return;
  }
  if (isClosed()) {
    if (DEBUG) {
      Log.v(TAG,""String_Node_Str"");
    }
    return;
  }
  final CaptureRequest request=holder.getRequest(resultExtras.getSubsequenceId());
  final CaptureResult resultAsCapture=new CaptureResult(result,request,requestId);
  Runnable resultDispatch=null;
  if (quirkIsPartialResult) {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCapturePartial(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
 else {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCaptureCompleted(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
  holder.getHandler().post(resultDispatch);
  if (!quirkIsPartialResult) {
    mFrameNumberTracker.updateTracker(resultExtras.getFrameNumber(),false);
    checkAndFireSequenceComplete();
  }
}","@Override public void onResultReceived(CameraMetadataNative result,CaptureResultExtras resultExtras) throws RemoteException {
  int requestId=resultExtras.getRequestId();
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + resultExtras.getFrameNumber() + ""String_Node_Str""+ requestId);
  }
  final CaptureListenerHolder holder;
synchronized (mLock) {
    holder=CameraDevice.this.mCaptureListenerMap.get(requestId);
  }
  Boolean quirkPartial=result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
  boolean quirkIsPartialResult=(quirkPartial != null && quirkPartial);
  if (!quirkIsPartialResult) {
    mFrameNumberTracker.updateTracker(resultExtras.getFrameNumber(),false);
  }
  if (holder == null) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + resultExtras.getFrameNumber());
    }
    return;
  }
  if (isClosed()) {
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + resultExtras.getFrameNumber());
    }
    return;
  }
  final CaptureRequest request=holder.getRequest(resultExtras.getSubsequenceId());
  final CaptureResult resultAsCapture=new CaptureResult(result,request,requestId);
  Runnable resultDispatch=null;
  if (quirkIsPartialResult) {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCapturePartial(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
 else {
    resultDispatch=new Runnable(){
      @Override public void run(){
        if (!CameraDevice.this.isClosed()) {
          holder.getListener().onCaptureCompleted(CameraDevice.this,request,resultAsCapture);
        }
      }
    }
;
  }
  holder.getHandler().post(resultDispatch);
  if (!quirkIsPartialResult) {
    checkAndFireSequenceComplete();
  }
}",0.9084423305588584
199371,"/** 
 * Update the height of the   {@link #mNotificationStackScroller} to the new expanded height.This is much more efficient than doing it over the layout pass.
 * @param expandedHeight the new expanded height
 */
private void updateNotificationStackHeight(float expandedHeight){
  mNotificationStackScroller.setIsExpanded(expandedHeight > 0.0f);
  float childOffset=getRelativeTop(mNotificationStackScroller) - mNotificationParent.getTranslationY();
  int newStackHeight=(int)(expandedHeight - childOffset);
  int itemHeight=mNotificationStackScroller.getItemHeight();
  int bottomStackPeekSize=mNotificationStackScroller.getBottomStackPeekSize();
  int minStackHeight=itemHeight + bottomStackPeekSize;
  if (newStackHeight >= minStackHeight) {
    mNotificationParent.setTranslationY(0);
    mNotificationStackScroller.setCurrentStackHeight(newStackHeight);
  }
 else {
    int translationY=(newStackHeight - minStackHeight);
    float partiallyThere=(float)newStackHeight / minStackHeight;
    partiallyThere=Math.max(0,partiallyThere);
    translationY+=(1 - partiallyThere) * bottomStackPeekSize;
    mNotificationParent.setTranslationY(translationY);
    mNotificationStackScroller.setCurrentStackHeight((int)(expandedHeight - (childOffset + translationY)));
  }
}","/** 
 * Update the height of the   {@link #mNotificationStackScroller} to the new expanded height.This is much more efficient than doing it over the layout pass.
 * @param expandedHeight the new expanded height
 */
private void updateNotificationStackHeight(float expandedHeight){
  if (mExpandedHeight == expandedHeight)   return;
  mExpandedHeight=expandedHeight;
  mNotificationStackScroller.setIsExpanded(expandedHeight > 0.0f);
  float childOffset=getRelativeTop(mNotificationStackScroller) - mNotificationParent.getTranslationY();
  int newStackHeight=(int)(expandedHeight - childOffset);
  int itemHeight=mNotificationStackScroller.getItemHeight();
  int bottomStackPeekSize=mNotificationStackScroller.getBottomStackPeekSize();
  int minStackHeight=itemHeight + bottomStackPeekSize;
  if (newStackHeight >= minStackHeight) {
    mNotificationParent.setTranslationY(0);
    mNotificationStackScroller.setCurrentStackHeight(newStackHeight);
  }
 else {
    int translationY=(newStackHeight - minStackHeight);
    float partiallyThere=(float)newStackHeight / minStackHeight;
    partiallyThere=Math.max(0,partiallyThere);
    translationY+=(1 - partiallyThere) * bottomStackPeekSize;
    mNotificationParent.setTranslationY(translationY);
    mNotificationStackScroller.setCurrentStackHeight((int)(expandedHeight - (childOffset + translationY)));
  }
}",0.9676437000380662
199372,"public boolean onSettingsEvent(MotionEvent event){
  if (mSettingsTracker != null) {
    mSettingsTracker.addMovement(event);
  }
  if (event.getAction() == MotionEvent.ACTION_DOWN) {
    mSettingsTracker=VelocityTracker.obtain();
    mSettingsDownY=event.getY();
    mSettingsCancelled=false;
    mSettingsClosing=mFlipSettingsView.getVisibility() == View.VISIBLE;
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mStackScroller.setVisibility(View.VISIBLE);
    positionSettings(0);
    if (!mSettingsClosing) {
      mFlipSettingsView.setTranslationY(-mNotificationPanel.getMeasuredHeight());
    }
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
    final float dy=event.getY() - mSettingsDownY;
    final FlipperButton flipper=mOnKeyguard ? mKeyguardFlipper : mHeaderFlipper;
    final boolean inButton=flipper.inHolderBounds(event);
    final int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
    final boolean qsTap=mSettingsClosing && Math.abs(dy) < slop;
    if (!qsTap && !inButton) {
      mSettingsTracker.computeCurrentVelocity(1000);
      final float vy=mSettingsTracker.getYVelocity();
      if (dy <= slop || vy <= 0) {
        flipToNotifications();
      }
 else {
        flipToSettings();
      }
    }
    mSettingsTracker.recycle();
    mSettingsTracker=null;
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && event.getAction() == MotionEvent.ACTION_MOVE) {
    final float dy=event.getY() - mSettingsDownY;
    positionSettings(dy);
    if (mSettingsClosing) {
      final boolean qsTap=Math.abs(dy) < ViewConfiguration.get(mContext).getScaledTouchSlop();
      if (!mSettingsCancelled && !qsTap) {
        MotionEvent cancelEvent=MotionEvent.obtainNoHistory(event);
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);
        dispatchSettingsEvent(cancelEvent);
        mSettingsCancelled=true;
      }
    }
 else {
      dispatchSettingsEvent(event);
    }
  }
  return true;
}","public boolean onSettingsEvent(MotionEvent event){
  userActivity();
  if (mSettingsClosing && mFlipSettingsViewAnim != null && mFlipSettingsViewAnim.isRunning()) {
    return true;
  }
  if (mSettingsTracker != null) {
    mSettingsTracker.addMovement(event);
  }
  if (event.getAction() == MotionEvent.ACTION_DOWN) {
    mSettingsTracker=VelocityTracker.obtain();
    mSettingsDownY=event.getY();
    mSettingsCancelled=false;
    mSettingsClosing=mFlipSettingsView.getVisibility() == View.VISIBLE;
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mStackScroller.setVisibility(View.VISIBLE);
    positionSettings(0);
    if (!mSettingsClosing) {
      mFlipSettingsView.setTranslationY(-mNotificationPanel.getMeasuredHeight());
    }
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
    final float dy=event.getY() - mSettingsDownY;
    final FlipperButton flipper=mOnKeyguard ? mKeyguardFlipper : mHeaderFlipper;
    final boolean inButton=flipper.inHolderBounds(event);
    final int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
    final boolean qsTap=mSettingsClosing && Math.abs(dy) < slop;
    if (!qsTap && !inButton) {
      mSettingsTracker.computeCurrentVelocity(1000);
      final float vy=mSettingsTracker.getYVelocity();
      if (dy <= slop || vy <= 0) {
        flipToNotifications();
      }
 else {
        flipToSettings();
      }
    }
    mSettingsTracker.recycle();
    mSettingsTracker=null;
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && event.getAction() == MotionEvent.ACTION_MOVE) {
    final float dy=event.getY() - mSettingsDownY;
    positionSettings(dy);
    if (mSettingsClosing) {
      final boolean qsTap=Math.abs(dy) < ViewConfiguration.get(mContext).getScaledTouchSlop();
      if (!mSettingsCancelled && !qsTap) {
        MotionEvent cancelEvent=MotionEvent.obtainNoHistory(event);
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);
        dispatchSettingsEvent(cancelEvent);
        mSettingsCancelled=true;
      }
    }
 else {
      dispatchSettingsEvent(event);
    }
  }
  return true;
}",0.9686265396235184
199373,"private void positionSettings(float dy){
  final int h=mFlipSettingsView.getMeasuredHeight();
  final int ph=mNotificationPanel.getMeasuredHeight();
  if (mSettingsClosing) {
    dy=Math.min(Math.max(-ph,dy),0);
    mFlipSettingsView.setTranslationY(dy);
    mStackScroller.setTranslationY(ph + dy);
  }
 else {
    dy=Math.min(Math.max(0,dy),ph);
    mFlipSettingsView.setTranslationY(-h + dy - mNotificationPadding * 2);
    mStackScroller.setTranslationY(dy);
  }
}","private void positionSettings(float dy){
  if (mSettingsClosing) {
    final int ph=mNotificationPanel.getMeasuredHeight();
    dy=Math.min(Math.max(-ph,dy),0);
    mFlipSettingsView.setTranslationY(dy);
    mStackScroller.setTranslationY(ph + dy);
  }
 else {
    final int h=mFlipSettingsView.getBottom();
    dy=Math.min(Math.max(0,dy),h);
    mFlipSettingsView.setTranslationY(-h + dy);
    mStackScroller.setTranslationY(dy);
  }
}",0.7389380530973452
199374,"public void flipToNotifications(){
  mNotificationButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,0f).setDuration(FLIP_DURATION),mNotificationButton,View.INVISIBLE));
  mSettingsButton.setVisibility(View.VISIBLE);
  mSettingsButtonAnim=start(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,1f).setDuration(FLIP_DURATION));
}","public void flipToNotifications(){
  mNotificationButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,0f).setDuration(FLIP_DURATION_OUT),mNotificationButton,View.INVISIBLE));
  mSettingsButton.setVisibility(View.VISIBLE);
  mSettingsButtonAnim=start(startDelay(FLIP_DURATION_OUT,ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,1f).setDuration(FLIP_DURATION_IN)));
}",0.9525032092426188
199375,"public void flipToSettings(){
  mSettingsButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,0f).setDuration(FLIP_DURATION),mStackScroller,View.INVISIBLE));
  mNotificationButton.setVisibility(View.VISIBLE);
  mNotificationButtonAnim=start(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,1f).setDuration(FLIP_DURATION));
}","public void flipToSettings(){
  mSettingsButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,0f).setDuration(FLIP_DURATION_OUT),mStackScroller,View.INVISIBLE));
  mNotificationButton.setVisibility(View.VISIBLE);
  mNotificationButtonAnim=start(startDelay(FLIP_DURATION_OUT,ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,1f).setDuration(FLIP_DURATION_IN)));
}",0.9517601043024772
199376,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mScrim.getAlpha() == 1) {
    mScrim.animate().alpha(0).setDuration(1000).start();
    sShowScrim=false;
  }
  return super.onTouchEvent(event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mScrim != null) {
    sShowScrim=false;
    removeView(mScrim);
  }
  return super.onTouchEvent(event);
}",0.7387862796833773
199377,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  mScrim.bringToFront();
  final int N=getChildCount();
  final boolean isLayoutRtl=isLayoutRtl();
  final int width=getWidth();
  int x=getPaddingStart();
  int y=getPaddingTop();
  int cursor=0;
  int maxRows=mKeyguardShowing ? mMaxRowsOnKeyguard : mMaxRows;
  for (int i=0; i < N; ++i) {
    if (getChildAt(i).equals(mScrim)) {
      int w=right - left - getPaddingLeft()- getPaddingRight();
      int h=bottom - top - getPaddingTop()- getPaddingBottom();
      mScrim.measure(MeasureSpec.makeMeasureSpec(w,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(h,MeasureSpec.EXACTLY));
      mScrim.layout(getPaddingLeft(),getPaddingTop(),right,bottom);
      continue;
    }
    QuickSettingsTileView child=(QuickSettingsTileView)getChildAt(i);
    ViewGroup.LayoutParams lp=child.getLayoutParams();
    if (child.getVisibility() != GONE) {
      final int col=cursor % mNumColumns;
      final int colSpan=child.getColumnSpan();
      final int childWidth=lp.width;
      final int childHeight=lp.height;
      int row=(int)(cursor / mNumColumns);
      if (row >= maxRows)       continue;
      if ((col + colSpan) > mNumColumns) {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
        row++;
      }
      final int childLeft=(isLayoutRtl) ? width - x - childWidth : x;
      final int childRight=childLeft + childWidth;
      final int childTop=y;
      final int childBottom=childTop + childHeight;
      child.layout(childLeft,childTop,childRight,childBottom);
      cursor+=child.getColumnSpan();
      if (cursor < (((row + 1) * mNumColumns))) {
        x+=childWidth + mCellGap;
      }
 else {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
      }
    }
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mScrim != null) {
    mScrim.bringToFront();
  }
  final int N=getChildCount();
  final boolean isLayoutRtl=isLayoutRtl();
  final int width=getWidth();
  int x=getPaddingStart();
  int y=getPaddingTop();
  int cursor=0;
  int maxRows=mKeyguardShowing ? mMaxRowsOnKeyguard : mMaxRows;
  for (int i=0; i < N; ++i) {
    if (getChildAt(i).equals(mScrim)) {
      int w=right - left - getPaddingLeft()- getPaddingRight();
      int h=bottom - top - getPaddingTop()- getPaddingBottom();
      mScrim.measure(MeasureSpec.makeMeasureSpec(w,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(h,MeasureSpec.EXACTLY));
      mScrim.layout(getPaddingLeft(),getPaddingTop(),right,bottom);
      continue;
    }
    QuickSettingsTileView child=(QuickSettingsTileView)getChildAt(i);
    ViewGroup.LayoutParams lp=child.getLayoutParams();
    if (child.getVisibility() != GONE) {
      final int col=cursor % mNumColumns;
      final int colSpan=child.getColumnSpan();
      final int childWidth=lp.width;
      final int childHeight=lp.height;
      int row=(int)(cursor / mNumColumns);
      if (row >= maxRows)       continue;
      if ((col + colSpan) > mNumColumns) {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
        row++;
      }
      final int childLeft=(isLayoutRtl) ? width - x - childWidth : x;
      final int childRight=childLeft + childWidth;
      final int childTop=y;
      final int childBottom=childTop + childHeight;
      child.layout(childLeft,childTop,childRight,childBottom);
      cursor+=child.getColumnSpan();
      if (cursor < (((row + 1) * mNumColumns))) {
        x+=childWidth + mCellGap;
      }
 else {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
      }
    }
  }
}",0.9917081260364844
199378,"@Override protected void onDraw(Canvas canvas){
  final int w=getMeasuredWidth();
  final int h=getMeasuredHeight();
  final int f=mStrokeWidth * 3 / 4;
  canvas.drawPath(line(f,h / 2,w - f,h / 2),mLinePaint);
  canvas.drawPath(line(w / 2,f,w / 2,h - f),mLinePaint);
  final int s=mStrokeWidth;
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  canvas.drawText(""String_Node_Str"",w / 2 - s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  canvas.drawText(""String_Node_Str"",w / 2 + s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  drawUnder(canvas,""String_Node_Str"",w / 2 - s,h / 2 + s);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  drawUnder(canvas,""String_Node_Str"",w / 2 + s,h / 2 + s);
}","@Override protected void onDraw(Canvas canvas){
  final int w=getMeasuredWidth();
  final int h=getMeasuredHeight();
  final int f=mStrokeWidth * 3 / 4;
  canvas.drawColor(SCRIM);
  canvas.drawPath(line(f,h / 2,w - f,h / 2),mLinePaint);
  canvas.drawPath(line(w / 2,f,w / 2,h - f),mLinePaint);
  final int s=mStrokeWidth;
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  canvas.drawText(""String_Node_Str"",w / 2 - s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  canvas.drawText(""String_Node_Str"",w / 2 + s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  drawUnder(canvas,""String_Node_Str"",w / 2 - s,h / 2 + s);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  drawUnder(canvas,""String_Node_Str"",w / 2 + s,h / 2 + s);
}",0.9819397993311036
199379,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mScrim=new ScrimView(mContext);
  addView(mScrim);
  mScrim.setAlpha(sShowScrim ? 1 : 0);
  LayoutTransition transitions=getLayoutTransition();
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  if (sShowScrim) {
    mScrim=new ScrimView(mContext);
    addView(mScrim);
  }
  LayoutTransition transitions=getLayoutTransition();
}",0.8564705882352941
199380,"/** 
 * Update the height of the   {@link #mNotificationStackScroller} to the new expanded height.This is much more efficient than doing it over the layout pass.
 * @param expandedHeight the new expanded height
 */
private void updateNotificationStackHeight(float expandedHeight){
  mNotificationStackScroller.setIsExpanded(expandedHeight > 0.0f);
  float childOffset=getRelativeTop(mNotificationStackScroller) - mNotificationParent.getTranslationY();
  int newStackHeight=(int)(expandedHeight - childOffset);
  int itemHeight=mNotificationStackScroller.getItemHeight();
  int bottomStackPeekSize=mNotificationStackScroller.getBottomStackPeekSize();
  int minStackHeight=itemHeight + bottomStackPeekSize;
  if (newStackHeight >= minStackHeight) {
    mNotificationParent.setTranslationY(0);
    mNotificationStackScroller.setCurrentStackHeight(newStackHeight);
  }
 else {
    int translationY=(newStackHeight - minStackHeight);
    float partiallyThere=(float)newStackHeight / minStackHeight;
    partiallyThere=Math.max(0,partiallyThere);
    translationY+=(1 - partiallyThere) * bottomStackPeekSize;
    mNotificationParent.setTranslationY(translationY);
    mNotificationStackScroller.setCurrentStackHeight((int)(expandedHeight - (childOffset + translationY)));
  }
}","/** 
 * Update the height of the   {@link #mNotificationStackScroller} to the new expanded height.This is much more efficient than doing it over the layout pass.
 * @param expandedHeight the new expanded height
 */
private void updateNotificationStackHeight(float expandedHeight){
  if (mExpandedHeight == expandedHeight)   return;
  mExpandedHeight=expandedHeight;
  mNotificationStackScroller.setIsExpanded(expandedHeight > 0.0f);
  float childOffset=getRelativeTop(mNotificationStackScroller) - mNotificationParent.getTranslationY();
  int newStackHeight=(int)(expandedHeight - childOffset);
  int itemHeight=mNotificationStackScroller.getItemHeight();
  int bottomStackPeekSize=mNotificationStackScroller.getBottomStackPeekSize();
  int minStackHeight=itemHeight + bottomStackPeekSize;
  if (newStackHeight >= minStackHeight) {
    mNotificationParent.setTranslationY(0);
    mNotificationStackScroller.setCurrentStackHeight(newStackHeight);
  }
 else {
    int translationY=(newStackHeight - minStackHeight);
    float partiallyThere=(float)newStackHeight / minStackHeight;
    partiallyThere=Math.max(0,partiallyThere);
    translationY+=(1 - partiallyThere) * bottomStackPeekSize;
    mNotificationParent.setTranslationY(translationY);
    mNotificationStackScroller.setCurrentStackHeight((int)(expandedHeight - (childOffset + translationY)));
  }
}",0.9676437000380662
199381,"public boolean onSettingsEvent(MotionEvent event){
  if (mSettingsTracker != null) {
    mSettingsTracker.addMovement(event);
  }
  if (event.getAction() == MotionEvent.ACTION_DOWN) {
    mSettingsTracker=VelocityTracker.obtain();
    mSettingsDownY=event.getY();
    mSettingsCancelled=false;
    mSettingsClosing=mFlipSettingsView.getVisibility() == View.VISIBLE;
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mStackScroller.setVisibility(View.VISIBLE);
    positionSettings(0);
    if (!mSettingsClosing) {
      mFlipSettingsView.setTranslationY(-mNotificationPanel.getMeasuredHeight());
    }
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
    final float dy=event.getY() - mSettingsDownY;
    final FlipperButton flipper=mOnKeyguard ? mKeyguardFlipper : mHeaderFlipper;
    final boolean inButton=flipper.inHolderBounds(event);
    final int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
    final boolean qsTap=mSettingsClosing && Math.abs(dy) < slop;
    if (!qsTap && !inButton) {
      mSettingsTracker.computeCurrentVelocity(1000);
      final float vy=mSettingsTracker.getYVelocity();
      if (dy <= slop || vy <= 0) {
        flipToNotifications();
      }
 else {
        flipToSettings();
      }
    }
    mSettingsTracker.recycle();
    mSettingsTracker=null;
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && event.getAction() == MotionEvent.ACTION_MOVE) {
    final float dy=event.getY() - mSettingsDownY;
    positionSettings(dy);
    if (mSettingsClosing) {
      final boolean qsTap=Math.abs(dy) < ViewConfiguration.get(mContext).getScaledTouchSlop();
      if (!mSettingsCancelled && !qsTap) {
        MotionEvent cancelEvent=MotionEvent.obtainNoHistory(event);
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);
        dispatchSettingsEvent(cancelEvent);
        mSettingsCancelled=true;
      }
    }
 else {
      dispatchSettingsEvent(event);
    }
  }
  return true;
}","public boolean onSettingsEvent(MotionEvent event){
  userActivity();
  if (mSettingsClosing && mFlipSettingsViewAnim != null && mFlipSettingsViewAnim.isRunning()) {
    return true;
  }
  if (mSettingsTracker != null) {
    mSettingsTracker.addMovement(event);
  }
  if (event.getAction() == MotionEvent.ACTION_DOWN) {
    mSettingsTracker=VelocityTracker.obtain();
    mSettingsDownY=event.getY();
    mSettingsCancelled=false;
    mSettingsClosing=mFlipSettingsView.getVisibility() == View.VISIBLE;
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mStackScroller.setVisibility(View.VISIBLE);
    positionSettings(0);
    if (!mSettingsClosing) {
      mFlipSettingsView.setTranslationY(-mNotificationPanel.getMeasuredHeight());
    }
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
    final float dy=event.getY() - mSettingsDownY;
    final FlipperButton flipper=mOnKeyguard ? mKeyguardFlipper : mHeaderFlipper;
    final boolean inButton=flipper.inHolderBounds(event);
    final int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
    final boolean qsTap=mSettingsClosing && Math.abs(dy) < slop;
    if (!qsTap && !inButton) {
      mSettingsTracker.computeCurrentVelocity(1000);
      final float vy=mSettingsTracker.getYVelocity();
      if (dy <= slop || vy <= 0) {
        flipToNotifications();
      }
 else {
        flipToSettings();
      }
    }
    mSettingsTracker.recycle();
    mSettingsTracker=null;
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && event.getAction() == MotionEvent.ACTION_MOVE) {
    final float dy=event.getY() - mSettingsDownY;
    positionSettings(dy);
    if (mSettingsClosing) {
      final boolean qsTap=Math.abs(dy) < ViewConfiguration.get(mContext).getScaledTouchSlop();
      if (!mSettingsCancelled && !qsTap) {
        MotionEvent cancelEvent=MotionEvent.obtainNoHistory(event);
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);
        dispatchSettingsEvent(cancelEvent);
        mSettingsCancelled=true;
      }
    }
 else {
      dispatchSettingsEvent(event);
    }
  }
  return true;
}",0.9686265396235184
199382,"private void positionSettings(float dy){
  final int h=mFlipSettingsView.getMeasuredHeight();
  final int ph=mNotificationPanel.getMeasuredHeight();
  if (mSettingsClosing) {
    dy=Math.min(Math.max(-ph,dy),0);
    mFlipSettingsView.setTranslationY(dy);
    mStackScroller.setTranslationY(ph + dy);
  }
 else {
    dy=Math.min(Math.max(0,dy),ph);
    mFlipSettingsView.setTranslationY(-h + dy - mNotificationPadding * 2);
    mStackScroller.setTranslationY(dy);
  }
}","private void positionSettings(float dy){
  if (mSettingsClosing) {
    final int ph=mNotificationPanel.getMeasuredHeight();
    dy=Math.min(Math.max(-ph,dy),0);
    mFlipSettingsView.setTranslationY(dy);
    mStackScroller.setTranslationY(ph + dy);
  }
 else {
    final int h=mFlipSettingsView.getBottom();
    dy=Math.min(Math.max(0,dy),h);
    mFlipSettingsView.setTranslationY(-h + dy);
    mStackScroller.setTranslationY(dy);
  }
}",0.7389380530973452
199383,"public void flipToNotifications(){
  mNotificationButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,0f).setDuration(FLIP_DURATION),mNotificationButton,View.INVISIBLE));
  mSettingsButton.setVisibility(View.VISIBLE);
  mSettingsButtonAnim=start(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,1f).setDuration(FLIP_DURATION));
}","public void flipToNotifications(){
  mNotificationButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,0f).setDuration(FLIP_DURATION_OUT),mNotificationButton,View.INVISIBLE));
  mSettingsButton.setVisibility(View.VISIBLE);
  mSettingsButtonAnim=start(startDelay(FLIP_DURATION_OUT,ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,1f).setDuration(FLIP_DURATION_IN)));
}",0.9525032092426188
199384,"public void flipToSettings(){
  mSettingsButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,0f).setDuration(FLIP_DURATION),mStackScroller,View.INVISIBLE));
  mNotificationButton.setVisibility(View.VISIBLE);
  mNotificationButtonAnim=start(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,1f).setDuration(FLIP_DURATION));
}","public void flipToSettings(){
  mSettingsButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,0f).setDuration(FLIP_DURATION_OUT),mStackScroller,View.INVISIBLE));
  mNotificationButton.setVisibility(View.VISIBLE);
  mNotificationButtonAnim=start(startDelay(FLIP_DURATION_OUT,ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,1f).setDuration(FLIP_DURATION_IN)));
}",0.9517601043024772
199385,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mScrim.getAlpha() == 1) {
    mScrim.animate().alpha(0).setDuration(1000).start();
    sShowScrim=false;
  }
  return super.onTouchEvent(event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mScrim != null) {
    sShowScrim=false;
    removeView(mScrim);
  }
  return super.onTouchEvent(event);
}",0.7387862796833773
199386,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  mScrim.bringToFront();
  final int N=getChildCount();
  final boolean isLayoutRtl=isLayoutRtl();
  final int width=getWidth();
  int x=getPaddingStart();
  int y=getPaddingTop();
  int cursor=0;
  int maxRows=mKeyguardShowing ? mMaxRowsOnKeyguard : mMaxRows;
  for (int i=0; i < N; ++i) {
    if (getChildAt(i).equals(mScrim)) {
      int w=right - left - getPaddingLeft()- getPaddingRight();
      int h=bottom - top - getPaddingTop()- getPaddingBottom();
      mScrim.measure(MeasureSpec.makeMeasureSpec(w,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(h,MeasureSpec.EXACTLY));
      mScrim.layout(getPaddingLeft(),getPaddingTop(),right,bottom);
      continue;
    }
    QuickSettingsTileView child=(QuickSettingsTileView)getChildAt(i);
    ViewGroup.LayoutParams lp=child.getLayoutParams();
    if (child.getVisibility() != GONE) {
      final int col=cursor % mNumColumns;
      final int colSpan=child.getColumnSpan();
      final int childWidth=lp.width;
      final int childHeight=lp.height;
      int row=(int)(cursor / mNumColumns);
      if (row >= maxRows)       continue;
      if ((col + colSpan) > mNumColumns) {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
        row++;
      }
      final int childLeft=(isLayoutRtl) ? width - x - childWidth : x;
      final int childRight=childLeft + childWidth;
      final int childTop=y;
      final int childBottom=childTop + childHeight;
      child.layout(childLeft,childTop,childRight,childBottom);
      cursor+=child.getColumnSpan();
      if (cursor < (((row + 1) * mNumColumns))) {
        x+=childWidth + mCellGap;
      }
 else {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
      }
    }
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mScrim != null) {
    mScrim.bringToFront();
  }
  final int N=getChildCount();
  final boolean isLayoutRtl=isLayoutRtl();
  final int width=getWidth();
  int x=getPaddingStart();
  int y=getPaddingTop();
  int cursor=0;
  int maxRows=mKeyguardShowing ? mMaxRowsOnKeyguard : mMaxRows;
  for (int i=0; i < N; ++i) {
    if (getChildAt(i).equals(mScrim)) {
      int w=right - left - getPaddingLeft()- getPaddingRight();
      int h=bottom - top - getPaddingTop()- getPaddingBottom();
      mScrim.measure(MeasureSpec.makeMeasureSpec(w,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(h,MeasureSpec.EXACTLY));
      mScrim.layout(getPaddingLeft(),getPaddingTop(),right,bottom);
      continue;
    }
    QuickSettingsTileView child=(QuickSettingsTileView)getChildAt(i);
    ViewGroup.LayoutParams lp=child.getLayoutParams();
    if (child.getVisibility() != GONE) {
      final int col=cursor % mNumColumns;
      final int colSpan=child.getColumnSpan();
      final int childWidth=lp.width;
      final int childHeight=lp.height;
      int row=(int)(cursor / mNumColumns);
      if (row >= maxRows)       continue;
      if ((col + colSpan) > mNumColumns) {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
        row++;
      }
      final int childLeft=(isLayoutRtl) ? width - x - childWidth : x;
      final int childRight=childLeft + childWidth;
      final int childTop=y;
      final int childBottom=childTop + childHeight;
      child.layout(childLeft,childTop,childRight,childBottom);
      cursor+=child.getColumnSpan();
      if (cursor < (((row + 1) * mNumColumns))) {
        x+=childWidth + mCellGap;
      }
 else {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
      }
    }
  }
}",0.9917081260364844
199387,"@Override protected void onDraw(Canvas canvas){
  final int w=getMeasuredWidth();
  final int h=getMeasuredHeight();
  final int f=mStrokeWidth * 3 / 4;
  canvas.drawPath(line(f,h / 2,w - f,h / 2),mLinePaint);
  canvas.drawPath(line(w / 2,f,w / 2,h - f),mLinePaint);
  final int s=mStrokeWidth;
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  canvas.drawText(""String_Node_Str"",w / 2 - s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  canvas.drawText(""String_Node_Str"",w / 2 + s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  drawUnder(canvas,""String_Node_Str"",w / 2 - s,h / 2 + s);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  drawUnder(canvas,""String_Node_Str"",w / 2 + s,h / 2 + s);
}","@Override protected void onDraw(Canvas canvas){
  final int w=getMeasuredWidth();
  final int h=getMeasuredHeight();
  final int f=mStrokeWidth * 3 / 4;
  canvas.drawColor(SCRIM);
  canvas.drawPath(line(f,h / 2,w - f,h / 2),mLinePaint);
  canvas.drawPath(line(w / 2,f,w / 2,h - f),mLinePaint);
  final int s=mStrokeWidth;
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  canvas.drawText(""String_Node_Str"",w / 2 - s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  canvas.drawText(""String_Node_Str"",w / 2 + s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  drawUnder(canvas,""String_Node_Str"",w / 2 - s,h / 2 + s);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  drawUnder(canvas,""String_Node_Str"",w / 2 + s,h / 2 + s);
}",0.9819397993311036
199388,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mScrim=new ScrimView(mContext);
  addView(mScrim);
  mScrim.setAlpha(sShowScrim ? 1 : 0);
  LayoutTransition transitions=getLayoutTransition();
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  if (sShowScrim) {
    mScrim=new ScrimView(mContext);
    addView(mScrim);
  }
  LayoutTransition transitions=getLayoutTransition();
}",0.8564705882352941
199389,"/** 
 * Update the height of the   {@link #mNotificationStackScroller} to the new expanded height.This is much more efficient than doing it over the layout pass.
 * @param expandedHeight the new expanded height
 */
private void updateNotificationStackHeight(float expandedHeight){
  mNotificationStackScroller.setIsExpanded(expandedHeight > 0.0f);
  float childOffset=getRelativeTop(mNotificationStackScroller) - mNotificationParent.getTranslationY();
  int newStackHeight=(int)(expandedHeight - childOffset);
  int itemHeight=mNotificationStackScroller.getItemHeight();
  int bottomStackPeekSize=mNotificationStackScroller.getBottomStackPeekSize();
  int minStackHeight=itemHeight + bottomStackPeekSize;
  if (newStackHeight >= minStackHeight) {
    mNotificationParent.setTranslationY(0);
    mNotificationStackScroller.setCurrentStackHeight(newStackHeight);
  }
 else {
    int translationY=(newStackHeight - minStackHeight);
    float partiallyThere=(float)newStackHeight / minStackHeight;
    partiallyThere=Math.max(0,partiallyThere);
    translationY+=(1 - partiallyThere) * bottomStackPeekSize;
    mNotificationParent.setTranslationY(translationY);
    mNotificationStackScroller.setCurrentStackHeight((int)(expandedHeight - (childOffset + translationY)));
  }
}","/** 
 * Update the height of the   {@link #mNotificationStackScroller} to the new expanded height.This is much more efficient than doing it over the layout pass.
 * @param expandedHeight the new expanded height
 */
private void updateNotificationStackHeight(float expandedHeight){
  if (mExpandedHeight == expandedHeight)   return;
  mExpandedHeight=expandedHeight;
  mNotificationStackScroller.setIsExpanded(expandedHeight > 0.0f);
  float childOffset=getRelativeTop(mNotificationStackScroller) - mNotificationParent.getTranslationY();
  int newStackHeight=(int)(expandedHeight - childOffset);
  int itemHeight=mNotificationStackScroller.getItemHeight();
  int bottomStackPeekSize=mNotificationStackScroller.getBottomStackPeekSize();
  int minStackHeight=itemHeight + bottomStackPeekSize;
  if (newStackHeight >= minStackHeight) {
    mNotificationParent.setTranslationY(0);
    mNotificationStackScroller.setCurrentStackHeight(newStackHeight);
  }
 else {
    int translationY=(newStackHeight - minStackHeight);
    float partiallyThere=(float)newStackHeight / minStackHeight;
    partiallyThere=Math.max(0,partiallyThere);
    translationY+=(1 - partiallyThere) * bottomStackPeekSize;
    mNotificationParent.setTranslationY(translationY);
    mNotificationStackScroller.setCurrentStackHeight((int)(expandedHeight - (childOffset + translationY)));
  }
}",0.9676437000380662
199390,"public boolean onSettingsEvent(MotionEvent event){
  if (mSettingsTracker != null) {
    mSettingsTracker.addMovement(event);
  }
  if (event.getAction() == MotionEvent.ACTION_DOWN) {
    mSettingsTracker=VelocityTracker.obtain();
    mSettingsDownY=event.getY();
    mSettingsCancelled=false;
    mSettingsClosing=mFlipSettingsView.getVisibility() == View.VISIBLE;
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mStackScroller.setVisibility(View.VISIBLE);
    positionSettings(0);
    if (!mSettingsClosing) {
      mFlipSettingsView.setTranslationY(-mNotificationPanel.getMeasuredHeight());
    }
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
    final float dy=event.getY() - mSettingsDownY;
    final FlipperButton flipper=mOnKeyguard ? mKeyguardFlipper : mHeaderFlipper;
    final boolean inButton=flipper.inHolderBounds(event);
    final int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
    final boolean qsTap=mSettingsClosing && Math.abs(dy) < slop;
    if (!qsTap && !inButton) {
      mSettingsTracker.computeCurrentVelocity(1000);
      final float vy=mSettingsTracker.getYVelocity();
      if (dy <= slop || vy <= 0) {
        flipToNotifications();
      }
 else {
        flipToSettings();
      }
    }
    mSettingsTracker.recycle();
    mSettingsTracker=null;
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && event.getAction() == MotionEvent.ACTION_MOVE) {
    final float dy=event.getY() - mSettingsDownY;
    positionSettings(dy);
    if (mSettingsClosing) {
      final boolean qsTap=Math.abs(dy) < ViewConfiguration.get(mContext).getScaledTouchSlop();
      if (!mSettingsCancelled && !qsTap) {
        MotionEvent cancelEvent=MotionEvent.obtainNoHistory(event);
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);
        dispatchSettingsEvent(cancelEvent);
        mSettingsCancelled=true;
      }
    }
 else {
      dispatchSettingsEvent(event);
    }
  }
  return true;
}","public boolean onSettingsEvent(MotionEvent event){
  userActivity();
  if (mSettingsClosing && mFlipSettingsViewAnim != null && mFlipSettingsViewAnim.isRunning()) {
    return true;
  }
  if (mSettingsTracker != null) {
    mSettingsTracker.addMovement(event);
  }
  if (event.getAction() == MotionEvent.ACTION_DOWN) {
    mSettingsTracker=VelocityTracker.obtain();
    mSettingsDownY=event.getY();
    mSettingsCancelled=false;
    mSettingsClosing=mFlipSettingsView.getVisibility() == View.VISIBLE;
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mStackScroller.setVisibility(View.VISIBLE);
    positionSettings(0);
    if (!mSettingsClosing) {
      mFlipSettingsView.setTranslationY(-mNotificationPanel.getMeasuredHeight());
    }
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
    final float dy=event.getY() - mSettingsDownY;
    final FlipperButton flipper=mOnKeyguard ? mKeyguardFlipper : mHeaderFlipper;
    final boolean inButton=flipper.inHolderBounds(event);
    final int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
    final boolean qsTap=mSettingsClosing && Math.abs(dy) < slop;
    if (!qsTap && !inButton) {
      mSettingsTracker.computeCurrentVelocity(1000);
      final float vy=mSettingsTracker.getYVelocity();
      if (dy <= slop || vy <= 0) {
        flipToNotifications();
      }
 else {
        flipToSettings();
      }
    }
    mSettingsTracker.recycle();
    mSettingsTracker=null;
    dispatchSettingsEvent(event);
  }
 else   if (mSettingsTracker != null && event.getAction() == MotionEvent.ACTION_MOVE) {
    final float dy=event.getY() - mSettingsDownY;
    positionSettings(dy);
    if (mSettingsClosing) {
      final boolean qsTap=Math.abs(dy) < ViewConfiguration.get(mContext).getScaledTouchSlop();
      if (!mSettingsCancelled && !qsTap) {
        MotionEvent cancelEvent=MotionEvent.obtainNoHistory(event);
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL);
        dispatchSettingsEvent(cancelEvent);
        mSettingsCancelled=true;
      }
    }
 else {
      dispatchSettingsEvent(event);
    }
  }
  return true;
}",0.9686265396235184
199391,"private void positionSettings(float dy){
  final int h=mFlipSettingsView.getMeasuredHeight();
  final int ph=mNotificationPanel.getMeasuredHeight();
  if (mSettingsClosing) {
    dy=Math.min(Math.max(-ph,dy),0);
    mFlipSettingsView.setTranslationY(dy);
    mStackScroller.setTranslationY(ph + dy);
  }
 else {
    dy=Math.min(Math.max(0,dy),ph);
    mFlipSettingsView.setTranslationY(-h + dy - mNotificationPadding * 2);
    mStackScroller.setTranslationY(dy);
  }
}","private void positionSettings(float dy){
  if (mSettingsClosing) {
    final int ph=mNotificationPanel.getMeasuredHeight();
    dy=Math.min(Math.max(-ph,dy),0);
    mFlipSettingsView.setTranslationY(dy);
    mStackScroller.setTranslationY(ph + dy);
  }
 else {
    final int h=mFlipSettingsView.getBottom();
    dy=Math.min(Math.max(0,dy),h);
    mFlipSettingsView.setTranslationY(-h + dy);
    mStackScroller.setTranslationY(dy);
  }
}",0.7389380530973452
199392,"public void flipToNotifications(){
  mNotificationButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,0f).setDuration(FLIP_DURATION),mNotificationButton,View.INVISIBLE));
  mSettingsButton.setVisibility(View.VISIBLE);
  mSettingsButtonAnim=start(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,1f).setDuration(FLIP_DURATION));
}","public void flipToNotifications(){
  mNotificationButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,0f).setDuration(FLIP_DURATION_OUT),mNotificationButton,View.INVISIBLE));
  mSettingsButton.setVisibility(View.VISIBLE);
  mSettingsButtonAnim=start(startDelay(FLIP_DURATION_OUT,ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,1f).setDuration(FLIP_DURATION_IN)));
}",0.9525032092426188
199393,"public void flipToSettings(){
  mSettingsButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,0f).setDuration(FLIP_DURATION),mStackScroller,View.INVISIBLE));
  mNotificationButton.setVisibility(View.VISIBLE);
  mNotificationButtonAnim=start(ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,1f).setDuration(FLIP_DURATION));
}","public void flipToSettings(){
  mSettingsButtonAnim=start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton,View.ALPHA,0f).setDuration(FLIP_DURATION_OUT),mStackScroller,View.INVISIBLE));
  mNotificationButton.setVisibility(View.VISIBLE);
  mNotificationButtonAnim=start(startDelay(FLIP_DURATION_OUT,ObjectAnimator.ofFloat(mNotificationButton,View.ALPHA,1f).setDuration(FLIP_DURATION_IN)));
}",0.9517601043024772
199394,"@Override public boolean onTouchEvent(MotionEvent event){
  if (mScrim.getAlpha() == 1) {
    mScrim.animate().alpha(0).setDuration(1000).start();
    sShowScrim=false;
  }
  return super.onTouchEvent(event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (mScrim != null) {
    sShowScrim=false;
    removeView(mScrim);
  }
  return super.onTouchEvent(event);
}",0.7387862796833773
199395,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  mScrim.bringToFront();
  final int N=getChildCount();
  final boolean isLayoutRtl=isLayoutRtl();
  final int width=getWidth();
  int x=getPaddingStart();
  int y=getPaddingTop();
  int cursor=0;
  int maxRows=mKeyguardShowing ? mMaxRowsOnKeyguard : mMaxRows;
  for (int i=0; i < N; ++i) {
    if (getChildAt(i).equals(mScrim)) {
      int w=right - left - getPaddingLeft()- getPaddingRight();
      int h=bottom - top - getPaddingTop()- getPaddingBottom();
      mScrim.measure(MeasureSpec.makeMeasureSpec(w,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(h,MeasureSpec.EXACTLY));
      mScrim.layout(getPaddingLeft(),getPaddingTop(),right,bottom);
      continue;
    }
    QuickSettingsTileView child=(QuickSettingsTileView)getChildAt(i);
    ViewGroup.LayoutParams lp=child.getLayoutParams();
    if (child.getVisibility() != GONE) {
      final int col=cursor % mNumColumns;
      final int colSpan=child.getColumnSpan();
      final int childWidth=lp.width;
      final int childHeight=lp.height;
      int row=(int)(cursor / mNumColumns);
      if (row >= maxRows)       continue;
      if ((col + colSpan) > mNumColumns) {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
        row++;
      }
      final int childLeft=(isLayoutRtl) ? width - x - childWidth : x;
      final int childRight=childLeft + childWidth;
      final int childTop=y;
      final int childBottom=childTop + childHeight;
      child.layout(childLeft,childTop,childRight,childBottom);
      cursor+=child.getColumnSpan();
      if (cursor < (((row + 1) * mNumColumns))) {
        x+=childWidth + mCellGap;
      }
 else {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
      }
    }
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mScrim != null) {
    mScrim.bringToFront();
  }
  final int N=getChildCount();
  final boolean isLayoutRtl=isLayoutRtl();
  final int width=getWidth();
  int x=getPaddingStart();
  int y=getPaddingTop();
  int cursor=0;
  int maxRows=mKeyguardShowing ? mMaxRowsOnKeyguard : mMaxRows;
  for (int i=0; i < N; ++i) {
    if (getChildAt(i).equals(mScrim)) {
      int w=right - left - getPaddingLeft()- getPaddingRight();
      int h=bottom - top - getPaddingTop()- getPaddingBottom();
      mScrim.measure(MeasureSpec.makeMeasureSpec(w,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(h,MeasureSpec.EXACTLY));
      mScrim.layout(getPaddingLeft(),getPaddingTop(),right,bottom);
      continue;
    }
    QuickSettingsTileView child=(QuickSettingsTileView)getChildAt(i);
    ViewGroup.LayoutParams lp=child.getLayoutParams();
    if (child.getVisibility() != GONE) {
      final int col=cursor % mNumColumns;
      final int colSpan=child.getColumnSpan();
      final int childWidth=lp.width;
      final int childHeight=lp.height;
      int row=(int)(cursor / mNumColumns);
      if (row >= maxRows)       continue;
      if ((col + colSpan) > mNumColumns) {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
        row++;
      }
      final int childLeft=(isLayoutRtl) ? width - x - childWidth : x;
      final int childRight=childLeft + childWidth;
      final int childTop=y;
      final int childBottom=childTop + childHeight;
      child.layout(childLeft,childTop,childRight,childBottom);
      cursor+=child.getColumnSpan();
      if (cursor < (((row + 1) * mNumColumns))) {
        x+=childWidth + mCellGap;
      }
 else {
        x=getPaddingStart();
        y+=childHeight + mCellGap;
      }
    }
  }
}",0.9917081260364844
199396,"@Override protected void onDraw(Canvas canvas){
  final int w=getMeasuredWidth();
  final int h=getMeasuredHeight();
  final int f=mStrokeWidth * 3 / 4;
  canvas.drawPath(line(f,h / 2,w - f,h / 2),mLinePaint);
  canvas.drawPath(line(w / 2,f,w / 2,h - f),mLinePaint);
  final int s=mStrokeWidth;
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  canvas.drawText(""String_Node_Str"",w / 2 - s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  canvas.drawText(""String_Node_Str"",w / 2 + s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  drawUnder(canvas,""String_Node_Str"",w / 2 - s,h / 2 + s);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  drawUnder(canvas,""String_Node_Str"",w / 2 + s,h / 2 + s);
}","@Override protected void onDraw(Canvas canvas){
  final int w=getMeasuredWidth();
  final int h=getMeasuredHeight();
  final int f=mStrokeWidth * 3 / 4;
  canvas.drawColor(SCRIM);
  canvas.drawPath(line(f,h / 2,w - f,h / 2),mLinePaint);
  canvas.drawPath(line(w / 2,f,w / 2,h - f),mLinePaint);
  final int s=mStrokeWidth;
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  canvas.drawText(""String_Node_Str"",w / 2 - s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  canvas.drawText(""String_Node_Str"",w / 2 + s,h / 2 - s,mTextPaint);
  mTextPaint.setTextAlign(Paint.Align.RIGHT);
  drawUnder(canvas,""String_Node_Str"",w / 2 - s,h / 2 + s);
  mTextPaint.setTextAlign(Paint.Align.LEFT);
  drawUnder(canvas,""String_Node_Str"",w / 2 + s,h / 2 + s);
}",0.9819397993311036
199397,"@Override protected void onFinishInflate(){
  super.onFinishInflate();
  mScrim=new ScrimView(mContext);
  addView(mScrim);
  mScrim.setAlpha(sShowScrim ? 1 : 0);
  LayoutTransition transitions=getLayoutTransition();
}","@Override protected void onFinishInflate(){
  super.onFinishInflate();
  if (sShowScrim) {
    mScrim=new ScrimView(mContext);
    addView(mScrim);
  }
  LayoutTransition transitions=getLayoutTransition();
}",0.8564705882352941
199398,"private void adjustScreenOrientation(State state){
  if (!state.isKeyguardShowingAndNotOccluded() || mKeyguardScreenRotation) {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
  }
}","private void adjustScreenOrientation(State state){
  if (state.isKeyguardShowingAndNotOccluded()) {
    if (mKeyguardScreenRotation) {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
    }
 else {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    }
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
  }
}",0.8201219512195121
199399,"private void adjustScreenOrientation(State state){
  if (!state.isKeyguardShowingAndNotOccluded() || mKeyguardScreenRotation) {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
  }
}","private void adjustScreenOrientation(State state){
  if (state.isKeyguardShowingAndNotOccluded()) {
    if (mKeyguardScreenRotation) {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
    }
 else {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    }
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
  }
}",0.8201219512195121
199400,"private void adjustScreenOrientation(State state){
  if (!state.isKeyguardShowingAndNotOccluded() || mKeyguardScreenRotation) {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
  }
}","private void adjustScreenOrientation(State state){
  if (state.isKeyguardShowingAndNotOccluded()) {
    if (mKeyguardScreenRotation) {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
    }
 else {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    }
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
  }
}",0.8201219512195121
199401,"private void adjustScreenOrientation(State state){
  if (!state.isKeyguardShowingAndNotOccluded() || mKeyguardScreenRotation) {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
  }
}","private void adjustScreenOrientation(State state){
  if (state.isKeyguardShowingAndNotOccluded()) {
    if (mKeyguardScreenRotation) {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_USER;
    }
 else {
      mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    }
  }
 else {
    mLp.screenOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
  }
}",0.8201219512195121
199402,"public boolean hasPlaybackDevices(){
  return mHasPlaybackDevices;
}","public boolean hasPlaybackDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_Audio && deviceRecord.mDeviceDir == AlsaDeviceRecord.kDeviceDir_Playback) {
      return true;
    }
  }
  return false;
}",0.2149122807017544
199403,"public boolean hasCaptureDevices(){
  return mHasCaptureDevices;
}","public boolean hasCaptureDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_Audio && deviceRecord.mDeviceDir == AlsaDeviceRecord.kDeviceDir_Capture) {
      return true;
    }
  }
  return false;
}",0.1858407079646017
199404,"public boolean hasMIDIDevices(){
  return mHasMIDIDevices;
}","public boolean hasMIDIDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_MIDI) {
      return true;
    }
  }
  return false;
}",0.2180851063829787
199405,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  int device;
  int state;
  if (action.equals(Intent.ACTION_DOCK_EVENT)) {
    int dockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
    int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
      config=AudioSystem.FORCE_BT_DESK_DOCK;
    break;
case Intent.EXTRA_DOCK_STATE_CAR:
  config=AudioSystem.FORCE_BT_CAR_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_LE_DESK:
config=AudioSystem.FORCE_ANALOG_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_HE_DESK:
config=AudioSystem.FORCE_DIGITAL_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
config=AudioSystem.FORCE_NONE;
}
if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
mDockState=dockState;
}
 else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
state=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,BluetoothProfile.STATE_DISCONNECTED);
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
String address=null;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (btDevice == null) {
return;
}
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
if (!BluetoothAdapter.checkBluetoothAddress(address)) {
address=""String_Node_Str"";
}
boolean connected=(state == BluetoothProfile.STATE_CONNECTED);
if (handleDeviceConnection(connected,device,address)) {
synchronized (mScoClients) {
if (connected) {
mBluetoothHeadsetDevice=btDevice;
}
 else {
mBluetoothHeadsetDevice=null;
resetBluetoothSco();
}
}
}
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
boolean hasPlayback=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasCapture=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasMIDI=intent.getBooleanExtra(""String_Node_Str"",false);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
device=action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
device=action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_IN_USB_ACCESSORY : AudioSystem.DEVICE_IN_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
 else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
boolean broadcast=false;
int scoAudioState=AudioManager.SCO_AUDIO_STATE_ERROR;
synchronized (mScoClients) {
int btState=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,-1);
if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
broadcast=true;
}
switch (btState) {
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_CONNECTED;
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
break;
case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
mScoAudioState=SCO_STATE_INACTIVE;
clearAllScoClients(0,false);
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTING:
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
default :
broadcast=false;
break;
}
}
if (broadcast) {
broadcastScoConnectionState(scoAudioState);
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,scoAudioState);
sendStickyBroadcastToAll(newIntent);
}
}
 else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
mBootCompleted=true;
sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,null,0);
mKeyguardManager=(KeyguardManager)mContext.getSystemService(Context.KEYGUARD_SERVICE);
mScoConnectionState=AudioManager.SCO_AUDIO_STATE_ERROR;
resetBluetoothSco();
getBluetoothHeadset();
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
sendStickyBroadcastToAll(newIntent);
BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
if (adapter != null) {
adapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.A2DP);
}
sendMsg(mAudioHandler,MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,SENDMSG_REPLACE,0,0,null,SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
}
 else if (action.equals(Intent.ACTION_SCREEN_ON)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
handleConfigurationChanged(context);
}
 else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
sendMsg(mAudioHandler,MSG_BROADCAST_AUDIO_BECOMING_NOISY,SENDMSG_REPLACE,0,0,null,0);
mMediaFocusControl.discardAudioFocusOwner();
readAudioSettings(true);
sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,mStreamStates[AudioSystem.STREAM_MUSIC],0);
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  int device;
  int state;
  if (action.equals(Intent.ACTION_DOCK_EVENT)) {
    int dockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
    int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
      config=AudioSystem.FORCE_BT_DESK_DOCK;
    break;
case Intent.EXTRA_DOCK_STATE_CAR:
  config=AudioSystem.FORCE_BT_CAR_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_LE_DESK:
config=AudioSystem.FORCE_ANALOG_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_HE_DESK:
config=AudioSystem.FORCE_DIGITAL_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
config=AudioSystem.FORCE_NONE;
}
if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
mDockState=dockState;
}
 else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
state=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,BluetoothProfile.STATE_DISCONNECTED);
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
String address=null;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (btDevice == null) {
return;
}
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
if (!BluetoothAdapter.checkBluetoothAddress(address)) {
address=""String_Node_Str"";
}
boolean connected=(state == BluetoothProfile.STATE_CONNECTED);
if (handleDeviceConnection(connected,device,address)) {
synchronized (mScoClients) {
if (connected) {
mBluetoothHeadsetDevice=btDevice;
}
 else {
mBluetoothHeadsetDevice=null;
resetBluetoothSco();
}
}
}
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
device=AudioSystem.DEVICE_OUT_USB_ACCESSORY;
setWiredDeviceConnectionState(device,state,params);
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
boolean hasPlayback=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasCapture=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasMIDI=intent.getBooleanExtra(""String_Node_Str"",false);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
if (hasPlayback) {
device=AudioSystem.DEVICE_OUT_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
if (hasCapture) {
device=AudioSystem.DEVICE_IN_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
boolean broadcast=false;
int scoAudioState=AudioManager.SCO_AUDIO_STATE_ERROR;
synchronized (mScoClients) {
int btState=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,-1);
if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
broadcast=true;
}
switch (btState) {
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_CONNECTED;
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
break;
case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
mScoAudioState=SCO_STATE_INACTIVE;
clearAllScoClients(0,false);
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTING:
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
default :
broadcast=false;
break;
}
}
if (broadcast) {
broadcastScoConnectionState(scoAudioState);
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,scoAudioState);
sendStickyBroadcastToAll(newIntent);
}
}
 else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
mBootCompleted=true;
sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,null,0);
mKeyguardManager=(KeyguardManager)mContext.getSystemService(Context.KEYGUARD_SERVICE);
mScoConnectionState=AudioManager.SCO_AUDIO_STATE_ERROR;
resetBluetoothSco();
getBluetoothHeadset();
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
sendStickyBroadcastToAll(newIntent);
BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
if (adapter != null) {
adapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.A2DP);
}
sendMsg(mAudioHandler,MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,SENDMSG_REPLACE,0,0,null,SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
}
 else if (action.equals(Intent.ACTION_SCREEN_ON)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
handleConfigurationChanged(context);
}
 else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
sendMsg(mAudioHandler,MSG_BROADCAST_AUDIO_BECOMING_NOISY,SENDMSG_REPLACE,0,0,null,0);
mMediaFocusControl.discardAudioFocusOwner();
readAudioSettings(true);
sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,mStreamStates[AudioSystem.STREAM_MUSIC],0);
}
}",0.9477630184989
199406,"private void endUsbDeviceAdded(){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"");
  }
  if (mNewInterface != null) {
    mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
  }
  if (mNewConfiguration != null) {
    mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
  }
synchronized (mLock) {
    if (mNewDevice != null) {
      mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
      mDevices.put(mNewDevice.getDeviceName(),mNewDevice);
      Slog.d(TAG,""String_Node_Str"" + mNewDevice);
      getCurrentSettings().deviceAttached(mNewDevice);
    }
 else {
      Slog.e(TAG,""String_Node_Str"");
    }
    mNewDevice=null;
    mNewConfigurations=null;
    mNewInterfaces=null;
    mNewEndpoints=null;
  }
}","private void endUsbDeviceAdded(){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"");
  }
  if (mNewInterface != null) {
    mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
  }
  if (mNewConfiguration != null) {
    mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
  }
  final int kUsbClassId_Audio=0x01;
  boolean isAudioDevice=false;
  for (int ntrfaceIndex=0; !isAudioDevice && ntrfaceIndex < mNewInterfaces.size(); ntrfaceIndex++) {
    UsbInterface ntrface=mNewInterfaces.get(ntrfaceIndex);
    if (ntrface.getInterfaceClass() == kUsbClassId_Audio) {
      isAudioDevice=true;
    }
  }
synchronized (mLock) {
    if (mNewDevice != null) {
      mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
      mDevices.put(mNewDevice.getDeviceName(),mNewDevice);
      Slog.d(TAG,""String_Node_Str"" + mNewDevice);
      getCurrentSettings().deviceAttached(mNewDevice);
    }
 else {
      Slog.e(TAG,""String_Node_Str"");
    }
    mNewDevice=null;
    mNewConfigurations=null;
    mNewInterfaces=null;
    mNewEndpoints=null;
  }
  if (!isAudioDevice) {
    return;
  }
  AlsaCardsParser cardsParser=new AlsaCardsParser();
  cardsParser.scan();
  AlsaDevicesParser devicesParser=new AlsaDevicesParser();
  devicesParser.scan();
  mConnectedUsbCard=cardsParser.getNumCardRecords() - 1;
  mConnectedUsbDeviceNum=0;
  if (!waitForAlsaFile(mConnectedUsbCard,mConnectedUsbDeviceNum,false)) {
    return;
  }
  mConnectedHasPlayback=devicesParser.hasPlaybackDevices(mConnectedUsbCard);
  mConnectedHasCapture=devicesParser.hasCaptureDevices(mConnectedUsbCard);
  mConnectedHasMIDI=devicesParser.hasMIDIDevices(mConnectedUsbCard);
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + mConnectedHasPlayback + ""String_Node_Str""+ mConnectedHasCapture);
  }
  sendDeviceNotification(mConnectedUsbCard,mConnectedUsbDeviceNum,true,mConnectedHasPlayback,mConnectedHasCapture,mConnectedHasMIDI);
}",0.5923103567717354
199407,"private void usbDeviceRemoved(String deviceName){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName);
  }
  sendDeviceNotification(1,0,false,false,false,false);
synchronized (mLock) {
    UsbDevice device=mDevices.remove(deviceName);
    if (device != null) {
      getCurrentSettings().deviceDetached(device);
    }
  }
}","private void usbDeviceRemoved(String deviceName){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName);
  }
  if (mConnectedUsbCard != -1 && mConnectedUsbDeviceNum != -1) {
    sendDeviceNotification(mConnectedUsbCard,mConnectedUsbDeviceNum,false,mConnectedHasPlayback,mConnectedHasCapture,mConnectedHasMIDI);
    mConnectedUsbCard=-1;
    mConnectedUsbDeviceNum=-1;
    mConnectedHasPlayback=false;
    mConnectedHasCapture=false;
    mConnectedHasMIDI=false;
  }
synchronized (mLock) {
    UsbDevice device=mDevices.remove(deviceName);
    if (device != null) {
      getCurrentSettings().deviceDetached(device);
    }
  }
}",0.6061224489795919
199408,"private boolean beginUsbDeviceAdded(String deviceName,int vendorID,int productID,int deviceClass,int deviceSubclass,int deviceProtocol,String manufacturerName,String productName,String serialNumber){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ vendorID+ ""String_Node_Str""+ productID+ ""String_Node_Str""+ deviceClass+ ""String_Node_Str""+ deviceSubclass+ ""String_Node_Str""+ deviceProtocol);
  }
  if (!isBuiltInUsbDevice(deviceName)) {
    com.android.alsascan.AlsaDevicesParser devicesParser=new com.android.alsascan.AlsaDevicesParser();
    devicesParser.scan();
    boolean hasPlaybackDevices=devicesParser.hasPlaybackDevices();
    boolean hasCaptureDevices=devicesParser.hasCaptureDevices();
    boolean hasMIDI=devicesParser.hasMIDIDevices();
    if (DEBUG_AUDIO) {
      Slog.d(TAG,""String_Node_Str"" + hasPlaybackDevices + ""String_Node_Str""+ hasCaptureDevices);
    }
    int cardNum=1;
    int deviceNum=0;
    sendDeviceNotification(cardNum,deviceNum,true,hasPlaybackDevices,hasCaptureDevices,hasMIDI);
  }
  if (isBlackListed(deviceName) || isBlackListed(deviceClass,deviceSubclass,deviceProtocol)) {
    return false;
  }
synchronized (mLock) {
    if (mDevices.get(deviceName) != null) {
      Slog.w(TAG,""String_Node_Str"" + deviceName);
      return false;
    }
    if (mNewDevice != null) {
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    mNewDevice=new UsbDevice(deviceName,vendorID,productID,deviceClass,deviceSubclass,deviceProtocol,manufacturerName,productName,serialNumber);
    mNewConfigurations=new ArrayList<UsbConfiguration>();
    mNewInterfaces=new ArrayList<UsbInterface>();
    mNewEndpoints=new ArrayList<UsbEndpoint>();
  }
  return true;
}","private boolean beginUsbDeviceAdded(String deviceName,int vendorID,int productID,int deviceClass,int deviceSubclass,int deviceProtocol,String manufacturerName,String productName,String serialNumber){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ vendorID+ ""String_Node_Str""+ productID+ ""String_Node_Str""+ deviceClass+ ""String_Node_Str""+ deviceSubclass+ ""String_Node_Str""+ deviceProtocol);
  }
  if (isBlackListed(deviceName) || isBlackListed(deviceClass,deviceSubclass,deviceProtocol)) {
    return false;
  }
synchronized (mLock) {
    if (mDevices.get(deviceName) != null) {
      Slog.w(TAG,""String_Node_Str"" + deviceName);
      return false;
    }
    if (mNewDevice != null) {
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    mNewDevice=new UsbDevice(deviceName,vendorID,productID,deviceClass,deviceSubclass,deviceProtocol,manufacturerName,productName,serialNumber);
    mNewConfigurations=new ArrayList<UsbConfiguration>();
    mNewInterfaces=new ArrayList<UsbInterface>();
    mNewEndpoints=new ArrayList<UsbEndpoint>();
  }
  return true;
}",0.5003322259136213
199409,"public boolean hasPlaybackDevices(){
  return mHasPlaybackDevices;
}","public boolean hasPlaybackDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_Audio && deviceRecord.mDeviceDir == AlsaDeviceRecord.kDeviceDir_Playback) {
      return true;
    }
  }
  return false;
}",0.2149122807017544
199410,"public boolean hasCaptureDevices(){
  return mHasCaptureDevices;
}","public boolean hasCaptureDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_Audio && deviceRecord.mDeviceDir == AlsaDeviceRecord.kDeviceDir_Capture) {
      return true;
    }
  }
  return false;
}",0.1858407079646017
199411,"public boolean hasMIDIDevices(){
  return mHasMIDIDevices;
}","public boolean hasMIDIDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_MIDI) {
      return true;
    }
  }
  return false;
}",0.2180851063829787
199412,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  int device;
  int state;
  if (action.equals(Intent.ACTION_DOCK_EVENT)) {
    int dockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
    int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
      config=AudioSystem.FORCE_BT_DESK_DOCK;
    break;
case Intent.EXTRA_DOCK_STATE_CAR:
  config=AudioSystem.FORCE_BT_CAR_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_LE_DESK:
config=AudioSystem.FORCE_ANALOG_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_HE_DESK:
config=AudioSystem.FORCE_DIGITAL_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
config=AudioSystem.FORCE_NONE;
}
if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
mDockState=dockState;
}
 else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
state=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,BluetoothProfile.STATE_DISCONNECTED);
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
String address=null;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (btDevice == null) {
return;
}
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
if (!BluetoothAdapter.checkBluetoothAddress(address)) {
address=""String_Node_Str"";
}
boolean connected=(state == BluetoothProfile.STATE_CONNECTED);
if (handleDeviceConnection(connected,device,address)) {
synchronized (mScoClients) {
if (connected) {
mBluetoothHeadsetDevice=btDevice;
}
 else {
mBluetoothHeadsetDevice=null;
resetBluetoothSco();
}
}
}
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
boolean hasPlayback=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasCapture=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasMIDI=intent.getBooleanExtra(""String_Node_Str"",false);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
device=action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
device=action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_IN_USB_ACCESSORY : AudioSystem.DEVICE_IN_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
 else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
boolean broadcast=false;
int scoAudioState=AudioManager.SCO_AUDIO_STATE_ERROR;
synchronized (mScoClients) {
int btState=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,-1);
if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
broadcast=true;
}
switch (btState) {
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_CONNECTED;
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
break;
case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
mScoAudioState=SCO_STATE_INACTIVE;
clearAllScoClients(0,false);
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTING:
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
default :
broadcast=false;
break;
}
}
if (broadcast) {
broadcastScoConnectionState(scoAudioState);
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,scoAudioState);
sendStickyBroadcastToAll(newIntent);
}
}
 else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
mBootCompleted=true;
sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,null,0);
mKeyguardManager=(KeyguardManager)mContext.getSystemService(Context.KEYGUARD_SERVICE);
mScoConnectionState=AudioManager.SCO_AUDIO_STATE_ERROR;
resetBluetoothSco();
getBluetoothHeadset();
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
sendStickyBroadcastToAll(newIntent);
BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
if (adapter != null) {
adapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.A2DP);
}
sendMsg(mAudioHandler,MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,SENDMSG_REPLACE,0,0,null,SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
}
 else if (action.equals(Intent.ACTION_SCREEN_ON)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
handleConfigurationChanged(context);
}
 else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
sendMsg(mAudioHandler,MSG_BROADCAST_AUDIO_BECOMING_NOISY,SENDMSG_REPLACE,0,0,null,0);
mMediaFocusControl.discardAudioFocusOwner();
readAudioSettings(true);
sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,mStreamStates[AudioSystem.STREAM_MUSIC],0);
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  int device;
  int state;
  if (action.equals(Intent.ACTION_DOCK_EVENT)) {
    int dockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
    int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
      config=AudioSystem.FORCE_BT_DESK_DOCK;
    break;
case Intent.EXTRA_DOCK_STATE_CAR:
  config=AudioSystem.FORCE_BT_CAR_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_LE_DESK:
config=AudioSystem.FORCE_ANALOG_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_HE_DESK:
config=AudioSystem.FORCE_DIGITAL_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
config=AudioSystem.FORCE_NONE;
}
if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
mDockState=dockState;
}
 else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
state=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,BluetoothProfile.STATE_DISCONNECTED);
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
String address=null;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (btDevice == null) {
return;
}
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
if (!BluetoothAdapter.checkBluetoothAddress(address)) {
address=""String_Node_Str"";
}
boolean connected=(state == BluetoothProfile.STATE_CONNECTED);
if (handleDeviceConnection(connected,device,address)) {
synchronized (mScoClients) {
if (connected) {
mBluetoothHeadsetDevice=btDevice;
}
 else {
mBluetoothHeadsetDevice=null;
resetBluetoothSco();
}
}
}
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
device=AudioSystem.DEVICE_OUT_USB_ACCESSORY;
setWiredDeviceConnectionState(device,state,params);
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
boolean hasPlayback=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasCapture=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasMIDI=intent.getBooleanExtra(""String_Node_Str"",false);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
if (hasPlayback) {
device=AudioSystem.DEVICE_OUT_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
if (hasCapture) {
device=AudioSystem.DEVICE_IN_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
boolean broadcast=false;
int scoAudioState=AudioManager.SCO_AUDIO_STATE_ERROR;
synchronized (mScoClients) {
int btState=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,-1);
if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
broadcast=true;
}
switch (btState) {
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_CONNECTED;
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
break;
case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
mScoAudioState=SCO_STATE_INACTIVE;
clearAllScoClients(0,false);
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTING:
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
default :
broadcast=false;
break;
}
}
if (broadcast) {
broadcastScoConnectionState(scoAudioState);
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,scoAudioState);
sendStickyBroadcastToAll(newIntent);
}
}
 else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
mBootCompleted=true;
sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,null,0);
mKeyguardManager=(KeyguardManager)mContext.getSystemService(Context.KEYGUARD_SERVICE);
mScoConnectionState=AudioManager.SCO_AUDIO_STATE_ERROR;
resetBluetoothSco();
getBluetoothHeadset();
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
sendStickyBroadcastToAll(newIntent);
BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
if (adapter != null) {
adapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.A2DP);
}
sendMsg(mAudioHandler,MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,SENDMSG_REPLACE,0,0,null,SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
}
 else if (action.equals(Intent.ACTION_SCREEN_ON)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
handleConfigurationChanged(context);
}
 else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
sendMsg(mAudioHandler,MSG_BROADCAST_AUDIO_BECOMING_NOISY,SENDMSG_REPLACE,0,0,null,0);
mMediaFocusControl.discardAudioFocusOwner();
readAudioSettings(true);
sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,mStreamStates[AudioSystem.STREAM_MUSIC],0);
}
}",0.9477630184989
199413,"private void endUsbDeviceAdded(){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"");
  }
  if (mNewInterface != null) {
    mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
  }
  if (mNewConfiguration != null) {
    mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
  }
synchronized (mLock) {
    if (mNewDevice != null) {
      mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
      mDevices.put(mNewDevice.getDeviceName(),mNewDevice);
      Slog.d(TAG,""String_Node_Str"" + mNewDevice);
      getCurrentSettings().deviceAttached(mNewDevice);
    }
 else {
      Slog.e(TAG,""String_Node_Str"");
    }
    mNewDevice=null;
    mNewConfigurations=null;
    mNewInterfaces=null;
    mNewEndpoints=null;
  }
}","private void endUsbDeviceAdded(){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"");
  }
  if (mNewInterface != null) {
    mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
  }
  if (mNewConfiguration != null) {
    mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
  }
  final int kUsbClassId_Audio=0x01;
  boolean isAudioDevice=false;
  for (int ntrfaceIndex=0; !isAudioDevice && ntrfaceIndex < mNewInterfaces.size(); ntrfaceIndex++) {
    UsbInterface ntrface=mNewInterfaces.get(ntrfaceIndex);
    if (ntrface.getInterfaceClass() == kUsbClassId_Audio) {
      isAudioDevice=true;
    }
  }
synchronized (mLock) {
    if (mNewDevice != null) {
      mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
      mDevices.put(mNewDevice.getDeviceName(),mNewDevice);
      Slog.d(TAG,""String_Node_Str"" + mNewDevice);
      getCurrentSettings().deviceAttached(mNewDevice);
    }
 else {
      Slog.e(TAG,""String_Node_Str"");
    }
    mNewDevice=null;
    mNewConfigurations=null;
    mNewInterfaces=null;
    mNewEndpoints=null;
  }
  if (!isAudioDevice) {
    return;
  }
  AlsaCardsParser cardsParser=new AlsaCardsParser();
  cardsParser.scan();
  AlsaDevicesParser devicesParser=new AlsaDevicesParser();
  devicesParser.scan();
  mConnectedUsbCard=cardsParser.getNumCardRecords() - 1;
  mConnectedUsbDeviceNum=0;
  if (!waitForAlsaFile(mConnectedUsbCard,mConnectedUsbDeviceNum,false)) {
    return;
  }
  mConnectedHasPlayback=devicesParser.hasPlaybackDevices(mConnectedUsbCard);
  mConnectedHasCapture=devicesParser.hasCaptureDevices(mConnectedUsbCard);
  mConnectedHasMIDI=devicesParser.hasMIDIDevices(mConnectedUsbCard);
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + mConnectedHasPlayback + ""String_Node_Str""+ mConnectedHasCapture);
  }
  sendDeviceNotification(mConnectedUsbCard,mConnectedUsbDeviceNum,true,mConnectedHasPlayback,mConnectedHasCapture,mConnectedHasMIDI);
}",0.5923103567717354
199414,"private void usbDeviceRemoved(String deviceName){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName);
  }
  sendDeviceNotification(1,0,false,false,false,false);
synchronized (mLock) {
    UsbDevice device=mDevices.remove(deviceName);
    if (device != null) {
      getCurrentSettings().deviceDetached(device);
    }
  }
}","private void usbDeviceRemoved(String deviceName){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName);
  }
  if (mConnectedUsbCard != -1 && mConnectedUsbDeviceNum != -1) {
    sendDeviceNotification(mConnectedUsbCard,mConnectedUsbDeviceNum,false,mConnectedHasPlayback,mConnectedHasCapture,mConnectedHasMIDI);
    mConnectedUsbCard=-1;
    mConnectedUsbDeviceNum=-1;
    mConnectedHasPlayback=false;
    mConnectedHasCapture=false;
    mConnectedHasMIDI=false;
  }
synchronized (mLock) {
    UsbDevice device=mDevices.remove(deviceName);
    if (device != null) {
      getCurrentSettings().deviceDetached(device);
    }
  }
}",0.6061224489795919
199415,"private boolean beginUsbDeviceAdded(String deviceName,int vendorID,int productID,int deviceClass,int deviceSubclass,int deviceProtocol,String manufacturerName,String productName,String serialNumber){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ vendorID+ ""String_Node_Str""+ productID+ ""String_Node_Str""+ deviceClass+ ""String_Node_Str""+ deviceSubclass+ ""String_Node_Str""+ deviceProtocol);
  }
  if (!isBuiltInUsbDevice(deviceName)) {
    com.android.alsascan.AlsaDevicesParser devicesParser=new com.android.alsascan.AlsaDevicesParser();
    devicesParser.scan();
    boolean hasPlaybackDevices=devicesParser.hasPlaybackDevices();
    boolean hasCaptureDevices=devicesParser.hasCaptureDevices();
    boolean hasMIDI=devicesParser.hasMIDIDevices();
    if (DEBUG_AUDIO) {
      Slog.d(TAG,""String_Node_Str"" + hasPlaybackDevices + ""String_Node_Str""+ hasCaptureDevices);
    }
    int cardNum=1;
    int deviceNum=0;
    sendDeviceNotification(cardNum,deviceNum,true,hasPlaybackDevices,hasCaptureDevices,hasMIDI);
  }
  if (isBlackListed(deviceName) || isBlackListed(deviceClass,deviceSubclass,deviceProtocol)) {
    return false;
  }
synchronized (mLock) {
    if (mDevices.get(deviceName) != null) {
      Slog.w(TAG,""String_Node_Str"" + deviceName);
      return false;
    }
    if (mNewDevice != null) {
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    mNewDevice=new UsbDevice(deviceName,vendorID,productID,deviceClass,deviceSubclass,deviceProtocol,manufacturerName,productName,serialNumber);
    mNewConfigurations=new ArrayList<UsbConfiguration>();
    mNewInterfaces=new ArrayList<UsbInterface>();
    mNewEndpoints=new ArrayList<UsbEndpoint>();
  }
  return true;
}","private boolean beginUsbDeviceAdded(String deviceName,int vendorID,int productID,int deviceClass,int deviceSubclass,int deviceProtocol,String manufacturerName,String productName,String serialNumber){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ vendorID+ ""String_Node_Str""+ productID+ ""String_Node_Str""+ deviceClass+ ""String_Node_Str""+ deviceSubclass+ ""String_Node_Str""+ deviceProtocol);
  }
  if (isBlackListed(deviceName) || isBlackListed(deviceClass,deviceSubclass,deviceProtocol)) {
    return false;
  }
synchronized (mLock) {
    if (mDevices.get(deviceName) != null) {
      Slog.w(TAG,""String_Node_Str"" + deviceName);
      return false;
    }
    if (mNewDevice != null) {
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    mNewDevice=new UsbDevice(deviceName,vendorID,productID,deviceClass,deviceSubclass,deviceProtocol,manufacturerName,productName,serialNumber);
    mNewConfigurations=new ArrayList<UsbConfiguration>();
    mNewInterfaces=new ArrayList<UsbInterface>();
    mNewEndpoints=new ArrayList<UsbEndpoint>();
  }
  return true;
}",0.5003322259136213
199416,"public boolean hasPlaybackDevices(){
  return mHasPlaybackDevices;
}","public boolean hasPlaybackDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_Audio && deviceRecord.mDeviceDir == AlsaDeviceRecord.kDeviceDir_Playback) {
      return true;
    }
  }
  return false;
}",0.2149122807017544
199417,"public boolean hasCaptureDevices(){
  return mHasCaptureDevices;
}","public boolean hasCaptureDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_Audio && deviceRecord.mDeviceDir == AlsaDeviceRecord.kDeviceDir_Capture) {
      return true;
    }
  }
  return false;
}",0.1858407079646017
199418,"public boolean hasMIDIDevices(){
  return mHasMIDIDevices;
}","public boolean hasMIDIDevices(int card){
  for (int index=0; index < deviceRecords_.size(); index++) {
    AlsaDeviceRecord deviceRecord=deviceRecords_.get(index);
    if (deviceRecord.mCardNum == card && deviceRecord.mDeviceType == AlsaDeviceRecord.kDeviceType_MIDI) {
      return true;
    }
  }
  return false;
}",0.2180851063829787
199419,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  int device;
  int state;
  if (action.equals(Intent.ACTION_DOCK_EVENT)) {
    int dockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
    int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
      config=AudioSystem.FORCE_BT_DESK_DOCK;
    break;
case Intent.EXTRA_DOCK_STATE_CAR:
  config=AudioSystem.FORCE_BT_CAR_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_LE_DESK:
config=AudioSystem.FORCE_ANALOG_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_HE_DESK:
config=AudioSystem.FORCE_DIGITAL_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
config=AudioSystem.FORCE_NONE;
}
if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
mDockState=dockState;
}
 else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
state=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,BluetoothProfile.STATE_DISCONNECTED);
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
String address=null;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (btDevice == null) {
return;
}
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
if (!BluetoothAdapter.checkBluetoothAddress(address)) {
address=""String_Node_Str"";
}
boolean connected=(state == BluetoothProfile.STATE_CONNECTED);
if (handleDeviceConnection(connected,device,address)) {
synchronized (mScoClients) {
if (connected) {
mBluetoothHeadsetDevice=btDevice;
}
 else {
mBluetoothHeadsetDevice=null;
resetBluetoothSco();
}
}
}
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
boolean hasPlayback=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasCapture=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasMIDI=intent.getBooleanExtra(""String_Node_Str"",false);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
device=action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
device=action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_IN_USB_ACCESSORY : AudioSystem.DEVICE_IN_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
 else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
boolean broadcast=false;
int scoAudioState=AudioManager.SCO_AUDIO_STATE_ERROR;
synchronized (mScoClients) {
int btState=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,-1);
if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
broadcast=true;
}
switch (btState) {
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_CONNECTED;
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
break;
case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
mScoAudioState=SCO_STATE_INACTIVE;
clearAllScoClients(0,false);
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTING:
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
default :
broadcast=false;
break;
}
}
if (broadcast) {
broadcastScoConnectionState(scoAudioState);
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,scoAudioState);
sendStickyBroadcastToAll(newIntent);
}
}
 else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
mBootCompleted=true;
sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,null,0);
mKeyguardManager=(KeyguardManager)mContext.getSystemService(Context.KEYGUARD_SERVICE);
mScoConnectionState=AudioManager.SCO_AUDIO_STATE_ERROR;
resetBluetoothSco();
getBluetoothHeadset();
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
sendStickyBroadcastToAll(newIntent);
BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
if (adapter != null) {
adapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.A2DP);
}
sendMsg(mAudioHandler,MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,SENDMSG_REPLACE,0,0,null,SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
}
 else if (action.equals(Intent.ACTION_SCREEN_ON)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
handleConfigurationChanged(context);
}
 else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
sendMsg(mAudioHandler,MSG_BROADCAST_AUDIO_BECOMING_NOISY,SENDMSG_REPLACE,0,0,null,0);
mMediaFocusControl.discardAudioFocusOwner();
readAudioSettings(true);
sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,mStreamStates[AudioSystem.STREAM_MUSIC],0);
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  int device;
  int state;
  if (action.equals(Intent.ACTION_DOCK_EVENT)) {
    int dockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
    int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
      config=AudioSystem.FORCE_BT_DESK_DOCK;
    break;
case Intent.EXTRA_DOCK_STATE_CAR:
  config=AudioSystem.FORCE_BT_CAR_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_LE_DESK:
config=AudioSystem.FORCE_ANALOG_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_HE_DESK:
config=AudioSystem.FORCE_DIGITAL_DOCK;
break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
config=AudioSystem.FORCE_NONE;
}
if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
mDockState=dockState;
}
 else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
state=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,BluetoothProfile.STATE_DISCONNECTED);
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
String address=null;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
if (btDevice == null) {
return;
}
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
if (!BluetoothAdapter.checkBluetoothAddress(address)) {
address=""String_Node_Str"";
}
boolean connected=(state == BluetoothProfile.STATE_CONNECTED);
if (handleDeviceConnection(connected,device,address)) {
synchronized (mScoClients) {
if (connected) {
mBluetoothHeadsetDevice=btDevice;
}
 else {
mBluetoothHeadsetDevice=null;
resetBluetoothSco();
}
}
}
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
device=AudioSystem.DEVICE_OUT_USB_ACCESSORY;
setWiredDeviceConnectionState(device,state,params);
}
 else if (action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
state=intent.getIntExtra(""String_Node_Str"",0);
int alsaCard=intent.getIntExtra(""String_Node_Str"",-1);
int alsaDevice=intent.getIntExtra(""String_Node_Str"",-1);
boolean hasPlayback=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasCapture=intent.getBooleanExtra(""String_Node_Str"",false);
boolean hasMIDI=intent.getBooleanExtra(""String_Node_Str"",false);
String params=(alsaCard == -1 && alsaDevice == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + alsaCard + ""String_Node_Str""+ alsaDevice);
if (hasPlayback) {
device=AudioSystem.DEVICE_OUT_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
if (hasCapture) {
device=AudioSystem.DEVICE_IN_USB_DEVICE;
setWiredDeviceConnectionState(device,state,params);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
boolean broadcast=false;
int scoAudioState=AudioManager.SCO_AUDIO_STATE_ERROR;
synchronized (mScoClients) {
int btState=intent.getIntExtra(BluetoothProfile.EXTRA_STATE,-1);
if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
broadcast=true;
}
switch (btState) {
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_CONNECTED;
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
break;
case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
scoAudioState=AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
mScoAudioState=SCO_STATE_INACTIVE;
clearAllScoClients(0,false);
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTING:
if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
mScoAudioState=SCO_STATE_ACTIVE_EXTERNAL;
}
default :
broadcast=false;
break;
}
}
if (broadcast) {
broadcastScoConnectionState(scoAudioState);
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,scoAudioState);
sendStickyBroadcastToAll(newIntent);
}
}
 else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
mBootCompleted=true;
sendMsg(mAudioHandler,MSG_LOAD_SOUND_EFFECTS,SENDMSG_QUEUE,0,0,null,0);
mKeyguardManager=(KeyguardManager)mContext.getSystemService(Context.KEYGUARD_SERVICE);
mScoConnectionState=AudioManager.SCO_AUDIO_STATE_ERROR;
resetBluetoothSco();
getBluetoothHeadset();
Intent newIntent=new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
sendStickyBroadcastToAll(newIntent);
BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
if (adapter != null) {
adapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.A2DP);
}
sendMsg(mAudioHandler,MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,SENDMSG_REPLACE,0,0,null,SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
}
 else if (action.equals(Intent.ACTION_SCREEN_ON)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
AudioSystem.setParameters(""String_Node_Str"");
}
 else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
handleConfigurationChanged(context);
}
 else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
sendMsg(mAudioHandler,MSG_BROADCAST_AUDIO_BECOMING_NOISY,SENDMSG_REPLACE,0,0,null,0);
mMediaFocusControl.discardAudioFocusOwner();
readAudioSettings(true);
sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,mStreamStates[AudioSystem.STREAM_MUSIC],0);
}
}",0.9477630184989
199420,"private void endUsbDeviceAdded(){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"");
  }
  if (mNewInterface != null) {
    mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
  }
  if (mNewConfiguration != null) {
    mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
  }
synchronized (mLock) {
    if (mNewDevice != null) {
      mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
      mDevices.put(mNewDevice.getDeviceName(),mNewDevice);
      Slog.d(TAG,""String_Node_Str"" + mNewDevice);
      getCurrentSettings().deviceAttached(mNewDevice);
    }
 else {
      Slog.e(TAG,""String_Node_Str"");
    }
    mNewDevice=null;
    mNewConfigurations=null;
    mNewInterfaces=null;
    mNewEndpoints=null;
  }
}","private void endUsbDeviceAdded(){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"");
  }
  if (mNewInterface != null) {
    mNewInterface.setEndpoints(mNewEndpoints.toArray(new UsbEndpoint[mNewEndpoints.size()]));
  }
  if (mNewConfiguration != null) {
    mNewConfiguration.setInterfaces(mNewInterfaces.toArray(new UsbInterface[mNewInterfaces.size()]));
  }
  final int kUsbClassId_Audio=0x01;
  boolean isAudioDevice=false;
  for (int ntrfaceIndex=0; !isAudioDevice && ntrfaceIndex < mNewInterfaces.size(); ntrfaceIndex++) {
    UsbInterface ntrface=mNewInterfaces.get(ntrfaceIndex);
    if (ntrface.getInterfaceClass() == kUsbClassId_Audio) {
      isAudioDevice=true;
    }
  }
synchronized (mLock) {
    if (mNewDevice != null) {
      mNewDevice.setConfigurations(mNewConfigurations.toArray(new UsbConfiguration[mNewConfigurations.size()]));
      mDevices.put(mNewDevice.getDeviceName(),mNewDevice);
      Slog.d(TAG,""String_Node_Str"" + mNewDevice);
      getCurrentSettings().deviceAttached(mNewDevice);
    }
 else {
      Slog.e(TAG,""String_Node_Str"");
    }
    mNewDevice=null;
    mNewConfigurations=null;
    mNewInterfaces=null;
    mNewEndpoints=null;
  }
  if (!isAudioDevice) {
    return;
  }
  AlsaCardsParser cardsParser=new AlsaCardsParser();
  cardsParser.scan();
  AlsaDevicesParser devicesParser=new AlsaDevicesParser();
  devicesParser.scan();
  mConnectedUsbCard=cardsParser.getNumCardRecords() - 1;
  mConnectedUsbDeviceNum=0;
  if (!waitForAlsaFile(mConnectedUsbCard,mConnectedUsbDeviceNum,false)) {
    return;
  }
  mConnectedHasPlayback=devicesParser.hasPlaybackDevices(mConnectedUsbCard);
  mConnectedHasCapture=devicesParser.hasCaptureDevices(mConnectedUsbCard);
  mConnectedHasMIDI=devicesParser.hasMIDIDevices(mConnectedUsbCard);
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + mConnectedHasPlayback + ""String_Node_Str""+ mConnectedHasCapture);
  }
  sendDeviceNotification(mConnectedUsbCard,mConnectedUsbDeviceNum,true,mConnectedHasPlayback,mConnectedHasCapture,mConnectedHasMIDI);
}",0.5923103567717354
199421,"private void usbDeviceRemoved(String deviceName){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName);
  }
  sendDeviceNotification(1,0,false,false,false,false);
synchronized (mLock) {
    UsbDevice device=mDevices.remove(deviceName);
    if (device != null) {
      getCurrentSettings().deviceDetached(device);
    }
  }
}","private void usbDeviceRemoved(String deviceName){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName);
  }
  if (mConnectedUsbCard != -1 && mConnectedUsbDeviceNum != -1) {
    sendDeviceNotification(mConnectedUsbCard,mConnectedUsbDeviceNum,false,mConnectedHasPlayback,mConnectedHasCapture,mConnectedHasMIDI);
    mConnectedUsbCard=-1;
    mConnectedUsbDeviceNum=-1;
    mConnectedHasPlayback=false;
    mConnectedHasCapture=false;
    mConnectedHasMIDI=false;
  }
synchronized (mLock) {
    UsbDevice device=mDevices.remove(deviceName);
    if (device != null) {
      getCurrentSettings().deviceDetached(device);
    }
  }
}",0.6061224489795919
199422,"private boolean beginUsbDeviceAdded(String deviceName,int vendorID,int productID,int deviceClass,int deviceSubclass,int deviceProtocol,String manufacturerName,String productName,String serialNumber){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ vendorID+ ""String_Node_Str""+ productID+ ""String_Node_Str""+ deviceClass+ ""String_Node_Str""+ deviceSubclass+ ""String_Node_Str""+ deviceProtocol);
  }
  if (!isBuiltInUsbDevice(deviceName)) {
    com.android.alsascan.AlsaDevicesParser devicesParser=new com.android.alsascan.AlsaDevicesParser();
    devicesParser.scan();
    boolean hasPlaybackDevices=devicesParser.hasPlaybackDevices();
    boolean hasCaptureDevices=devicesParser.hasCaptureDevices();
    boolean hasMIDI=devicesParser.hasMIDIDevices();
    if (DEBUG_AUDIO) {
      Slog.d(TAG,""String_Node_Str"" + hasPlaybackDevices + ""String_Node_Str""+ hasCaptureDevices);
    }
    int cardNum=1;
    int deviceNum=0;
    sendDeviceNotification(cardNum,deviceNum,true,hasPlaybackDevices,hasCaptureDevices,hasMIDI);
  }
  if (isBlackListed(deviceName) || isBlackListed(deviceClass,deviceSubclass,deviceProtocol)) {
    return false;
  }
synchronized (mLock) {
    if (mDevices.get(deviceName) != null) {
      Slog.w(TAG,""String_Node_Str"" + deviceName);
      return false;
    }
    if (mNewDevice != null) {
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    mNewDevice=new UsbDevice(deviceName,vendorID,productID,deviceClass,deviceSubclass,deviceProtocol,manufacturerName,productName,serialNumber);
    mNewConfigurations=new ArrayList<UsbConfiguration>();
    mNewInterfaces=new ArrayList<UsbInterface>();
    mNewEndpoints=new ArrayList<UsbEndpoint>();
  }
  return true;
}","private boolean beginUsbDeviceAdded(String deviceName,int vendorID,int productID,int deviceClass,int deviceSubclass,int deviceProtocol,String manufacturerName,String productName,String serialNumber){
  if (DEBUG_AUDIO) {
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str"");
    Slog.d(TAG,""String_Node_Str"" + deviceName + ""String_Node_Str""+ vendorID+ ""String_Node_Str""+ productID+ ""String_Node_Str""+ deviceClass+ ""String_Node_Str""+ deviceSubclass+ ""String_Node_Str""+ deviceProtocol);
  }
  if (isBlackListed(deviceName) || isBlackListed(deviceClass,deviceSubclass,deviceProtocol)) {
    return false;
  }
synchronized (mLock) {
    if (mDevices.get(deviceName) != null) {
      Slog.w(TAG,""String_Node_Str"" + deviceName);
      return false;
    }
    if (mNewDevice != null) {
      Slog.e(TAG,""String_Node_Str"");
      return false;
    }
    mNewDevice=new UsbDevice(deviceName,vendorID,productID,deviceClass,deviceSubclass,deviceProtocol,manufacturerName,productName,serialNumber);
    mNewConfigurations=new ArrayList<UsbConfiguration>();
    mNewInterfaces=new ArrayList<UsbInterface>();
    mNewEndpoints=new ArrayList<UsbEndpoint>();
  }
  return true;
}",0.5003322259136213
199423,"@SuppressWarnings(""String_Node_Str"") private <T>T getOverride(Key<T> key){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return (T)getAvailableFormats();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACES)) {
    return (T)getFaces();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return (T)getFaceRectangles();
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private <T>T getOverride(Key<T> key){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return (T)getAvailableFormats();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACES)) {
    return (T)getFaces();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return (T)getFaceRectangles();
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS)) {
    return (T)getAvailableStreamConfigurations();
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS)) {
    return (T)getAvailableMinFrameDurations();
  }
  return null;
}",0.7165575304022451
199424,"private <T>boolean setOverride(Key<T> key,T value){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return setAvailableFormats((int[])value);
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return setFaceRectangles((Rect[])value);
  }
  return false;
}","private <T>boolean setOverride(Key<T> key,T value){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return setAvailableFormats((int[])value);
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return setFaceRectangles((Rect[])value);
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS)) {
    return setAvailableStreamConfigurations((int[])value);
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS)) {
    return setAvailableMinFrameDurations((long[])value);
  }
  return false;
}",0.6445916114790287
199425,"@SmallTest public void testReadWriteOverride(){
  int[] availableFormats=new int[]{0x20,0x32315659,0x11,0x100,0x22,0x23};
  int[] expectedIntValues=new int[]{0x20,0x32315659,0x11,0x21,0x22,0x23};
  int availableFormatTag=CameraMetadataNative.getTag(""String_Node_Str"");
  mMetadata.set(CameraCharacteristics.SCALER_AVAILABLE_FORMATS,availableFormats);
  byte[] availableFormatValues=mMetadata.readValues(availableFormatTag);
  ByteBuffer bf=ByteBuffer.wrap(availableFormatValues).order(ByteOrder.nativeOrder());
  assertEquals(expectedIntValues.length * 4,availableFormatValues.length);
  for (int i=0; i < expectedIntValues.length; ++i) {
    assertEquals(expectedIntValues[i],bf.getInt());
  }
  byte[] availableFormatsAsByteArray=new byte[expectedIntValues.length * 4];
  ByteBuffer availableFormatsByteBuffer=ByteBuffer.wrap(availableFormatsAsByteArray).order(ByteOrder.nativeOrder());
  for (  int value : expectedIntValues) {
    availableFormatsByteBuffer.putInt(value);
  }
  mMetadata.writeValues(availableFormatTag,availableFormatsAsByteArray);
  int[] resultFormats=mMetadata.get(CameraCharacteristics.SCALER_AVAILABLE_FORMATS);
  assertNotNull(""String_Node_Str"",resultFormats);
  assertArrayEquals(availableFormats,resultFormats);
  int[] expectedFaceIds=new int[]{1,2,3,4,5};
  byte[] expectedFaceScores=new byte[]{10,20,30,40,50};
  int numFaces=expectedFaceIds.length;
  Rect[] expectedRects=new Rect[numFaces];
  for (int i=0; i < numFaces; i++) {
    expectedRects[i]=new Rect(i * 4 + 1,i * 4 + 2,i * 4 + 3,i * 4 + 4);
  }
  int[] expectedFaceLM=new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
  Point[] expectedFaceLMPoints=new Point[numFaces * 3];
  for (int i=0; i < numFaces; i++) {
    expectedFaceLMPoints[i * 3]=new Point(expectedFaceLM[i * 6],expectedFaceLM[i * 6 + 1]);
    expectedFaceLMPoints[i * 3 + 1]=new Point(expectedFaceLM[i * 6 + 2],expectedFaceLM[i * 6 + 3]);
    expectedFaceLMPoints[i * 3 + 2]=new Point(expectedFaceLM[i * 6 + 4],expectedFaceLM[i * 6 + 5]);
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL);
  mMetadata.set(CaptureResult.STATISTICS_FACE_IDS,expectedFaceIds);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  mMetadata.set(CaptureResult.STATISTICS_FACE_LANDMARKS,expectedFaceLM);
  Face[] resultFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(expectedFaceIds[i],resultFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultFaces[i].getScore());
    assertEquals(expectedRects[i],resultFaces[i].getBounds());
    assertEquals(expectedFaceLMPoints[i * 3],resultFaces[i].getLeftEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 1],resultFaces[i].getRightEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 2],resultFaces[i].getMouthPosition());
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  Face[] resultSimpleFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultSimpleFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(Face.ID_UNSUPPORTED,resultSimpleFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultSimpleFaces[i].getScore());
    assertEquals(expectedRects[i],resultSimpleFaces[i].getBounds());
    assertNull(resultSimpleFaces[i].getLeftEyePosition());
    assertNull(resultSimpleFaces[i].getRightEyePosition());
    assertNull(resultSimpleFaces[i].getMouthPosition());
  }
}","@SmallTest public void testReadWriteOverride(){
  int[] availableFormats=new int[]{0x20,0x32315659,0x11,0x100,0x22,0x23};
  int[] expectedIntValues=new int[]{0x20,0x32315659,0x11,0x21,0x22,0x23};
  int availableFormatTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<int[]> formatKey=CameraCharacteristics.SCALER_AVAILABLE_FORMATS;
  validateArrayMetadataReadWriteOverride(formatKey,availableFormats,expectedIntValues,availableFormatTag);
  final int OUTPUT=CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT;
  int[] availableStreamConfigs=new int[]{0x20,3280,2464,OUTPUT,0x23,3264,2448,OUTPUT,0x23,3200,2400,OUTPUT,0x100,3264,2448,OUTPUT,0x100,3200,2400,OUTPUT,0x100,2592,1944,OUTPUT,0x100,2048,1536,OUTPUT,0x100,1920,1080,OUTPUT};
  int[] expectedAvailableStreamConfigs=new int[]{0x20,3280,2464,OUTPUT,0x23,3264,2448,OUTPUT,0x23,3200,2400,OUTPUT,0x21,3264,2448,OUTPUT,0x21,3200,2400,OUTPUT,0x21,2592,1944,OUTPUT,0x21,2048,1536,OUTPUT,0x21,1920,1080,OUTPUT};
  int availableStreamConfigTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<int[]> configKey=CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS;
  validateArrayMetadataReadWriteOverride(configKey,availableStreamConfigs,expectedAvailableStreamConfigs,availableStreamConfigTag);
  long[] availableMinDurations=new long[]{0x20,3280,2464,33333336,0x23,3264,2448,33333336,0x23,3200,2400,33333336,0x100,3264,2448,33333336,0x100,3200,2400,33333336,0x100,2592,1944,33333336,0x100,2048,1536,33333336,0x100,1920,1080,33333336};
  long[] expectedAvailableMinDurations=new long[]{0x20,3280,2464,33333336,0x23,3264,2448,33333336,0x23,3200,2400,33333336,0x21,3264,2448,33333336,0x21,3200,2400,33333336,0x21,2592,1944,33333336,0x21,2048,1536,33333336,0x21,1920,1080,33333336};
  int availableMinDurationsTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<long[]> durationKey=CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS;
  validateArrayMetadataReadWriteOverride(durationKey,availableMinDurations,expectedAvailableMinDurations,availableMinDurationsTag);
  int[] expectedFaceIds=new int[]{1,2,3,4,5};
  byte[] expectedFaceScores=new byte[]{10,20,30,40,50};
  int numFaces=expectedFaceIds.length;
  Rect[] expectedRects=new Rect[numFaces];
  for (int i=0; i < numFaces; i++) {
    expectedRects[i]=new Rect(i * 4 + 1,i * 4 + 2,i * 4 + 3,i * 4 + 4);
  }
  int[] expectedFaceLM=new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
  Point[] expectedFaceLMPoints=new Point[numFaces * 3];
  for (int i=0; i < numFaces; i++) {
    expectedFaceLMPoints[i * 3]=new Point(expectedFaceLM[i * 6],expectedFaceLM[i * 6 + 1]);
    expectedFaceLMPoints[i * 3 + 1]=new Point(expectedFaceLM[i * 6 + 2],expectedFaceLM[i * 6 + 3]);
    expectedFaceLMPoints[i * 3 + 2]=new Point(expectedFaceLM[i * 6 + 4],expectedFaceLM[i * 6 + 5]);
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL);
  mMetadata.set(CaptureResult.STATISTICS_FACE_IDS,expectedFaceIds);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  mMetadata.set(CaptureResult.STATISTICS_FACE_LANDMARKS,expectedFaceLM);
  Face[] resultFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(expectedFaceIds[i],resultFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultFaces[i].getScore());
    assertEquals(expectedRects[i],resultFaces[i].getBounds());
    assertEquals(expectedFaceLMPoints[i * 3],resultFaces[i].getLeftEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 1],resultFaces[i].getRightEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 2],resultFaces[i].getMouthPosition());
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  Face[] resultSimpleFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultSimpleFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(Face.ID_UNSUPPORTED,resultSimpleFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultSimpleFaces[i].getScore());
    assertEquals(expectedRects[i],resultSimpleFaces[i].getBounds());
    assertNull(resultSimpleFaces[i].getLeftEyePosition());
    assertNull(resultSimpleFaces[i].getRightEyePosition());
    assertNull(resultSimpleFaces[i].getMouthPosition());
  }
}",0.7147887323943662
199426,"@SuppressWarnings(""String_Node_Str"") private <T>T getOverride(Key<T> key){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return (T)getAvailableFormats();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACES)) {
    return (T)getFaces();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return (T)getFaceRectangles();
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private <T>T getOverride(Key<T> key){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return (T)getAvailableFormats();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACES)) {
    return (T)getFaces();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return (T)getFaceRectangles();
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS)) {
    return (T)getAvailableStreamConfigurations();
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS)) {
    return (T)getAvailableMinFrameDurations();
  }
  return null;
}",0.7165575304022451
199427,"private <T>boolean setOverride(Key<T> key,T value){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return setAvailableFormats((int[])value);
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return setFaceRectangles((Rect[])value);
  }
  return false;
}","private <T>boolean setOverride(Key<T> key,T value){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return setAvailableFormats((int[])value);
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return setFaceRectangles((Rect[])value);
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS)) {
    return setAvailableStreamConfigurations((int[])value);
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS)) {
    return setAvailableMinFrameDurations((long[])value);
  }
  return false;
}",0.6445916114790287
199428,"@SmallTest public void testReadWriteOverride(){
  int[] availableFormats=new int[]{0x20,0x32315659,0x11,0x100,0x22,0x23};
  int[] expectedIntValues=new int[]{0x20,0x32315659,0x11,0x21,0x22,0x23};
  int availableFormatTag=CameraMetadataNative.getTag(""String_Node_Str"");
  mMetadata.set(CameraCharacteristics.SCALER_AVAILABLE_FORMATS,availableFormats);
  byte[] availableFormatValues=mMetadata.readValues(availableFormatTag);
  ByteBuffer bf=ByteBuffer.wrap(availableFormatValues).order(ByteOrder.nativeOrder());
  assertEquals(expectedIntValues.length * 4,availableFormatValues.length);
  for (int i=0; i < expectedIntValues.length; ++i) {
    assertEquals(expectedIntValues[i],bf.getInt());
  }
  byte[] availableFormatsAsByteArray=new byte[expectedIntValues.length * 4];
  ByteBuffer availableFormatsByteBuffer=ByteBuffer.wrap(availableFormatsAsByteArray).order(ByteOrder.nativeOrder());
  for (  int value : expectedIntValues) {
    availableFormatsByteBuffer.putInt(value);
  }
  mMetadata.writeValues(availableFormatTag,availableFormatsAsByteArray);
  int[] resultFormats=mMetadata.get(CameraCharacteristics.SCALER_AVAILABLE_FORMATS);
  assertNotNull(""String_Node_Str"",resultFormats);
  assertArrayEquals(availableFormats,resultFormats);
  int[] expectedFaceIds=new int[]{1,2,3,4,5};
  byte[] expectedFaceScores=new byte[]{10,20,30,40,50};
  int numFaces=expectedFaceIds.length;
  Rect[] expectedRects=new Rect[numFaces];
  for (int i=0; i < numFaces; i++) {
    expectedRects[i]=new Rect(i * 4 + 1,i * 4 + 2,i * 4 + 3,i * 4 + 4);
  }
  int[] expectedFaceLM=new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
  Point[] expectedFaceLMPoints=new Point[numFaces * 3];
  for (int i=0; i < numFaces; i++) {
    expectedFaceLMPoints[i * 3]=new Point(expectedFaceLM[i * 6],expectedFaceLM[i * 6 + 1]);
    expectedFaceLMPoints[i * 3 + 1]=new Point(expectedFaceLM[i * 6 + 2],expectedFaceLM[i * 6 + 3]);
    expectedFaceLMPoints[i * 3 + 2]=new Point(expectedFaceLM[i * 6 + 4],expectedFaceLM[i * 6 + 5]);
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL);
  mMetadata.set(CaptureResult.STATISTICS_FACE_IDS,expectedFaceIds);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  mMetadata.set(CaptureResult.STATISTICS_FACE_LANDMARKS,expectedFaceLM);
  Face[] resultFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(expectedFaceIds[i],resultFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultFaces[i].getScore());
    assertEquals(expectedRects[i],resultFaces[i].getBounds());
    assertEquals(expectedFaceLMPoints[i * 3],resultFaces[i].getLeftEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 1],resultFaces[i].getRightEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 2],resultFaces[i].getMouthPosition());
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  Face[] resultSimpleFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultSimpleFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(Face.ID_UNSUPPORTED,resultSimpleFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultSimpleFaces[i].getScore());
    assertEquals(expectedRects[i],resultSimpleFaces[i].getBounds());
    assertNull(resultSimpleFaces[i].getLeftEyePosition());
    assertNull(resultSimpleFaces[i].getRightEyePosition());
    assertNull(resultSimpleFaces[i].getMouthPosition());
  }
}","@SmallTest public void testReadWriteOverride(){
  int[] availableFormats=new int[]{0x20,0x32315659,0x11,0x100,0x22,0x23};
  int[] expectedIntValues=new int[]{0x20,0x32315659,0x11,0x21,0x22,0x23};
  int availableFormatTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<int[]> formatKey=CameraCharacteristics.SCALER_AVAILABLE_FORMATS;
  validateArrayMetadataReadWriteOverride(formatKey,availableFormats,expectedIntValues,availableFormatTag);
  final int OUTPUT=CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT;
  int[] availableStreamConfigs=new int[]{0x20,3280,2464,OUTPUT,0x23,3264,2448,OUTPUT,0x23,3200,2400,OUTPUT,0x100,3264,2448,OUTPUT,0x100,3200,2400,OUTPUT,0x100,2592,1944,OUTPUT,0x100,2048,1536,OUTPUT,0x100,1920,1080,OUTPUT};
  int[] expectedAvailableStreamConfigs=new int[]{0x20,3280,2464,OUTPUT,0x23,3264,2448,OUTPUT,0x23,3200,2400,OUTPUT,0x21,3264,2448,OUTPUT,0x21,3200,2400,OUTPUT,0x21,2592,1944,OUTPUT,0x21,2048,1536,OUTPUT,0x21,1920,1080,OUTPUT};
  int availableStreamConfigTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<int[]> configKey=CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS;
  validateArrayMetadataReadWriteOverride(configKey,availableStreamConfigs,expectedAvailableStreamConfigs,availableStreamConfigTag);
  long[] availableMinDurations=new long[]{0x20,3280,2464,33333336,0x23,3264,2448,33333336,0x23,3200,2400,33333336,0x100,3264,2448,33333336,0x100,3200,2400,33333336,0x100,2592,1944,33333336,0x100,2048,1536,33333336,0x100,1920,1080,33333336};
  long[] expectedAvailableMinDurations=new long[]{0x20,3280,2464,33333336,0x23,3264,2448,33333336,0x23,3200,2400,33333336,0x21,3264,2448,33333336,0x21,3200,2400,33333336,0x21,2592,1944,33333336,0x21,2048,1536,33333336,0x21,1920,1080,33333336};
  int availableMinDurationsTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<long[]> durationKey=CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS;
  validateArrayMetadataReadWriteOverride(durationKey,availableMinDurations,expectedAvailableMinDurations,availableMinDurationsTag);
  int[] expectedFaceIds=new int[]{1,2,3,4,5};
  byte[] expectedFaceScores=new byte[]{10,20,30,40,50};
  int numFaces=expectedFaceIds.length;
  Rect[] expectedRects=new Rect[numFaces];
  for (int i=0; i < numFaces; i++) {
    expectedRects[i]=new Rect(i * 4 + 1,i * 4 + 2,i * 4 + 3,i * 4 + 4);
  }
  int[] expectedFaceLM=new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
  Point[] expectedFaceLMPoints=new Point[numFaces * 3];
  for (int i=0; i < numFaces; i++) {
    expectedFaceLMPoints[i * 3]=new Point(expectedFaceLM[i * 6],expectedFaceLM[i * 6 + 1]);
    expectedFaceLMPoints[i * 3 + 1]=new Point(expectedFaceLM[i * 6 + 2],expectedFaceLM[i * 6 + 3]);
    expectedFaceLMPoints[i * 3 + 2]=new Point(expectedFaceLM[i * 6 + 4],expectedFaceLM[i * 6 + 5]);
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL);
  mMetadata.set(CaptureResult.STATISTICS_FACE_IDS,expectedFaceIds);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  mMetadata.set(CaptureResult.STATISTICS_FACE_LANDMARKS,expectedFaceLM);
  Face[] resultFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(expectedFaceIds[i],resultFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultFaces[i].getScore());
    assertEquals(expectedRects[i],resultFaces[i].getBounds());
    assertEquals(expectedFaceLMPoints[i * 3],resultFaces[i].getLeftEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 1],resultFaces[i].getRightEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 2],resultFaces[i].getMouthPosition());
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  Face[] resultSimpleFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultSimpleFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(Face.ID_UNSUPPORTED,resultSimpleFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultSimpleFaces[i].getScore());
    assertEquals(expectedRects[i],resultSimpleFaces[i].getBounds());
    assertNull(resultSimpleFaces[i].getLeftEyePosition());
    assertNull(resultSimpleFaces[i].getRightEyePosition());
    assertNull(resultSimpleFaces[i].getMouthPosition());
  }
}",0.7147887323943662
199429,"@SuppressWarnings(""String_Node_Str"") private <T>T getOverride(Key<T> key){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return (T)getAvailableFormats();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACES)) {
    return (T)getFaces();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return (T)getFaceRectangles();
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") private <T>T getOverride(Key<T> key){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return (T)getAvailableFormats();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACES)) {
    return (T)getFaces();
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return (T)getFaceRectangles();
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS)) {
    return (T)getAvailableStreamConfigurations();
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS)) {
    return (T)getAvailableMinFrameDurations();
  }
  return null;
}",0.7165575304022451
199430,"private <T>boolean setOverride(Key<T> key,T value){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return setAvailableFormats((int[])value);
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return setFaceRectangles((Rect[])value);
  }
  return false;
}","private <T>boolean setOverride(Key<T> key,T value){
  if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_FORMATS)) {
    return setAvailableFormats((int[])value);
  }
 else   if (key.equals(CaptureResult.STATISTICS_FACE_RECTANGLES)) {
    return setFaceRectangles((Rect[])value);
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS)) {
    return setAvailableStreamConfigurations((int[])value);
  }
 else   if (key.equals(CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS)) {
    return setAvailableMinFrameDurations((long[])value);
  }
  return false;
}",0.6445916114790287
199431,"@SmallTest public void testReadWriteOverride(){
  int[] availableFormats=new int[]{0x20,0x32315659,0x11,0x100,0x22,0x23};
  int[] expectedIntValues=new int[]{0x20,0x32315659,0x11,0x21,0x22,0x23};
  int availableFormatTag=CameraMetadataNative.getTag(""String_Node_Str"");
  mMetadata.set(CameraCharacteristics.SCALER_AVAILABLE_FORMATS,availableFormats);
  byte[] availableFormatValues=mMetadata.readValues(availableFormatTag);
  ByteBuffer bf=ByteBuffer.wrap(availableFormatValues).order(ByteOrder.nativeOrder());
  assertEquals(expectedIntValues.length * 4,availableFormatValues.length);
  for (int i=0; i < expectedIntValues.length; ++i) {
    assertEquals(expectedIntValues[i],bf.getInt());
  }
  byte[] availableFormatsAsByteArray=new byte[expectedIntValues.length * 4];
  ByteBuffer availableFormatsByteBuffer=ByteBuffer.wrap(availableFormatsAsByteArray).order(ByteOrder.nativeOrder());
  for (  int value : expectedIntValues) {
    availableFormatsByteBuffer.putInt(value);
  }
  mMetadata.writeValues(availableFormatTag,availableFormatsAsByteArray);
  int[] resultFormats=mMetadata.get(CameraCharacteristics.SCALER_AVAILABLE_FORMATS);
  assertNotNull(""String_Node_Str"",resultFormats);
  assertArrayEquals(availableFormats,resultFormats);
  int[] expectedFaceIds=new int[]{1,2,3,4,5};
  byte[] expectedFaceScores=new byte[]{10,20,30,40,50};
  int numFaces=expectedFaceIds.length;
  Rect[] expectedRects=new Rect[numFaces];
  for (int i=0; i < numFaces; i++) {
    expectedRects[i]=new Rect(i * 4 + 1,i * 4 + 2,i * 4 + 3,i * 4 + 4);
  }
  int[] expectedFaceLM=new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
  Point[] expectedFaceLMPoints=new Point[numFaces * 3];
  for (int i=0; i < numFaces; i++) {
    expectedFaceLMPoints[i * 3]=new Point(expectedFaceLM[i * 6],expectedFaceLM[i * 6 + 1]);
    expectedFaceLMPoints[i * 3 + 1]=new Point(expectedFaceLM[i * 6 + 2],expectedFaceLM[i * 6 + 3]);
    expectedFaceLMPoints[i * 3 + 2]=new Point(expectedFaceLM[i * 6 + 4],expectedFaceLM[i * 6 + 5]);
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL);
  mMetadata.set(CaptureResult.STATISTICS_FACE_IDS,expectedFaceIds);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  mMetadata.set(CaptureResult.STATISTICS_FACE_LANDMARKS,expectedFaceLM);
  Face[] resultFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(expectedFaceIds[i],resultFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultFaces[i].getScore());
    assertEquals(expectedRects[i],resultFaces[i].getBounds());
    assertEquals(expectedFaceLMPoints[i * 3],resultFaces[i].getLeftEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 1],resultFaces[i].getRightEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 2],resultFaces[i].getMouthPosition());
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  Face[] resultSimpleFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultSimpleFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(Face.ID_UNSUPPORTED,resultSimpleFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultSimpleFaces[i].getScore());
    assertEquals(expectedRects[i],resultSimpleFaces[i].getBounds());
    assertNull(resultSimpleFaces[i].getLeftEyePosition());
    assertNull(resultSimpleFaces[i].getRightEyePosition());
    assertNull(resultSimpleFaces[i].getMouthPosition());
  }
}","@SmallTest public void testReadWriteOverride(){
  int[] availableFormats=new int[]{0x20,0x32315659,0x11,0x100,0x22,0x23};
  int[] expectedIntValues=new int[]{0x20,0x32315659,0x11,0x21,0x22,0x23};
  int availableFormatTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<int[]> formatKey=CameraCharacteristics.SCALER_AVAILABLE_FORMATS;
  validateArrayMetadataReadWriteOverride(formatKey,availableFormats,expectedIntValues,availableFormatTag);
  final int OUTPUT=CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT;
  int[] availableStreamConfigs=new int[]{0x20,3280,2464,OUTPUT,0x23,3264,2448,OUTPUT,0x23,3200,2400,OUTPUT,0x100,3264,2448,OUTPUT,0x100,3200,2400,OUTPUT,0x100,2592,1944,OUTPUT,0x100,2048,1536,OUTPUT,0x100,1920,1080,OUTPUT};
  int[] expectedAvailableStreamConfigs=new int[]{0x20,3280,2464,OUTPUT,0x23,3264,2448,OUTPUT,0x23,3200,2400,OUTPUT,0x21,3264,2448,OUTPUT,0x21,3200,2400,OUTPUT,0x21,2592,1944,OUTPUT,0x21,2048,1536,OUTPUT,0x21,1920,1080,OUTPUT};
  int availableStreamConfigTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<int[]> configKey=CameraCharacteristics.SCALER_AVAILABLE_STREAM_CONFIGURATIONS;
  validateArrayMetadataReadWriteOverride(configKey,availableStreamConfigs,expectedAvailableStreamConfigs,availableStreamConfigTag);
  long[] availableMinDurations=new long[]{0x20,3280,2464,33333336,0x23,3264,2448,33333336,0x23,3200,2400,33333336,0x100,3264,2448,33333336,0x100,3200,2400,33333336,0x100,2592,1944,33333336,0x100,2048,1536,33333336,0x100,1920,1080,33333336};
  long[] expectedAvailableMinDurations=new long[]{0x20,3280,2464,33333336,0x23,3264,2448,33333336,0x23,3200,2400,33333336,0x21,3264,2448,33333336,0x21,3200,2400,33333336,0x21,2592,1944,33333336,0x21,2048,1536,33333336,0x21,1920,1080,33333336};
  int availableMinDurationsTag=CameraMetadataNative.getTag(""String_Node_Str"");
  Key<long[]> durationKey=CameraCharacteristics.SCALER_AVAILABLE_MIN_FRAME_DURATIONS;
  validateArrayMetadataReadWriteOverride(durationKey,availableMinDurations,expectedAvailableMinDurations,availableMinDurationsTag);
  int[] expectedFaceIds=new int[]{1,2,3,4,5};
  byte[] expectedFaceScores=new byte[]{10,20,30,40,50};
  int numFaces=expectedFaceIds.length;
  Rect[] expectedRects=new Rect[numFaces];
  for (int i=0; i < numFaces; i++) {
    expectedRects[i]=new Rect(i * 4 + 1,i * 4 + 2,i * 4 + 3,i * 4 + 4);
  }
  int[] expectedFaceLM=new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30};
  Point[] expectedFaceLMPoints=new Point[numFaces * 3];
  for (int i=0; i < numFaces; i++) {
    expectedFaceLMPoints[i * 3]=new Point(expectedFaceLM[i * 6],expectedFaceLM[i * 6 + 1]);
    expectedFaceLMPoints[i * 3 + 1]=new Point(expectedFaceLM[i * 6 + 2],expectedFaceLM[i * 6 + 3]);
    expectedFaceLMPoints[i * 3 + 2]=new Point(expectedFaceLM[i * 6 + 4],expectedFaceLM[i * 6 + 5]);
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL);
  mMetadata.set(CaptureResult.STATISTICS_FACE_IDS,expectedFaceIds);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  mMetadata.set(CaptureResult.STATISTICS_FACE_LANDMARKS,expectedFaceLM);
  Face[] resultFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(expectedFaceIds[i],resultFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultFaces[i].getScore());
    assertEquals(expectedRects[i],resultFaces[i].getBounds());
    assertEquals(expectedFaceLMPoints[i * 3],resultFaces[i].getLeftEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 1],resultFaces[i].getRightEyePosition());
    assertEquals(expectedFaceLMPoints[i * 3 + 2],resultFaces[i].getMouthPosition());
  }
  mMetadata.set(CaptureResult.STATISTICS_FACE_DETECT_MODE,CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE);
  mMetadata.set(CaptureResult.STATISTICS_FACE_SCORES,expectedFaceScores);
  mMetadata.set(CaptureResult.STATISTICS_FACE_RECTANGLES,expectedRects);
  Face[] resultSimpleFaces=mMetadata.get(CaptureResult.STATISTICS_FACES);
  assertEquals(numFaces,resultSimpleFaces.length);
  for (int i=0; i < numFaces; i++) {
    assertEquals(Face.ID_UNSUPPORTED,resultSimpleFaces[i].getId());
    assertEquals(expectedFaceScores[i],resultSimpleFaces[i].getScore());
    assertEquals(expectedRects[i],resultSimpleFaces[i].getBounds());
    assertNull(resultSimpleFaces[i].getLeftEyePosition());
    assertNull(resultSimpleFaces[i].getRightEyePosition());
    assertNull(resultSimpleFaces[i].getMouthPosition());
  }
}",0.7147887323943662
199432,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationDpsMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}",0.5089058524173028
199433,"public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(Math.abs(distancePx) / config.animationDpsMovementPerSecond) * 1000);
}","public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(1000f * (Math.abs(distancePx) / config.animationPxMovementPerSecond)));
}",0.7566539923954373
199434,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationDpsMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}",0.5089058524173028
199435,"public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(Math.abs(distancePx) / config.animationDpsMovementPerSecond) * 1000);
}","public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(1000f * (Math.abs(distancePx) / config.animationPxMovementPerSecond)));
}",0.7566539923954373
199436,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationDpsMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}",0.5089058524173028
199437,"public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(Math.abs(distancePx) / config.animationDpsMovementPerSecond) * 1000);
}","public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(1000f * (Math.abs(distancePx) / config.animationPxMovementPerSecond)));
}",0.7566539923954373
199438,"/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationDpsMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}","/** 
 * Updates the state, given the specified context 
 */
void update(Context context){
  Resources res=context.getResources();
  DisplayMetrics dm=res.getDisplayMetrics();
  mDisplayMetrics=dm;
  displayRect.set(0,0,dm.widthPixels,dm.heightPixels);
  animationPxMovementPerSecond=res.getDimensionPixelSize(R.dimen.recents_animation_movement_in_dps_per_second);
  filteringCurrentViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_current_views_min_duration);
  filteringNewViewsMinAnimDuration=res.getInteger(R.integer.recents_filter_animate_new_views_min_duration);
}",0.5089058524173028
199439,"public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(Math.abs(distancePx) / config.animationDpsMovementPerSecond) * 1000);
}","public static int calculateTranslationAnimationDuration(int distancePx,int minDuration){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  return Math.max(minDuration,(int)(1000f * (Math.abs(distancePx) / config.animationPxMovementPerSecond)));
}",0.7566539923954373
199440,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199441,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199442,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199443,"public boolean isCurrentProfile(int userId){
synchronized (this) {
    for (int i=0; i < mCurrentProfileIds.length; i++) {
      if (userId == mCurrentProfileIds[i])       return true;
    }
    return false;
  }
}","public boolean isCurrentProfile(int userId){
synchronized (this) {
    if (userId == mCurrentUserId)     return true;
    for (int i=0; i < mCurrentProfileIds.length; i++) {
      if (userId == mCurrentProfileIds[i])       return true;
    }
    return false;
  }
}",0.8935281837160751
199444,"/** 
 * Checks whether the userid is a profile of the current user.
 */
private boolean isCurrentProfileLocked(int userId){
  for (int i=0; i < mService.mCurrentProfileIds.length; i++) {
    if (mService.mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}","/** 
 * Checks whether the userid is a profile of the current user.
 */
private boolean isCurrentProfileLocked(int userId){
  if (userId == mCurrentUser)   return true;
  for (int i=0; i < mService.mCurrentProfileIds.length; i++) {
    if (mService.mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}",0.9243697478991596
199445,"boolean isCurrentProfileLocked(int userId){
  for (int i=0; i < mCurrentProfileIds.length; i++) {
    if (mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}","boolean isCurrentProfileLocked(int userId){
  if (userId == mCurrentUserId)   return true;
  for (int i=0; i < mCurrentProfileIds.length; i++) {
    if (mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}",0.8827930174563591
199446,"public boolean isCurrentProfile(int userId){
synchronized (this) {
    for (int i=0; i < mCurrentProfileIds.length; i++) {
      if (userId == mCurrentProfileIds[i])       return true;
    }
    return false;
  }
}","public boolean isCurrentProfile(int userId){
synchronized (this) {
    if (userId == mCurrentUserId)     return true;
    for (int i=0; i < mCurrentProfileIds.length; i++) {
      if (userId == mCurrentProfileIds[i])       return true;
    }
    return false;
  }
}",0.8935281837160751
199447,"/** 
 * Checks whether the userid is a profile of the current user.
 */
private boolean isCurrentProfileLocked(int userId){
  for (int i=0; i < mService.mCurrentProfileIds.length; i++) {
    if (mService.mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}","/** 
 * Checks whether the userid is a profile of the current user.
 */
private boolean isCurrentProfileLocked(int userId){
  if (userId == mCurrentUser)   return true;
  for (int i=0; i < mService.mCurrentProfileIds.length; i++) {
    if (mService.mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}",0.9243697478991596
199448,"boolean isCurrentProfileLocked(int userId){
  for (int i=0; i < mCurrentProfileIds.length; i++) {
    if (mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}","boolean isCurrentProfileLocked(int userId){
  if (userId == mCurrentUserId)   return true;
  for (int i=0; i < mCurrentProfileIds.length; i++) {
    if (mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}",0.8827930174563591
199449,"public boolean isCurrentProfile(int userId){
synchronized (this) {
    for (int i=0; i < mCurrentProfileIds.length; i++) {
      if (userId == mCurrentProfileIds[i])       return true;
    }
    return false;
  }
}","public boolean isCurrentProfile(int userId){
synchronized (this) {
    if (userId == mCurrentUserId)     return true;
    for (int i=0; i < mCurrentProfileIds.length; i++) {
      if (userId == mCurrentProfileIds[i])       return true;
    }
    return false;
  }
}",0.8935281837160751
199450,"/** 
 * Checks whether the userid is a profile of the current user.
 */
private boolean isCurrentProfileLocked(int userId){
  for (int i=0; i < mService.mCurrentProfileIds.length; i++) {
    if (mService.mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}","/** 
 * Checks whether the userid is a profile of the current user.
 */
private boolean isCurrentProfileLocked(int userId){
  if (userId == mCurrentUser)   return true;
  for (int i=0; i < mService.mCurrentProfileIds.length; i++) {
    if (mService.mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}",0.9243697478991596
199451,"boolean isCurrentProfileLocked(int userId){
  for (int i=0; i < mCurrentProfileIds.length; i++) {
    if (mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}","boolean isCurrentProfileLocked(int userId){
  if (userId == mCurrentUserId)   return true;
  for (int i=0; i < mCurrentProfileIds.length; i++) {
    if (mCurrentProfileIds[i] == userId)     return true;
  }
  return false;
}",0.8827930174563591
199452,"public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  mPathPaint.setColor(Color.WHITE);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}","public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  int defaultColor=Color.WHITE;
  TypedValue outValue=new TypedValue();
  if (context.getTheme().resolveAttribute(android.R.attr.textColorPrimary,outValue,true)) {
    defaultColor=context.getResources().getColor(outValue.resourceId);
  }
  final int color=a.getColor(R.styleable.LockPatternView_pathColor,defaultColor);
  mPathPaint.setColor(color);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}",0.9035588155392557
199453,"private void waitUntilIdle() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    try {
      mRemoteDevice.waitUntilIdle();
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
    mRepeatingRequestId=REQUEST_ID_NONE;
    mRepeatingRequestIdDeletedList.clear();
    mCaptureListenerMap.clear();
  }
}","private void waitUntilIdle() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    try {
      mRemoteDevice.waitUntilIdle();
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
    mRepeatingRequestId=REQUEST_ID_NONE;
  }
}",0.9146968139773896
199454,"@Override public void stopRepeating() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      int requestId=mRepeatingRequestId;
      mRepeatingRequestId=REQUEST_ID_NONE;
      mRepeatingRequestIdDeletedList.add(requestId);
      try {
        mRemoteDevice.cancelRequest(requestId);
      }
 catch (      CameraRuntimeException e) {
        throw e.asChecked();
      }
catch (      RemoteException e) {
        return;
      }
    }
  }
}","@Override public void stopRepeating() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      int requestId=mRepeatingRequestId;
      mRepeatingRequestId=REQUEST_ID_NONE;
      if (mCaptureListenerMap.get(requestId) != null) {
        mRepeatingRequestIdDeletedList.add(requestId);
      }
      try {
        mRemoteDevice.cancelRequest(requestId);
      }
 catch (      CameraRuntimeException e) {
        throw e.asChecked();
      }
catch (      RemoteException e) {
        return;
      }
    }
  }
}",0.9243243243243244
199455,"private void waitUntilIdle() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    try {
      mRemoteDevice.waitUntilIdle();
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
    mRepeatingRequestId=REQUEST_ID_NONE;
    mRepeatingRequestIdDeletedList.clear();
    mCaptureListenerMap.clear();
  }
}","private void waitUntilIdle() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    try {
      mRemoteDevice.waitUntilIdle();
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
    mRepeatingRequestId=REQUEST_ID_NONE;
  }
}",0.9146968139773896
199456,"@Override public void stopRepeating() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      int requestId=mRepeatingRequestId;
      mRepeatingRequestId=REQUEST_ID_NONE;
      mRepeatingRequestIdDeletedList.add(requestId);
      try {
        mRemoteDevice.cancelRequest(requestId);
      }
 catch (      CameraRuntimeException e) {
        throw e.asChecked();
      }
catch (      RemoteException e) {
        return;
      }
    }
  }
}","@Override public void stopRepeating() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      int requestId=mRepeatingRequestId;
      mRepeatingRequestId=REQUEST_ID_NONE;
      if (mCaptureListenerMap.get(requestId) != null) {
        mRepeatingRequestIdDeletedList.add(requestId);
      }
      try {
        mRemoteDevice.cancelRequest(requestId);
      }
 catch (      CameraRuntimeException e) {
        throw e.asChecked();
      }
catch (      RemoteException e) {
        return;
      }
    }
  }
}",0.9243243243243244
199457,"public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  mPathPaint.setColor(Color.WHITE);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}","public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  int defaultColor=Color.WHITE;
  TypedValue outValue=new TypedValue();
  if (context.getTheme().resolveAttribute(android.R.attr.textColorPrimary,outValue,true)) {
    defaultColor=context.getResources().getColor(outValue.resourceId);
  }
  final int color=a.getColor(R.styleable.LockPatternView_pathColor,defaultColor);
  mPathPaint.setColor(color);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}",0.9035588155392557
199458,"private void waitUntilIdle() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    try {
      mRemoteDevice.waitUntilIdle();
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
    mRepeatingRequestId=REQUEST_ID_NONE;
    mRepeatingRequestIdDeletedList.clear();
    mCaptureListenerMap.clear();
  }
}","private void waitUntilIdle() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    try {
      mRemoteDevice.waitUntilIdle();
    }
 catch (    CameraRuntimeException e) {
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
    mRepeatingRequestId=REQUEST_ID_NONE;
  }
}",0.9146968139773896
199459,"@Override public void stopRepeating() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      int requestId=mRepeatingRequestId;
      mRepeatingRequestId=REQUEST_ID_NONE;
      mRepeatingRequestIdDeletedList.add(requestId);
      try {
        mRemoteDevice.cancelRequest(requestId);
      }
 catch (      CameraRuntimeException e) {
        throw e.asChecked();
      }
catch (      RemoteException e) {
        return;
      }
    }
  }
}","@Override public void stopRepeating() throws CameraAccessException {
synchronized (mLock) {
    checkIfCameraClosed();
    if (mRepeatingRequestId != REQUEST_ID_NONE) {
      int requestId=mRepeatingRequestId;
      mRepeatingRequestId=REQUEST_ID_NONE;
      if (mCaptureListenerMap.get(requestId) != null) {
        mRepeatingRequestIdDeletedList.add(requestId);
      }
      try {
        mRemoteDevice.cancelRequest(requestId);
      }
 catch (      CameraRuntimeException e) {
        throw e.asChecked();
      }
catch (      RemoteException e) {
        return;
      }
    }
  }
}",0.9243243243243244
199460,"public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  mPathPaint.setColor(Color.WHITE);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}","public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  int defaultColor=Color.WHITE;
  TypedValue outValue=new TypedValue();
  if (context.getTheme().resolveAttribute(android.R.attr.textColorPrimary,outValue,true)) {
    defaultColor=context.getResources().getColor(outValue.resourceId);
  }
  final int color=a.getColor(R.styleable.LockPatternView_pathColor,defaultColor);
  mPathPaint.setColor(color);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}",0.9035588155392557
199461,"public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  mPathPaint.setColor(Color.WHITE);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}","public LockPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.LockPatternView);
  final String aspect=a.getString(R.styleable.LockPatternView_aspect);
  if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_SQUARE;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_WIDTH;
  }
 else   if (""String_Node_Str"".equals(aspect)) {
    mAspect=ASPECT_LOCK_HEIGHT;
  }
 else {
    mAspect=ASPECT_SQUARE;
  }
  setClickable(true);
  mPathPaint.setAntiAlias(true);
  mPathPaint.setDither(true);
  int defaultColor=Color.WHITE;
  TypedValue outValue=new TypedValue();
  if (context.getTheme().resolveAttribute(android.R.attr.textColorPrimary,outValue,true)) {
    defaultColor=context.getResources().getColor(outValue.resourceId);
  }
  final int color=a.getColor(R.styleable.LockPatternView_pathColor,defaultColor);
  mPathPaint.setColor(color);
  mPathPaint.setAlpha(mStrokeAlpha);
  mPathPaint.setStyle(Paint.Style.STROKE);
  mPathPaint.setStrokeJoin(Paint.Join.ROUND);
  mPathPaint.setStrokeCap(Paint.Cap.ROUND);
  mBitmapBtnDefault=getBitmapFor(R.drawable.btn_code_lock_default_holo);
  mBitmapBtnTouched=getBitmapFor(R.drawable.btn_code_lock_touched_holo);
  mBitmapCircleDefault=getBitmapFor(R.drawable.indicator_code_lock_point_area_default_holo);
  mBitmapCircleGreen=getBitmapFor(R.drawable.indicator_code_lock_point_area_green_holo);
  mBitmapCircleRed=getBitmapFor(R.drawable.indicator_code_lock_point_area_red_holo);
  mBitmapArrowGreenUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_green_up);
  mBitmapArrowRedUp=getBitmapFor(R.drawable.indicator_code_lock_drag_direction_red_up);
  final Bitmap bitmaps[]={mBitmapBtnDefault,mBitmapBtnTouched,mBitmapCircleDefault,mBitmapCircleGreen,mBitmapCircleRed};
  for (  Bitmap bitmap : bitmaps) {
    mBitmapWidth=Math.max(mBitmapWidth,bitmap.getWidth());
    mBitmapHeight=Math.max(mBitmapHeight,bitmap.getHeight());
  }
}",0.9035588155392557
199462,"/** 
 * @deprecated in API 16Bind an os surface
 * @param w
 * @param h
 * @param sur
 */
public void setSurfaceTexture(SurfaceTexture sur,int w,int h){
  validate();
  mWidth=w;
  mHeight=h;
  nContextSetSurfaceTexture(w,h,sur);
}","/** 
 * @deprecated in API 16Bind an os surface
 * @param w
 * @param h
 * @param sur
 */
public void setSurfaceTexture(SurfaceTexture sur,int w,int h){
  validate();
  Surface s=null;
  if (sur != null) {
    s=new Surface(sur);
  }
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,s);
}",0.8307692307692308
199463,"/** 
 * @deprecated in API 16Bind an os surface
 * @param w
 * @param h
 * @param sur
 */
public void setSurfaceTexture(SurfaceTexture sur,int w,int h){
  validate();
  mWidth=w;
  mHeight=h;
  nContextSetSurfaceTexture(w,h,sur);
}","/** 
 * @deprecated in API 16Bind an os surface
 * @param w
 * @param h
 * @param sur
 */
public void setSurfaceTexture(SurfaceTexture sur,int w,int h){
  validate();
  Surface s=null;
  if (sur != null) {
    s=new Surface(sur);
  }
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,s);
}",0.8307692307692308
199464,"/** 
 * @deprecated in API 16Bind an os surface
 * @param w
 * @param h
 * @param sur
 */
public void setSurfaceTexture(SurfaceTexture sur,int w,int h){
  validate();
  mWidth=w;
  mHeight=h;
  nContextSetSurfaceTexture(w,h,sur);
}","/** 
 * @deprecated in API 16Bind an os surface
 * @param w
 * @param h
 * @param sur
 */
public void setSurfaceTexture(SurfaceTexture sur,int w,int h){
  validate();
  Surface s=null;
  if (sur != null) {
    s=new Surface(sur);
  }
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,s);
}",0.8307692307692308
199465,"/** 
 * @param context everything needs a context :(
 */
public GlobalActions(Context context,WindowManagerFuncs windowManagerFuncs){
  mContext=context;
  mWindowManagerFuncs=windowManagerFuncs;
  mAudioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  mDreamManager=IDreamManager.Stub.asInterface(ServiceManager.getService(DreamService.DREAM_SERVICE));
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  context.registerReceiver(mBroadcastReceiver,filter);
  TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_SERVICE_STATE);
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mHasTelephony=cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
  mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),true,mAirplaneModeObserver);
  Vibrator vibrator=(Vibrator)mContext.getSystemService(Context.VIBRATOR_SERVICE);
  mHasVibrator=vibrator != null && vibrator.hasVibrator();
  mShowSilentToggle=SHOW_SILENT_TOGGLE && !mContext.getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume);
}","/** 
 * @param context everything needs a context :(
 */
public GlobalActions(Context context,WindowManagerFuncs windowManagerFuncs){
  mContext=context;
  mWindowManagerFuncs=windowManagerFuncs;
  mAudioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  mDreamManager=IDreamManager.Stub.asInterface(ServiceManager.getService(DreamService.DREAM_SERVICE));
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  context.registerReceiver(mBroadcastReceiver,filter);
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mHasTelephony=cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
  TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_SERVICE_STATE);
  mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),true,mAirplaneModeObserver);
  Vibrator vibrator=(Vibrator)mContext.getSystemService(Context.VIBRATOR_SERVICE);
  mHasVibrator=vibrator != null && vibrator.hasVibrator();
  mShowSilentToggle=SHOW_SILENT_TOGGLE && !mContext.getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume);
}",0.8793342579750347
199466,"/** 
 * @param context everything needs a context :(
 */
public GlobalActions(Context context,WindowManagerFuncs windowManagerFuncs){
  mContext=context;
  mWindowManagerFuncs=windowManagerFuncs;
  mAudioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  mDreamManager=IDreamManager.Stub.asInterface(ServiceManager.getService(DreamService.DREAM_SERVICE));
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  context.registerReceiver(mBroadcastReceiver,filter);
  TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_SERVICE_STATE);
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mHasTelephony=cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
  mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),true,mAirplaneModeObserver);
  Vibrator vibrator=(Vibrator)mContext.getSystemService(Context.VIBRATOR_SERVICE);
  mHasVibrator=vibrator != null && vibrator.hasVibrator();
  mShowSilentToggle=SHOW_SILENT_TOGGLE && !mContext.getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume);
}","/** 
 * @param context everything needs a context :(
 */
public GlobalActions(Context context,WindowManagerFuncs windowManagerFuncs){
  mContext=context;
  mWindowManagerFuncs=windowManagerFuncs;
  mAudioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  mDreamManager=IDreamManager.Stub.asInterface(ServiceManager.getService(DreamService.DREAM_SERVICE));
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  context.registerReceiver(mBroadcastReceiver,filter);
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mHasTelephony=cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
  TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_SERVICE_STATE);
  mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),true,mAirplaneModeObserver);
  Vibrator vibrator=(Vibrator)mContext.getSystemService(Context.VIBRATOR_SERVICE);
  mHasVibrator=vibrator != null && vibrator.hasVibrator();
  mShowSilentToggle=SHOW_SILENT_TOGGLE && !mContext.getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume);
}",0.8793342579750347
199467,"/** 
 * @param context everything needs a context :(
 */
public GlobalActions(Context context,WindowManagerFuncs windowManagerFuncs){
  mContext=context;
  mWindowManagerFuncs=windowManagerFuncs;
  mAudioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  mDreamManager=IDreamManager.Stub.asInterface(ServiceManager.getService(DreamService.DREAM_SERVICE));
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  context.registerReceiver(mBroadcastReceiver,filter);
  TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_SERVICE_STATE);
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mHasTelephony=cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
  mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),true,mAirplaneModeObserver);
  Vibrator vibrator=(Vibrator)mContext.getSystemService(Context.VIBRATOR_SERVICE);
  mHasVibrator=vibrator != null && vibrator.hasVibrator();
  mShowSilentToggle=SHOW_SILENT_TOGGLE && !mContext.getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume);
}","/** 
 * @param context everything needs a context :(
 */
public GlobalActions(Context context,WindowManagerFuncs windowManagerFuncs){
  mContext=context;
  mWindowManagerFuncs=windowManagerFuncs;
  mAudioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  mDreamManager=IDreamManager.Stub.asInterface(ServiceManager.getService(DreamService.DREAM_SERVICE));
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
  context.registerReceiver(mBroadcastReceiver,filter);
  ConnectivityManager cm=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mHasTelephony=cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);
  TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_SERVICE_STATE);
  mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON),true,mAirplaneModeObserver);
  Vibrator vibrator=(Vibrator)mContext.getSystemService(Context.VIBRATOR_SERVICE);
  mHasVibrator=vibrator != null && vibrator.hasVibrator();
  mShowSilentToggle=SHOW_SILENT_TOGGLE && !mContext.getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume);
}",0.8793342579750347
199468,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mPausingActivity == r) {
    mPausingActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}",0.979011509817197
199469,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mPausingActivity == r) {
    mPausingActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}",0.979011509817197
199470,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mPausingActivity == r) {
    mPausingActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}",0.979011509817197
199471,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,byte[] c,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,c,paint_instance_or_null,destDensity,srcDensity);
}",0.9517241379310344
199472,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisableNotificationAlerts=true;
  }
  updateZenMode();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  filter.addAction(Intent.ACTION_USER_ADDED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisableNotificationAlerts=true;
  }
  updateZenMode();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  filter.addAction(Intent.ACTION_USER_ADDED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9954324443789596
199473,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199474,"/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,(t.id > -1),t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}",0.997226715969494
199475,"public Task(int id,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
}","public Task(int id,boolean isActive,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
  this.isActive=isActive;
}",0.9016018306636157
199476,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  try {
    if (opts != null) {
      getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
    }
 else {
      getContext().startActivityAsUser(i,UserHandle.CURRENT);
    }
  }
 catch (  ActivityNotFoundException anfe) {
    Console.logError(getContext(),""String_Node_Str"");
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  if (task.isActive) {
    ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
    if (opts != null) {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
    }
 else {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
    }
  }
 else {
    Intent i=new Intent(task.key.intent);
    i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
 catch (    ActivityNotFoundException anfe) {
      Console.logError(getContext(),""String_Node_Str"");
    }
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.8975559022360895
199477,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        if (opts != null) {
          getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
        }
 else {
          getContext().startActivityAsUser(i,UserHandle.CURRENT);
        }
      }
 catch (      ActivityNotFoundException anfe) {
        Console.logError(getContext(),""String_Node_Str"");
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      if (task.isActive) {
        ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        if (opts != null) {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
        }
 else {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
        }
      }
 else {
        Intent i=new Intent(task.key.intent);
        i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          if (opts != null) {
            getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
          }
 else {
            getContext().startActivityAsUser(i,UserHandle.CURRENT);
          }
        }
 catch (        ActivityNotFoundException anfe) {
          Console.logError(getContext(),""String_Node_Str"");
        }
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9203703703703704
199478,"/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}","/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}",0.9083503054989815
199479,"@Override public void sessionCreated(IInputMethodSession session){
  mParentIMMS.onSessionCreated(mMethod,session,mChannel);
}","@Override public void sessionCreated(IInputMethodSession session){
  long ident=Binder.clearCallingIdentity();
  try {
    mParentIMMS.onSessionCreated(mMethod,session,mChannel);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.6847826086956522
199480,"/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
 else {
    if (mPaused) {
      if (mPauseTime < 0) {
        mPauseTime=currentTime;
      }
      return false;
    }
 else     if (mResumed) {
      mResumed=false;
      if (mPauseTime > 0) {
        mDelayStartTime+=(currentTime - mPauseTime);
      }
    }
    long deltaTime=currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
      mStartTime=currentTime - (deltaTime - mStartDelay);
      mPlayingState=RUNNING;
      return true;
    }
  }
  return false;
}","/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
  if (mPaused) {
    if (mPauseTime < 0) {
      mPauseTime=currentTime;
    }
    return false;
  }
 else   if (mResumed) {
    mResumed=false;
    if (mPauseTime > 0) {
      mDelayStartTime+=(currentTime - mPauseTime);
    }
  }
  long deltaTime=currentTime - mDelayStartTime;
  if (deltaTime > mStartDelay) {
    mStartTime=currentTime - (deltaTime - mStartDelay);
    mPlayingState=RUNNING;
    return true;
  }
  return false;
}",0.9554973821989527
199481,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisableNotificationAlerts=true;
  }
  updateZenMode();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  filter.addAction(Intent.ACTION_USER_ADDED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisableNotificationAlerts=true;
  }
  updateZenMode();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  filter.addAction(Intent.ACTION_USER_ADDED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9954324443789596
199482,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199483,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisableNotificationAlerts=true;
  }
  updateZenMode();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  filter.addAction(Intent.ACTION_USER_ADDED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisableNotificationAlerts=true;
  }
  updateZenMode();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  filter.addAction(Intent.ACTION_USER_ADDED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9954324443789596
199484,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199485,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9953930747510774
199486,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199487,"void systemReady(){
  final Context context=ActivityThread.systemMain().getSystemContext();
  mUserPackageMonitor.register(context,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}","void systemReady(){
  mUserPackageMonitor.register(mContext,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}",0.7734138972809668
199488,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9953930747510774
199489,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199490,"void systemReady(){
  final Context context=ActivityThread.systemMain().getSystemContext();
  mUserPackageMonitor.register(context,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}","void systemReady(){
  mUserPackageMonitor.register(mContext,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}",0.7734138972809668
199491,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9953930747510774
199492,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199493,"void systemReady(){
  final Context context=ActivityThread.systemMain().getSystemContext();
  mUserPackageMonitor.register(context,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}","void systemReady(){
  mUserPackageMonitor.register(mContext,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}",0.7734138972809668
199494,"protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(mCropView.getWidth(),cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(mCropView.getHeight(),cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Point inSize=mCropView.getSourceDimensions();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}","protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  Point inSize=mCropView.getSourceDimensions();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(inSize.x,cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(inSize.y,cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}",0.934483391447972
199495,"/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,(t.id > -1),t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}",0.997226715969494
199496,"public Task(int id,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
}","public Task(int id,boolean isActive,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
  this.isActive=isActive;
}",0.9016018306636157
199497,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  try {
    if (opts != null) {
      getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
    }
 else {
      getContext().startActivityAsUser(i,UserHandle.CURRENT);
    }
  }
 catch (  ActivityNotFoundException anfe) {
    Console.logError(getContext(),""String_Node_Str"");
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  if (task.isActive) {
    ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
    if (opts != null) {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
    }
 else {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
    }
  }
 else {
    Intent i=new Intent(task.key.intent);
    i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
 catch (    ActivityNotFoundException anfe) {
      Console.logError(getContext(),""String_Node_Str"");
    }
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.8975559022360895
199498,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        if (opts != null) {
          getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
        }
 else {
          getContext().startActivityAsUser(i,UserHandle.CURRENT);
        }
      }
 catch (      ActivityNotFoundException anfe) {
        Console.logError(getContext(),""String_Node_Str"");
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      if (task.isActive) {
        ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        if (opts != null) {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
        }
 else {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
        }
      }
 else {
        Intent i=new Intent(task.key.intent);
        i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          if (opts != null) {
            getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
          }
 else {
            getContext().startActivityAsUser(i,UserHandle.CURRENT);
          }
        }
 catch (        ActivityNotFoundException anfe) {
          Console.logError(getContext(),""String_Node_Str"");
        }
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9203703703703704
199499,"/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,(t.id > -1),t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}",0.997226715969494
199500,"public Task(int id,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
}","public Task(int id,boolean isActive,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
  this.isActive=isActive;
}",0.9016018306636157
199501,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  try {
    if (opts != null) {
      getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
    }
 else {
      getContext().startActivityAsUser(i,UserHandle.CURRENT);
    }
  }
 catch (  ActivityNotFoundException anfe) {
    Console.logError(getContext(),""String_Node_Str"");
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  if (task.isActive) {
    ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
    if (opts != null) {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
    }
 else {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
    }
  }
 else {
    Intent i=new Intent(task.key.intent);
    i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
 catch (    ActivityNotFoundException anfe) {
      Console.logError(getContext(),""String_Node_Str"");
    }
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.8975559022360895
199502,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        if (opts != null) {
          getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
        }
 else {
          getContext().startActivityAsUser(i,UserHandle.CURRENT);
        }
      }
 catch (      ActivityNotFoundException anfe) {
        Console.logError(getContext(),""String_Node_Str"");
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      if (task.isActive) {
        ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        if (opts != null) {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
        }
 else {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
        }
      }
 else {
        Intent i=new Intent(task.key.intent);
        i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          if (opts != null) {
            getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
          }
 else {
            getContext().startActivityAsUser(i,UserHandle.CURRENT);
          }
        }
 catch (        ActivityNotFoundException anfe) {
          Console.logError(getContext(),""String_Node_Str"");
        }
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9203703703703704
199503,"protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(mCropView.getWidth(),cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(mCropView.getHeight(),cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Point inSize=mCropView.getSourceDimensions();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}","protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  Point inSize=mCropView.getSourceDimensions();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(inSize.x,cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(inSize.y,cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}",0.934483391447972
199504,"protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(mCropView.getWidth(),cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(mCropView.getHeight(),cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Point inSize=mCropView.getSourceDimensions();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}","protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  Point inSize=mCropView.getSourceDimensions();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(inSize.x,cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(inSize.y,cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}",0.934483391447972
199505,"/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}","/** 
 * Reload the set of recent tasks 
 */
SpaceNode reload(Context context,int preloadCount){
  Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
  Resources res=context.getResources();
  ArrayList<Task> tasksToForceLoad=new ArrayList<Task>();
  TaskStack stack=new TaskStack(context);
  SpaceNode root=new SpaceNode(context);
  root.setStack(stack);
  try {
    long t1=System.currentTimeMillis();
    PackageManager pm=context.getPackageManager();
    ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
    List<ActivityManager.RecentTaskInfo> tasks=am.getRecentTasksForUser(25,ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_RELATED,UserHandle.CURRENT.getIdentifier());
    Collections.reverse(tasks);
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
    Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + tasks.size());
    Iterator<ActivityManager.RecentTaskInfo> iter=tasks.iterator();
    while (iter.hasNext()) {
      ActivityManager.RecentTaskInfo t=iter.next();
      if (am.isInHomeStack(t.persistentId)) {
        iter.remove();
        continue;
      }
      if (t.baseIntent.getComponent().getPackageName().equals(context.getPackageName())) {
        iter.remove();
        continue;
      }
    }
    t1=System.currentTimeMillis();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      ActivityManager.RecentTaskInfo t=tasks.get(i);
      ActivityInfo info=pm.getActivityInfo(t.baseIntent.getComponent(),PackageManager.GET_META_DATA);
      String title=info.loadLabel(pm).toString();
      boolean isForemostTask=(i == (taskCount - 1));
      if (i >= (taskCount - preloadCount)) {
        Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",""String_Node_Str"" + i + ""String_Node_Str""+ t.baseIntent.getComponent().getPackageName());
        String label=(t.activityLabel == null ? title : t.activityLabel.toString());
        BitmapDrawable bd=null;
        if (t.activityIcon != null) {
          bd=new BitmapDrawable(res,t.activityIcon);
        }
        Task task=new Task(t.persistentId,(t.id > -1),t.baseIntent,label,bd);
        if (task.icon != null) {
          mIconCache.put(task.key,task.icon);
        }
 else {
          if (!isForemostTask) {
            task.icon=mIconCache.get(task.key);
            if (task.icon != null) {
              tasksToForceLoad.add(task);
            }
          }
          if (task.icon == null) {
            task.icon=info.loadIcon(pm);
            if (task.icon != null) {
              mIconCache.put(task.key,task.icon);
            }
 else {
              task.icon=mDefaultIcon;
            }
          }
        }
        if (!isForemostTask) {
          task.thumbnail=mThumbnailCache.get(task.key);
          if (task.thumbnail != null) {
            tasksToForceLoad.add(task);
          }
        }
        if (task.thumbnail == null) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"");
          task.thumbnail=am.getTaskTopThumbnail(t.id);
          if (task.thumbnail != null) {
            mThumbnailCache.put(task.key,task.thumbnail);
          }
 else {
            task.thumbnail=mDefaultThumbnail;
          }
        }
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(task);
        }
      }
 else {
        for (int j=0; j < Constants.Values.RecentsTaskLoader.TaskEntryMultiplier; j++) {
          Console.log(Constants.DebugFlags.App.TaskDataLoader,""String_Node_Str"",t.baseIntent.getComponent().getPackageName());
          stack.addTask(new Task(t.persistentId,(t.id > -1),t.baseIntent,title,null,null));
        }
      }
    }
    Console.log(Constants.DebugFlags.App.TimeSystemCalls,""String_Node_Str"",""String_Node_Str"" + (System.currentTimeMillis() - t1) + ""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  mLoader.start(context);
  for (  Task t : tasksToForceLoad) {
    mLoadQueue.addTask(t,true);
  }
  return root;
}",0.997226715969494
199506,"public Task(int id,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
}","public Task(int id,boolean isActive,Intent intent,String activityTitle,Drawable icon,Bitmap thumbnail){
  this.key=new TaskKey(id,intent);
  this.title=activityTitle;
  this.icon=icon;
  this.thumbnail=thumbnail;
  this.isActive=isActive;
}",0.9016018306636157
199507,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  try {
    if (opts != null) {
      getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
    }
 else {
      getContext().startActivityAsUser(i,UserHandle.CURRENT);
    }
  }
 catch (  ActivityNotFoundException anfe) {
    Console.logError(getContext(),""String_Node_Str"");
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    RecentsConfiguration config=RecentsConfiguration.getInstance();
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=Math.min(transform.rect.top,config.displayRect.height());
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  if (task.isActive) {
    ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
    if (opts != null) {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
    }
 else {
      am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
    }
  }
 else {
    Intent i=new Intent(task.key.intent);
    i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
 catch (    ActivityNotFoundException anfe) {
      Console.logError(getContext(),""String_Node_Str"");
    }
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.8975559022360895
199508,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        if (opts != null) {
          getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
        }
 else {
          getContext().startActivityAsUser(i,UserHandle.CURRENT);
        }
      }
 catch (      ActivityNotFoundException anfe) {
        Console.logError(getContext(),""String_Node_Str"");
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        RecentsConfiguration config=RecentsConfiguration.getInstance();
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=Math.min(transform.rect.top,config.displayRect.height());
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      if (task.isActive) {
        ActivityManager am=(ActivityManager)stackView.getContext().getSystemService(Context.ACTIVITY_SERVICE);
        if (opts != null) {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME,opts.toBundle());
        }
 else {
          am.moveTaskToFront(task.key.id,ActivityManager.MOVE_TASK_WITH_HOME);
        }
      }
 else {
        Intent i=new Intent(task.key.intent);
        i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          if (opts != null) {
            getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
          }
 else {
            getContext().startActivityAsUser(i,UserHandle.CURRENT);
          }
        }
 catch (        ActivityNotFoundException anfe) {
          Console.logError(getContext(),""String_Node_Str"");
        }
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9203703703703704
199509,"/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}","/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}",0.9083503054989815
199510,"@Override public void sessionCreated(IInputMethodSession session){
  mParentIMMS.onSessionCreated(mMethod,session,mChannel);
}","@Override public void sessionCreated(IInputMethodSession session){
  long ident=Binder.clearCallingIdentity();
  try {
    mParentIMMS.onSessionCreated(mMethod,session,mChannel);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.6847826086956522
199511,"/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}","/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}",0.9083503054989815
199512,"@Override public void sessionCreated(IInputMethodSession session){
  mParentIMMS.onSessionCreated(mMethod,session,mChannel);
}","@Override public void sessionCreated(IInputMethodSession session){
  long ident=Binder.clearCallingIdentity();
  try {
    mParentIMMS.onSessionCreated(mMethod,session,mChannel);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.6847826086956522
199513,"/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}","/** 
 * Reset all of the state associated with being bound to an input method.
 */
void clearBindingLocked(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  clearConnectionLocked();
  setInputChannelLocked(null);
  mBindSequence=-1;
  mCurId=null;
  mCurMethod=null;
}",0.9083503054989815
199514,"@Override public void sessionCreated(IInputMethodSession session){
  mParentIMMS.onSessionCreated(mMethod,session,mChannel);
}","@Override public void sessionCreated(IInputMethodSession session){
  long ident=Binder.clearCallingIdentity();
  try {
    mParentIMMS.onSessionCreated(mMethod,session,mChannel);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.6847826086956522
199515,"@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  mSettingsObserver.observe();
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}","@Override public void onStart(){
  mAm=ActivityManagerNative.getDefault();
  mAppOps=(AppOpsManager)getContext().getSystemService(Context.APP_OPS_SERVICE);
  mVibrator=(Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);
  mHandler=new WorkerHandler();
  importOldBlockDb();
  mStatusBar=getLocalService(StatusBarManagerInternal.class);
  mStatusBar.setNotificationDelegate(mNotificationDelegate);
  final LightsManager lights=getLocalService(LightsManager.class);
  mNotificationLight=lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
  mAttentionLight=lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
  Resources resources=getContext().getResources();
  mDefaultNotificationColor=resources.getColor(R.color.config_defaultNotificationColor);
  mDefaultNotificationLedOn=resources.getInteger(R.integer.config_defaultNotificationLedOn);
  mDefaultNotificationLedOff=resources.getInteger(R.integer.config_defaultNotificationLedOff);
  mDefaultVibrationPattern=getLongArray(resources,R.array.config_defaultNotificationVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  mFallbackVibrationPattern=getLongArray(resources,R.array.config_notificationFallbackVibePattern,VIBRATE_PATTERN_MAXLEN,DEFAULT_VIBRATE_PATTERN);
  if (0 == Settings.Global.getInt(getContext().getContentResolver(),Settings.Global.DEVICE_PROVISIONED,0)) {
    mDisabledNotifications=StatusBarManager.DISABLE_NOTIFICATION_ALERTS;
  }
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
  filter.addAction(Intent.ACTION_USER_PRESENT);
  filter.addAction(Intent.ACTION_USER_STOPPED);
  filter.addAction(Intent.ACTION_USER_SWITCHED);
  getContext().registerReceiver(mIntentReceiver,filter);
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  getContext().registerReceiver(mIntentReceiver,pkgFilter);
  IntentFilter sdFilter=new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  getContext().registerReceiver(mIntentReceiver,sdFilter);
  mSettingsObserver=new SettingsObserver(mHandler);
  String[] notificationScorerNames=resources.getStringArray(R.array.config_notificationScorers);
  for (  String scorerName : notificationScorerNames) {
    try {
      Class<?> scorerClass=getContext().getClassLoader().loadClass(scorerName);
      NotificationScorer scorer=(NotificationScorer)scorerClass.newInstance();
      scorer.initialize(getContext());
      mScorers.add(scorer);
    }
 catch (    ClassNotFoundException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    InstantiationException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
catch (    IllegalAccessException e) {
      Slog.w(TAG,""String_Node_Str"" + scorerName + ""String_Node_Str"",e);
    }
  }
  publishBinderService(Context.NOTIFICATION_SERVICE,mService);
  publishLocalService(NotificationManagerInternal.class,mInternalService);
}",0.9953930747510774
199516,"@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
    rebindListenerServices();
  }
}","@Override public void onBootPhase(int phase){
  if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
    mSystemReady=true;
    mAudioManager=(AudioManager)getContext().getSystemService(Context.AUDIO_SERVICE);
  }
 else   if (phase == SystemService.PHASE_THIRD_PARTY_APPS_CAN_START) {
    mSettingsObserver.observe();
  }
}",0.7854671280276817
199517,"void systemReady(){
  final Context context=ActivityThread.systemMain().getSystemContext();
  mUserPackageMonitor.register(context,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}","void systemReady(){
  mUserPackageMonitor.register(mContext,null,UserHandle.ALL,false);
  userForeground(UserHandle.USER_OWNER);
}",0.7734138972809668
199518,"protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(mCropView.getWidth(),cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(mCropView.getHeight(),cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Point inSize=mCropView.getSourceDimensions();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}","protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  Point inSize=mCropView.getSourceDimensions();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(inSize.x,cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(inSize.y,cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}",0.934483391447972
199519,"protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(mCropView.getWidth(),cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(mCropView.getHeight(),cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Point inSize=mCropView.getSourceDimensions();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}","protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  Point inSize=mCropView.getSourceDimensions();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(inSize.x,cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(inSize.y,cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}",0.934483391447972
199520,"/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
 else {
    if (mPaused) {
      if (mPauseTime < 0) {
        mPauseTime=currentTime;
      }
      return false;
    }
 else     if (mResumed) {
      mResumed=false;
      if (mPauseTime > 0) {
        mDelayStartTime+=(currentTime - mPauseTime);
      }
    }
    long deltaTime=currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
      mStartTime=currentTime - (deltaTime - mStartDelay);
      mPlayingState=RUNNING;
      return true;
    }
  }
  return false;
}","/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
  if (mPaused) {
    if (mPauseTime < 0) {
      mPauseTime=currentTime;
    }
    return false;
  }
 else   if (mResumed) {
    mResumed=false;
    if (mPauseTime > 0) {
      mDelayStartTime+=(currentTime - mPauseTime);
    }
  }
  long deltaTime=currentTime - mDelayStartTime;
  if (deltaTime > mStartDelay) {
    mStartTime=currentTime - (deltaTime - mStartDelay);
    mPlayingState=RUNNING;
    return true;
  }
  return false;
}",0.9554973821989527
199521,"/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
 else {
    if (mPaused) {
      if (mPauseTime < 0) {
        mPauseTime=currentTime;
      }
      return false;
    }
 else     if (mResumed) {
      mResumed=false;
      if (mPauseTime > 0) {
        mDelayStartTime+=(currentTime - mPauseTime);
      }
    }
    long deltaTime=currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
      mStartTime=currentTime - (deltaTime - mStartDelay);
      mPlayingState=RUNNING;
      return true;
    }
  }
  return false;
}","/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
  if (mPaused) {
    if (mPauseTime < 0) {
      mPauseTime=currentTime;
    }
    return false;
  }
 else   if (mResumed) {
    mResumed=false;
    if (mPauseTime > 0) {
      mDelayStartTime+=(currentTime - mPauseTime);
    }
  }
  long deltaTime=currentTime - mDelayStartTime;
  if (deltaTime > mStartDelay) {
    mStartTime=currentTime - (deltaTime - mStartDelay);
    mPlayingState=RUNNING;
    return true;
  }
  return false;
}",0.9554973821989527
199522,"protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(mCropView.getWidth(),cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(mCropView.getHeight(),cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Point inSize=mCropView.getSourceDimensions();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}","protected void cropImageAndSetWallpaper(Uri uri,OnBitmapCroppedHandler onBitmapCroppedHandler,final boolean finishActivityWhenDone){
  boolean centerCrop=getResources().getBoolean(R.bool.center_crop);
  boolean ltr=mCropView.getLayoutDirection() == View.LAYOUT_DIRECTION_LTR;
  Display d=getWindowManager().getDefaultDisplay();
  Point displaySize=new Point();
  d.getSize(displaySize);
  boolean isPortrait=displaySize.x < displaySize.y;
  Point defaultWallpaperSize=getDefaultWallpaperSize(getResources(),getWindowManager());
  RectF cropRect=mCropView.getCrop();
  Point inSize=mCropView.getSourceDimensions();
  cropRect.left=Math.max(0,cropRect.left);
  cropRect.right=Math.min(inSize.x,cropRect.right);
  cropRect.top=Math.max(0,cropRect.top);
  cropRect.bottom=Math.min(inSize.y,cropRect.bottom);
  int cropRotation=mCropView.getImageRotation();
  float cropScale=mCropView.getWidth() / (float)cropRect.width();
  Matrix rotateMatrix=new Matrix();
  rotateMatrix.setRotate(cropRotation);
  float[] rotatedInSize=new float[]{inSize.x,inSize.y};
  rotateMatrix.mapPoints(rotatedInSize);
  rotatedInSize[0]=Math.abs(rotatedInSize[0]);
  rotatedInSize[1]=Math.abs(rotatedInSize[1]);
  float extraSpace;
  if (centerCrop) {
    extraSpace=2f * Math.min(rotatedInSize[0] - cropRect.right,cropRect.left);
  }
 else {
    extraSpace=ltr ? rotatedInSize[0] - cropRect.right : cropRect.left;
  }
  float maxExtraSpace=defaultWallpaperSize.x / cropScale - cropRect.width();
  extraSpace=Math.min(extraSpace,maxExtraSpace);
  if (centerCrop) {
    cropRect.left-=extraSpace / 2f;
    cropRect.right+=extraSpace / 2f;
  }
 else {
    if (ltr) {
      cropRect.right+=extraSpace;
    }
 else {
      cropRect.left-=extraSpace;
    }
  }
  if (isPortrait) {
    cropRect.bottom=cropRect.top + defaultWallpaperSize.y / cropScale;
  }
 else {
    float extraPortraitHeight=defaultWallpaperSize.y / cropScale - cropRect.height();
    float expandHeight=Math.min(Math.min(rotatedInSize[1] - cropRect.bottom,cropRect.top),extraPortraitHeight / 2);
    cropRect.top-=expandHeight;
    cropRect.bottom+=expandHeight;
  }
  final int outWidth=(int)Math.round(cropRect.width() * cropScale);
  final int outHeight=(int)Math.round(cropRect.height() * cropScale);
  Runnable onEndCrop=new Runnable(){
    public void run(){
      updateWallpaperDimensions(outWidth,outHeight);
      if (finishActivityWhenDone) {
        setResult(Activity.RESULT_OK);
        finish();
      }
    }
  }
;
  BitmapCropTask cropTask=new BitmapCropTask(this,uri,cropRect,cropRotation,outWidth,outHeight,true,false,onEndCrop);
  if (onBitmapCroppedHandler != null) {
    cropTask.setOnBitmapCropped(onBitmapCroppedHandler);
  }
  cropTask.execute();
}",0.934483391447972
199523,"/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
 else {
    if (mPaused) {
      if (mPauseTime < 0) {
        mPauseTime=currentTime;
      }
      return false;
    }
 else     if (mResumed) {
      mResumed=false;
      if (mPauseTime > 0) {
        mDelayStartTime+=(currentTime - mPauseTime);
      }
    }
    long deltaTime=currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
      mStartTime=currentTime - (deltaTime - mStartDelay);
      mPlayingState=RUNNING;
      return true;
    }
  }
  return false;
}","/** 
 * Internal function called to process an animation frame on an animation that is currently sleeping through its <code>startDelay</code> phase. The return value indicates whether it should be woken up and put on the active animations queue.
 * @param currentTime The current animation time, used to calculate whether the animationhas exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animationshould be added to the set of active animations.
 */
private boolean delayedAnimationFrame(long currentTime){
  if (!mStartedDelay) {
    mStartedDelay=true;
    mDelayStartTime=currentTime;
  }
  if (mPaused) {
    if (mPauseTime < 0) {
      mPauseTime=currentTime;
    }
    return false;
  }
 else   if (mResumed) {
    mResumed=false;
    if (mPauseTime > 0) {
      mDelayStartTime+=(currentTime - mPauseTime);
    }
  }
  long deltaTime=currentTime - mDelayStartTime;
  if (deltaTime > mStartDelay) {
    mStartTime=currentTime - (deltaTime - mStartDelay);
    mPlayingState=RUNNING;
    return true;
  }
  return false;
}",0.9554973821989527
199524,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mPausingActivity == r) {
    mPausingActivity=null;
  }
  if (mService.mFocusedActivity == r) {
    mService.mFocusedActivity=null;
  }
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  if (!mService.mPendingThumbnails.isEmpty()) {
    mStackSupervisor.mCancelledThumbnails.add(r);
  }
  removeTimeoutsForActivityLocked(r);
}",0.979011509817197
199525,"@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
}","@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
  getSecurityContainer().onPause();
}",0.9240506329113924
199526,"@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
}","@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
  getSecurityContainer().onPause();
}",0.9240506329113924
199527,"@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
}","@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
  getSecurityContainer().onPause();
}",0.9240506329113924
199528,"@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
}","@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
  getSecurityContainer().onPause();
}",0.9240506329113924
199529,"@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
}","@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
  getSecurityContainer().onPause();
}",0.9240506329113924
199530,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199531,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199532,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199533,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199534,"private void updateMinScale(int w,int h,TileSource source,boolean resetScale){
synchronized (mLock) {
    if (resetScale) {
      mRenderer.scale=1;
    }
    if (source != null) {
      final float[] imageDims=getImageDims();
      final float imageWidth=imageDims[0];
      final float imageHeight=imageDims[1];
      mMinScale=Math.max(w / imageWidth,h / imageHeight);
      mRenderer.scale=Math.max(mMinScale,mRenderer.scale);
    }
  }
}","private void updateMinScale(int w,int h,TileSource source,boolean resetScale){
synchronized (mLock) {
    if (resetScale) {
      mRenderer.scale=1;
    }
    if (source != null) {
      final float[] imageDims=getImageDims();
      final float imageWidth=imageDims[0];
      final float imageHeight=imageDims[1];
      mMinScale=Math.max(w / imageWidth,h / imageHeight);
      mRenderer.scale=Math.max(mMinScale,resetScale ? Float.MIN_VALUE : mRenderer.scale);
    }
  }
}",0.966120218579235
199535,"public boolean cropBitmap(){
  boolean failure=false;
  WallpaperManager wallpaperManager=null;
  if (mSetWallpaper) {
    wallpaperManager=WallpaperManager.getInstance(mContext.getApplicationContext());
  }
  if (mSetWallpaper && mNoCrop) {
    try {
      InputStream is=regenerateInputStream();
      if (is != null) {
        wallpaperManager.setStream(is);
        Utils.closeSilently(is);
      }
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"",e);
      failure=true;
    }
    return !failure;
  }
 else {
    Rect roundedTrueCrop=new Rect();
    Matrix rotateMatrix=new Matrix();
    Matrix inverseRotateMatrix=new Matrix();
    if (mRotation > 0) {
      rotateMatrix.setRotate(mRotation);
      inverseRotateMatrix.setRotate(-mRotation);
      mCropBounds.roundOut(roundedTrueCrop);
      mCropBounds=new RectF(roundedTrueCrop);
      Point bounds=getImageBounds();
      if (bounds == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        failure=true;
        return false;
      }
      float[] rotatedBounds=new float[]{bounds.x,bounds.y};
      rotateMatrix.mapPoints(rotatedBounds);
      rotatedBounds[0]=Math.abs(rotatedBounds[0]);
      rotatedBounds[1]=Math.abs(rotatedBounds[1]);
      mCropBounds.offset(-rotatedBounds[0] / 2,-rotatedBounds[1] / 2);
      inverseRotateMatrix.mapRect(mCropBounds);
      mCropBounds.offset(bounds.x / 2,bounds.y / 2);
    }
    mCropBounds.roundOut(roundedTrueCrop);
    if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
      return false;
    }
    int scaleDownSampleSize=Math.max(1,Math.min(roundedTrueCrop.width() / mOutWidth,roundedTrueCrop.height() / mOutHeight));
    BitmapRegionDecoder decoder=null;
    InputStream is=null;
    try {
      is=regenerateInputStream();
      if (is == null) {
        Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
        failure=true;
        return false;
      }
      decoder=BitmapRegionDecoder.newInstance(is,false);
      Utils.closeSilently(is);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString(),e);
    }
 finally {
      Utils.closeSilently(is);
      is=null;
    }
    Bitmap crop=null;
    if (decoder != null) {
      BitmapFactory.Options options=new BitmapFactory.Options();
      if (scaleDownSampleSize > 1) {
        options.inSampleSize=scaleDownSampleSize;
      }
      crop=decoder.decodeRegion(roundedTrueCrop,options);
      decoder.recycle();
    }
    if (crop == null) {
      is=regenerateInputStream();
      Bitmap fullSize=null;
      if (is != null) {
        BitmapFactory.Options options=new BitmapFactory.Options();
        if (scaleDownSampleSize > 1) {
          options.inSampleSize=scaleDownSampleSize;
        }
        fullSize=BitmapFactory.decodeStream(is,null,options);
        Utils.closeSilently(is);
      }
      if (fullSize != null) {
        mCropBounds.left/=scaleDownSampleSize;
        mCropBounds.top/=scaleDownSampleSize;
        mCropBounds.bottom/=scaleDownSampleSize;
        mCropBounds.right/=scaleDownSampleSize;
        mCropBounds.roundOut(roundedTrueCrop);
        crop=Bitmap.createBitmap(fullSize,roundedTrueCrop.left,roundedTrueCrop.top,roundedTrueCrop.width(),roundedTrueCrop.height());
      }
    }
    if (crop == null) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
      failure=true;
      return false;
    }
    if (mOutWidth > 0 && mOutHeight > 0 || mRotation > 0) {
      float[] dimsAfter=new float[]{crop.getWidth(),crop.getHeight()};
      rotateMatrix.mapPoints(dimsAfter);
      dimsAfter[0]=Math.abs(dimsAfter[0]);
      dimsAfter[1]=Math.abs(dimsAfter[1]);
      if (!(mOutWidth > 0 && mOutHeight > 0)) {
        mOutWidth=Math.round(dimsAfter[0]);
        mOutHeight=Math.round(dimsAfter[1]);
      }
      RectF cropRect=new RectF(0,0,dimsAfter[0],dimsAfter[1]);
      RectF returnRect=new RectF(0,0,mOutWidth,mOutHeight);
      Matrix m=new Matrix();
      if (mRotation == 0) {
        m.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
      }
 else {
        Matrix m1=new Matrix();
        m1.setTranslate(-crop.getWidth() / 2f,-crop.getHeight() / 2f);
        Matrix m2=new Matrix();
        m2.setRotate(mRotation);
        Matrix m3=new Matrix();
        m3.setTranslate(dimsAfter[0] / 2f,dimsAfter[1] / 2f);
        Matrix m4=new Matrix();
        m4.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
        Matrix c1=new Matrix();
        c1.setConcat(m2,m1);
        Matrix c2=new Matrix();
        c2.setConcat(m4,m3);
        m.setConcat(c2,c1);
      }
      Bitmap tmp=Bitmap.createBitmap((int)returnRect.width(),(int)returnRect.height(),Bitmap.Config.ARGB_8888);
      if (tmp != null) {
        Canvas c=new Canvas(tmp);
        Paint p=new Paint();
        p.setFilterBitmap(true);
        c.drawBitmap(crop,m,p);
        crop=tmp;
      }
    }
    if (mSaveCroppedBitmap) {
      mCroppedBitmap=crop;
    }
    CompressFormat cf=convertExtensionToCompressFormat(getFileExtension(mOutputFormat));
    ByteArrayOutputStream tmpOut=new ByteArrayOutputStream(2048);
    if (crop.compress(cf,DEFAULT_COMPRESS_QUALITY,tmpOut)) {
      if (mSetWallpaper && wallpaperManager != null) {
        try {
          byte[] outByteArray=tmpOut.toByteArray();
          wallpaperManager.setStream(new ByteArrayInputStream(outByteArray));
          if (mOnBitmapCroppedHandler != null) {
            mOnBitmapCroppedHandler.onBitmapCropped(outByteArray);
          }
        }
 catch (        IOException e) {
          Log.w(LOGTAG,""String_Node_Str"",e);
          failure=true;
        }
      }
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
    }
  }
  return !failure;
}","public boolean cropBitmap(){
  boolean failure=false;
  WallpaperManager wallpaperManager=null;
  if (mSetWallpaper) {
    wallpaperManager=WallpaperManager.getInstance(mContext.getApplicationContext());
  }
  if (mSetWallpaper && mNoCrop) {
    try {
      InputStream is=regenerateInputStream();
      if (is != null) {
        wallpaperManager.setStream(is);
        Utils.closeSilently(is);
      }
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"",e);
      failure=true;
    }
    return !failure;
  }
 else {
    Rect roundedTrueCrop=new Rect();
    Matrix rotateMatrix=new Matrix();
    Matrix inverseRotateMatrix=new Matrix();
    Point bounds=getImageBounds();
    if (mRotation > 0) {
      rotateMatrix.setRotate(mRotation);
      inverseRotateMatrix.setRotate(-mRotation);
      mCropBounds.roundOut(roundedTrueCrop);
      mCropBounds=new RectF(roundedTrueCrop);
      if (bounds == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        failure=true;
        return false;
      }
      float[] rotatedBounds=new float[]{bounds.x,bounds.y};
      rotateMatrix.mapPoints(rotatedBounds);
      rotatedBounds[0]=Math.abs(rotatedBounds[0]);
      rotatedBounds[1]=Math.abs(rotatedBounds[1]);
      mCropBounds.offset(-rotatedBounds[0] / 2,-rotatedBounds[1] / 2);
      inverseRotateMatrix.mapRect(mCropBounds);
      mCropBounds.offset(bounds.x / 2,bounds.y / 2);
    }
    mCropBounds.roundOut(roundedTrueCrop);
    if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
      return false;
    }
    int scaleDownSampleSize=Math.max(1,Math.min(roundedTrueCrop.width() / mOutWidth,roundedTrueCrop.height() / mOutHeight));
    BitmapRegionDecoder decoder=null;
    InputStream is=null;
    try {
      is=regenerateInputStream();
      if (is == null) {
        Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
        failure=true;
        return false;
      }
      decoder=BitmapRegionDecoder.newInstance(is,false);
      Utils.closeSilently(is);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString(),e);
    }
 finally {
      Utils.closeSilently(is);
      is=null;
    }
    Bitmap crop=null;
    if (decoder != null) {
      BitmapFactory.Options options=new BitmapFactory.Options();
      if (scaleDownSampleSize > 1) {
        options.inSampleSize=scaleDownSampleSize;
      }
      crop=decoder.decodeRegion(roundedTrueCrop,options);
      decoder.recycle();
    }
    if (crop == null) {
      is=regenerateInputStream();
      Bitmap fullSize=null;
      if (is != null) {
        BitmapFactory.Options options=new BitmapFactory.Options();
        if (scaleDownSampleSize > 1) {
          options.inSampleSize=scaleDownSampleSize;
        }
        fullSize=BitmapFactory.decodeStream(is,null,options);
        Utils.closeSilently(is);
      }
      if (fullSize != null) {
        scaleDownSampleSize=bounds.x / fullSize.getWidth();
        mCropBounds.left/=scaleDownSampleSize;
        mCropBounds.top/=scaleDownSampleSize;
        mCropBounds.bottom/=scaleDownSampleSize;
        mCropBounds.right/=scaleDownSampleSize;
        mCropBounds.roundOut(roundedTrueCrop);
        if (roundedTrueCrop.width() > fullSize.getWidth()) {
          roundedTrueCrop.right=roundedTrueCrop.left + fullSize.getWidth();
        }
        if (roundedTrueCrop.right > fullSize.getWidth()) {
          int adjustment=roundedTrueCrop.left - Math.max(0,roundedTrueCrop.right - roundedTrueCrop.width());
          roundedTrueCrop.left-=adjustment;
          roundedTrueCrop.right-=adjustment;
        }
        if (roundedTrueCrop.height() > fullSize.getHeight()) {
          roundedTrueCrop.bottom=roundedTrueCrop.top + fullSize.getHeight();
        }
        if (roundedTrueCrop.bottom > fullSize.getHeight()) {
          int adjustment=roundedTrueCrop.top - Math.max(0,roundedTrueCrop.bottom - roundedTrueCrop.height());
          roundedTrueCrop.top-=adjustment;
          roundedTrueCrop.bottom-=adjustment;
        }
        crop=Bitmap.createBitmap(fullSize,roundedTrueCrop.left,roundedTrueCrop.top,roundedTrueCrop.width(),roundedTrueCrop.height());
      }
    }
    if (crop == null) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
      failure=true;
      return false;
    }
    if (mOutWidth > 0 && mOutHeight > 0 || mRotation > 0) {
      float[] dimsAfter=new float[]{crop.getWidth(),crop.getHeight()};
      rotateMatrix.mapPoints(dimsAfter);
      dimsAfter[0]=Math.abs(dimsAfter[0]);
      dimsAfter[1]=Math.abs(dimsAfter[1]);
      if (!(mOutWidth > 0 && mOutHeight > 0)) {
        mOutWidth=Math.round(dimsAfter[0]);
        mOutHeight=Math.round(dimsAfter[1]);
      }
      RectF cropRect=new RectF(0,0,dimsAfter[0],dimsAfter[1]);
      RectF returnRect=new RectF(0,0,mOutWidth,mOutHeight);
      Matrix m=new Matrix();
      if (mRotation == 0) {
        m.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
      }
 else {
        Matrix m1=new Matrix();
        m1.setTranslate(-crop.getWidth() / 2f,-crop.getHeight() / 2f);
        Matrix m2=new Matrix();
        m2.setRotate(mRotation);
        Matrix m3=new Matrix();
        m3.setTranslate(dimsAfter[0] / 2f,dimsAfter[1] / 2f);
        Matrix m4=new Matrix();
        m4.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
        Matrix c1=new Matrix();
        c1.setConcat(m2,m1);
        Matrix c2=new Matrix();
        c2.setConcat(m4,m3);
        m.setConcat(c2,c1);
      }
      Bitmap tmp=Bitmap.createBitmap((int)returnRect.width(),(int)returnRect.height(),Bitmap.Config.ARGB_8888);
      if (tmp != null) {
        Canvas c=new Canvas(tmp);
        Paint p=new Paint();
        p.setFilterBitmap(true);
        c.drawBitmap(crop,m,p);
        crop=tmp;
      }
    }
    if (mSaveCroppedBitmap) {
      mCroppedBitmap=crop;
    }
    CompressFormat cf=convertExtensionToCompressFormat(getFileExtension(mOutputFormat));
    ByteArrayOutputStream tmpOut=new ByteArrayOutputStream(2048);
    if (crop.compress(cf,DEFAULT_COMPRESS_QUALITY,tmpOut)) {
      if (mSetWallpaper && wallpaperManager != null) {
        try {
          byte[] outByteArray=tmpOut.toByteArray();
          wallpaperManager.setStream(new ByteArrayInputStream(outByteArray));
          if (mOnBitmapCroppedHandler != null) {
            mOnBitmapCroppedHandler.onBitmapCropped(outByteArray);
          }
        }
 catch (        IOException e) {
          Log.w(LOGTAG,""String_Node_Str"",e);
          failure=true;
        }
      }
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
    }
  }
  return !failure;
}",0.9224096385542168
199536,"public void run(){
  int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
  int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
  wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
}","public void run(){
  updateWallpaperDimensions(outWidth,outHeight);
  if (finishActivityWhenDone) {
    setResult(Activity.RESULT_OK);
    finish();
  }
}",0.2899262899262899
199537,"static public void suggestWallpaperDimension(Resources res,final SharedPreferences sharedPrefs,WindowManager windowManager,final WallpaperManager wallpaperManager){
  final Point defaultWallpaperSize=getDefaultWallpaperSize(res,windowManager);
  new Thread(""String_Node_Str""){
    public void run(){
      int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
      int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
      wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
    }
  }
.start();
}","static public void suggestWallpaperDimension(Resources res,final SharedPreferences sharedPrefs,WindowManager windowManager,final WallpaperManager wallpaperManager){
  final Point defaultWallpaperSize=getDefaultWallpaperSize(res,windowManager);
  new AsyncTask<Void,Void,Void>(){
    public Void doInBackground(    Void... args){
      int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
      int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
      wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
      return null;
    }
  }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,(Void)null);
}",0.8564476885644768
199538,"@Override protected Boolean doInBackground(Void... params){
  return cropBitmap();
}","public Void doInBackground(Void... args){
  int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
  int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
  wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
  return null;
}",0.1546666666666666
199539,"private void updateMinScale(int w,int h,TileSource source,boolean resetScale){
synchronized (mLock) {
    if (resetScale) {
      mRenderer.scale=1;
    }
    if (source != null) {
      final float[] imageDims=getImageDims();
      final float imageWidth=imageDims[0];
      final float imageHeight=imageDims[1];
      mMinScale=Math.max(w / imageWidth,h / imageHeight);
      mRenderer.scale=Math.max(mMinScale,mRenderer.scale);
    }
  }
}","private void updateMinScale(int w,int h,TileSource source,boolean resetScale){
synchronized (mLock) {
    if (resetScale) {
      mRenderer.scale=1;
    }
    if (source != null) {
      final float[] imageDims=getImageDims();
      final float imageWidth=imageDims[0];
      final float imageHeight=imageDims[1];
      mMinScale=Math.max(w / imageWidth,h / imageHeight);
      mRenderer.scale=Math.max(mMinScale,resetScale ? Float.MIN_VALUE : mRenderer.scale);
    }
  }
}",0.966120218579235
199540,"public boolean cropBitmap(){
  boolean failure=false;
  WallpaperManager wallpaperManager=null;
  if (mSetWallpaper) {
    wallpaperManager=WallpaperManager.getInstance(mContext.getApplicationContext());
  }
  if (mSetWallpaper && mNoCrop) {
    try {
      InputStream is=regenerateInputStream();
      if (is != null) {
        wallpaperManager.setStream(is);
        Utils.closeSilently(is);
      }
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"",e);
      failure=true;
    }
    return !failure;
  }
 else {
    Rect roundedTrueCrop=new Rect();
    Matrix rotateMatrix=new Matrix();
    Matrix inverseRotateMatrix=new Matrix();
    if (mRotation > 0) {
      rotateMatrix.setRotate(mRotation);
      inverseRotateMatrix.setRotate(-mRotation);
      mCropBounds.roundOut(roundedTrueCrop);
      mCropBounds=new RectF(roundedTrueCrop);
      Point bounds=getImageBounds();
      if (bounds == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        failure=true;
        return false;
      }
      float[] rotatedBounds=new float[]{bounds.x,bounds.y};
      rotateMatrix.mapPoints(rotatedBounds);
      rotatedBounds[0]=Math.abs(rotatedBounds[0]);
      rotatedBounds[1]=Math.abs(rotatedBounds[1]);
      mCropBounds.offset(-rotatedBounds[0] / 2,-rotatedBounds[1] / 2);
      inverseRotateMatrix.mapRect(mCropBounds);
      mCropBounds.offset(bounds.x / 2,bounds.y / 2);
    }
    mCropBounds.roundOut(roundedTrueCrop);
    if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
      return false;
    }
    int scaleDownSampleSize=Math.max(1,Math.min(roundedTrueCrop.width() / mOutWidth,roundedTrueCrop.height() / mOutHeight));
    BitmapRegionDecoder decoder=null;
    InputStream is=null;
    try {
      is=regenerateInputStream();
      if (is == null) {
        Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
        failure=true;
        return false;
      }
      decoder=BitmapRegionDecoder.newInstance(is,false);
      Utils.closeSilently(is);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString(),e);
    }
 finally {
      Utils.closeSilently(is);
      is=null;
    }
    Bitmap crop=null;
    if (decoder != null) {
      BitmapFactory.Options options=new BitmapFactory.Options();
      if (scaleDownSampleSize > 1) {
        options.inSampleSize=scaleDownSampleSize;
      }
      crop=decoder.decodeRegion(roundedTrueCrop,options);
      decoder.recycle();
    }
    if (crop == null) {
      is=regenerateInputStream();
      Bitmap fullSize=null;
      if (is != null) {
        BitmapFactory.Options options=new BitmapFactory.Options();
        if (scaleDownSampleSize > 1) {
          options.inSampleSize=scaleDownSampleSize;
        }
        fullSize=BitmapFactory.decodeStream(is,null,options);
        Utils.closeSilently(is);
      }
      if (fullSize != null) {
        mCropBounds.left/=scaleDownSampleSize;
        mCropBounds.top/=scaleDownSampleSize;
        mCropBounds.bottom/=scaleDownSampleSize;
        mCropBounds.right/=scaleDownSampleSize;
        mCropBounds.roundOut(roundedTrueCrop);
        crop=Bitmap.createBitmap(fullSize,roundedTrueCrop.left,roundedTrueCrop.top,roundedTrueCrop.width(),roundedTrueCrop.height());
      }
    }
    if (crop == null) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
      failure=true;
      return false;
    }
    if (mOutWidth > 0 && mOutHeight > 0 || mRotation > 0) {
      float[] dimsAfter=new float[]{crop.getWidth(),crop.getHeight()};
      rotateMatrix.mapPoints(dimsAfter);
      dimsAfter[0]=Math.abs(dimsAfter[0]);
      dimsAfter[1]=Math.abs(dimsAfter[1]);
      if (!(mOutWidth > 0 && mOutHeight > 0)) {
        mOutWidth=Math.round(dimsAfter[0]);
        mOutHeight=Math.round(dimsAfter[1]);
      }
      RectF cropRect=new RectF(0,0,dimsAfter[0],dimsAfter[1]);
      RectF returnRect=new RectF(0,0,mOutWidth,mOutHeight);
      Matrix m=new Matrix();
      if (mRotation == 0) {
        m.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
      }
 else {
        Matrix m1=new Matrix();
        m1.setTranslate(-crop.getWidth() / 2f,-crop.getHeight() / 2f);
        Matrix m2=new Matrix();
        m2.setRotate(mRotation);
        Matrix m3=new Matrix();
        m3.setTranslate(dimsAfter[0] / 2f,dimsAfter[1] / 2f);
        Matrix m4=new Matrix();
        m4.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
        Matrix c1=new Matrix();
        c1.setConcat(m2,m1);
        Matrix c2=new Matrix();
        c2.setConcat(m4,m3);
        m.setConcat(c2,c1);
      }
      Bitmap tmp=Bitmap.createBitmap((int)returnRect.width(),(int)returnRect.height(),Bitmap.Config.ARGB_8888);
      if (tmp != null) {
        Canvas c=new Canvas(tmp);
        Paint p=new Paint();
        p.setFilterBitmap(true);
        c.drawBitmap(crop,m,p);
        crop=tmp;
      }
    }
    if (mSaveCroppedBitmap) {
      mCroppedBitmap=crop;
    }
    CompressFormat cf=convertExtensionToCompressFormat(getFileExtension(mOutputFormat));
    ByteArrayOutputStream tmpOut=new ByteArrayOutputStream(2048);
    if (crop.compress(cf,DEFAULT_COMPRESS_QUALITY,tmpOut)) {
      if (mSetWallpaper && wallpaperManager != null) {
        try {
          byte[] outByteArray=tmpOut.toByteArray();
          wallpaperManager.setStream(new ByteArrayInputStream(outByteArray));
          if (mOnBitmapCroppedHandler != null) {
            mOnBitmapCroppedHandler.onBitmapCropped(outByteArray);
          }
        }
 catch (        IOException e) {
          Log.w(LOGTAG,""String_Node_Str"",e);
          failure=true;
        }
      }
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
    }
  }
  return !failure;
}","public boolean cropBitmap(){
  boolean failure=false;
  WallpaperManager wallpaperManager=null;
  if (mSetWallpaper) {
    wallpaperManager=WallpaperManager.getInstance(mContext.getApplicationContext());
  }
  if (mSetWallpaper && mNoCrop) {
    try {
      InputStream is=regenerateInputStream();
      if (is != null) {
        wallpaperManager.setStream(is);
        Utils.closeSilently(is);
      }
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"",e);
      failure=true;
    }
    return !failure;
  }
 else {
    Rect roundedTrueCrop=new Rect();
    Matrix rotateMatrix=new Matrix();
    Matrix inverseRotateMatrix=new Matrix();
    Point bounds=getImageBounds();
    if (mRotation > 0) {
      rotateMatrix.setRotate(mRotation);
      inverseRotateMatrix.setRotate(-mRotation);
      mCropBounds.roundOut(roundedTrueCrop);
      mCropBounds=new RectF(roundedTrueCrop);
      if (bounds == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        failure=true;
        return false;
      }
      float[] rotatedBounds=new float[]{bounds.x,bounds.y};
      rotateMatrix.mapPoints(rotatedBounds);
      rotatedBounds[0]=Math.abs(rotatedBounds[0]);
      rotatedBounds[1]=Math.abs(rotatedBounds[1]);
      mCropBounds.offset(-rotatedBounds[0] / 2,-rotatedBounds[1] / 2);
      inverseRotateMatrix.mapRect(mCropBounds);
      mCropBounds.offset(bounds.x / 2,bounds.y / 2);
    }
    mCropBounds.roundOut(roundedTrueCrop);
    if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
      return false;
    }
    int scaleDownSampleSize=Math.max(1,Math.min(roundedTrueCrop.width() / mOutWidth,roundedTrueCrop.height() / mOutHeight));
    BitmapRegionDecoder decoder=null;
    InputStream is=null;
    try {
      is=regenerateInputStream();
      if (is == null) {
        Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
        failure=true;
        return false;
      }
      decoder=BitmapRegionDecoder.newInstance(is,false);
      Utils.closeSilently(is);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString(),e);
    }
 finally {
      Utils.closeSilently(is);
      is=null;
    }
    Bitmap crop=null;
    if (decoder != null) {
      BitmapFactory.Options options=new BitmapFactory.Options();
      if (scaleDownSampleSize > 1) {
        options.inSampleSize=scaleDownSampleSize;
      }
      crop=decoder.decodeRegion(roundedTrueCrop,options);
      decoder.recycle();
    }
    if (crop == null) {
      is=regenerateInputStream();
      Bitmap fullSize=null;
      if (is != null) {
        BitmapFactory.Options options=new BitmapFactory.Options();
        if (scaleDownSampleSize > 1) {
          options.inSampleSize=scaleDownSampleSize;
        }
        fullSize=BitmapFactory.decodeStream(is,null,options);
        Utils.closeSilently(is);
      }
      if (fullSize != null) {
        scaleDownSampleSize=bounds.x / fullSize.getWidth();
        mCropBounds.left/=scaleDownSampleSize;
        mCropBounds.top/=scaleDownSampleSize;
        mCropBounds.bottom/=scaleDownSampleSize;
        mCropBounds.right/=scaleDownSampleSize;
        mCropBounds.roundOut(roundedTrueCrop);
        if (roundedTrueCrop.width() > fullSize.getWidth()) {
          roundedTrueCrop.right=roundedTrueCrop.left + fullSize.getWidth();
        }
        if (roundedTrueCrop.right > fullSize.getWidth()) {
          int adjustment=roundedTrueCrop.left - Math.max(0,roundedTrueCrop.right - roundedTrueCrop.width());
          roundedTrueCrop.left-=adjustment;
          roundedTrueCrop.right-=adjustment;
        }
        if (roundedTrueCrop.height() > fullSize.getHeight()) {
          roundedTrueCrop.bottom=roundedTrueCrop.top + fullSize.getHeight();
        }
        if (roundedTrueCrop.bottom > fullSize.getHeight()) {
          int adjustment=roundedTrueCrop.top - Math.max(0,roundedTrueCrop.bottom - roundedTrueCrop.height());
          roundedTrueCrop.top-=adjustment;
          roundedTrueCrop.bottom-=adjustment;
        }
        crop=Bitmap.createBitmap(fullSize,roundedTrueCrop.left,roundedTrueCrop.top,roundedTrueCrop.width(),roundedTrueCrop.height());
      }
    }
    if (crop == null) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
      failure=true;
      return false;
    }
    if (mOutWidth > 0 && mOutHeight > 0 || mRotation > 0) {
      float[] dimsAfter=new float[]{crop.getWidth(),crop.getHeight()};
      rotateMatrix.mapPoints(dimsAfter);
      dimsAfter[0]=Math.abs(dimsAfter[0]);
      dimsAfter[1]=Math.abs(dimsAfter[1]);
      if (!(mOutWidth > 0 && mOutHeight > 0)) {
        mOutWidth=Math.round(dimsAfter[0]);
        mOutHeight=Math.round(dimsAfter[1]);
      }
      RectF cropRect=new RectF(0,0,dimsAfter[0],dimsAfter[1]);
      RectF returnRect=new RectF(0,0,mOutWidth,mOutHeight);
      Matrix m=new Matrix();
      if (mRotation == 0) {
        m.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
      }
 else {
        Matrix m1=new Matrix();
        m1.setTranslate(-crop.getWidth() / 2f,-crop.getHeight() / 2f);
        Matrix m2=new Matrix();
        m2.setRotate(mRotation);
        Matrix m3=new Matrix();
        m3.setTranslate(dimsAfter[0] / 2f,dimsAfter[1] / 2f);
        Matrix m4=new Matrix();
        m4.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
        Matrix c1=new Matrix();
        c1.setConcat(m2,m1);
        Matrix c2=new Matrix();
        c2.setConcat(m4,m3);
        m.setConcat(c2,c1);
      }
      Bitmap tmp=Bitmap.createBitmap((int)returnRect.width(),(int)returnRect.height(),Bitmap.Config.ARGB_8888);
      if (tmp != null) {
        Canvas c=new Canvas(tmp);
        Paint p=new Paint();
        p.setFilterBitmap(true);
        c.drawBitmap(crop,m,p);
        crop=tmp;
      }
    }
    if (mSaveCroppedBitmap) {
      mCroppedBitmap=crop;
    }
    CompressFormat cf=convertExtensionToCompressFormat(getFileExtension(mOutputFormat));
    ByteArrayOutputStream tmpOut=new ByteArrayOutputStream(2048);
    if (crop.compress(cf,DEFAULT_COMPRESS_QUALITY,tmpOut)) {
      if (mSetWallpaper && wallpaperManager != null) {
        try {
          byte[] outByteArray=tmpOut.toByteArray();
          wallpaperManager.setStream(new ByteArrayInputStream(outByteArray));
          if (mOnBitmapCroppedHandler != null) {
            mOnBitmapCroppedHandler.onBitmapCropped(outByteArray);
          }
        }
 catch (        IOException e) {
          Log.w(LOGTAG,""String_Node_Str"",e);
          failure=true;
        }
      }
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
    }
  }
  return !failure;
}",0.9224096385542168
199541,"public void run(){
  int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
  int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
  wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
}","public void run(){
  updateWallpaperDimensions(outWidth,outHeight);
  if (finishActivityWhenDone) {
    setResult(Activity.RESULT_OK);
    finish();
  }
}",0.2899262899262899
199542,"static public void suggestWallpaperDimension(Resources res,final SharedPreferences sharedPrefs,WindowManager windowManager,final WallpaperManager wallpaperManager){
  final Point defaultWallpaperSize=getDefaultWallpaperSize(res,windowManager);
  new Thread(""String_Node_Str""){
    public void run(){
      int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
      int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
      wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
    }
  }
.start();
}","static public void suggestWallpaperDimension(Resources res,final SharedPreferences sharedPrefs,WindowManager windowManager,final WallpaperManager wallpaperManager){
  final Point defaultWallpaperSize=getDefaultWallpaperSize(res,windowManager);
  new AsyncTask<Void,Void,Void>(){
    public Void doInBackground(    Void... args){
      int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
      int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
      wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
      return null;
    }
  }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,(Void)null);
}",0.8564476885644768
199543,"@Override protected Boolean doInBackground(Void... params){
  return cropBitmap();
}","public Void doInBackground(Void... args){
  int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
  int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
  wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
  return null;
}",0.1546666666666666
199544,"private void updateMinScale(int w,int h,TileSource source,boolean resetScale){
synchronized (mLock) {
    if (resetScale) {
      mRenderer.scale=1;
    }
    if (source != null) {
      final float[] imageDims=getImageDims();
      final float imageWidth=imageDims[0];
      final float imageHeight=imageDims[1];
      mMinScale=Math.max(w / imageWidth,h / imageHeight);
      mRenderer.scale=Math.max(mMinScale,mRenderer.scale);
    }
  }
}","private void updateMinScale(int w,int h,TileSource source,boolean resetScale){
synchronized (mLock) {
    if (resetScale) {
      mRenderer.scale=1;
    }
    if (source != null) {
      final float[] imageDims=getImageDims();
      final float imageWidth=imageDims[0];
      final float imageHeight=imageDims[1];
      mMinScale=Math.max(w / imageWidth,h / imageHeight);
      mRenderer.scale=Math.max(mMinScale,resetScale ? Float.MIN_VALUE : mRenderer.scale);
    }
  }
}",0.966120218579235
199545,"public boolean cropBitmap(){
  boolean failure=false;
  WallpaperManager wallpaperManager=null;
  if (mSetWallpaper) {
    wallpaperManager=WallpaperManager.getInstance(mContext.getApplicationContext());
  }
  if (mSetWallpaper && mNoCrop) {
    try {
      InputStream is=regenerateInputStream();
      if (is != null) {
        wallpaperManager.setStream(is);
        Utils.closeSilently(is);
      }
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"",e);
      failure=true;
    }
    return !failure;
  }
 else {
    Rect roundedTrueCrop=new Rect();
    Matrix rotateMatrix=new Matrix();
    Matrix inverseRotateMatrix=new Matrix();
    if (mRotation > 0) {
      rotateMatrix.setRotate(mRotation);
      inverseRotateMatrix.setRotate(-mRotation);
      mCropBounds.roundOut(roundedTrueCrop);
      mCropBounds=new RectF(roundedTrueCrop);
      Point bounds=getImageBounds();
      if (bounds == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        failure=true;
        return false;
      }
      float[] rotatedBounds=new float[]{bounds.x,bounds.y};
      rotateMatrix.mapPoints(rotatedBounds);
      rotatedBounds[0]=Math.abs(rotatedBounds[0]);
      rotatedBounds[1]=Math.abs(rotatedBounds[1]);
      mCropBounds.offset(-rotatedBounds[0] / 2,-rotatedBounds[1] / 2);
      inverseRotateMatrix.mapRect(mCropBounds);
      mCropBounds.offset(bounds.x / 2,bounds.y / 2);
    }
    mCropBounds.roundOut(roundedTrueCrop);
    if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
      return false;
    }
    int scaleDownSampleSize=Math.max(1,Math.min(roundedTrueCrop.width() / mOutWidth,roundedTrueCrop.height() / mOutHeight));
    BitmapRegionDecoder decoder=null;
    InputStream is=null;
    try {
      is=regenerateInputStream();
      if (is == null) {
        Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
        failure=true;
        return false;
      }
      decoder=BitmapRegionDecoder.newInstance(is,false);
      Utils.closeSilently(is);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString(),e);
    }
 finally {
      Utils.closeSilently(is);
      is=null;
    }
    Bitmap crop=null;
    if (decoder != null) {
      BitmapFactory.Options options=new BitmapFactory.Options();
      if (scaleDownSampleSize > 1) {
        options.inSampleSize=scaleDownSampleSize;
      }
      crop=decoder.decodeRegion(roundedTrueCrop,options);
      decoder.recycle();
    }
    if (crop == null) {
      is=regenerateInputStream();
      Bitmap fullSize=null;
      if (is != null) {
        BitmapFactory.Options options=new BitmapFactory.Options();
        if (scaleDownSampleSize > 1) {
          options.inSampleSize=scaleDownSampleSize;
        }
        fullSize=BitmapFactory.decodeStream(is,null,options);
        Utils.closeSilently(is);
      }
      if (fullSize != null) {
        mCropBounds.left/=scaleDownSampleSize;
        mCropBounds.top/=scaleDownSampleSize;
        mCropBounds.bottom/=scaleDownSampleSize;
        mCropBounds.right/=scaleDownSampleSize;
        mCropBounds.roundOut(roundedTrueCrop);
        crop=Bitmap.createBitmap(fullSize,roundedTrueCrop.left,roundedTrueCrop.top,roundedTrueCrop.width(),roundedTrueCrop.height());
      }
    }
    if (crop == null) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
      failure=true;
      return false;
    }
    if (mOutWidth > 0 && mOutHeight > 0 || mRotation > 0) {
      float[] dimsAfter=new float[]{crop.getWidth(),crop.getHeight()};
      rotateMatrix.mapPoints(dimsAfter);
      dimsAfter[0]=Math.abs(dimsAfter[0]);
      dimsAfter[1]=Math.abs(dimsAfter[1]);
      if (!(mOutWidth > 0 && mOutHeight > 0)) {
        mOutWidth=Math.round(dimsAfter[0]);
        mOutHeight=Math.round(dimsAfter[1]);
      }
      RectF cropRect=new RectF(0,0,dimsAfter[0],dimsAfter[1]);
      RectF returnRect=new RectF(0,0,mOutWidth,mOutHeight);
      Matrix m=new Matrix();
      if (mRotation == 0) {
        m.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
      }
 else {
        Matrix m1=new Matrix();
        m1.setTranslate(-crop.getWidth() / 2f,-crop.getHeight() / 2f);
        Matrix m2=new Matrix();
        m2.setRotate(mRotation);
        Matrix m3=new Matrix();
        m3.setTranslate(dimsAfter[0] / 2f,dimsAfter[1] / 2f);
        Matrix m4=new Matrix();
        m4.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
        Matrix c1=new Matrix();
        c1.setConcat(m2,m1);
        Matrix c2=new Matrix();
        c2.setConcat(m4,m3);
        m.setConcat(c2,c1);
      }
      Bitmap tmp=Bitmap.createBitmap((int)returnRect.width(),(int)returnRect.height(),Bitmap.Config.ARGB_8888);
      if (tmp != null) {
        Canvas c=new Canvas(tmp);
        Paint p=new Paint();
        p.setFilterBitmap(true);
        c.drawBitmap(crop,m,p);
        crop=tmp;
      }
    }
    if (mSaveCroppedBitmap) {
      mCroppedBitmap=crop;
    }
    CompressFormat cf=convertExtensionToCompressFormat(getFileExtension(mOutputFormat));
    ByteArrayOutputStream tmpOut=new ByteArrayOutputStream(2048);
    if (crop.compress(cf,DEFAULT_COMPRESS_QUALITY,tmpOut)) {
      if (mSetWallpaper && wallpaperManager != null) {
        try {
          byte[] outByteArray=tmpOut.toByteArray();
          wallpaperManager.setStream(new ByteArrayInputStream(outByteArray));
          if (mOnBitmapCroppedHandler != null) {
            mOnBitmapCroppedHandler.onBitmapCropped(outByteArray);
          }
        }
 catch (        IOException e) {
          Log.w(LOGTAG,""String_Node_Str"",e);
          failure=true;
        }
      }
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
    }
  }
  return !failure;
}","public boolean cropBitmap(){
  boolean failure=false;
  WallpaperManager wallpaperManager=null;
  if (mSetWallpaper) {
    wallpaperManager=WallpaperManager.getInstance(mContext.getApplicationContext());
  }
  if (mSetWallpaper && mNoCrop) {
    try {
      InputStream is=regenerateInputStream();
      if (is != null) {
        wallpaperManager.setStream(is);
        Utils.closeSilently(is);
      }
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"",e);
      failure=true;
    }
    return !failure;
  }
 else {
    Rect roundedTrueCrop=new Rect();
    Matrix rotateMatrix=new Matrix();
    Matrix inverseRotateMatrix=new Matrix();
    Point bounds=getImageBounds();
    if (mRotation > 0) {
      rotateMatrix.setRotate(mRotation);
      inverseRotateMatrix.setRotate(-mRotation);
      mCropBounds.roundOut(roundedTrueCrop);
      mCropBounds=new RectF(roundedTrueCrop);
      if (bounds == null) {
        Log.w(LOGTAG,""String_Node_Str"");
        failure=true;
        return false;
      }
      float[] rotatedBounds=new float[]{bounds.x,bounds.y};
      rotateMatrix.mapPoints(rotatedBounds);
      rotatedBounds[0]=Math.abs(rotatedBounds[0]);
      rotatedBounds[1]=Math.abs(rotatedBounds[1]);
      mCropBounds.offset(-rotatedBounds[0] / 2,-rotatedBounds[1] / 2);
      inverseRotateMatrix.mapRect(mCropBounds);
      mCropBounds.offset(bounds.x / 2,bounds.y / 2);
    }
    mCropBounds.roundOut(roundedTrueCrop);
    if (roundedTrueCrop.width() <= 0 || roundedTrueCrop.height() <= 0) {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
      return false;
    }
    int scaleDownSampleSize=Math.max(1,Math.min(roundedTrueCrop.width() / mOutWidth,roundedTrueCrop.height() / mOutHeight));
    BitmapRegionDecoder decoder=null;
    InputStream is=null;
    try {
      is=regenerateInputStream();
      if (is == null) {
        Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
        failure=true;
        return false;
      }
      decoder=BitmapRegionDecoder.newInstance(is,false);
      Utils.closeSilently(is);
    }
 catch (    IOException e) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString(),e);
    }
 finally {
      Utils.closeSilently(is);
      is=null;
    }
    Bitmap crop=null;
    if (decoder != null) {
      BitmapFactory.Options options=new BitmapFactory.Options();
      if (scaleDownSampleSize > 1) {
        options.inSampleSize=scaleDownSampleSize;
      }
      crop=decoder.decodeRegion(roundedTrueCrop,options);
      decoder.recycle();
    }
    if (crop == null) {
      is=regenerateInputStream();
      Bitmap fullSize=null;
      if (is != null) {
        BitmapFactory.Options options=new BitmapFactory.Options();
        if (scaleDownSampleSize > 1) {
          options.inSampleSize=scaleDownSampleSize;
        }
        fullSize=BitmapFactory.decodeStream(is,null,options);
        Utils.closeSilently(is);
      }
      if (fullSize != null) {
        scaleDownSampleSize=bounds.x / fullSize.getWidth();
        mCropBounds.left/=scaleDownSampleSize;
        mCropBounds.top/=scaleDownSampleSize;
        mCropBounds.bottom/=scaleDownSampleSize;
        mCropBounds.right/=scaleDownSampleSize;
        mCropBounds.roundOut(roundedTrueCrop);
        if (roundedTrueCrop.width() > fullSize.getWidth()) {
          roundedTrueCrop.right=roundedTrueCrop.left + fullSize.getWidth();
        }
        if (roundedTrueCrop.right > fullSize.getWidth()) {
          int adjustment=roundedTrueCrop.left - Math.max(0,roundedTrueCrop.right - roundedTrueCrop.width());
          roundedTrueCrop.left-=adjustment;
          roundedTrueCrop.right-=adjustment;
        }
        if (roundedTrueCrop.height() > fullSize.getHeight()) {
          roundedTrueCrop.bottom=roundedTrueCrop.top + fullSize.getHeight();
        }
        if (roundedTrueCrop.bottom > fullSize.getHeight()) {
          int adjustment=roundedTrueCrop.top - Math.max(0,roundedTrueCrop.bottom - roundedTrueCrop.height());
          roundedTrueCrop.top-=adjustment;
          roundedTrueCrop.bottom-=adjustment;
        }
        crop=Bitmap.createBitmap(fullSize,roundedTrueCrop.left,roundedTrueCrop.top,roundedTrueCrop.width(),roundedTrueCrop.height());
      }
    }
    if (crop == null) {
      Log.w(LOGTAG,""String_Node_Str"" + mInUri.toString());
      failure=true;
      return false;
    }
    if (mOutWidth > 0 && mOutHeight > 0 || mRotation > 0) {
      float[] dimsAfter=new float[]{crop.getWidth(),crop.getHeight()};
      rotateMatrix.mapPoints(dimsAfter);
      dimsAfter[0]=Math.abs(dimsAfter[0]);
      dimsAfter[1]=Math.abs(dimsAfter[1]);
      if (!(mOutWidth > 0 && mOutHeight > 0)) {
        mOutWidth=Math.round(dimsAfter[0]);
        mOutHeight=Math.round(dimsAfter[1]);
      }
      RectF cropRect=new RectF(0,0,dimsAfter[0],dimsAfter[1]);
      RectF returnRect=new RectF(0,0,mOutWidth,mOutHeight);
      Matrix m=new Matrix();
      if (mRotation == 0) {
        m.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
      }
 else {
        Matrix m1=new Matrix();
        m1.setTranslate(-crop.getWidth() / 2f,-crop.getHeight() / 2f);
        Matrix m2=new Matrix();
        m2.setRotate(mRotation);
        Matrix m3=new Matrix();
        m3.setTranslate(dimsAfter[0] / 2f,dimsAfter[1] / 2f);
        Matrix m4=new Matrix();
        m4.setRectToRect(cropRect,returnRect,Matrix.ScaleToFit.FILL);
        Matrix c1=new Matrix();
        c1.setConcat(m2,m1);
        Matrix c2=new Matrix();
        c2.setConcat(m4,m3);
        m.setConcat(c2,c1);
      }
      Bitmap tmp=Bitmap.createBitmap((int)returnRect.width(),(int)returnRect.height(),Bitmap.Config.ARGB_8888);
      if (tmp != null) {
        Canvas c=new Canvas(tmp);
        Paint p=new Paint();
        p.setFilterBitmap(true);
        c.drawBitmap(crop,m,p);
        crop=tmp;
      }
    }
    if (mSaveCroppedBitmap) {
      mCroppedBitmap=crop;
    }
    CompressFormat cf=convertExtensionToCompressFormat(getFileExtension(mOutputFormat));
    ByteArrayOutputStream tmpOut=new ByteArrayOutputStream(2048);
    if (crop.compress(cf,DEFAULT_COMPRESS_QUALITY,tmpOut)) {
      if (mSetWallpaper && wallpaperManager != null) {
        try {
          byte[] outByteArray=tmpOut.toByteArray();
          wallpaperManager.setStream(new ByteArrayInputStream(outByteArray));
          if (mOnBitmapCroppedHandler != null) {
            mOnBitmapCroppedHandler.onBitmapCropped(outByteArray);
          }
        }
 catch (        IOException e) {
          Log.w(LOGTAG,""String_Node_Str"",e);
          failure=true;
        }
      }
    }
 else {
      Log.w(LOGTAG,""String_Node_Str"");
      failure=true;
    }
  }
  return !failure;
}",0.9224096385542168
199546,"public void run(){
  int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
  int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
  wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
}","public void run(){
  updateWallpaperDimensions(outWidth,outHeight);
  if (finishActivityWhenDone) {
    setResult(Activity.RESULT_OK);
    finish();
  }
}",0.2899262899262899
199547,"static public void suggestWallpaperDimension(Resources res,final SharedPreferences sharedPrefs,WindowManager windowManager,final WallpaperManager wallpaperManager){
  final Point defaultWallpaperSize=getDefaultWallpaperSize(res,windowManager);
  new Thread(""String_Node_Str""){
    public void run(){
      int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
      int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
      wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
    }
  }
.start();
}","static public void suggestWallpaperDimension(Resources res,final SharedPreferences sharedPrefs,WindowManager windowManager,final WallpaperManager wallpaperManager){
  final Point defaultWallpaperSize=getDefaultWallpaperSize(res,windowManager);
  new AsyncTask<Void,Void,Void>(){
    public Void doInBackground(    Void... args){
      int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
      int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
      wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
      return null;
    }
  }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,(Void)null);
}",0.8564476885644768
199548,"@Override protected Boolean doInBackground(Void... params){
  return cropBitmap();
}","public Void doInBackground(Void... args){
  int savedWidth=sharedPrefs.getInt(WALLPAPER_WIDTH_KEY,defaultWallpaperSize.x);
  int savedHeight=sharedPrefs.getInt(WALLPAPER_HEIGHT_KEY,defaultWallpaperSize.y);
  wallpaperManager.suggestDesiredDimensions(savedWidth,savedHeight);
  return null;
}",0.1546666666666666
199549,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199550,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mActionBarTop.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionBarView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    mContent.dispatchApplyWindowInsets(new WindowInsets(mInnerInsets));
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mActionBarTop.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() != GONE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionBarView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    mContent.dispatchApplyWindowInsets(new WindowInsets(mInnerInsets));
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}",0.9975494200294068
199551,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mActionBarTop.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionBarView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    mContent.dispatchApplyWindowInsets(new WindowInsets(mInnerInsets));
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mActionBarTop.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() != GONE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionBarView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    mContent.dispatchApplyWindowInsets(new WindowInsets(mInnerInsets));
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}",0.9975494200294068
199552,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mActionBarTop.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() == VISIBLE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionBarView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    mContent.dispatchApplyWindowInsets(new WindowInsets(mInnerInsets));
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  pullChildren();
  int maxHeight=0;
  int maxWidth=0;
  int childState=0;
  int topInset=0;
  int bottomInset=0;
  measureChildWithMargins(mActionBarTop,widthMeasureSpec,0,heightMeasureSpec,0);
  LayoutParams lp=(LayoutParams)mActionBarTop.getLayoutParams();
  maxWidth=Math.max(maxWidth,mActionBarTop.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mActionBarTop.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mActionBarTop.getMeasuredState());
  if (mActionBarBottom != null) {
    measureChildWithMargins(mActionBarBottom,widthMeasureSpec,0,heightMeasureSpec,0);
    lp=(LayoutParams)mActionBarBottom.getLayoutParams();
    maxWidth=Math.max(maxWidth,mActionBarBottom.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
    maxHeight=Math.max(maxHeight,mActionBarBottom.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
    childState=combineMeasuredStates(childState,mActionBarBottom.getMeasuredState());
  }
  final int vis=getWindowSystemUiVisibility();
  final boolean stable=(vis & SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0;
  if (stable) {
    topInset=mActionBarHeight;
    if (mActionBar != null && mActionBar.hasNonEmbeddedTabs()) {
      View tabs=mActionBarTop.getTabContainer();
      if (tabs != null) {
        topInset+=mActionBarHeight;
      }
    }
  }
 else   if (mActionBarTop.getVisibility() != GONE) {
    topInset=mActionBarTop.getMeasuredHeight();
  }
  if (mActionBarView.isSplitActionBar()) {
    if (mActionBarBottom != null) {
      if (stable) {
        bottomInset=mActionBarHeight;
      }
 else {
        bottomInset=mActionBarBottom.getMeasuredHeight();
      }
    }
  }
  mContentInsets.set(mBaseContentInsets);
  mInnerInsets.set(mBaseInnerInsets);
  if (!mOverlayMode && !stable) {
    mContentInsets.top+=topInset;
    mContentInsets.bottom+=bottomInset;
  }
 else {
    mInnerInsets.top+=topInset;
    mInnerInsets.bottom+=bottomInset;
  }
  applyInsets(mContent,mContentInsets,true,true,true,true);
  if (!mLastInnerInsets.equals(mInnerInsets)) {
    mLastInnerInsets.set(mInnerInsets);
    mContent.dispatchApplyWindowInsets(new WindowInsets(mInnerInsets));
  }
  measureChildWithMargins(mContent,widthMeasureSpec,0,heightMeasureSpec,0);
  lp=(LayoutParams)mContent.getLayoutParams();
  maxWidth=Math.max(maxWidth,mContent.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
  maxHeight=Math.max(maxHeight,mContent.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
  childState=combineMeasuredStates(childState,mContent.getMeasuredState());
  maxWidth+=getPaddingLeft() + getPaddingRight();
  maxHeight+=getPaddingTop() + getPaddingBottom();
  maxHeight=Math.max(maxHeight,getSuggestedMinimumHeight());
  maxWidth=Math.max(maxWidth,getSuggestedMinimumWidth());
  setMeasuredDimension(resolveSizeAndState(maxWidth,widthMeasureSpec,childState),resolveSizeAndState(maxHeight,heightMeasureSpec,childState << MEASURED_HEIGHT_STATE_SHIFT));
}",0.9975494200294068
199553,"/** 
 * Toggles the alternate recents activity 
 */
public void onToggleRecents(Display display,int layoutDirection,View statusBarView){
  Console.log(Constants.DebugFlags.App.RecentsComponent,""String_Node_Str"",""String_Node_Str"" + mServiceIsBound);
  mStatusBarView=statusBarView;
  if (!mServiceIsBound) {
    bindToRecentsService(true);
    return;
  }
  try {
    startAlternateRecentsActivity();
  }
 catch (  ActivityNotFoundException e) {
    Console.logRawError(""String_Node_Str"",e);
  }
}","/** 
 * Toggles the alternate recents activity 
 */
public void onToggleRecents(Display display,int layoutDirection,View statusBarView){
  Console.logStartTracingTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey);
  Console.logStartTracingTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey);
  Console.log(Constants.DebugFlags.App.RecentsComponent,""String_Node_Str"",""String_Node_Str"" + mServiceIsBound);
  mStatusBarView=statusBarView;
  if (!mServiceIsBound) {
    bindToRecentsService(true);
    return;
  }
  try {
    startAlternateRecentsActivity();
  }
 catch (  ActivityNotFoundException e) {
    Console.logRawError(""String_Node_Str"",e);
  }
}",0.8
199554,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  WindowManager.LayoutParams wlp=getWindow().getAttributes();
  wlp.dimAmount=Constants.Values.Window.BackgroundDim;
  getWindow().setAttributes(wlp);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
  mRecentsView=new RecentsView(this);
  mRecentsView.setCallbacks(this);
  mRecentsView.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT));
  LayoutInflater inflater=LayoutInflater.from(this);
  mEmptyView=inflater.inflate(R.layout.recents_empty,mContainerView,false);
  mContainerView=new FrameLayout(this);
  mContainerView.addView(mRecentsView);
  mContainerView.addView(mEmptyView);
  setContentView(mContainerView);
  updateRecentsTasks();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  WindowManager.LayoutParams wlp=getWindow().getAttributes();
  wlp.dimAmount=Constants.Values.Window.BackgroundDim;
  getWindow().setAttributes(wlp);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
  mRecentsView=new RecentsView(this);
  mRecentsView.setCallbacks(this);
  mRecentsView.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT));
  LayoutInflater inflater=LayoutInflater.from(this);
  mEmptyView=inflater.inflate(R.layout.recents_empty,mContainerView,false);
  mContainerView=new FrameLayout(this);
  mContainerView.addView(mRecentsView);
  mContainerView.addView(mEmptyView);
  setContentView(mContainerView);
  updateRecentsTasks();
}",0.9464856230031948
199555,"@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  updateRecentsTasks();
}","@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  updateRecentsTasks();
}",0.8624229979466119
199556,"@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
    Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
    Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  }
}",0.913126188966392
199557,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",new Rect(left,top,right,bottom) + ""String_Node_Str"" + changed,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  top+=config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      child.layout(left,top,left + width,top + height);
    }
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",new Rect(left,top,right,bottom) + ""String_Node_Str"" + changed,Console.AnsiGreen);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  top+=config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      child.layout(left,top,left + width,top + height);
    }
  }
}",0.9075862068965516
199558,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=transform.rect.top;
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  if (opts != null) {
    getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
  }
 else {
    getContext().startActivityAsUser(i,UserHandle.CURRENT);
  }
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=transform.rect.top;
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  if (opts != null) {
    getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
  }
 else {
    getContext().startActivityAsUser(i,UserHandle.CURRENT);
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.9526132404181183
199559,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  int childHeight=height - config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      child.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight,heightMode));
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height,Console.AnsiGreen);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  int childHeight=height - config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      child.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight,heightMode));
    }
  }
  setMeasuredDimension(width,height);
}",0.9223638470451913
199560,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=transform.rect.top;
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
  }
;
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=transform.rect.top;
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9342857142857144
199561,"/** 
 * Animates this task view as it exits recents 
 */
public void animateOnLeavingRecents(final Runnable r){
  if (Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingUseClip) {
    mIconView.animateCircularClip(false,0f,Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration,0,new DecelerateInterpolator(),new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
);
  }
 else {
    mIconView.animate().alpha(0f).setDuration(Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration).setInterpolator(new DecelerateInterpolator()).setListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
).start();
  }
}","/** 
 * Animates this task view as it exits recents 
 */
public void animateOnLeavingRecents(final Runnable r){
  if (Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingUseClip) {
    mIconView.animateCircularClip(false,0f,Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration,0,new DecelerateInterpolator(),new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
);
  }
 else {
    mIconView.animate().alpha(0f).setStartDelay(0).setDuration(Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration).setInterpolator(new DecelerateInterpolator()).setListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
).start();
  }
}",0.989247311827957
199562,"/** 
 * Toggles the alternate recents activity 
 */
public void onToggleRecents(Display display,int layoutDirection,View statusBarView){
  Console.log(Constants.DebugFlags.App.RecentsComponent,""String_Node_Str"",""String_Node_Str"" + mServiceIsBound);
  mStatusBarView=statusBarView;
  if (!mServiceIsBound) {
    bindToRecentsService(true);
    return;
  }
  try {
    startAlternateRecentsActivity();
  }
 catch (  ActivityNotFoundException e) {
    Console.logRawError(""String_Node_Str"",e);
  }
}","/** 
 * Toggles the alternate recents activity 
 */
public void onToggleRecents(Display display,int layoutDirection,View statusBarView){
  Console.logStartTracingTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey);
  Console.logStartTracingTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey);
  Console.log(Constants.DebugFlags.App.RecentsComponent,""String_Node_Str"",""String_Node_Str"" + mServiceIsBound);
  mStatusBarView=statusBarView;
  if (!mServiceIsBound) {
    bindToRecentsService(true);
    return;
  }
  try {
    startAlternateRecentsActivity();
  }
 catch (  ActivityNotFoundException e) {
    Console.logRawError(""String_Node_Str"",e);
  }
}",0.8
199563,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  WindowManager.LayoutParams wlp=getWindow().getAttributes();
  wlp.dimAmount=Constants.Values.Window.BackgroundDim;
  getWindow().setAttributes(wlp);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
  mRecentsView=new RecentsView(this);
  mRecentsView.setCallbacks(this);
  mRecentsView.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT));
  LayoutInflater inflater=LayoutInflater.from(this);
  mEmptyView=inflater.inflate(R.layout.recents_empty,mContainerView,false);
  mContainerView=new FrameLayout(this);
  mContainerView.addView(mRecentsView);
  mContainerView.addView(mEmptyView);
  setContentView(mContainerView);
  updateRecentsTasks();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  WindowManager.LayoutParams wlp=getWindow().getAttributes();
  wlp.dimAmount=Constants.Values.Window.BackgroundDim;
  getWindow().setAttributes(wlp);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
  mRecentsView=new RecentsView(this);
  mRecentsView.setCallbacks(this);
  mRecentsView.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT));
  LayoutInflater inflater=LayoutInflater.from(this);
  mEmptyView=inflater.inflate(R.layout.recents_empty,mContainerView,false);
  mContainerView=new FrameLayout(this);
  mContainerView.addView(mRecentsView);
  mContainerView.addView(mEmptyView);
  setContentView(mContainerView);
  updateRecentsTasks();
}",0.9464856230031948
199564,"@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  updateRecentsTasks();
}","@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  updateRecentsTasks();
}",0.8624229979466119
199565,"@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
    Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
    Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  }
}",0.913126188966392
199566,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",new Rect(left,top,right,bottom) + ""String_Node_Str"" + changed,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  top+=config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      child.layout(left,top,left + width,top + height);
    }
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",new Rect(left,top,right,bottom) + ""String_Node_Str"" + changed,Console.AnsiGreen);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  top+=config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      child.layout(left,top,left + width,top + height);
    }
  }
}",0.9075862068965516
199567,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=transform.rect.top;
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  if (opts != null) {
    getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
  }
 else {
    getContext().startActivityAsUser(i,UserHandle.CURRENT);
  }
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=transform.rect.top;
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  if (opts != null) {
    getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
  }
 else {
    getContext().startActivityAsUser(i,UserHandle.CURRENT);
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.9526132404181183
199568,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  int childHeight=height - config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      child.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight,heightMode));
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height,Console.AnsiGreen);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  int childHeight=height - config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      child.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight,heightMode));
    }
  }
  setMeasuredDimension(width,height);
}",0.9223638470451913
199569,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=transform.rect.top;
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
  }
;
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=transform.rect.top;
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9342857142857144
199570,"/** 
 * Animates this task view as it exits recents 
 */
public void animateOnLeavingRecents(final Runnable r){
  if (Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingUseClip) {
    mIconView.animateCircularClip(false,0f,Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration,0,new DecelerateInterpolator(),new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
);
  }
 else {
    mIconView.animate().alpha(0f).setDuration(Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration).setInterpolator(new DecelerateInterpolator()).setListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
).start();
  }
}","/** 
 * Animates this task view as it exits recents 
 */
public void animateOnLeavingRecents(final Runnable r){
  if (Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingUseClip) {
    mIconView.animateCircularClip(false,0f,Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration,0,new DecelerateInterpolator(),new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
);
  }
 else {
    mIconView.animate().alpha(0f).setStartDelay(0).setDuration(Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration).setInterpolator(new DecelerateInterpolator()).setListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
).start();
  }
}",0.989247311827957
199571,"/** 
 * Toggles the alternate recents activity 
 */
public void onToggleRecents(Display display,int layoutDirection,View statusBarView){
  Console.log(Constants.DebugFlags.App.RecentsComponent,""String_Node_Str"",""String_Node_Str"" + mServiceIsBound);
  mStatusBarView=statusBarView;
  if (!mServiceIsBound) {
    bindToRecentsService(true);
    return;
  }
  try {
    startAlternateRecentsActivity();
  }
 catch (  ActivityNotFoundException e) {
    Console.logRawError(""String_Node_Str"",e);
  }
}","/** 
 * Toggles the alternate recents activity 
 */
public void onToggleRecents(Display display,int layoutDirection,View statusBarView){
  Console.logStartTracingTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey);
  Console.logStartTracingTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey);
  Console.log(Constants.DebugFlags.App.RecentsComponent,""String_Node_Str"",""String_Node_Str"" + mServiceIsBound);
  mStatusBarView=statusBarView;
  if (!mServiceIsBound) {
    bindToRecentsService(true);
    return;
  }
  try {
    startAlternateRecentsActivity();
  }
 catch (  ActivityNotFoundException e) {
    Console.logRawError(""String_Node_Str"",e);
  }
}",0.8
199572,"/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  WindowManager.LayoutParams wlp=getWindow().getAttributes();
  wlp.dimAmount=Constants.Values.Window.BackgroundDim;
  getWindow().setAttributes(wlp);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
  mRecentsView=new RecentsView(this);
  mRecentsView.setCallbacks(this);
  mRecentsView.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT));
  LayoutInflater inflater=LayoutInflater.from(this);
  mEmptyView=inflater.inflate(R.layout.recents_empty,mContainerView,false);
  mContainerView=new FrameLayout(this);
  mContainerView.addView(mRecentsView);
  mContainerView.addView(mEmptyView);
  setContentView(mContainerView);
  updateRecentsTasks();
}","/** 
 * Called with the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",getIntent().getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  WindowManager.LayoutParams wlp=getWindow().getAttributes();
  wlp.dimAmount=Constants.Values.Window.BackgroundDim;
  getWindow().setAttributes(wlp);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
  mRecentsView=new RecentsView(this);
  mRecentsView.setCallbacks(this);
  mRecentsView.setLayoutParams(new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT));
  LayoutInflater inflater=LayoutInflater.from(this);
  mEmptyView=inflater.inflate(R.layout.recents_empty,mContainerView,false);
  mContainerView=new FrameLayout(this);
  mContainerView.addView(mRecentsView);
  mContainerView.addView(mEmptyView);
  setContentView(mContainerView);
  updateRecentsTasks();
}",0.9464856230031948
199573,"@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  updateRecentsTasks();
}","@Override protected void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  mTaskLaunched=false;
  Console.logDivider(Constants.DebugFlags.App.SystemUIHandshake);
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",intent.getAction() + ""String_Node_Str"" + mVisible,Console.AnsiRed);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsTaskLoader.initialize(this);
  RecentsConfiguration.reinitialize(this);
  updateRecentsTasks();
}",0.8624229979466119
199574,"@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
    Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
    Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  }
}",0.913126188966392
199575,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",new Rect(left,top,right,bottom) + ""String_Node_Str"" + changed,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  top+=config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      child.layout(left,top,left + width,top + height);
    }
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",new Rect(left,top,right,bottom) + ""String_Node_Str"" + changed,Console.AnsiGreen);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  top+=config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      child.layout(left,top,left + width,top + height);
    }
  }
}",0.9075862068965516
199576,"@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=transform.rect.top;
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  if (opts != null) {
    getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
  }
 else {
    getContext().startActivityAsUser(i,UserHandle.CURRENT);
  }
}","@Override public void run(){
  TaskViewTransform transform;
  View sourceView=tv;
  int offsetX=0;
  int offsetY=0;
  if (tv == null) {
    sourceView=stackView;
    transform=stackView.getStackTransform(stack.indexOfTask(task));
    offsetX=transform.rect.left;
    offsetY=transform.rect.top;
  }
 else {
    transform=stackView.getStackTransform(stack.indexOfTask(task));
  }
  ActivityOptions opts=null;
  int thumbnailWidth=transform.rect.width();
  int thumbnailHeight=transform.rect.height();
  if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
    Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
    Canvas c=new Canvas(b);
    c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
    c.setBitmap(null);
    opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
  }
  Intent i=new Intent(task.key.intent);
  i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
  if (opts != null) {
    getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
  }
 else {
    getContext().startActivityAsUser(i,UserHandle.CURRENT);
  }
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
}",0.9526132404181183
199577,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  int childHeight=height - config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      child.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight,heightMode));
    }
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height,Console.AnsiGreen);
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsStartup,Constants.DebugFlags.App.TimeRecentsStartupKey,""String_Node_Str"");
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  int childHeight=height - config.systemInsets.top;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      child.measure(widthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight,heightMode));
    }
  }
  setMeasuredDimension(width,height);
}",0.9223638470451913
199578,"/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=transform.rect.top;
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
    }
  }
;
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}","/** 
 * TaskStackView.TaskStackCallbacks Implementation 
 */
@Override public void onTaskLaunched(final TaskStackView stackView,final TaskView tv,final TaskStack stack,final Task task){
  if (mCb != null) {
    mCb.onTaskLaunching();
  }
  final Runnable launchRunnable=new Runnable(){
    @Override public void run(){
      TaskViewTransform transform;
      View sourceView=tv;
      int offsetX=0;
      int offsetY=0;
      if (tv == null) {
        sourceView=stackView;
        transform=stackView.getStackTransform(stack.indexOfTask(task));
        offsetX=transform.rect.left;
        offsetY=transform.rect.top;
      }
 else {
        transform=stackView.getStackTransform(stack.indexOfTask(task));
      }
      ActivityOptions opts=null;
      int thumbnailWidth=transform.rect.width();
      int thumbnailHeight=transform.rect.height();
      if (task.thumbnail != null && thumbnailWidth > 0 && thumbnailHeight > 0 && task.thumbnail.getWidth() > 0 && task.thumbnail.getHeight() > 0) {
        Bitmap b=Bitmap.createBitmap(thumbnailWidth,thumbnailHeight,Bitmap.Config.ARGB_8888);
        Canvas c=new Canvas(b);
        c.drawBitmap(task.thumbnail,new Rect(0,0,task.thumbnail.getWidth(),task.thumbnail.getHeight()),new Rect(0,0,thumbnailWidth,thumbnailHeight),null);
        c.setBitmap(null);
        opts=ActivityOptions.makeThumbnailScaleUpAnimation(sourceView,b,offsetX,offsetY);
      }
      Intent i=new Intent(task.key.intent);
      i.setFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY | Intent.FLAG_ACTIVITY_TASK_ON_HOME | Intent.FLAG_ACTIVITY_NEW_TASK);
      if (opts != null) {
        getContext().startActivityAsUser(i,opts.toBundle(),UserHandle.CURRENT);
      }
 else {
        getContext().startActivityAsUser(i,UserHandle.CURRENT);
      }
      Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
    }
  }
;
  Console.logTraceTime(Constants.DebugFlags.App.TimeRecentsLaunchTask,Constants.DebugFlags.App.TimeRecentsLaunchKey,""String_Node_Str"");
  if (tv == null || !Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingRecents) {
    post(launchRunnable);
  }
 else {
    tv.animateOnLeavingRecents(launchRunnable);
  }
}",0.9342857142857144
199579,"/** 
 * Animates this task view as it exits recents 
 */
public void animateOnLeavingRecents(final Runnable r){
  if (Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingUseClip) {
    mIconView.animateCircularClip(false,0f,Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration,0,new DecelerateInterpolator(),new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
);
  }
 else {
    mIconView.animate().alpha(0f).setDuration(Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration).setInterpolator(new DecelerateInterpolator()).setListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
).start();
  }
}","/** 
 * Animates this task view as it exits recents 
 */
public void animateOnLeavingRecents(final Runnable r){
  if (Constants.Values.TaskView.AnimateFrontTaskIconOnLeavingUseClip) {
    mIconView.animateCircularClip(false,0f,Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration,0,new DecelerateInterpolator(),new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
);
  }
 else {
    mIconView.animate().alpha(0f).setStartDelay(0).setDuration(Constants.Values.TaskView.Animation.TaskIconOnLeavingDuration).setInterpolator(new DecelerateInterpolator()).setListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        r.run();
      }
    }
).start();
  }
}",0.989247311827957
199580,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199581,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportFailedUnlockAttempt();
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8337088778729157
199582,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199583,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199584,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199585,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199586,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199587,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportFailedUnlockAttempt();
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8337088778729157
199588,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199589,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199590,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199591,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199592,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199593,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportFailedUnlockAttempt();
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8337088778729157
199594,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199595,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199596,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199597,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199598,"@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      RecentsConfiguration.getInstance().updateSystemInsets(systemInsets);
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}",0.9739248222146968
199599,"/** 
 * Computes the stack and task rects 
 */
public void computeRects(int width,int height){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  mRect.set(0,0,width,height);
  mStackRect.set(mRect);
  mStackRect.bottom-=config.systemInsets.bottom;
  int smallestDimension=Math.min(width,height);
  int padding=(int)(Constants.Values.TaskStackView.StackPaddingPct * smallestDimension / 2f);
  mStackRect.inset(padding,padding);
  mStackRectSansPeek.set(mStackRect);
  mStackRectSansPeek.top+=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  int minHeight=(int)(mStackRect.height() - (Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height()));
  int size=Math.min(minHeight,Math.min(mStackRect.width(),mStackRect.height()));
  int centerX=mStackRect.centerX();
  mTaskRect.set(centerX - size / 2,mStackRectSansPeek.top,centerX + size / 2,mStackRectSansPeek.top + size);
  updateMinMaxScroll(false);
}","/** 
 * Computes the stack and task rects 
 */
public void computeRects(int width,int height,int insetBottom){
  mRect.set(0,0,width,height);
  mStackRect.set(mRect);
  mStackRect.bottom-=insetBottom;
  int smallestDimension=Math.min(width,height);
  int padding=(int)(Constants.Values.TaskStackView.StackPaddingPct * smallestDimension / 2f);
  mStackRect.inset(padding,padding);
  mStackRectSansPeek.set(mStackRect);
  mStackRectSansPeek.top+=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  int minHeight=(int)(mStackRect.height() - (Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height()));
  int size=Math.min(minHeight,Math.min(mStackRect.width(),mStackRect.height()));
  int centerX=mStackRect.centerX();
  mTaskRect.set(centerX - size / 2,mStackRectSansPeek.top,centerX + size / 2,mStackRectSansPeek.top + size);
  updateMinMaxScroll(false);
}",0.9411129119394922
199600,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ mAwaitingFirstLayout,Console.AnsiGreen);
  computeRects(width,height);
  if (Constants.DebugFlags.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mRect);
    Console.log(""String_Node_Str"" + mStackRect);
    Console.log(""String_Node_Str"" + mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mTaskRect);
  }
  if (mAwaitingFirstLayout) {
    setStackScroll(mMaxScroll);
    requestSynchronizeStackViewsWithModel();
    synchronizeStackViewsWithModel();
    if (Constants.Values.TaskView.AnimateFrontTaskIconOnEnterRecents) {
      TaskView tv=(TaskView)getChildAt(getChildCount() - 1);
      if (tv != null) {
        tv.animateOnEnterRecents();
      }
    }
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.measure(MeasureSpec.makeMeasureSpec(mTaskRect.width(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mTaskRect.height(),MeasureSpec.EXACTLY));
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ mAwaitingFirstLayout,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  computeRects(width,height,config.systemInsets.bottom);
  if (Constants.DebugFlags.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mRect);
    Console.log(""String_Node_Str"" + mStackRect);
    Console.log(""String_Node_Str"" + mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mTaskRect);
  }
  if (mAwaitingFirstLayout) {
    setStackScroll(mMaxScroll);
    requestSynchronizeStackViewsWithModel();
    synchronizeStackViewsWithModel();
    if (Constants.Values.TaskView.AnimateFrontTaskIconOnEnterRecents) {
      TaskView tv=(TaskView)getChildAt(getChildCount() - 1);
      if (tv != null) {
        tv.animateOnEnterRecents();
      }
    }
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.measure(MeasureSpec.makeMeasureSpec(mTaskRect.width(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mTaskRect.height(),MeasureSpec.EXACTLY));
  }
  setMeasuredDimension(width,height);
}",0.965896589658966
199601,"@Override protected void onDetachedFromWindow(){
  if (mIndeterminate) {
    stopAnimation();
  }
  if (mRefreshProgressRunnable != null) {
    removeCallbacks(mRefreshProgressRunnable);
  }
  if (mRefreshProgressRunnable != null && mRefreshIsPosted) {
    removeCallbacks(mRefreshProgressRunnable);
  }
  if (mAccessibilityEventSender != null) {
    removeCallbacks(mAccessibilityEventSender);
  }
  super.onDetachedFromWindow();
  mAttached=false;
}","@Override protected void onDetachedFromWindow(){
  if (mIndeterminate) {
    stopAnimation();
  }
  if (mRefreshProgressRunnable != null) {
    removeCallbacks(mRefreshProgressRunnable);
    mRefreshIsPosted=false;
  }
  if (mAccessibilityEventSender != null) {
    removeCallbacks(mAccessibilityEventSender);
  }
  super.onDetachedFromWindow();
  mAttached=false;
}",0.6291309669522643
199602,"@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      RecentsConfiguration.getInstance().updateSystemInsets(systemInsets);
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}",0.9739248222146968
199603,"/** 
 * Computes the stack and task rects 
 */
public void computeRects(int width,int height){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  mRect.set(0,0,width,height);
  mStackRect.set(mRect);
  mStackRect.bottom-=config.systemInsets.bottom;
  int smallestDimension=Math.min(width,height);
  int padding=(int)(Constants.Values.TaskStackView.StackPaddingPct * smallestDimension / 2f);
  mStackRect.inset(padding,padding);
  mStackRectSansPeek.set(mStackRect);
  mStackRectSansPeek.top+=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  int minHeight=(int)(mStackRect.height() - (Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height()));
  int size=Math.min(minHeight,Math.min(mStackRect.width(),mStackRect.height()));
  int centerX=mStackRect.centerX();
  mTaskRect.set(centerX - size / 2,mStackRectSansPeek.top,centerX + size / 2,mStackRectSansPeek.top + size);
  updateMinMaxScroll(false);
}","/** 
 * Computes the stack and task rects 
 */
public void computeRects(int width,int height,int insetBottom){
  mRect.set(0,0,width,height);
  mStackRect.set(mRect);
  mStackRect.bottom-=insetBottom;
  int smallestDimension=Math.min(width,height);
  int padding=(int)(Constants.Values.TaskStackView.StackPaddingPct * smallestDimension / 2f);
  mStackRect.inset(padding,padding);
  mStackRectSansPeek.set(mStackRect);
  mStackRectSansPeek.top+=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  int minHeight=(int)(mStackRect.height() - (Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height()));
  int size=Math.min(minHeight,Math.min(mStackRect.width(),mStackRect.height()));
  int centerX=mStackRect.centerX();
  mTaskRect.set(centerX - size / 2,mStackRectSansPeek.top,centerX + size / 2,mStackRectSansPeek.top + size);
  updateMinMaxScroll(false);
}",0.9411129119394922
199604,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ mAwaitingFirstLayout,Console.AnsiGreen);
  computeRects(width,height);
  if (Constants.DebugFlags.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mRect);
    Console.log(""String_Node_Str"" + mStackRect);
    Console.log(""String_Node_Str"" + mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mTaskRect);
  }
  if (mAwaitingFirstLayout) {
    setStackScroll(mMaxScroll);
    requestSynchronizeStackViewsWithModel();
    synchronizeStackViewsWithModel();
    if (Constants.Values.TaskView.AnimateFrontTaskIconOnEnterRecents) {
      TaskView tv=(TaskView)getChildAt(getChildCount() - 1);
      if (tv != null) {
        tv.animateOnEnterRecents();
      }
    }
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.measure(MeasureSpec.makeMeasureSpec(mTaskRect.width(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mTaskRect.height(),MeasureSpec.EXACTLY));
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ mAwaitingFirstLayout,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  computeRects(width,height,config.systemInsets.bottom);
  if (Constants.DebugFlags.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mRect);
    Console.log(""String_Node_Str"" + mStackRect);
    Console.log(""String_Node_Str"" + mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mTaskRect);
  }
  if (mAwaitingFirstLayout) {
    setStackScroll(mMaxScroll);
    requestSynchronizeStackViewsWithModel();
    synchronizeStackViewsWithModel();
    if (Constants.Values.TaskView.AnimateFrontTaskIconOnEnterRecents) {
      TaskView tv=(TaskView)getChildAt(getChildCount() - 1);
      if (tv != null) {
        tv.animateOnEnterRecents();
      }
    }
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.measure(MeasureSpec.makeMeasureSpec(mTaskRect.width(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mTaskRect.height(),MeasureSpec.EXACTLY));
  }
  setMeasuredDimension(width,height);
}",0.965896589658966
199605,"@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      RecentsConfiguration.getInstance().updateSystemInsets(systemInsets);
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}","@Override public void handleMessage(Message msg){
  Console.log(Constants.DebugFlags.App.SystemUIHandshake,""String_Node_Str"",msg);
  Context context=mContext.get();
  if (context == null)   return;
  if (msg.what == RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION) {
    RecentsTaskLoader.initialize(context);
    RecentsConfiguration.reinitialize(context);
    try {
      Bundle data=msg.getData();
      Rect windowRect=(Rect)data.getParcelable(""String_Node_Str"");
      Rect systemInsets=(Rect)data.getParcelable(""String_Node_Str"");
      TaskStack stack=new TaskStack(context);
      TaskStackView tsv=new TaskStackView(context,stack);
      tsv.computeRects(windowRect.width(),windowRect.height() - systemInsets.top,0);
      tsv.boundScroll();
      TaskViewTransform transform=tsv.getStackTransform(0);
      Rect taskRect=new Rect(transform.rect);
      data.putParcelable(""String_Node_Str"",taskRect);
      Message reply=Message.obtain(null,RecentsService.MSG_UPDATE_RECENTS_FOR_CONFIGURATION,0,0);
      reply.setData(data);
      msg.replyTo.send(reply);
    }
 catch (    RemoteException re) {
      re.printStackTrace();
    }
  }
 else   if (msg.what == RecentsService.MSG_CLOSE_RECENTS) {
  }
 else   if (msg.what == RecentsService.MSG_TOGGLE_RECENTS) {
    Intent intent=new Intent(RecentsService.ACTION_TOGGLE_RECENTS_ACTIVITY);
    intent.setPackage(context.getPackageName());
    context.sendBroadcast(intent);
  }
}",0.9739248222146968
199606,"/** 
 * Computes the stack and task rects 
 */
public void computeRects(int width,int height){
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  mRect.set(0,0,width,height);
  mStackRect.set(mRect);
  mStackRect.bottom-=config.systemInsets.bottom;
  int smallestDimension=Math.min(width,height);
  int padding=(int)(Constants.Values.TaskStackView.StackPaddingPct * smallestDimension / 2f);
  mStackRect.inset(padding,padding);
  mStackRectSansPeek.set(mStackRect);
  mStackRectSansPeek.top+=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  int minHeight=(int)(mStackRect.height() - (Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height()));
  int size=Math.min(minHeight,Math.min(mStackRect.width(),mStackRect.height()));
  int centerX=mStackRect.centerX();
  mTaskRect.set(centerX - size / 2,mStackRectSansPeek.top,centerX + size / 2,mStackRectSansPeek.top + size);
  updateMinMaxScroll(false);
}","/** 
 * Computes the stack and task rects 
 */
public void computeRects(int width,int height,int insetBottom){
  mRect.set(0,0,width,height);
  mStackRect.set(mRect);
  mStackRect.bottom-=insetBottom;
  int smallestDimension=Math.min(width,height);
  int padding=(int)(Constants.Values.TaskStackView.StackPaddingPct * smallestDimension / 2f);
  mStackRect.inset(padding,padding);
  mStackRectSansPeek.set(mStackRect);
  mStackRectSansPeek.top+=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  int minHeight=(int)(mStackRect.height() - (Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height()));
  int size=Math.min(minHeight,Math.min(mStackRect.width(),mStackRect.height()));
  int centerX=mStackRect.centerX();
  mTaskRect.set(centerX - size / 2,mStackRectSansPeek.top,centerX + size / 2,mStackRectSansPeek.top + size);
  updateMinMaxScroll(false);
}",0.9411129119394922
199607,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ mAwaitingFirstLayout,Console.AnsiGreen);
  computeRects(width,height);
  if (Constants.DebugFlags.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mRect);
    Console.log(""String_Node_Str"" + mStackRect);
    Console.log(""String_Node_Str"" + mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mTaskRect);
  }
  if (mAwaitingFirstLayout) {
    setStackScroll(mMaxScroll);
    requestSynchronizeStackViewsWithModel();
    synchronizeStackViewsWithModel();
    if (Constants.Values.TaskView.AnimateFrontTaskIconOnEnterRecents) {
      TaskView tv=(TaskView)getChildAt(getChildCount() - 1);
      if (tv != null) {
        tv.animateOnEnterRecents();
      }
    }
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.measure(MeasureSpec.makeMeasureSpec(mTaskRect.width(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mTaskRect.height(),MeasureSpec.EXACTLY));
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  Console.log(Constants.DebugFlags.UI.MeasureAndLayout,""String_Node_Str"",""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str""+ mAwaitingFirstLayout,Console.AnsiGreen);
  RecentsConfiguration config=RecentsConfiguration.getInstance();
  computeRects(width,height,config.systemInsets.bottom);
  if (Constants.DebugFlags.UI.MeasureAndLayout) {
    Console.log(""String_Node_Str"" + mRect);
    Console.log(""String_Node_Str"" + mStackRect);
    Console.log(""String_Node_Str"" + mStackRectSansPeek);
    Console.log(""String_Node_Str"" + mTaskRect);
  }
  if (mAwaitingFirstLayout) {
    setStackScroll(mMaxScroll);
    requestSynchronizeStackViewsWithModel();
    synchronizeStackViewsWithModel();
    if (Constants.Values.TaskView.AnimateFrontTaskIconOnEnterRecents) {
      TaskView tv=(TaskView)getChildAt(getChildCount() - 1);
      if (tv != null) {
        tv.animateOnEnterRecents();
      }
    }
  }
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    TaskView t=(TaskView)getChildAt(i);
    t.measure(MeasureSpec.makeMeasureSpec(mTaskRect.width(),MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mTaskRect.height(),MeasureSpec.EXACTLY));
  }
  setMeasuredDimension(width,height);
}",0.965896589658966
199608,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity,ActivityContainer container){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid)+ ""String_Node_Str""+ (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId)));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this,container);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity,ActivityContainer container){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid)+ ""String_Node_Str""+ (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId)));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this,container);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.989957208977382
199609,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity,ActivityContainer container){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid)+ ""String_Node_Str""+ (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId)));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this,container);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity,ActivityContainer container){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid)+ ""String_Node_Str""+ (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId)));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this,container);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.989957208977382
199610,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity,ActivityContainer container){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid)+ ""String_Node_Str""+ (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId)));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this,container);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity,ActivityContainer container){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid)+ ""String_Node_Str""+ (container == null ? (mFocusedStack == null ? Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) : (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY : container.mActivityDisplay.mDisplayId)));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this,container);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.989957208977382
199611,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.9894756108721516
199612,"private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDim=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDim=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
        setScreenOn(false);
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.useAutoBrightness && wantScreenOn(mPowerRequest.screenState),updateAutoBrightness);
  }
  if (wantScreenOn(mPowerRequest.screenState)) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDim) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (!mScreenOffBecauseOfProximity) {
    if (wantScreenOn(mPowerRequest.screenState)) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        setScreenOn(true);
        if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
          blockScreenOn();
        }
 else {
          unblockScreenOn();
          if (USE_ELECTRON_BEAM_ON_ANIMATION) {
            if (!mElectronBeamOnAnimator.isStarted()) {
              if (mPowerState.getElectronBeamLevel() == 1.0f) {
                mPowerState.dismissElectronBeam();
              }
 else               if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
                mElectronBeamOnAnimator.start();
              }
 else {
                mElectronBeamOnAnimator.end();
              }
            }
          }
 else {
            mPowerState.setElectronBeamLevel(1.0f);
            mPowerState.dismissElectronBeam();
          }
        }
      }
    }
 else {
      if (!mElectronBeamOnAnimator.isStarted()) {
        if (!mElectronBeamOffAnimator.isStarted()) {
          if (mPowerState.getElectronBeamLevel() == 0.0f) {
            setScreenOn(false);
          }
 else           if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
            mElectronBeamOffAnimator.start();
          }
 else {
            mElectronBeamOffAnimator.end();
          }
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}","private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDim=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDim=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.useAutoBrightness && wantScreenOn(mPowerRequest.screenState),updateAutoBrightness);
  }
  if (wantScreenOn(mPowerRequest.screenState)) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDim) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (mScreenOffBecauseOfProximity) {
    setScreenOn(false);
    unblockScreenOn();
  }
 else   if (wantScreenOn(mPowerRequest.screenState)) {
    if (!mElectronBeamOffAnimator.isStarted()) {
      setScreenOn(true);
      if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
        blockScreenOn();
      }
 else {
        unblockScreenOn();
        if (USE_ELECTRON_BEAM_ON_ANIMATION) {
          if (!mElectronBeamOnAnimator.isStarted()) {
            if (mPowerState.getElectronBeamLevel() == 1.0f) {
              mPowerState.dismissElectronBeam();
            }
 else             if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
              mElectronBeamOnAnimator.start();
            }
 else {
              mElectronBeamOnAnimator.end();
            }
          }
        }
 else {
          mPowerState.setElectronBeamLevel(1.0f);
          mPowerState.dismissElectronBeam();
        }
      }
    }
  }
 else {
    unblockScreenOn();
    if (!mElectronBeamOnAnimator.isStarted()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        if (mPowerState.getElectronBeamLevel() == 0.0f) {
          setScreenOn(false);
        }
 else         if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
          mElectronBeamOffAnimator.start();
        }
 else {
          mElectronBeamOffAnimator.end();
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}",0.9496502118435314
199613,"private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime) + ""String_Node_Str"");
    }
  }
}","private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    long delay=SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime;
    if (delay > 1000 || DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
}",0.694980694980695
199614,"private void setScreenOn(boolean on){
  if (!mPowerState.isScreenOn() == on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}","private void setScreenOn(boolean on){
  if (mPowerState.isScreenOn() != on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}",0.8226950354609929
199615,"public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return mChangeInProgress;
  }
}","public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return !mChangeInProgress;
  }
}",0.9989189189189188
199616,"/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}","/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  if (!Thread.holdsLock(mLock)) {
    Slog.wtf(TAG,""String_Node_Str"");
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}",0.9648382559774964
199617,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199618,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199619,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199620,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199621,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportFailedUnlockAttempt();
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8337088778729157
199622,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199623,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199624,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199625,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199626,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199627,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportFailedUnlockAttempt();
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8337088778729157
199628,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199629,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199630,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199631,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199632,"/** 
 * Retrieve the statistics object for a particular service, creating if needed.
 */
public Uid.Pkg.Serv getServiceStatsLocked(int uid,String pkg,String name){
  Uid u=getUidStatsLocked(uid);
  return u.getServiceStatsLocked(pkg,name);
}","/** 
 * Retrieve the statistics object for a particular service, creating if needed.
 */
public Uid.Pkg.Serv getServiceStatsLocked(int uid,String pkg,String name){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getServiceStatsLocked(pkg,name);
}",0.942115768463074
199633,"/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Pkg getPackageStatsLocked(int uid,String pkg){
  Uid u=getUidStatsLocked(uid);
  return u.getPackageStatsLocked(pkg);
}","/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Pkg getPackageStatsLocked(int uid,String pkg){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getPackageStatsLocked(pkg);
}",0.936542669584245
199634,"/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Proc getProcessStatsLocked(int uid,String name){
  Uid u=getUidStatsLocked(uid);
  return u.getProcessStatsLocked(name);
}","/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Proc getProcessStatsLocked(int uid,String name){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getProcessStatsLocked(name);
}",0.937365010799136
199635,"public void noteWifiOffLocked(){
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mWifiOn) {
    mHistoryCur.states&=~HistoryItem.STATE_WIFI_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(elapsedRealtime);
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(elapsedRealtime);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiStoppedLocked(elapsedRealtime);
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(){
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mWifiOn) {
    mHistoryCur.states&=~HistoryItem.STATE_WIFI_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(elapsedRealtime);
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(elapsedRealtime);
  }
}",0.8644444444444445
199636,"private void updateNetworkActivityLocked(int which,long elapsedRealtimeMs){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if ((which & NET_UPDATE_MOBILE) != 0 && mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      long radioTime=mMobileRadioActivePerAppTimer.checkpointRunningLocked(elapsedRealtimeMs);
      long totalPackets=delta.getTotalPackets();
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(entry.uid);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
        if (radioTime > 0) {
          long appPackets=entry.rxPackets + entry.txPackets;
          long appRadioTime=(radioTime * appPackets) / totalPackets;
          u.noteMobileRadioActiveTimeLocked(appRadioTime);
          radioTime-=appRadioTime;
          totalPackets-=appPackets;
        }
        mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
      }
      if (radioTime > 0) {
        mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
        mMobileRadioActiveUnknownCount.addCountLocked(1);
      }
    }
  }
  if ((which & NET_UPDATE_WIFI) != 0 && mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (DEBUG) {
          final NetworkStats.Entry cur=snapshot.getValues(i,null);
          Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
        }
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(entry.uid);
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
      }
    }
  }
}","private void updateNetworkActivityLocked(int which,long elapsedRealtimeMs){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if ((which & NET_UPDATE_MOBILE) != 0 && mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      long radioTime=mMobileRadioActivePerAppTimer.checkpointRunningLocked(elapsedRealtimeMs);
      long totalPackets=delta.getTotalPackets();
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
        if (radioTime > 0) {
          long appPackets=entry.rxPackets + entry.txPackets;
          long appRadioTime=(radioTime * appPackets) / totalPackets;
          u.noteMobileRadioActiveTimeLocked(appRadioTime);
          radioTime-=appRadioTime;
          totalPackets-=appPackets;
        }
        mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
      }
      if (radioTime > 0) {
        mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
        mMobileRadioActiveUnknownCount.addCountLocked(1);
      }
    }
  }
  if ((which & NET_UPDATE_WIFI) != 0 && mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (DEBUG) {
          final NetworkStats.Entry cur=snapshot.getValues(i,null);
          Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
        }
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
      }
    }
  }
}",0.9933673469387756
199637,"/** 
 * Called when a wake lock is changing.
 */
public void onWakeLockChanging(int flags,String tag,String packageName,int ownerUid,int ownerPid,WorkSource workSource,String historyTag,int newFlags,String newTag,String newPackageName,int newOwnerUid,int newOwnerPid,WorkSource newWorkSource,String newHistoryTag){
  final int monitorType=getBatteryStatsWakeLockMonitorType(flags);
  final int newMonitorType=getBatteryStatsWakeLockMonitorType(newFlags);
  boolean unimportantForLogging=(flags & PowerManager.UNIMPORTANT_FOR_LOGGING) != 0 && ownerUid == Process.SYSTEM_UID;
  if (workSource != null && newWorkSource != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + newFlags + ""String_Node_Str""+ newTag+ ""String_Node_Str""+ newPackageName+ ""String_Node_Str""+ newOwnerUid+ ""String_Node_Str""+ newOwnerPid+ ""String_Node_Str""+ newWorkSource);
    }
    try {
      mBatteryStats.noteChangeWakelockFromSource(workSource,ownerPid,tag,monitorType,newWorkSource,newOwnerPid,newTag,newHistoryTag,newMonitorType,unimportantForLogging);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    onWakeLockReleased(flags,tag,packageName,ownerUid,ownerPid,workSource);
    onWakeLockAcquired(newFlags,newTag,newPackageName,newOwnerUid,newOwnerPid,newWorkSource,newHistoryTag);
  }
}","/** 
 * Called when a wake lock is changing.
 */
public void onWakeLockChanging(int flags,String tag,String packageName,int ownerUid,int ownerPid,WorkSource workSource,String historyTag,int newFlags,String newTag,String newPackageName,int newOwnerUid,int newOwnerPid,WorkSource newWorkSource,String newHistoryTag){
  if (workSource != null && newWorkSource != null) {
    final int monitorType=getBatteryStatsWakeLockMonitorType(flags);
    final int newMonitorType=getBatteryStatsWakeLockMonitorType(newFlags);
    boolean unimportantForLogging=(newFlags & PowerManager.UNIMPORTANT_FOR_LOGGING) != 0 && newOwnerUid == Process.SYSTEM_UID;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + newFlags + ""String_Node_Str""+ newTag+ ""String_Node_Str""+ newPackageName+ ""String_Node_Str""+ newOwnerUid+ ""String_Node_Str""+ newOwnerPid+ ""String_Node_Str""+ newWorkSource);
    }
    try {
      mBatteryStats.noteChangeWakelockFromSource(workSource,ownerPid,tag,monitorType,newWorkSource,newOwnerPid,newTag,newHistoryTag,newMonitorType,unimportantForLogging);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    onWakeLockReleased(flags,tag,packageName,ownerUid,ownerPid,workSource);
    onWakeLockAcquired(newFlags,newTag,newPackageName,newOwnerUid,newOwnerPid,newWorkSource,newHistoryTag);
  }
}",0.9528228924980664
199638,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199639,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199640,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199641,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199642,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportFailedUnlockAttempt();
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportSuccessfulUnlockAttempt();
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportFailedUnlockAttempt();
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8337088778729157
199643,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199644,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199645,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199646,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199647,"/** 
 * Retrieve the statistics object for a particular service, creating if needed.
 */
public Uid.Pkg.Serv getServiceStatsLocked(int uid,String pkg,String name){
  Uid u=getUidStatsLocked(uid);
  return u.getServiceStatsLocked(pkg,name);
}","/** 
 * Retrieve the statistics object for a particular service, creating if needed.
 */
public Uid.Pkg.Serv getServiceStatsLocked(int uid,String pkg,String name){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getServiceStatsLocked(pkg,name);
}",0.942115768463074
199648,"/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Pkg getPackageStatsLocked(int uid,String pkg){
  Uid u=getUidStatsLocked(uid);
  return u.getPackageStatsLocked(pkg);
}","/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Pkg getPackageStatsLocked(int uid,String pkg){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getPackageStatsLocked(pkg);
}",0.936542669584245
199649,"/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Proc getProcessStatsLocked(int uid,String name){
  Uid u=getUidStatsLocked(uid);
  return u.getProcessStatsLocked(name);
}","/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Proc getProcessStatsLocked(int uid,String name){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getProcessStatsLocked(name);
}",0.937365010799136
199650,"public void noteWifiOffLocked(){
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mWifiOn) {
    mHistoryCur.states&=~HistoryItem.STATE_WIFI_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(elapsedRealtime);
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(elapsedRealtime);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiStoppedLocked(elapsedRealtime);
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(){
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mWifiOn) {
    mHistoryCur.states&=~HistoryItem.STATE_WIFI_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(elapsedRealtime);
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(elapsedRealtime);
  }
}",0.8644444444444445
199651,"private void updateNetworkActivityLocked(int which,long elapsedRealtimeMs){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if ((which & NET_UPDATE_MOBILE) != 0 && mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      long radioTime=mMobileRadioActivePerAppTimer.checkpointRunningLocked(elapsedRealtimeMs);
      long totalPackets=delta.getTotalPackets();
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(entry.uid);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
        if (radioTime > 0) {
          long appPackets=entry.rxPackets + entry.txPackets;
          long appRadioTime=(radioTime * appPackets) / totalPackets;
          u.noteMobileRadioActiveTimeLocked(appRadioTime);
          radioTime-=appRadioTime;
          totalPackets-=appPackets;
        }
        mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
      }
      if (radioTime > 0) {
        mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
        mMobileRadioActiveUnknownCount.addCountLocked(1);
      }
    }
  }
  if ((which & NET_UPDATE_WIFI) != 0 && mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (DEBUG) {
          final NetworkStats.Entry cur=snapshot.getValues(i,null);
          Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
        }
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(entry.uid);
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
      }
    }
  }
}","private void updateNetworkActivityLocked(int which,long elapsedRealtimeMs){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if ((which & NET_UPDATE_MOBILE) != 0 && mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      long radioTime=mMobileRadioActivePerAppTimer.checkpointRunningLocked(elapsedRealtimeMs);
      long totalPackets=delta.getTotalPackets();
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
        if (radioTime > 0) {
          long appPackets=entry.rxPackets + entry.txPackets;
          long appRadioTime=(radioTime * appPackets) / totalPackets;
          u.noteMobileRadioActiveTimeLocked(appRadioTime);
          radioTime-=appRadioTime;
          totalPackets-=appPackets;
        }
        mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
      }
      if (radioTime > 0) {
        mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
        mMobileRadioActiveUnknownCount.addCountLocked(1);
      }
    }
  }
  if ((which & NET_UPDATE_WIFI) != 0 && mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (DEBUG) {
          final NetworkStats.Entry cur=snapshot.getValues(i,null);
          Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
        }
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
      }
    }
  }
}",0.9933673469387756
199652,"/** 
 * Called when a wake lock is changing.
 */
public void onWakeLockChanging(int flags,String tag,String packageName,int ownerUid,int ownerPid,WorkSource workSource,String historyTag,int newFlags,String newTag,String newPackageName,int newOwnerUid,int newOwnerPid,WorkSource newWorkSource,String newHistoryTag){
  final int monitorType=getBatteryStatsWakeLockMonitorType(flags);
  final int newMonitorType=getBatteryStatsWakeLockMonitorType(newFlags);
  boolean unimportantForLogging=(flags & PowerManager.UNIMPORTANT_FOR_LOGGING) != 0 && ownerUid == Process.SYSTEM_UID;
  if (workSource != null && newWorkSource != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + newFlags + ""String_Node_Str""+ newTag+ ""String_Node_Str""+ newPackageName+ ""String_Node_Str""+ newOwnerUid+ ""String_Node_Str""+ newOwnerPid+ ""String_Node_Str""+ newWorkSource);
    }
    try {
      mBatteryStats.noteChangeWakelockFromSource(workSource,ownerPid,tag,monitorType,newWorkSource,newOwnerPid,newTag,newHistoryTag,newMonitorType,unimportantForLogging);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    onWakeLockReleased(flags,tag,packageName,ownerUid,ownerPid,workSource);
    onWakeLockAcquired(newFlags,newTag,newPackageName,newOwnerUid,newOwnerPid,newWorkSource,newHistoryTag);
  }
}","/** 
 * Called when a wake lock is changing.
 */
public void onWakeLockChanging(int flags,String tag,String packageName,int ownerUid,int ownerPid,WorkSource workSource,String historyTag,int newFlags,String newTag,String newPackageName,int newOwnerUid,int newOwnerPid,WorkSource newWorkSource,String newHistoryTag){
  if (workSource != null && newWorkSource != null) {
    final int monitorType=getBatteryStatsWakeLockMonitorType(flags);
    final int newMonitorType=getBatteryStatsWakeLockMonitorType(newFlags);
    boolean unimportantForLogging=(newFlags & PowerManager.UNIMPORTANT_FOR_LOGGING) != 0 && newOwnerUid == Process.SYSTEM_UID;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + newFlags + ""String_Node_Str""+ newTag+ ""String_Node_Str""+ newPackageName+ ""String_Node_Str""+ newOwnerUid+ ""String_Node_Str""+ newOwnerPid+ ""String_Node_Str""+ newWorkSource);
    }
    try {
      mBatteryStats.noteChangeWakelockFromSource(workSource,ownerPid,tag,monitorType,newWorkSource,newOwnerPid,newTag,newHistoryTag,newMonitorType,unimportantForLogging);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    onWakeLockReleased(flags,tag,packageName,ownerUid,ownerPid,workSource);
    onWakeLockAcquired(newFlags,newTag,newPackageName,newOwnerUid,newOwnerPid,newWorkSource,newHistoryTag);
  }
}",0.9528228924980664
199653,"/** 
 * Retrieve the statistics object for a particular service, creating if needed.
 */
public Uid.Pkg.Serv getServiceStatsLocked(int uid,String pkg,String name){
  Uid u=getUidStatsLocked(uid);
  return u.getServiceStatsLocked(pkg,name);
}","/** 
 * Retrieve the statistics object for a particular service, creating if needed.
 */
public Uid.Pkg.Serv getServiceStatsLocked(int uid,String pkg,String name){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getServiceStatsLocked(pkg,name);
}",0.942115768463074
199654,"/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Pkg getPackageStatsLocked(int uid,String pkg){
  Uid u=getUidStatsLocked(uid);
  return u.getPackageStatsLocked(pkg);
}","/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Pkg getPackageStatsLocked(int uid,String pkg){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getPackageStatsLocked(pkg);
}",0.936542669584245
199655,"/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Proc getProcessStatsLocked(int uid,String name){
  Uid u=getUidStatsLocked(uid);
  return u.getProcessStatsLocked(name);
}","/** 
 * Retrieve the statistics object for a particular process, creating if needed.
 */
public Uid.Proc getProcessStatsLocked(int uid,String name){
  uid=mapUid(uid);
  Uid u=getUidStatsLocked(uid);
  return u.getProcessStatsLocked(name);
}",0.937365010799136
199656,"public void noteWifiOffLocked(){
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mWifiOn) {
    mHistoryCur.states&=~HistoryItem.STATE_WIFI_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(elapsedRealtime);
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(elapsedRealtime);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiStoppedLocked(elapsedRealtime);
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(){
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mWifiOn) {
    mHistoryCur.states&=~HistoryItem.STATE_WIFI_ON_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(elapsedRealtime);
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(elapsedRealtime);
  }
}",0.8644444444444445
199657,"private void updateNetworkActivityLocked(int which,long elapsedRealtimeMs){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if ((which & NET_UPDATE_MOBILE) != 0 && mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      long radioTime=mMobileRadioActivePerAppTimer.checkpointRunningLocked(elapsedRealtimeMs);
      long totalPackets=delta.getTotalPackets();
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(entry.uid);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
        if (radioTime > 0) {
          long appPackets=entry.rxPackets + entry.txPackets;
          long appRadioTime=(radioTime * appPackets) / totalPackets;
          u.noteMobileRadioActiveTimeLocked(appRadioTime);
          radioTime-=appRadioTime;
          totalPackets-=appPackets;
        }
        mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
      }
      if (radioTime > 0) {
        mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
        mMobileRadioActiveUnknownCount.addCountLocked(1);
      }
    }
  }
  if ((which & NET_UPDATE_WIFI) != 0 && mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (DEBUG) {
          final NetworkStats.Entry cur=snapshot.getValues(i,null);
          Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
        }
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(entry.uid);
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
      }
    }
  }
}","private void updateNetworkActivityLocked(int which,long elapsedRealtimeMs){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if ((which & NET_UPDATE_MOBILE) != 0 && mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      long radioTime=mMobileRadioActivePerAppTimer.checkpointRunningLocked(elapsedRealtimeMs);
      long totalPackets=delta.getTotalPackets();
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
        if (radioTime > 0) {
          long appPackets=entry.rxPackets + entry.txPackets;
          long appRadioTime=(radioTime * appPackets) / totalPackets;
          u.noteMobileRadioActiveTimeLocked(appRadioTime);
          radioTime-=appRadioTime;
          totalPackets-=appPackets;
        }
        mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
      }
      if (radioTime > 0) {
        mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
        mMobileRadioActiveUnknownCount.addCountLocked(1);
      }
    }
  }
  if ((which & NET_UPDATE_WIFI) != 0 && mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    if (mOnBatteryInternal) {
      final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
      mTmpNetworkStats=delta;
      final int size=delta.size();
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (DEBUG) {
          final NetworkStats.Entry cur=snapshot.getValues(i,null);
          Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
        }
        if (entry.rxBytes == 0 || entry.txBytes == 0)         continue;
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
      }
    }
  }
}",0.9933673469387756
199658,"/** 
 * Called when a wake lock is changing.
 */
public void onWakeLockChanging(int flags,String tag,String packageName,int ownerUid,int ownerPid,WorkSource workSource,String historyTag,int newFlags,String newTag,String newPackageName,int newOwnerUid,int newOwnerPid,WorkSource newWorkSource,String newHistoryTag){
  final int monitorType=getBatteryStatsWakeLockMonitorType(flags);
  final int newMonitorType=getBatteryStatsWakeLockMonitorType(newFlags);
  boolean unimportantForLogging=(flags & PowerManager.UNIMPORTANT_FOR_LOGGING) != 0 && ownerUid == Process.SYSTEM_UID;
  if (workSource != null && newWorkSource != null) {
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + newFlags + ""String_Node_Str""+ newTag+ ""String_Node_Str""+ newPackageName+ ""String_Node_Str""+ newOwnerUid+ ""String_Node_Str""+ newOwnerPid+ ""String_Node_Str""+ newWorkSource);
    }
    try {
      mBatteryStats.noteChangeWakelockFromSource(workSource,ownerPid,tag,monitorType,newWorkSource,newOwnerPid,newTag,newHistoryTag,newMonitorType,unimportantForLogging);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    onWakeLockReleased(flags,tag,packageName,ownerUid,ownerPid,workSource);
    onWakeLockAcquired(newFlags,newTag,newPackageName,newOwnerUid,newOwnerPid,newWorkSource,newHistoryTag);
  }
}","/** 
 * Called when a wake lock is changing.
 */
public void onWakeLockChanging(int flags,String tag,String packageName,int ownerUid,int ownerPid,WorkSource workSource,String historyTag,int newFlags,String newTag,String newPackageName,int newOwnerUid,int newOwnerPid,WorkSource newWorkSource,String newHistoryTag){
  if (workSource != null && newWorkSource != null) {
    final int monitorType=getBatteryStatsWakeLockMonitorType(flags);
    final int newMonitorType=getBatteryStatsWakeLockMonitorType(newFlags);
    boolean unimportantForLogging=(newFlags & PowerManager.UNIMPORTANT_FOR_LOGGING) != 0 && newOwnerUid == Process.SYSTEM_UID;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + newFlags + ""String_Node_Str""+ newTag+ ""String_Node_Str""+ newPackageName+ ""String_Node_Str""+ newOwnerUid+ ""String_Node_Str""+ newOwnerPid+ ""String_Node_Str""+ newWorkSource);
    }
    try {
      mBatteryStats.noteChangeWakelockFromSource(workSource,ownerPid,tag,monitorType,newWorkSource,newOwnerPid,newTag,newHistoryTag,newMonitorType,unimportantForLogging);
    }
 catch (    RemoteException ex) {
    }
  }
 else {
    onWakeLockReleased(flags,tag,packageName,ownerUid,ownerPid,workSource);
    onWakeLockAcquired(newFlags,newTag,newPackageName,newOwnerUid,newOwnerPid,newWorkSource,newHistoryTag);
  }
}",0.9528228924980664
199659,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199660,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199661,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199662,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.9894756108721516
199663,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    mRS=null;
    mID=0;
    mDestroyed=true;
  }
  super.finalize();
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9165628891656288
199664,"/** 
 * Frees any native resources associated with this object.  The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough.
 */
synchronized public void destroy(){
  if (mDestroyed) {
    throw new RSInvalidStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nObjDestroy(mID);
}","/** 
 * Frees any native resources associated with this object.  The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough.
 */
public void destroy(){
  if (mDestroyed) {
    throw new RSInvalidStateException(""String_Node_Str"");
  }
  helpDestroy();
}",0.928895612708018
199665,"/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyDelete()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);","/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyChange()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);",0.9956140350877192
199666,"/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The bottom of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The right of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.9960728311317386
199667,"/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The bottom of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The left of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.996551724137931
199668,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.9894756108721516
199669,"@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
}","@Override public void cleanUp(){
  int count=mAppWidgetContainer.getChildCount();
  for (int i=0; i < count; i++) {
    KeyguardWidgetFrame frame=mAppWidgetContainer.getWidgetPageAt(i);
    frame.removeAllViews();
  }
  getSecurityContainer().onPause();
}",0.9240506329113924
199670,"private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDim=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDim=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
        setScreenOn(false);
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.useAutoBrightness && wantScreenOn(mPowerRequest.screenState),updateAutoBrightness);
  }
  if (wantScreenOn(mPowerRequest.screenState)) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDim) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (!mScreenOffBecauseOfProximity) {
    if (wantScreenOn(mPowerRequest.screenState)) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        setScreenOn(true);
        if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
          blockScreenOn();
        }
 else {
          unblockScreenOn();
          if (USE_ELECTRON_BEAM_ON_ANIMATION) {
            if (!mElectronBeamOnAnimator.isStarted()) {
              if (mPowerState.getElectronBeamLevel() == 1.0f) {
                mPowerState.dismissElectronBeam();
              }
 else               if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
                mElectronBeamOnAnimator.start();
              }
 else {
                mElectronBeamOnAnimator.end();
              }
            }
          }
 else {
            mPowerState.setElectronBeamLevel(1.0f);
            mPowerState.dismissElectronBeam();
          }
        }
      }
    }
 else {
      if (!mElectronBeamOnAnimator.isStarted()) {
        if (!mElectronBeamOffAnimator.isStarted()) {
          if (mPowerState.getElectronBeamLevel() == 0.0f) {
            setScreenOn(false);
          }
 else           if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
            mElectronBeamOffAnimator.start();
          }
 else {
            mElectronBeamOffAnimator.end();
          }
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}","private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDim=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDim=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.useAutoBrightness && wantScreenOn(mPowerRequest.screenState),updateAutoBrightness);
  }
  if (wantScreenOn(mPowerRequest.screenState)) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDim) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (mScreenOffBecauseOfProximity) {
    setScreenOn(false);
    unblockScreenOn();
  }
 else   if (wantScreenOn(mPowerRequest.screenState)) {
    if (!mElectronBeamOffAnimator.isStarted()) {
      setScreenOn(true);
      if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
        blockScreenOn();
      }
 else {
        unblockScreenOn();
        if (USE_ELECTRON_BEAM_ON_ANIMATION) {
          if (!mElectronBeamOnAnimator.isStarted()) {
            if (mPowerState.getElectronBeamLevel() == 1.0f) {
              mPowerState.dismissElectronBeam();
            }
 else             if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
              mElectronBeamOnAnimator.start();
            }
 else {
              mElectronBeamOnAnimator.end();
            }
          }
        }
 else {
          mPowerState.setElectronBeamLevel(1.0f);
          mPowerState.dismissElectronBeam();
        }
      }
    }
  }
 else {
    unblockScreenOn();
    if (!mElectronBeamOnAnimator.isStarted()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        if (mPowerState.getElectronBeamLevel() == 0.0f) {
          setScreenOn(false);
        }
 else         if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
          mElectronBeamOffAnimator.start();
        }
 else {
          mElectronBeamOffAnimator.end();
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}",0.9496502118435314
199671,"private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime) + ""String_Node_Str"");
    }
  }
}","private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    long delay=SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime;
    if (delay > 1000 || DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
}",0.694980694980695
199672,"private void setScreenOn(boolean on){
  if (!mPowerState.isScreenOn() == on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}","private void setScreenOn(boolean on){
  if (mPowerState.isScreenOn() != on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}",0.8226950354609929
199673,"public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return mChangeInProgress;
  }
}","public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return !mChangeInProgress;
  }
}",0.9989189189189188
199674,"/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}","/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  if (!Thread.holdsLock(mLock)) {
    Slog.wtf(TAG,""String_Node_Str"");
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}",0.9648382559774964
199675,"final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}","final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,String callingPackage,int startFlags,Bundle options,boolean componentSpecified,ActivityRecord[] outActivity){
  int err=ActivityManager.START_SUCCESS;
  ProcessRecord callerApp=null;
  if (caller != null) {
    callerApp=mService.getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Slog.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=ActivityManager.START_PERMISSION_DENIED;
    }
  }
  if (err == ActivityManager.START_SUCCESS) {
    final int userId=aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;
    Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ intent.toShortString(true,true,true,false)+ ""String_Node_Str""+ (callerApp != null ? callerApp.pid : callingPid));
  }
  ActivityRecord sourceRecord=null;
  ActivityRecord resultRecord=null;
  if (resultTo != null) {
    sourceRecord=isInAnyStackLocked(resultTo);
    if (DEBUG_RESULTS)     Slog.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ sourceRecord);
    if (sourceRecord != null) {
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  ActivityStack resultStack=resultRecord == null ? null : resultRecord.task.stack;
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      ActivityOptions.abort(options);
      return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
    if (sourceRecord.launchedFromUid == callingUid) {
      callingPackage=sourceRecord.launchedFromPackage;
    }
  }
  if (err == ActivityManager.START_SUCCESS && intent.getComponent() == null) {
    err=ActivityManager.START_INTENT_NOT_RESOLVED;
  }
  if (err == ActivityManager.START_SUCCESS && aInfo == null) {
    err=ActivityManager.START_CLASS_NOT_FOUND;
  }
  if (err != ActivityManager.START_SUCCESS) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return err;
  }
  final int startAnyPerm=mService.checkPermission(START_ANY_ACTIVITY,callingPid,callingUid);
  final int componentPerm=mService.checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.applicationInfo.uid,aInfo.exported);
  if (startAnyPerm != PERMISSION_GRANTED && componentPerm != PERMISSION_GRANTED) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    String msg;
    if (!aInfo.exported) {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.applicationInfo.uid;
    }
 else {
      msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    }
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  boolean abort=!mService.mIntentFirewall.checkStartActivity(intent,callingUid,callingPid,resolvedType,aInfo.applicationInfo);
  if (mService.mController != null) {
    try {
      Intent watchIntent=intent.cloneFilter();
      abort|=!mService.mController.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mService.mController=null;
    }
  }
  if (abort) {
    if (resultRecord != null) {
      resultStack.sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    setDismissKeyguard(false);
    ActivityOptions.abort(options);
    return ActivityManager.START_SUCCESS;
  }
  ActivityRecord r=new ActivityRecord(mService,callerApp,callingUid,callingPackage,intent,resolvedType,aInfo,mService.mConfiguration,resultRecord,resultWho,requestCode,componentSpecified,this);
  if (outActivity != null) {
    outActivity[0]=r;
  }
  final ActivityStack stack=getFocusedStack();
  if (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!mService.checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch(r,sourceRecord,startFlags,stack);
      mService.mPendingActivityLaunches.add(pal);
      setDismissKeyguard(false);
      ActivityOptions.abort(options);
      return ActivityManager.START_SWITCHES_CANCELED;
    }
  }
  if (mService.mDidAppSwitch) {
    mService.mAppSwitchesAllowedTime=0;
  }
 else {
    mService.mDidAppSwitch=true;
  }
  mService.doPendingActivityLaunchesLocked(false);
  err=startActivityUncheckedLocked(r,sourceRecord,startFlags,true,options);
  if (allPausedActivitiesComplete()) {
    dismissKeyguard();
  }
  return err;
}",0.9894756108721516
199676,"private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDimOrDoze=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDimOrDoze=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM || mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
        setScreenOn(false);
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.wantLightSensorEnabled(),updateAutoBrightness);
  }
  if (mPowerRequest.wantScreenOnAny()) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE) {
      target=mScreenBrightnessDozeConfig;
      slow=false;
    }
 else     if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDimOrDoze) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (!mScreenOffBecauseOfProximity) {
    if (mPowerRequest.wantScreenOnAny()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        setScreenOn(true);
        if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
          blockScreenOn();
        }
 else {
          unblockScreenOn();
          if (USE_ELECTRON_BEAM_ON_ANIMATION) {
            if (!mElectronBeamOnAnimator.isStarted()) {
              if (mPowerState.getElectronBeamLevel() == 1.0f) {
                mPowerState.dismissElectronBeam();
              }
 else               if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
                mElectronBeamOnAnimator.start();
              }
 else {
                mElectronBeamOnAnimator.end();
              }
            }
          }
 else {
            mPowerState.setElectronBeamLevel(1.0f);
            mPowerState.dismissElectronBeam();
          }
        }
      }
    }
 else {
      if (!mElectronBeamOnAnimator.isStarted()) {
        if (!mElectronBeamOffAnimator.isStarted()) {
          if (mPowerState.getElectronBeamLevel() == 0.0f) {
            setScreenOn(false);
          }
 else           if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
            mElectronBeamOffAnimator.start();
          }
 else {
            mElectronBeamOffAnimator.end();
          }
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}","private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDimOrDoze=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDimOrDoze=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM || mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.wantLightSensorEnabled(),updateAutoBrightness);
  }
  if (mPowerRequest.wantScreenOnAny()) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE) {
      target=mScreenBrightnessDozeConfig;
      slow=false;
    }
 else     if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDimOrDoze) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (mScreenOffBecauseOfProximity) {
    setScreenOn(false);
    unblockScreenOn();
  }
 else   if (mPowerRequest.wantScreenOnAny()) {
    if (!mElectronBeamOffAnimator.isStarted()) {
      setScreenOn(true);
      if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
        blockScreenOn();
      }
 else {
        unblockScreenOn();
        if (USE_ELECTRON_BEAM_ON_ANIMATION) {
          if (!mElectronBeamOnAnimator.isStarted()) {
            if (mPowerState.getElectronBeamLevel() == 1.0f) {
              mPowerState.dismissElectronBeam();
            }
 else             if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
              mElectronBeamOnAnimator.start();
            }
 else {
              mElectronBeamOnAnimator.end();
            }
          }
        }
 else {
          mPowerState.setElectronBeamLevel(1.0f);
          mPowerState.dismissElectronBeam();
        }
      }
    }
  }
 else {
    unblockScreenOn();
    if (!mElectronBeamOnAnimator.isStarted()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        if (mPowerState.getElectronBeamLevel() == 0.0f) {
          setScreenOn(false);
        }
 else         if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
          mElectronBeamOffAnimator.start();
        }
 else {
          mElectronBeamOffAnimator.end();
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}",0.9753825681969396
199677,"private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime) + ""String_Node_Str"");
    }
  }
}","private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    long delay=SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime;
    if (delay > 1000 || DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
}",0.694980694980695
199678,"private void setScreenOn(boolean on){
  if (!mPowerState.isScreenOn() == on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}","private void setScreenOn(boolean on){
  if (mPowerState.isScreenOn() != on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}",0.8226950354609929
199679,"public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return mChangeInProgress;
  }
}","public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return !mChangeInProgress;
  }
}",0.9989189189189188
199680,"/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}","/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  if (!Thread.holdsLock(mLock)) {
    Slog.wtf(TAG,""String_Node_Str"");
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}",0.9648382559774964
199681,"private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDimOrDoze=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDimOrDoze=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM || mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
        setScreenOn(false);
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.wantLightSensorEnabled(),updateAutoBrightness);
  }
  if (mPowerRequest.wantScreenOnAny()) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE) {
      target=mScreenBrightnessDozeConfig;
      slow=false;
    }
 else     if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDimOrDoze) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (!mScreenOffBecauseOfProximity) {
    if (mPowerRequest.wantScreenOnAny()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        setScreenOn(true);
        if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
          blockScreenOn();
        }
 else {
          unblockScreenOn();
          if (USE_ELECTRON_BEAM_ON_ANIMATION) {
            if (!mElectronBeamOnAnimator.isStarted()) {
              if (mPowerState.getElectronBeamLevel() == 1.0f) {
                mPowerState.dismissElectronBeam();
              }
 else               if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
                mElectronBeamOnAnimator.start();
              }
 else {
                mElectronBeamOnAnimator.end();
              }
            }
          }
 else {
            mPowerState.setElectronBeamLevel(1.0f);
            mPowerState.dismissElectronBeam();
          }
        }
      }
    }
 else {
      if (!mElectronBeamOnAnimator.isStarted()) {
        if (!mElectronBeamOffAnimator.isStarted()) {
          if (mPowerState.getElectronBeamLevel() == 0.0f) {
            setScreenOn(false);
          }
 else           if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
            mElectronBeamOffAnimator.start();
          }
 else {
            mElectronBeamOffAnimator.end();
          }
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}","private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDimOrDoze=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDimOrDoze=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM || mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.wantLightSensorEnabled(),updateAutoBrightness);
  }
  if (mPowerRequest.wantScreenOnAny()) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE) {
      target=mScreenBrightnessDozeConfig;
      slow=false;
    }
 else     if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDimOrDoze) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (mScreenOffBecauseOfProximity) {
    setScreenOn(false);
    unblockScreenOn();
  }
 else   if (mPowerRequest.wantScreenOnAny()) {
    if (!mElectronBeamOffAnimator.isStarted()) {
      setScreenOn(true);
      if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
        blockScreenOn();
      }
 else {
        unblockScreenOn();
        if (USE_ELECTRON_BEAM_ON_ANIMATION) {
          if (!mElectronBeamOnAnimator.isStarted()) {
            if (mPowerState.getElectronBeamLevel() == 1.0f) {
              mPowerState.dismissElectronBeam();
            }
 else             if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
              mElectronBeamOnAnimator.start();
            }
 else {
              mElectronBeamOnAnimator.end();
            }
          }
        }
 else {
          mPowerState.setElectronBeamLevel(1.0f);
          mPowerState.dismissElectronBeam();
        }
      }
    }
  }
 else {
    unblockScreenOn();
    if (!mElectronBeamOnAnimator.isStarted()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        if (mPowerState.getElectronBeamLevel() == 0.0f) {
          setScreenOn(false);
        }
 else         if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
          mElectronBeamOffAnimator.start();
        }
 else {
          mElectronBeamOffAnimator.end();
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}",0.9753825681969396
199682,"private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime) + ""String_Node_Str"");
    }
  }
}","private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    long delay=SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime;
    if (delay > 1000 || DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
}",0.694980694980695
199683,"private void setScreenOn(boolean on){
  if (!mPowerState.isScreenOn() == on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}","private void setScreenOn(boolean on){
  if (mPowerState.isScreenOn() != on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}",0.8226950354609929
199684,"public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return mChangeInProgress;
  }
}","public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return !mChangeInProgress;
  }
}",0.9989189189189188
199685,"/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}","/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  if (!Thread.holdsLock(mLock)) {
    Slog.wtf(TAG,""String_Node_Str"");
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}",0.9648382559774964
199686,"private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDimOrDoze=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDimOrDoze=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM || mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
        setScreenOn(false);
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.wantLightSensorEnabled(),updateAutoBrightness);
  }
  if (mPowerRequest.wantScreenOnAny()) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE) {
      target=mScreenBrightnessDozeConfig;
      slow=false;
    }
 else     if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDimOrDoze) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (!mScreenOffBecauseOfProximity) {
    if (mPowerRequest.wantScreenOnAny()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        setScreenOn(true);
        if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
          blockScreenOn();
        }
 else {
          unblockScreenOn();
          if (USE_ELECTRON_BEAM_ON_ANIMATION) {
            if (!mElectronBeamOnAnimator.isStarted()) {
              if (mPowerState.getElectronBeamLevel() == 1.0f) {
                mPowerState.dismissElectronBeam();
              }
 else               if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
                mElectronBeamOnAnimator.start();
              }
 else {
                mElectronBeamOnAnimator.end();
              }
            }
          }
 else {
            mPowerState.setElectronBeamLevel(1.0f);
            mPowerState.dismissElectronBeam();
          }
        }
      }
    }
 else {
      if (!mElectronBeamOnAnimator.isStarted()) {
        if (!mElectronBeamOffAnimator.isStarted()) {
          if (mPowerState.getElectronBeamLevel() == 0.0f) {
            setScreenOn(false);
          }
 else           if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
            mElectronBeamOffAnimator.start();
          }
 else {
            mElectronBeamOffAnimator.end();
          }
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}","private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDimOrDoze=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDimOrDoze=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM || mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.wantLightSensorEnabled(),updateAutoBrightness);
  }
  if (mPowerRequest.wantScreenOnAny()) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DOZE) {
      target=mScreenBrightnessDozeConfig;
      slow=false;
    }
 else     if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDimOrDoze) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (mScreenOffBecauseOfProximity) {
    setScreenOn(false);
    unblockScreenOn();
  }
 else   if (mPowerRequest.wantScreenOnAny()) {
    if (!mElectronBeamOffAnimator.isStarted()) {
      setScreenOn(true);
      if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
        blockScreenOn();
      }
 else {
        unblockScreenOn();
        if (USE_ELECTRON_BEAM_ON_ANIMATION) {
          if (!mElectronBeamOnAnimator.isStarted()) {
            if (mPowerState.getElectronBeamLevel() == 1.0f) {
              mPowerState.dismissElectronBeam();
            }
 else             if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
              mElectronBeamOnAnimator.start();
            }
 else {
              mElectronBeamOnAnimator.end();
            }
          }
        }
 else {
          mPowerState.setElectronBeamLevel(1.0f);
          mPowerState.dismissElectronBeam();
        }
      }
    }
  }
 else {
    unblockScreenOn();
    if (!mElectronBeamOnAnimator.isStarted()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        if (mPowerState.getElectronBeamLevel() == 0.0f) {
          setScreenOn(false);
        }
 else         if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
          mElectronBeamOffAnimator.start();
        }
 else {
          mElectronBeamOffAnimator.end();
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}",0.9753825681969396
199687,"private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime) + ""String_Node_Str"");
    }
  }
}","private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    long delay=SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime;
    if (delay > 1000 || DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
}",0.694980694980695
199688,"private void setScreenOn(boolean on){
  if (!mPowerState.isScreenOn() == on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}","private void setScreenOn(boolean on){
  if (mPowerState.isScreenOn() != on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}",0.8226950354609929
199689,"public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return mChangeInProgress;
  }
}","public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return !mChangeInProgress;
  }
}",0.9989189189189188
199690,"/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}","/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  if (!Thread.holdsLock(mLock)) {
    Slog.wtf(TAG,""String_Node_Str"");
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}",0.9648382559774964
199691,"private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDim=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDim=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
        setScreenOn(false);
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.useAutoBrightness && wantScreenOn(mPowerRequest.screenState),updateAutoBrightness);
  }
  if (wantScreenOn(mPowerRequest.screenState)) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDim) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (!mScreenOffBecauseOfProximity) {
    if (wantScreenOn(mPowerRequest.screenState)) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        setScreenOn(true);
        if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
          blockScreenOn();
        }
 else {
          unblockScreenOn();
          if (USE_ELECTRON_BEAM_ON_ANIMATION) {
            if (!mElectronBeamOnAnimator.isStarted()) {
              if (mPowerState.getElectronBeamLevel() == 1.0f) {
                mPowerState.dismissElectronBeam();
              }
 else               if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
                mElectronBeamOnAnimator.start();
              }
 else {
                mElectronBeamOnAnimator.end();
              }
            }
          }
 else {
            mPowerState.setElectronBeamLevel(1.0f);
            mPowerState.dismissElectronBeam();
          }
        }
      }
    }
 else {
      if (!mElectronBeamOnAnimator.isStarted()) {
        if (!mElectronBeamOffAnimator.isStarted()) {
          if (mPowerState.getElectronBeamLevel() == 0.0f) {
            setScreenOn(false);
          }
 else           if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
            mElectronBeamOffAnimator.start();
          }
 else {
            mElectronBeamOffAnimator.end();
          }
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}","private void updatePowerState(){
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean updateAutoBrightness=mTwilightChanged;
  boolean wasDim=false;
  mTwilightChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      if (mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment) {
        updateAutoBrightness=true;
      }
      wasDim=(mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  if (mProximitySensor != null) {
    if (mPowerRequest.useProximitySensor && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
      if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
        mScreenOffBecauseOfProximity=true;
        sendOnProximityPositiveWithWakelock();
      }
    }
 else     if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && mPowerRequest.screenState != DisplayPowerRequest.SCREEN_STATE_OFF) {
      setProximitySensorEnabled(true);
    }
 else {
      setProximitySensorEnabled(false);
      mWaitingForNegativeProximity=false;
    }
    if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
      mScreenOffBecauseOfProximity=false;
      sendOnProximityNegativeWithWakelock();
    }
  }
 else {
    mWaitingForNegativeProximity=false;
  }
  if (mLightSensor != null) {
    setLightSensorEnabled(mPowerRequest.useAutoBrightness && wantScreenOn(mPowerRequest.screenState),updateAutoBrightness);
  }
  if (wantScreenOn(mPowerRequest.screenState)) {
    int target;
    boolean slow;
    if (mScreenAutoBrightness >= 0 && mLightSensorEnabled) {
      target=mScreenAutoBrightness;
      slow=mUsingScreenAutoBrightness;
      mUsingScreenAutoBrightness=true;
    }
 else {
      target=mPowerRequest.screenBrightness;
      slow=false;
      mUsingScreenAutoBrightness=false;
    }
    if (mPowerRequest.screenState == DisplayPowerRequest.SCREEN_STATE_DIM) {
      target=Math.min(target - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig);
      slow=false;
    }
 else     if (wasDim) {
      slow=false;
    }
    animateScreenBrightness(clampScreenBrightness(target),slow ? BRIGHTNESS_RAMP_RATE_SLOW : BRIGHTNESS_RAMP_RATE_FAST);
  }
 else {
    mUsingScreenAutoBrightness=false;
  }
  if (mScreenOffBecauseOfProximity) {
    setScreenOn(false);
    unblockScreenOn();
  }
 else   if (wantScreenOn(mPowerRequest.screenState)) {
    if (!mElectronBeamOffAnimator.isStarted()) {
      setScreenOn(true);
      if (mPowerRequest.blockScreenOn && mPowerState.getElectronBeamLevel() == 0.0f) {
        blockScreenOn();
      }
 else {
        unblockScreenOn();
        if (USE_ELECTRON_BEAM_ON_ANIMATION) {
          if (!mElectronBeamOnAnimator.isStarted()) {
            if (mPowerState.getElectronBeamLevel() == 1.0f) {
              mPowerState.dismissElectronBeam();
            }
 else             if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_WARM_UP)) {
              mElectronBeamOnAnimator.start();
            }
 else {
              mElectronBeamOnAnimator.end();
            }
          }
        }
 else {
          mPowerState.setElectronBeamLevel(1.0f);
          mPowerState.dismissElectronBeam();
        }
      }
    }
  }
 else {
    unblockScreenOn();
    if (!mElectronBeamOnAnimator.isStarted()) {
      if (!mElectronBeamOffAnimator.isStarted()) {
        if (mPowerState.getElectronBeamLevel() == 0.0f) {
          setScreenOn(false);
        }
 else         if (mPowerState.prepareElectronBeam(mElectronBeamFadesConfig ? ElectronBeam.MODE_FADE : ElectronBeam.MODE_COOL_DOWN) && mPowerState.isScreenOn()) {
          mElectronBeamOffAnimator.start();
        }
 else {
          mElectronBeamOffAnimator.end();
        }
      }
    }
  }
  if (mustNotify && !mScreenOnWasBlocked && !mElectronBeamOnAnimator.isStarted()&& !mElectronBeamOffAnimator.isStarted()&& mPowerState.waitUntilClean(mCleanListener)) {
synchronized (mLock) {
      if (!mPendingRequestChangedLocked) {
        mDisplayReadyLocked=true;
        if (DEBUG) {
          Slog.d(TAG,""String_Node_Str"");
        }
      }
    }
    sendOnStateChangedWithWakelock();
  }
}",0.9496502118435314
199692,"private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    if (DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + (SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime) + ""String_Node_Str"");
    }
  }
}","private void unblockScreenOn(){
  if (mScreenOnWasBlocked) {
    mScreenOnWasBlocked=false;
    long delay=SystemClock.elapsedRealtime() - mScreenOnBlockStartRealTime;
    if (delay > 1000 || DEBUG) {
      Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
    }
  }
}",0.694980694980695
199693,"private void setScreenOn(boolean on){
  if (!mPowerState.isScreenOn() == on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}","private void setScreenOn(boolean on){
  if (mPowerState.isScreenOn() != on) {
    mPowerState.setScreenOn(on);
    if (on) {
      mNotifier.onScreenOn();
    }
 else {
      mNotifier.onScreenOff();
    }
  }
}",0.8226950354609929
199694,"public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return mChangeInProgress;
  }
}","public boolean setState(boolean on,int backlight){
synchronized (mLock) {
    if (on != mPendingOn || backlight != mPendingBacklight) {
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + on + ""String_Node_Str""+ backlight);
      }
      mPendingOn=on;
      mPendingBacklight=backlight;
      if (!mChangeInProgress) {
        mChangeInProgress=true;
        AsyncTask.THREAD_POOL_EXECUTOR.execute(mTask);
      }
    }
    return !mChangeInProgress;
  }
}",0.9989189189189188
199695,"/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}","/** 
 * Updates the global power state based on dirty bits recorded in mDirty. This is the main function that performs power state transitions. We centralize them here so that we can recompute the power state completely each time something important changes, and ensure that we do it the same way each time.  The point is to gather all of the transition logic here.
 */
private void updatePowerStateLocked(){
  if (!mSystemReady || mDirty == 0) {
    return;
  }
  if (!Thread.holdsLock(mLock)) {
    Slog.wtf(TAG,""String_Node_Str"");
  }
  updateIsPoweredLocked(mDirty);
  updateStayOnLocked(mDirty);
  final long now=SystemClock.uptimeMillis();
  int dirtyPhase2=0;
  for (; ; ) {
    int dirtyPhase1=mDirty;
    dirtyPhase2|=dirtyPhase1;
    mDirty=0;
    updateWakeLockSummaryLocked(dirtyPhase1);
    updateUserActivitySummaryLocked(now,dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
      break;
    }
  }
  updateDreamLocked(dirtyPhase2);
  updateDisplayPowerStateLocked(dirtyPhase2);
  if (mDisplayReady) {
    sendPendingNotificationsLocked();
  }
  updateSuspendBlockerLocked();
}",0.9648382559774964
199696,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199697,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199698,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199699,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199700,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199701,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199702,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199703,"/** 
 * Frees any native resources associated with this object.  The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough.
 */
synchronized public void destroy(){
  if (mDestroyed) {
    throw new RSInvalidStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nObjDestroy(mID);
}","/** 
 * Frees any native resources associated with this object.  The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough.
 */
public void destroy(){
  if (mDestroyed) {
    throw new RSInvalidStateException(""String_Node_Str"");
  }
  helpDestroy();
}",0.928895612708018
199704,"protected void finalize() throws Throwable {
  if (!mDestroyed) {
    if (mID != 0 && mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    mRS=null;
    mID=0;
    mDestroyed=true;
  }
  super.finalize();
}","protected void finalize() throws Throwable {
  helpDestroy();
  super.finalize();
}",0.5567010309278351
199705,"synchronized void nContextDestroy(){
  validate();
  rsnContextDestroy(mContext);
}","synchronized void nContextDestroy(){
  validate();
  ReentrantReadWriteLock.WriteLock wlock=mRWLock.writeLock();
  wlock.lock();
  int curCon=mContext;
  mContext=0;
  wlock.unlock();
  rsnContextDestroy(curCon);
}",0.5050505050505051
199706,"synchronized void nObjDestroy(int id){
  if (mContext != 0) {
    rsnObjDestroy(mContext,id);
  }
}","void nObjDestroy(int id){
  if (mContext != 0) {
    rsnObjDestroy(mContext,id);
  }
}",0.9297297297297298
199707,"/** 
 * Destroys this RenderScript context.  Once this function is called, using this context or any objects belonging to this context is illegal.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  try {
    mMessageThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","/** 
 * Destroys this RenderScript context.  Once this function is called, using this context or any objects belonging to this context is illegal.
 */
public void destroy(){
  validate();
  nContextFinish();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  try {
    mMessageThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  nDeviceDestroy(mDev);
  mDev=0;
}",0.9580246913580248
199708,"RenderScript(Context ctx){
  mContextType=ContextType.NORMAL;
  if (ctx != null) {
    mApplicationContext=ctx.getApplicationContext();
  }
}","RenderScript(Context ctx){
  mContextType=ContextType.NORMAL;
  if (ctx != null) {
    mApplicationContext=ctx.getApplicationContext();
  }
  mRWLock=new ReentrantReadWriteLock();
}",0.8757763975155279
199709,"public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}","public long getCurrentTimeUs(boolean refreshTime,boolean monotonic) throws IllegalStateException {
synchronized (this) {
    if (mPaused && !refreshTime) {
      return mLastReportedTime;
    }
    long nanoTime=System.nanoTime();
    if (refreshTime || nanoTime >= mLastNanoTime + MAX_NS_WITHOUT_POSITION_CHECK) {
      try {
        mLastTimeUs=mPlayer.getCurrentPosition() * 1000L;
        mPaused=!mPlayer.isPlaying();
        if (DEBUG)         Log.v(TAG,(mPaused ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + mLastTimeUs);
      }
 catch (      IllegalStateException e) {
        if (mPausing) {
          mPausing=false;
          getEstimatedTime(nanoTime,monotonic);
          mPaused=true;
          if (DEBUG)           Log.d(TAG,""String_Node_Str"" + mLastReportedTime);
          return mLastReportedTime;
        }
        throw e;
      }
      mLastNanoTime=nanoTime;
      if (monotonic && mLastTimeUs < mLastReportedTime) {
        mTimeAdjustment=mLastReportedTime - mLastTimeUs;
        if (mTimeAdjustment > 1000000) {
          mStopped=false;
          mSeeking=true;
          scheduleNotification(NOTIFY_SEEK,0);
        }
      }
 else {
        mTimeAdjustment=0;
      }
    }
    return getEstimatedTime(nanoTime,monotonic);
  }
}",0.9996073812328228
199710,"/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyDelete()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);","/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyChange()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);",0.9956140350877192
199711,"/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The bottom of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The right of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.9960728311317386
199712,"/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The bottom of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The left of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.996551724137931
199713,"/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyDelete()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);","/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyChange()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);",0.9956140350877192
199714,"/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The bottom of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The right of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.9960728311317386
199715,"/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The bottom of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The left of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.996551724137931
199716,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199717,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199718,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199719,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199720,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199721,"/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyDelete()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);","/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyChange()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);",0.9956140350877192
199722,"/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The bottom of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The right of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.9960728311317386
199723,"/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The bottom of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The left of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.996551724137931
199724,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199725,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199726,"/** 
 * Frees any native resources associated with this object.  The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough.
 */
synchronized public void destroy(){
  if (mDestroyed) {
    throw new RSInvalidStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nObjDestroy(mID);
}","/** 
 * Frees any native resources associated with this object.  The primary use is to force immediate cleanup of resources when it is believed the GC will not respond quickly enough.
 */
public void destroy(){
  if (mDestroyed) {
    throw new RSInvalidStateException(""String_Node_Str"");
  }
  helpDestroy();
}",0.928895612708018
199727,"protected void finalize() throws Throwable {
  if (!mDestroyed) {
    if (mID != 0 && mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    mRS=null;
    mID=0;
    mDestroyed=true;
  }
  super.finalize();
}","protected void finalize() throws Throwable {
  helpDestroy();
  super.finalize();
}",0.5567010309278351
199728,"synchronized void nContextDestroy(){
  validate();
  rsnContextDestroy(mContext);
}","synchronized void nContextDestroy(){
  validate();
  ReentrantReadWriteLock.WriteLock wlock=mRWLock.writeLock();
  wlock.lock();
  int curCon=mContext;
  mContext=0;
  wlock.unlock();
  rsnContextDestroy(curCon);
}",0.5050505050505051
199729,"synchronized void nObjDestroy(int id){
  if (mContext != 0) {
    rsnObjDestroy(mContext,id);
  }
}","void nObjDestroy(int id){
  if (mContext != 0) {
    rsnObjDestroy(mContext,id);
  }
}",0.9297297297297298
199730,"/** 
 * Destroys this RenderScript context.  Once this function is called, using this context or any objects belonging to this context is illegal.
 */
public void destroy(){
  validate();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  try {
    mMessageThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","/** 
 * Destroys this RenderScript context.  Once this function is called, using this context or any objects belonging to this context is illegal.
 */
public void destroy(){
  validate();
  nContextFinish();
  nContextDeinitToClient(mContext);
  mMessageThread.mRun=false;
  try {
    mMessageThread.join();
  }
 catch (  InterruptedException e) {
  }
  nContextDestroy();
  nDeviceDestroy(mDev);
  mDev=0;
}",0.9580246913580248
199731,"RenderScript(Context ctx){
  mContextType=ContextType.NORMAL;
  if (ctx != null) {
    mApplicationContext=ctx.getApplicationContext();
  }
}","RenderScript(Context ctx){
  mContextType=ContextType.NORMAL;
  if (ctx != null) {
    mApplicationContext=ctx.getApplicationContext();
  }
  mRWLock=new ReentrantReadWriteLock();
}",0.8757763975155279
199732,"/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyDelete()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);","/** 
 * Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call   {@link ContentResolver#notifyChange(android.net.Uri,android.database.ContentObserver) notifyChange()}after deleting. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads"">Processes and Threads</a>. <p>The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in <code>content://contacts/people/22</code> and the implementation is responsible for parsing the record number (22) when creating a SQL statement.
 * @param uri The full URI to query, including a row ID (if a specific record is requested).
 * @param selection An optional restriction to apply to rows when deleting.
 * @return The number of rows affected.
 * @throws SQLException
 */
public abstract int delete(Uri uri,String selection,String[] selectionArgs);",0.9956140350877192
199733,"/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The bottom of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param right The right of this view, in pixels.
 */
public final void setRight(int right){
  if (right != mRight) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int maxRight;
        if (right < mRight) {
          maxRight=mRight;
        }
 else {
          maxRight=right;
        }
        invalidate(0,0,maxRight - mLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mRight=right;
    if (mDisplayList != null) {
      mDisplayList.setRight(mRight);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.9960728311317386
199734,"/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The bottom of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}","/** 
 * Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.
 * @param left The left of this view, in pixels.
 */
public final void setLeft(int left){
  if (left != mLeft) {
    updateMatrix();
    final boolean matrixIsIdentity=mTransformationInfo == null || mTransformationInfo.mMatrixIsIdentity;
    if (matrixIsIdentity) {
      if (mAttachInfo != null) {
        int minLeft;
        int xLoc;
        if (left < mLeft) {
          minLeft=left;
          xLoc=left - mLeft;
        }
 else {
          minLeft=mLeft;
          xLoc=0;
        }
        invalidate(xLoc,0,mRight - minLeft,mBottom - mTop);
      }
    }
 else {
      invalidate(true);
    }
    int oldWidth=mRight - mLeft;
    int height=mBottom - mTop;
    mLeft=left;
    if (mDisplayList != null) {
      mDisplayList.setLeft(left);
    }
    sizeChange(mRight - mLeft,height,oldWidth,height);
    if (!matrixIsIdentity) {
      if ((mPrivateFlags & PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
        mTransformationInfo.mMatrixDirty=true;
      }
      mPrivateFlags|=PFLAG_DRAWN;
      invalidate(true);
    }
    mBackgroundSizeChanged=true;
    invalidateParentIfNeeded();
    if ((mPrivateFlags2 & PFLAG2_VIEW_QUICK_REJECTED) == PFLAG2_VIEW_QUICK_REJECTED) {
      invalidateParentIfNeeded();
    }
  }
}",0.996551724137931
199735,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199736,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportUnlockAttempt(true);
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportUnlockAttempt(false);
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportUnlockAttempt(true);
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportUnlockAttempt(false);
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8263038548752835
199737,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199738,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199739,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199740,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199741,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199742,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportUnlockAttempt(true);
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportUnlockAttempt(false);
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportUnlockAttempt(true);
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportUnlockAttempt(false);
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8263038548752835
199743,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199744,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199745,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199746,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199747,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),0);
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  mMenu.performItemAction(mAdapter.getItem(position),this,0);
}",0.9832775919732442
199748,"private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}","private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu,MenuPresenter preferredPresenter){
  if (mPresenters.isEmpty())   return false;
  boolean result=false;
  if (preferredPresenter != null) {
    result=preferredPresenter.onSubMenuSelected(subMenu);
  }
  for (  WeakReference<MenuPresenter> ref : mPresenters) {
    final MenuPresenter presenter=ref.get();
    if (presenter == null) {
      mPresenters.remove(ref);
    }
 else     if (!result) {
      result=presenter.onSubMenuSelected(subMenu);
    }
  }
  return result;
}",0.8616684266103485
199749,"public boolean performItemAction(MenuItem item,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}","public boolean performItemAction(MenuItem item,MenuPresenter preferredPresenter,int flags){
  MenuItemImpl itemImpl=(MenuItemImpl)item;
  if (itemImpl == null || !itemImpl.isEnabled()) {
    return false;
  }
  boolean invoked=itemImpl.invoke();
  final ActionProvider provider=item.getActionProvider();
  final boolean providerHasSubMenu=provider != null && provider.hasSubMenu();
  if (itemImpl.hasCollapsibleActionView()) {
    invoked|=itemImpl.expandActionView();
    if (invoked)     close(true);
  }
 else   if (itemImpl.hasSubMenu() || providerHasSubMenu) {
    close(false);
    if (!itemImpl.hasSubMenu()) {
      itemImpl.setSubMenu(new SubMenuBuilder(getContext(),this,itemImpl));
    }
    final SubMenuBuilder subMenu=(SubMenuBuilder)itemImpl.getSubMenu();
    if (providerHasSubMenu) {
      provider.onPrepareSubMenu(subMenu);
    }
    invoked|=dispatchSubMenuSelected(subMenu,preferredPresenter);
    if (!invoked)     close(true);
  }
 else {
    if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
      close(true);
    }
  }
  return invoked;
}",0.9748062015503876
199750,"@Override public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mLock) {
    if (mWallpaper.connection == this) {
      mWallpaper.lastDiedTime=SystemClock.uptimeMillis();
      mService=IWallpaperService.Stub.asInterface(service);
      attachServiceLocked(this,mWallpaper);
      saveSettingsLocked(mWallpaper);
    }
  }
}","@Override public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mLock) {
    if (mWallpaper.connection == this) {
      mService=IWallpaperService.Stub.asInterface(service);
      attachServiceLocked(this,mWallpaper);
      saveSettingsLocked(mWallpaper);
    }
  }
}",0.910493827160494
199751,"boolean bindWallpaperComponentLocked(ComponentName componentName,boolean force,boolean fromUser,WallpaperData wallpaper,IRemoteCallback reply){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + componentName);
  if (!force) {
    if (wallpaper.connection != null) {
      if (wallpaper.wallpaperComponent == null) {
        if (componentName == null) {
          if (DEBUG)           Slog.v(TAG,""String_Node_Str"");
          return true;
        }
      }
 else       if (wallpaper.wallpaperComponent.equals(componentName)) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
        return true;
      }
    }
  }
  try {
    if (componentName == null) {
      String defaultComponent=mContext.getString(com.android.internal.R.string.default_wallpaper_component);
      if (defaultComponent != null) {
        componentName=ComponentName.unflattenFromString(defaultComponent);
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + componentName);
      }
      if (componentName == null) {
        componentName=IMAGE_WALLPAPER;
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
      }
    }
    int serviceUserId=wallpaper.userId;
    ServiceInfo si=mIPackageManager.getServiceInfo(componentName,PackageManager.GET_META_DATA | PackageManager.GET_PERMISSIONS,serviceUserId);
    if (si == null) {
      Slog.w(TAG,""String_Node_Str"" + componentName + ""String_Node_Str"");
      return false;
    }
    if (!android.Manifest.permission.BIND_WALLPAPER.equals(si.permission)) {
      String msg=""String_Node_Str"" + android.Manifest.permission.BIND_WALLPAPER + ""String_Node_Str""+ componentName;
      if (fromUser) {
        throw new SecurityException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    WallpaperInfo wi=null;
    Intent intent=new Intent(WallpaperService.SERVICE_INTERFACE);
    if (componentName != null && !componentName.equals(IMAGE_WALLPAPER)) {
      List<ResolveInfo> ris=mIPackageManager.queryIntentServices(intent,intent.resolveTypeIfNeeded(mContext.getContentResolver()),PackageManager.GET_META_DATA,serviceUserId);
      for (int i=0; i < ris.size(); i++) {
        ServiceInfo rsi=ris.get(i).serviceInfo;
        if (rsi.name.equals(si.name) && rsi.packageName.equals(si.packageName)) {
          try {
            wi=new WallpaperInfo(mContext,ris.get(i));
          }
 catch (          XmlPullParserException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
catch (          IOException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
          break;
        }
      }
      if (wi == null) {
        String msg=""String_Node_Str"" + componentName;
        if (fromUser) {
          throw new SecurityException(msg);
        }
        Slog.w(TAG,msg);
        return false;
      }
    }
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + componentName);
    WallpaperConnection newConn=new WallpaperConnection(wi,wallpaper);
    intent.setComponent(componentName);
    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,com.android.internal.R.string.wallpaper_binding_label);
    intent.putExtra(Intent.EXTRA_CLIENT_INTENT,PendingIntent.getActivityAsUser(mContext,0,Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),mContext.getText(com.android.internal.R.string.chooser_wallpaper)),0,null,new UserHandle(serviceUserId)));
    if (!mContext.bindServiceAsUser(intent,newConn,Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,new UserHandle(serviceUserId))) {
      String msg=""String_Node_Str"" + componentName;
      if (fromUser) {
        throw new IllegalArgumentException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    if (wallpaper.userId == mCurrentUserId && mLastWallpaper != null) {
      detachWallpaperLocked(mLastWallpaper);
    }
    wallpaper.wallpaperComponent=componentName;
    wallpaper.connection=newConn;
    wallpaper.lastDiedTime=SystemClock.uptimeMillis();
    newConn.mReply=reply;
    try {
      if (wallpaper.userId == mCurrentUserId) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + newConn.mToken);
        mIWindowManager.addWindowToken(newConn.mToken,WindowManager.LayoutParams.TYPE_WALLPAPER);
        mLastWallpaper=wallpaper;
      }
    }
 catch (    RemoteException e) {
    }
  }
 catch (  RemoteException e) {
    String msg=""String_Node_Str"" + componentName + ""String_Node_Str""+ e;
    if (fromUser) {
      throw new IllegalArgumentException(msg);
    }
    Slog.w(TAG,msg);
    return false;
  }
  return true;
}","boolean bindWallpaperComponentLocked(ComponentName componentName,boolean force,boolean fromUser,WallpaperData wallpaper,IRemoteCallback reply){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + componentName);
  if (!force) {
    if (wallpaper.connection != null) {
      if (wallpaper.wallpaperComponent == null) {
        if (componentName == null) {
          if (DEBUG)           Slog.v(TAG,""String_Node_Str"");
          return true;
        }
      }
 else       if (wallpaper.wallpaperComponent.equals(componentName)) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
        return true;
      }
    }
  }
  try {
    if (componentName == null) {
      String defaultComponent=mContext.getString(com.android.internal.R.string.default_wallpaper_component);
      if (defaultComponent != null) {
        componentName=ComponentName.unflattenFromString(defaultComponent);
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + componentName);
      }
      if (componentName == null) {
        componentName=IMAGE_WALLPAPER;
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
      }
    }
    int serviceUserId=wallpaper.userId;
    ServiceInfo si=mIPackageManager.getServiceInfo(componentName,PackageManager.GET_META_DATA | PackageManager.GET_PERMISSIONS,serviceUserId);
    if (si == null) {
      Slog.w(TAG,""String_Node_Str"" + componentName + ""String_Node_Str"");
      return false;
    }
    if (!android.Manifest.permission.BIND_WALLPAPER.equals(si.permission)) {
      String msg=""String_Node_Str"" + android.Manifest.permission.BIND_WALLPAPER + ""String_Node_Str""+ componentName;
      if (fromUser) {
        throw new SecurityException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    WallpaperInfo wi=null;
    Intent intent=new Intent(WallpaperService.SERVICE_INTERFACE);
    if (componentName != null && !componentName.equals(IMAGE_WALLPAPER)) {
      List<ResolveInfo> ris=mIPackageManager.queryIntentServices(intent,intent.resolveTypeIfNeeded(mContext.getContentResolver()),PackageManager.GET_META_DATA,serviceUserId);
      for (int i=0; i < ris.size(); i++) {
        ServiceInfo rsi=ris.get(i).serviceInfo;
        if (rsi.name.equals(si.name) && rsi.packageName.equals(si.packageName)) {
          try {
            wi=new WallpaperInfo(mContext,ris.get(i));
          }
 catch (          XmlPullParserException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
catch (          IOException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
          break;
        }
      }
      if (wi == null) {
        String msg=""String_Node_Str"" + componentName;
        if (fromUser) {
          throw new SecurityException(msg);
        }
        Slog.w(TAG,msg);
        return false;
      }
    }
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + componentName);
    WallpaperConnection newConn=new WallpaperConnection(wi,wallpaper);
    intent.setComponent(componentName);
    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,com.android.internal.R.string.wallpaper_binding_label);
    intent.putExtra(Intent.EXTRA_CLIENT_INTENT,PendingIntent.getActivityAsUser(mContext,0,Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),mContext.getText(com.android.internal.R.string.chooser_wallpaper)),0,null,new UserHandle(serviceUserId)));
    if (!mContext.bindServiceAsUser(intent,newConn,Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,new UserHandle(serviceUserId))) {
      String msg=""String_Node_Str"" + componentName;
      if (fromUser) {
        throw new IllegalArgumentException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    if (wallpaper.userId == mCurrentUserId && mLastWallpaper != null) {
      detachWallpaperLocked(mLastWallpaper);
    }
    wallpaper.wallpaperComponent=componentName;
    wallpaper.connection=newConn;
    newConn.mReply=reply;
    try {
      if (wallpaper.userId == mCurrentUserId) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + newConn.mToken);
        mIWindowManager.addWindowToken(newConn.mToken,WindowManager.LayoutParams.TYPE_WALLPAPER);
        mLastWallpaper=wallpaper;
      }
    }
 catch (    RemoteException e) {
    }
  }
 catch (  RemoteException e) {
    String msg=""String_Node_Str"" + componentName + ""String_Node_Str""+ e;
    if (fromUser) {
      throw new IllegalArgumentException(msg);
    }
    Slog.w(TAG,msg);
    return false;
  }
  return true;
}",0.9940841131547812
199752,"@Override public void onServiceDisconnected(ComponentName name){
synchronized (mLock) {
    mService=null;
    mEngine=null;
    if (mWallpaper.connection == this) {
      Slog.w(TAG,""String_Node_Str"" + mWallpaper.wallpaperComponent);
      if (!mWallpaper.wallpaperUpdating && (mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME) > SystemClock.uptimeMillis() && mWallpaper.userId == mCurrentUserId) {
        Slog.w(TAG,""String_Node_Str"");
        clearWallpaperLocked(true,mWallpaper.userId,null);
      }
    }
  }
}","@Override public void onServiceDisconnected(ComponentName name){
synchronized (mLock) {
    mService=null;
    mEngine=null;
    if (mWallpaper.connection == this) {
      Slog.w(TAG,""String_Node_Str"" + mWallpaper.wallpaperComponent);
      if (!mWallpaper.wallpaperUpdating && mWallpaper.userId == mCurrentUserId) {
        if (mWallpaper.lastDiedTime != 0 && mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME > SystemClock.uptimeMillis()) {
          Slog.w(TAG,""String_Node_Str"");
          clearWallpaperLocked(true,mWallpaper.userId,null);
        }
 else {
          mWallpaper.lastDiedTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}",0.8143100511073254
199753,"public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
}","public KeyguardPatternView(Context context,AttributeSet attrs){
  super(context,attrs);
  mKeyguardUpdateMonitor=KeyguardUpdateMonitor.getInstance(mContext);
}",0.717741935483871
199754,"public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportUnlockAttempt(true);
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mTotalFailedPatternAttempts=0;
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    if (pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL) {
      mTotalFailedPatternAttempts++;
      mFailedPatternAttemptsSinceLastTimeout++;
      mCallback.reportUnlockAttempt(false);
    }
    if (mFailedPatternAttemptsSinceLastTimeout >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}","public void onPatternDetected(List<LockPatternView.Cell> pattern){
  if (mLockPatternUtils.checkPattern(pattern)) {
    mCallback.reportUnlockAttempt(true);
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Correct);
    mCallback.dismiss(true);
  }
 else {
    if (pattern.size() > MIN_PATTERN_BEFORE_POKE_WAKELOCK) {
      mCallback.userActivity(UNLOCK_PATTERN_WAKE_INTERVAL_MS);
    }
    mLockPatternView.setDisplayMode(LockPatternView.DisplayMode.Wrong);
    boolean registeredAttempt=pattern.size() >= LockPatternUtils.MIN_PATTERN_REGISTER_FAIL;
    if (registeredAttempt) {
      mCallback.reportUnlockAttempt(false);
    }
    int attempts=mKeyguardUpdateMonitor.getFailedUnlockAttempts();
    if (registeredAttempt && 0 == (attempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
      long deadline=mLockPatternUtils.setLockoutAttemptDeadline();
      handleAttemptLockout(deadline);
    }
 else {
      mSecurityMessageDisplay.setMessage(R.string.kg_wrong_pattern,true);
      mLockPatternView.postDelayed(mCancelPatternRunnable,PATTERN_CLEAR_TIMEOUT_MS);
    }
  }
}",0.8263038548752835
199755,"@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  mFailedPatternAttemptsSinceLastTimeout=0;
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","@Override public void onFinish(){
  mLockPatternView.setEnabled(true);
  displayDefaultSecurityMessage();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.9137254901960784
199756,"private void displayDefaultSecurityMessage(){
  if (KeyguardUpdateMonitor.getInstance(mContext).getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}","private void displayDefaultSecurityMessage(){
  if (mKeyguardUpdateMonitor.getMaxBiometricUnlockAttemptsReached()) {
    mSecurityMessageDisplay.setMessage(R.string.faceunlock_multiple_failures,true);
  }
 else {
    mSecurityMessageDisplay.setMessage(R.string.kg_pattern_instructions,false);
  }
}",0.9627228525121556
199757,"public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mTotalFailedPatternAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}","public void reset(){
  mLockPatternView.enableInput();
  mLockPatternView.setEnabled(true);
  mLockPatternView.clearPattern();
  long deadline=mLockPatternUtils.getLockoutAttemptDeadline();
  if (deadline != 0) {
    handleAttemptLockout(deadline);
  }
 else {
    displayDefaultSecurityMessage();
  }
  if (mCallback.isVerifyUnlockOnly()) {
    updateFooter(FooterMode.VerifyUnlocked);
  }
 else   if (mEnableFallback && (mKeyguardUpdateMonitor.getFailedUnlockAttempts() >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
 else {
    updateFooter(FooterMode.Normal);
  }
}",0.95392077607114
199758,"private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      mFailedPatternAttemptsSinceLastTimeout=0;
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}","private void handleAttemptLockout(long elapsedRealtimeDeadline){
  mLockPatternView.clearPattern();
  mLockPatternView.setEnabled(false);
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  if (mEnableFallback) {
    updateFooter(FooterMode.ForgotLockPattern);
  }
  mCountdownTimer=new CountDownTimer(elapsedRealtimeDeadline - elapsedRealtime,1000){
    @Override public void onTick(    long millisUntilFinished){
      final int secondsRemaining=(int)(millisUntilFinished / 1000);
      mSecurityMessageDisplay.setMessage(R.string.kg_too_many_failed_attempts_countdown,true,secondsRemaining);
    }
    @Override public void onFinish(){
      mLockPatternView.setEnabled(true);
      displayDefaultSecurityMessage();
      if (mEnableFallback) {
        updateFooter(FooterMode.ForgotLockPattern);
      }
 else {
        updateFooter(FooterMode.Normal);
      }
    }
  }
.start();
}",0.8684782608695653
199759,"@Override public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mLock) {
    if (mWallpaper.connection == this) {
      mWallpaper.lastDiedTime=SystemClock.uptimeMillis();
      mService=IWallpaperService.Stub.asInterface(service);
      attachServiceLocked(this,mWallpaper);
      saveSettingsLocked(mWallpaper);
    }
  }
}","@Override public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mLock) {
    if (mWallpaper.connection == this) {
      mService=IWallpaperService.Stub.asInterface(service);
      attachServiceLocked(this,mWallpaper);
      saveSettingsLocked(mWallpaper);
    }
  }
}",0.910493827160494
199760,"boolean bindWallpaperComponentLocked(ComponentName componentName,boolean force,boolean fromUser,WallpaperData wallpaper,IRemoteCallback reply){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + componentName);
  if (!force) {
    if (wallpaper.connection != null) {
      if (wallpaper.wallpaperComponent == null) {
        if (componentName == null) {
          if (DEBUG)           Slog.v(TAG,""String_Node_Str"");
          return true;
        }
      }
 else       if (wallpaper.wallpaperComponent.equals(componentName)) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
        return true;
      }
    }
  }
  try {
    if (componentName == null) {
      String defaultComponent=mContext.getString(com.android.internal.R.string.default_wallpaper_component);
      if (defaultComponent != null) {
        componentName=ComponentName.unflattenFromString(defaultComponent);
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + componentName);
      }
      if (componentName == null) {
        componentName=IMAGE_WALLPAPER;
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
      }
    }
    int serviceUserId=wallpaper.userId;
    ServiceInfo si=mIPackageManager.getServiceInfo(componentName,PackageManager.GET_META_DATA | PackageManager.GET_PERMISSIONS,serviceUserId);
    if (si == null) {
      Slog.w(TAG,""String_Node_Str"" + componentName + ""String_Node_Str"");
      return false;
    }
    if (!android.Manifest.permission.BIND_WALLPAPER.equals(si.permission)) {
      String msg=""String_Node_Str"" + android.Manifest.permission.BIND_WALLPAPER + ""String_Node_Str""+ componentName;
      if (fromUser) {
        throw new SecurityException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    WallpaperInfo wi=null;
    Intent intent=new Intent(WallpaperService.SERVICE_INTERFACE);
    if (componentName != null && !componentName.equals(IMAGE_WALLPAPER)) {
      List<ResolveInfo> ris=mIPackageManager.queryIntentServices(intent,intent.resolveTypeIfNeeded(mContext.getContentResolver()),PackageManager.GET_META_DATA,serviceUserId);
      for (int i=0; i < ris.size(); i++) {
        ServiceInfo rsi=ris.get(i).serviceInfo;
        if (rsi.name.equals(si.name) && rsi.packageName.equals(si.packageName)) {
          try {
            wi=new WallpaperInfo(mContext,ris.get(i));
          }
 catch (          XmlPullParserException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
catch (          IOException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
          break;
        }
      }
      if (wi == null) {
        String msg=""String_Node_Str"" + componentName;
        if (fromUser) {
          throw new SecurityException(msg);
        }
        Slog.w(TAG,msg);
        return false;
      }
    }
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + componentName);
    WallpaperConnection newConn=new WallpaperConnection(wi,wallpaper);
    intent.setComponent(componentName);
    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,com.android.internal.R.string.wallpaper_binding_label);
    intent.putExtra(Intent.EXTRA_CLIENT_INTENT,PendingIntent.getActivityAsUser(mContext,0,Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),mContext.getText(com.android.internal.R.string.chooser_wallpaper)),0,null,new UserHandle(serviceUserId)));
    if (!mContext.bindServiceAsUser(intent,newConn,Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,new UserHandle(serviceUserId))) {
      String msg=""String_Node_Str"" + componentName;
      if (fromUser) {
        throw new IllegalArgumentException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    if (wallpaper.userId == mCurrentUserId && mLastWallpaper != null) {
      detachWallpaperLocked(mLastWallpaper);
    }
    wallpaper.wallpaperComponent=componentName;
    wallpaper.connection=newConn;
    wallpaper.lastDiedTime=SystemClock.uptimeMillis();
    newConn.mReply=reply;
    try {
      if (wallpaper.userId == mCurrentUserId) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + newConn.mToken);
        mIWindowManager.addWindowToken(newConn.mToken,WindowManager.LayoutParams.TYPE_WALLPAPER);
        mLastWallpaper=wallpaper;
      }
    }
 catch (    RemoteException e) {
    }
  }
 catch (  RemoteException e) {
    String msg=""String_Node_Str"" + componentName + ""String_Node_Str""+ e;
    if (fromUser) {
      throw new IllegalArgumentException(msg);
    }
    Slog.w(TAG,msg);
    return false;
  }
  return true;
}","boolean bindWallpaperComponentLocked(ComponentName componentName,boolean force,boolean fromUser,WallpaperData wallpaper,IRemoteCallback reply){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + componentName);
  if (!force) {
    if (wallpaper.connection != null) {
      if (wallpaper.wallpaperComponent == null) {
        if (componentName == null) {
          if (DEBUG)           Slog.v(TAG,""String_Node_Str"");
          return true;
        }
      }
 else       if (wallpaper.wallpaperComponent.equals(componentName)) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
        return true;
      }
    }
  }
  try {
    if (componentName == null) {
      String defaultComponent=mContext.getString(com.android.internal.R.string.default_wallpaper_component);
      if (defaultComponent != null) {
        componentName=ComponentName.unflattenFromString(defaultComponent);
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + componentName);
      }
      if (componentName == null) {
        componentName=IMAGE_WALLPAPER;
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
      }
    }
    int serviceUserId=wallpaper.userId;
    ServiceInfo si=mIPackageManager.getServiceInfo(componentName,PackageManager.GET_META_DATA | PackageManager.GET_PERMISSIONS,serviceUserId);
    if (si == null) {
      Slog.w(TAG,""String_Node_Str"" + componentName + ""String_Node_Str"");
      return false;
    }
    if (!android.Manifest.permission.BIND_WALLPAPER.equals(si.permission)) {
      String msg=""String_Node_Str"" + android.Manifest.permission.BIND_WALLPAPER + ""String_Node_Str""+ componentName;
      if (fromUser) {
        throw new SecurityException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    WallpaperInfo wi=null;
    Intent intent=new Intent(WallpaperService.SERVICE_INTERFACE);
    if (componentName != null && !componentName.equals(IMAGE_WALLPAPER)) {
      List<ResolveInfo> ris=mIPackageManager.queryIntentServices(intent,intent.resolveTypeIfNeeded(mContext.getContentResolver()),PackageManager.GET_META_DATA,serviceUserId);
      for (int i=0; i < ris.size(); i++) {
        ServiceInfo rsi=ris.get(i).serviceInfo;
        if (rsi.name.equals(si.name) && rsi.packageName.equals(si.packageName)) {
          try {
            wi=new WallpaperInfo(mContext,ris.get(i));
          }
 catch (          XmlPullParserException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
catch (          IOException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
          break;
        }
      }
      if (wi == null) {
        String msg=""String_Node_Str"" + componentName;
        if (fromUser) {
          throw new SecurityException(msg);
        }
        Slog.w(TAG,msg);
        return false;
      }
    }
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + componentName);
    WallpaperConnection newConn=new WallpaperConnection(wi,wallpaper);
    intent.setComponent(componentName);
    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,com.android.internal.R.string.wallpaper_binding_label);
    intent.putExtra(Intent.EXTRA_CLIENT_INTENT,PendingIntent.getActivityAsUser(mContext,0,Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),mContext.getText(com.android.internal.R.string.chooser_wallpaper)),0,null,new UserHandle(serviceUserId)));
    if (!mContext.bindServiceAsUser(intent,newConn,Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,new UserHandle(serviceUserId))) {
      String msg=""String_Node_Str"" + componentName;
      if (fromUser) {
        throw new IllegalArgumentException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    if (wallpaper.userId == mCurrentUserId && mLastWallpaper != null) {
      detachWallpaperLocked(mLastWallpaper);
    }
    wallpaper.wallpaperComponent=componentName;
    wallpaper.connection=newConn;
    newConn.mReply=reply;
    try {
      if (wallpaper.userId == mCurrentUserId) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + newConn.mToken);
        mIWindowManager.addWindowToken(newConn.mToken,WindowManager.LayoutParams.TYPE_WALLPAPER);
        mLastWallpaper=wallpaper;
      }
    }
 catch (    RemoteException e) {
    }
  }
 catch (  RemoteException e) {
    String msg=""String_Node_Str"" + componentName + ""String_Node_Str""+ e;
    if (fromUser) {
      throw new IllegalArgumentException(msg);
    }
    Slog.w(TAG,msg);
    return false;
  }
  return true;
}",0.9940841131547812
199761,"@Override public void onServiceDisconnected(ComponentName name){
synchronized (mLock) {
    mService=null;
    mEngine=null;
    if (mWallpaper.connection == this) {
      Slog.w(TAG,""String_Node_Str"" + mWallpaper.wallpaperComponent);
      if (!mWallpaper.wallpaperUpdating && (mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME) > SystemClock.uptimeMillis() && mWallpaper.userId == mCurrentUserId) {
        Slog.w(TAG,""String_Node_Str"");
        clearWallpaperLocked(true,mWallpaper.userId,null);
      }
    }
  }
}","@Override public void onServiceDisconnected(ComponentName name){
synchronized (mLock) {
    mService=null;
    mEngine=null;
    if (mWallpaper.connection == this) {
      Slog.w(TAG,""String_Node_Str"" + mWallpaper.wallpaperComponent);
      if (!mWallpaper.wallpaperUpdating && mWallpaper.userId == mCurrentUserId) {
        if (mWallpaper.lastDiedTime != 0 && mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME > SystemClock.uptimeMillis()) {
          Slog.w(TAG,""String_Node_Str"");
          clearWallpaperLocked(true,mWallpaper.userId,null);
        }
 else {
          mWallpaper.lastDiedTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}",0.8143100511073254
199762,"@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  if (item.hasSubMenu()) {
    actionView.setOnTouchListener(new ForwardingListener(actionView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionView.setOnTouchListener(null);
  }
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}","@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}",0.6914710933028048
199763,"@Override public void bindItemView(MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
}","@Override public void bindItemView(final MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  final ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
  if (item.hasSubMenu()) {
    actionItemView.setOnTouchListener(new ForwardingListener(actionItemView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionItemView.setOnTouchListener(null);
  }
}",0.5004436557231589
199764,"@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  if (item.hasSubMenu()) {
    actionView.setOnTouchListener(new ForwardingListener(actionView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionView.setOnTouchListener(null);
  }
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}","@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}",0.6914710933028048
199765,"@Override public void bindItemView(MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
}","@Override public void bindItemView(final MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  final ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
  if (item.hasSubMenu()) {
    actionItemView.setOnTouchListener(new ForwardingListener(actionItemView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionItemView.setOnTouchListener(null);
  }
}",0.5004436557231589
199766,"@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  if (item.hasSubMenu()) {
    actionView.setOnTouchListener(new ForwardingListener(actionView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionView.setOnTouchListener(null);
  }
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}","@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}",0.6914710933028048
199767,"@Override public void bindItemView(MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
}","@Override public void bindItemView(final MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  final ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
  if (item.hasSubMenu()) {
    actionItemView.setOnTouchListener(new ForwardingListener(actionItemView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionItemView.setOnTouchListener(null);
  }
}",0.5004436557231589
199768,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199769,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199770,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974396235554632
199771,"/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else       if (id != View.NO_ID) {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=createAnimator(sceneRoot,start,end);
        if (animator != null) {
          View view=null;
          TransitionValues infoValues=null;
          if (end != null) {
            view=end.view;
            String[] properties=getTransitionProperties();
            if (view != null && properties != null && properties.length > 0) {
              infoValues=new TransitionValues();
              infoValues.view=view;
              TransitionValues newValues=endValues.viewValues.get(view);
              if (newValues != null) {
                for (int j=0; j < properties.length; ++j) {
                  infoValues.values.put(properties[j],newValues.values.get(properties[j]));
                }
              }
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
 else {
            view=(start != null) ? start.view : null;
          }
          if (animator != null) {
            AnimationInfo info=new AnimationInfo(view,getName(),infoValues);
            runningAnimators.put(animator,info);
            mAnimators.add(animator);
          }
        }
      }
    }
  }
}","/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else       if (id != View.NO_ID) {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=createAnimator(sceneRoot,start,end);
        if (animator != null) {
          View view=null;
          TransitionValues infoValues=null;
          if (end != null) {
            view=end.view;
            String[] properties=getTransitionProperties();
            if (view != null && properties != null && properties.length > 0) {
              infoValues=new TransitionValues();
              infoValues.view=view;
              TransitionValues newValues=endValues.viewValues.get(view);
              if (newValues != null) {
                for (int j=0; j < properties.length; ++j) {
                  infoValues.values.put(properties[j],newValues.values.get(properties[j]));
                }
              }
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
 else {
            view=(start != null) ? start.view : null;
          }
          if (animator != null) {
            AnimationInfo info=new AnimationInfo(view,getName(),sceneRoot.getWindowId(),infoValues);
            runningAnimators.put(animator,info);
            mAnimators.add(animator);
          }
        }
      }
    }
  }
}",0.998289136013687
199772,"AnimationInfo(View view,String name,TransitionValues values){
  this.view=view;
  this.name=name;
  this.values=values;
}","AnimationInfo(View view,String name,WindowId windowId,TransitionValues values){
  this.view=view;
  this.name=name;
  this.values=values;
  this.windowId=windowId;
}",0.8461538461538461
199773,"/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    for (int i=numOldAnims - 1; i >= 0; i--) {
      Animator anim=runningAnimators.keyAt(i);
      anim.pause();
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}","/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(View sceneRoot){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    WindowId windowId=sceneRoot.getWindowId();
    for (int i=numOldAnims - 1; i >= 0; i--) {
      AnimationInfo info=runningAnimators.valueAt(i);
      if (info.view != null && windowId.equals(info.windowId)) {
        Animator anim=runningAnimators.keyAt(i);
        anim.pause();
      }
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}",0.836801752464403
199774,"/** 
 * Resumes this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void resume(){
  if (mPaused) {
    if (!mEnded) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      for (int i=numOldAnims - 1; i >= 0; i--) {
        Animator anim=runningAnimators.keyAt(i);
        anim.resume();
      }
      if (mListeners != null && mListeners.size() > 0) {
        ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
        int numListeners=tmpListeners.size();
        for (int i=0; i < numListeners; ++i) {
          tmpListeners.get(i).onTransitionResume(this);
        }
      }
    }
    mPaused=false;
  }
}","/** 
 * Resumes this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void resume(View sceneRoot){
  if (mPaused) {
    if (!mEnded) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      WindowId windowId=sceneRoot.getWindowId();
      for (int i=numOldAnims - 1; i >= 0; i--) {
        AnimationInfo info=runningAnimators.valueAt(i);
        if (info.view != null && windowId.equals(info.windowId)) {
          Animator anim=runningAnimators.keyAt(i);
          anim.resume();
        }
      }
      if (mListeners != null && mListeners.size() > 0) {
        ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
        int numListeners=tmpListeners.size();
        for (int i=0; i < numListeners; ++i) {
          tmpListeners.get(i).onTransitionResume(this);
        }
      }
    }
    mPaused=false;
  }
}",0.8273381294964028
199775,"private static void sceneChangeSetup(ViewGroup sceneRoot,Transition transition){
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(sceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.pause();
    }
  }
  if (transition != null) {
    transition.captureValues(sceneRoot,true);
  }
  Scene previousScene=Scene.getCurrentScene(sceneRoot);
  if (previousScene != null) {
    previousScene.exit();
  }
}","private static void sceneChangeSetup(ViewGroup sceneRoot,Transition transition){
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(sceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.pause(sceneRoot);
    }
  }
  if (transition != null) {
    transition.captureValues(sceneRoot,true);
  }
  Scene previousScene=Scene.getCurrentScene(sceneRoot);
  if (previousScene != null) {
    previousScene.exit();
  }
}",0.991705069124424
199776,"@Override public boolean onPreDraw(){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(mSceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(mTransition);
  mTransition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  mTransition.captureValues(mSceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume();
    }
  }
  mTransition.playTransition(mSceneRoot);
  return true;
}","@Override public boolean onPreDraw(){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(mSceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(mTransition);
  mTransition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  mTransition.captureValues(mSceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(mSceneRoot);
    }
  }
  mTransition.playTransition(mSceneRoot);
  return true;
}",0.9958368026644464
199777,"@Override public void onViewDetachedFromWindow(View v){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(mSceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.resume();
    }
  }
  mTransition.clearValues(true);
}","@Override public void onViewDetachedFromWindow(View v){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(mSceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.resume(mSceneRoot);
    }
  }
  mTransition.clearValues(true);
}",0.98812351543943
199778,"/** 
 * @hide 
 */
@Override public void resume(){
  super.resume();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).resume();
  }
}","/** 
 * @hide 
 */
@Override public void resume(View sceneRoot){
  super.resume(sceneRoot);
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).resume(sceneRoot);
  }
}",0.9234449760765552
199779,"/** 
 * @hide 
 */
@Override public void pause(){
  super.pause();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).pause();
  }
}","/** 
 * @hide 
 */
@Override public void pause(View sceneRoot){
  super.pause(sceneRoot);
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).pause(sceneRoot);
  }
}",0.9223300970873788
199780,"/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else       if (id != View.NO_ID) {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=createAnimator(sceneRoot,start,end);
        if (animator != null) {
          View view=null;
          TransitionValues infoValues=null;
          if (end != null) {
            view=end.view;
            String[] properties=getTransitionProperties();
            if (view != null && properties != null && properties.length > 0) {
              infoValues=new TransitionValues();
              infoValues.view=view;
              TransitionValues newValues=endValues.viewValues.get(view);
              if (newValues != null) {
                for (int j=0; j < properties.length; ++j) {
                  infoValues.values.put(properties[j],newValues.values.get(properties[j]));
                }
              }
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
 else {
            view=(start != null) ? start.view : null;
          }
          if (animator != null) {
            AnimationInfo info=new AnimationInfo(view,getName(),infoValues);
            runningAnimators.put(animator,info);
            mAnimators.add(animator);
          }
        }
      }
    }
  }
}","/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else       if (id != View.NO_ID) {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=createAnimator(sceneRoot,start,end);
        if (animator != null) {
          View view=null;
          TransitionValues infoValues=null;
          if (end != null) {
            view=end.view;
            String[] properties=getTransitionProperties();
            if (view != null && properties != null && properties.length > 0) {
              infoValues=new TransitionValues();
              infoValues.view=view;
              TransitionValues newValues=endValues.viewValues.get(view);
              if (newValues != null) {
                for (int j=0; j < properties.length; ++j) {
                  infoValues.values.put(properties[j],newValues.values.get(properties[j]));
                }
              }
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
 else {
            view=(start != null) ? start.view : null;
          }
          if (animator != null) {
            AnimationInfo info=new AnimationInfo(view,getName(),sceneRoot.getWindowId(),infoValues);
            runningAnimators.put(animator,info);
            mAnimators.add(animator);
          }
        }
      }
    }
  }
}",0.998289136013687
199781,"AnimationInfo(View view,String name,TransitionValues values){
  this.view=view;
  this.name=name;
  this.values=values;
}","AnimationInfo(View view,String name,WindowId windowId,TransitionValues values){
  this.view=view;
  this.name=name;
  this.values=values;
  this.windowId=windowId;
}",0.8461538461538461
199782,"/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    for (int i=numOldAnims - 1; i >= 0; i--) {
      Animator anim=runningAnimators.keyAt(i);
      anim.pause();
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}","/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(View sceneRoot){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    WindowId windowId=sceneRoot.getWindowId();
    for (int i=numOldAnims - 1; i >= 0; i--) {
      AnimationInfo info=runningAnimators.valueAt(i);
      if (info.view != null && windowId.equals(info.windowId)) {
        Animator anim=runningAnimators.keyAt(i);
        anim.pause();
      }
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}",0.836801752464403
199783,"/** 
 * Resumes this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void resume(){
  if (mPaused) {
    if (!mEnded) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      for (int i=numOldAnims - 1; i >= 0; i--) {
        Animator anim=runningAnimators.keyAt(i);
        anim.resume();
      }
      if (mListeners != null && mListeners.size() > 0) {
        ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
        int numListeners=tmpListeners.size();
        for (int i=0; i < numListeners; ++i) {
          tmpListeners.get(i).onTransitionResume(this);
        }
      }
    }
    mPaused=false;
  }
}","/** 
 * Resumes this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void resume(View sceneRoot){
  if (mPaused) {
    if (!mEnded) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      WindowId windowId=sceneRoot.getWindowId();
      for (int i=numOldAnims - 1; i >= 0; i--) {
        AnimationInfo info=runningAnimators.valueAt(i);
        if (info.view != null && windowId.equals(info.windowId)) {
          Animator anim=runningAnimators.keyAt(i);
          anim.resume();
        }
      }
      if (mListeners != null && mListeners.size() > 0) {
        ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
        int numListeners=tmpListeners.size();
        for (int i=0; i < numListeners; ++i) {
          tmpListeners.get(i).onTransitionResume(this);
        }
      }
    }
    mPaused=false;
  }
}",0.8273381294964028
199784,"private static void sceneChangeSetup(ViewGroup sceneRoot,Transition transition){
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(sceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.pause();
    }
  }
  if (transition != null) {
    transition.captureValues(sceneRoot,true);
  }
  Scene previousScene=Scene.getCurrentScene(sceneRoot);
  if (previousScene != null) {
    previousScene.exit();
  }
}","private static void sceneChangeSetup(ViewGroup sceneRoot,Transition transition){
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(sceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.pause(sceneRoot);
    }
  }
  if (transition != null) {
    transition.captureValues(sceneRoot,true);
  }
  Scene previousScene=Scene.getCurrentScene(sceneRoot);
  if (previousScene != null) {
    previousScene.exit();
  }
}",0.991705069124424
199785,"@Override public boolean onPreDraw(){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(mSceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(mTransition);
  mTransition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  mTransition.captureValues(mSceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume();
    }
  }
  mTransition.playTransition(mSceneRoot);
  return true;
}","@Override public boolean onPreDraw(){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(mSceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(mTransition);
  mTransition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  mTransition.captureValues(mSceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(mSceneRoot);
    }
  }
  mTransition.playTransition(mSceneRoot);
  return true;
}",0.9958368026644464
199786,"@Override public void onViewDetachedFromWindow(View v){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(mSceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.resume();
    }
  }
  mTransition.clearValues(true);
}","@Override public void onViewDetachedFromWindow(View v){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(mSceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.resume(mSceneRoot);
    }
  }
  mTransition.clearValues(true);
}",0.98812351543943
199787,"/** 
 * @hide 
 */
@Override public void resume(){
  super.resume();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).resume();
  }
}","/** 
 * @hide 
 */
@Override public void resume(View sceneRoot){
  super.resume(sceneRoot);
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).resume(sceneRoot);
  }
}",0.9234449760765552
199788,"/** 
 * @hide 
 */
@Override public void pause(){
  super.pause();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).pause();
  }
}","/** 
 * @hide 
 */
@Override public void pause(View sceneRoot){
  super.pause(sceneRoot);
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).pause(sceneRoot);
  }
}",0.9223300970873788
199789,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974389146535612
199790,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974389146535612
199791,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974389146535612
199792,"@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  if (item.hasSubMenu()) {
    actionView.setOnTouchListener(new ForwardingListener(actionView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionView.setOnTouchListener(null);
  }
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}","@Override public View getItemView(final MenuItemImpl item,View convertView,ViewGroup parent){
  View actionView=item.getActionView();
  if (actionView == null || item.hasCollapsibleActionView()) {
    actionView=super.getItemView(item,convertView,parent);
  }
  actionView.setVisibility(item.isActionViewExpanded() ? View.GONE : View.VISIBLE);
  final ActionMenuView menuParent=(ActionMenuView)parent;
  final ViewGroup.LayoutParams lp=actionView.getLayoutParams();
  if (!menuParent.checkLayoutParams(lp)) {
    actionView.setLayoutParams(menuParent.generateLayoutParams(lp));
  }
  return actionView;
}",0.6914710933028048
199793,"@Override public void bindItemView(MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
}","@Override public void bindItemView(final MenuItemImpl item,MenuView.ItemView itemView){
  itemView.initialize(item,0);
  final ActionMenuView menuView=(ActionMenuView)mMenuView;
  final ActionMenuItemView actionItemView=(ActionMenuItemView)itemView;
  actionItemView.setItemInvoker(menuView);
  if (item.hasSubMenu()) {
    actionItemView.setOnTouchListener(new ForwardingListener(actionItemView){
      @Override public ListPopupWindow getPopup(){
        return mActionButtonPopup != null ? mActionButtonPopup.getPopup() : null;
      }
      @Override protected boolean onForwardingStarted(){
        return onSubMenuSelected((SubMenuBuilder)item.getSubMenu());
      }
      @Override protected boolean onForwardingStopped(){
        return dismissPopupMenus();
      }
    }
);
  }
 else {
    actionItemView.setOnTouchListener(null);
  }
}",0.5004436557231589
199794,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974396235554632
199795,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974396235554632
199796,"/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else       if (id != View.NO_ID) {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=createAnimator(sceneRoot,start,end);
        if (animator != null) {
          View view=null;
          TransitionValues infoValues=null;
          if (end != null) {
            view=end.view;
            String[] properties=getTransitionProperties();
            if (view != null && properties != null && properties.length > 0) {
              infoValues=new TransitionValues();
              infoValues.view=view;
              TransitionValues newValues=endValues.viewValues.get(view);
              if (newValues != null) {
                for (int j=0; j < properties.length; ++j) {
                  infoValues.values.put(properties[j],newValues.values.get(properties[j]));
                }
              }
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
 else {
            view=(start != null) ? start.view : null;
          }
          if (animator != null) {
            AnimationInfo info=new AnimationInfo(view,getName(),infoValues);
            runningAnimators.put(animator,info);
            mAnimators.add(animator);
          }
        }
      }
    }
  }
}","/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<View,TransitionValues> endCopy=new ArrayMap<View,TransitionValues>(endValues.viewValues);
  SparseArray<TransitionValues> endIdCopy=new SparseArray<TransitionValues>(endValues.idValues.size());
  for (int i=0; i < endValues.idValues.size(); ++i) {
    int id=endValues.idValues.keyAt(i);
    endIdCopy.put(id,endValues.idValues.valueAt(i));
  }
  LongSparseArray<TransitionValues> endItemIdCopy=new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
  for (int i=0; i < endValues.itemIdValues.size(); ++i) {
    long id=endValues.itemIdValues.keyAt(i);
    endItemIdCopy.put(id,endValues.itemIdValues.valueAt(i));
  }
  ArrayList<TransitionValues> startValuesList=new ArrayList<TransitionValues>();
  ArrayList<TransitionValues> endValuesList=new ArrayList<TransitionValues>();
  for (  View view : startValues.viewValues.keySet()) {
    TransitionValues start=null;
    TransitionValues end=null;
    boolean isInListView=false;
    if (view.getParent() instanceof ListView) {
      isInListView=true;
    }
    if (!isInListView) {
      int id=view.getId();
      start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      if (endValues.viewValues.get(view) != null) {
        end=endValues.viewValues.get(view);
        endCopy.remove(view);
      }
 else       if (id != View.NO_ID) {
        end=endValues.idValues.get(id);
        View removeView=null;
        for (        View viewToRemove : endCopy.keySet()) {
          if (viewToRemove.getId() == id) {
            removeView=viewToRemove;
          }
        }
        if (removeView != null) {
          endCopy.remove(removeView);
        }
      }
      endIdCopy.remove(id);
      if (isValidTarget(view,id)) {
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
 else {
      ListView parent=(ListView)view.getParent();
      if (parent.getAdapter().hasStableIds()) {
        int position=parent.getPositionForView(view);
        long itemId=parent.getItemIdAtPosition(position);
        start=startValues.itemIdValues.get(itemId);
        endItemIdCopy.remove(itemId);
        startValuesList.add(start);
        endValuesList.add(end);
      }
    }
  }
  int startItemIdCopySize=startValues.itemIdValues.size();
  for (int i=0; i < startItemIdCopySize; ++i) {
    long id=startValues.itemIdValues.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.itemIdValues.get(id);
      TransitionValues end=endValues.itemIdValues.get(id);
      endItemIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  for (  View view : endCopy.keySet()) {
    int id=view.getId();
    if (isValidTarget(view,id)) {
      TransitionValues start=startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
      TransitionValues end=endCopy.get(view);
      endIdCopy.remove(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endIdCopySize=endIdCopy.size();
  for (int i=0; i < endIdCopySize; ++i) {
    int id=endIdCopy.keyAt(i);
    if (isValidTarget(null,id)) {
      TransitionValues start=startValues.idValues.get(id);
      TransitionValues end=endIdCopy.get(id);
      startValuesList.add(start);
      endValuesList.add(end);
    }
  }
  int endItemIdCopySize=endItemIdCopy.size();
  for (int i=0; i < endItemIdCopySize; ++i) {
    long id=endItemIdCopy.keyAt(i);
    TransitionValues start=startValues.itemIdValues.get(id);
    TransitionValues end=endItemIdCopy.get(id);
    startValuesList.add(start);
    endValuesList.add(end);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  for (int i=0; i < startValuesList.size(); ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null || end != null) {
      if (start == null || !start.equals(end)) {
        if (DBG) {
          View view=(end != null) ? end.view : start.view;
          Log.d(LOG_TAG,""String_Node_Str"" + view);
          if (start == null || end == null) {
            Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
          }
 else {
            for (            String key : start.values.keySet()) {
              Object startValue=start.values.get(key);
              Object endValue=end.values.get(key);
              if (startValue != endValue && !startValue.equals(endValue)) {
                Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
              }
            }
          }
        }
        Animator animator=createAnimator(sceneRoot,start,end);
        if (animator != null) {
          View view=null;
          TransitionValues infoValues=null;
          if (end != null) {
            view=end.view;
            String[] properties=getTransitionProperties();
            if (view != null && properties != null && properties.length > 0) {
              infoValues=new TransitionValues();
              infoValues.view=view;
              TransitionValues newValues=endValues.viewValues.get(view);
              if (newValues != null) {
                for (int j=0; j < properties.length; ++j) {
                  infoValues.values.put(properties[j],newValues.values.get(properties[j]));
                }
              }
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
 else {
            view=(start != null) ? start.view : null;
          }
          if (animator != null) {
            AnimationInfo info=new AnimationInfo(view,getName(),sceneRoot.getWindowId(),infoValues);
            runningAnimators.put(animator,info);
            mAnimators.add(animator);
          }
        }
      }
    }
  }
}",0.998289136013687
199797,"AnimationInfo(View view,String name,TransitionValues values){
  this.view=view;
  this.name=name;
  this.values=values;
}","AnimationInfo(View view,String name,WindowId windowId,TransitionValues values){
  this.view=view;
  this.name=name;
  this.values=values;
  this.windowId=windowId;
}",0.8461538461538461
199798,"/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    for (int i=numOldAnims - 1; i >= 0; i--) {
      Animator anim=runningAnimators.keyAt(i);
      anim.pause();
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}","/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(View sceneRoot){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    WindowId windowId=sceneRoot.getWindowId();
    for (int i=numOldAnims - 1; i >= 0; i--) {
      AnimationInfo info=runningAnimators.valueAt(i);
      if (info.view != null && windowId.equals(info.windowId)) {
        Animator anim=runningAnimators.keyAt(i);
        anim.pause();
      }
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}",0.836801752464403
199799,"/** 
 * Resumes this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void resume(){
  if (mPaused) {
    if (!mEnded) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      for (int i=numOldAnims - 1; i >= 0; i--) {
        Animator anim=runningAnimators.keyAt(i);
        anim.resume();
      }
      if (mListeners != null && mListeners.size() > 0) {
        ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
        int numListeners=tmpListeners.size();
        for (int i=0; i < numListeners; ++i) {
          tmpListeners.get(i).onTransitionResume(this);
        }
      }
    }
    mPaused=false;
  }
}","/** 
 * Resumes this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void resume(View sceneRoot){
  if (mPaused) {
    if (!mEnded) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      WindowId windowId=sceneRoot.getWindowId();
      for (int i=numOldAnims - 1; i >= 0; i--) {
        AnimationInfo info=runningAnimators.valueAt(i);
        if (info.view != null && windowId.equals(info.windowId)) {
          Animator anim=runningAnimators.keyAt(i);
          anim.resume();
        }
      }
      if (mListeners != null && mListeners.size() > 0) {
        ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
        int numListeners=tmpListeners.size();
        for (int i=0; i < numListeners; ++i) {
          tmpListeners.get(i).onTransitionResume(this);
        }
      }
    }
    mPaused=false;
  }
}",0.8273381294964028
199800,"private static void sceneChangeSetup(ViewGroup sceneRoot,Transition transition){
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(sceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.pause();
    }
  }
  if (transition != null) {
    transition.captureValues(sceneRoot,true);
  }
  Scene previousScene=Scene.getCurrentScene(sceneRoot);
  if (previousScene != null) {
    previousScene.exit();
  }
}","private static void sceneChangeSetup(ViewGroup sceneRoot,Transition transition){
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(sceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.pause(sceneRoot);
    }
  }
  if (transition != null) {
    transition.captureValues(sceneRoot,true);
  }
  Scene previousScene=Scene.getCurrentScene(sceneRoot);
  if (previousScene != null) {
    previousScene.exit();
  }
}",0.991705069124424
199801,"@Override public boolean onPreDraw(){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(mSceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(mTransition);
  mTransition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  mTransition.captureValues(mSceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume();
    }
  }
  mTransition.playTransition(mSceneRoot);
  return true;
}","@Override public boolean onPreDraw(){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(mSceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(mTransition);
  mTransition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(mSceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  mTransition.captureValues(mSceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(mSceneRoot);
    }
  }
  mTransition.playTransition(mSceneRoot);
  return true;
}",0.9958368026644464
199802,"@Override public void onViewDetachedFromWindow(View v){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(mSceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.resume();
    }
  }
  mTransition.clearValues(true);
}","@Override public void onViewDetachedFromWindow(View v){
  removeListeners();
  sPendingTransitions.remove(mSceneRoot);
  ArrayList<Transition> runningTransitions=getRunningTransitions().get(mSceneRoot);
  if (runningTransitions != null && runningTransitions.size() > 0) {
    for (    Transition runningTransition : runningTransitions) {
      runningTransition.resume(mSceneRoot);
    }
  }
  mTransition.clearValues(true);
}",0.98812351543943
199803,"/** 
 * @hide 
 */
@Override public void resume(){
  super.resume();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).resume();
  }
}","/** 
 * @hide 
 */
@Override public void resume(View sceneRoot){
  super.resume(sceneRoot);
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).resume(sceneRoot);
  }
}",0.9234449760765552
199804,"/** 
 * @hide 
 */
@Override public void pause(){
  super.pause();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).pause();
  }
}","/** 
 * @hide 
 */
@Override public void pause(View sceneRoot){
  super.pause(sceneRoot);
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    mTransitions.get(i).pause(sceneRoot);
  }
}",0.9223300970873788
199805,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.9963636363636365
199806,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,boolean uninstalling,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null || uninstalling) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}",0.9953616647862604
199807,"private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}","private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}",0.9938144329896909
199808,"final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}","final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}",0.9988151658767772
199809,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9986486486486488
199810,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,false,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9968879668049792
199811,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            boolean fullUninstall=removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}",0.994988306047444
199812,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.9963636363636365
199813,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,boolean uninstalling,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null || uninstalling) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}",0.9953616647862604
199814,"private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}","private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}",0.9938144329896909
199815,"final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}","final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}",0.9988151658767772
199816,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9986486486486488
199817,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,false,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9968879668049792
199818,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            boolean fullUninstall=removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}",0.994988306047444
199819,"public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}","public void systemReady(final Runnable goingCallback){
synchronized (this) {
    if (mSystemReady) {
      if (goingCallback != null)       goingCallback.run();
      return;
    }
    if (!mDidUpdate) {
      if (mWaitingUpdate) {
        return;
      }
      Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
      List<ResolveInfo> ris=null;
      try {
        ris=AppGlobals.getPackageManager().queryIntentReceivers(intent,null,0,0);
      }
 catch (      RemoteException e) {
      }
      if (ris != null) {
        for (int i=ris.size() - 1; i >= 0; i--) {
          if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            ris.remove(i);
          }
        }
        intent.addFlags(Intent.FLAG_RECEIVER_BOOT_UPGRADE);
        ArrayList<ComponentName> lastDoneReceivers=readLastDonePreBootReceivers();
        final ArrayList<ComponentName> doneReceivers=new ArrayList<ComponentName>();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          if (lastDoneReceivers.contains(comp)) {
            ris.remove(i);
            i--;
            doneReceivers.add(comp);
          }
        }
        final int[] users=getUsersLocked();
        for (int i=0; i < ris.size(); i++) {
          ActivityInfo ai=ris.get(i).activityInfo;
          ComponentName comp=new ComponentName(ai.packageName,ai.name);
          doneReceivers.add(comp);
          intent.setComponent(comp);
          for (int j=0; j < users.length; j++) {
            IIntentReceiver finisher=null;
            if (i == ris.size() - 1 && j == users.length - 1) {
              finisher=new IIntentReceiver.Stub(){
                public void performReceive(                Intent intent,                int resultCode,                String data,                Bundle extras,                boolean ordered,                boolean sticky,                int sendingUser){
                  mHandler.post(new Runnable(){
                    public void run(){
synchronized (ActivityManagerService.this) {
                        mDidUpdate=true;
                      }
                      writeLastDonePreBootReceivers(doneReceivers);
                      showBootMessage(mContext.getText(R.string.android_upgrading_complete),false);
                      systemReady(goingCallback);
                    }
                  }
);
                }
              }
;
            }
            Slog.i(TAG,""String_Node_Str"" + intent.getComponent() + ""String_Node_Str""+ users[j]);
            broadcastIntentLocked(null,null,intent,null,finisher,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,users[j]);
            if (finisher != null) {
              mWaitingUpdate=true;
            }
          }
        }
      }
      if (mWaitingUpdate) {
        return;
      }
      mDidUpdate=true;
    }
    mAppOpsService.systemReady();
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  ArrayList<ProcessRecord> procsToKill=null;
synchronized (mPidsSelfLocked) {
    for (int i=mPidsSelfLocked.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mPidsSelfLocked.valueAt(i);
      if (!isAllowedWhileBooting(proc.info)) {
        if (procsToKill == null) {
          procsToKill=new ArrayList<ProcessRecord>();
        }
        procsToKill.add(proc);
      }
    }
  }
synchronized (this) {
    if (procsToKill != null) {
      for (int i=procsToKill.size() - 1; i >= 0; i--) {
        ProcessRecord proc=procsToKill.get(i);
        Slog.i(TAG,""String_Node_Str"" + proc);
        removeProcessLocked(proc,true,false,""String_Node_Str"");
      }
    }
    mProcessesReady=true;
  }
  Slog.i(TAG,""String_Node_Str"");
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    readGrantedUriPermissionsLocked();
  }
  if (goingCallback != null)   goingCallback.run();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info,false);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    mBooting=true;
    try {
      if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    long ident=Binder.clearCallingIdentity();
    try {
      Intent intent=new Intent(Intent.ACTION_USER_STARTED);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,mCurrentUserId);
      intent=new Intent(Intent.ACTION_USER_STARTING);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
      intent.putExtra(Intent.EXTRA_USER_HANDLE,mCurrentUserId);
      broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
        @Override public void performReceive(        Intent intent,        int resultCode,        String data,        Bundle extras,        boolean ordered,        boolean sticky,        int sendingUser) throws RemoteException {
        }
      }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
    mStackSupervisor.resumeTopActivitiesLocked();
    sendUserSwitchBroadcastsLocked(-1,mCurrentUserId);
  }
}",0.9974396235554632
199820,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.9963636363636365
199821,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,boolean uninstalling,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null || uninstalling) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}",0.9953616647862604
199822,"private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}","private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}",0.9938144329896909
199823,"final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}","final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}",0.9988151658767772
199824,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9986486486486488
199825,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,false,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9968879668049792
199826,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            boolean fullUninstall=removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}",0.994988306047444
199827,"@Override public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mLock) {
    if (mWallpaper.connection == this) {
      mWallpaper.lastDiedTime=SystemClock.uptimeMillis();
      mService=IWallpaperService.Stub.asInterface(service);
      attachServiceLocked(this,mWallpaper);
      saveSettingsLocked(mWallpaper);
    }
  }
}","@Override public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mLock) {
    if (mWallpaper.connection == this) {
      mService=IWallpaperService.Stub.asInterface(service);
      attachServiceLocked(this,mWallpaper);
      saveSettingsLocked(mWallpaper);
    }
  }
}",0.910493827160494
199828,"boolean bindWallpaperComponentLocked(ComponentName componentName,boolean force,boolean fromUser,WallpaperData wallpaper,IRemoteCallback reply){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + componentName);
  if (!force) {
    if (wallpaper.connection != null) {
      if (wallpaper.wallpaperComponent == null) {
        if (componentName == null) {
          if (DEBUG)           Slog.v(TAG,""String_Node_Str"");
          return true;
        }
      }
 else       if (wallpaper.wallpaperComponent.equals(componentName)) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
        return true;
      }
    }
  }
  try {
    if (componentName == null) {
      String defaultComponent=mContext.getString(com.android.internal.R.string.default_wallpaper_component);
      if (defaultComponent != null) {
        componentName=ComponentName.unflattenFromString(defaultComponent);
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + componentName);
      }
      if (componentName == null) {
        componentName=IMAGE_WALLPAPER;
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
      }
    }
    int serviceUserId=wallpaper.userId;
    ServiceInfo si=mIPackageManager.getServiceInfo(componentName,PackageManager.GET_META_DATA | PackageManager.GET_PERMISSIONS,serviceUserId);
    if (si == null) {
      Slog.w(TAG,""String_Node_Str"" + componentName + ""String_Node_Str"");
      return false;
    }
    if (!android.Manifest.permission.BIND_WALLPAPER.equals(si.permission)) {
      String msg=""String_Node_Str"" + android.Manifest.permission.BIND_WALLPAPER + ""String_Node_Str""+ componentName;
      if (fromUser) {
        throw new SecurityException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    WallpaperInfo wi=null;
    Intent intent=new Intent(WallpaperService.SERVICE_INTERFACE);
    if (componentName != null && !componentName.equals(IMAGE_WALLPAPER)) {
      List<ResolveInfo> ris=mIPackageManager.queryIntentServices(intent,intent.resolveTypeIfNeeded(mContext.getContentResolver()),PackageManager.GET_META_DATA,serviceUserId);
      for (int i=0; i < ris.size(); i++) {
        ServiceInfo rsi=ris.get(i).serviceInfo;
        if (rsi.name.equals(si.name) && rsi.packageName.equals(si.packageName)) {
          try {
            wi=new WallpaperInfo(mContext,ris.get(i));
          }
 catch (          XmlPullParserException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
catch (          IOException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
          break;
        }
      }
      if (wi == null) {
        String msg=""String_Node_Str"" + componentName;
        if (fromUser) {
          throw new SecurityException(msg);
        }
        Slog.w(TAG,msg);
        return false;
      }
    }
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + componentName);
    WallpaperConnection newConn=new WallpaperConnection(wi,wallpaper);
    intent.setComponent(componentName);
    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,com.android.internal.R.string.wallpaper_binding_label);
    intent.putExtra(Intent.EXTRA_CLIENT_INTENT,PendingIntent.getActivityAsUser(mContext,0,Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),mContext.getText(com.android.internal.R.string.chooser_wallpaper)),0,null,new UserHandle(serviceUserId)));
    if (!mContext.bindServiceAsUser(intent,newConn,Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,new UserHandle(serviceUserId))) {
      String msg=""String_Node_Str"" + componentName;
      if (fromUser) {
        throw new IllegalArgumentException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    if (wallpaper.userId == mCurrentUserId && mLastWallpaper != null) {
      detachWallpaperLocked(mLastWallpaper);
    }
    wallpaper.wallpaperComponent=componentName;
    wallpaper.connection=newConn;
    wallpaper.lastDiedTime=SystemClock.uptimeMillis();
    newConn.mReply=reply;
    try {
      if (wallpaper.userId == mCurrentUserId) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + newConn.mToken);
        mIWindowManager.addWindowToken(newConn.mToken,WindowManager.LayoutParams.TYPE_WALLPAPER);
        mLastWallpaper=wallpaper;
      }
    }
 catch (    RemoteException e) {
    }
  }
 catch (  RemoteException e) {
    String msg=""String_Node_Str"" + componentName + ""String_Node_Str""+ e;
    if (fromUser) {
      throw new IllegalArgumentException(msg);
    }
    Slog.w(TAG,msg);
    return false;
  }
  return true;
}","boolean bindWallpaperComponentLocked(ComponentName componentName,boolean force,boolean fromUser,WallpaperData wallpaper,IRemoteCallback reply){
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + componentName);
  if (!force) {
    if (wallpaper.connection != null) {
      if (wallpaper.wallpaperComponent == null) {
        if (componentName == null) {
          if (DEBUG)           Slog.v(TAG,""String_Node_Str"");
          return true;
        }
      }
 else       if (wallpaper.wallpaperComponent.equals(componentName)) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
        return true;
      }
    }
  }
  try {
    if (componentName == null) {
      String defaultComponent=mContext.getString(com.android.internal.R.string.default_wallpaper_component);
      if (defaultComponent != null) {
        componentName=ComponentName.unflattenFromString(defaultComponent);
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + componentName);
      }
      if (componentName == null) {
        componentName=IMAGE_WALLPAPER;
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"");
      }
    }
    int serviceUserId=wallpaper.userId;
    ServiceInfo si=mIPackageManager.getServiceInfo(componentName,PackageManager.GET_META_DATA | PackageManager.GET_PERMISSIONS,serviceUserId);
    if (si == null) {
      Slog.w(TAG,""String_Node_Str"" + componentName + ""String_Node_Str"");
      return false;
    }
    if (!android.Manifest.permission.BIND_WALLPAPER.equals(si.permission)) {
      String msg=""String_Node_Str"" + android.Manifest.permission.BIND_WALLPAPER + ""String_Node_Str""+ componentName;
      if (fromUser) {
        throw new SecurityException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    WallpaperInfo wi=null;
    Intent intent=new Intent(WallpaperService.SERVICE_INTERFACE);
    if (componentName != null && !componentName.equals(IMAGE_WALLPAPER)) {
      List<ResolveInfo> ris=mIPackageManager.queryIntentServices(intent,intent.resolveTypeIfNeeded(mContext.getContentResolver()),PackageManager.GET_META_DATA,serviceUserId);
      for (int i=0; i < ris.size(); i++) {
        ServiceInfo rsi=ris.get(i).serviceInfo;
        if (rsi.name.equals(si.name) && rsi.packageName.equals(si.packageName)) {
          try {
            wi=new WallpaperInfo(mContext,ris.get(i));
          }
 catch (          XmlPullParserException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
catch (          IOException e) {
            if (fromUser) {
              throw new IllegalArgumentException(e);
            }
            Slog.w(TAG,e);
            return false;
          }
          break;
        }
      }
      if (wi == null) {
        String msg=""String_Node_Str"" + componentName;
        if (fromUser) {
          throw new SecurityException(msg);
        }
        Slog.w(TAG,msg);
        return false;
      }
    }
    if (DEBUG)     Slog.v(TAG,""String_Node_Str"" + componentName);
    WallpaperConnection newConn=new WallpaperConnection(wi,wallpaper);
    intent.setComponent(componentName);
    intent.putExtra(Intent.EXTRA_CLIENT_LABEL,com.android.internal.R.string.wallpaper_binding_label);
    intent.putExtra(Intent.EXTRA_CLIENT_INTENT,PendingIntent.getActivityAsUser(mContext,0,Intent.createChooser(new Intent(Intent.ACTION_SET_WALLPAPER),mContext.getText(com.android.internal.R.string.chooser_wallpaper)),0,null,new UserHandle(serviceUserId)));
    if (!mContext.bindServiceAsUser(intent,newConn,Context.BIND_AUTO_CREATE | Context.BIND_SHOWING_UI,new UserHandle(serviceUserId))) {
      String msg=""String_Node_Str"" + componentName;
      if (fromUser) {
        throw new IllegalArgumentException(msg);
      }
      Slog.w(TAG,msg);
      return false;
    }
    if (wallpaper.userId == mCurrentUserId && mLastWallpaper != null) {
      detachWallpaperLocked(mLastWallpaper);
    }
    wallpaper.wallpaperComponent=componentName;
    wallpaper.connection=newConn;
    newConn.mReply=reply;
    try {
      if (wallpaper.userId == mCurrentUserId) {
        if (DEBUG)         Slog.v(TAG,""String_Node_Str"" + newConn.mToken);
        mIWindowManager.addWindowToken(newConn.mToken,WindowManager.LayoutParams.TYPE_WALLPAPER);
        mLastWallpaper=wallpaper;
      }
    }
 catch (    RemoteException e) {
    }
  }
 catch (  RemoteException e) {
    String msg=""String_Node_Str"" + componentName + ""String_Node_Str""+ e;
    if (fromUser) {
      throw new IllegalArgumentException(msg);
    }
    Slog.w(TAG,msg);
    return false;
  }
  return true;
}",0.9940841131547812
199829,"@Override public void onServiceDisconnected(ComponentName name){
synchronized (mLock) {
    mService=null;
    mEngine=null;
    if (mWallpaper.connection == this) {
      Slog.w(TAG,""String_Node_Str"" + mWallpaper.wallpaperComponent);
      if (!mWallpaper.wallpaperUpdating && (mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME) > SystemClock.uptimeMillis() && mWallpaper.userId == mCurrentUserId) {
        Slog.w(TAG,""String_Node_Str"");
        clearWallpaperLocked(true,mWallpaper.userId,null);
      }
    }
  }
}","@Override public void onServiceDisconnected(ComponentName name){
synchronized (mLock) {
    mService=null;
    mEngine=null;
    if (mWallpaper.connection == this) {
      Slog.w(TAG,""String_Node_Str"" + mWallpaper.wallpaperComponent);
      if (!mWallpaper.wallpaperUpdating && mWallpaper.userId == mCurrentUserId) {
        if (mWallpaper.lastDiedTime != 0 && mWallpaper.lastDiedTime + MIN_WALLPAPER_CRASH_TIME > SystemClock.uptimeMillis()) {
          Slog.w(TAG,""String_Node_Str"");
          clearWallpaperLocked(true,mWallpaper.userId,null);
        }
 else {
          mWallpaper.lastDiedTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}",0.8143100511073254
199830,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    try {
      app.instrumentationUiAutomationConnection.shutdown();
    }
 catch (    RemoteException re) {
    }
    mUserIsMonkey=false;
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.9963636363636365
199831,"private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}","private final boolean forceStopPackageLocked(String name,int appId,boolean callerWillRestart,boolean purgeCache,boolean doit,boolean evenPersistent,boolean uninstalling,int userId,String reason){
  int i;
  int N;
  if (userId == UserHandle.USER_ALL && name == null) {
    Slog.w(TAG,""String_Node_Str"");
  }
  if (appId < 0 && name != null) {
    try {
      appId=UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(name,0));
    }
 catch (    RemoteException e) {
    }
  }
  if (doit) {
    if (name != null) {
      Slog.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ appId+ ""String_Node_Str""+ userId+ ""String_Node_Str""+ reason);
    }
 else {
      Slog.i(TAG,""String_Node_Str"" + userId + ""String_Node_Str""+ reason);
    }
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    for (int ip=pmap.size() - 1; ip >= 0; ip--) {
      SparseArray<Long> ba=pmap.valueAt(ip);
      for (i=ba.size() - 1; i >= 0; i--) {
        boolean remove=false;
        final int entUid=ba.keyAt(i);
        if (name != null) {
          if (userId == UserHandle.USER_ALL) {
            if (UserHandle.getAppId(entUid) == appId) {
              remove=true;
            }
          }
 else {
            if (entUid == UserHandle.getUid(userId,appId)) {
              remove=true;
            }
          }
        }
 else         if (UserHandle.getUserId(entUid) == userId) {
          remove=true;
        }
        if (remove) {
          ba.removeAt(i);
        }
      }
      if (ba.size() == 0) {
        pmap.removeAt(ip);
      }
    }
  }
  boolean didSomething=killPackageProcessesLocked(name,appId,userId,-100,callerWillRestart,true,doit,evenPersistent,name == null ? (""String_Node_Str"" + userId) : (""String_Node_Str"" + name));
  if (mStackSupervisor.forceStopPackageLocked(name,doit,evenPersistent,userId)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (mServices.forceStopLocked(name,userId,evenPersistent,doit)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  if (name == null) {
    mStickyBroadcasts.remove(userId);
  }
  ArrayList<ContentProviderRecord> providers=new ArrayList<ContentProviderRecord>();
  if (mProviderMap.collectForceStopProviders(name,appId,doit,evenPersistent,userId,providers)) {
    if (!doit) {
      return true;
    }
    didSomething=true;
  }
  N=providers.size();
  for (i=0; i < N; i++) {
    removeDyingProviderLocked(null,providers.get(i),true);
  }
  removeUriPermissionsForPackageLocked(name,userId,false);
  if (name == null || uninstalling) {
    if (mIntentSenderRecords.size() > 0) {
      Iterator<WeakReference<PendingIntentRecord>> it=mIntentSenderRecords.values().iterator();
      while (it.hasNext()) {
        WeakReference<PendingIntentRecord> wpir=it.next();
        if (wpir == null) {
          it.remove();
          continue;
        }
        PendingIntentRecord pir=wpir.get();
        if (pir == null) {
          it.remove();
          continue;
        }
        if (name == null) {
          if (pir.key.userId != userId) {
            continue;
          }
        }
 else {
          if (UserHandle.getAppId(pir.uid) != appId) {
            continue;
          }
          if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
            continue;
          }
          if (!pir.key.packageName.equals(name)) {
            continue;
          }
        }
        if (!doit) {
          return true;
        }
        didSomething=true;
        it.remove();
        pir.canceled=true;
        if (pir.key.activity != null) {
          pir.key.activity.pendingResults.remove(pir.ref);
        }
      }
    }
  }
  if (doit) {
    if (purgeCache && name != null) {
      AttributeCache ac=AttributeCache.instance();
      if (ac != null) {
        ac.removePackage(name);
      }
    }
    if (mBooted) {
      mStackSupervisor.resumeTopActivitiesLocked();
      mStackSupervisor.scheduleIdleLocked();
    }
  }
  return didSomething;
}",0.9953616647862604
199832,"private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}","private void forceStopUserLocked(int userId,String reason){
  forceStopPackageLocked(null,-1,false,false,true,false,false,userId,reason);
  Intent intent=new Intent(Intent.ACTION_USER_STOPPED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
  intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
  broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
}",0.9938144329896909
199833,"final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}","final void finishBooting(){
  IntentFilter pkgFilter=new IntentFilter();
  pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
  pkgFilter.addDataScheme(""String_Node_Str"");
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      String[] pkgs=intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
      if (pkgs != null) {
        for (        String pkg : pkgs) {
synchronized (ActivityManagerService.this) {
            if (forceStopPackageLocked(pkg,-1,false,false,false,false,false,0,""String_Node_Str"")) {
              setResultCode(Activity.RESULT_OK);
              return;
            }
          }
        }
      }
    }
  }
,pkgFilter);
synchronized (this) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        if (DEBUG_PROCESSES)         Slog.v(TAG,""String_Node_Str"" + procs.get(ip));
        startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      Message nmsg=mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
      mHandler.sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < mStartedUsers.size(); i++) {
        UserStartedState uss=mStartedUsers.valueAt(i);
        if (uss.mState == UserStartedState.STATE_BOOTING) {
          uss.mState=UserStartedState.STATE_RUNNING;
          final int userId=mStartedUsers.keyAt(i);
          Intent intent=new Intent(Intent.ACTION_BOOT_COMPLETED,null);
          intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
          intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            @Override public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
synchronized (ActivityManagerService.this) {
                requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
              }
            }
          }
,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
        }
      }
    }
  }
}",0.9988151658767772
199834,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,true,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9986486486486488
199835,"public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void setDebugApp(String packageName,boolean waitForDebugger,boolean persistent){
  enforceCallingPermission(android.Manifest.permission.SET_DEBUG_APP,""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
    if (persistent) {
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.Global.putString(resolver,Settings.Global.DEBUG_APP,packageName);
      Settings.Global.putInt(resolver,Settings.Global.WAIT_FOR_DEBUGGER,waitForDebugger ? 1 : 0);
    }
synchronized (this) {
      if (!persistent) {
        mOrigDebugApp=mDebugApp;
        mOrigWaitForDebugger=mWaitForDebugger;
      }
      mDebugApp=packageName;
      mWaitForDebugger=waitForDebugger;
      mDebugTransient=!persistent;
      if (packageName != null) {
        forceStopPackageLocked(packageName,-1,false,false,true,true,false,UserHandle.USER_ALL,""String_Node_Str"");
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9968879668049792
199836,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,int appOp,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str"";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,""String_Node_Str"",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,false,userId,""String_Node_Str"");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            boolean fullUninstall=removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra(""String_Node_Str"");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Slog.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}",0.994988306047444
199837,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199838,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199839,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199840,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199841,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199842,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199843,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199844,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199845,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199846,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199847,"private boolean startUser(final int userId,boolean foreground){
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  final long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final int oldUserId=mCurrentUserId;
      if (oldUserId == userId) {
        return true;
      }
      final UserInfo userInfo=getUserManagerLocked().getUserInfo(userId);
      if (userInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + userId);
        return false;
      }
      mWindowManager.startFreezingScreen(R.anim.screen_user_exit,R.anim.screen_user_enter);
      boolean needStart=false;
      if (mStartedUsers.get(userId) == null) {
        mStartedUsers.put(userId,new UserStartedState(new UserHandle(userId),false));
        updateStartedUserArrayLocked();
        needStart=true;
      }
      final Integer userIdInt=Integer.valueOf(userId);
      mUserLru.remove(userIdInt);
      mUserLru.add(userIdInt);
      if (foreground) {
        mCurrentUserId=userId;
        mWindowManager.setCurrentUser(userId);
      }
 else {
        final Integer currentUserIdInt=Integer.valueOf(mCurrentUserId);
        mUserLru.remove(currentUserIdInt);
        mUserLru.add(currentUserIdInt);
      }
      mWindowManager.lockNow(null);
      final UserStartedState uss=mStartedUsers.get(userId);
      if (uss.mState == UserStartedState.STATE_STOPPING) {
        uss.mState=UserStartedState.STATE_RUNNING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
 else       if (uss.mState == UserStartedState.STATE_SHUTDOWN) {
        uss.mState=UserStartedState.STATE_BOOTING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
      if (foreground) {
        mHandler.removeMessages(REPORT_USER_SWITCH_MSG);
        mHandler.removeMessages(USER_SWITCH_TIMEOUT_MSG);
        mHandler.sendMessage(mHandler.obtainMessage(REPORT_USER_SWITCH_MSG,oldUserId,userId,uss));
        mHandler.sendMessageDelayed(mHandler.obtainMessage(USER_SWITCH_TIMEOUT_MSG,oldUserId,userId,uss),USER_SWITCH_TIMEOUT);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTED);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,userId);
      }
      if ((userInfo.flags & UserInfo.FLAG_INITIALIZED) == 0) {
        if (userId != 0) {
          Intent intent=new Intent(Intent.ACTION_USER_INITIALIZE);
          intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
              userInitialized(uss,userId);
            }
          }
,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
          uss.initializing=true;
        }
 else {
          getUserManagerLocked().makeInitialized(userInfo.id);
        }
      }
      if (foreground) {
        boolean homeInFront=mStackSupervisor.switchUserLocked(userId,uss);
        if (homeInFront) {
          startHomeActivityLocked(userId);
        }
 else {
          mStackSupervisor.resumeTopActivitiesLocked();
        }
        EventLogTags.writeAmSwitchUser(userId);
        getUserManagerLocked().userForeground(userId);
        sendUserSwitchBroadcastsLocked(oldUserId,userId);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTING);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky,          int sendingUser) throws RemoteException {
          }
        }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return true;
}","private boolean startUser(final int userId,boolean foreground){
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  final long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final int oldUserId=mCurrentUserId;
      if (oldUserId == userId) {
        return true;
      }
      final UserInfo userInfo=getUserManagerLocked().getUserInfo(userId);
      if (userInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + userId);
        return false;
      }
      if (foreground) {
        mWindowManager.startFreezingScreen(R.anim.screen_user_exit,R.anim.screen_user_enter);
      }
      boolean needStart=false;
      if (mStartedUsers.get(userId) == null) {
        mStartedUsers.put(userId,new UserStartedState(new UserHandle(userId),false));
        updateStartedUserArrayLocked();
        needStart=true;
      }
      final Integer userIdInt=Integer.valueOf(userId);
      mUserLru.remove(userIdInt);
      mUserLru.add(userIdInt);
      if (foreground) {
        mCurrentUserId=userId;
        mWindowManager.setCurrentUser(userId);
        mWindowManager.lockNow(null);
      }
 else {
        final Integer currentUserIdInt=Integer.valueOf(mCurrentUserId);
        mUserLru.remove(currentUserIdInt);
        mUserLru.add(currentUserIdInt);
      }
      final UserStartedState uss=mStartedUsers.get(userId);
      if (uss.mState == UserStartedState.STATE_STOPPING) {
        uss.mState=UserStartedState.STATE_RUNNING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
 else       if (uss.mState == UserStartedState.STATE_SHUTDOWN) {
        uss.mState=UserStartedState.STATE_BOOTING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
      if (foreground) {
        mHandler.removeMessages(REPORT_USER_SWITCH_MSG);
        mHandler.removeMessages(USER_SWITCH_TIMEOUT_MSG);
        mHandler.sendMessage(mHandler.obtainMessage(REPORT_USER_SWITCH_MSG,oldUserId,userId,uss));
        mHandler.sendMessageDelayed(mHandler.obtainMessage(USER_SWITCH_TIMEOUT_MSG,oldUserId,userId,uss),USER_SWITCH_TIMEOUT);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTED);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,userId);
      }
      if ((userInfo.flags & UserInfo.FLAG_INITIALIZED) == 0) {
        if (userId != 0) {
          Intent intent=new Intent(Intent.ACTION_USER_INITIALIZE);
          intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
              userInitialized(uss,userId);
            }
          }
,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
          uss.initializing=true;
        }
 else {
          getUserManagerLocked().makeInitialized(userInfo.id);
        }
      }
      if (foreground) {
        boolean homeInFront=mStackSupervisor.switchUserLocked(userId,uss);
        if (homeInFront) {
          startHomeActivityLocked(userId);
        }
 else {
          mStackSupervisor.resumeTopActivitiesLocked();
        }
        EventLogTags.writeAmSwitchUser(userId);
        getUserManagerLocked().userForeground(userId);
        sendUserSwitchBroadcastsLocked(oldUserId,userId);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTING);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky,          int sendingUser) throws RemoteException {
          }
        }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return true;
}",0.9887453105460609
199848,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199849,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199850,"private boolean startUser(final int userId,boolean foreground){
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  final long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final int oldUserId=mCurrentUserId;
      if (oldUserId == userId) {
        return true;
      }
      final UserInfo userInfo=getUserManagerLocked().getUserInfo(userId);
      if (userInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + userId);
        return false;
      }
      mWindowManager.startFreezingScreen(R.anim.screen_user_exit,R.anim.screen_user_enter);
      boolean needStart=false;
      if (mStartedUsers.get(userId) == null) {
        mStartedUsers.put(userId,new UserStartedState(new UserHandle(userId),false));
        updateStartedUserArrayLocked();
        needStart=true;
      }
      final Integer userIdInt=Integer.valueOf(userId);
      mUserLru.remove(userIdInt);
      mUserLru.add(userIdInt);
      if (foreground) {
        mCurrentUserId=userId;
        mWindowManager.setCurrentUser(userId);
      }
 else {
        final Integer currentUserIdInt=Integer.valueOf(mCurrentUserId);
        mUserLru.remove(currentUserIdInt);
        mUserLru.add(currentUserIdInt);
      }
      mWindowManager.lockNow(null);
      final UserStartedState uss=mStartedUsers.get(userId);
      if (uss.mState == UserStartedState.STATE_STOPPING) {
        uss.mState=UserStartedState.STATE_RUNNING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
 else       if (uss.mState == UserStartedState.STATE_SHUTDOWN) {
        uss.mState=UserStartedState.STATE_BOOTING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
      if (foreground) {
        mHandler.removeMessages(REPORT_USER_SWITCH_MSG);
        mHandler.removeMessages(USER_SWITCH_TIMEOUT_MSG);
        mHandler.sendMessage(mHandler.obtainMessage(REPORT_USER_SWITCH_MSG,oldUserId,userId,uss));
        mHandler.sendMessageDelayed(mHandler.obtainMessage(USER_SWITCH_TIMEOUT_MSG,oldUserId,userId,uss),USER_SWITCH_TIMEOUT);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTED);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,userId);
      }
      if ((userInfo.flags & UserInfo.FLAG_INITIALIZED) == 0) {
        if (userId != 0) {
          Intent intent=new Intent(Intent.ACTION_USER_INITIALIZE);
          intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
              userInitialized(uss,userId);
            }
          }
,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
          uss.initializing=true;
        }
 else {
          getUserManagerLocked().makeInitialized(userInfo.id);
        }
      }
      if (foreground) {
        boolean homeInFront=mStackSupervisor.switchUserLocked(userId,uss);
        if (homeInFront) {
          startHomeActivityLocked(userId);
        }
 else {
          mStackSupervisor.resumeTopActivitiesLocked();
        }
        EventLogTags.writeAmSwitchUser(userId);
        getUserManagerLocked().userForeground(userId);
        sendUserSwitchBroadcastsLocked(oldUserId,userId);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTING);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky,          int sendingUser) throws RemoteException {
          }
        }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return true;
}","private boolean startUser(final int userId,boolean foreground){
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  final long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final int oldUserId=mCurrentUserId;
      if (oldUserId == userId) {
        return true;
      }
      final UserInfo userInfo=getUserManagerLocked().getUserInfo(userId);
      if (userInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + userId);
        return false;
      }
      if (foreground) {
        mWindowManager.startFreezingScreen(R.anim.screen_user_exit,R.anim.screen_user_enter);
      }
      boolean needStart=false;
      if (mStartedUsers.get(userId) == null) {
        mStartedUsers.put(userId,new UserStartedState(new UserHandle(userId),false));
        updateStartedUserArrayLocked();
        needStart=true;
      }
      final Integer userIdInt=Integer.valueOf(userId);
      mUserLru.remove(userIdInt);
      mUserLru.add(userIdInt);
      if (foreground) {
        mCurrentUserId=userId;
        mWindowManager.setCurrentUser(userId);
        mWindowManager.lockNow(null);
      }
 else {
        final Integer currentUserIdInt=Integer.valueOf(mCurrentUserId);
        mUserLru.remove(currentUserIdInt);
        mUserLru.add(currentUserIdInt);
      }
      final UserStartedState uss=mStartedUsers.get(userId);
      if (uss.mState == UserStartedState.STATE_STOPPING) {
        uss.mState=UserStartedState.STATE_RUNNING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
 else       if (uss.mState == UserStartedState.STATE_SHUTDOWN) {
        uss.mState=UserStartedState.STATE_BOOTING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
      if (foreground) {
        mHandler.removeMessages(REPORT_USER_SWITCH_MSG);
        mHandler.removeMessages(USER_SWITCH_TIMEOUT_MSG);
        mHandler.sendMessage(mHandler.obtainMessage(REPORT_USER_SWITCH_MSG,oldUserId,userId,uss));
        mHandler.sendMessageDelayed(mHandler.obtainMessage(USER_SWITCH_TIMEOUT_MSG,oldUserId,userId,uss),USER_SWITCH_TIMEOUT);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTED);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,userId);
      }
      if ((userInfo.flags & UserInfo.FLAG_INITIALIZED) == 0) {
        if (userId != 0) {
          Intent intent=new Intent(Intent.ACTION_USER_INITIALIZE);
          intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
              userInitialized(uss,userId);
            }
          }
,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
          uss.initializing=true;
        }
 else {
          getUserManagerLocked().makeInitialized(userInfo.id);
        }
      }
      if (foreground) {
        boolean homeInFront=mStackSupervisor.switchUserLocked(userId,uss);
        if (homeInFront) {
          startHomeActivityLocked(userId);
        }
 else {
          mStackSupervisor.resumeTopActivitiesLocked();
        }
        EventLogTags.writeAmSwitchUser(userId);
        getUserManagerLocked().userForeground(userId);
        sendUserSwitchBroadcastsLocked(oldUserId,userId);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTING);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky,          int sendingUser) throws RemoteException {
          }
        }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return true;
}",0.9887453105460609
199851,"private boolean startUser(final int userId,boolean foreground){
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  final long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final int oldUserId=mCurrentUserId;
      if (oldUserId == userId) {
        return true;
      }
      final UserInfo userInfo=getUserManagerLocked().getUserInfo(userId);
      if (userInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + userId);
        return false;
      }
      mWindowManager.startFreezingScreen(R.anim.screen_user_exit,R.anim.screen_user_enter);
      boolean needStart=false;
      if (mStartedUsers.get(userId) == null) {
        mStartedUsers.put(userId,new UserStartedState(new UserHandle(userId),false));
        updateStartedUserArrayLocked();
        needStart=true;
      }
      final Integer userIdInt=Integer.valueOf(userId);
      mUserLru.remove(userIdInt);
      mUserLru.add(userIdInt);
      if (foreground) {
        mCurrentUserId=userId;
        mWindowManager.setCurrentUser(userId);
      }
 else {
        final Integer currentUserIdInt=Integer.valueOf(mCurrentUserId);
        mUserLru.remove(currentUserIdInt);
        mUserLru.add(currentUserIdInt);
      }
      mWindowManager.lockNow(null);
      final UserStartedState uss=mStartedUsers.get(userId);
      if (uss.mState == UserStartedState.STATE_STOPPING) {
        uss.mState=UserStartedState.STATE_RUNNING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
 else       if (uss.mState == UserStartedState.STATE_SHUTDOWN) {
        uss.mState=UserStartedState.STATE_BOOTING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
      if (foreground) {
        mHandler.removeMessages(REPORT_USER_SWITCH_MSG);
        mHandler.removeMessages(USER_SWITCH_TIMEOUT_MSG);
        mHandler.sendMessage(mHandler.obtainMessage(REPORT_USER_SWITCH_MSG,oldUserId,userId,uss));
        mHandler.sendMessageDelayed(mHandler.obtainMessage(USER_SWITCH_TIMEOUT_MSG,oldUserId,userId,uss),USER_SWITCH_TIMEOUT);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTED);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,userId);
      }
      if ((userInfo.flags & UserInfo.FLAG_INITIALIZED) == 0) {
        if (userId != 0) {
          Intent intent=new Intent(Intent.ACTION_USER_INITIALIZE);
          intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
              userInitialized(uss,userId);
            }
          }
,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
          uss.initializing=true;
        }
 else {
          getUserManagerLocked().makeInitialized(userInfo.id);
        }
      }
      if (foreground) {
        boolean homeInFront=mStackSupervisor.switchUserLocked(userId,uss);
        if (homeInFront) {
          startHomeActivityLocked(userId);
        }
 else {
          mStackSupervisor.resumeTopActivitiesLocked();
        }
        EventLogTags.writeAmSwitchUser(userId);
        getUserManagerLocked().userForeground(userId);
        sendUserSwitchBroadcastsLocked(oldUserId,userId);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTING);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky,          int sendingUser) throws RemoteException {
          }
        }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return true;
}","private boolean startUser(final int userId,boolean foreground){
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  final long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final int oldUserId=mCurrentUserId;
      if (oldUserId == userId) {
        return true;
      }
      final UserInfo userInfo=getUserManagerLocked().getUserInfo(userId);
      if (userInfo == null) {
        Slog.w(TAG,""String_Node_Str"" + userId);
        return false;
      }
      if (foreground) {
        mWindowManager.startFreezingScreen(R.anim.screen_user_exit,R.anim.screen_user_enter);
      }
      boolean needStart=false;
      if (mStartedUsers.get(userId) == null) {
        mStartedUsers.put(userId,new UserStartedState(new UserHandle(userId),false));
        updateStartedUserArrayLocked();
        needStart=true;
      }
      final Integer userIdInt=Integer.valueOf(userId);
      mUserLru.remove(userIdInt);
      mUserLru.add(userIdInt);
      if (foreground) {
        mCurrentUserId=userId;
        mWindowManager.setCurrentUser(userId);
        mWindowManager.lockNow(null);
      }
 else {
        final Integer currentUserIdInt=Integer.valueOf(mCurrentUserId);
        mUserLru.remove(currentUserIdInt);
        mUserLru.add(currentUserIdInt);
      }
      final UserStartedState uss=mStartedUsers.get(userId);
      if (uss.mState == UserStartedState.STATE_STOPPING) {
        uss.mState=UserStartedState.STATE_RUNNING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
 else       if (uss.mState == UserStartedState.STATE_SHUTDOWN) {
        uss.mState=UserStartedState.STATE_BOOTING;
        updateStartedUserArrayLocked();
        needStart=true;
      }
      if (foreground) {
        mHandler.removeMessages(REPORT_USER_SWITCH_MSG);
        mHandler.removeMessages(USER_SWITCH_TIMEOUT_MSG);
        mHandler.sendMessage(mHandler.obtainMessage(REPORT_USER_SWITCH_MSG,oldUserId,userId,uss));
        mHandler.sendMessageDelayed(mHandler.obtainMessage(USER_SWITCH_TIMEOUT_MSG,oldUserId,userId,uss),USER_SWITCH_TIMEOUT);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTED);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,userId);
      }
      if ((userInfo.flags & UserInfo.FLAG_INITIALIZED) == 0) {
        if (userId != 0) {
          Intent intent=new Intent(Intent.ACTION_USER_INITIALIZE);
          intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
          broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
            public void performReceive(            Intent intent,            int resultCode,            String data,            Bundle extras,            boolean ordered,            boolean sticky,            int sendingUser){
              userInitialized(uss,userId);
            }
          }
,0,null,null,null,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,userId);
          uss.initializing=true;
        }
 else {
          getUserManagerLocked().makeInitialized(userInfo.id);
        }
      }
      if (foreground) {
        boolean homeInFront=mStackSupervisor.switchUserLocked(userId,uss);
        if (homeInFront) {
          startHomeActivityLocked(userId);
        }
 else {
          mStackSupervisor.resumeTopActivitiesLocked();
        }
        EventLogTags.writeAmSwitchUser(userId);
        getUserManagerLocked().userForeground(userId);
        sendUserSwitchBroadcastsLocked(oldUserId,userId);
      }
      if (needStart) {
        Intent intent=new Intent(Intent.ACTION_USER_STARTING);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        intent.putExtra(Intent.EXTRA_USER_HANDLE,userId);
        broadcastIntentLocked(null,null,intent,null,new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky,          int sendingUser) throws RemoteException {
          }
        }
,0,null,null,android.Manifest.permission.INTERACT_ACROSS_USERS,AppOpsManager.OP_NONE,true,false,MY_PID,Process.SYSTEM_UID,UserHandle.USER_ALL);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return true;
}",0.9887453105460609
199852,"/** 
 * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.
 */
private double getMobilePowerPerPacket(){
  final long MOBILE_BPS=200000;
  final double MOBILE_POWER=mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE) / 3600;
  final long mobileRx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
  final long mobileTx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
  final long mobileData=mobileRx + mobileTx;
  final long radioDataUptimeMs=mStats.getMobileRadioActiveTime(mBatteryRealtime,mStatsType) / 1000;
  final double mobilePps=radioDataUptimeMs != 0 ? mobileData / (double)radioDataUptimeMs : (((double)MOBILE_BPS) / 8 / 2048);
  return (MOBILE_POWER / mobilePps) / (60 * 60);
}","/** 
 * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.
 */
private double getMobilePowerPerPacket(){
  final long MOBILE_BPS=200000;
  final double MOBILE_POWER=mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE) / 3600;
  final long mobileRx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
  final long mobileTx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
  final long mobileData=mobileRx + mobileTx;
  final long radioDataUptimeMs=mStats.getMobileRadioActiveTime(mBatteryRealtime,mStatsType) / 1000;
  final double mobilePps=(mobileData != 0 && radioDataUptimeMs != 0) ? (mobileData / (double)radioDataUptimeMs) : (((double)MOBILE_BPS) / 8 / 2048);
  return (MOBILE_POWER / mobilePps) / (60 * 60);
}",0.9853968253968254
199853,"private void updateNetworkActivityLocked(){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if (mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    if (mLastMobileSnapshot == null) {
      mLastMobileSnapshot=snapshot;
      return;
    }
    final NetworkStats delta=NetworkStats.subtract(snapshot,mLastMobileSnapshot,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastMobileSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
  if (mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    if (mLastWifiSnapshot == null) {
      mLastWifiSnapshot=snapshot;
      return;
    }
    final NetworkStats delta=NetworkStats.subtract(snapshot,mLastWifiSnapshot,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastWifiSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
}","private void updateNetworkActivityLocked(){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if (mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
  if (mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastWifiSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG) {
        final NetworkStats.Entry cur=snapshot.getValues(i,null);
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
      }
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
}",0.8328298086606244
199854,"/** 
 * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.
 */
private double getMobilePowerPerPacket(){
  final long MOBILE_BPS=200000;
  final double MOBILE_POWER=mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE) / 3600;
  final long mobileRx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
  final long mobileTx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
  final long mobileData=mobileRx + mobileTx;
  final long radioDataUptimeMs=mStats.getMobileRadioActiveTime(mBatteryRealtime,mStatsType) / 1000;
  final double mobilePps=radioDataUptimeMs != 0 ? mobileData / (double)radioDataUptimeMs : (((double)MOBILE_BPS) / 8 / 2048);
  return (MOBILE_POWER / mobilePps) / (60 * 60);
}","/** 
 * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.
 */
private double getMobilePowerPerPacket(){
  final long MOBILE_BPS=200000;
  final double MOBILE_POWER=mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE) / 3600;
  final long mobileRx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
  final long mobileTx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
  final long mobileData=mobileRx + mobileTx;
  final long radioDataUptimeMs=mStats.getMobileRadioActiveTime(mBatteryRealtime,mStatsType) / 1000;
  final double mobilePps=(mobileData != 0 && radioDataUptimeMs != 0) ? (mobileData / (double)radioDataUptimeMs) : (((double)MOBILE_BPS) / 8 / 2048);
  return (MOBILE_POWER / mobilePps) / (60 * 60);
}",0.9853968253968254
199855,"private void updateNetworkActivityLocked(){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if (mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    if (mLastMobileSnapshot == null) {
      mLastMobileSnapshot=snapshot;
      return;
    }
    final NetworkStats delta=NetworkStats.subtract(snapshot,mLastMobileSnapshot,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastMobileSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
  if (mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    if (mLastWifiSnapshot == null) {
      mLastWifiSnapshot=snapshot;
      return;
    }
    final NetworkStats delta=NetworkStats.subtract(snapshot,mLastWifiSnapshot,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastWifiSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
}","private void updateNetworkActivityLocked(){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if (mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
  if (mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastWifiSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG) {
        final NetworkStats.Entry cur=snapshot.getValues(i,null);
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
      }
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
}",0.8328298086606244
199856,"/** 
 * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.
 */
private double getMobilePowerPerPacket(){
  final long MOBILE_BPS=200000;
  final double MOBILE_POWER=mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE) / 3600;
  final long mobileRx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
  final long mobileTx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
  final long mobileData=mobileRx + mobileTx;
  final long radioDataUptimeMs=mStats.getMobileRadioActiveTime(mBatteryRealtime,mStatsType) / 1000;
  final double mobilePps=radioDataUptimeMs != 0 ? mobileData / (double)radioDataUptimeMs : (((double)MOBILE_BPS) / 8 / 2048);
  return (MOBILE_POWER / mobilePps) / (60 * 60);
}","/** 
 * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.
 */
private double getMobilePowerPerPacket(){
  final long MOBILE_BPS=200000;
  final double MOBILE_POWER=mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE) / 3600;
  final long mobileRx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
  final long mobileTx=mStats.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
  final long mobileData=mobileRx + mobileTx;
  final long radioDataUptimeMs=mStats.getMobileRadioActiveTime(mBatteryRealtime,mStatsType) / 1000;
  final double mobilePps=(mobileData != 0 && radioDataUptimeMs != 0) ? (mobileData / (double)radioDataUptimeMs) : (((double)MOBILE_BPS) / 8 / 2048);
  return (MOBILE_POWER / mobilePps) / (60 * 60);
}",0.9853968253968254
199857,"private void updateNetworkActivityLocked(){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if (mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    if (mLastMobileSnapshot == null) {
      mLastMobileSnapshot=snapshot;
      return;
    }
    final NetworkStats delta=NetworkStats.subtract(snapshot,mLastMobileSnapshot,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastMobileSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
  if (mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    if (mLastWifiSnapshot == null) {
      mLastWifiSnapshot=snapshot;
      return;
    }
    final NetworkStats delta=NetworkStats.subtract(snapshot,mLastWifiSnapshot,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastWifiSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
}","private void updateNetworkActivityLocked(){
  if (!SystemProperties.getBoolean(PROP_QTAGUID_ENABLED,false))   return;
  if (mMobileIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurMobileSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mMobileIfaces,NetworkStats.TAG_NONE,mLastMobileSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurMobileSnapshot=snapshot;
    mLastMobileSnapshot=last;
    final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
  if (mWifiIfaces.length > 0) {
    final NetworkStats snapshot;
    final NetworkStats last=mCurWifiSnapshot;
    try {
      snapshot=mNetworkStatsFactory.readNetworkStatsDetail(UID_ALL,mWifiIfaces,NetworkStats.TAG_NONE,mLastWifiSnapshot);
    }
 catch (    IOException e) {
      Log.wtf(TAG,""String_Node_Str"",e);
      return;
    }
    mCurWifiSnapshot=snapshot;
    mLastWifiSnapshot=last;
    final NetworkStats delta=NetworkStats.subtract(snapshot,last,null,null,mTmpNetworkStats);
    mTmpNetworkStats=delta;
    mLastWifiSnapshot=snapshot;
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG) {
        final NetworkStats.Entry cur=snapshot.getValues(i,null);
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ cur.rxBytes+ ""String_Node_Str""+ cur.txBytes);
      }
      if (entry.rxBytes == 0 || entry.txBytes == 0)       continue;
      final Uid u=getUidStatsLocked(entry.uid);
      u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
    }
  }
}",0.8328298086606244
199858,"private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}","private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  if (sNumSpeedSteps < 0 || sNumSpeedSteps > 100) {
    throw new BadParcelableException(""String_Node_Str"" + sNumSpeedSteps);
  }
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}",0.990811422109132
199859,"public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}","public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  Exception e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}",0.9931412894375856
199860,"private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}","private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  if (sNumSpeedSteps < 0 || sNumSpeedSteps > 100) {
    throw new BadParcelableException(""String_Node_Str"" + sNumSpeedSteps);
  }
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}",0.990811422109132
199861,"public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}","public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  Exception e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}",0.9931412894375856
199862,"private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}","private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  if (sNumSpeedSteps < 0 || sNumSpeedSteps > 100) {
    throw new BadParcelableException(""String_Node_Str"" + sNumSpeedSteps);
  }
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}",0.990811422109132
199863,"public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}","public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  Exception e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}",0.9931412894375856
199864,"private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}","private void readSummaryFromParcel(Parcel in){
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w(""String_Node_Str"",""String_Node_Str"" + version + ""String_Node_Str""+ VERSION+ ""String_Node_Str"");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mBatteryUptime=in.readLong();
  mBatteryRealtime=in.readLong();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mDischargeUnplugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mStartCount++;
  mScreenOn=false;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInputEventCounter.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioActive=false;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  if (sNumSpeedSteps < 0 || sNumSpeedSteps > 100) {
    throw new BadParcelableException(""String_Node_Str"" + sNumSpeedSteps);
  }
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,""String_Node_Str"" + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    u.mAudioTurnedOn=false;
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mVideoTurnedOn=false;
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,""String_Node_Str"" + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
      }
      if (in.readInt() != 0) {
        u.getWakeTimerLocked(wlName,WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
      }
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,""String_Node_Str"" + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mUnpluggables);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,""String_Node_Str"" + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      final int NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,""String_Node_Str"" + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}",0.990811422109132
199865,"public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  java.io.IOException e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}","public void readLocked(){
  if (mFile == null) {
    Slog.w(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  mUidStats.clear();
  try {
    File file=mFile.chooseForRead();
    if (!file.exists()) {
      return;
    }
    FileInputStream stream=new FileInputStream(file);
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readSummaryFromParcel(in);
  }
 catch (  Exception e) {
    Slog.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  long now=SystemClock.elapsedRealtime();
  if (USE_OLD_HISTORY) {
    addHistoryRecordLocked(now,HistoryItem.CMD_START);
  }
  addHistoryBufferLocked(now,HistoryItem.CMD_START);
}",0.9931412894375856
199866,"public boolean isInUse(){
  return mOwner != null;
}","public boolean isInUse(){
  return mOwner != null || mRestarting;
}",0.8739495798319328
199867,"public boolean isInUse(){
  return mOwner != null;
}","public boolean isInUse(){
  return mOwner != null || mRestarting;
}",0.8739495798319328
199868,"public boolean isInUse(){
  return mOwner != null;
}","public boolean isInUse(){
  return mOwner != null || mRestarting;
}",0.8739495798319328
199869,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199870,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199871,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199872,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199873,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199874,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199875,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199876,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199877,"static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  android.util.Log.e(""String_Node_Str"",""String_Node_Str"" + a);
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}","static public AllocationAdapter create2D(RenderScript rs,Allocation a){
  rs.validate();
  AllocationAdapter aa=new AllocationAdapter(0,rs,a);
  aa.mConstrainedLOD=true;
  aa.mConstrainedFace=true;
  aa.mConstrainedY=false;
  aa.mConstrainedZ=true;
  aa.initLOD(0);
  return aa;
}",0.898876404494382
199878,"private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive()) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}","private void helpDestroy(){
  boolean shouldDestroy=false;
synchronized (this) {
    if (!mDestroyed) {
      shouldDestroy=true;
      mDestroyed=true;
    }
  }
  if (shouldDestroy) {
    ReentrantReadWriteLock.ReadLock rlock=mRS.mRWLock.readLock();
    rlock.lock();
    if (mRS.isAlive() && mID != 0) {
      mRS.nObjDestroy(mID);
    }
    rlock.unlock();
    mRS=null;
    mID=0;
  }
}",0.9844155844155844
199879,"/** 
 * Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. <p>You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window.  If you use   {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}or   {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,and your content can be placed under those system elements.  You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. <p>The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true.  This behavior is off by default, but can be enabled through  {@link #setFitsSystemWindows(boolean)}. <p>This function's traversal down the hierarchy is depth-first.  The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal).  The first view that returns true will abort the entire traversal. <p>The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges.  If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window.  (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) <p>Note: unlike many View methods, there is no dispatch phase to this call.  If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. <p>Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows.  This can be used with code like the second sample (video player) shown in   {@link #setSystemUiVisibility(int)}.  {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 * @param insets Current content insets of the window.  Prior to{@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modifythe insets or else you and Android will be unhappy.
 * @return {@code true} if this view applied the insets and it should notcontinue propagating further down the hierarchy,  {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 * @deprecated As of API XX use {@link #dispatchApplyWindowInsets(WindowInsets)} to applyinsets to views. Views should override  {@link #onApplyWindowInsets(WindowInsets)} or use{@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}to implement handling their own insets.
 */
protected boolean fitSystemWindows(Rect insets){
  if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
    try {
      mPrivateFlags3|=PFLAG3_FITTING_SYSTEM_WINDOWS;
      return !dispatchApplyWindowInsets(new WindowInsets(insets)).hasInsets();
    }
  finally {
      mPrivateFlags3&=PFLAG3_FITTING_SYSTEM_WINDOWS;
    }
  }
 else {
    return fitSystemWindowsInt(insets);
  }
}","/** 
 * Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. <p>You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window.  If you use   {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}or   {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,and your content can be placed under those system elements.  You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. <p>The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true.  This behavior is off by default, but can be enabled through  {@link #setFitsSystemWindows(boolean)}. <p>This function's traversal down the hierarchy is depth-first.  The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal).  The first view that returns true will abort the entire traversal. <p>The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges.  If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window.  (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) <p>Note: unlike many View methods, there is no dispatch phase to this call.  If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. <p>Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows.  This can be used with code like the second sample (video player) shown in   {@link #setSystemUiVisibility(int)}.  {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 * @param insets Current content insets of the window.  Prior to{@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modifythe insets or else you and Android will be unhappy.
 * @return {@code true} if this view applied the insets and it should notcontinue propagating further down the hierarchy,  {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 * @deprecated As of API XX use {@link #dispatchApplyWindowInsets(WindowInsets)} to applyinsets to views. Views should override  {@link #onApplyWindowInsets(WindowInsets)} or use{@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}to implement handling their own insets.
 */
protected boolean fitSystemWindows(Rect insets){
  if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
    try {
      mPrivateFlags3|=PFLAG3_FITTING_SYSTEM_WINDOWS;
      return !dispatchApplyWindowInsets(new WindowInsets(insets)).hasInsets();
    }
  finally {
      mPrivateFlags3&=~PFLAG3_FITTING_SYSTEM_WINDOWS;
    }
  }
 else {
    return fitSystemWindowsInt(insets);
  }
}",0.9998701130016884
199880,"/** 
 * Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. <p>You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window.  If you use   {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}or   {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,and your content can be placed under those system elements.  You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. <p>The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true.  This behavior is off by default, but can be enabled through  {@link #setFitsSystemWindows(boolean)}. <p>This function's traversal down the hierarchy is depth-first.  The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal).  The first view that returns true will abort the entire traversal. <p>The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges.  If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window.  (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) <p>Note: unlike many View methods, there is no dispatch phase to this call.  If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. <p>Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows.  This can be used with code like the second sample (video player) shown in   {@link #setSystemUiVisibility(int)}.  {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 * @param insets Current content insets of the window.  Prior to{@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modifythe insets or else you and Android will be unhappy.
 * @return {@code true} if this view applied the insets and it should notcontinue propagating further down the hierarchy,  {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 * @deprecated As of API XX use {@link #dispatchApplyWindowInsets(WindowInsets)} to applyinsets to views. Views should override  {@link #onApplyWindowInsets(WindowInsets)} or use{@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}to implement handling their own insets.
 */
protected boolean fitSystemWindows(Rect insets){
  if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
    try {
      mPrivateFlags3|=PFLAG3_FITTING_SYSTEM_WINDOWS;
      return !dispatchApplyWindowInsets(new WindowInsets(insets)).hasInsets();
    }
  finally {
      mPrivateFlags3&=PFLAG3_FITTING_SYSTEM_WINDOWS;
    }
  }
 else {
    return fitSystemWindowsInt(insets);
  }
}","/** 
 * Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. <p>You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window.  If you use   {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}or   {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,and your content can be placed under those system elements.  You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. <p>The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true.  This behavior is off by default, but can be enabled through  {@link #setFitsSystemWindows(boolean)}. <p>This function's traversal down the hierarchy is depth-first.  The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal).  The first view that returns true will abort the entire traversal. <p>The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges.  If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window.  (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) <p>Note: unlike many View methods, there is no dispatch phase to this call.  If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. <p>Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows.  This can be used with code like the second sample (video player) shown in   {@link #setSystemUiVisibility(int)}.  {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 * @param insets Current content insets of the window.  Prior to{@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modifythe insets or else you and Android will be unhappy.
 * @return {@code true} if this view applied the insets and it should notcontinue propagating further down the hierarchy,  {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 * @deprecated As of API XX use {@link #dispatchApplyWindowInsets(WindowInsets)} to applyinsets to views. Views should override  {@link #onApplyWindowInsets(WindowInsets)} or use{@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}to implement handling their own insets.
 */
protected boolean fitSystemWindows(Rect insets){
  if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
    try {
      mPrivateFlags3|=PFLAG3_FITTING_SYSTEM_WINDOWS;
      return !dispatchApplyWindowInsets(new WindowInsets(insets)).hasInsets();
    }
  finally {
      mPrivateFlags3&=~PFLAG3_FITTING_SYSTEM_WINDOWS;
    }
  }
 else {
    return fitSystemWindowsInt(insets);
  }
}",0.9998701130016884
199881,"/** 
 * Reads one start command from the command socket. If successful, a child is forked and a   {@link ZygoteInit.MethodAndArgsCaller}exception is thrown in that child while in the parent process, the method returns normally. On failure, the child is not spawned and messages are printed to the log and stderr. Returns a boolean status value indicating whether an end-of-file on the command socket has been encountered.
 * @return false if command socket should continue to be read from, ortrue if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()method in child process
 */
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + ex.getMessage());
    closeSocket();
    return true;
  }
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException(""String_Node_Str"" + ""String_Node_Str"" + Long.toHexString(parsedArgs.permittedCapabilities) + ""String_Node_Str""+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Libcore.os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName);
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}","/** 
 * Reads one start command from the command socket. If successful, a child is forked and a   {@link ZygoteInit.MethodAndArgsCaller}exception is thrown in that child while in the parent process, the method returns normally. On failure, the child is not spawned and messages are printed to the log and stderr. Returns a boolean status value indicating whether an end-of-file on the command socket has been encountered.
 * @return false if command socket should continue to be read from, ortrue if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()method in child process
 */
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + ex.getMessage());
    closeSocket();
    return true;
  }
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException(""String_Node_Str"" + ""String_Node_Str"" + Long.toHexString(parsedArgs.permittedCapabilities) + ""String_Node_Str""+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Libcore.os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    int[] fdsToClose={-1,-1};
    FileDescriptor fd=mSocket.getFileDescriptor();
    if (fd != null) {
      fdsToClose[0]=fd.getInt$();
    }
    fd=ZygoteInit.getServerSocketFileDescriptor();
    if (fd != null) {
      fdsToClose[1]=fd.getInt$();
    }
    fd=null;
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName,fdsToClose);
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}",0.9593006592146748
199882,"/** 
 * Reads one start command from the command socket. If successful, a child is forked and a   {@link ZygoteInit.MethodAndArgsCaller}exception is thrown in that child while in the parent process, the method returns normally. On failure, the child is not spawned and messages are printed to the log and stderr. Returns a boolean status value indicating whether an end-of-file on the command socket has been encountered.
 * @return false if command socket should continue to be read from, ortrue if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()method in child process
 */
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + ex.getMessage());
    closeSocket();
    return true;
  }
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException(""String_Node_Str"" + ""String_Node_Str"" + Long.toHexString(parsedArgs.permittedCapabilities) + ""String_Node_Str""+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Libcore.os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName);
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}","/** 
 * Reads one start command from the command socket. If successful, a child is forked and a   {@link ZygoteInit.MethodAndArgsCaller}exception is thrown in that child while in the parent process, the method returns normally. On failure, the child is not spawned and messages are printed to the log and stderr. Returns a boolean status value indicating whether an end-of-file on the command socket has been encountered.
 * @return false if command socket should continue to be read from, ortrue if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()method in child process
 */
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + ex.getMessage());
    closeSocket();
    return true;
  }
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException(""String_Node_Str"" + ""String_Node_Str"" + Long.toHexString(parsedArgs.permittedCapabilities) + ""String_Node_Str""+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Libcore.os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    int[] fdsToClose={-1,-1};
    FileDescriptor fd=mSocket.getFileDescriptor();
    if (fd != null) {
      fdsToClose[0]=fd.getInt$();
    }
    fd=ZygoteInit.getServerSocketFileDescriptor();
    if (fd != null) {
      fdsToClose[1]=fd.getInt$();
    }
    fd=null;
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName,fdsToClose);
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}",0.9593006592146748
199883,"/** 
 * Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. <p>You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window.  If you use   {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}or   {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,and your content can be placed under those system elements.  You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. <p>The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true.  This behavior is off by default, but can be enabled through  {@link #setFitsSystemWindows(boolean)}. <p>This function's traversal down the hierarchy is depth-first.  The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal).  The first view that returns true will abort the entire traversal. <p>The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges.  If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window.  (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) <p>Note: unlike many View methods, there is no dispatch phase to this call.  If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. <p>Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows.  This can be used with code like the second sample (video player) shown in   {@link #setSystemUiVisibility(int)}.  {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 * @param insets Current content insets of the window.  Prior to{@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modifythe insets or else you and Android will be unhappy.
 * @return {@code true} if this view applied the insets and it should notcontinue propagating further down the hierarchy,  {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 * @deprecated As of API XX use {@link #dispatchApplyWindowInsets(WindowInsets)} to applyinsets to views. Views should override  {@link #onApplyWindowInsets(WindowInsets)} or use{@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}to implement handling their own insets.
 */
protected boolean fitSystemWindows(Rect insets){
  if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
    try {
      mPrivateFlags3|=PFLAG3_FITTING_SYSTEM_WINDOWS;
      return !dispatchApplyWindowInsets(new WindowInsets(insets)).hasInsets();
    }
  finally {
      mPrivateFlags3&=PFLAG3_FITTING_SYSTEM_WINDOWS;
    }
  }
 else {
    return fitSystemWindowsInt(insets);
  }
}","/** 
 * Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. <p>You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window.  If you use   {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}or   {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,and your content can be placed under those system elements.  You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. <p>The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true.  This behavior is off by default, but can be enabled through  {@link #setFitsSystemWindows(boolean)}. <p>This function's traversal down the hierarchy is depth-first.  The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal).  The first view that returns true will abort the entire traversal. <p>The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges.  If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window.  (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) <p>Note: unlike many View methods, there is no dispatch phase to this call.  If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. <p>Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows.  This can be used with code like the second sample (video player) shown in   {@link #setSystemUiVisibility(int)}.  {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 * @param insets Current content insets of the window.  Prior to{@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modifythe insets or else you and Android will be unhappy.
 * @return {@code true} if this view applied the insets and it should notcontinue propagating further down the hierarchy,  {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 * @deprecated As of API XX use {@link #dispatchApplyWindowInsets(WindowInsets)} to applyinsets to views. Views should override  {@link #onApplyWindowInsets(WindowInsets)} or use{@link #setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)}to implement handling their own insets.
 */
protected boolean fitSystemWindows(Rect insets){
  if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
    try {
      mPrivateFlags3|=PFLAG3_FITTING_SYSTEM_WINDOWS;
      return !dispatchApplyWindowInsets(new WindowInsets(insets)).hasInsets();
    }
  finally {
      mPrivateFlags3&=~PFLAG3_FITTING_SYSTEM_WINDOWS;
    }
  }
 else {
    return fitSystemWindowsInt(insets);
  }
}",0.9998701130016884
199884,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 */
public void removeContentProvider(IBinder connection,boolean stable){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    ContentProviderConnection conn;
    try {
      conn=(ContentProviderConnection)connection;
    }
 catch (    ClassCastException e) {
      String msg=""String_Node_Str"" + connection + ""String_Node_Str"";
      Slog.w(TAG,msg);
      throw new IllegalArgumentException(msg);
    }
    if (conn == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    if (decProviderCountLocked(conn,null,null,stable)) {
      updateOomAdjLocked();
    }
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 */
public void removeContentProvider(IBinder connection,boolean stable){
  enforceNotIsolatedCaller(""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ContentProviderConnection conn;
      try {
        conn=(ContentProviderConnection)connection;
      }
 catch (      ClassCastException e) {
        String msg=""String_Node_Str"" + connection + ""String_Node_Str"";
        Slog.w(TAG,msg);
        throw new IllegalArgumentException(msg);
      }
      if (conn == null) {
        throw new NullPointerException(""String_Node_Str"");
      }
      if (decProviderCountLocked(conn,null,null,stable)) {
        updateOomAdjLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9012016021361816
199885,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 */
public void removeContentProvider(IBinder connection,boolean stable){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    ContentProviderConnection conn;
    try {
      conn=(ContentProviderConnection)connection;
    }
 catch (    ClassCastException e) {
      String msg=""String_Node_Str"" + connection + ""String_Node_Str"";
      Slog.w(TAG,msg);
      throw new IllegalArgumentException(msg);
    }
    if (conn == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    if (decProviderCountLocked(conn,null,null,stable)) {
      updateOomAdjLocked();
    }
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 */
public void removeContentProvider(IBinder connection,boolean stable){
  enforceNotIsolatedCaller(""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ContentProviderConnection conn;
      try {
        conn=(ContentProviderConnection)connection;
      }
 catch (      ClassCastException e) {
        String msg=""String_Node_Str"" + connection + ""String_Node_Str"";
        Slog.w(TAG,msg);
        throw new IllegalArgumentException(msg);
      }
      if (conn == null) {
        throw new NullPointerException(""String_Node_Str"");
      }
      if (decProviderCountLocked(conn,null,null,stable)) {
        updateOomAdjLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9012016021361816
199886,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(l,t,r,b);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(0,0,r - l,b - t);
}",0.9292035398230089
199887,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(l,t,r,b);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(0,0,r - l,b - t);
}",0.9292035398230089
199888,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(l,t,r,b);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(0,0,r - l,b - t);
}",0.9292035398230089
199889,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(l,t,r,b);
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  mTextureView.layout(0,0,r - l,b - t);
}",0.9292035398230089
199890,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 */
public void removeContentProvider(IBinder connection,boolean stable){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    ContentProviderConnection conn;
    try {
      conn=(ContentProviderConnection)connection;
    }
 catch (    ClassCastException e) {
      String msg=""String_Node_Str"" + connection + ""String_Node_Str"";
      Slog.w(TAG,msg);
      throw new IllegalArgumentException(msg);
    }
    if (conn == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    if (decProviderCountLocked(conn,null,null,stable)) {
      updateOomAdjLocked();
    }
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 */
public void removeContentProvider(IBinder connection,boolean stable){
  enforceNotIsolatedCaller(""String_Node_Str"");
  long ident=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      ContentProviderConnection conn;
      try {
        conn=(ContentProviderConnection)connection;
      }
 catch (      ClassCastException e) {
        String msg=""String_Node_Str"" + connection + ""String_Node_Str"";
        Slog.w(TAG,msg);
        throw new IllegalArgumentException(msg);
      }
      if (conn == null) {
        throw new NullPointerException(""String_Node_Str"");
      }
      if (decProviderCountLocked(conn,null,null,stable)) {
        updateOomAdjLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9012016021361816
199891,"@Override protected boolean dismiss(boolean authenticated){
  boolean finished=super.dismiss(authenticated);
  if (!finished) {
    mViewStateManager.showBouncer(true);
    SecurityMode securityMode=getSecurityContainer().getSecurityMode();
    boolean isFullScreen=getResources().getBoolean(R.bool.kg_sim_puk_account_full_screen);
    boolean isSimOrAccount=securityMode == SecurityMode.SimPin || securityMode == SecurityMode.SimPuk || securityMode == SecurityMode.Account;
    mAppWidgetContainer.setVisibility(isSimOrAccount && isFullScreen ? View.GONE : View.VISIBLE);
    setSystemUiVisibility(isSimOrAccount ? (getSystemUiVisibility() | View.STATUS_BAR_DISABLE_SEARCH) : (getSystemUiVisibility() & ~View.STATUS_BAR_DISABLE_SEARCH));
    if (mSlidingChallengeLayout != null) {
      mSlidingChallengeLayout.setChallengeInteractive(!isFullScreen);
    }
  }
  return finished;
}","@Override public boolean dismiss(boolean authenticated){
  boolean finished=super.dismiss(authenticated);
  if (!finished) {
    mViewStateManager.showBouncer(true);
    SecurityMode securityMode=getSecurityContainer().getSecurityMode();
    boolean isFullScreen=getResources().getBoolean(R.bool.kg_sim_puk_account_full_screen);
    boolean isSimOrAccount=securityMode == SecurityMode.SimPin || securityMode == SecurityMode.SimPuk || securityMode == SecurityMode.Account;
    mAppWidgetContainer.setVisibility(isSimOrAccount && isFullScreen ? View.GONE : View.VISIBLE);
    setSystemUiVisibility(isSimOrAccount ? (getSystemUiVisibility() | View.STATUS_BAR_DISABLE_SEARCH) : (getSystemUiVisibility() & ~View.STATUS_BAR_DISABLE_SEARCH));
    if (mSlidingChallengeLayout != null) {
      mSlidingChallengeLayout.setChallengeInteractive(!isFullScreen);
    }
  }
  return finished;
}",0.9926178307779672
199892,"boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    securityMode=mSecurityModel.getAlternateFor(securityMode);
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
case Account:
case Biometric:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
 else {
showPrimarySecurityScreen(false);
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @param authenticated
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    securityMode=mSecurityModel.getAlternateFor(securityMode);
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
case Account:
case Biometric:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
 else {
showPrimarySecurityScreen(false);
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9168081494057724
199893,"/** 
 * Switches to the given security view unless it's already being shown, in which case this is a no-op.
 * @param securityMode
 */
private void showSecurityScreen(SecurityMode securityMode){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + securityMode + ""String_Node_Str"");
  if (securityMode == mCurrentSecuritySelection)   return;
  KeyguardSecurityView oldView=getSecurityView(mCurrentSecuritySelection);
  KeyguardSecurityView newView=getSecurityView(securityMode);
  if (oldView != null) {
    oldView.onPause();
    oldView.setKeyguardCallback(mNullCallback);
  }
  newView.onResume(KeyguardSecurityView.VIEW_REVEALED);
  newView.setKeyguardCallback(mCallback);
  final int childCount=mSecurityViewFlipper.getChildCount();
  final int securityViewIdForMode=getSecurityViewIdForMode(securityMode);
  for (int i=0; i < childCount; i++) {
    if (mSecurityViewFlipper.getChildAt(i).getId() == securityViewIdForMode) {
      mSecurityViewFlipper.setDisplayedChild(i);
      break;
    }
  }
  mCurrentSecuritySelection=securityMode;
}","/** 
 * Switches to the given security view unless it's already being shown, in which case this is a no-op.
 * @param securityMode
 */
private void showSecurityScreen(SecurityMode securityMode){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + securityMode + ""String_Node_Str"");
  if (securityMode == mCurrentSecuritySelection)   return;
  KeyguardSecurityView oldView=getSecurityView(mCurrentSecuritySelection);
  KeyguardSecurityView newView=getSecurityView(securityMode);
  if (oldView != null) {
    oldView.onPause();
    oldView.setKeyguardCallback(mNullCallback);
  }
  newView.onResume(KeyguardSecurityView.VIEW_REVEALED);
  newView.setKeyguardCallback(mCallback);
  final int childCount=mSecurityViewFlipper.getChildCount();
  final int securityViewIdForMode=getSecurityViewIdForMode(securityMode);
  for (int i=0; i < childCount; i++) {
    if (mSecurityViewFlipper.getChildAt(i).getId() == securityViewIdForMode) {
      mSecurityViewFlipper.setDisplayedChild(i);
      break;
    }
  }
  mCurrentSecuritySelection=securityMode;
  mSecurityCallback.onSecurityModeChanged(securityMode,newView.needsInput());
}",0.9637546468401488
199894,"public void setViewMediatorCallback(KeyguardViewMediator.ViewMediatorCallback viewMediatorCallback){
  mViewMediatorCallback=viewMediatorCallback;
}","public void setViewMediatorCallback(KeyguardViewMediator.ViewMediatorCallback viewMediatorCallback){
  mViewMediatorCallback=viewMediatorCallback;
  mViewMediatorCallback.setNeedsInput(mSecurityContainer.needsInput());
}",0.8043478260869565
199895,"/** 
 * Authentication has happened and it's time to dismiss keyguard. This function should clean up and inform KeyguardViewMediator.
 */
public void finish(){
  KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(true);
  boolean deferKeyguardDone=false;
  if (mDismissAction != null) {
    deferKeyguardDone=mDismissAction.onDismiss();
    mDismissAction=null;
  }
  if (mViewMediatorCallback != null) {
    if (deferKeyguardDone) {
      mViewMediatorCallback.keyguardDonePending();
    }
 else {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
}","/** 
 * Authentication has happened and it's time to dismiss keyguard. This function should clean up and inform KeyguardViewMediator.
 */
@Override public void finish(){
  KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(true);
  boolean deferKeyguardDone=false;
  if (mDismissAction != null) {
    deferKeyguardDone=mDismissAction.onDismiss();
    mDismissAction=null;
  }
  if (mViewMediatorCallback != null) {
    if (deferKeyguardDone) {
      mViewMediatorCallback.keyguardDonePending();
    }
 else {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
}",0.9914089347079038
199896,"/** 
 * Verify that the user can get past the keyguard securely.  This is called, for example, when the phone disables the keyguard but then wants to launch something else that requires secure access. The result will be propogated back via   {@link KeyguardViewCallback#keyguardDone(boolean)}
 */
public void verifyUnlock(){
  SecurityMode securityMode=getSecurityContainer().getSecurityMode();
  if (securityMode == KeyguardSecurityModel.SecurityMode.None) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
 else   if (securityMode != KeyguardSecurityModel.SecurityMode.Pattern && securityMode != KeyguardSecurityModel.SecurityMode.PIN && securityMode != KeyguardSecurityModel.SecurityMode.Password) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(false);
    }
  }
 else {
    mSecurityContainer.verifyUnlock();
  }
}","/** 
 * Verify that the user can get past the keyguard securely.  This is called, for example, when the phone disables the keyguard but then wants to launch something else that requires secure access. The result will be propogated back via   {@link KeyguardViewCallback#keyguardDone(boolean)}
 */
public void verifyUnlock(){
  SecurityMode securityMode=mSecurityContainer.getSecurityMode();
  if (securityMode == KeyguardSecurityModel.SecurityMode.None) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
 else   if (securityMode != KeyguardSecurityModel.SecurityMode.Pattern && securityMode != KeyguardSecurityModel.SecurityMode.PIN && securityMode != KeyguardSecurityModel.SecurityMode.Password) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(false);
    }
  }
 else {
    mSecurityContainer.verifyUnlock();
  }
}",0.9966814159292036
199897,"protected boolean dismiss(boolean authenticated){
  boolean finished=getSecurityContainer().showNextSecurityScreenOrFinish(authenticated);
  if (!finished) {
    updateAfterSecuritySelection();
  }
  return finished;
}","@Override public boolean dismiss(boolean authenticated){
  return mSecurityContainer.showNextSecurityScreenOrFinish(authenticated);
}",0.6495726495726496
199898,"protected void userActivity(){
  if (mViewMediatorCallback != null) {
    mViewMediatorCallback.userActivity();
  }
}","public void userActivity(){
  if (mViewMediatorCallback != null) {
    mViewMediatorCallback.userActivity();
  }
}",0.9523809523809524
199899,"@Override protected void onFinishInflate(){
  mSecurityContainer=(KeyguardSecurityContainer)findViewById(R.id.keyguard_security_container);
  mLockPatternUtils=new LockPatternUtils(mContext);
  mSecurityContainer.setLockPatternUtils(mLockPatternUtils);
  mSecurityContainer.setSecurityCallback(new SecurityCallback(){
    @Override public void userActivity(    long timeout){
      KeyguardViewBase.this.userActivity(timeout);
    }
    @Override public void dismiss(    boolean authenticated){
      KeyguardViewBase.this.dismiss(authenticated);
    }
    @Override public void finish(){
      KeyguardViewBase.this.finish();
    }
  }
);
  mSecurityContainer.showPrimarySecurityScreen(false);
  setBackButtonEnabled(false);
}","@Override protected void onFinishInflate(){
  mSecurityContainer=(KeyguardSecurityContainer)findViewById(R.id.keyguard_security_container);
  mLockPatternUtils=new LockPatternUtils(mContext);
  mSecurityContainer.setLockPatternUtils(mLockPatternUtils);
  mSecurityContainer.setSecurityCallback(this);
  mSecurityContainer.showPrimarySecurityScreen(false);
  setBackButtonEnabled(false);
}",0.5327354260089686
199900,"private void inflateKeyguardView(Bundle options){
  View v=mKeyguardHost.findViewById(R.id.keyguard_host_view);
  if (v != null) {
    mKeyguardHost.removeView(v);
  }
  final LayoutInflater inflater=LayoutInflater.from(mContext);
  View view=inflater.inflate(HOST_LAYOUT,mKeyguardHost,true);
  mKeyguardView=(KeyguardViewBase)view.findViewById(R.id.keyguard_host_view);
  mKeyguardView.setLockPatternUtils(mLockPatternUtils);
  mKeyguardView.setViewMediatorCallback(mViewMediatorCallback);
  mKeyguardView.onUserSwitching(options != null && options.getBoolean(IS_SWITCHING_USER));
  if (mViewMediatorCallback != null) {
    KeyguardPasswordView kpv=(KeyguardPasswordView)mKeyguardView.findViewById(R.id.keyguard_password_view);
    if (kpv != null) {
      mViewMediatorCallback.setNeedsInput(kpv.needsInput());
    }
  }
  mKeyguardView.onCreateOptions(options);
}","private KeyguardViewBase inflateKeyguardView(Bundle options,int layoutId){
  View v=mKeyguardHost.findViewById(R.id.keyguard_host_view);
  if (v != null) {
    mKeyguardHost.removeView(v);
  }
  final LayoutInflater inflater=LayoutInflater.from(mContext);
  View view=inflater.inflate(layoutId,mKeyguardHost,true);
  KeyguardViewBase keyguard=(KeyguardViewBase)view.findViewById(R.id.keyguard_host_view);
  keyguard.setLockPatternUtils(mLockPatternUtils);
  keyguard.setViewMediatorCallback(mViewMediatorCallback);
  keyguard.onUserSwitching(options != null && options.getBoolean(IS_SWITCHING_USER));
  keyguard.onCreateOptions(options);
  return keyguard;
}",0.6850393700787402
199901,"private void maybeCreateKeyguardLocked(boolean enableScreenRotation,boolean force,Bundle options){
  if (mKeyguardHost != null) {
    mKeyguardHost.saveHierarchyState(mStateContainer);
  }
  if (mKeyguardHost == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mKeyguardHost=new ViewManagerHost(mContext);
    int flags=WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN| WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
    if (!mNeedsInput) {
      flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
    }
    final int stretch=ViewGroup.LayoutParams.MATCH_PARENT;
    final int type=WindowManager.LayoutParams.TYPE_KEYGUARD;
    WindowManager.LayoutParams lp=new WindowManager.LayoutParams(stretch,stretch,type,flags,PixelFormat.TRANSLUCENT);
    lp.softInputMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    lp.windowAnimations=R.style.Animation_LockScreen;
    lp.screenOrientation=enableScreenRotation ? ActivityInfo.SCREEN_ORIENTATION_USER : ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    if (ActivityManager.isHighEndGfx()) {
      lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
      lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
    }
    lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    lp.inputFeatures|=WindowManager.LayoutParams.INPUT_FEATURE_DISABLE_USER_ACTIVITY;
    lp.setTitle(""String_Node_Str"");
    mWindowLayoutParams=lp;
    mViewManager.addView(mKeyguardHost,lp);
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mBackgroundChanger);
  }
  if (force || mKeyguardView == null) {
    mKeyguardHost.setCustomBackground(null);
    mKeyguardHost.removeAllViews();
    inflateKeyguardView(options);
    mKeyguardView.requestFocus();
  }
  updateUserActivityTimeoutInWindowLayoutParams();
  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);
  mKeyguardHost.restoreHierarchyState(mStateContainer);
}","private void maybeCreateKeyguardLocked(boolean enableScreenRotation,boolean force,Bundle options){
  if (mKeyguardHost != null) {
    mKeyguardHost.saveHierarchyState(mStateContainer);
  }
  if (mKeyguardHost == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mKeyguardHost=new ViewManagerHost(mContext);
    int flags=WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN| WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
    if (!mNeedsInput) {
      flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
    }
    final int stretch=ViewGroup.LayoutParams.MATCH_PARENT;
    final int type=WindowManager.LayoutParams.TYPE_KEYGUARD;
    WindowManager.LayoutParams lp=new WindowManager.LayoutParams(stretch,stretch,type,flags,PixelFormat.TRANSLUCENT);
    lp.softInputMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    lp.windowAnimations=R.style.Animation_LockScreen;
    lp.screenOrientation=enableScreenRotation ? ActivityInfo.SCREEN_ORIENTATION_USER : ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    if (ActivityManager.isHighEndGfx()) {
      lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
      lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
    }
    lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    lp.inputFeatures|=WindowManager.LayoutParams.INPUT_FEATURE_DISABLE_USER_ACTIVITY;
    lp.setTitle(""String_Node_Str"");
    mWindowLayoutParams=lp;
    mViewManager.addView(mKeyguardHost,lp);
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mBackgroundChanger);
  }
  if (force || mKeyguardView == null) {
    mKeyguardHost.setCustomBackground(null);
    mKeyguardHost.removeAllViews();
    int layout=allowNotificationsOnSecureKeyguard() ? R.layout.keyguard_simple_host_view : R.layout.keyguard_host_view;
    if (mCurrentLayout != layout) {
      mStateContainer.clear();
      mCurrentLayout=layout;
    }
    mKeyguardView=inflateKeyguardView(options,layout);
    mKeyguardView.requestFocus();
  }
  updateUserActivityTimeoutInWindowLayoutParams();
  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);
  mKeyguardHost.restoreHierarchyState(mStateContainer);
}",0.9358593928326866
199902,"@Override protected boolean dismiss(boolean authenticated){
  boolean finished=super.dismiss(authenticated);
  if (!finished) {
    mViewStateManager.showBouncer(true);
    SecurityMode securityMode=getSecurityContainer().getSecurityMode();
    boolean isFullScreen=getResources().getBoolean(R.bool.kg_sim_puk_account_full_screen);
    boolean isSimOrAccount=securityMode == SecurityMode.SimPin || securityMode == SecurityMode.SimPuk || securityMode == SecurityMode.Account;
    mAppWidgetContainer.setVisibility(isSimOrAccount && isFullScreen ? View.GONE : View.VISIBLE);
    setSystemUiVisibility(isSimOrAccount ? (getSystemUiVisibility() | View.STATUS_BAR_DISABLE_SEARCH) : (getSystemUiVisibility() & ~View.STATUS_BAR_DISABLE_SEARCH));
    if (mSlidingChallengeLayout != null) {
      mSlidingChallengeLayout.setChallengeInteractive(!isFullScreen);
    }
  }
  return finished;
}","@Override public boolean dismiss(boolean authenticated){
  boolean finished=super.dismiss(authenticated);
  if (!finished) {
    mViewStateManager.showBouncer(true);
    SecurityMode securityMode=getSecurityContainer().getSecurityMode();
    boolean isFullScreen=getResources().getBoolean(R.bool.kg_sim_puk_account_full_screen);
    boolean isSimOrAccount=securityMode == SecurityMode.SimPin || securityMode == SecurityMode.SimPuk || securityMode == SecurityMode.Account;
    mAppWidgetContainer.setVisibility(isSimOrAccount && isFullScreen ? View.GONE : View.VISIBLE);
    setSystemUiVisibility(isSimOrAccount ? (getSystemUiVisibility() | View.STATUS_BAR_DISABLE_SEARCH) : (getSystemUiVisibility() & ~View.STATUS_BAR_DISABLE_SEARCH));
    if (mSlidingChallengeLayout != null) {
      mSlidingChallengeLayout.setChallengeInteractive(!isFullScreen);
    }
  }
  return finished;
}",0.9926178307779672
199903,"boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    securityMode=mSecurityModel.getAlternateFor(securityMode);
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
case Account:
case Biometric:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
 else {
showPrimarySecurityScreen(false);
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}","/** 
 * Shows the next security screen if there is one.
 * @param authenticated true if the user entered the correct authentication
 * @param authenticated
 * @return true if keyguard is done
 */
boolean showNextSecurityScreenOrFinish(boolean authenticated){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authenticated + ""String_Node_Str"");
  boolean finish=false;
  if (SecurityMode.None == mCurrentSecuritySelection) {
    SecurityMode securityMode=mSecurityModel.getSecurityMode();
    securityMode=mSecurityModel.getAlternateFor(securityMode);
    if (SecurityMode.None == securityMode) {
      finish=true;
    }
 else {
      showSecurityScreen(securityMode);
    }
  }
 else   if (authenticated) {
switch (mCurrentSecuritySelection) {
case Pattern:
case Password:
case PIN:
case Account:
case Biometric:
      finish=true;
    break;
case SimPin:
case SimPuk:
  SecurityMode securityMode=mSecurityModel.getSecurityMode();
if (securityMode != SecurityMode.None) {
  showSecurityScreen(securityMode);
}
 else {
  finish=true;
}
break;
default :
Log.v(TAG,""String_Node_Str"" + mCurrentSecuritySelection + ""String_Node_Str"");
showPrimarySecurityScreen(false);
break;
}
}
 else {
showPrimarySecurityScreen(false);
}
if (finish) {
mSecurityCallback.finish();
}
return finish;
}",0.9168081494057724
199904,"/** 
 * Switches to the given security view unless it's already being shown, in which case this is a no-op.
 * @param securityMode
 */
private void showSecurityScreen(SecurityMode securityMode){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + securityMode + ""String_Node_Str"");
  if (securityMode == mCurrentSecuritySelection)   return;
  KeyguardSecurityView oldView=getSecurityView(mCurrentSecuritySelection);
  KeyguardSecurityView newView=getSecurityView(securityMode);
  if (oldView != null) {
    oldView.onPause();
    oldView.setKeyguardCallback(mNullCallback);
  }
  newView.onResume(KeyguardSecurityView.VIEW_REVEALED);
  newView.setKeyguardCallback(mCallback);
  final int childCount=mSecurityViewFlipper.getChildCount();
  final int securityViewIdForMode=getSecurityViewIdForMode(securityMode);
  for (int i=0; i < childCount; i++) {
    if (mSecurityViewFlipper.getChildAt(i).getId() == securityViewIdForMode) {
      mSecurityViewFlipper.setDisplayedChild(i);
      break;
    }
  }
  mCurrentSecuritySelection=securityMode;
}","/** 
 * Switches to the given security view unless it's already being shown, in which case this is a no-op.
 * @param securityMode
 */
private void showSecurityScreen(SecurityMode securityMode){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + securityMode + ""String_Node_Str"");
  if (securityMode == mCurrentSecuritySelection)   return;
  KeyguardSecurityView oldView=getSecurityView(mCurrentSecuritySelection);
  KeyguardSecurityView newView=getSecurityView(securityMode);
  if (oldView != null) {
    oldView.onPause();
    oldView.setKeyguardCallback(mNullCallback);
  }
  newView.onResume(KeyguardSecurityView.VIEW_REVEALED);
  newView.setKeyguardCallback(mCallback);
  final int childCount=mSecurityViewFlipper.getChildCount();
  final int securityViewIdForMode=getSecurityViewIdForMode(securityMode);
  for (int i=0; i < childCount; i++) {
    if (mSecurityViewFlipper.getChildAt(i).getId() == securityViewIdForMode) {
      mSecurityViewFlipper.setDisplayedChild(i);
      break;
    }
  }
  mCurrentSecuritySelection=securityMode;
  mSecurityCallback.onSecurityModeChanged(securityMode,newView.needsInput());
}",0.9637546468401488
199905,"public void setViewMediatorCallback(KeyguardViewMediator.ViewMediatorCallback viewMediatorCallback){
  mViewMediatorCallback=viewMediatorCallback;
}","public void setViewMediatorCallback(KeyguardViewMediator.ViewMediatorCallback viewMediatorCallback){
  mViewMediatorCallback=viewMediatorCallback;
  mViewMediatorCallback.setNeedsInput(mSecurityContainer.needsInput());
}",0.8043478260869565
199906,"/** 
 * Authentication has happened and it's time to dismiss keyguard. This function should clean up and inform KeyguardViewMediator.
 */
public void finish(){
  KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(true);
  boolean deferKeyguardDone=false;
  if (mDismissAction != null) {
    deferKeyguardDone=mDismissAction.onDismiss();
    mDismissAction=null;
  }
  if (mViewMediatorCallback != null) {
    if (deferKeyguardDone) {
      mViewMediatorCallback.keyguardDonePending();
    }
 else {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
}","/** 
 * Authentication has happened and it's time to dismiss keyguard. This function should clean up and inform KeyguardViewMediator.
 */
@Override public void finish(){
  KeyguardUpdateMonitor.getInstance(mContext).setAlternateUnlockEnabled(true);
  boolean deferKeyguardDone=false;
  if (mDismissAction != null) {
    deferKeyguardDone=mDismissAction.onDismiss();
    mDismissAction=null;
  }
  if (mViewMediatorCallback != null) {
    if (deferKeyguardDone) {
      mViewMediatorCallback.keyguardDonePending();
    }
 else {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
}",0.9914089347079038
199907,"/** 
 * Verify that the user can get past the keyguard securely.  This is called, for example, when the phone disables the keyguard but then wants to launch something else that requires secure access. The result will be propogated back via   {@link KeyguardViewCallback#keyguardDone(boolean)}
 */
public void verifyUnlock(){
  SecurityMode securityMode=getSecurityContainer().getSecurityMode();
  if (securityMode == KeyguardSecurityModel.SecurityMode.None) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
 else   if (securityMode != KeyguardSecurityModel.SecurityMode.Pattern && securityMode != KeyguardSecurityModel.SecurityMode.PIN && securityMode != KeyguardSecurityModel.SecurityMode.Password) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(false);
    }
  }
 else {
    mSecurityContainer.verifyUnlock();
  }
}","/** 
 * Verify that the user can get past the keyguard securely.  This is called, for example, when the phone disables the keyguard but then wants to launch something else that requires secure access. The result will be propogated back via   {@link KeyguardViewCallback#keyguardDone(boolean)}
 */
public void verifyUnlock(){
  SecurityMode securityMode=mSecurityContainer.getSecurityMode();
  if (securityMode == KeyguardSecurityModel.SecurityMode.None) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(true);
    }
  }
 else   if (securityMode != KeyguardSecurityModel.SecurityMode.Pattern && securityMode != KeyguardSecurityModel.SecurityMode.PIN && securityMode != KeyguardSecurityModel.SecurityMode.Password) {
    if (mViewMediatorCallback != null) {
      mViewMediatorCallback.keyguardDone(false);
    }
  }
 else {
    mSecurityContainer.verifyUnlock();
  }
}",0.9966814159292036
199908,"protected boolean dismiss(boolean authenticated){
  boolean finished=getSecurityContainer().showNextSecurityScreenOrFinish(authenticated);
  if (!finished) {
    updateAfterSecuritySelection();
  }
  return finished;
}","@Override public boolean dismiss(boolean authenticated){
  return mSecurityContainer.showNextSecurityScreenOrFinish(authenticated);
}",0.6495726495726496
199909,"protected void userActivity(){
  if (mViewMediatorCallback != null) {
    mViewMediatorCallback.userActivity();
  }
}","public void userActivity(){
  if (mViewMediatorCallback != null) {
    mViewMediatorCallback.userActivity();
  }
}",0.9523809523809524
199910,"@Override protected void onFinishInflate(){
  mSecurityContainer=(KeyguardSecurityContainer)findViewById(R.id.keyguard_security_container);
  mLockPatternUtils=new LockPatternUtils(mContext);
  mSecurityContainer.setLockPatternUtils(mLockPatternUtils);
  mSecurityContainer.setSecurityCallback(new SecurityCallback(){
    @Override public void userActivity(    long timeout){
      KeyguardViewBase.this.userActivity(timeout);
    }
    @Override public void dismiss(    boolean authenticated){
      KeyguardViewBase.this.dismiss(authenticated);
    }
    @Override public void finish(){
      KeyguardViewBase.this.finish();
    }
  }
);
  mSecurityContainer.showPrimarySecurityScreen(false);
  setBackButtonEnabled(false);
}","@Override protected void onFinishInflate(){
  mSecurityContainer=(KeyguardSecurityContainer)findViewById(R.id.keyguard_security_container);
  mLockPatternUtils=new LockPatternUtils(mContext);
  mSecurityContainer.setLockPatternUtils(mLockPatternUtils);
  mSecurityContainer.setSecurityCallback(this);
  mSecurityContainer.showPrimarySecurityScreen(false);
  setBackButtonEnabled(false);
}",0.5327354260089686
199911,"private void inflateKeyguardView(Bundle options){
  View v=mKeyguardHost.findViewById(R.id.keyguard_host_view);
  if (v != null) {
    mKeyguardHost.removeView(v);
  }
  final LayoutInflater inflater=LayoutInflater.from(mContext);
  View view=inflater.inflate(HOST_LAYOUT,mKeyguardHost,true);
  mKeyguardView=(KeyguardViewBase)view.findViewById(R.id.keyguard_host_view);
  mKeyguardView.setLockPatternUtils(mLockPatternUtils);
  mKeyguardView.setViewMediatorCallback(mViewMediatorCallback);
  mKeyguardView.onUserSwitching(options != null && options.getBoolean(IS_SWITCHING_USER));
  if (mViewMediatorCallback != null) {
    KeyguardPasswordView kpv=(KeyguardPasswordView)mKeyguardView.findViewById(R.id.keyguard_password_view);
    if (kpv != null) {
      mViewMediatorCallback.setNeedsInput(kpv.needsInput());
    }
  }
  mKeyguardView.onCreateOptions(options);
}","private KeyguardViewBase inflateKeyguardView(Bundle options,int layoutId){
  View v=mKeyguardHost.findViewById(R.id.keyguard_host_view);
  if (v != null) {
    mKeyguardHost.removeView(v);
  }
  final LayoutInflater inflater=LayoutInflater.from(mContext);
  View view=inflater.inflate(layoutId,mKeyguardHost,true);
  KeyguardViewBase keyguard=(KeyguardViewBase)view.findViewById(R.id.keyguard_host_view);
  keyguard.setLockPatternUtils(mLockPatternUtils);
  keyguard.setViewMediatorCallback(mViewMediatorCallback);
  keyguard.onUserSwitching(options != null && options.getBoolean(IS_SWITCHING_USER));
  keyguard.onCreateOptions(options);
  return keyguard;
}",0.6850393700787402
199912,"private void maybeCreateKeyguardLocked(boolean enableScreenRotation,boolean force,Bundle options){
  if (mKeyguardHost != null) {
    mKeyguardHost.saveHierarchyState(mStateContainer);
  }
  if (mKeyguardHost == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mKeyguardHost=new ViewManagerHost(mContext);
    int flags=WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN| WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
    if (!mNeedsInput) {
      flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
    }
    final int stretch=ViewGroup.LayoutParams.MATCH_PARENT;
    final int type=WindowManager.LayoutParams.TYPE_KEYGUARD;
    WindowManager.LayoutParams lp=new WindowManager.LayoutParams(stretch,stretch,type,flags,PixelFormat.TRANSLUCENT);
    lp.softInputMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    lp.windowAnimations=R.style.Animation_LockScreen;
    lp.screenOrientation=enableScreenRotation ? ActivityInfo.SCREEN_ORIENTATION_USER : ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    if (ActivityManager.isHighEndGfx()) {
      lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
      lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
    }
    lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    lp.inputFeatures|=WindowManager.LayoutParams.INPUT_FEATURE_DISABLE_USER_ACTIVITY;
    lp.setTitle(""String_Node_Str"");
    mWindowLayoutParams=lp;
    mViewManager.addView(mKeyguardHost,lp);
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mBackgroundChanger);
  }
  if (force || mKeyguardView == null) {
    mKeyguardHost.setCustomBackground(null);
    mKeyguardHost.removeAllViews();
    inflateKeyguardView(options);
    mKeyguardView.requestFocus();
  }
  updateUserActivityTimeoutInWindowLayoutParams();
  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);
  mKeyguardHost.restoreHierarchyState(mStateContainer);
}","private void maybeCreateKeyguardLocked(boolean enableScreenRotation,boolean force,Bundle options){
  if (mKeyguardHost != null) {
    mKeyguardHost.saveHierarchyState(mStateContainer);
  }
  if (mKeyguardHost == null) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mKeyguardHost=new ViewManagerHost(mContext);
    int flags=WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN| WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
    if (!mNeedsInput) {
      flags|=WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
    }
    final int stretch=ViewGroup.LayoutParams.MATCH_PARENT;
    final int type=WindowManager.LayoutParams.TYPE_KEYGUARD;
    WindowManager.LayoutParams lp=new WindowManager.LayoutParams(stretch,stretch,type,flags,PixelFormat.TRANSLUCENT);
    lp.softInputMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    lp.windowAnimations=R.style.Animation_LockScreen;
    lp.screenOrientation=enableScreenRotation ? ActivityInfo.SCREEN_ORIENTATION_USER : ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
    if (ActivityManager.isHighEndGfx()) {
      lp.flags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
      lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
    }
    lp.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    lp.inputFeatures|=WindowManager.LayoutParams.INPUT_FEATURE_DISABLE_USER_ACTIVITY;
    lp.setTitle(""String_Node_Str"");
    mWindowLayoutParams=lp;
    mViewManager.addView(mKeyguardHost,lp);
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mBackgroundChanger);
  }
  if (force || mKeyguardView == null) {
    mKeyguardHost.setCustomBackground(null);
    mKeyguardHost.removeAllViews();
    int layout=allowNotificationsOnSecureKeyguard() ? R.layout.keyguard_simple_host_view : R.layout.keyguard_host_view;
    if (mCurrentLayout != layout) {
      mStateContainer.clear();
      mCurrentLayout=layout;
    }
    mKeyguardView=inflateKeyguardView(options,layout);
    mKeyguardView.requestFocus();
  }
  updateUserActivityTimeoutInWindowLayoutParams();
  mViewManager.updateViewLayout(mKeyguardHost,mWindowLayoutParams);
  mKeyguardHost.restoreHierarchyState(mStateContainer);
}",0.9358593928326866
199913,"/** 
 * Reads one start command from the command socket. If successful, a child is forked and a   {@link ZygoteInit.MethodAndArgsCaller}exception is thrown in that child while in the parent process, the method returns normally. On failure, the child is not spawned and messages are printed to the log and stderr. Returns a boolean status value indicating whether an end-of-file on the command socket has been encountered.
 * @return false if command socket should continue to be read from, ortrue if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()method in child process
 */
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + ex.getMessage());
    closeSocket();
    return true;
  }
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException(""String_Node_Str"" + ""String_Node_Str"" + Long.toHexString(parsedArgs.permittedCapabilities) + ""String_Node_Str""+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Libcore.os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName);
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}","/** 
 * Reads one start command from the command socket. If successful, a child is forked and a   {@link ZygoteInit.MethodAndArgsCaller}exception is thrown in that child while in the parent process, the method returns normally. On failure, the child is not spawned and messages are printed to the log and stderr. Returns a boolean status value indicating whether an end-of-file on the command socket has been encountered.
 * @return false if command socket should continue to be read from, ortrue if an end-of-file has been encountered.
 * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()method in child process
 */
boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + ex.getMessage());
    closeSocket();
    return true;
  }
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException(""String_Node_Str"" + ""String_Node_Str"" + Long.toHexString(parsedArgs.permittedCapabilities) + ""String_Node_Str""+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Libcore.os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    int[] fdsToClose={-1,-1};
    FileDescriptor fd=mSocket.getFileDescriptor();
    if (fd != null) {
      fdsToClose[0]=fd.getInt$();
    }
    fd=ZygoteInit.getServerSocketFileDescriptor();
    if (fd != null) {
      fdsToClose[1]=fd.getInt$();
    }
    fd=null;
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName,fdsToClose);
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,""String_Node_Str"",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}",0.9593006592146748
199914,"@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}",0.94314381270903
199915,"@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}",0.94314381270903
199916,"@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}",0.94314381270903
199917,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,int chunk,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,int chunk,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}",0.952542372881356
199918,"@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,int chunk,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(int canvas_instance,Rect loc,int bitmap_instance,int chunk,int paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}",0.952542372881356
199919,"@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.width(),loc.height(),bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}","@LayoutlibDelegate static void nativeDraw(long canvas_instance,Rect loc,long bitmap_instance,long chunk,long paint_instance_or_null,int destDensity,int srcDensity){
  draw(canvas_instance,loc.left,loc.top,loc.right,loc.bottom,bitmap_instance,chunk,paint_instance_or_null,destDensity,srcDensity);
}",0.94314381270903
199920,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199921,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199922,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199923,"/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  int month;
  if (mIsScrollingUp) {
    month=child.getMonthOfFirstWeekDay();
  }
 else {
    month=child.getMonthOfLastWeekDay();
  }
  int monthDiff;
  if (mCurrentMonthDisplayed == 11 && month == 0) {
    monthDiff=1;
  }
 else   if (mCurrentMonthDisplayed == 0 && month == 11) {
    monthDiff=-1;
  }
 else {
    monthDiff=month - mCurrentMonthDisplayed;
  }
  if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
    Calendar firstDay=child.getFirstDay();
    if (mIsScrollingUp) {
      firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
    }
 else {
      firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
    }
    setMonthDisplayed(firstDay);
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}","/** 
 * Updates the title and selected month if the <code>view</code> has moved to a new month.
 */
private void onScroll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totalItemCount){
  WeekView child=(WeekView)view.getChildAt(0);
  if (child == null) {
    return;
  }
  long currScroll=view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();
  if (currScroll < mPreviousScrollPosition) {
    mIsScrollingUp=true;
  }
 else   if (currScroll > mPreviousScrollPosition) {
    mIsScrollingUp=false;
  }
 else {
    return;
  }
  int offset=child.getBottom() < mWeekMinVisibleHeight ? 1 : 0;
  if (mIsScrollingUp) {
    child=(WeekView)view.getChildAt(SCROLL_HYST_WEEKS + offset);
  }
 else   if (offset != 0) {
    child=(WeekView)view.getChildAt(offset);
  }
  if (child != null) {
    int month;
    if (mIsScrollingUp) {
      month=child.getMonthOfFirstWeekDay();
    }
 else {
      month=child.getMonthOfLastWeekDay();
    }
    int monthDiff;
    if (mCurrentMonthDisplayed == 11 && month == 0) {
      monthDiff=1;
    }
 else     if (mCurrentMonthDisplayed == 0 && month == 11) {
      monthDiff=-1;
    }
 else {
      monthDiff=month - mCurrentMonthDisplayed;
    }
    if ((!mIsScrollingUp && monthDiff > 0) || (mIsScrollingUp && monthDiff < 0)) {
      Calendar firstDay=child.getFirstDay();
      if (mIsScrollingUp) {
        firstDay.add(Calendar.DAY_OF_MONTH,-DAYS_PER_WEEK);
      }
 else {
        firstDay.add(Calendar.DAY_OF_MONTH,DAYS_PER_WEEK);
      }
      setMonthDisplayed(firstDay);
    }
  }
  mPreviousScrollPosition=currScroll;
  mPreviousScrollState=mCurrentScrollState;
}",0.960900844541758
199924,"@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
}","@Override public void onRtlPropertiesChanged(int layoutDirection){
  super.onRtlPropertiesChanged(layoutDirection);
  mTextDir=getTextDirectionHeuristic();
  if (mLayout != null) {
    checkForRelayout();
  }
}",0.8555858310626703
199925,"public void handleExternalCameraEvent(MotionEvent event){
  beginCameraEvent();
  int cameraPage=getPageCount() - 1;
  boolean endWarp=false;
  if (isCameraPage(cameraPage) || mCameraEventInProgress) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      mCameraEventInProgress=true;
    userActivity();
  startPageWarp(cameraPage);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mCameraEventInProgress=false;
endWarp=isWarping();
break;
}
dispatchTouchEvent(event);
if (endWarp) stopPageWarp();
}
endCameraEvent();
}","public void handleExternalCameraEvent(MotionEvent event){
  beginCameraEvent();
  int cameraPage=getPageCount() - 1;
  boolean endWarp=false;
  if (isCameraPage(cameraPage) || mCameraEventInProgress) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      mCameraEventInProgress=true;
    userActivity();
  break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mCameraEventInProgress=false;
break;
}
dispatchTouchEvent(event);
}
endCameraEvent();
}",0.8991185112634672
199926,"protected void pageBeginMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (!mIsPageMoving) {
    mIsPageMoving=true;
    if (isWarping()) {
      dispatchOnPageBeginWarp();
      if (mPageSwapIndex != -1) {
        swapPages(mPageSwapIndex,mPageWarpIndex);
      }
    }
    onPageBeginMoving();
  }
}","protected void pageBeginMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (!mIsPageMoving) {
    mIsPageMoving=true;
    if (isWarping()) {
      dispatchOnPageBeginWarp();
    }
    onPageBeginMoving();
  }
}",0.7745098039215687
199927,"@Override public void onAnimationEnd(Animator animation){
  mWarpAnimation=null;
  mWarpPageExposed=false;
}","@Override public void onAnimationEnd(Animator animation){
  mWarpAnimation=null;
  mWarpPageExposed=false;
  KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
  v.setTranslationX(0.0f);
}",0.677115987460815
199928,"@Override public void onAnimationCancel(Animator animation){
  mDragView=null;
}","@Override public void onAnimationCancel(Animator animation){
  super.onAnimationCancel(animation);
  mWarpAnimation=null;
}",0.7389162561576355
199929,"protected boolean determineScrollingStart(MotionEvent ev){
  final int pointerIndex=ev.findPointerIndex(mActivePointerId);
  if (pointerIndex == -1)   return false;
  final float x=ev.getX(pointerIndex);
  final float y=ev.getY(pointerIndex);
  if (!isTouchPointInViewportWithBuffer((int)x,(int)y))   return false;
  if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)   return false;
  final int xDiff=(int)Math.abs(x - mLastMotionX);
  final int yDiff=(int)Math.abs(y - mLastMotionY);
  final int touchSlop=Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
  boolean xPaged=xDiff > mPagingTouchSlop;
  boolean xMoved=xDiff > touchSlop;
  boolean yMoved=yDiff > touchSlop;
  return (xMoved || xPaged || yMoved) && (mUsePagingTouchSlop ? xPaged : xMoved);
}","protected boolean determineScrollingStart(MotionEvent ev){
  final int pointerIndex=ev.findPointerIndex(mActivePointerId);
  if (pointerIndex == -1)   return false;
  final float x=ev.getX(pointerIndex);
  final float y=ev.getY(pointerIndex);
  if (!isTouchPointInViewportWithBuffer((int)x,(int)y))   return false;
  if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)   return false;
  final int xDiff=(int)Math.abs(x - mLastMotionX);
  final int touchSlop=Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
  boolean xPaged=xDiff > mPagingTouchSlop;
  boolean xMoved=xDiff > touchSlop;
  return mUsePagingTouchSlop ? xPaged : xMoved;
}",0.8546384222059897
199930,"private void cancelWarpAnimation(String msg,boolean abortAnimation){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + msg + ""String_Node_Str""+ abortAnimation+ ""String_Node_Str"");
  if (abortAnimation) {
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    v.animate().cancel();
    scrollBy(Math.round(-v.getTranslationX()),0);
    v.setTranslationX(0);
  }
 else {
    animateWarpPageOffScreen(""String_Node_Str"",true);
  }
}","private void cancelWarpAnimation(String msg,boolean abortAnimation){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + msg + ""String_Node_Str""+ abortAnimation+ ""String_Node_Str"");
  if (abortAnimation) {
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    v.animate().cancel();
    scrollBy(Math.round(-v.getTranslationX()),0);
    v.setTranslationX(0);
  }
 else {
    animateWarpPageOffScreen(""String_Node_Str"",true);
  }
}",0.9933774834437086
199931,"protected void snapToPage(int whichPage,int delta,int duration,boolean immediate){
  if (mPageSwapIndex != -1 && whichPage == mPageSwapIndex) {
    mNextPage=mPageWarpIndex;
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + whichPage + ""String_Node_Str"");
  }
 else {
    mNextPage=whichPage;
  }
  if (isWarping()) {
    dispatchOnPageEndWarp();
    notifyPageSwitching(whichPage);
    resetPageWarp();
  }
 else {
    notifyPageSwitching(whichPage);
  }
  View focusedChild=getFocusedChild();
  if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
    focusedChild.clearFocus();
  }
  pageBeginMoving();
  awakenScrollBars(duration);
  if (immediate) {
    duration=0;
  }
 else   if (duration == 0) {
    duration=Math.abs(delta);
  }
  if (!mScroller.isFinished())   mScroller.abortAnimation();
  mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
  notifyPageSwitched();
  if (immediate) {
    computeScroll();
  }
  mForceScreenScrolled=true;
  invalidate();
}","protected void snapToPage(int whichPage,int delta,int duration,boolean immediate){
  if (isWarping() && whichPage == mCurrentPage + 1) {
    mNextPage=getPageWarpIndex();
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + whichPage + ""String_Node_Str"");
  }
 else {
    mNextPage=whichPage;
  }
  if (mWarpPageExposed) {
    dispatchOnPageEndWarp();
    mWarpPageExposed=false;
  }
  notifyPageSwitching(whichPage);
  View focusedChild=getFocusedChild();
  if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
    focusedChild.clearFocus();
  }
  pageBeginMoving();
  awakenScrollBars(duration);
  if (immediate) {
    duration=0;
  }
 else   if (duration == 0) {
    duration=Math.abs(delta);
  }
  if (!mScroller.isFinished())   mScroller.abortAnimation();
  mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
  notifyPageSwitched();
  if (immediate) {
    computeScroll();
  }
  mForceScreenScrolled=true;
  invalidate();
}",0.8822652757078987
199932,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (!mIsDataReady || getChildCount() == 0) {
    return;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final int childCount=getChildCount();
  int offsetX=getViewportOffsetX();
  int offsetY=getViewportOffsetY();
  mViewport.offset(offsetX,offsetY);
  int childLeft=offsetX + getRelativeChildOffset(0);
  for (int i=0; i < childCount; i++) {
    final View child=getPageAt(i);
    int childTop=offsetY + getPaddingTop();
    if (child.getVisibility() != View.GONE) {
      final int childWidth=getScaledMeasuredWidth(child);
      final int childHeight=child.getMeasuredHeight();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ childLeft+ ""String_Node_Str""+ childTop);
      child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
      childLeft+=childWidth + mPageSpacing;
    }
  }
  if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
    setHorizontalScrollBarEnabled(false);
    updateCurrentPageScroll();
    setHorizontalScrollBarEnabled(true);
    mFirstLayout=false;
  }
  if (mPageSwapIndex != -1) {
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"");
    swapPages(mPageSwapIndex,mPageWarpIndex);
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (!mIsDataReady || getChildCount() == 0) {
    return;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final int childCount=getChildCount();
  int offsetX=getViewportOffsetX();
  int offsetY=getViewportOffsetY();
  mViewport.offset(offsetX,offsetY);
  int childLeft=offsetX + getRelativeChildOffset(0);
  for (int i=0; i < childCount; i++) {
    final View child=getPageAt(i);
    int childTop=offsetY + getPaddingTop();
    if (child.getVisibility() != View.GONE) {
      final int childWidth=getScaledMeasuredWidth(child);
      final int childHeight=child.getMeasuredHeight();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ childLeft+ ""String_Node_Str""+ childTop);
      child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
      childLeft+=childWidth + mPageSpacing;
    }
  }
  if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
    setHorizontalScrollBarEnabled(false);
    updateCurrentPageScroll();
    setHorizontalScrollBarEnabled(true);
    mFirstLayout=false;
  }
}",0.945748987854251
199933,"protected void pageEndMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (mIsPageMoving) {
    mIsPageMoving=false;
    if (isWarping()) {
      if (mPageSwapIndex != -1) {
        swapPages(mPageSwapIndex,mPageWarpIndex);
      }
      dispatchOnPageEndWarp();
      resetPageWarp();
    }
    onPageEndMoving();
  }
}","protected void pageEndMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (mIsPageMoving) {
    mIsPageMoving=false;
    if (isWarping()) {
      dispatchOnPageEndWarp();
      mWarpPageExposed=false;
    }
    onPageEndMoving();
  }
}",0.8024502297090352
199934,"private void animateWarpPageOnScreen(String reason){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str"");
  if (isWarping() && !mWarpPageExposed) {
    mWarpPageExposed=true;
    dispatchOnPageBeginWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    DecelerateInterpolator interp=new DecelerateInterpolator(1.5f);
    mWarpAnimation=v.animate();
    mWarpAnimation.translationX(mWarpPeekAmount).setInterpolator(interp).setDuration(WARP_PEEK_ANIMATION_DURATION).setListener(mOnScreenAnimationListener);
  }
}","private void animateWarpPageOnScreen(String reason){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str"");
  if (!mWarpPageExposed) {
    mWarpPageExposed=true;
    dispatchOnPageBeginWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    DecelerateInterpolator interp=new DecelerateInterpolator(1.5f);
    int totalOffset=getCurrentWarpOffset();
    v.setTranslationX(totalOffset);
    mWarpAnimation=v.animate();
    mWarpAnimation.translationX(mWarpPeekAmount + totalOffset).setInterpolator(interp).setDuration(WARP_PEEK_ANIMATION_DURATION).setListener(mOnScreenAnimationListener);
  }
}",0.9159970781592404
199935,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (DISABLE_TOUCH_INTERACTION) {
    return false;
  }
  if (getChildCount() <= 0)   return super.onTouchEvent(ev);
  acquireVelocityTrackerAndAddMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  saveDownState(ev);
if (mTouchState == TOUCH_STATE_SCROLLING) {
  pageBeginMoving();
}
 else {
  setTouchState(TOUCH_STATE_READY);
}
if (mIsCameraEvent) {
animateWarpPageOnScreen(""String_Node_Str"");
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (isWarping()) {
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
v.setTranslationX(v.getTranslationX() - deltaX);
}
 else if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
final int dragViewIndex=indexOfChild(mDragView);
int bufferSize=(int)(REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth());
int leftBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.left,0)[0] + bufferSize);
int rightBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.right,0)[0] - bufferSize);
boolean isHoveringOverDelete=isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY);
setPageHoveringOverDeleteDropTarget(dragViewIndex,isHoveringOverDelete);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + leftBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + rightBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionY);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionY);
float parentX=mParentDownMotionX;
int pageIndexToSnapTo=-1;
if (parentX < leftBufferEdge && dragViewIndex > 0) {
pageIndexToSnapTo=dragViewIndex - 1;
}
 else if (parentX > rightBufferEdge && dragViewIndex < getChildCount() - 1) {
pageIndexToSnapTo=dragViewIndex + 1;
}
final int pageUnderPointIndex=pageIndexToSnapTo;
if (pageUnderPointIndex > -1 && !isHoveringOverDelete) {
mTempVisiblePagesRange[0]=0;
mTempVisiblePagesRange[1]=getPageCount() - 1;
boundByReorderablePages(true,mTempVisiblePagesRange);
if (mTempVisiblePagesRange[0] <= pageUnderPointIndex && pageUnderPointIndex <= mTempVisiblePagesRange[1] && pageUnderPointIndex != mSidePageHoverIndex && mScroller.isFinished()) {
mSidePageHoverIndex=pageUnderPointIndex;
mSidePageHoverRunnable=new Runnable(){
  @Override public void run(){
    mDownScrollX=getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);
    snapToPage(pageUnderPointIndex);
    int shiftDelta=(dragViewIndex < pageUnderPointIndex) ? -1 : 1;
    int lowerIndex=(dragViewIndex < pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;
    int upperIndex=(dragViewIndex > pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;
    for (int i=lowerIndex; i <= upperIndex; ++i) {
      View v=getChildAt(i);
      int oldX=getViewportOffsetX() + getChildOffset(i);
      int newX=getViewportOffsetX() + getChildOffset(i + shiftDelta);
      AnimatorSet anim=(AnimatorSet)v.getTag();
      if (anim != null) {
        anim.cancel();
      }
      v.setTranslationX(oldX - newX);
      anim=new AnimatorSet();
      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
      anim.playTogether(ObjectAnimator.ofFloat(v,""String_Node_Str"",0f));
      anim.start();
      v.setTag(anim);
    }
    removeView(mDragView);
    onRemoveView(mDragView,false);
    addView(mDragView,pageUnderPointIndex);
    onAddView(mDragView,pageUnderPointIndex);
    mSidePageHoverIndex=-1;
  }
}
;
postDelayed(mSidePageHoverRunnable,REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
}
}
 else {
removeCallbacks(mSidePageHoverRunnable);
mSidePageHoverIndex=-1;
}
}
 else if (mIsCameraEvent || determineScrollingStart(ev)) {
startScrolling(ev);
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
boolean isSignificantMove=Math.abs(deltaX) > pageWidth * SIGNIFICANT_MOVE_THRESHOLD;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > mFlingThresholdVelocity;
boolean returnToOriginalPage=false;
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX) && isFling) {
returnToOriginalPage=true;
}
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage || isWarping() ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
boolean handledFling=false;
if (!DISABLE_FLING_TO_DELETE) {
PointF flingToDeleteVector=isFlingingToDelete();
if (flingToDeleteVector != null) {
onFlingToDelete(flingToDeleteVector);
handledFling=true;
}
}
if (!handledFling && isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY)) {
onDropToDelete();
}
}
 else {
if (DEBUG_WARP) Log.v(TAG,""String_Node_Str"");
if (mWarpPageExposed && !isAnimatingWarpPage()) {
animateWarpPageOffScreen(""String_Node_Str"",true);
}
onUnhandledTap(ev);
}
removeCallbacks(mSidePageHoverRunnable);
resetTouchState();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
resetTouchState();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (DISABLE_TOUCH_INTERACTION) {
    return false;
  }
  if (getChildCount() <= 0)   return super.onTouchEvent(ev);
  acquireVelocityTrackerAndAddMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  saveDownState(ev);
if (mTouchState == TOUCH_STATE_SCROLLING) {
  pageBeginMoving();
}
 else {
  setTouchState(TOUCH_STATE_READY);
}
if (mIsCameraEvent) {
animateWarpPageOnScreen(""String_Node_Str"");
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (isWarping()) {
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
v.setTranslationX(v.getTranslationX() - deltaX);
}
 else if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
final int dragViewIndex=indexOfChild(mDragView);
int bufferSize=(int)(REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth());
int leftBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.left,0)[0] + bufferSize);
int rightBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.right,0)[0] - bufferSize);
boolean isHoveringOverDelete=isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY);
setPageHoveringOverDeleteDropTarget(dragViewIndex,isHoveringOverDelete);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + leftBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + rightBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionY);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionY);
float parentX=mParentDownMotionX;
int pageIndexToSnapTo=-1;
if (parentX < leftBufferEdge && dragViewIndex > 0) {
pageIndexToSnapTo=dragViewIndex - 1;
}
 else if (parentX > rightBufferEdge && dragViewIndex < getChildCount() - 1) {
pageIndexToSnapTo=dragViewIndex + 1;
}
final int pageUnderPointIndex=pageIndexToSnapTo;
if (pageUnderPointIndex > -1 && !isHoveringOverDelete) {
mTempVisiblePagesRange[0]=0;
mTempVisiblePagesRange[1]=getPageCount() - 1;
boundByReorderablePages(true,mTempVisiblePagesRange);
if (mTempVisiblePagesRange[0] <= pageUnderPointIndex && pageUnderPointIndex <= mTempVisiblePagesRange[1] && pageUnderPointIndex != mSidePageHoverIndex && mScroller.isFinished()) {
mSidePageHoverIndex=pageUnderPointIndex;
mSidePageHoverRunnable=new Runnable(){
  @Override public void run(){
    mDownScrollX=getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);
    snapToPage(pageUnderPointIndex);
    int shiftDelta=(dragViewIndex < pageUnderPointIndex) ? -1 : 1;
    int lowerIndex=(dragViewIndex < pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;
    int upperIndex=(dragViewIndex > pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;
    for (int i=lowerIndex; i <= upperIndex; ++i) {
      View v=getChildAt(i);
      int oldX=getViewportOffsetX() + getChildOffset(i);
      int newX=getViewportOffsetX() + getChildOffset(i + shiftDelta);
      AnimatorSet anim=(AnimatorSet)v.getTag();
      if (anim != null) {
        anim.cancel();
      }
      v.setTranslationX(oldX - newX);
      anim=new AnimatorSet();
      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
      anim.playTogether(ObjectAnimator.ofFloat(v,""String_Node_Str"",0f));
      anim.start();
      v.setTag(anim);
    }
    removeView(mDragView);
    onRemoveView(mDragView,false);
    addView(mDragView,pageUnderPointIndex);
    onAddView(mDragView,pageUnderPointIndex);
    mSidePageHoverIndex=-1;
  }
}
;
postDelayed(mSidePageHoverRunnable,REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
}
}
 else {
removeCallbacks(mSidePageHoverRunnable);
mSidePageHoverIndex=-1;
}
}
 else if (determineScrollingStart(ev)) {
startScrolling(ev);
}
 else if (isHorizontalCameraScroll(ev)) {
startScrolling(ev);
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
v.animate().cancel();
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
boolean isSignificantMove=Math.abs(deltaX) > pageWidth * SIGNIFICANT_MOVE_THRESHOLD;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > mFlingThresholdVelocity;
boolean returnToOriginalPage=false;
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX) && isFling) {
returnToOriginalPage=true;
}
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage || isWarping() ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : isWarping() ? getPageWarpIndex() : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
boolean handledFling=false;
if (!DISABLE_FLING_TO_DELETE) {
PointF flingToDeleteVector=isFlingingToDelete();
if (flingToDeleteVector != null) {
onFlingToDelete(flingToDeleteVector);
handledFling=true;
}
}
if (!handledFling && isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY)) {
onDropToDelete();
}
}
 else {
if (DEBUG_WARP) Log.v(TAG,""String_Node_Str"");
if (mWarpPageExposed && !isAnimatingWarpPage()) {
animateWarpPageOffScreen(""String_Node_Str"",true);
}
onUnhandledTap(ev);
}
removeCallbacks(mSidePageHoverRunnable);
resetTouchState();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
resetTouchState();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9836192942699904
199936,"protected boolean isWarping(){
  return mPageWarpIndex != -1;
}","protected boolean isWarping(){
  return mWarpPageExposed;
}",0.819672131147541
199937,"private void animateWarpPageOffScreen(String reason,boolean animate){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ animate+ ""String_Node_Str"");
  if (isWarping()) {
    dispatchOnPageEndWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    AccelerateInterpolator interp=new AccelerateInterpolator(1.5f);
    v.animate().translationX(0.0f).setInterpolator(interp).setDuration(animate ? WARP_PEEK_ANIMATION_DURATION : 0).setListener(mOffScreenAnimationListener);
  }
 else {
    if (DEBUG_WARP)     Log.e(TAG,""String_Node_Str"",new Exception());
  }
}","private void animateWarpPageOffScreen(String reason,boolean animate){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ animate+ ""String_Node_Str"");
  if (mWarpPageExposed) {
    dispatchOnPageEndWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    AccelerateInterpolator interp=new AccelerateInterpolator(1.5f);
    int totalOffset=getCurrentWarpOffset();
    v.animate().translationX(totalOffset).setInterpolator(interp).setDuration(animate ? WARP_PEEK_ANIMATION_DURATION : 0).setListener(mOffScreenAnimationListener);
  }
 else {
    if (DEBUG_WARP)     Log.e(TAG,""String_Node_Str"",new Exception());
  }
}",0.9360222531293464
199938,"protected int getPageWarpIndex(){
  return mPageWarpIndex;
}","protected int getPageWarpIndex(){
  return getPageCount() - 1;
}",0.8225806451612904
199939,"public void handleExternalCameraEvent(MotionEvent event){
  beginCameraEvent();
  int cameraPage=getPageCount() - 1;
  boolean endWarp=false;
  if (isCameraPage(cameraPage) || mCameraEventInProgress) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      mCameraEventInProgress=true;
    userActivity();
  startPageWarp(cameraPage);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mCameraEventInProgress=false;
endWarp=isWarping();
break;
}
dispatchTouchEvent(event);
if (endWarp) stopPageWarp();
}
endCameraEvent();
}","public void handleExternalCameraEvent(MotionEvent event){
  beginCameraEvent();
  int cameraPage=getPageCount() - 1;
  boolean endWarp=false;
  if (isCameraPage(cameraPage) || mCameraEventInProgress) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      mCameraEventInProgress=true;
    userActivity();
  break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mCameraEventInProgress=false;
break;
}
dispatchTouchEvent(event);
}
endCameraEvent();
}",0.8991185112634672
199940,"protected void pageBeginMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (!mIsPageMoving) {
    mIsPageMoving=true;
    if (isWarping()) {
      dispatchOnPageBeginWarp();
      if (mPageSwapIndex != -1) {
        swapPages(mPageSwapIndex,mPageWarpIndex);
      }
    }
    onPageBeginMoving();
  }
}","protected void pageBeginMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (!mIsPageMoving) {
    mIsPageMoving=true;
    if (isWarping()) {
      dispatchOnPageBeginWarp();
    }
    onPageBeginMoving();
  }
}",0.7745098039215687
199941,"@Override public void onAnimationEnd(Animator animation){
  mWarpAnimation=null;
  mWarpPageExposed=false;
}","@Override public void onAnimationEnd(Animator animation){
  mWarpAnimation=null;
  mWarpPageExposed=false;
  KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
  v.setTranslationX(0.0f);
}",0.677115987460815
199942,"@Override public void onAnimationCancel(Animator animation){
  mDragView=null;
}","@Override public void onAnimationCancel(Animator animation){
  super.onAnimationCancel(animation);
  mWarpAnimation=null;
}",0.7389162561576355
199943,"protected boolean determineScrollingStart(MotionEvent ev){
  final int pointerIndex=ev.findPointerIndex(mActivePointerId);
  if (pointerIndex == -1)   return false;
  final float x=ev.getX(pointerIndex);
  final float y=ev.getY(pointerIndex);
  if (!isTouchPointInViewportWithBuffer((int)x,(int)y))   return false;
  if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)   return false;
  final int xDiff=(int)Math.abs(x - mLastMotionX);
  final int yDiff=(int)Math.abs(y - mLastMotionY);
  final int touchSlop=Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
  boolean xPaged=xDiff > mPagingTouchSlop;
  boolean xMoved=xDiff > touchSlop;
  boolean yMoved=yDiff > touchSlop;
  return (xMoved || xPaged || yMoved) && (mUsePagingTouchSlop ? xPaged : xMoved);
}","protected boolean determineScrollingStart(MotionEvent ev){
  final int pointerIndex=ev.findPointerIndex(mActivePointerId);
  if (pointerIndex == -1)   return false;
  final float x=ev.getX(pointerIndex);
  final float y=ev.getY(pointerIndex);
  if (!isTouchPointInViewportWithBuffer((int)x,(int)y))   return false;
  if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)   return false;
  final int xDiff=(int)Math.abs(x - mLastMotionX);
  final int touchSlop=Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
  boolean xPaged=xDiff > mPagingTouchSlop;
  boolean xMoved=xDiff > touchSlop;
  return mUsePagingTouchSlop ? xPaged : xMoved;
}",0.8546384222059897
199944,"private void cancelWarpAnimation(String msg,boolean abortAnimation){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + msg + ""String_Node_Str""+ abortAnimation+ ""String_Node_Str"");
  if (abortAnimation) {
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    v.animate().cancel();
    scrollBy(Math.round(-v.getTranslationX()),0);
    v.setTranslationX(0);
  }
 else {
    animateWarpPageOffScreen(""String_Node_Str"",true);
  }
}","private void cancelWarpAnimation(String msg,boolean abortAnimation){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + msg + ""String_Node_Str""+ abortAnimation+ ""String_Node_Str"");
  if (abortAnimation) {
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    v.animate().cancel();
    scrollBy(Math.round(-v.getTranslationX()),0);
    v.setTranslationX(0);
  }
 else {
    animateWarpPageOffScreen(""String_Node_Str"",true);
  }
}",0.9933774834437086
199945,"protected void snapToPage(int whichPage,int delta,int duration,boolean immediate){
  if (mPageSwapIndex != -1 && whichPage == mPageSwapIndex) {
    mNextPage=mPageWarpIndex;
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + whichPage + ""String_Node_Str"");
  }
 else {
    mNextPage=whichPage;
  }
  if (isWarping()) {
    dispatchOnPageEndWarp();
    notifyPageSwitching(whichPage);
    resetPageWarp();
  }
 else {
    notifyPageSwitching(whichPage);
  }
  View focusedChild=getFocusedChild();
  if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
    focusedChild.clearFocus();
  }
  pageBeginMoving();
  awakenScrollBars(duration);
  if (immediate) {
    duration=0;
  }
 else   if (duration == 0) {
    duration=Math.abs(delta);
  }
  if (!mScroller.isFinished())   mScroller.abortAnimation();
  mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
  notifyPageSwitched();
  if (immediate) {
    computeScroll();
  }
  mForceScreenScrolled=true;
  invalidate();
}","protected void snapToPage(int whichPage,int delta,int duration,boolean immediate){
  if (isWarping() && whichPage == mCurrentPage + 1) {
    mNextPage=getPageWarpIndex();
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + whichPage + ""String_Node_Str"");
  }
 else {
    mNextPage=whichPage;
  }
  if (mWarpPageExposed) {
    dispatchOnPageEndWarp();
    mWarpPageExposed=false;
  }
  notifyPageSwitching(whichPage);
  View focusedChild=getFocusedChild();
  if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
    focusedChild.clearFocus();
  }
  pageBeginMoving();
  awakenScrollBars(duration);
  if (immediate) {
    duration=0;
  }
 else   if (duration == 0) {
    duration=Math.abs(delta);
  }
  if (!mScroller.isFinished())   mScroller.abortAnimation();
  mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
  notifyPageSwitched();
  if (immediate) {
    computeScroll();
  }
  mForceScreenScrolled=true;
  invalidate();
}",0.8822652757078987
199946,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (!mIsDataReady || getChildCount() == 0) {
    return;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final int childCount=getChildCount();
  int offsetX=getViewportOffsetX();
  int offsetY=getViewportOffsetY();
  mViewport.offset(offsetX,offsetY);
  int childLeft=offsetX + getRelativeChildOffset(0);
  for (int i=0; i < childCount; i++) {
    final View child=getPageAt(i);
    int childTop=offsetY + getPaddingTop();
    if (child.getVisibility() != View.GONE) {
      final int childWidth=getScaledMeasuredWidth(child);
      final int childHeight=child.getMeasuredHeight();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ childLeft+ ""String_Node_Str""+ childTop);
      child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
      childLeft+=childWidth + mPageSpacing;
    }
  }
  if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
    setHorizontalScrollBarEnabled(false);
    updateCurrentPageScroll();
    setHorizontalScrollBarEnabled(true);
    mFirstLayout=false;
  }
  if (mPageSwapIndex != -1) {
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"");
    swapPages(mPageSwapIndex,mPageWarpIndex);
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (!mIsDataReady || getChildCount() == 0) {
    return;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final int childCount=getChildCount();
  int offsetX=getViewportOffsetX();
  int offsetY=getViewportOffsetY();
  mViewport.offset(offsetX,offsetY);
  int childLeft=offsetX + getRelativeChildOffset(0);
  for (int i=0; i < childCount; i++) {
    final View child=getPageAt(i);
    int childTop=offsetY + getPaddingTop();
    if (child.getVisibility() != View.GONE) {
      final int childWidth=getScaledMeasuredWidth(child);
      final int childHeight=child.getMeasuredHeight();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ childLeft+ ""String_Node_Str""+ childTop);
      child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
      childLeft+=childWidth + mPageSpacing;
    }
  }
  if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
    setHorizontalScrollBarEnabled(false);
    updateCurrentPageScroll();
    setHorizontalScrollBarEnabled(true);
    mFirstLayout=false;
  }
}",0.945748987854251
199947,"protected void pageEndMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (mIsPageMoving) {
    mIsPageMoving=false;
    if (isWarping()) {
      if (mPageSwapIndex != -1) {
        swapPages(mPageSwapIndex,mPageWarpIndex);
      }
      dispatchOnPageEndWarp();
      resetPageWarp();
    }
    onPageEndMoving();
  }
}","protected void pageEndMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (mIsPageMoving) {
    mIsPageMoving=false;
    if (isWarping()) {
      dispatchOnPageEndWarp();
      mWarpPageExposed=false;
    }
    onPageEndMoving();
  }
}",0.8024502297090352
199948,"private void animateWarpPageOnScreen(String reason){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str"");
  if (isWarping() && !mWarpPageExposed) {
    mWarpPageExposed=true;
    dispatchOnPageBeginWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    DecelerateInterpolator interp=new DecelerateInterpolator(1.5f);
    mWarpAnimation=v.animate();
    mWarpAnimation.translationX(mWarpPeekAmount).setInterpolator(interp).setDuration(WARP_PEEK_ANIMATION_DURATION).setListener(mOnScreenAnimationListener);
  }
}","private void animateWarpPageOnScreen(String reason){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str"");
  if (!mWarpPageExposed) {
    mWarpPageExposed=true;
    dispatchOnPageBeginWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    DecelerateInterpolator interp=new DecelerateInterpolator(1.5f);
    int totalOffset=getCurrentWarpOffset();
    v.setTranslationX(totalOffset);
    mWarpAnimation=v.animate();
    mWarpAnimation.translationX(mWarpPeekAmount + totalOffset).setInterpolator(interp).setDuration(WARP_PEEK_ANIMATION_DURATION).setListener(mOnScreenAnimationListener);
  }
}",0.9159970781592404
199949,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (DISABLE_TOUCH_INTERACTION) {
    return false;
  }
  if (getChildCount() <= 0)   return super.onTouchEvent(ev);
  acquireVelocityTrackerAndAddMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  saveDownState(ev);
if (mTouchState == TOUCH_STATE_SCROLLING) {
  pageBeginMoving();
}
 else {
  setTouchState(TOUCH_STATE_READY);
}
if (mIsCameraEvent) {
animateWarpPageOnScreen(""String_Node_Str"");
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (isWarping()) {
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
v.setTranslationX(v.getTranslationX() - deltaX);
}
 else if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
final int dragViewIndex=indexOfChild(mDragView);
int bufferSize=(int)(REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth());
int leftBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.left,0)[0] + bufferSize);
int rightBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.right,0)[0] - bufferSize);
boolean isHoveringOverDelete=isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY);
setPageHoveringOverDeleteDropTarget(dragViewIndex,isHoveringOverDelete);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + leftBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + rightBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionY);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionY);
float parentX=mParentDownMotionX;
int pageIndexToSnapTo=-1;
if (parentX < leftBufferEdge && dragViewIndex > 0) {
pageIndexToSnapTo=dragViewIndex - 1;
}
 else if (parentX > rightBufferEdge && dragViewIndex < getChildCount() - 1) {
pageIndexToSnapTo=dragViewIndex + 1;
}
final int pageUnderPointIndex=pageIndexToSnapTo;
if (pageUnderPointIndex > -1 && !isHoveringOverDelete) {
mTempVisiblePagesRange[0]=0;
mTempVisiblePagesRange[1]=getPageCount() - 1;
boundByReorderablePages(true,mTempVisiblePagesRange);
if (mTempVisiblePagesRange[0] <= pageUnderPointIndex && pageUnderPointIndex <= mTempVisiblePagesRange[1] && pageUnderPointIndex != mSidePageHoverIndex && mScroller.isFinished()) {
mSidePageHoverIndex=pageUnderPointIndex;
mSidePageHoverRunnable=new Runnable(){
  @Override public void run(){
    mDownScrollX=getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);
    snapToPage(pageUnderPointIndex);
    int shiftDelta=(dragViewIndex < pageUnderPointIndex) ? -1 : 1;
    int lowerIndex=(dragViewIndex < pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;
    int upperIndex=(dragViewIndex > pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;
    for (int i=lowerIndex; i <= upperIndex; ++i) {
      View v=getChildAt(i);
      int oldX=getViewportOffsetX() + getChildOffset(i);
      int newX=getViewportOffsetX() + getChildOffset(i + shiftDelta);
      AnimatorSet anim=(AnimatorSet)v.getTag();
      if (anim != null) {
        anim.cancel();
      }
      v.setTranslationX(oldX - newX);
      anim=new AnimatorSet();
      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
      anim.playTogether(ObjectAnimator.ofFloat(v,""String_Node_Str"",0f));
      anim.start();
      v.setTag(anim);
    }
    removeView(mDragView);
    onRemoveView(mDragView,false);
    addView(mDragView,pageUnderPointIndex);
    onAddView(mDragView,pageUnderPointIndex);
    mSidePageHoverIndex=-1;
  }
}
;
postDelayed(mSidePageHoverRunnable,REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
}
}
 else {
removeCallbacks(mSidePageHoverRunnable);
mSidePageHoverIndex=-1;
}
}
 else if (mIsCameraEvent || determineScrollingStart(ev)) {
startScrolling(ev);
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
boolean isSignificantMove=Math.abs(deltaX) > pageWidth * SIGNIFICANT_MOVE_THRESHOLD;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > mFlingThresholdVelocity;
boolean returnToOriginalPage=false;
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX) && isFling) {
returnToOriginalPage=true;
}
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage || isWarping() ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
boolean handledFling=false;
if (!DISABLE_FLING_TO_DELETE) {
PointF flingToDeleteVector=isFlingingToDelete();
if (flingToDeleteVector != null) {
onFlingToDelete(flingToDeleteVector);
handledFling=true;
}
}
if (!handledFling && isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY)) {
onDropToDelete();
}
}
 else {
if (DEBUG_WARP) Log.v(TAG,""String_Node_Str"");
if (mWarpPageExposed && !isAnimatingWarpPage()) {
animateWarpPageOffScreen(""String_Node_Str"",true);
}
onUnhandledTap(ev);
}
removeCallbacks(mSidePageHoverRunnable);
resetTouchState();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
resetTouchState();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (DISABLE_TOUCH_INTERACTION) {
    return false;
  }
  if (getChildCount() <= 0)   return super.onTouchEvent(ev);
  acquireVelocityTrackerAndAddMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  saveDownState(ev);
if (mTouchState == TOUCH_STATE_SCROLLING) {
  pageBeginMoving();
}
 else {
  setTouchState(TOUCH_STATE_READY);
}
if (mIsCameraEvent) {
animateWarpPageOnScreen(""String_Node_Str"");
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (isWarping()) {
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
v.setTranslationX(v.getTranslationX() - deltaX);
}
 else if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
final int dragViewIndex=indexOfChild(mDragView);
int bufferSize=(int)(REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth());
int leftBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.left,0)[0] + bufferSize);
int rightBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.right,0)[0] - bufferSize);
boolean isHoveringOverDelete=isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY);
setPageHoveringOverDeleteDropTarget(dragViewIndex,isHoveringOverDelete);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + leftBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + rightBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionY);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionY);
float parentX=mParentDownMotionX;
int pageIndexToSnapTo=-1;
if (parentX < leftBufferEdge && dragViewIndex > 0) {
pageIndexToSnapTo=dragViewIndex - 1;
}
 else if (parentX > rightBufferEdge && dragViewIndex < getChildCount() - 1) {
pageIndexToSnapTo=dragViewIndex + 1;
}
final int pageUnderPointIndex=pageIndexToSnapTo;
if (pageUnderPointIndex > -1 && !isHoveringOverDelete) {
mTempVisiblePagesRange[0]=0;
mTempVisiblePagesRange[1]=getPageCount() - 1;
boundByReorderablePages(true,mTempVisiblePagesRange);
if (mTempVisiblePagesRange[0] <= pageUnderPointIndex && pageUnderPointIndex <= mTempVisiblePagesRange[1] && pageUnderPointIndex != mSidePageHoverIndex && mScroller.isFinished()) {
mSidePageHoverIndex=pageUnderPointIndex;
mSidePageHoverRunnable=new Runnable(){
  @Override public void run(){
    mDownScrollX=getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);
    snapToPage(pageUnderPointIndex);
    int shiftDelta=(dragViewIndex < pageUnderPointIndex) ? -1 : 1;
    int lowerIndex=(dragViewIndex < pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;
    int upperIndex=(dragViewIndex > pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;
    for (int i=lowerIndex; i <= upperIndex; ++i) {
      View v=getChildAt(i);
      int oldX=getViewportOffsetX() + getChildOffset(i);
      int newX=getViewportOffsetX() + getChildOffset(i + shiftDelta);
      AnimatorSet anim=(AnimatorSet)v.getTag();
      if (anim != null) {
        anim.cancel();
      }
      v.setTranslationX(oldX - newX);
      anim=new AnimatorSet();
      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
      anim.playTogether(ObjectAnimator.ofFloat(v,""String_Node_Str"",0f));
      anim.start();
      v.setTag(anim);
    }
    removeView(mDragView);
    onRemoveView(mDragView,false);
    addView(mDragView,pageUnderPointIndex);
    onAddView(mDragView,pageUnderPointIndex);
    mSidePageHoverIndex=-1;
  }
}
;
postDelayed(mSidePageHoverRunnable,REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
}
}
 else {
removeCallbacks(mSidePageHoverRunnable);
mSidePageHoverIndex=-1;
}
}
 else if (determineScrollingStart(ev)) {
startScrolling(ev);
}
 else if (isHorizontalCameraScroll(ev)) {
startScrolling(ev);
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
v.animate().cancel();
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
boolean isSignificantMove=Math.abs(deltaX) > pageWidth * SIGNIFICANT_MOVE_THRESHOLD;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > mFlingThresholdVelocity;
boolean returnToOriginalPage=false;
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX) && isFling) {
returnToOriginalPage=true;
}
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage || isWarping() ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : isWarping() ? getPageWarpIndex() : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
boolean handledFling=false;
if (!DISABLE_FLING_TO_DELETE) {
PointF flingToDeleteVector=isFlingingToDelete();
if (flingToDeleteVector != null) {
onFlingToDelete(flingToDeleteVector);
handledFling=true;
}
}
if (!handledFling && isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY)) {
onDropToDelete();
}
}
 else {
if (DEBUG_WARP) Log.v(TAG,""String_Node_Str"");
if (mWarpPageExposed && !isAnimatingWarpPage()) {
animateWarpPageOffScreen(""String_Node_Str"",true);
}
onUnhandledTap(ev);
}
removeCallbacks(mSidePageHoverRunnable);
resetTouchState();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
resetTouchState();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9836192942699904
199950,"protected boolean isWarping(){
  return mPageWarpIndex != -1;
}","protected boolean isWarping(){
  return mWarpPageExposed;
}",0.819672131147541
199951,"private void animateWarpPageOffScreen(String reason,boolean animate){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ animate+ ""String_Node_Str"");
  if (isWarping()) {
    dispatchOnPageEndWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    AccelerateInterpolator interp=new AccelerateInterpolator(1.5f);
    v.animate().translationX(0.0f).setInterpolator(interp).setDuration(animate ? WARP_PEEK_ANIMATION_DURATION : 0).setListener(mOffScreenAnimationListener);
  }
 else {
    if (DEBUG_WARP)     Log.e(TAG,""String_Node_Str"",new Exception());
  }
}","private void animateWarpPageOffScreen(String reason,boolean animate){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ animate+ ""String_Node_Str"");
  if (mWarpPageExposed) {
    dispatchOnPageEndWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    AccelerateInterpolator interp=new AccelerateInterpolator(1.5f);
    int totalOffset=getCurrentWarpOffset();
    v.animate().translationX(totalOffset).setInterpolator(interp).setDuration(animate ? WARP_PEEK_ANIMATION_DURATION : 0).setListener(mOffScreenAnimationListener);
  }
 else {
    if (DEBUG_WARP)     Log.e(TAG,""String_Node_Str"",new Exception());
  }
}",0.9360222531293464
199952,"protected int getPageWarpIndex(){
  return mPageWarpIndex;
}","protected int getPageWarpIndex(){
  return getPageCount() - 1;
}",0.8225806451612904
199953,"public void handleExternalCameraEvent(MotionEvent event){
  beginCameraEvent();
  int cameraPage=getPageCount() - 1;
  boolean endWarp=false;
  if (isCameraPage(cameraPage) || mCameraEventInProgress) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      mCameraEventInProgress=true;
    userActivity();
  startPageWarp(cameraPage);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mCameraEventInProgress=false;
endWarp=isWarping();
break;
}
dispatchTouchEvent(event);
if (endWarp) stopPageWarp();
}
endCameraEvent();
}","public void handleExternalCameraEvent(MotionEvent event){
  beginCameraEvent();
  int cameraPage=getPageCount() - 1;
  boolean endWarp=false;
  if (isCameraPage(cameraPage) || mCameraEventInProgress) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      mCameraEventInProgress=true;
    userActivity();
  break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mCameraEventInProgress=false;
break;
}
dispatchTouchEvent(event);
}
endCameraEvent();
}",0.8991185112634672
199954,"protected void pageBeginMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (!mIsPageMoving) {
    mIsPageMoving=true;
    if (isWarping()) {
      dispatchOnPageBeginWarp();
      if (mPageSwapIndex != -1) {
        swapPages(mPageSwapIndex,mPageWarpIndex);
      }
    }
    onPageBeginMoving();
  }
}","protected void pageBeginMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (!mIsPageMoving) {
    mIsPageMoving=true;
    if (isWarping()) {
      dispatchOnPageBeginWarp();
    }
    onPageBeginMoving();
  }
}",0.7745098039215687
199955,"@Override public void onAnimationEnd(Animator animation){
  mWarpAnimation=null;
  mWarpPageExposed=false;
}","@Override public void onAnimationEnd(Animator animation){
  mWarpAnimation=null;
  mWarpPageExposed=false;
  KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
  v.setTranslationX(0.0f);
}",0.677115987460815
199956,"@Override public void onAnimationCancel(Animator animation){
  mDragView=null;
}","@Override public void onAnimationCancel(Animator animation){
  super.onAnimationCancel(animation);
  mWarpAnimation=null;
}",0.7389162561576355
199957,"protected boolean determineScrollingStart(MotionEvent ev){
  final int pointerIndex=ev.findPointerIndex(mActivePointerId);
  if (pointerIndex == -1)   return false;
  final float x=ev.getX(pointerIndex);
  final float y=ev.getY(pointerIndex);
  if (!isTouchPointInViewportWithBuffer((int)x,(int)y))   return false;
  if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)   return false;
  final int xDiff=(int)Math.abs(x - mLastMotionX);
  final int yDiff=(int)Math.abs(y - mLastMotionY);
  final int touchSlop=Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
  boolean xPaged=xDiff > mPagingTouchSlop;
  boolean xMoved=xDiff > touchSlop;
  boolean yMoved=yDiff > touchSlop;
  return (xMoved || xPaged || yMoved) && (mUsePagingTouchSlop ? xPaged : xMoved);
}","protected boolean determineScrollingStart(MotionEvent ev){
  final int pointerIndex=ev.findPointerIndex(mActivePointerId);
  if (pointerIndex == -1)   return false;
  final float x=ev.getX(pointerIndex);
  final float y=ev.getY(pointerIndex);
  if (!isTouchPointInViewportWithBuffer((int)x,(int)y))   return false;
  if (mOnlyAllowEdgeSwipes && !mDownEventOnEdge)   return false;
  final int xDiff=(int)Math.abs(x - mLastMotionX);
  final int touchSlop=Math.round(TOUCH_SLOP_SCALE * mTouchSlop);
  boolean xPaged=xDiff > mPagingTouchSlop;
  boolean xMoved=xDiff > touchSlop;
  return mUsePagingTouchSlop ? xPaged : xMoved;
}",0.8546384222059897
199958,"private void cancelWarpAnimation(String msg,boolean abortAnimation){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + msg + ""String_Node_Str""+ abortAnimation+ ""String_Node_Str"");
  if (abortAnimation) {
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    v.animate().cancel();
    scrollBy(Math.round(-v.getTranslationX()),0);
    v.setTranslationX(0);
  }
 else {
    animateWarpPageOffScreen(""String_Node_Str"",true);
  }
}","private void cancelWarpAnimation(String msg,boolean abortAnimation){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + msg + ""String_Node_Str""+ abortAnimation+ ""String_Node_Str"");
  if (abortAnimation) {
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    v.animate().cancel();
    scrollBy(Math.round(-v.getTranslationX()),0);
    v.setTranslationX(0);
  }
 else {
    animateWarpPageOffScreen(""String_Node_Str"",true);
  }
}",0.9933774834437086
199959,"protected void snapToPage(int whichPage,int delta,int duration,boolean immediate){
  if (mPageSwapIndex != -1 && whichPage == mPageSwapIndex) {
    mNextPage=mPageWarpIndex;
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + whichPage + ""String_Node_Str"");
  }
 else {
    mNextPage=whichPage;
  }
  if (isWarping()) {
    dispatchOnPageEndWarp();
    notifyPageSwitching(whichPage);
    resetPageWarp();
  }
 else {
    notifyPageSwitching(whichPage);
  }
  View focusedChild=getFocusedChild();
  if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
    focusedChild.clearFocus();
  }
  pageBeginMoving();
  awakenScrollBars(duration);
  if (immediate) {
    duration=0;
  }
 else   if (duration == 0) {
    duration=Math.abs(delta);
  }
  if (!mScroller.isFinished())   mScroller.abortAnimation();
  mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
  notifyPageSwitched();
  if (immediate) {
    computeScroll();
  }
  mForceScreenScrolled=true;
  invalidate();
}","protected void snapToPage(int whichPage,int delta,int duration,boolean immediate){
  if (isWarping() && whichPage == mCurrentPage + 1) {
    mNextPage=getPageWarpIndex();
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + whichPage + ""String_Node_Str"");
  }
 else {
    mNextPage=whichPage;
  }
  if (mWarpPageExposed) {
    dispatchOnPageEndWarp();
    mWarpPageExposed=false;
  }
  notifyPageSwitching(whichPage);
  View focusedChild=getFocusedChild();
  if (focusedChild != null && whichPage != mCurrentPage && focusedChild == getPageAt(mCurrentPage)) {
    focusedChild.clearFocus();
  }
  pageBeginMoving();
  awakenScrollBars(duration);
  if (immediate) {
    duration=0;
  }
 else   if (duration == 0) {
    duration=Math.abs(delta);
  }
  if (!mScroller.isFinished())   mScroller.abortAnimation();
  mScroller.startScroll(mUnboundedScrollX,0,delta,0,duration);
  notifyPageSwitched();
  if (immediate) {
    computeScroll();
  }
  mForceScreenScrolled=true;
  invalidate();
}",0.8822652757078987
199960,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (!mIsDataReady || getChildCount() == 0) {
    return;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final int childCount=getChildCount();
  int offsetX=getViewportOffsetX();
  int offsetY=getViewportOffsetY();
  mViewport.offset(offsetX,offsetY);
  int childLeft=offsetX + getRelativeChildOffset(0);
  for (int i=0; i < childCount; i++) {
    final View child=getPageAt(i);
    int childTop=offsetY + getPaddingTop();
    if (child.getVisibility() != View.GONE) {
      final int childWidth=getScaledMeasuredWidth(child);
      final int childHeight=child.getMeasuredHeight();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ childLeft+ ""String_Node_Str""+ childTop);
      child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
      childLeft+=childWidth + mPageSpacing;
    }
  }
  if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
    setHorizontalScrollBarEnabled(false);
    updateCurrentPageScroll();
    setHorizontalScrollBarEnabled(true);
    mFirstLayout=false;
  }
  if (mPageSwapIndex != -1) {
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"");
    swapPages(mPageSwapIndex,mPageWarpIndex);
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (!mIsDataReady || getChildCount() == 0) {
    return;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final int childCount=getChildCount();
  int offsetX=getViewportOffsetX();
  int offsetY=getViewportOffsetY();
  mViewport.offset(offsetX,offsetY);
  int childLeft=offsetX + getRelativeChildOffset(0);
  for (int i=0; i < childCount; i++) {
    final View child=getPageAt(i);
    int childTop=offsetY + getPaddingTop();
    if (child.getVisibility() != View.GONE) {
      final int childWidth=getScaledMeasuredWidth(child);
      final int childHeight=child.getMeasuredHeight();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ childLeft+ ""String_Node_Str""+ childTop);
      child.layout(childLeft,childTop,childLeft + child.getMeasuredWidth(),childTop + childHeight);
      childLeft+=childWidth + mPageSpacing;
    }
  }
  if (mFirstLayout && mCurrentPage >= 0 && mCurrentPage < getChildCount()) {
    setHorizontalScrollBarEnabled(false);
    updateCurrentPageScroll();
    setHorizontalScrollBarEnabled(true);
    mFirstLayout=false;
  }
}",0.945748987854251
199961,"protected void pageEndMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (mIsPageMoving) {
    mIsPageMoving=false;
    if (isWarping()) {
      if (mPageSwapIndex != -1) {
        swapPages(mPageSwapIndex,mPageWarpIndex);
      }
      dispatchOnPageEndWarp();
      resetPageWarp();
    }
    onPageEndMoving();
  }
}","protected void pageEndMoving(){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + mIsPageMoving + ""String_Node_Str"");
  if (mIsPageMoving) {
    mIsPageMoving=false;
    if (isWarping()) {
      dispatchOnPageEndWarp();
      mWarpPageExposed=false;
    }
    onPageEndMoving();
  }
}",0.8024502297090352
199962,"private void animateWarpPageOnScreen(String reason){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str"");
  if (isWarping() && !mWarpPageExposed) {
    mWarpPageExposed=true;
    dispatchOnPageBeginWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    DecelerateInterpolator interp=new DecelerateInterpolator(1.5f);
    mWarpAnimation=v.animate();
    mWarpAnimation.translationX(mWarpPeekAmount).setInterpolator(interp).setDuration(WARP_PEEK_ANIMATION_DURATION).setListener(mOnScreenAnimationListener);
  }
}","private void animateWarpPageOnScreen(String reason){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str"");
  if (!mWarpPageExposed) {
    mWarpPageExposed=true;
    dispatchOnPageBeginWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    DecelerateInterpolator interp=new DecelerateInterpolator(1.5f);
    int totalOffset=getCurrentWarpOffset();
    v.setTranslationX(totalOffset);
    mWarpAnimation=v.animate();
    mWarpAnimation.translationX(mWarpPeekAmount + totalOffset).setInterpolator(interp).setDuration(WARP_PEEK_ANIMATION_DURATION).setListener(mOnScreenAnimationListener);
  }
}",0.9159970781592404
199963,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (DISABLE_TOUCH_INTERACTION) {
    return false;
  }
  if (getChildCount() <= 0)   return super.onTouchEvent(ev);
  acquireVelocityTrackerAndAddMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  saveDownState(ev);
if (mTouchState == TOUCH_STATE_SCROLLING) {
  pageBeginMoving();
}
 else {
  setTouchState(TOUCH_STATE_READY);
}
if (mIsCameraEvent) {
animateWarpPageOnScreen(""String_Node_Str"");
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (isWarping()) {
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
v.setTranslationX(v.getTranslationX() - deltaX);
}
 else if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
final int dragViewIndex=indexOfChild(mDragView);
int bufferSize=(int)(REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth());
int leftBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.left,0)[0] + bufferSize);
int rightBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.right,0)[0] - bufferSize);
boolean isHoveringOverDelete=isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY);
setPageHoveringOverDeleteDropTarget(dragViewIndex,isHoveringOverDelete);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + leftBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + rightBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionY);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionY);
float parentX=mParentDownMotionX;
int pageIndexToSnapTo=-1;
if (parentX < leftBufferEdge && dragViewIndex > 0) {
pageIndexToSnapTo=dragViewIndex - 1;
}
 else if (parentX > rightBufferEdge && dragViewIndex < getChildCount() - 1) {
pageIndexToSnapTo=dragViewIndex + 1;
}
final int pageUnderPointIndex=pageIndexToSnapTo;
if (pageUnderPointIndex > -1 && !isHoveringOverDelete) {
mTempVisiblePagesRange[0]=0;
mTempVisiblePagesRange[1]=getPageCount() - 1;
boundByReorderablePages(true,mTempVisiblePagesRange);
if (mTempVisiblePagesRange[0] <= pageUnderPointIndex && pageUnderPointIndex <= mTempVisiblePagesRange[1] && pageUnderPointIndex != mSidePageHoverIndex && mScroller.isFinished()) {
mSidePageHoverIndex=pageUnderPointIndex;
mSidePageHoverRunnable=new Runnable(){
  @Override public void run(){
    mDownScrollX=getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);
    snapToPage(pageUnderPointIndex);
    int shiftDelta=(dragViewIndex < pageUnderPointIndex) ? -1 : 1;
    int lowerIndex=(dragViewIndex < pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;
    int upperIndex=(dragViewIndex > pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;
    for (int i=lowerIndex; i <= upperIndex; ++i) {
      View v=getChildAt(i);
      int oldX=getViewportOffsetX() + getChildOffset(i);
      int newX=getViewportOffsetX() + getChildOffset(i + shiftDelta);
      AnimatorSet anim=(AnimatorSet)v.getTag();
      if (anim != null) {
        anim.cancel();
      }
      v.setTranslationX(oldX - newX);
      anim=new AnimatorSet();
      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
      anim.playTogether(ObjectAnimator.ofFloat(v,""String_Node_Str"",0f));
      anim.start();
      v.setTag(anim);
    }
    removeView(mDragView);
    onRemoveView(mDragView,false);
    addView(mDragView,pageUnderPointIndex);
    onAddView(mDragView,pageUnderPointIndex);
    mSidePageHoverIndex=-1;
  }
}
;
postDelayed(mSidePageHoverRunnable,REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
}
}
 else {
removeCallbacks(mSidePageHoverRunnable);
mSidePageHoverIndex=-1;
}
}
 else if (mIsCameraEvent || determineScrollingStart(ev)) {
startScrolling(ev);
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
boolean isSignificantMove=Math.abs(deltaX) > pageWidth * SIGNIFICANT_MOVE_THRESHOLD;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > mFlingThresholdVelocity;
boolean returnToOriginalPage=false;
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX) && isFling) {
returnToOriginalPage=true;
}
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage || isWarping() ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
boolean handledFling=false;
if (!DISABLE_FLING_TO_DELETE) {
PointF flingToDeleteVector=isFlingingToDelete();
if (flingToDeleteVector != null) {
onFlingToDelete(flingToDeleteVector);
handledFling=true;
}
}
if (!handledFling && isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY)) {
onDropToDelete();
}
}
 else {
if (DEBUG_WARP) Log.v(TAG,""String_Node_Str"");
if (mWarpPageExposed && !isAnimatingWarpPage()) {
animateWarpPageOffScreen(""String_Node_Str"",true);
}
onUnhandledTap(ev);
}
removeCallbacks(mSidePageHoverRunnable);
resetTouchState();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
resetTouchState();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (DISABLE_TOUCH_INTERACTION) {
    return false;
  }
  if (getChildCount() <= 0)   return super.onTouchEvent(ev);
  acquireVelocityTrackerAndAddMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  saveDownState(ev);
if (mTouchState == TOUCH_STATE_SCROLLING) {
  pageBeginMoving();
}
 else {
  setTouchState(TOUCH_STATE_READY);
}
if (mIsCameraEvent) {
animateWarpPageOnScreen(""String_Node_Str"");
}
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final float deltaX=mLastMotionX + mLastMotionXRemainder - x;
mTotalMotionX+=Math.abs(deltaX);
if (Math.abs(deltaX) >= 1.0f) {
mTouchX+=deltaX;
mSmoothingTime=System.nanoTime() / NANOTIME_DIV;
if (isWarping()) {
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
v.setTranslationX(v.getTranslationX() - deltaX);
}
 else if (!mDeferScrollUpdate) {
scrollBy((int)deltaX,0);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + deltaX);
}
 else {
invalidate();
}
mLastMotionX=x;
mLastMotionXRemainder=deltaX - (int)deltaX;
}
 else {
awakenScrollBars();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
final int dragViewIndex=indexOfChild(mDragView);
int bufferSize=(int)(REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth());
int leftBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.left,0)[0] + bufferSize);
int rightBufferEdge=(int)(mapPointFromViewToParent(this,mViewport.right,0)[0] - bufferSize);
boolean isHoveringOverDelete=isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY);
setPageHoveringOverDeleteDropTarget(dragViewIndex,isHoveringOverDelete);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + leftBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + rightBufferEdge);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mLastMotionY);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionX);
if (DEBUG) Log.d(TAG,""String_Node_Str"" + mParentDownMotionY);
float parentX=mParentDownMotionX;
int pageIndexToSnapTo=-1;
if (parentX < leftBufferEdge && dragViewIndex > 0) {
pageIndexToSnapTo=dragViewIndex - 1;
}
 else if (parentX > rightBufferEdge && dragViewIndex < getChildCount() - 1) {
pageIndexToSnapTo=dragViewIndex + 1;
}
final int pageUnderPointIndex=pageIndexToSnapTo;
if (pageUnderPointIndex > -1 && !isHoveringOverDelete) {
mTempVisiblePagesRange[0]=0;
mTempVisiblePagesRange[1]=getPageCount() - 1;
boundByReorderablePages(true,mTempVisiblePagesRange);
if (mTempVisiblePagesRange[0] <= pageUnderPointIndex && pageUnderPointIndex <= mTempVisiblePagesRange[1] && pageUnderPointIndex != mSidePageHoverIndex && mScroller.isFinished()) {
mSidePageHoverIndex=pageUnderPointIndex;
mSidePageHoverRunnable=new Runnable(){
  @Override public void run(){
    mDownScrollX=getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);
    snapToPage(pageUnderPointIndex);
    int shiftDelta=(dragViewIndex < pageUnderPointIndex) ? -1 : 1;
    int lowerIndex=(dragViewIndex < pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;
    int upperIndex=(dragViewIndex > pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;
    for (int i=lowerIndex; i <= upperIndex; ++i) {
      View v=getChildAt(i);
      int oldX=getViewportOffsetX() + getChildOffset(i);
      int newX=getViewportOffsetX() + getChildOffset(i + shiftDelta);
      AnimatorSet anim=(AnimatorSet)v.getTag();
      if (anim != null) {
        anim.cancel();
      }
      v.setTranslationX(oldX - newX);
      anim=new AnimatorSet();
      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
      anim.playTogether(ObjectAnimator.ofFloat(v,""String_Node_Str"",0f));
      anim.start();
      v.setTag(anim);
    }
    removeView(mDragView);
    onRemoveView(mDragView,false);
    addView(mDragView,pageUnderPointIndex);
    onAddView(mDragView,pageUnderPointIndex);
    mSidePageHoverIndex=-1;
  }
}
;
postDelayed(mSidePageHoverRunnable,REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
}
}
 else {
removeCallbacks(mSidePageHoverRunnable);
mSidePageHoverIndex=-1;
}
}
 else if (determineScrollingStart(ev)) {
startScrolling(ev);
}
 else if (isHorizontalCameraScroll(ev)) {
startScrolling(ev);
KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
v.animate().cancel();
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
if (pointerIndex == -1) return true;
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
final int deltaX=(int)(x - mDownMotionX);
final int pageWidth=getScaledMeasuredWidth(getPageAt(mCurrentPage));
boolean isSignificantMove=Math.abs(deltaX) > pageWidth * SIGNIFICANT_MOVE_THRESHOLD;
mTotalMotionX+=Math.abs(mLastMotionX + mLastMotionXRemainder - x);
boolean isFling=mTotalMotionX > MIN_LENGTH_FOR_FLING && Math.abs(velocityX) > mFlingThresholdVelocity;
boolean returnToOriginalPage=false;
if (Math.abs(deltaX) > pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD && Math.signum(velocityX) != Math.signum(deltaX) && isFling) {
returnToOriginalPage=true;
}
int finalPage;
if (((isSignificantMove && deltaX > 0 && !isFling) || (isFling && velocityX > 0)) && mCurrentPage > 0) {
finalPage=returnToOriginalPage || isWarping() ? mCurrentPage : mCurrentPage - 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else if (((isSignificantMove && deltaX < 0 && !isFling) || (isFling && velocityX < 0)) && mCurrentPage < getChildCount() - 1) {
finalPage=returnToOriginalPage ? mCurrentPage : isWarping() ? getPageWarpIndex() : mCurrentPage + 1;
snapToPageWithVelocity(finalPage,velocityX);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_REORDERING) {
mLastMotionX=ev.getX();
mLastMotionY=ev.getY();
float[] pt=mapPointFromViewToParent(this,mLastMotionX,mLastMotionY);
mParentDownMotionX=pt[0];
mParentDownMotionY=pt[1];
updateDragViewTranslationDuringDrag();
boolean handledFling=false;
if (!DISABLE_FLING_TO_DELETE) {
PointF flingToDeleteVector=isFlingingToDelete();
if (flingToDeleteVector != null) {
onFlingToDelete(flingToDeleteVector);
handledFling=true;
}
}
if (!handledFling && isHoveringOverDeleteDropTarget((int)mParentDownMotionX,(int)mParentDownMotionY)) {
onDropToDelete();
}
}
 else {
if (DEBUG_WARP) Log.v(TAG,""String_Node_Str"");
if (mWarpPageExposed && !isAnimatingWarpPage()) {
animateWarpPageOffScreen(""String_Node_Str"",true);
}
onUnhandledTap(ev);
}
removeCallbacks(mSidePageHoverRunnable);
resetTouchState();
break;
case MotionEvent.ACTION_CANCEL:
if (mTouchState == TOUCH_STATE_SCROLLING) {
snapToDestination();
}
resetTouchState();
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}",0.9836192942699904
199964,"protected boolean isWarping(){
  return mPageWarpIndex != -1;
}","protected boolean isWarping(){
  return mWarpPageExposed;
}",0.819672131147541
199965,"private void animateWarpPageOffScreen(String reason,boolean animate){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ animate+ ""String_Node_Str"");
  if (isWarping()) {
    dispatchOnPageEndWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(mPageWarpIndex);
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    AccelerateInterpolator interp=new AccelerateInterpolator(1.5f);
    v.animate().translationX(0.0f).setInterpolator(interp).setDuration(animate ? WARP_PEEK_ANIMATION_DURATION : 0).setListener(mOffScreenAnimationListener);
  }
 else {
    if (DEBUG_WARP)     Log.e(TAG,""String_Node_Str"",new Exception());
  }
}","private void animateWarpPageOffScreen(String reason,boolean animate){
  if (DEBUG_WARP)   Log.v(TAG,""String_Node_Str"" + reason + ""String_Node_Str""+ animate+ ""String_Node_Str"");
  if (mWarpPageExposed) {
    dispatchOnPageEndWarp();
    KeyguardWidgetFrame v=(KeyguardWidgetFrame)getPageAt(getPageWarpIndex());
    if (DEBUG_WARP)     Log.v(TAG,""String_Node_Str"" + v.getTranslationX());
    AccelerateInterpolator interp=new AccelerateInterpolator(1.5f);
    int totalOffset=getCurrentWarpOffset();
    v.animate().translationX(totalOffset).setInterpolator(interp).setDuration(animate ? WARP_PEEK_ANIMATION_DURATION : 0).setListener(mOffScreenAnimationListener);
  }
 else {
    if (DEBUG_WARP)     Log.e(TAG,""String_Node_Str"",new Exception());
  }
}",0.9360222531293464
199966,"protected int getPageWarpIndex(){
  return mPageWarpIndex;
}","protected int getPageWarpIndex(){
  return getPageCount() - 1;
}",0.8225806451612904
199967,"/** 
 * Get the LTE signal level as an asu value between 0..97, 99 is unknown Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */
@Override public int getAsuLevel(){
  final int cdmaDbm=getCdmaDbm();
  final int cdmaEcio=getCdmaEcio();
  int cdmaAsuLevel;
  int ecioAsuLevel;
  if (cdmaDbm >= -75)   cdmaAsuLevel=16;
 else   if (cdmaDbm >= -82)   cdmaAsuLevel=8;
 else   if (cdmaDbm >= -90)   cdmaAsuLevel=4;
 else   if (cdmaDbm >= -95)   cdmaAsuLevel=2;
 else   if (cdmaDbm >= -100)   cdmaAsuLevel=1;
 else   cdmaAsuLevel=99;
  if (cdmaEcio >= -90)   ecioAsuLevel=16;
 else   if (cdmaEcio >= -100)   ecioAsuLevel=8;
 else   if (cdmaEcio >= -115)   ecioAsuLevel=4;
 else   if (cdmaEcio >= -130)   ecioAsuLevel=2;
 else   if (cdmaEcio >= -150)   ecioAsuLevel=1;
 else   ecioAsuLevel=99;
  int level=(cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
  if (DBG)   log(""String_Node_Str"" + level);
  return level;
}","/** 
 * Get the signal level as an asu value between 0..97, 99 is unknown Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */
@Override public int getAsuLevel(){
  final int cdmaDbm=getCdmaDbm();
  final int cdmaEcio=getCdmaEcio();
  int cdmaAsuLevel;
  int ecioAsuLevel;
  if (cdmaDbm >= -75)   cdmaAsuLevel=16;
 else   if (cdmaDbm >= -82)   cdmaAsuLevel=8;
 else   if (cdmaDbm >= -90)   cdmaAsuLevel=4;
 else   if (cdmaDbm >= -95)   cdmaAsuLevel=2;
 else   if (cdmaDbm >= -100)   cdmaAsuLevel=1;
 else   cdmaAsuLevel=99;
  if (cdmaEcio >= -90)   ecioAsuLevel=16;
 else   if (cdmaEcio >= -100)   ecioAsuLevel=8;
 else   if (cdmaEcio >= -115)   ecioAsuLevel=4;
 else   if (cdmaEcio >= -130)   ecioAsuLevel=2;
 else   if (cdmaEcio >= -150)   ecioAsuLevel=1;
 else   ecioAsuLevel=99;
  int level=(cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
  if (DBG)   log(""String_Node_Str"" + level);
  return level;
}",0.9978991596638656
199968,"/** 
 * Given a start and stop distance, return in dst the intervening segment(s). If the segment is zero-length, return false, else return true. startD and stopD are pinned to legal values (0..getLength()). If startD <= stopD then return false (and leave dst untouched). Begin the segment with a moveTo if startWithMoveTo is true
 */
public boolean getSegment(float startD,float stopD,Path dst,boolean startWithMoveTo){
  return native_getSegment(native_instance,startD,stopD,dst.ni(),startWithMoveTo);
}","/** 
 * Given a start and stop distance, return in dst the intervening segment(s). If the segment is zero-length, return false, else return true. startD and stopD are pinned to legal values (0..getLength()). If startD <= stopD then return false (and leave dst untouched). Begin the segment with a moveTo if startWithMoveTo is true. <p>On   {@link android.os.Build.VERSION_CODES#KITKAT} and earlierreleases, the resulting path may not display on a hardware-accelerated Canvas. A simple workaround is to add a single operation to this path, such as <code>dst.rLineTo(0, 0)</code>.</p>
 */
public boolean getSegment(float startD,float stopD,Path dst,boolean startWithMoveTo){
  dst.isSimplePath=false;
  return native_getSegment(native_instance,startD,stopD,dst.ni(),startWithMoveTo);
}",0.7841614906832298
199969,"/** 
 * Given a start and stop distance, return in dst the intervening segment(s). If the segment is zero-length, return false, else return true. startD and stopD are pinned to legal values (0..getLength()). If startD <= stopD then return false (and leave dst untouched). Begin the segment with a moveTo if startWithMoveTo is true
 */
public boolean getSegment(float startD,float stopD,Path dst,boolean startWithMoveTo){
  return native_getSegment(native_instance,startD,stopD,dst.ni(),startWithMoveTo);
}","/** 
 * Given a start and stop distance, return in dst the intervening segment(s). If the segment is zero-length, return false, else return true. startD and stopD are pinned to legal values (0..getLength()). If startD <= stopD then return false (and leave dst untouched). Begin the segment with a moveTo if startWithMoveTo is true. <p>On   {@link android.os.Build.VERSION_CODES#KITKAT} and earlierreleases, the resulting path may not display on a hardware-accelerated Canvas. A simple workaround is to add a single operation to this path, such as <code>dst.rLineTo(0, 0)</code>.</p>
 */
public boolean getSegment(float startD,float stopD,Path dst,boolean startWithMoveTo){
  dst.isSimplePath=false;
  return native_getSegment(native_instance,startD,stopD,dst.ni(),startWithMoveTo);
}",0.7841614906832298
199970,"/** 
 * Get the LTE signal level as an asu value between 0..97, 99 is unknown Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */
@Override public int getAsuLevel(){
  final int cdmaDbm=getCdmaDbm();
  final int cdmaEcio=getCdmaEcio();
  int cdmaAsuLevel;
  int ecioAsuLevel;
  if (cdmaDbm >= -75)   cdmaAsuLevel=16;
 else   if (cdmaDbm >= -82)   cdmaAsuLevel=8;
 else   if (cdmaDbm >= -90)   cdmaAsuLevel=4;
 else   if (cdmaDbm >= -95)   cdmaAsuLevel=2;
 else   if (cdmaDbm >= -100)   cdmaAsuLevel=1;
 else   cdmaAsuLevel=99;
  if (cdmaEcio >= -90)   ecioAsuLevel=16;
 else   if (cdmaEcio >= -100)   ecioAsuLevel=8;
 else   if (cdmaEcio >= -115)   ecioAsuLevel=4;
 else   if (cdmaEcio >= -130)   ecioAsuLevel=2;
 else   if (cdmaEcio >= -150)   ecioAsuLevel=1;
 else   ecioAsuLevel=99;
  int level=(cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
  if (DBG)   log(""String_Node_Str"" + level);
  return level;
}","/** 
 * Get the signal level as an asu value between 0..97, 99 is unknown Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */
@Override public int getAsuLevel(){
  final int cdmaDbm=getCdmaDbm();
  final int cdmaEcio=getCdmaEcio();
  int cdmaAsuLevel;
  int ecioAsuLevel;
  if (cdmaDbm >= -75)   cdmaAsuLevel=16;
 else   if (cdmaDbm >= -82)   cdmaAsuLevel=8;
 else   if (cdmaDbm >= -90)   cdmaAsuLevel=4;
 else   if (cdmaDbm >= -95)   cdmaAsuLevel=2;
 else   if (cdmaDbm >= -100)   cdmaAsuLevel=1;
 else   cdmaAsuLevel=99;
  if (cdmaEcio >= -90)   ecioAsuLevel=16;
 else   if (cdmaEcio >= -100)   ecioAsuLevel=8;
 else   if (cdmaEcio >= -115)   ecioAsuLevel=4;
 else   if (cdmaEcio >= -130)   ecioAsuLevel=2;
 else   if (cdmaEcio >= -150)   ecioAsuLevel=1;
 else   ecioAsuLevel=99;
  int level=(cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
  if (DBG)   log(""String_Node_Str"" + level);
  return level;
}",0.9978991596638656
199971,"/** 
 * Get the LTE signal level as an asu value between 0..97, 99 is unknown Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */
@Override public int getAsuLevel(){
  final int cdmaDbm=getCdmaDbm();
  final int cdmaEcio=getCdmaEcio();
  int cdmaAsuLevel;
  int ecioAsuLevel;
  if (cdmaDbm >= -75)   cdmaAsuLevel=16;
 else   if (cdmaDbm >= -82)   cdmaAsuLevel=8;
 else   if (cdmaDbm >= -90)   cdmaAsuLevel=4;
 else   if (cdmaDbm >= -95)   cdmaAsuLevel=2;
 else   if (cdmaDbm >= -100)   cdmaAsuLevel=1;
 else   cdmaAsuLevel=99;
  if (cdmaEcio >= -90)   ecioAsuLevel=16;
 else   if (cdmaEcio >= -100)   ecioAsuLevel=8;
 else   if (cdmaEcio >= -115)   ecioAsuLevel=4;
 else   if (cdmaEcio >= -130)   ecioAsuLevel=2;
 else   if (cdmaEcio >= -150)   ecioAsuLevel=1;
 else   ecioAsuLevel=99;
  int level=(cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
  if (DBG)   log(""String_Node_Str"" + level);
  return level;
}","/** 
 * Get the signal level as an asu value between 0..97, 99 is unknown Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */
@Override public int getAsuLevel(){
  final int cdmaDbm=getCdmaDbm();
  final int cdmaEcio=getCdmaEcio();
  int cdmaAsuLevel;
  int ecioAsuLevel;
  if (cdmaDbm >= -75)   cdmaAsuLevel=16;
 else   if (cdmaDbm >= -82)   cdmaAsuLevel=8;
 else   if (cdmaDbm >= -90)   cdmaAsuLevel=4;
 else   if (cdmaDbm >= -95)   cdmaAsuLevel=2;
 else   if (cdmaDbm >= -100)   cdmaAsuLevel=1;
 else   cdmaAsuLevel=99;
  if (cdmaEcio >= -90)   ecioAsuLevel=16;
 else   if (cdmaEcio >= -100)   ecioAsuLevel=8;
 else   if (cdmaEcio >= -115)   ecioAsuLevel=4;
 else   if (cdmaEcio >= -130)   ecioAsuLevel=2;
 else   if (cdmaEcio >= -150)   ecioAsuLevel=1;
 else   ecioAsuLevel=99;
  int level=(cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
  if (DBG)   log(""String_Node_Str"" + level);
  return level;
}",0.9978991596638656
199972,"/** 
 * Given a start and stop distance, return in dst the intervening segment(s). If the segment is zero-length, return false, else return true. startD and stopD are pinned to legal values (0..getLength()). If startD <= stopD then return false (and leave dst untouched). Begin the segment with a moveTo if startWithMoveTo is true
 */
public boolean getSegment(float startD,float stopD,Path dst,boolean startWithMoveTo){
  return native_getSegment(native_instance,startD,stopD,dst.ni(),startWithMoveTo);
}","/** 
 * Given a start and stop distance, return in dst the intervening segment(s). If the segment is zero-length, return false, else return true. startD and stopD are pinned to legal values (0..getLength()). If startD <= stopD then return false (and leave dst untouched). Begin the segment with a moveTo if startWithMoveTo is true. <p>On   {@link android.os.Build.VERSION_CODES#KITKAT} and earlierreleases, the resulting path may not display on a hardware-accelerated Canvas. A simple workaround is to add a single operation to this path, such as <code>dst.rLineTo(0, 0)</code>.</p>
 */
public boolean getSegment(float startD,float stopD,Path dst,boolean startWithMoveTo){
  dst.isSimplePath=false;
  return native_getSegment(native_instance,startD,stopD,dst.ni(),startWithMoveTo);
}",0.7841614906832298
199973,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.999486125385406
199974,"private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}","private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}",0.999613152804642
199975,"void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}","void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}",0.9996868149076104
199976,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      app.services.removeAt(i);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.9859536717594874
199977,"ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STATS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}","ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}",0.9995949777237748
199978,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}",0.9991184249191888
199979,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}",0.9967105263157896
199980,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.999486125385406
199981,"private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}","private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}",0.999613152804642
199982,"void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}","void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}",0.9996868149076104
199983,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      app.services.removeAt(i);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.9859536717594874
199984,"ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STATS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}","ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}",0.9995949777237748
199985,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}",0.9991184249191888
199986,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}",0.9967105263157896
199987,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.999486125385406
199988,"private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}","private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}",0.999613152804642
199989,"void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}","void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}",0.9996868149076104
199990,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      app.services.removeAt(i);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.9859536717594874
199991,"ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STATS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}","ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}",0.9995949777237748
199992,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}",0.9991184249191888
199993,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}",0.9967105263157896
199994,"private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}","private final void realStartServiceLocked(ServiceRecord r,ProcessRecord app,boolean execInFg) throws RemoteException {
  if (app.thread == null) {
    throw new RemoteException();
  }
  if (DEBUG_MU)   Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app.uid);
  r.app=app;
  r.restartTime=r.lastActivity=SystemClock.uptimeMillis();
  app.services.add(r);
  bumpServiceExecutingLocked(r,execInFg,""String_Node_Str"");
  mAm.updateLruProcessLocked(app,false,null);
  mAm.updateOomAdjLocked();
  boolean created=false;
  try {
    String nameTerm;
    int lastPeriod=r.shortName.lastIndexOf('.');
    nameTerm=lastPeriod >= 0 ? r.shortName.substring(lastPeriod) : r.shortName;
    EventLogTags.writeAmCreateService(r.userId,System.identityHashCode(r),nameTerm,r.app.uid,r.app.pid);
synchronized (r.stats.getBatteryStats()) {
      r.stats.startLaunchedLocked();
    }
    mAm.ensurePackageDexOpt(r.serviceInfo.packageName);
    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
    app.thread.scheduleCreateService(r,r.serviceInfo,mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),app.repProcState);
    r.postNotification();
    created=true;
  }
  finally {
    if (!created) {
      app.services.remove(r);
      r.app=null;
      scheduleServiceRestartLocked(r,false);
    }
  }
  requestServiceBindingsLocked(r,execInFg);
  if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
    r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),null,null));
  }
  sendServiceArgsLocked(r,execInFg,true);
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
}",0.999486125385406
199995,"private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}","private final String bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean execInFg,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,execInFg,false);
    return null;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return null;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.intent);
  if (mRestartingServices.remove(r)) {
    clearRestartingIfNeededLocked(r);
  }
  if (r.delayed) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    getServiceMap(r.userId).mDelayedStartList.remove(r);
    r.delayed=false;
  }
  if (mAm.mStartedUsers.get(r.userId) == null) {
    String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str""+ r.userId+ ""String_Node_Str"";
    Slog.w(TAG,msg);
    bringDownServiceLocked(r);
    return msg;
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,""String_Node_Str"" + r.packageName + ""String_Node_Str""+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid,false);
    if (DEBUG_MU)     Slog.v(TAG_MU,""String_Node_Str"" + r.appInfo.uid + ""String_Node_Str""+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName,mAm.mProcessStats);
        realStartServiceLocked(r,app,execInFg);
        return null;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false,isolated,false)) == null) {
      String msg=""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"";
      Slog.w(TAG,msg);
      bringDownServiceLocked(r);
      return msg;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  if (r.delayedStop) {
    r.delayedStop=false;
    if (r.startRequested) {
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      stopServiceLocked(r);
    }
  }
  return null;
}",0.999613152804642
199996,"void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}","void rescheduleDelayedStarts(){
  removeMessages(MSG_BG_START_TIMEOUT);
  final long now=SystemClock.uptimeMillis();
  for (int i=0, N=mStartingBackground.size(); i < N; i++) {
    ServiceRecord r=mStartingBackground.get(i);
    if (r.startingBgTimeout <= now) {
      Slog.i(TAG,""String_Node_Str"" + r);
      mStartingBackground.remove(i);
      N--;
    }
  }
  while (mDelayedStartList.size() > 0 && mStartingBackground.size() < mMaxStartingBackground) {
    ServiceRecord r=mDelayedStartList.remove(0);
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    if (r.pendingStarts.size() <= 0) {
      Slog.w(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ r.startRequested+ ""String_Node_Str""+ r.delayedStop);
    }
    if (DEBUG_DELAYED_SERVICE) {
      if (mDelayedStartList.size() > 0) {
        Slog.v(TAG,""String_Node_Str"");
        for (int i=0; i < mDelayedStartList.size(); i++) {
          Slog.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ mDelayedStartList.get(i));
        }
      }
    }
    r.delayed=false;
    startServiceInnerLocked(this,r.pendingStarts.get(0).intent,r,false,true);
  }
  if (mStartingBackground.size() > 0) {
    ServiceRecord next=mStartingBackground.get(0);
    long when=next.startingBgTimeout > now ? next.startingBgTimeout : now;
    if (DEBUG_DELAYED_SERVICE)     Slog.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ when);
    Message msg=obtainMessage(MSG_BG_START_TIMEOUT);
    sendMessageAtTime(msg,when);
  }
  if (mStartingBackground.size() < mMaxStartingBackground) {
    mAm.backgroundServicesFinishedLocked(mUserId);
  }
}",0.9996868149076104
199997,"final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      app.services.removeAt(i);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}","final void killServicesLocked(ProcessRecord app,boolean allowRestart){
  if (false) {
    if (app.services.size() > 0) {
      Iterator<ServiceRecord> it=app.services.iterator();
      while (it.hasNext()) {
        ServiceRecord r=it.next();
        for (int conni=r.connections.size() - 1; conni >= 0; conni--) {
          ArrayList<ConnectionRecord> cl=r.connections.valueAt(conni);
          for (int i=0; i < cl.size(); i++) {
            ConnectionRecord c=cl.get(i);
            if (c.binding.client != app) {
              try {
              }
 catch (              Exception e) {
                Slog.w(TAG,""String_Node_Str"" + r.shortName + ""String_Node_Str""+ app.processName,e);
              }
            }
          }
        }
      }
    }
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
synchronized (sr.stats.getBatteryStats()) {
      sr.stats.stopLaunchedLocked();
    }
    if (sr.app != app && sr.app != null && !sr.app.persistent) {
      sr.app.services.remove(sr);
    }
    sr.app=null;
    sr.isolatedProc=null;
    sr.executeNesting=0;
    sr.forceClearTracker();
    if (mDestroyingServices.remove(sr)) {
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
    final int numClients=sr.bindings.size();
    for (int bindingi=numClients - 1; bindingi >= 0; bindingi--) {
      IntentBindRecord b=sr.bindings.valueAt(bindingi);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + b + ""String_Node_Str""+ b.hasBound);
      b.binder=null;
      b.requested=b.received=b.hasBound=false;
    }
  }
  for (int i=app.connections.size() - 1; i >= 0; i--) {
    ConnectionRecord r=app.connections.valueAt(i);
    removeConnectionLocked(r,app,null);
  }
  app.connections.clear();
  ServiceMap smap=getServiceMap(app.userId);
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    if (!app.persistent) {
      app.services.removeAt(i);
    }
    if (smap.mServicesByName.get(sr.name) != sr) {
      ServiceRecord cur=smap.mServicesByName.get(sr.name);
      Slog.wtf(TAG,""String_Node_Str"" + sr + ""String_Node_Str""+ app+ ""String_Node_Str""+ cur);
      continue;
    }
    if (allowRestart && sr.crashCount >= 2 && (sr.serviceInfo.applicationInfo.flags & ApplicationInfo.FLAG_PERSISTENT) == 0) {
      Slog.w(TAG,""String_Node_Str"" + sr.crashCount + ""String_Node_Str""+ sr);
      EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,sr.userId,sr.crashCount,sr.shortName,app.pid);
      bringDownServiceLocked(sr);
    }
 else     if (!allowRestart) {
      bringDownServiceLocked(sr);
    }
 else {
      boolean canceled=scheduleServiceRestartLocked(sr,true);
      if (sr.startRequested && (sr.stopIfKilled || canceled)) {
        if (sr.pendingStarts.size() == 0) {
          sr.startRequested=false;
          if (sr.tracker != null) {
            sr.tracker.setStarted(false,mAm.mProcessStats.getMemFactorLocked(),SystemClock.uptimeMillis());
          }
          if (!sr.hasAutoCreateConnections()) {
            bringDownServiceLocked(sr);
          }
        }
      }
    }
  }
  if (!allowRestart) {
    app.services.clear();
    for (int i=mRestartingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mRestartingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mRestartingServices.remove(i);
        clearRestartingIfNeededLocked(r);
      }
    }
    for (int i=mPendingServices.size() - 1; i >= 0; i--) {
      ServiceRecord r=mPendingServices.get(i);
      if (r.processName.equals(app.processName) && r.serviceInfo.applicationInfo.uid == app.info.uid) {
        mPendingServices.remove(i);
      }
    }
  }
  int i=mDestroyingServices.size();
  while (i > 0) {
    i--;
    ServiceRecord sr=mDestroyingServices.get(i);
    if (sr.app == app) {
      sr.forceClearTracker();
      mDestroyingServices.remove(i);
      if (DEBUG_SERVICE)       Slog.v(TAG,""String_Node_Str"" + sr);
    }
  }
  app.executingServices.clear();
}",0.9859536717594874
199998,"ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STATS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}","ComponentName startServiceInnerLocked(ServiceMap smap,Intent service,ServiceRecord r,boolean callerFg,boolean addToStarting){
  ProcessStats.ServiceState stracker=r.getTracker();
  if (stracker != null) {
    stracker.setStarted(true,mAm.mProcessStats.getMemFactorLocked(),r.lastActivity);
  }
  r.callStart=false;
synchronized (r.stats.getBatteryStats()) {
    r.stats.startRunningLocked();
  }
  String error=bringUpServiceLocked(r,service.getFlags(),callerFg,false);
  if (error != null) {
    return new ComponentName(""String_Node_Str"",error);
  }
  if (r.startRequested && addToStarting) {
    boolean first=smap.mStartingBackground.size() == 0;
    smap.mStartingBackground.add(r);
    r.startingBgTimeout=SystemClock.uptimeMillis() + BG_START_TIMEOUT;
    if (DEBUG_DELAYED_SERVICE) {
      RuntimeException here=new RuntimeException(""String_Node_Str"");
      here.fillInStackTrace();
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r,here);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      Slog.v(TAG,""String_Node_Str"" + first + ""String_Node_Str""+ r);
    }
    if (first) {
      smap.rescheduleDelayedStarts();
    }
  }
 else   if (callerFg) {
    smap.ensureNotStartingBackground(r);
  }
  return r.name;
}",0.9995949777237748
199999,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STATS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STATS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STATS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STATS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STATS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,int userId){
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPid,callingUid,userId,true,callerFg);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null);
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mStartedUsers.get(r.userId) != null) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}",0.9991184249191888
200000,"void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STATS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}","void ensureNotStartingBackground(ServiceRecord r){
  if (mStartingBackground.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
    rescheduleDelayedStarts();
  }
  if (mDelayedStartList.remove(r)) {
    if (DEBUG_DELAYED_STARTS)     Slog.v(TAG,""String_Node_Str"" + r);
  }
}",0.9967105263157896
