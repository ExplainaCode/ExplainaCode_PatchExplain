record_number,buggy_code,fixed_code,code_similarity
30001,"/** 
 * @return 
 */
public boolean isDegenerate(){
  return ((getTrueDim() < 3) && (getTrueDim() > -1));
}","/** 
 * @return
 */
public boolean isDegenerate(){
  return ((getTrueDim() < 3) && (getTrueDim() > -1));
}",0.9953051643192488
30002,"/** 
 * @return 
 */
public double getDepth(){
  return getSize(2);
}","/** 
 * @return
 */
public double getDepth(){
  return getSize(2);
}",0.9927007299270072
30003,"/** 
 * @param p1 
 * @param p2 
 * @param q1 
 * @param q2 
 * @return 
 */
public static boolean intersects(final WB_Coordinate p1,final WB_Coordinate p2,final WB_Coordinate q1,final WB_Coordinate q2){
  double minq=Math.min(q1.xd(),q2.xd());
  double maxq=Math.max(q1.xd(),q2.xd());
  double minp=Math.min(p1.xd(),p2.xd());
  double maxp=Math.max(p1.xd(),p2.xd());
  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  minq=Math.min(q1.yd(),q2.yd());
  maxq=Math.max(q1.yd(),q2.yd());
  minp=Math.min(p1.yd(),p2.yd());
  maxp=Math.max(p1.yd(),p2.yd());
  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  minq=Math.min(q1.zd(),q2.zd());
  maxq=Math.max(q1.zd(),q2.zd());
  minp=Math.min(p1.zd(),p2.zd());
  maxp=Math.max(p1.zd(),p2.zd());
  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  return true;
}","/** 
 * @param p1
 * @param p2
 * @param q1
 * @param q2
 * @return
 */
public static boolean intersects(final WB_Coordinate p1,final WB_Coordinate p2,final WB_Coordinate q1,final WB_Coordinate q2){
  double minq=Math.min(q1.xd(),q2.xd());
  double maxq=Math.max(q1.xd(),q2.xd());
  double minp=Math.min(p1.xd(),p2.xd());
  double maxp=Math.max(p1.xd(),p2.xd());
  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  minq=Math.min(q1.yd(),q2.yd());
  maxq=Math.max(q1.yd(),q2.yd());
  minp=Math.min(p1.yd(),p2.yd());
  maxp=Math.max(p1.yd(),p2.yd());
  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  minq=Math.min(q1.zd(),q2.zd());
  maxq=Math.max(q1.zd(),q2.zd());
  minp=Math.min(p1.zd(),p2.zd());
  maxp=Math.max(p1.zd(),p2.zd());
  if (minp > maxq) {
    return false;
  }
  if (maxp < minq) {
    return false;
  }
  return true;
}",0.9972572682391662
30004,"/** 
 * @return 
 */
public int numberOfTriangles(){
  if (isNull()) {
    return 0;
  }
  return 12;
}","/** 
 * @return
 */
public int numberOfTriangles(){
  if (isNull()) {
    return 0;
  }
  return 12;
}",0.9951219512195122
30005,"/** 
 * @return 
 */
public int getId(){
  return _id;
}","/** 
 * @return
 */
public int getId(){
  return _id;
}",0.990990990990991
30006,"/** 
 * @return 
 */
public double getWidth(){
  return getSize(0);
}","/** 
 * @return
 */
public double getWidth(){
  return getSize(0);
}",0.9927007299270072
30007,"/** 
 * @return 
 */
public double getHeight(){
  return getSize(1);
}","/** 
 * @return
 */
public double getHeight(){
  return getSize(1);
}",0.9928057553956836
30008,"/** 
 * @param v 
 * @return 
 */
private int hashCode(final double v){
  final long tmp=Double.doubleToLongBits(v);
  return (int)(tmp ^ (tmp >>> 32));
}","/** 
 * @param v
 * @return
 */
private int hashCode(final double v){
  final long tmp=Double.doubleToLongBits(v);
  return (int)(tmp ^ (tmp >>> 32));
}",0.9934640522875816
30009,"/** 
 * @return 
 */
public WB_AABB get(){
  return new WB_AABB(_min,_max);
}","/** 
 * @return
 */
public WB_AABB get(){
  return new WB_AABB(_min,_max);
}",0.9934640522875816
30010,"/** 
 * @return 
 */
public int numberOfPoints(){
  if (isNull()) {
    return 0;
  }
  return 8;
}","/** 
 * @return
 */
public int numberOfPoints(){
  if (isNull()) {
    return 0;
  }
  return 8;
}",0.9949238578680204
30011,"/** 
 * @return 
 */
public WB_Point[] getPoints(){
  if (isNull()) {
    return null;
  }
  final int n=numberOfPoints();
  final WB_Point[] points=new WB_Point[n];
  double[] values;
  for (int i=0; i < n; i++) {
    values=new double[3];
    int disc=1;
    for (int j=0; j < 3; j++) {
      if (((i / disc) % 2) == 0) {
        values[j]=_min[j];
      }
 else {
        values[j]=_max[j];
      }
      disc*=2;
    }
    points[i]=new WB_Point(values);
  }
  return points;
}","/** 
 * @return
 */
public WB_Point[] getPoints(){
  if (isNull()) {
    return null;
  }
  final int n=numberOfPoints();
  final WB_Point[] points=new WB_Point[n];
  double[] values;
  for (int i=0; i < n; i++) {
    values=new double[3];
    int disc=1;
    for (int j=0; j < 3; j++) {
      if (((i / disc) % 2) == 0) {
        values[j]=_min[j];
      }
 else {
        values[j]=_max[j];
      }
      disc*=2;
    }
    points[i]=new WB_Point(values);
  }
  return points;
}",0.9989594172736732
30012,"/** 
 * @return 
 */
public int getDim(){
  return 3;
}","/** 
 * @return
 */
public int getDim(){
  return 3;
}",0.9908256880733946
30013,"/** 
 * @return 
 */
public List<int[]> getTriangles(){
  final List<int[]> tris=new ArrayList<int[]>();
  final int[] tri01={4,5,6};
  final int[] tri02={5,7,6};
  tris.add(tri01);
  tris.add(tri02);
  final int[] tri11={0,2,1};
  final int[] tri12={2,3,1};
  tris.add(tri11);
  tris.add(tri12);
  final int[] tri21={0,1,4};
  final int[] tri22={1,5,4};
  tris.add(tri21);
  tris.add(tri22);
  final int[] tri31={3,2,7};
  final int[] tri32={2,6,7};
  tris.add(tri31);
  tris.add(tri32);
  final int[] tri41={0,4,2};
  final int[] tri42={4,6,2};
  tris.add(tri41);
  tris.add(tri42);
  final int[] tri51={1,3,5};
  final int[] tri52={3,7,5};
  tris.add(tri51);
  tris.add(tri52);
  return tris;
}","/** 
 * @return
 */
public List<int[]> getTriangles(){
  final List<int[]> tris=new ArrayList<int[]>();
  final int[] tri01={4,5,6};
  final int[] tri02={5,7,6};
  tris.add(tri01);
  tris.add(tri02);
  final int[] tri11={0,2,1};
  final int[] tri12={2,3,1};
  tris.add(tri11);
  tris.add(tri12);
  final int[] tri21={0,1,4};
  final int[] tri22={1,5,4};
  tris.add(tri21);
  tris.add(tri22);
  final int[] tri31={3,2,7};
  final int[] tri32={2,6,7};
  tris.add(tri31);
  tris.add(tri32);
  final int[] tri41={0,4,2};
  final int[] tri42={4,6,2};
  tris.add(tri41);
  tris.add(tri42);
  final int[] tri51={1,3,5};
  final int[] tri52={3,7,5};
  tris.add(tri51);
  tris.add(tri52);
  return tris;
}",0.9992821249102656
30014,"/** 
 * @param s 
 * @return 
 */
public Object getData(final String s){
  return _data.get(s);
}","/** 
 * @param s
 * @return
 */
public Object getData(final String s){
  return (_data == null) ? null : _data.get(s);
}",0.8755760368663594
30015,"/** 
 * @return 
 */
public double maxExtent(){
  if (isNull()) {
    return 0.0;
  }
  final double w=getWidth();
  final double h=getHeight();
  final double d=getDepth();
  if (w > h) {
    return (w > d) ? w : d;
  }
  return (h > d) ? h : d;
}","/** 
 * @return
 */
public double maxExtent(){
  if (isNull()) {
    return 0.0;
  }
  final double w=getWidth();
  final double h=getHeight();
  final double d=getDepth();
  if (w > h) {
    return (w > d) ? w : d;
  }
  return (h > d) ? h : d;
}",0.997979797979798
30016,"/** 
 * @param other 
 * @return 
 */
public boolean covers(final WB_AABB other){
  if (isNull() || other.isNull()) {
    return false;
  }
  for (int i=0; i < 3; i++) {
    if (other._max[i] > _max[i]) {
      return false;
    }
    if (other._min[i] < _min[i]) {
      return false;
    }
  }
  return true;
}","/** 
 * @param other
 * @return
 */
public boolean covers(final WB_AABB other){
  if (isNull() || other.isNull()) {
    return false;
  }
  for (int i=0; i < 3; i++) {
    if (other._max[i] > _max[i]) {
      return false;
    }
    if (other._min[i] < _min[i]) {
      return false;
    }
  }
  return true;
}",0.9967845659163987
30017,"/** 
 * @return 
 */
public List<int[]> getSegments(){
  final List<double[]> points=getCoords();
  final List<int[]> segments=new ArrayList<int[]>(numberOfSegments());
  for (int i=0; i < points.size(); i++) {
    for (int j=i + 1; j < points.size(); j++) {
      int comp=0;
      for (int k=0; k < 3; k++) {
        if (points.get(i)[k] != points.get(j)[k]) {
          comp++;
        }
        if (comp > 1) {
          break;
        }
      }
      if (comp == 1) {
        final int[] seg={i,j};
        segments.add(seg);
      }
    }
  }
  return segments;
}","/** 
 * @return
 */
public List<int[]> getSegments(){
  final List<double[]> points=getCoords();
  final List<int[]> segments=new ArrayList<int[]>(numberOfSegments());
  for (int i=0; i < points.size(); i++) {
    for (int j=i + 1; j < points.size(); j++) {
      int comp=0;
      for (int k=0; k < 3; k++) {
        if (points.get(i)[k] != points.get(j)[k]) {
          comp++;
        }
        if (comp > 1) {
          break;
        }
      }
      if (comp == 1) {
        final int[] seg={i,j};
        segments.add(seg);
      }
    }
  }
  return segments;
}",0.9991204925241864
30018,"/** 
 * @param tuple 
 * @return 
 */
public double getDistance(final WB_Coordinate tuple){
  double dx=0;
  double sqr=0;
  for (int i=0; i < 3; i++) {
    if (_max[i] < tuple.getd(i)) {
      sqr+=(dx=tuple.getd(i) - _max[i]) * dx;
    }
 else     if (_min[i] > tuple.getd(i)) {
      sqr+=(dx=_min[i] - tuple.getd(i)) * dx;
    }
  }
  return Math.sqrt(sqr);
}","/** 
 * @param tuple
 * @return
 */
public double getDistance(final WB_Coordinate tuple){
  double dx=0;
  double sqr=0;
  for (int i=0; i < 3; i++) {
    if (_max[i] < tuple.getd(i)) {
      sqr+=(dx=tuple.getd(i) - _max[i]) * dx;
    }
 else     if (_min[i] > tuple.getd(i)) {
      sqr+=(dx=_min[i] - tuple.getd(i)) * dx;
    }
  }
  return Math.sqrt(sqr);
}",0.9972375690607734
30019,"/** 
 * @param points 
 */
public WB_AABB(final WB_CoordinateSequence points){
  init();
  double val;
  for (int i=0; i < points.size(); i++) {
    for (int j=0; j < 3; j++) {
      val=points.get(i,j);
      if (_min[j] > val) {
        _min[j]=val;
      }
      if (_max[j] < val) {
        _max[j]=val;
      }
    }
  }
}","/** 
 * @param points
 */
public WB_AABB(final WB_CoordinateSequence points){
  init();
  double val;
  for (int i=0; i < points.size(); i++) {
    for (int j=0; j < 3; j++) {
      val=points.get(i,j);
      if (_min[j] > val) {
        _min[j]=val;
      }
      if (_max[j] < val) {
        _max[j]=val;
      }
    }
  }
}",0.998468606431853
30020,"/** 
 * @param src 
 */
public void set(final WB_AABB src){
  System.arraycopy(src._min,0,_min,0,3);
  System.arraycopy(src._max,0,_max,0,3);
}","/** 
 * @param src
 */
public void set(final WB_AABB src){
  System.arraycopy(src._min,0,_min,0,3);
  System.arraycopy(src._max,0,_max,0,3);
}",0.9964912280701754
30021,"/** 
 * @param s 
 * @param o 
 */
public void setData(final String s,final Object o){
  if (_data == null) {
    _data=new HashMap<String,Object>();
  }
  _data.put(s,o);
}","/** 
 * @param s
 * @param o
 */
public void setData(final String s,final Object o){
  if (_data == null) {
    _data=new HashMap<String,Object>();
  }
  _data.put(s,o);
}",0.994186046511628
30022,"/** 
 * @return 
 */
public double minExtent(){
  if (isNull()) {
    return 0.0;
  }
  final double w=getWidth();
  final double h=getHeight();
  final double d=getDepth();
  if (w < h) {
    return (w < d) ? w : d;
  }
  return (h < d) ? h : d;
}","/** 
 * @return
 */
public double minExtent(){
  if (isNull()) {
    return 0.0;
  }
  final double w=getWidth();
  final double h=getHeight();
  final double d=getDepth();
  if (w < h) {
    return (w < d) ? w : d;
  }
  return (h < d) ? h : d;
}",0.997979797979798
30023,"/** 
 * @return 
 */
public boolean isValid(){
  return !isNull();
}","/** 
 * @return
 */
public boolean isValid(){
  return !isNull();
}",0.9925925925925926
30024,"/** 
 * @return 
 */
public double getMaxX(){
  return _max[0];
}","/** 
 * @return
 */
public double getMaxX(){
  return _max[0];
}",0.992248062015504
30025,"/** 
 * @return 
 */
public int[][] getFaces(){
  final int[][] faces=new int[6][];
  faces[0]=new int[]{4,5,7,6};
  faces[1]=new int[]{0,2,3,1};
  faces[2]=new int[]{0,1,5,4};
  faces[3]=new int[]{3,2,6,7};
  faces[4]=new int[]{0,4,6,2};
  faces[5]=new int[]{1,3,7,5};
  return faces;
}","/** 
 * @return
 */
public int[][] getFaces(){
  final int[][] faces=new int[6][];
  faces[0]=new int[]{4,5,7,6};
  faces[1]=new int[]{0,2,3,1};
  faces[2]=new int[]{0,1,5,4};
  faces[3]=new int[]{3,2,6,7};
  faces[4]=new int[]{0,4,6,2};
  faces[5]=new int[]{1,3,7,5};
  return faces;
}",0.9982547993019196
30026,"/** 
 * @return 
 */
public double getMaxY(){
  return _max[1];
}","/** 
 * @return
 */
public double getMaxY(){
  return _max[1];
}",0.992248062015504
30027,"/** 
 * @param aabb 
 * @return 
 */
public WB_AABB union(final WB_AABB aabb){
  final double[] newmin=new double[3];
  final double[] newmax=new double[3];
  for (int i=0; i < 3; i++) {
    newmin[i]=Math.min(_min[i],aabb._min[i]);
    newmax[i]=Math.max(_max[i],aabb._max[i]);
  }
  return new WB_AABB(newmin,newmax);
}","/** 
 * @param aabb
 * @return
 */
public WB_AABB union(final WB_AABB aabb){
  final double[] newmin=new double[3];
  final double[] newmax=new double[3];
  for (int i=0; i < 3; i++) {
    newmin[i]=Math.min(_min[i],aabb._min[i]);
    newmax[i]=Math.max(_max[i],aabb._max[i]);
  }
  return new WB_AABB(newmin,newmax);
}",0.996875
30028,"/** 
 * @return 
 */
public double getMaxZ(){
  return _max[2];
}","/** 
 * @return
 */
public double getMaxZ(){
  return _max[2];
}",0.992248062015504
30029,"/** 
 * @return 
 */
public int numberOfSegments(){
  if (isNull()) {
    return 0;
  }
  return 12;
}","/** 
 * @return
 */
public int numberOfSegments(){
  if (isNull()) {
    return 0;
  }
  return 12;
}",0.9950738916256158
30030,"/** 
 * @param i 
 * @return 
 */
public double getSize(final int i){
  if (isNull()) {
    return 0;
  }
  return _max[i] - _min[i];
}","/** 
 * @param i
 * @return
 */
public double getSize(final int i){
  if (isNull()) {
    return 0;
  }
  return _max[i] - _min[i];
}",0.9925373134328358
30031,"/** 
 * @return 
 */
public int minOrdinate(){
  if (isNull()) {
    return 0;
  }
  double res=Double.POSITIVE_INFINITY;
  int ord=0;
  for (int i=0; i < 3; i++) {
    final double w=getSize(i);
    if (res > w) {
      res=w;
      ord=i;
    }
  }
  return ord;
}","/** 
 * @return
 */
public int minOrdinate(){
  if (isNull()) {
    return 0;
  }
  double res=Double.POSITIVE_INFINITY;
  int ord=0;
  for (int i=0; i < 3; i++) {
    final double w=getSize(i);
    if (res > w) {
      res=w;
      ord=i;
    }
  }
  return ord;
}",0.9981167608286252
30032,"/** 
 * @param tuple 
 * @return 
 */
public double getDistanceSquare(final WB_Coordinate tuple){
  double dx=0;
  double sqr=0;
  for (int i=0; i < 3; i++) {
    if (_max[i] < tuple.getd(i)) {
      sqr+=(dx=tuple.getd(i) - _max[i]) * dx;
    }
 else     if (_min[i] > tuple.getd(i)) {
      sqr+=(dx=_min[i] - tuple.getd(i)) * dx;
    }
  }
  return sqr;
}","/** 
 * @param tuple
 * @return
 */
public double getDistanceSquare(final WB_Coordinate tuple){
  double dx=0;
  double sqr=0;
  for (int i=0; i < 3; i++) {
    if (_max[i] < tuple.getd(i)) {
      sqr+=(dx=tuple.getd(i) - _max[i]) * dx;
    }
 else     if (_min[i] > tuple.getd(i)) {
      sqr+=(dx=_min[i] - tuple.getd(i)) * dx;
    }
  }
  return sqr;
}",0.9971988795518208
30033,"/** 
 * @return 
 */
public int numberOfFaces(){
  if (isNull()) {
    return 0;
  }
  return 6;
}","/** 
 * @return
 */
public int numberOfFaces(){
  if (isNull()) {
    return 0;
  }
  return 6;
}",0.9948717948717948
30034,"/** 
 * @param other 
 * @return 
 */
public boolean equals(final WB_AABB other){
  if (isNull()) {
    return other.isNull();
  }
  for (int i=0; i < 3; i++) {
    if (other._max[i] != _max[i]) {
      return false;
    }
    if (other._min[i] != _min[i]) {
      return false;
    }
  }
  return true;
}","/** 
 * @param other
 * @return
 */
public boolean equals(final WB_AABB other){
  if (isNull()) {
    return other.isNull();
  }
  for (int i=0; i < 3; i++) {
    if (other._max[i] != _max[i]) {
      return false;
    }
    if (other._min[i] != _min[i]) {
      return false;
    }
  }
  return true;
}",0.9967105263157896
30035,"/** 
 * @return 
 */
public boolean isNull(){
  return _max[0] < _min[0];
}","/** 
 * @return
 */
public boolean isNull(){
  return _max[0] < _min[0];
}",0.9932885906040269
30036,"/** 
 * @return 
 */
public int maxOrdinate(){
  if (isNull()) {
    return 0;
  }
  double res=Double.NEGATIVE_INFINITY;
  int ord=0;
  for (int i=0; i < 3; i++) {
    final double w=getSize(i);
    if (res < w) {
      res=w;
      ord=i;
    }
  }
  return ord;
}","/** 
 * @return
 */
public int maxOrdinate(){
  if (isNull()) {
    return 0;
  }
  double res=Double.NEGATIVE_INFINITY;
  int ord=0;
  for (int i=0; i < 3; i++) {
    final double w=getSize(i);
    if (res < w) {
      res=w;
      ord=i;
    }
  }
  return ord;
}",0.9981167608286252
30037,"/** 
 * @param dx 
 * @param dy 
 * @param dz 
 */
public void expandBy(final double dx,final double dy,final double dz){
  if (isNull()) {
    return;
  }
  _min[0]-=dx;
  _max[0]+=dx;
  if (_min[0] > _max[0]) {
    setToNull();
    return;
  }
  _min[1]-=dy;
  _max[1]+=dy;
  if (_min[1] > _max[1]) {
    setToNull();
    return;
  }
  _min[2]-=dz;
  _max[2]+=dz;
  if (_min[2] > _max[2]) {
    setToNull();
    return;
  }
}","/** 
 * @param dx
 * @param dy
 * @param dz
 */
public void expandBy(final double dx,final double dy,final double dz){
  if (isNull()) {
    return;
  }
  _min[0]-=dx;
  _max[0]+=dx;
  if (_min[0] > _max[0]) {
    setToNull();
    return;
  }
  _min[1]-=dy;
  _max[1]+=dy;
  if (_min[1] > _max[1]) {
    setToNull();
    return;
  }
  _min[2]-=dz;
  _max[2]+=dz;
  if (_min[2] > _max[2]) {
    setToNull();
    return;
  }
}",0.9964747356051704
30038,"/** 
 * @param i 
 * @return 
 */
public double[] getCoord(final int i){
  final double[] values=new double[3];
  int disc=1;
  for (int j=0; j < 3; j++) {
    if (((i / disc) % 2) == 0) {
      values[j]=_min[j];
    }
 else {
      values[j]=_max[j];
    }
    disc*=2;
  }
  return (values);
}","/** 
 * @param i
 * @return
 */
public double[] getCoord(final int i){
  final double[] values=new double[3];
  int disc=1;
  for (int j=0; j < 3; j++) {
    if (((i / disc) % 2) == 0) {
      values[j]=_min[j];
    }
 else {
      values[j]=_max[j];
    }
    disc*=2;
  }
  return (values);
}",0.9966101694915256
30039,"/** 
 * @return 
 */
public double getArea(){
  return getWidth() * getHeight() * getDepth();
}","/** 
 * @return
 */
public double getArea(){
  return getWidth() * getHeight() * getDepth();
}",0.9947089947089948
30040,"/** 
 * @param s 
 * @param e 
 */
TriangulateRunner(final int s,final int e){
  start=s;
  end=e;
}","/** 
 * @param s
 * @param e
 */
TriangulateRunner(final int s,final int e){
  start=s;
  end=e;
}",0.98989898989899
30041,"/** 
 * @return 
 */
public double Kmin(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return Kmin;
}","/** 
 * @return
 */
public double Kmin(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return Kmin;
}",0.9956331877729258
30042,"/** 
 * @return 
 */
public double k1max(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k1max;
}","/** 
 * @return
 */
public double k1max(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k1max;
}",0.9957081545064378
30043,"/** 
 * @param i 
 * @return 
 */
public int[] vfNeighbors(final int i){
  if (!vfNeighborsUpdated) {
    updatevfNeighbors();
  }
  return vfNeighbors[i];
}","/** 
 * @param i
 * @return
 */
public int[] vfNeighbors(final int i){
  if (!vfNeighborsUpdated) {
    updatevfNeighbors();
  }
  return vfNeighbors[i];
}",0.9935897435897436
30044,"/** 
 * @return 
 */
public double k1min(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k1min;
}","/** 
 * @return
 */
public double k1min(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k1min;
}",0.9957081545064378
30045,"/** 
 * @return 
 */
public double Kmax(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return Kmax;
}","/** 
 * @return
 */
public double Kmax(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return Kmax;
}",0.9956331877729258
30046,"/** 
 * @param id 
 * @return 
 */
public WB_Polygon getPolygon(final int id){
  return geometryfactory.createSimplePolygon(vertices.getSubSequence(faces[id]));
}","/** 
 * @param id
 * @return
 */
public WB_Polygon getPolygon(final int id){
  return geometryfactory.createSimplePolygon(vertices.getSubSequence(faces[id]));
}",0.9937888198757764
30047,"/** 
 * @return 
 */
public WB_FaceListMesh triangulate(){
  return triangulateST();
}","/** 
 * @return
 */
public WB_FaceListMesh triangulate(){
  return triangulateST();
}",0.9941520467836256
30048,"/** 
 * @return 
 */
public double k2max(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k2max;
}","/** 
 * @return
 */
public double k2max(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k2max;
}",0.9957081545064378
30049,"/** 
 * @return 
 */
private WB_FaceListMesh triangulateST(){
  tris=new FastTable<int[]>();
  int[] face;
  int[][] triangles;
  int id=0;
  for (  final int[] face2 : faces) {
    face=face2;
    if (face.length == 3) {
      addTriangle(face);
    }
 else {
      triangles=WB_Triangulate.getPolygonTriangulation2D(face,vertices,true,geometryfactory.createEmbeddedPlane(getPlane(id))).getTriangles();
      for (      final int[] triangle : triangles) {
        addTriangle(triangle);
      }
    }
    id++;
  }
  faces=new int[tris.size()][3];
  int i=0;
  for (  final int[] tri : tris) {
    faces[i++]=tri;
  }
  return this;
}","/** 
 * @return
 */
private WB_FaceListMesh triangulateST(){
  tris=new FastTable<int[]>();
  int[] face;
  int[][] triangles;
  int id=0;
  for (  final int[] face2 : faces) {
    face=face2;
    if (face.length == 3) {
      addTriangle(face);
    }
 else {
      triangles=new WB_Triangulate().getPolygonTriangulation2D(face,vertices,true,geometryfactory.createEmbeddedPlane(getPlane(id))).getTriangles();
      for (      final int[] triangle : triangles) {
        addTriangle(triangle);
      }
    }
    id++;
  }
  faces=new int[tris.size()][3];
  int i=0;
  for (  final int[] tri : tris) {
    faces[i++]=tri;
  }
  return this;
}",0.9945098039215686
30050,"/** 
 * @param i 
 * @return 
 */
public double k1(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return curv1[i];
}","/** 
 * @param i
 * @return
 */
public double k1(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return curv1[i];
}",0.9928571428571428
30051,"/** 
 * @param i 
 * @return 
 */
public double k2(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return curv2[i];
}","/** 
 * @param i
 * @return
 */
public double k2(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return curv2[i];
}",0.9928571428571428
30052,"/** 
 * @param i 
 * @return 
 */
public int[] getFace(final int i){
  return faces[i];
}","/** 
 * @param i
 * @return
 */
public int[] getFace(final int i){
  return faces[i];
}",0.9886363636363636
30053,"/** 
 * @param points 
 * @param faces 
 */
protected WB_FaceListMesh(final double[] points,final int[][] faces){
  vertices=geometryfactory.createPointSequence(points);
  this.faces=new int[faces.length][];
  int i=0;
  for (  final int[] face : faces) {
    this.faces[i]=new int[face.length];
    for (int j=0; j < face.length; j++) {
      this.faces[i][j]=face[j];
    }
    i++;
  }
}","/** 
 * @param points
 * @param faces
 */
protected WB_FaceListMesh(final double[] points,final int[][] faces){
  vertices=geometryfactory.createPointSequence(points);
  this.faces=new int[faces.length][];
  int i=0;
  for (  final int[] face : faces) {
    this.faces[i]=new int[face.length];
    for (int j=0; j < face.length; j++) {
      this.faces[i][j]=face[j];
    }
    i++;
  }
}",0.9974293059125964
30054,"/** 
 * @param s 
 * @param e 
 */
FaceNormalRunner(final int s,final int e){
  start=s;
  end=e;
}","/** 
 * @param s
 * @param e
 */
FaceNormalRunner(final int s,final int e){
  start=s;
  end=e;
}",0.9897959183673468
30055,"/** 
 * @return 
 */
public double k2min(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k2min;
}","/** 
 * @return
 */
public double k2min(){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return k2min;
}",0.9957081545064378
30056,"/** 
 * @return 
 */
public List<WB_Polygon> getPolygons(){
  final List<WB_Polygon> polygons=new FastTable<WB_Polygon>();
  for (int i=0; i < faces.length; i++) {
    polygons.add(getPolygon(i));
  }
  return polygons;
}","/** 
 * @return
 */
public List<WB_Polygon> getPolygons(){
  final List<WB_Polygon> polygons=new FastTable<WB_Polygon>();
  for (int i=0; i < faces.length; i++) {
    polygons.add(getPolygon(i));
  }
  return polygons;
}",0.9977324263038548
30057,"/** 
 * @param i 
 * @return 
 */
public double DCurvInvariant(final int i){
  if (!DCurvaturesUpdated) {
    updateDCurvatures();
  }
  return (dcurv[i][0] * dcurv[i][0]) + (dcurv[i][1] * dcurv[i][1]) + (dcurv[i][2] * dcurv[i][2])+ (dcurv[i][3] * dcurv[i][3]);
}","/** 
 * @param i
 * @return
 */
public double DCurvInvariant(final int i){
  if (!DCurvaturesUpdated) {
    updateDCurvatures();
  }
  return (dcurv[i][0] * dcurv[i][0]) + (dcurv[i][1] * dcurv[i][1]) + (dcurv[i][2] * dcurv[i][2])+ (dcurv[i][3] * dcurv[i][3]);
}",0.9961832061068704
30058,"/** 
 * @param i 
 * @return 
 */
public double[] DCurv(final int i){
  if (!DCurvaturesUpdated) {
    updateDCurvatures();
  }
  return dcurv[i];
}","/** 
 * @param i
 * @return
 */
public double[] DCurv(final int i){
  if (!DCurvaturesUpdated) {
    updateDCurvatures();
  }
  return dcurv[i];
}",0.9931972789115646
30059,"/** 
 * @param i 
 * @return 
 */
public double K(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return curv2[i] * curv1[i];
}","/** 
 * @param i
 * @return
 */
public double K(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return curv2[i] * curv1[i];
}",0.9933333333333332
30060,"/** 
 * @return 
 */
public WB_FaceListMesh get(){
  return new WB_FaceListMesh(this);
}","/** 
 * @return
 */
public WB_FaceListMesh get(){
  return new WB_FaceListMesh(this);
}",0.9942857142857144
30061,"/** 
 * @return 
 */
public List<WB_Plane> getPlanes(){
  return getPlanes(0);
}","/** 
 * @return
 */
public List<WB_Plane> getPlanes(){
  return getPlanes(0);
}",0.9937106918238994
30062,"/** 
 * @param id 
 * @return 
 */
public WB_Plane getPlane(final int id){
  return getPlane(id,0);
}","/** 
 * @param id
 * @return
 */
public WB_Plane getPlane(final int id){
  return getPlane(id,0);
}",0.99
30063,"/** 
 * @param i 
 * @return 
 */
public WB_Vector k1dir(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return pdir1[i];
}","/** 
 * @param i
 * @return
 */
public WB_Vector k1dir(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return pdir1[i];
}",0.9931506849315068
30064,"/** 
 * @param AABB 
 * @return 
 */
public WB_FaceListMesh isoFitInAABB(final WB_AABB AABB){
  final WB_AABB self=getAABB();
  final double scx=self.getCenterX();
  final double acx=AABB.getCenterX();
  final double scy=self.getCenterY();
  final double acy=AABB.getCenterY();
  final double scz=self.getCenterZ();
  final double acz=AABB.getCenterZ();
  double f=Math.min(AABB.getWidth() / self.getWidth(),AABB.getHeight() / self.getHeight());
  f=Math.min(f,AABB.getDepth() / self.getDepth());
  final List<WB_SequencePoint> rescaled=new FastTable<WB_SequencePoint>();
  for (int i=0; i < vertices.size(); i++) {
    final WB_SequencePoint p=vertices.getPoint(i);
    p.addSelf(-scx,-scy,-scz);
    p.mulSelf(f);
    p.addSelf(acx,acy,acz);
    rescaled.add(p);
  }
  return geometryfactory.createMesh(rescaled,faces);
}","/** 
 * @param AABB
 * @return
 */
public WB_FaceListMesh isoFitInAABB(final WB_AABB AABB){
  final WB_AABB self=getAABB();
  final double scx=self.getCenterX();
  final double acx=AABB.getCenterX();
  final double scy=self.getCenterY();
  final double acy=AABB.getCenterY();
  final double scz=self.getCenterZ();
  final double acz=AABB.getCenterZ();
  double f=Math.min(AABB.getWidth() / self.getWidth(),AABB.getHeight() / self.getHeight());
  f=Math.min(f,AABB.getDepth() / self.getDepth());
  final List<WB_SequencePoint> rescaled=new FastTable<WB_SequencePoint>();
  for (int i=0; i < vertices.size(); i++) {
    final WB_SequencePoint p=vertices.getPoint(i);
    p.addSelf(-scx,-scy,-scz);
    p.mulSelf(f);
    p.addSelf(acx,acy,acz);
    rescaled.add(p);
  }
  return geometryfactory.createMesh(rescaled,faces);
}",0.9987834549878344
30065,"/** 
 * @param tri 
 */
synchronized void addTriangle(final int[] tri){
  tris.add(tri);
}","/** 
 * @param tri
 */
synchronized void addTriangle(final int[] tri){
  tris.add(tri);
}",0.994413407821229
30066,"/** 
 * @param i 
 * @return 
 */
public WB_Vector k2dir(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return pdir2[i];
}","/** 
 * @param i
 * @return
 */
public WB_Vector k2dir(final int i){
  if (!curvaturesUpdated) {
    updateCurvatures();
  }
  return pdir2[i];
}",0.9931506849315068
30067,"/** 
 * @return 
 */
@SuppressWarnings(""String_Node_Str"") private WB_FaceListMesh triangulateMT(){
  tris=Collections.synchronizedList(new FastTable<int[]>());
  final int threadCount=Runtime.getRuntime().availableProcessors();
  final int dfaces=faces.length / threadCount;
  final ExecutorService executor=Executors.newFixedThreadPool(threadCount);
  int i=0;
  for (i=0; i < (threadCount - 1); i++) {
    final Runnable runner=new TriangulateRunner(dfaces * i,(dfaces * (i + 1)) - 1);
    executor.submit(runner);
  }
  final Runnable runner=new TriangulateRunner(dfaces * i,faces.length - 1);
  executor.submit(runner);
  executor.shutdown();
  try {
    executor.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  final InterruptedException e) {
    e.printStackTrace();
  }
  faces=new int[tris.size()][3];
  i=0;
  for (  final int[] tri : tris) {
    faces[i++]=tri;
  }
  return this;
}","/** 
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private WB_FaceListMesh triangulateMT(){
  tris=Collections.synchronizedList(new FastTable<int[]>());
  final int threadCount=Runtime.getRuntime().availableProcessors();
  final int dfaces=faces.length / threadCount;
  final ExecutorService executor=Executors.newFixedThreadPool(threadCount);
  int i=0;
  for (i=0; i < (threadCount - 1); i++) {
    final Runnable runner=new TriangulateRunner(dfaces * i,(dfaces * (i + 1)) - 1);
    executor.submit(runner);
  }
  final Runnable runner=new TriangulateRunner(dfaces * i,faces.length - 1);
  executor.submit(runner);
  executor.shutdown();
  try {
    executor.awaitTermination(Long.MAX_VALUE,TimeUnit.NANOSECONDS);
  }
 catch (  final InterruptedException e) {
    e.printStackTrace();
  }
  faces=new int[tris.size()][3];
  i=0;
  for (  final int[] tri : tris) {
    faces[i++]=tri;
  }
  return this;
}",0.9994520547945206
30068,"/** 
 * @param optimize
 * @return
 */
public int[][] getTriangles(final boolean optimize){
  if (triangles == null) {
    if (numberOfShellPoints < 3) {
      return new int[][]{{0,0,0}};
    }
 else     if ((numberOfShellPoints == 3) && (numberOfContours == 1)) {
      return new int[][]{{0,1,2}};
    }
 else     if ((numberOfShellPoints == 4) && (numberOfContours == 1)) {
      return WB_Triangulate.triangulateQuad(points.getPoint(0),points.getPoint(1),points.getPoint(2),points.getPoint(3));
    }
 else {
      final WB_Triangulation2D triangulation=WB_Triangulate.getPolygonTriangulation2D(this,optimize);
      triangles=triangulation.getTriangles();
    }
  }
  return triangles;
}","/** 
 * @param optimize
 * @return
 */
public int[][] getTriangles(final boolean optimize){
  if (triangles == null) {
    if (numberOfShellPoints < 3) {
      return new int[][]{{0,0,0}};
    }
 else     if ((numberOfShellPoints == 3) && (numberOfContours == 1)) {
      return new int[][]{{0,1,2}};
    }
 else     if ((numberOfShellPoints == 4) && (numberOfContours == 1)) {
      return WB_Triangulate.triangulateQuad(points.getPoint(0),points.getPoint(1),points.getPoint(2),points.getPoint(3));
    }
 else {
      final WB_Triangulation2D triangulation=new WB_Triangulate().getPolygonTriangulation2D(this,optimize);
      triangles=triangulation.getTriangles();
    }
  }
  return triangles;
}",0.9956896551724138
30069,"/** 
 * @return 
 */
public HE_Mesh createWithQuickHull(){
  if (points == null) {
    return new HE_Mesh();
  }
  if (numberOfPoints == 0) {
    numberOfPoints=points.length;
  }
  final WB_QuickHull3D hull=new WB_QuickHull3D(points);
  final int[][] faceIndices=hull.getFaces();
  final int[] originalindices=hull.getVertexPointIndices();
  final HEC_FromFacelist ffl=new HEC_FromFacelist().setVertices(hull.getVertices()).setFaces(faceIndices).setDuplicate(false).setCheckNormals(false);
  final HE_Mesh result=ffl.createBase();
  vertexToPointIndex=new FastMap<Long,Integer>();
  final Iterator<HE_Vertex> vItr=result.vItr();
  int i=0;
  while (vItr.hasNext()) {
    vertexToPointIndex.put(vItr.next().key(),originalindices[i++]);
  }
  result.cleanUnusedElementsByFace();
  return result;
}","/** 
 * @return
 */
public HE_Mesh createWithQuickHull(){
  if (points == null) {
    return new HE_Mesh();
  }
  if (numberOfPoints == 0) {
    numberOfPoints=points.length;
  }
  final WB_QuickHull3D hull=new WB_QuickHull3D(points);
  final int[][] faceIndices=hull.getFaces();
  final int[] originalindices=hull.getVertexPointIndices();
  final HEC_FromFacelist ffl=new HEC_FromFacelist().setVertices(hull.getVertices()).setFaces(faceIndices).setDuplicate(false).setCheckNormals(false);
  final HE_Mesh result=ffl.createBase();
  vertexToPointIndex=new FastMap<Long,Integer>();
  final Iterator<HE_Vertex> vItr=result.vItr();
  int i=0;
  while (vItr.hasNext()) {
    vertexToPointIndex.put(vItr.next().key(),originalindices[i++]);
  }
  result.cleanUnusedElementsByFace();
  return result;
}",0.9993714644877436
30070,"/** 
 * Grow the tracers.
 * @param tracers the tracers
 * @param index the index
 */
private void grow(final WB_Point[] tracers,final int index){
  final WB_KDTree<WB_Point,Integer> kdtree=new WB_KDTree<WB_Point,Integer>();
  for (int i=0; i < numberOfPoints; i++) {
    kdtree.add(points[i],i);
  }
  final WB_Point c=new WB_Point(points[index]);
  WB_Point p;
  WB_Vector r;
  double d2self=0;
  for (int i=0; i < numTracers; i++) {
    p=tracers[i];
    r=dir[i];
    d2self=0;
    double stepSize=traceStep;
    int j=index;
    while (stepSize > WB_Epsilon.EPSILON) {
      while ((j == index) && (d2self < (cutoff * cutoff))) {
        p.addSelf(stepSize * r.xd(),stepSize * r.yd(),stepSize * r.zd());
        d2self=WB_GeometryOp.getSqDistance3D(p,c);
        final WB_KDEntry<WB_Point,Integer>[] closest=kdtree.getNearestNeighbors(p,2);
        j=closest[1].value;
      }
      if (j != index) {
        p.subSelf(stepSize * r.xd(),stepSize * r.yd(),stepSize * r.zd());
        d2self=0;
        stepSize/=2;
      }
 else {
        p.set(c.xd() + (cutoff * r.xd()),c.yd() + (cutoff * r.yd()),c.zd() + (cutoff * r.zd()));
        stepSize=-1;
      }
    }
  }
}","/** 
 * Grow the tracers.
 * @param tracers the tracers
 * @param index the index
 */
private void grow(final WB_Point[] tracers,final int index){
  final WB_KDTree<WB_Point,Integer> kdtree=new WB_KDTree<WB_Point,Integer>();
  for (int i=0; i < numberOfPoints; i++) {
    kdtree.add(points[i],i);
  }
  final WB_Point c=new WB_Point(points[index]);
  WB_Point p;
  WB_Vector r;
  double d2self=0;
  for (int i=0; i < numTracers; i++) {
    p=tracers[i];
    r=dir[i];
    d2self=0;
    double stepSize=traceStep;
    int j=index;
    while (stepSize > WB_Epsilon.EPSILON) {
      while ((j == index) && (d2self < (cutoff * cutoff))) {
        p.addSelf(stepSize * r.xd(),stepSize * r.yd(),stepSize * r.zd());
        d2self=WB_GeometryOp.getSqDistance3D(p,c);
        final WB_KDEntry<WB_Point,Integer>[] closest=kdtree.getNearestNeighbors(p,1);
        j=closest[0].value;
      }
      if (j != index) {
        p.subSelf(stepSize * r.xd(),stepSize * r.yd(),stepSize * r.zd());
        d2self=0;
        stepSize/=2;
      }
 else {
        p.set(c.xd() + (cutoff * r.xd()),c.yd() + (cutoff * r.yd()),c.zd() + (cutoff * r.zd()));
        stepSize=-1;
      }
    }
  }
}",0.9982935153583616
30071,"@Override public HE_Mesh apply(final HE_Selection selection){
  selection.parent.triangulate(selection);
  final List<HE_Halfedge> edges=selection.getInnerEdges();
  HE_Vertex a, b, c, d;
  int devpre, devpost;
  for (  final HE_Halfedge e : edges) {
    if (!e.isBoundary() && (e.getEdgeDihedralAngle() > threshold)) {
      a=e.getVertex();
      b=e.getPair().getVertex();
      c=e.getNextInFace().getEndVertex();
      d=e.getPair().getNextInFace().getEndVertex();
      devpre=Math.abs(((a.isBoundary()) ? 4 : 6) - a.getVertexOrder());
      devpre+=Math.abs(((b.isBoundary()) ? 4 : 6) - b.getVertexOrder());
      devpre+=Math.abs(((c.isBoundary()) ? 4 : 6) - c.getVertexOrder());
      devpre+=Math.abs(((d.isBoundary()) ? 4 : 6) - d.getVertexOrder());
      if (selection.parent.flipEdge(e)) {
        devpost=Math.abs(((a.isBoundary()) ? 4 : 6) - a.getVertexOrder());
        devpost+=Math.abs(((b.isBoundary()) ? 4 : 6) - b.getVertexOrder());
        devpost+=Math.abs(((b.isBoundary()) ? 4 : 6) - c.getVertexOrder());
        devpost+=Math.abs(((b.isBoundary()) ? 4 : 6) - d.getVertexOrder());
        if (devpre <= devpost) {
          selection.parent.flipEdge(e);
        }
      }
    }
  }
  return selection.parent;
}","@Override public HE_Mesh apply(final HE_Selection selection){
  selection.parent.triangulate(selection);
  final List<HE_Halfedge> edges=selection.getInnerEdges();
  HE_Vertex a, b, c, d;
  int devpre, devpost;
  for (int r=0; r < 2; r++) {
    for (    final HE_Halfedge e : edges) {
      if (!e.isBoundary() && (e.getEdgeDihedralAngle() > threshold)) {
        a=e.getVertex();
        b=e.getPair().getVertex();
        c=e.getNextInFace().getEndVertex();
        d=e.getPair().getNextInFace().getEndVertex();
        devpre=Math.abs(((a.isBoundary()) ? 4 : 6) - a.getVertexOrder());
        devpre+=Math.abs(((b.isBoundary()) ? 4 : 6) - b.getVertexOrder());
        devpre+=Math.abs(((c.isBoundary()) ? 4 : 6) - c.getVertexOrder());
        devpre+=Math.abs(((d.isBoundary()) ? 4 : 6) - d.getVertexOrder());
        if (selection.parent.flipEdge(e)) {
          devpost=Math.abs(((a.isBoundary()) ? 4 : 6) - a.getVertexOrder());
          devpost+=Math.abs(((b.isBoundary()) ? 4 : 6) - b.getVertexOrder());
          devpost+=Math.abs(((b.isBoundary()) ? 4 : 6) - c.getVertexOrder());
          devpost+=Math.abs(((b.isBoundary()) ? 4 : 6) - d.getVertexOrder());
          if (devpre <= devpost) {
            selection.parent.flipEdge(e);
          }
        }
      }
    }
  }
  return selection.parent;
}",0.9693877551020408
30072,"@Override public HE_Mesh apply(final HE_Selection selection){
  selection.parent.splitFacesQuad(selection);
  final List<WB_Point> newPositions=new ArrayList<WB_Point>();
  final List<HE_Vertex> boundary=selection.getBoundaryVertices();
  final List<HE_Vertex> inner=selection.getInnerVertices();
  final List<HE_Vertex> outer=selection.getOuterVertices();
  System.out.println(boundary.size() + ""String_Node_Str"" + inner.size()+ ""String_Node_Str""+ outer.size());
  List<HE_Face> sharedFaces;
  HE_Vertex v;
  Iterator<HE_Vertex> vItr=outer.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (boundary.contains(v)) {
      vItr.remove();
    }
  }
  HE_Vertex n;
  List<HE_Vertex> neighbors;
  int id=0;
  vItr=inner.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    final WB_Point p=new WB_Point(v);
    neighbors=v.getNeighborVertices();
    p.mulSelf(origWeight);
    double c=origWeight;
    for (int i=0; i < neighbors.size(); i++) {
      n=neighbors.get(i);
      p.addSelf(neigWeight * n.xd(),neigWeight * n.yd(),neigWeight * n.zd());
      c+=neigWeight;
    }
    newPositions.add(p.scaleSelf(1.0 / c));
    id++;
  }
  vItr=boundary.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (keepBoundary) {
      newPositions.add(v.getPoint());
    }
 else {
      final WB_Point p=new WB_Point(v);
      neighbors=v.getNeighborVertices();
      p.mulSelf(origWeight);
      double c=origWeight;
      int nc=0;
      for (int i=0; i < neighbors.size(); i++) {
        n=neighbors.get(i);
        if (boundary.contains(n)) {
          p.addSelf(neigWeight * n.xd(),neigWeight * n.yd(),neigWeight * n.zd());
          c+=neigWeight;
          nc++;
        }
      }
      newPositions.add((nc > 1) ? p.scaleSelf(1.0 / c) : v.getPoint());
    }
    id++;
  }
  vItr=outer.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    if ((keepEdges) || (v.getVertexType() != WB_Convex.FLAT)) {
      newPositions.add(v.getPoint());
    }
 else {
      final WB_Point p=new WB_Point(v);
      neighbors=v.getNeighborVertices();
      p.mulSelf(origWeight);
      double c=origWeight;
      int nc=0;
      for (int i=0; i < neighbors.size(); i++) {
        n=neighbors.get(i);
        if (outer.contains(n)) {
          sharedFaces=selection.parent.getSharedFaces(v,n);
          boolean singleFaceGap=true;
          for (int j=0; j < sharedFaces.size(); j++) {
            if (selection.contains(sharedFaces.get(j))) {
              singleFaceGap=false;
              break;
            }
          }
          if (!singleFaceGap) {
            p.addSelf(neigWeight * n.xd(),neigWeight * n.yd(),neigWeight * n.zd());
            c+=neigWeight;
            nc++;
          }
        }
      }
      newPositions.add((nc > 1) ? p.scaleSelf(1.0 / c) : v.getPoint());
    }
    id++;
  }
  vItr=inner.iterator();
  id=0;
  while (vItr.hasNext()) {
    vItr.next().set(newPositions.get(id));
    id++;
  }
  vItr=boundary.iterator();
  while (vItr.hasNext()) {
    vItr.next().set(newPositions.get(id));
    id++;
  }
  vItr=outer.iterator();
  while (vItr.hasNext()) {
    vItr.next().set(newPositions.get(id));
    id++;
  }
  return selection.parent;
}","@Override public HE_Mesh apply(final HE_Selection selection){
  selection.parent.splitFacesQuad(selection);
  final List<WB_Point> newPositions=new ArrayList<WB_Point>();
  final List<HE_Vertex> boundary=selection.getBoundaryVertices();
  final List<HE_Vertex> inner=selection.getInnerVertices();
  final List<HE_Vertex> outer=selection.getOuterVertices();
  List<HE_Face> sharedFaces;
  HE_Vertex v;
  Iterator<HE_Vertex> vItr=outer.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (boundary.contains(v)) {
      vItr.remove();
    }
  }
  HE_Vertex n;
  List<HE_Vertex> neighbors;
  int id=0;
  vItr=inner.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    final WB_Point p=new WB_Point(v);
    neighbors=v.getNeighborVertices();
    p.mulSelf(origWeight);
    double c=origWeight;
    for (int i=0; i < neighbors.size(); i++) {
      n=neighbors.get(i);
      p.addSelf(neigWeight * n.xd(),neigWeight * n.yd(),neigWeight * n.zd());
      c+=neigWeight;
    }
    newPositions.add(p.scaleSelf(1.0 / c));
    id++;
  }
  vItr=boundary.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    if (keepBoundary) {
      newPositions.add(v.getPoint());
    }
 else {
      final WB_Point p=new WB_Point(v);
      neighbors=v.getNeighborVertices();
      p.mulSelf(origWeight);
      double c=origWeight;
      int nc=0;
      for (int i=0; i < neighbors.size(); i++) {
        n=neighbors.get(i);
        if (boundary.contains(n)) {
          p.addSelf(neigWeight * n.xd(),neigWeight * n.yd(),neigWeight * n.zd());
          c+=neigWeight;
          nc++;
        }
      }
      newPositions.add((nc > 1) ? p.scaleSelf(1.0 / c) : v.getPoint());
    }
    id++;
  }
  vItr=outer.iterator();
  while (vItr.hasNext()) {
    v=vItr.next();
    if ((keepEdges) || (v.getVertexType() != WB_Convex.FLAT)) {
      newPositions.add(v.getPoint());
    }
 else {
      final WB_Point p=new WB_Point(v);
      neighbors=v.getNeighborVertices();
      p.mulSelf(origWeight);
      double c=origWeight;
      int nc=0;
      for (int i=0; i < neighbors.size(); i++) {
        n=neighbors.get(i);
        if (outer.contains(n)) {
          sharedFaces=selection.parent.getSharedFaces(v,n);
          boolean singleFaceGap=true;
          for (int j=0; j < sharedFaces.size(); j++) {
            if (selection.contains(sharedFaces.get(j))) {
              singleFaceGap=false;
              break;
            }
          }
          if (!singleFaceGap) {
            p.addSelf(neigWeight * n.xd(),neigWeight * n.yd(),neigWeight * n.zd());
            c+=neigWeight;
            nc++;
          }
        }
      }
      newPositions.add((nc > 1) ? p.scaleSelf(1.0 / c) : v.getPoint());
    }
    id++;
  }
  vItr=inner.iterator();
  id=0;
  while (vItr.hasNext()) {
    vItr.next().set(newPositions.get(id));
    id++;
  }
  vItr=boundary.iterator();
  while (vItr.hasNext()) {
    vItr.next().set(newPositions.get(id));
    id++;
  }
  vItr=outer.iterator();
  while (vItr.hasNext()) {
    vItr.next().set(newPositions.get(id));
    id++;
  }
  return selection.parent;
}",0.9829699188285852
30073,"public WB_Point p1(){
  return p1;
}","@Override public WB_Point p1(){
  return p1;
}",0.8780487804878049
30074,"public WB_Point p2(){
  return p2;
}","@Override public WB_Point p2(){
  return p2;
}",0.8780487804878049
30075,"public WB_Point p3(){
  return p3;
}","@Override public WB_Point p3(){
  return p3;
}",0.8780487804878049
30076,"/** 
 * Get plane of triangle.
 * @return WB_Plane
 */
public WB_Plane getPlane(){
  final WB_Plane P=new WB_Plane(p1,p2,p3);
  if (P.getNormal().getSqLength() < WB_Epsilon.SQEPSILON) {
    return null;
  }
  return P;
}","/** 
 * Get plane of triangle.
 * @return WB_Plane
 */
@Override public WB_Plane getPlane(){
  final WB_Plane P=new WB_Plane(p1,p2,p3);
  if (P.getNormal().getSqLength() < WB_Epsilon.SQEPSILON) {
    return null;
  }
  return P;
}",0.9777777777777776
30077,"/** 
 * Get orthocenter.
 * @return orthocenter
 */
public WB_Point getOrthocenter(){
  final double a2=a * a;
  final double b2=b * b;
  final double c2=c * c;
  return getPointFromBarycentric((a2 + b2 - c2) * (a2 - b2 + c2),(a2 + b2 - c2) * (-a2 + b2 + c2),(a2 - b2 + c2) * (-a2 + b2 + c2));
}","/** 
 * Get orthocenter.
 * @return orthocenter
 */
@Override public WB_Point getOrthocenter(){
  final double a2=a * a;
  final double b2=b * b;
  final double c2=c * c;
  return getPointFromBarycentric((a2 + b2 - c2) * (a2 - b2 + c2),(a2 + b2 - c2) * (-a2 + b2 + c2),(a2 - b2 + c2) * (-a2 + b2 + c2));
}",0.9833333333333332
30078,"/** 
 * Get centroid.
 * @return centroid
 */
public WB_Point getCentroid(){
  return getPointFromTrilinear(b * c,c * a,a * b);
}","/** 
 * Get centroid.
 * @return centroid
 */
@Override public WB_Point getCentroid(){
  return getPointFromTrilinear(b * c,c * a,a * b);
}",0.9626865671641792
30079,"/** 
 * Barycentric.
 * @param p the p
 * @return the w b_ point
 */
public WB_Point getBarycentric(final WB_Coordinate p){
  final WB_Vector m=p3.subToVector(p1).cross(p2.subToVector(p1));
  double nu, nv, ood;
  final double x=WB_Math.fastAbs(m.xd());
  final double y=WB_Math.fastAbs(m.yd());
  final double z=WB_Math.fastAbs(m.zd());
  if (x >= y && x >= z) {
    nu=WB_Triangle.twiceSignedTriArea2D(p.yd(),p.zd(),p2.yd(),p2.zd(),p3.yd(),p3.zd());
    nv=WB_Triangle.twiceSignedTriArea2D(p.yd(),p.zd(),p3.yd(),p3.zd(),p1.yd(),p1.zd());
    ood=1.0 / m.xd();
  }
 else   if (y >= x && y >= z) {
    nu=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.zd(),p2.xd(),p2.zd(),p3.xd(),p3.zd());
    nv=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.zd(),p3.xd(),p3.zd(),p1.xd(),p1.zd());
    ood=-1.0 / m.yd();
  }
 else {
    nu=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.yd(),p2.xd(),p2.yd(),p3.xd(),p3.yd());
    nv=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.yd(),p3.xd(),p3.yd(),p1.xd(),p1.yd());
    ood=-1.0 / m.zd();
  }
  nu*=ood;
  nv*=ood;
  return new WB_Point(nu,nv,1 - nu - nv);
}","/** 
 * Barycentric.
 * @param p the p
 * @return the w b_ point
 */
@Override public WB_Point getBarycentric(final WB_Coordinate p){
  final WB_Vector m=p3.subToVector(p1).cross(p2.subToVector(p1));
  double nu, nv, ood;
  final double x=WB_Math.fastAbs(m.xd());
  final double y=WB_Math.fastAbs(m.yd());
  final double z=WB_Math.fastAbs(m.zd());
  if (x >= y && x >= z) {
    nu=WB_Triangle.twiceSignedTriArea2D(p.yd(),p.zd(),p2.yd(),p2.zd(),p3.yd(),p3.zd());
    nv=WB_Triangle.twiceSignedTriArea2D(p.yd(),p.zd(),p3.yd(),p3.zd(),p1.yd(),p1.zd());
    ood=1.0 / m.xd();
  }
 else   if (y >= x && y >= z) {
    nu=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.zd(),p2.xd(),p2.zd(),p3.xd(),p3.zd());
    nv=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.zd(),p3.xd(),p3.zd(),p1.xd(),p1.zd());
    ood=-1.0 / m.yd();
  }
 else {
    nu=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.yd(),p2.xd(),p2.yd(),p3.xd(),p3.yd());
    nv=WB_Triangle.twiceSignedTriArea2D(p.xd(),p.yd(),p3.xd(),p3.yd(),p1.xd(),p1.yd());
    ood=-1.0 / m.zd();
  }
  nu*=ood;
  nv*=ood;
  return new WB_Point(nu,nv,1 - nu - nv);
}",0.9953789279112756
30080,"/** 
 * Get point from barycentric coordinates.
 * @param x the x
 * @param y the y
 * @param z the z
 * @return point
 */
public WB_Point getPointFromBarycentric(final double x,final double y,final double z){
  return getPointFromTrilinear(x / a,y / b,z / c);
}","/** 
 * Get point from barycentric coordinates.
 * @param x the x
 * @param y the y
 * @param z the z
 * @return point
 */
@Override public WB_Point getPointFromBarycentric(final double x,final double y,final double z){
  return getPointFromTrilinear(x / a,y / b,z / c);
}",0.9812734082397004
30081,"/** 
 * Get point from trilinear coordinates.
 * @param x the x
 * @param y the y
 * @param z the z
 * @return point
 */
public WB_Point getPointFromTrilinear(final double x,final double y,final double z){
  final double abc=a * x + b * y + c * z;
  final WB_Point ea=p2.sub(p3);
  final WB_Point eb=p1.sub(p3);
  ea._mulSelf(b * y);
  eb._mulSelf(a * x);
  ea._addSelf(eb);
  ea._divSelf(abc);
  ea._addSelf(p3);
  return ea;
}","/** 
 * Get point from trilinear coordinates.
 * @param x the x
 * @param y the y
 * @param z the z
 * @return point
 */
@Override public WB_Point getPointFromTrilinear(final double x,final double y,final double z){
  final double abc=a * x + b * y + c * z;
  final WB_Point ea=p2.sub(p3);
  final WB_Point eb=p1.sub(p3);
  ea._mulSelf(b * y);
  eb._mulSelf(a * x);
  ea._addSelf(eb);
  ea._divSelf(abc);
  ea._addSelf(p3);
  return ea;
}",0.9884526558891455
30082,"/** 
 * Get circumcenter.
 * @return circumcenter
 */
public WB_Point getCircumcenter(){
  return getPointFromTrilinear(cosA,cosB,cosC);
}","/** 
 * Get circumcenter.
 * @return circumcenter
 */
@Override public WB_Point getCircumcenter(){
  return getPointFromTrilinear(cosA,cosB,cosC);
}",0.965034965034965
30083,"@Override protected HE_Mesh createBase(){
  if (path == null) {
    return null;
  }
  final StringBuilder contents=new StringBuilder();
  try {
    final BufferedReader input=new BufferedReader(new FileReader(path));
    try {
      String line=null;
      while ((line=input.readLine()) != null) {
        contents.append(line);
        contents.append(System.getProperty(""String_Node_Str""));
      }
    }
  finally {
      input.close();
    }
  }
 catch (  final IOException ex) {
    ex.printStackTrace();
  }
  final String data=contents.toString();
  final String[] result=data.split(System.getProperty(""String_Node_Str""));
  int id=0;
  String[] subresult=result[id].split(""String_Node_Str"");
  id++;
  final int numVertices=Integer.parseInt(subresult[0]);
  final int numHalfedges=Integer.parseInt(subresult[1]);
  final int numFaces=Integer.parseInt(subresult[3]);
  final HE_Mesh mesh=new HE_Mesh();
  final FastTable<HE_Vertex> vertices=new FastTable<HE_Vertex>();
  for (int i=0; i < numVertices; i++) {
    vertices.add(new HE_Vertex());
  }
  final FastTable<HE_Halfedge> halfedges=new FastTable<HE_Halfedge>();
  for (int i=0; i < numHalfedges; i++) {
    halfedges.add(new HE_Halfedge());
  }
  final FastTable<HE_Face> faces=new FastTable<HE_Face>();
  for (int i=0; i < numFaces; i++) {
    faces.add(new HE_Face());
  }
  double x, y, z;
  int heid, vid, henextid, hepairid, fid;
  HE_Vertex v;
  for (int i=0; i < numVertices; i++) {
    v=vertices.get(i);
    subresult=result[id].split(""String_Node_Str"");
    x=Double.parseDouble(subresult[0]);
    y=Double.parseDouble(subresult[1]);
    z=Double.parseDouble(subresult[2]);
    heid=Integer.parseInt(subresult[3]);
    v._set(x,y,z);
    if (heid > -1) {
      v.setHalfedge(halfedges.get(heid));
    }
    id++;
  }
  HE_Halfedge he;
  for (int i=0; i < numHalfedges; i++) {
    he=halfedges.get(i);
    subresult=result[id].split(""String_Node_Str"");
    vid=Integer.parseInt(subresult[0]);
    henextid=Integer.parseInt(subresult[1]);
    hepairid=Integer.parseInt(subresult[2]);
    fid=Integer.parseInt(subresult[4]);
    if (vid > -1) {
      he.setVertex(vertices.get(vid));
    }
    if (henextid > -1) {
      he.setNext(halfedges.get(henextid));
    }
    if (hepairid > -1) {
      he.setPair(halfedges.get(hepairid));
      halfedges.get(hepairid).setPair(he);
    }
    if (fid > -1) {
      he.setFace(faces.get(fid));
    }
    id++;
  }
  HE_Face f;
  for (int i=0; i < numFaces; i++) {
    f=faces.get(i);
    subresult=result[id].split(""String_Node_Str"");
    heid=Integer.parseInt(subresult[0]);
    if (heid > -1) {
      f.setHalfedge(halfedges.get(heid));
    }
    id++;
  }
  mesh.addVertices(vertices);
  mesh.addHalfedges(halfedges);
  mesh.addFaces(faces);
  return mesh;
}","@Override protected HE_Mesh createBase(){
  if (path == null) {
    return null;
  }
  final StringBuilder contents=new StringBuilder();
  try {
    final BufferedReader input=new BufferedReader(new FileReader(path));
    try {
      String line=null;
      while ((line=input.readLine()) != null) {
        contents.append(line);
        contents.append(System.getProperty(""String_Node_Str""));
      }
    }
  finally {
      input.close();
    }
  }
 catch (  final IOException ex) {
    ex.printStackTrace();
  }
  final String data=contents.toString();
  final String[] result=data.split(System.getProperty(""String_Node_Str""));
  int id=0;
  String[] subresult=result[id].split(""String_Node_Str"");
  id++;
  final int numVertices=Integer.parseInt(subresult[0]);
  final int numHalfedges=Integer.parseInt(subresult[1]);
  final int numFaces=Integer.parseInt(subresult[2]);
  final HE_Mesh mesh=new HE_Mesh();
  final FastTable<HE_Vertex> vertices=new FastTable<HE_Vertex>();
  for (int i=0; i < numVertices; i++) {
    vertices.add(new HE_Vertex());
  }
  final FastTable<HE_Halfedge> halfedges=new FastTable<HE_Halfedge>();
  for (int i=0; i < numHalfedges; i++) {
    halfedges.add(new HE_Halfedge());
  }
  final FastTable<HE_Face> faces=new FastTable<HE_Face>();
  for (int i=0; i < numFaces; i++) {
    faces.add(new HE_Face());
  }
  double x, y, z;
  int heid, vid, henextid, hepairid, fid;
  HE_Vertex v;
  for (int i=0; i < numVertices; i++) {
    v=vertices.get(i);
    subresult=result[id].split(""String_Node_Str"");
    x=Double.parseDouble(subresult[0]);
    y=Double.parseDouble(subresult[1]);
    z=Double.parseDouble(subresult[2]);
    heid=Integer.parseInt(subresult[3]);
    v._set(x,y,z);
    if (heid > -1) {
      v.setHalfedge(halfedges.get(heid));
    }
    id++;
  }
  HE_Halfedge he;
  for (int i=0; i < numHalfedges; i++) {
    he=halfedges.get(i);
    subresult=result[id].split(""String_Node_Str"");
    vid=Integer.parseInt(subresult[0]);
    henextid=Integer.parseInt(subresult[1]);
    hepairid=Integer.parseInt(subresult[2]);
    fid=Integer.parseInt(subresult[3]);
    if (vid > -1) {
      he.setVertex(vertices.get(vid));
    }
    if (henextid > -1) {
      he.setNext(halfedges.get(henextid));
    }
    if (hepairid > -1) {
      he.setPair(halfedges.get(hepairid));
      halfedges.get(hepairid).setPair(he);
    }
    if (fid > -1) {
      he.setFace(faces.get(fid));
    }
    id++;
  }
  HE_Face f;
  for (int i=0; i < numFaces; i++) {
    f=faces.get(i);
    subresult=result[id].split(""String_Node_Str"");
    heid=Integer.parseInt(subresult[0]);
    if (heid > -1) {
      f.setHalfedge(halfedges.get(heid));
    }
    id++;
  }
  mesh.addVertices(vertices);
  mesh.addHalfedges(halfedges);
  mesh.addFaces(faces);
  return mesh;
}",0.9992792792792792
30084,"private void buildPaths(final HE_Selection cutEdges){
  paths=new FastTable<HE_Path>();
  if (cutEdges.getNumberOfEdges() == 0) {
    return;
  }
  final List<HE_Halfedge> edges=new FastTable<HE_Halfedge>();
  for (  final HE_Halfedge he : cutEdges.getEdgesAsList()) {
    final HE_Face f=he.getFace();
    if (WB_Classify.classifyPointToPlane(P,f.getFaceCenter()) == WB_Classification.BACK) {
      edges.add(he.getPair());
    }
 else {
      edges.add(he);
    }
  }
  while (edges.size() > 0) {
    final List<HE_Halfedge> pathedges=new FastTable<HE_Halfedge>();
    HE_Halfedge current=edges.get(0);
    pathedges.add(current);
    boolean loop=false;
    for (int i=0; i < edges.size(); i++) {
      if (edges.get(i).getVertex() == current.getEndVertex()) {
        if (i > 0) {
          current=edges.get(i);
          pathedges.add(current);
          i=0;
        }
 else {
          loop=true;
          break;
        }
      }
    }
    paths.add(new HE_Path(pathedges,loop));
    edges.removeAll(pathedges);
  }
}","private void buildPaths(final HE_Selection cutEdges){
  paths=new FastTable<HE_Path>();
  if (cutEdges.getNumberOfEdges() == 0) {
    return;
  }
  final List<HE_Halfedge> edges=new FastTable<HE_Halfedge>();
  for (  final HE_Halfedge he : cutEdges.getEdgesAsList()) {
    final HE_Face f=he.getFace();
    if (WB_Classify.classifyPointToPlane(P,f.getFaceCenter()) == WB_Classification.BACK) {
      edges.add(he.getPair());
    }
 else {
      edges.add(he);
    }
  }
  while (edges.size() > 0) {
    final List<HE_Halfedge> pathedges=new FastTable<HE_Halfedge>();
    HE_Halfedge current=edges.get(0);
    pathedges.add(current);
    boolean loop=false;
    for (int i=0; i < edges.size(); i++) {
      if (edges.get(i).getVertex() == current.getEndVertex()) {
        if (i > 0) {
          current=edges.get(i);
          pathedges.add(current);
          i=0;
        }
 else {
          loop=true;
          break;
        }
      }
    }
    if (!loop) {
      final List<HE_Halfedge> reversepathedges=new FastTable<HE_Halfedge>();
      current=edges.get(0);
      for (int i=0; i < edges.size(); i++) {
        if (edges.get(i).getEndVertex() == current.getVertex()) {
          if (i > 0) {
            current=edges.get(i);
            reversepathedges.add(current);
            i=0;
          }
        }
      }
      final List<HE_Halfedge> finalpathedges=new FastTable<HE_Halfedge>();
      for (int i=reversepathedges.size() - 1; i > -1; i--) {
        finalpathedges.add(reversepathedges.get(i));
      }
      finalpathedges.addAll(pathedges);
      paths.add(new HE_Path(finalpathedges,loop));
      edges.removeAll(finalpathedges);
    }
 else {
      paths.add(new HE_Path(pathedges,loop));
      edges.removeAll(pathedges);
    }
  }
}",0.7289048473967684
30085,"@Override public String toString(){
  String string=""String_Node_Str"";
  int i=0;
  for (i=0; i < 3 - 1; i++) {
    string+=_min[0] + ""String_Node_Str"" + _max[0]+ ""String_Node_Str"";
  }
  string+=_min[i] + ""String_Node_Str"" + _max[i]+ ""String_Node_Str"";
  return string;
}","@Override public String toString(){
  String string=""String_Node_Str"";
  int i=0;
  for (i=0; i < 3 - 1; i++) {
    string+=_min[i] + ""String_Node_Str"" + _max[i]+ ""String_Node_Str"";
  }
  string+=_min[i] + ""String_Node_Str"" + _max[i]+ ""String_Node_Str"";
  return string;
}",0.9926470588235294
30086,"private void updateHeap(final List<HE_Vertex> vertices){
  double min;
  double c;
  HE_Halfedge minhe;
  List<HE_Halfedge> vstar;
  double vvi;
  for (  final HE_Vertex v : vertices) {
    vvi=visualImportance(v);
    v.setInternalLabel(counter);
    vertexCost.remove(v.key());
    vstar=v.getHalfedgeStar();
    minhe=vstar.get(0);
    min=Double.POSITIVE_INFINITY;
    if (v.isBoundary()) {
      for (int i=0; i < vstar.size(); i++) {
        if (vstar.get(i).isBoundary()) {
          c=halfedgeCollapseCost(vstar.get(i));
          if (c < min) {
            min=c;
            minhe=vstar.get(i);
          }
        }
      }
    }
 else {
      for (int i=0; i < vstar.size(); i++) {
        c=halfedgeCollapseCost(vstar.get(i));
        if (c < min) {
          min=c;
          minhe=vstar.get(i);
        }
      }
    }
    if (min != Double.POSITIVE_INFINITY) {
      vertexCost.put(v.key(),min * vvi);
      v.setHalfedge(minhe);
      heap.push(min * vvi,v);
    }
  }
}","private void updateHeap(final List<HE_Vertex> vertices,final HE_MeshStructure selection){
  double min;
  double c;
  HE_Halfedge minhe;
  List<HE_Halfedge> vstar;
  double vvi;
  for (  final HE_Vertex v : vertices) {
    if (selection == null || selection.contains(v)) {
      vvi=visualImportance(v);
      v.setInternalLabel(counter);
      vertexCost.remove(v.key());
      vstar=v.getHalfedgeStar();
      minhe=vstar.get(0);
      min=Double.POSITIVE_INFINITY;
      if (v.isBoundary()) {
        for (int i=0; i < vstar.size(); i++) {
          if (vstar.get(i).isBoundary()) {
            c=halfedgeCollapseCost(vstar.get(i));
            if (c < min) {
              min=c;
              minhe=vstar.get(i);
            }
          }
        }
      }
 else {
        for (int i=0; i < vstar.size(); i++) {
          c=halfedgeCollapseCost(vstar.get(i));
          if (c < min) {
            min=c;
            minhe=vstar.get(i);
          }
        }
      }
      if (min != Double.POSITIVE_INFINITY) {
        vertexCost.put(v.key(),min * vvi);
        v.setHalfedge(minhe);
        heap.push(min * vvi,v);
      }
    }
  }
}",0.914903620122238
30087,"@Override public HE_Mesh apply(final HE_Selection selection){
  return apply(selection.parent);
}","@Override public HE_Mesh apply(final HE_Selection selection){
  if (selection.parent.getNumberOfVertices() <= goal) {
    return selection.parent;
  }
  _mesh=selection.parent;
  _mesh.triangulate();
  _mesh.resetVertexInternalLabels();
  if (_mesh.getNumberOfVertices() <= 4) {
    return _mesh;
  }
  buildHeap(selection);
  HE_Vertex v;
  Entry entry;
  List<HE_Vertex> vertices;
  while (_mesh.getNumberOfVertices() > goal && heap.size() > 0 && _mesh.getNumberOfVertices() > 4) {
    boolean valid=false;
    do {
      entry=heap.pop();
      v=entry.v;
      valid=selection.contains(v) && (entry.version == v.getInternalLabel());
    }
 while (heap.size() > 0 && !valid);
    if (valid) {
      vertices=v.getNeighborVertices();
      if (_mesh.collapseHalfedge(v.getHalfedge())) {
        vertexCost.remove(v.key());
        selection.remove(v);
        counter++;
        updateHeap(vertices,selection);
      }
    }
  }
  return _mesh;
}",0.1263157894736842
30088,"/** 
 * Begin save.
 * @param fn the fn
 */
public static void beginSave(final String fn,final String name){
  try {
    objStream=new FileOutputStream(new File(fn,name + ""String_Node_Str""));
    mtlStream=new FileOutputStream(new File(fn,name + ""String_Node_Str""));
    handleBeginSave();
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Begin save.
 * @param fn the fn
 */
public static void beginSave(final String fn,final String name){
  try {
    objStream=createOutputStream(new File(fn,name + ""String_Node_Str""));
    mtlStream=createOutputStream(new File(fn,name + ""String_Node_Str""));
    handleBeginSave();
  }
 catch (  final Exception e) {
    e.printStackTrace();
  }
}",0.9660056657223796
30089,"public WB_CoordinateSystem setY(final double yx,final double yy,final double yz){
  final WB_Vector lY=new WB_Vector(yx,yy,yz);
  lY._normalizeSelf();
  final WB_Vector tmp=lY.cross(_Y);
  if (!WB_Epsilon.isZeroSq(tmp.getSqLength())) {
    rotate(-Math.acos(_Y.dot(lY)),tmp);
  }
 else   if (_Y.dot(lY) < -1 + WB_Epsilon.EPSILON) {
    flipY();
  }
  return this;
}","public WB_CoordinateSystem setY(final double yx,final double yy,final double yz){
  final WB_Vector lY=new WB_Vector(yx,yy,yz);
  lY._normalizeSelf();
  final WB_Vector tmp=lY.cross(_Y);
  if (!WB_Epsilon.isZeroSq(tmp.getSqLength())) {
    rotate(-Math.acos(WB_Math.clamp(_Y.dot(lY),-1,1)),tmp);
  }
 else   if (_Y.dot(lY) < -1 + WB_Epsilon.EPSILON) {
    flipY();
  }
  return this;
}",0.9493333333333334
30090,"public WB_CoordinateSystem setX(final double xx,final double xy,final double xz){
  final WB_Vector lX=new WB_Vector(xx,xy,xz);
  lX._normalizeSelf();
  final WB_Vector tmp=lX.cross(_X);
  if (!WB_Epsilon.isZeroSq(tmp.getSqLength())) {
    rotate(-Math.acos(_X.dot(lX)),tmp);
  }
 else   if (_X.dot(lX) < -1 + WB_Epsilon.EPSILON) {
    flipX();
  }
  return this;
}","public WB_CoordinateSystem setX(final double xx,final double xy,final double xz){
  final WB_Vector lX=new WB_Vector(xx,xy,xz);
  lX._normalizeSelf();
  final WB_Vector tmp=lX.cross(_X);
  if (!WB_Epsilon.isZeroSq(tmp.getSqLength())) {
    rotate(-Math.acos(WB_Math.clamp(_X.dot(lX),-1,1)),tmp);
  }
 else   if (_X.dot(lX) < -1 + WB_Epsilon.EPSILON) {
    flipX();
  }
  return this;
}",0.9493333333333334
30091,"public WB_CoordinateSystem setZ(final double zx,final double zy,final double zz){
  final WB_Vector lZ=new WB_Vector(zx,zy,zz);
  lZ._normalizeSelf();
  final WB_Vector tmp=lZ.cross(_Z);
  if (!WB_Epsilon.isZeroSq(tmp.getSqLength())) {
    rotate(-Math.acos(_Z.dot(lZ)),tmp);
  }
 else   if (_Z.dot(lZ) < -1 + WB_Epsilon.EPSILON) {
    flipZ();
  }
  return this;
}","public WB_CoordinateSystem setZ(final double zx,final double zy,final double zz){
  final WB_Vector lZ=new WB_Vector(zx,zy,zz);
  lZ._normalizeSelf();
  final WB_Vector tmp=lZ.cross(_Z);
  if (!WB_Epsilon.isZeroSq(tmp.getSqLength())) {
    rotate(-Math.acos(WB_Math.clamp(_Z.dot(lZ),-1,1)),tmp);
  }
 else   if (_Z.dot(lZ) < -1 + WB_Epsilon.EPSILON) {
    flipZ();
  }
  return this;
}",0.9493333333333334
30092,"protected void set(final WB_Coordinate origin,final WB_Coordinate x,final WB_Coordinate y,final WB_Coordinate z,WB_CoordinateSystem CS){
  _origin=new WB_Point(origin);
  _X=new WB_Vector(x);
  _Y=new WB_Vector(y);
  _Z=new WB_Vector(z);
  _parent=CS;
}","protected void set(final WB_Coordinate origin,final WB_Coordinate x,final WB_Coordinate y,final WB_Coordinate z,final WB_CoordinateSystem CS){
  _origin=new WB_Point(origin);
  _X=new WB_Vector(x);
  _Y=new WB_Vector(y);
  _Z=new WB_Vector(z);
  _parent=CS;
}",0.98828125
30093,"public double findSmallestSpanAroundStrut(final int i){
  final int n=struts.size();
  if ((i < 0) || (i >= n)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ArrayList<WB_FrameNode> nnodes=getNeighbors();
  if (n == 1) {
    return 2 * Math.PI;
  }
 else   if (n == 2) {
    final WB_Vector u=nnodes.get(0).subToVector(this);
    final WB_Vector w=nnodes.get(1).subToVector(this);
    u._normalizeSelf();
    w._normalizeSelf();
    final double udw=u.dot(w);
    if (udw < WB_Epsilon.EPSILON - 1) {
      return Math.PI;
    }
 else {
      return Math.acos(udw);
    }
  }
 else {
    double minAngle=Double.MAX_VALUE;
    final WB_Vector u=nnodes.get(i).subToVector(this);
    u._normalizeSelf();
    for (int j=0; j < n; j++) {
      if (i != j) {
        final WB_Vector w=nnodes.get(j).subToVector(this);
        w._normalizeSelf();
        final double a=Math.acos(u.dot(w));
        minAngle=WB_Math.min(minAngle,a);
      }
    }
    return minAngle;
  }
}","public double findSmallestSpanAroundStrut(final int i){
  final int n=struts.size();
  if ((i < 0) || (i >= n)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ArrayList<WB_FrameNode> nnodes=getNeighbors();
  if (n == 1) {
    return 2 * Math.PI;
  }
 else   if (n == 2) {
    final WB_Vector u=nnodes.get(0).subToVector(this);
    final WB_Vector w=nnodes.get(1).subToVector(this);
    u._normalizeSelf();
    w._normalizeSelf();
    final double udw=WB_Math.clamp(u.dot(w),-1,1);
    if (udw < WB_Epsilon.EPSILON - 1) {
      return Math.PI;
    }
 else {
      return Math.acos(udw);
    }
  }
 else {
    double minAngle=Double.MAX_VALUE;
    final WB_Vector u=nnodes.get(i).subToVector(this);
    u._normalizeSelf();
    for (int j=0; j < n; j++) {
      if (i != j) {
        final WB_Vector w=nnodes.get(j).subToVector(this);
        w._normalizeSelf();
        final double a=Math.acos(u.dot(w));
        minAngle=WB_Math.min(minAngle,a);
      }
    }
    return minAngle;
  }
}",0.9900199600798404
30094,"/** 
 * returns the smallest rotation angle (direction determined by vector dir) needed to bring point p on this circle to be on the circle c as well. Returns null if there is no intersection or just one intersection.
 * @return
 */
public Double getFirstIntersection(Circle c,Point p,Vector dir){
  double dist=center.distance(c.getCenter());
  if (dist > radius + c.getRadius() - WB_Epsilon.EPSILON)   return null;
  double r2d2=radius * radius + dist * dist;
  double rd2=2 * radius * dist;
  double cosAlpha=(r2d2 - c.getRadius() * c.getRadius()) / rd2;
  System.out.println(""String_Node_Str"" + cosAlpha + ""String_Node_Str""+ Math.acos(cosAlpha));
  double distP2=p.distanceSquared(c.getCenter());
  double cosBeta=(r2d2 - distP2) / rd2;
  System.out.println(""String_Node_Str"" + cosAlpha + ""String_Node_Str""+ Math.acos(cosBeta));
  Vector op=new Vector(center,p);
  Vector oco=new Vector(center,c.getCenter());
  Vector cr=op.crossNew(oco);
  cr.divideThis(op.length() * oco.length());
  double sinBeta=cr.length();
  double alpha=Math.acos(cosAlpha);
  System.out.println(""String_Node_Str"" + Math.toDegrees(cosAlpha));
  double beta=Math.atan2(sinBeta,cosBeta);
  System.out.println(""String_Node_Str"" + Math.toDegrees(beta));
  if (normal.dot(dir) > 0) {
    if (normal.dot(cr) > 0)     return beta - alpha;
 else     return 2 * Math.PI - beta - alpha;
  }
 else {
    if (normal.dot(cr) > 0)     return 2 * Math.PI - beta - alpha;
 else     return beta - alpha;
  }
}","/** 
 * returns the smallest rotation angle (direction determined by vector dir) needed to bring point p on this circle to be on the circle c as well. Returns null if there is no intersection or just one intersection.
 * @return smallest rotation angle
 */
public Double getFirstIntersection(Circle c,Point p,Vector dir){
  double dist=center.distance(c.getCenter());
  if (dist > radius + c.getRadius() - WB_Epsilon.EPSILON)   return null;
  double r2d2=radius * radius + dist * dist;
  double rd2=2 * radius * dist;
  double cosAlpha=(r2d2 - c.getRadius() * c.getRadius()) / rd2;
  System.out.println(""String_Node_Str"" + cosAlpha + ""String_Node_Str""+ Math.acos(cosAlpha));
  double distP2=p.distanceSquared(c.getCenter());
  double cosBeta=(r2d2 - distP2) / rd2;
  System.out.println(""String_Node_Str"" + cosAlpha + ""String_Node_Str""+ Math.acos(cosBeta));
  Vector op=new Vector(center,p);
  Vector oco=new Vector(center,c.getCenter());
  Vector cr=op.crossNew(oco);
  cr.divideThis(op.length() * oco.length());
  double sinBeta=cr.length();
  double alpha=Math.acos(cosAlpha);
  System.out.println(""String_Node_Str"" + Math.toDegrees(cosAlpha));
  double beta=Math.atan2(sinBeta,cosBeta);
  System.out.println(""String_Node_Str"" + Math.toDegrees(beta));
  if (normal.dot(dir) > 0) {
    if (normal.dot(cr) > 0)     return beta - alpha;
 else     return 2 * Math.PI - beta - alpha;
  }
 else {
    if (normal.dot(cr) > 0)     return 2 * Math.PI - beta - alpha;
 else     return beta - alpha;
  }
}",0.9919137466307276
30095,"/** 
 * LU Decomposition
 * @param A Rectangular matrix
 * @return Structure to access L, U and piv.
 */
public LUDecomposition(Matrix A){
  LU=A.clone().coords;
  m=A.getM();
  n=A.getN();
  piv=new int[m];
  for (int i=0; i < m; i++) {
    piv[i]=i;
  }
  pivsign=1;
  double[] LUrowi;
  double[] LUcolj=new double[m];
  for (int j=0; j < n; j++) {
    for (int i=0; i < m; i++) {
      LUcolj[i]=LU[i][j];
    }
    for (int i=0; i < m; i++) {
      LUrowi=LU[i];
      int kmax=Math.min(i,j);
      double s=0.0;
      for (int k=0; k < kmax; k++) {
        s+=LUrowi[k] * LUcolj[k];
      }
      LUrowi[j]=LUcolj[i]-=s;
    }
    int p=j;
    for (int i=j + 1; i < m; i++) {
      if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
        p=i;
      }
    }
    if (p != j) {
      for (int k=0; k < n; k++) {
        double t=LU[p][k];
        LU[p][k]=LU[j][k];
        LU[j][k]=t;
      }
      int k=piv[p];
      piv[p]=piv[j];
      piv[j]=k;
      pivsign=-pivsign;
    }
    if (j < m & LU[j][j] != 0.0) {
      for (int i=j + 1; i < m; i++) {
        LU[i][j]/=LU[j][j];
      }
    }
  }
}","/** 
 * LU Decomposition
 * @param A Rectangular matrix
 */
public LUDecomposition(Matrix A){
  LU=A.clone().coords;
  m=A.getM();
  n=A.getN();
  piv=new int[m];
  for (int i=0; i < m; i++) {
    piv[i]=i;
  }
  pivsign=1;
  double[] LUrowi;
  double[] LUcolj=new double[m];
  for (int j=0; j < n; j++) {
    for (int i=0; i < m; i++) {
      LUcolj[i]=LU[i][j];
    }
    for (int i=0; i < m; i++) {
      LUrowi=LU[i];
      int kmax=Math.min(i,j);
      double s=0.0;
      for (int k=0; k < kmax; k++) {
        s+=LUrowi[k] * LUcolj[k];
      }
      LUrowi[j]=LUcolj[i]-=s;
    }
    int p=j;
    for (int i=j + 1; i < m; i++) {
      if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
        p=i;
      }
    }
    if (p != j) {
      for (int k=0; k < n; k++) {
        double t=LU[p][k];
        LU[p][k]=LU[j][k];
        LU[j][k]=t;
      }
      int k=piv[p];
      piv[p]=piv[j];
      piv[j]=k;
      pivsign=-pivsign;
    }
    if (j < m & LU[j][j] != 0.0) {
      for (int i=j + 1; i < m; i++) {
        LU[i][j]/=LU[j][j];
      }
    }
  }
}",0.9791955617198336
30096,"/** 
 * Gets the minimum squared distance to another line.
 * @see [Ericsson 05, p. 147]
 * @hop 14-32
 */
public double getSquaredDistance(Line l){
  double a=dir.getLengthSquared();
  double b=dir.dot(l.dir);
  double e=l.dir.getLengthSquared();
  double d=a * e - b * b;
  if (Math.abs(d) < WB_Epsilon.EPSILON)   return getDistanceSquared(l.p);
  Vector r=l.p.vectorTo(p);
  double c=dir.dot(r);
  double f=l.dir.dot(r);
  double s=(b * f - c * e) / d;
  double t=(a * f - b * c) / d;
  double dx=(p.x() + s * dir.x()) - (l.p.x() + t * l.dir.x());
  double dy=(p.y() + s * dir.y()) - (l.p.y() + t * l.dir.y());
  double dz=(p.z() + s * dir.z()) - (l.p.z() + t * l.dir.z());
  return dx * dx + dy * dy + dz * dz;
}","/** 
 * Gets the minimum squared distance to another line.
 */
public double getSquaredDistance(Line l){
  double a=dir.getLengthSquared();
  double b=dir.dot(l.dir);
  double e=l.dir.getLengthSquared();
  double d=a * e - b * b;
  if (Math.abs(d) < WB_Epsilon.EPSILON)   return getDistanceSquared(l.p);
  Vector r=l.p.vectorTo(p);
  double c=dir.dot(r);
  double f=l.dir.dot(r);
  double s=(b * f - c * e) / d;
  double t=(a * f - b * c) / d;
  double dx=(p.x() + s * dir.x()) - (l.p.x() + t * l.dir.x());
  double dy=(p.y() + s * dir.y()) - (l.p.y() + t * l.dir.y());
  double dz=(p.z() + s * dir.z()) - (l.p.z() + t * l.dir.z());
  return dx * dx + dy * dy + dz * dz;
}",0.968299711815562
30097,"/** 
 * Check for symmetry, then construct the eigenvalue decomposition.
 * @param A Square matrix
 */
protected EigenvalueDecomposition(){
  double[][] A=coords;
  n=N;
  V=new double[n][n];
  d=new double[n];
  e=new double[n];
  issymmetric=true;
  for (int j=0; (j < n) & issymmetric; j++) {
    for (int i=0; (i < n) & issymmetric; i++) {
      issymmetric=(A[i][j] == A[j][i]);
    }
  }
  if (issymmetric) {
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        V[i][j]=A[i][j];
      }
    }
    tred2();
    tql2();
  }
 else {
    H=new double[n][n];
    ort=new double[n];
    for (int j=0; j < n; j++) {
      for (int i=0; i < n; i++) {
        H[i][j]=A[i][j];
      }
    }
    orthes();
    hqr2();
  }
}","/** 
 * Check for symmetry, then construct the eigenvalue decomposition.
 */
protected EigenvalueDecomposition(){
  double[][] A=coords;
  n=N;
  V=new double[n][n];
  d=new double[n];
  e=new double[n];
  issymmetric=true;
  for (int j=0; (j < n) & issymmetric; j++) {
    for (int i=0; (i < n) & issymmetric; i++) {
      issymmetric=(A[i][j] == A[j][i]);
    }
  }
  if (issymmetric) {
    for (int i=0; i < n; i++) {
      for (int j=0; j < n; j++) {
        V[i][j]=A[i][j];
      }
    }
    tred2();
    tql2();
  }
 else {
    H=new double[n][n];
    ort=new double[n];
    for (int j=0; j < n; j++) {
      for (int i=0; i < n; i++) {
        H[i][j]=A[i][j];
      }
    }
    orthes();
    hqr2();
  }
}",0.9821182943603852
30098,"/** 
 * Get a submatrix.
 * @param r Array of row indices.
 * @param i0 Initial column index
 * @param i1 Final column index
 * @return A(r(:),j0:j1)
 * @exception ArrayIndexOutOfBoundsException Submatrix indices
 */
Matrix getMatrix(int[] r,int j0,int j1){
  Matrix X=new Matrix(r.length,j1 - j0 + 1);
  double[][] B=X.coords;
  try {
    for (int i=0; i < r.length; i++) {
      for (int j=j0; j <= j1; j++) {
        B[i][j - j0]=coords[r[i]][j];
      }
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"");
  }
  return X;
}","/** 
 * Get a submatrix.
 * @param r Array of row indices.
 * @param j0 Initial column index
 * @param j1 Final column index
 * @return A(r(:),j0:j1)
 * @exception ArrayIndexOutOfBoundsException Submatrix indices
 */
Matrix getMatrix(int[] r,int j0,int j1){
  Matrix X=new Matrix(r.length,j1 - j0 + 1);
  double[][] B=X.coords;
  try {
    for (int i=0; i < r.length; i++) {
      for (int j=j0; j <= j1; j++) {
        B[i][j - j0]=coords[r[i]][j];
      }
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"");
  }
  return X;
}",0.9966442953020134
30099,"/** 
 * Reduce this matrix to row canonical form (reduced row echelon form). This matrix is changed and returned.
 * @hops For n by m matrix: 0 to m*n+(n-1)^2*m
 * @todo TODO Optimize loops to remove 0-nominator divisions.
 */
public Matrix reduceThis(){
  int rowCount=M;
  int colCount=N;
  int lead=0;
  for (int r=0; r < rowCount; r++) {
    if (lead >= colCount)     return this;
    int i=r;
    while (Math.abs(coords[i][lead]) <= WB_Epsilon.EPSILON) {
      i++;
      if (rowCount == i) {
        i=r;
        lead++;
        if (colCount == lead) {
          return this;
        }
      }
    }
    if (i != r) {
      double[] tmpArr=coords[i];
      coords[i]=coords[r];
      coords[r]=tmpArr;
    }
    double tmp=coords[r][lead];
    for (int c=0; c < coords[r].length; c++)     coords[r][c]/=tmp;
    for (i=0; i < rowCount; i++) {
      if (i != r) {
        tmp=coords[i][lead];
        for (int c=0; c < coords[i].length; c++)         coords[i][c]-=tmp * coords[r][c];
      }
    }
    lead++;
  }
  return this;
}","/** 
 * Reduce this matrix to row canonical form (reduced row echelon form). This matrix is changed and returned.
 */
public Matrix reduceThis(){
  int rowCount=M;
  int colCount=N;
  int lead=0;
  for (int r=0; r < rowCount; r++) {
    if (lead >= colCount)     return this;
    int i=r;
    while (Math.abs(coords[i][lead]) <= WB_Epsilon.EPSILON) {
      i++;
      if (rowCount == i) {
        i=r;
        lead++;
        if (colCount == lead) {
          return this;
        }
      }
    }
    if (i != r) {
      double[] tmpArr=coords[i];
      coords[i]=coords[r];
      coords[r]=tmpArr;
    }
    double tmp=coords[r][lead];
    for (int c=0; c < coords[r].length; c++)     coords[r][c]/=tmp;
    for (i=0; i < rowCount; i++) {
      if (i != r) {
        tmp=coords[i][lead];
        for (int c=0; c < coords[i].length; c++)         coords[i][c]-=tmp * coords[r][c];
      }
    }
    lead++;
  }
  return this;
}",0.944416114227435
30100,"/** 
 * Get the eigenvectors of a 3x3 matrix sorted by decreasing eigenvalue. If the matrix is singular ... TODO: test this.
 * @return an array containing eigenvectors.
 * @hops 84
 */
public Vector[] getEigenvectors(){
  if (coords.length != 3 || coords[0].length != 3)   throw new Error(""String_Node_Str"" + coords.length + ""String_Node_Str""+ coords[0].length);
  boolean issymmetric=true;
  for (int j=0; (j < 3) & issymmetric; j++) {
    for (int i=0; (i < 3) & issymmetric; i++) {
      issymmetric=(coords[i][j] == coords[j][i]);
    }
  }
  if (issymmetric) {
    double c=coords[0][0] * coords[1][1];
    double d=coords[1][2] * coords[2][1];
    double e=coords[0][1] * coords[1][0];
    double f=coords[0][2] * coords[2][0];
    double p=-coords[0][0] - coords[1][1] - coords[2][2];
    double q=c + (coords[0][0] + coords[1][1]) * coords[2][2] - d - e - f;
    double r=(e - c) * coords[2][2] + d * coords[0][0] - 2 * (coords[0][1] * coords[1][2] * coords[2][0]) + f * coords[1][1];
    double pThirds=p / 3;
    double a=q - p * pThirds;
    double b=(2 * pThirds * pThirds - q) * pThirds + r;
    double aThirds=a / 3;
    double m=2 * Math.sqrt(-aThirds);
    double t=Math.acos(b / (aThirds * m)) / 3;
    double cosT=Math.cos(t);
    double sinT=Math.sin(t);
    double l1=m * cosT - pThirds;
    double l2=-m * ((cosT + Math.sqrt(3) * sinT) / 2) - pThirds;
    double l3=-m * ((cosT - Math.sqrt(3) * sinT) / 2) - pThirds;
    Matrix3x3 m1=clone();
    m1.set(0,0,-l1 + m1.get(0,0));
    m1.set(1,1,-l1 + m1.get(1,1));
    m1.set(2,2,-l1 + m1.get(2,2));
    m1.reduceThis();
    m1.toConsole();
    Vector v1=new Vector(-m1.coords[0][2],-m1.coords[1][2],1);
    Vector v2=null, v3=null;
    if (l2 > WB_Epsilon.EPSILON) {
      Matrix3x3 m2=clone();
      m2.set(0,0,-l2 + m2.get(0,0));
      m2.set(1,1,-l2 + m2.get(1,1));
      m2.set(2,2,-l2 + m2.get(2,2));
      m2.reduceThis();
      v2=new Vector(-m2.coords[0][2],-m2.coords[1][2],1);
    }
    if (l3 > WB_Epsilon.EPSILON) {
      Matrix3x3 m3=clone();
      m3.set(0,0,-l3 + m3.get(0,0));
      m3.set(1,1,-l3 + m3.get(1,1));
      m3.set(2,2,-l3 + m3.get(2,2));
      m3.reduceThis();
      v3=new Vector(-m3.coords[0][2],-m3.coords[1][2],1);
    }
    return new Vector[]{v1,v2,v3};
  }
  EigenvalueDecomposition ed=new EigenvalueDecomposition();
  Vector[] ret=new Vector[3];
  double[][] V=ed.getV().coords;
  ret[0]=new Vector(V[0][0],V[1][0],V[2][0]).multiplyThis(ed.getRealEigenvalues()[0]);
  ret[1]=new Vector(V[0][1],V[1][1],V[2][1]).multiplyThis(ed.getRealEigenvalues()[1]);
  ret[2]=new Vector(V[0][2],V[1][2],V[2][2]).multiplyThis(ed.getRealEigenvalues()[2]);
  return ret;
}","/** 
 * Get the eigenvectors of a 3x3 matrix sorted by decreasing eigenvalue. If the matrix is singular ... TODO: test this.
 * @return an array containing eigenvectors.
 */
public Vector[] getEigenvectors(){
  if (coords.length != 3 || coords[0].length != 3)   throw new Error(""String_Node_Str"" + coords.length + ""String_Node_Str""+ coords[0].length);
  boolean issymmetric=true;
  for (int j=0; (j < 3) & issymmetric; j++) {
    for (int i=0; (i < 3) & issymmetric; i++) {
      issymmetric=(coords[i][j] == coords[j][i]);
    }
  }
  if (issymmetric) {
    double c=coords[0][0] * coords[1][1];
    double d=coords[1][2] * coords[2][1];
    double e=coords[0][1] * coords[1][0];
    double f=coords[0][2] * coords[2][0];
    double p=-coords[0][0] - coords[1][1] - coords[2][2];
    double q=c + (coords[0][0] + coords[1][1]) * coords[2][2] - d - e - f;
    double r=(e - c) * coords[2][2] + d * coords[0][0] - 2 * (coords[0][1] * coords[1][2] * coords[2][0]) + f * coords[1][1];
    double pThirds=p / 3;
    double a=q - p * pThirds;
    double b=(2 * pThirds * pThirds - q) * pThirds + r;
    double aThirds=a / 3;
    double m=2 * Math.sqrt(-aThirds);
    double t=Math.acos(b / (aThirds * m)) / 3;
    double cosT=Math.cos(t);
    double sinT=Math.sin(t);
    double l1=m * cosT - pThirds;
    double l2=-m * ((cosT + Math.sqrt(3) * sinT) / 2) - pThirds;
    double l3=-m * ((cosT - Math.sqrt(3) * sinT) / 2) - pThirds;
    Matrix3x3 m1=clone();
    m1.set(0,0,-l1 + m1.get(0,0));
    m1.set(1,1,-l1 + m1.get(1,1));
    m1.set(2,2,-l1 + m1.get(2,2));
    m1.reduceThis();
    m1.toConsole();
    Vector v1=new Vector(-m1.coords[0][2],-m1.coords[1][2],1);
    Vector v2=null, v3=null;
    if (l2 > WB_Epsilon.EPSILON) {
      Matrix3x3 m2=clone();
      m2.set(0,0,-l2 + m2.get(0,0));
      m2.set(1,1,-l2 + m2.get(1,1));
      m2.set(2,2,-l2 + m2.get(2,2));
      m2.reduceThis();
      v2=new Vector(-m2.coords[0][2],-m2.coords[1][2],1);
    }
    if (l3 > WB_Epsilon.EPSILON) {
      Matrix3x3 m3=clone();
      m3.set(0,0,-l3 + m3.get(0,0));
      m3.set(1,1,-l3 + m3.get(1,1));
      m3.set(2,2,-l3 + m3.get(2,2));
      m3.reduceThis();
      v3=new Vector(-m3.coords[0][2],-m3.coords[1][2],1);
    }
    return new Vector[]{v1,v2,v3};
  }
  EigenvalueDecomposition ed=new EigenvalueDecomposition();
  Vector[] ret=new Vector[3];
  double[][] V=ed.getV().coords;
  ret[0]=new Vector(V[0][0],V[1][0],V[2][0]).multiplyThis(ed.getRealEigenvalues()[0]);
  ret[1]=new Vector(V[0][1],V[1][1],V[2][1]).multiplyThis(ed.getRealEigenvalues()[1]);
  ret[2]=new Vector(V[0][2],V[1][2],V[2][2]).multiplyThis(ed.getRealEigenvalues()[2]);
  return ret;
}",0.9977418140760256
30101,"/** 
 * Invert this matrix (overwrites this and returns it).
 * @hops 31
 */
@Override public Matrix invertThis(){
  double[][] newCoords=new double[coords.length][coords[0].length];
  newCoords[0][0]=coords[1][1] * coords[2][2] - coords[1][2] * coords[2][1];
  newCoords[0][1]=coords[0][2] * coords[2][1] - coords[0][1] * coords[2][2];
  newCoords[0][2]=coords[0][1] * coords[1][2] - coords[0][2] * coords[1][1];
  newCoords[1][0]=coords[1][2] * coords[2][0] - coords[1][0] * coords[2][2];
  newCoords[1][1]=coords[0][0] * coords[2][2] - coords[0][2] * coords[2][0];
  newCoords[1][2]=coords[0][2] * coords[1][0] - coords[0][0] * coords[1][2];
  newCoords[2][0]=coords[1][0] * coords[2][1] - coords[1][1] * coords[2][0];
  newCoords[2][1]=coords[0][1] * coords[2][0] - coords[0][0] * coords[2][1];
  newCoords[2][2]=coords[0][0] * coords[1][1] - coords[0][1] * coords[1][0];
  double det=coords[0][0] * newCoords[0][0] + coords[0][1] * newCoords[1][0] + coords[0][2] * newCoords[2][0];
  this.coords=newCoords;
  return multiplyThis(1 / det);
}","/** 
 * Invert this matrix (overwrites this and returns it).
 */
@Override public Matrix invertThis(){
  double[][] newCoords=new double[coords.length][coords[0].length];
  newCoords[0][0]=coords[1][1] * coords[2][2] - coords[1][2] * coords[2][1];
  newCoords[0][1]=coords[0][2] * coords[2][1] - coords[0][1] * coords[2][2];
  newCoords[0][2]=coords[0][1] * coords[1][2] - coords[0][2] * coords[1][1];
  newCoords[1][0]=coords[1][2] * coords[2][0] - coords[1][0] * coords[2][2];
  newCoords[1][1]=coords[0][0] * coords[2][2] - coords[0][2] * coords[2][0];
  newCoords[1][2]=coords[0][2] * coords[1][0] - coords[0][0] * coords[1][2];
  newCoords[2][0]=coords[1][0] * coords[2][1] - coords[1][1] * coords[2][0];
  newCoords[2][1]=coords[0][1] * coords[2][0] - coords[0][0] * coords[2][1];
  newCoords[2][2]=coords[0][0] * coords[1][1] - coords[0][1] * coords[1][0];
  double det=coords[0][0] * newCoords[0][0] + coords[0][1] * newCoords[1][0] + coords[0][2] * newCoords[2][0];
  this.coords=newCoords;
  return multiplyThis(1 / det);
}",0.9942252165543792
30102,"/** 
 * Get the determinant of this matrix.
 * @hops 9
 */
@Override public double determinant(){
  double ret=coords[0][0] * (coords[1][1] * coords[2][2] - coords[1][2] * coords[2][1]);
  ret-=coords[0][1] * (coords[1][0] * coords[2][2] - coords[1][2] * coords[2][0]);
  ret+=coords[0][2] * (coords[1][0] * coords[2][1] - coords[1][1] * coords[2][0]);
  return ret;
}","/** 
 * Get the determinant of this matrix.
 */
@Override public double determinant(){
  double ret=coords[0][0] * (coords[1][1] * coords[2][2] - coords[1][2] * coords[2][1]);
  ret-=coords[0][1] * (coords[1][0] * coords[2][2] - coords[1][2] * coords[2][0]);
  ret+=coords[0][2] * (coords[1][0] * coords[2][1] - coords[1][1] * coords[2][0]);
  return ret;
}",0.9848275862068966
30103,"/** 
 * Find the two, one or zero points that is at the intersection of the three sphere shells. If the three spheres intersect in more than two points or one sphere contains another, the result of this method not specified.
 * @hops 57-70
 */
public static Point[] getIntersections(Sphere s1,Sphere s2,Sphere s3){
  double x1=s1.center.x();
  double y1=s1.center.y();
  double z1=s1.center.z();
  double c1Sq=s1.center.dot(s1.center);
  double c2Sq=s2.center.dot(s2.center);
  double r1=s1.radius, r1Sq=r1 * r1;
  Vector v12=s2.center.vectorTo(s1.center);
  Vector v23=s3.center.vectorTo(s2.center);
  double c12=c1Sq - c2Sq;
  double c23=c2Sq - s3.center.dot(s3.center);
  double r2Sq=s2.radius * s2.radius;
  double r12=r2Sq - r1Sq + c12;
  double r23=s3.radius * s3.radius - r2Sq + c23;
  double Dyz=v12.y() * v23.z() - v23.y() * v12.z(), DyzSq=Dyz * Dyz;
  double Dry=r12 * v23.y() - r23 * v12.y(), DrySq=Dry * Dry;
  double Dzx=v12.z() * v23.x() - v23.z() * v12.x(), DzxSq=Dzx * Dzx;
  double Dxr=v12.x() * r23 - v23.x() * r12, DxrSq=Dxr * Dxr;
  double Dxy=v12.x() * v23.y() - v23.x() * v12.y(), DxySq=Dxy * Dxy;
  double k2=(DyzSq + DzxSq) / DxySq + 1;
  double k1=(Dyz * Dry + Dzx * Dxr) / DxySq - 4 * (x1 * Dyz + y1 * Dzx) / Dxy - z1;
  double k0=(DrySq + DxrSq) / (4 * DxySq) + c1Sq - r1Sq - 2 * (x1 * Dry + y1 * Dxr) / Dxy;
  double d=k1 * k1 - 4 * k2 * k0;
  if (d < -WB_Epsilon.EPSILON)   return new Point[]{};
  if (d < WB_Epsilon.EPSILON) {
    double zi=-k1 / (2 * k2);
    return new Point[]{new Point((2 * zi * Dyz + Dry) / (2 * Dxy),(2 * zi * Dzx + Dxr) / (2 * Dxy),zi)};
  }
  double dRt=Math.sqrt(d);
  double zi0=(-k1 - dRt) / (2 * k2);
  double zi1=(-k1 + dRt) / (2 * k2);
  return new Point[]{new Point((2 * zi0 * Dyz + Dry) / (2 * Dxy),(2 * zi0 * Dzx + Dxr) / (2 * Dxy),zi0),new Point((2 * zi1 * Dyz + Dry) / (2 * Dxy),(2 * zi1 * Dzx + Dxr) / (2 * Dxy),zi1)};
}","/** 
 * Find the two, one or zero points that is at the intersection of the three sphere shells. If the three spheres intersect in more than two points or one sphere contains another, the result of this method not specified.
 */
public static Point[] getIntersections(Sphere s1,Sphere s2,Sphere s3){
  double x1=s1.center.x();
  double y1=s1.center.y();
  double z1=s1.center.z();
  double c1Sq=s1.center.dot(s1.center);
  double c2Sq=s2.center.dot(s2.center);
  double r1=s1.radius, r1Sq=r1 * r1;
  Vector v12=s2.center.vectorTo(s1.center);
  Vector v23=s3.center.vectorTo(s2.center);
  double c12=c1Sq - c2Sq;
  double c23=c2Sq - s3.center.dot(s3.center);
  double r2Sq=s2.radius * s2.radius;
  double r12=r2Sq - r1Sq + c12;
  double r23=s3.radius * s3.radius - r2Sq + c23;
  double Dyz=v12.y() * v23.z() - v23.y() * v12.z(), DyzSq=Dyz * Dyz;
  double Dry=r12 * v23.y() - r23 * v12.y(), DrySq=Dry * Dry;
  double Dzx=v12.z() * v23.x() - v23.z() * v12.x(), DzxSq=Dzx * Dzx;
  double Dxr=v12.x() * r23 - v23.x() * r12, DxrSq=Dxr * Dxr;
  double Dxy=v12.x() * v23.y() - v23.x() * v12.y(), DxySq=Dxy * Dxy;
  double k2=(DyzSq + DzxSq) / DxySq + 1;
  double k1=(Dyz * Dry + Dzx * Dxr) / DxySq - 4 * (x1 * Dyz + y1 * Dzx) / Dxy - z1;
  double k0=(DrySq + DxrSq) / (4 * DxySq) + c1Sq - r1Sq - 2 * (x1 * Dry + y1 * Dxr) / Dxy;
  double d=k1 * k1 - 4 * k2 * k0;
  if (d < -WB_Epsilon.EPSILON)   return new Point[]{};
  if (d < WB_Epsilon.EPSILON) {
    double zi=-k1 / (2 * k2);
    return new Point[]{new Point((2 * zi * Dyz + Dry) / (2 * Dxy),(2 * zi * Dzx + Dxr) / (2 * Dxy),zi)};
  }
  double dRt=Math.sqrt(d);
  double zi0=(-k1 - dRt) / (2 * k2);
  double zi1=(-k1 + dRt) / (2 * k2);
  return new Point[]{new Point((2 * zi0 * Dyz + Dry) / (2 * Dxy),(2 * zi0 * Dzx + Dxr) / (2 * Dxy),zi0),new Point((2 * zi1 * Dyz + Dry) / (2 * Dxy),(2 * zi1 * Dzx + Dxr) / (2 * Dxy),zi1)};
}",0.9960095770151636
30104,"/** 
 * @param corners the input set of corners
 * @param liveEdges the (continuously updated) set of edges that still feature in the live corner list. Caller has to update this set :)
 */
public CollisionQ(Skeleton skel){
  this.skel=skel;
  faceEvents=new PriorityQueue<EdgeCollision>(Math.max(3,skel.liveCorners.size()),HeightEvent.heightComparator);
  miscEvents=new PriorityQueue<HeightEvent>(Math.max(3,skel.liveCorners.size()),HeightEvent.heightComparator);
}","public CollisionQ(Skeleton skel){
  this.skel=skel;
  faceEvents=new PriorityQueue<EdgeCollision>(Math.max(3,skel.liveCorners.size()),HeightEvent.heightComparator);
  miscEvents=new PriorityQueue<HeightEvent>(Math.max(3,skel.liveCorners.size()),HeightEvent.heightComparator);
}",0.7456258411843876
30105,"/** 
 * We rely on the fact that we can shift the point's heights without changing their locations in hashmaps.
 * @return
 */
@Override public int hashCode(){
  return System.identityHashCode(this);
}","/** 
 * We rely on the fact that we can shift the point's heights without changing their locations in hashmaps.
 * @return integer hashCode
 */
@Override public int hashCode(){
  return System.identityHashCode(this);
}",0.9594272076372315
30106,"/** 
 * Corners (unlike point3ds) are only equal to themselves. We never move a point, but can create multiple (uniques) at one location. We also change prev/next pointers to edges and other corners but need to retain hashing behaviour. Therefore we revert to the system hash.
 * @param t1
 * @return
 */
@Override public boolean equals(Object t1){
  return this == t1;
}","/** 
 * Corners (unlike point3ds) are only equal to themselves. We never move a point, but can create multiple (uniques) at one location. We also change prev/next pointers to edges and other corners but need to retain hashing behaviour. Therefore we revert to the system hash.
 * @param t1
 * @return true/false
 */
@Override public boolean equals(Object t1){
  return this == t1;
}",0.9853917662682604
30107,"/** 
 * Clones this set of corners. Creates new edges, corners and machines from the given set. Preserves currentCorners.
 * @param ribbon
 * @return
 */
public static LoopL<Corner> dupeNewAll(LoopL<Corner> ribbon){
  final Cache<Corner,Corner> cacheC=new Cache<Corner,Corner>(){
    Cache<Machine,Machine> cacheM=new Cache<Machine,Machine>(){
      @Override public Machine create(      Machine i){
        return new Machine(i.currentAngle);
      }
    }
;
    Cache<Edge,Edge> cacheE=new Cache<Edge,Edge>(){
      @Override public Edge create(      Edge i){
        Edge out=new Edge(getCorner(i.start),getCorner(i.end));
        out.setAngle(i.getAngle());
        out.machine=cacheM.get(i.machine);
        for (        Corner c : i.currentCorners) {
          out.currentCorners.add(getCorner(c));
        }
        return out;
      }
    }
;
    public Corner getCorner(    Corner input){
      Corner ner=get(input);
      return ner;
    }
    @Override public Corner create(    Corner i){
      Corner ner=new Corner(i.x,i.y);
      cache.put(i,ner);
      ner.nextC=get(i.nextC);
      ner.prevC=get(i.prevC);
      ner.nextL=cacheE.get(i.nextL);
      ner.prevL=cacheE.get(i.prevL);
      return ner;
    }
  }
;
  LoopL<Corner> loopl=new LoopL();
  for (  Loop<Corner> pLoop : ribbon) {
    Loop<Corner> loop=new Loop();
    loopl.add(loop);
    for (    Corner c : pLoop)     loop.append(cacheC.get(c));
  }
  return loopl;
}","/** 
 * Clones this set of corners. Creates new edges, corners and machines from the given set. Preserves currentCorners.
 * @param ribbon
 * @return cloned set of corners
 */
public static LoopL<Corner> dupeNewAll(LoopL<Corner> ribbon){
  final Cache<Corner,Corner> cacheC=new Cache<Corner,Corner>(){
    Cache<Machine,Machine> cacheM=new Cache<Machine,Machine>(){
      @Override public Machine create(      Machine i){
        return new Machine(i.currentAngle);
      }
    }
;
    Cache<Edge,Edge> cacheE=new Cache<Edge,Edge>(){
      @Override public Edge create(      Edge i){
        Edge out=new Edge(getCorner(i.start),getCorner(i.end));
        out.setAngle(i.getAngle());
        out.machine=cacheM.get(i.machine);
        for (        Corner c : i.currentCorners) {
          out.currentCorners.add(getCorner(c));
        }
        return out;
      }
    }
;
    public Corner getCorner(    Corner input){
      Corner ner=get(input);
      return ner;
    }
    @Override public Corner create(    Corner i){
      Corner ner=new Corner(i.x,i.y);
      cache.put(i,ner);
      ner.nextC=get(i.nextC);
      ner.prevC=get(i.prevC);
      ner.nextL=cacheE.get(i.nextL);
      ner.prevL=cacheE.get(i.prevL);
      return ner;
    }
  }
;
  LoopL<Corner> loopl=new LoopL();
  for (  Loop<Corner> pLoop : ribbon) {
    Loop<Corner> loop=new Loop();
    loopl.add(loop);
    for (    Corner c : pLoop)     loop.append(cacheC.get(c));
  }
  return loopl;
}",0.9924242424242424
30108,"/** 
 * UNTESTED!
 * @param ribbon
 * @return
 */
public static LoopL<Edge> fromPoints2d(LoopL<Point2d> ribbon){
  LoopL<Edge> loopl=new LoopL();
  Cache<Point2d,Corner> cache=new Cache<Point2d,Corner>(){
    @Override public Corner create(    Point2d i){
      return new Corner(i.x,i.y);
    }
  }
;
  for (  Loop<Point2d> pLoop : ribbon) {
    Loop<Edge> loop=new Loop();
    loopl.add(loop);
    for (    Loopable<Point2d> pair : pLoop.loopableIterator())     loop.append(new Edge(cache.get(pair.get()),cache.get(pair.getNext().get())));
  }
  return loopl;
}","/** 
 * @param ribbon
 * @return edge loops
 */
public static LoopL<Edge> fromPoints2d(LoopL<Point2d> ribbon){
  LoopL<Edge> loopl=new LoopL();
  Cache<Point2d,Corner> cache=new Cache<Point2d,Corner>(){
    @Override public Corner create(    Point2d i){
      return new Corner(i.x,i.y);
    }
  }
;
  for (  Loop<Point2d> pLoop : ribbon) {
    Loop<Edge> loop=new Loop();
    loopl.add(loop);
    for (    Loopable<Point2d> pair : pLoop.loopableIterator())     loop.append(new Edge(cache.get(pair.get()),cache.get(pair.getNext().get())));
  }
  return loopl;
}",0.9555160142348754
30109,"/** 
 * Collides a's two adjacent edges against the other given edge. Currently this handles the case that a.next, a.prev is
 * @return
 */
static Tuple3d collide(Corner a,Edge edge){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","static Tuple3d collide(Corner a,Edge edge){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.6045197740112994
30110,"/** 
 * Hash is agnostic to which edge is in a, b and c
 * @return
 */
@Override public int hashCode(){
  int hash=3;
  hash+=(this.a != null ? this.a.hashCode() : 0);
  hash+=(this.b != null ? this.b.hashCode() : 0);
  hash+=(this.c != null ? this.c.hashCode() : 0);
  return hash * 31;
}","/** 
 * Hash is agnostic to which edge is in a, b and c
 * @return hashcode
 */
@Override public int hashCode(){
  int hash=3;
  hash+=(this.a != null ? this.a.hashCode() : 0);
  hash+=(this.b != null ? this.b.hashCode() : 0);
  hash+=(this.c != null ? this.c.hashCode() : 0);
  return hash * 31;
}",0.9846678023850084
30111,"public HeightCollision(List<EdgeCollision> coHeighted){
  this.coHeighted=coHeighted;
  height=coHeighted.get(0).getHeight();
}","/** 
 * @param coHeighted .size() > 1
 */
public HeightCollision(List<EdgeCollision> coHeighted){
  this.coHeighted=coHeighted;
  height=coHeighted.get(0).getHeight();
}",0.8581081081081081
30112,"/** 
 * @param A Each rows of A is a cartesian point
 * @param b the offset of the matrix (normally 0?)
 * @return
 */
public static Vector3d solve(final Matrix3d A,final Tuple3d offset){
  final double[][] as=new double[][]{{A.m00,A.m01,A.m02},{A.m10,A.m11,A.m12},{A.m20,A.m21,A.m22}};
  final Matrix am=new Matrix(as);
  final double[] bs=new double[]{offset.x,offset.y,offset.z};
  final Matrix bm=new Matrix(bs,3);
  final double[][] out=am.solve(bm).getArray();
  final double d=offset.x * out[0][0] + offset.y * out[1][0] + offset.z * out[2][0];
  return new Vector3d(out[0][0],out[1][0],out[2][0]);
}","public static Vector3d solve(final Matrix3d A,final Tuple3d offset){
  final double[][] as=new double[][]{{A.m00,A.m01,A.m02},{A.m10,A.m11,A.m12},{A.m20,A.m21,A.m22}};
  final Matrix am=new Matrix(as);
  final double[] bs=new double[]{offset.x,offset.y,offset.z};
  final Matrix bm=new Matrix(bs,3);
  final double[][] out=am.solve(bm).getArray();
  final double d=offset.x * out[0][0] + offset.y * out[1][0] + offset.z * out[2][0];
  return new Vector3d(out[0][0],out[1][0],out[2][0]);
}",0.021917808219178
30113,"/** 
 * Project point onto line
 * @param ept
 * @return
 */
public Point3d projectLine(Point3d ept){
  return project(ept,false);
}","/** 
 * Project point onto line
 * @param ept
 * @return projected point
 */
public Point3d projectLine(Point3d ept){
  return project(ept,false);
}",0.9428571428571428
30114,"/** 
 * @param directions the directions to set
 */
public void addHeightEvent(HeightEvent dir){
  events.add(dir);
  sortHeightEvents();
}","public void addHeightEvent(HeightEvent dir){
  events.add(dir);
  sortHeightEvents();
}",0.7699115044247787
30115,"/** 
 * Removes entire list indexed by key
 * @param key
 * @return
 */
public List<B> remove(A key){
  return map.remove(key);
}","/** 
 * Removes entire list indexed by key
 * @param key
 * @return list indexed by key
 */
public List<B> remove(A key){
  return map.remove(key);
}",0.9280575539568344
30116,"/** 
 * Given two sets of leading corners, find the corner (if any) that lies on both edges
 * @return
 */
private Corner findAdjacent(Set<Corner> first,Set<Corner> second){
  for (  Corner c : first)   if (second.contains(c.nextC))   return c.nextC;
  return null;
}","/** 
 * Given two sets of leading corners, find the corner (if any) that lies on both edges
 * @return Corner
 */
private Corner findAdjacent(Set<Corner> first,Set<Corner> second){
  for (  Corner c : first)   if (second.contains(c.nextC))   return c.nextC;
  return null;
}",0.9870609981515712
30117,"/** 
 * When caculating an offset, we can assume that all edges add a face at every interval this returns the number of faces below this face.
 * @return
 */
public int getParentCount(){
  int count=-1;
  Face f=this;
  while (f != null) {
    count++;
    f=f.parent;
  }
  return count;
}","/** 
 * When calculating an offset, we can assume that all edges add a face at every interval this returns the number of faces below this face.
 * @return parent count
 */
public int getParentCount(){
  int count=-1;
  Face f=this;
  while (f != null) {
    count++;
    f=f.parent;
  }
  return count;
}",0.9764309764309764
30118,"/** 
 * One edge may start in two locations at the same time. To accomodate this, you call newEdge once per new edge, then new Defining Segment for each corner that references that edge.
 * @param startCorner The corner at the start of the edge at the base of this edge
 * @param aParentCorner A corner whose
 * @param profileFeatures
 */
public void newEdge(Edge e,Corner aParentLeadingCorner){
}","public void newEdge(Edge e,Corner aParentLeadingCorner){
}",0.2549450549450549
30119,"/** 
 * Some faces (such as base-plates for globals) can't really be classified nicely. They live here.
 * @param geom
 */
public void addNonSkeletonOutputFace(LoopL<Point3d> points,Vector3d norm){
  nonSkelFaces.add(new LoopNormal(points,norm));
}","public void addNonSkeletonOutputFace(LoopL<Point3d> points,Vector3d norm){
  nonSkelFaces.add(new LoopNormal(points,norm));
}",0.6702412868632708
30120,"/** 
 * Two parallel faces have become consecutive, remove info about toGo, add to toKeep
 * @toKeep leading corner to keep
 * @toGo leading corner to go
 */
void merge(Corner toKeep,Corner toGo){
  Face toGoFace=faces.get(toGo.nextL.start), toKeepFace=faces.get(toKeep.nextL.start);
  if (toGoFace == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  toKeepFace.definingSE.addAll(toGoFace.definingSE);
  toKeepFace.results.addEntriesFrom(toGoFace.results);
  toKeepFace.definingCorners.addAll(toGoFace.definingCorners);
  faces.put(toGo.nextL.start,toKeepFace);
  faces.put(toGo,toKeepFace);
}","/** 
 * Two parallel faces have become consecutive, remove info about toGo, add to toKeep
 */
void merge(Corner toKeep,Corner toGo){
  Face toGoFace=faces.get(toGo.nextL.start), toKeepFace=faces.get(toKeep.nextL.start);
  if (toGoFace == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  toKeepFace.definingSE.addAll(toGoFace.definingSE);
  toKeepFace.results.addEntriesFrom(toGoFace.results);
  toKeepFace.definingCorners.addAll(toGoFace.definingCorners);
  faces.put(toGo.nextL.start,toKeepFace);
  faces.put(toGo,toKeepFace);
}",0.9449225473321858
30121,"/** 
 * @Deprecated
 * @param cap height (flat-topped skeleton) to finish at
 */
public Skeleton(LoopL<Edge> input,final double cap){
  setupForEdges(input);
  qu.add(new HeightEvent(){
    @Override public double getHeight(){
      return cap;
    }
    @Override public boolean process(    Skeleton skel){
      SkeletonCapUpdate capUpdate=new SkeletonCapUpdate(skel);
      flatTop=capUpdate.getCap(cap);
      capUpdate.update(new LoopL(),new SetCorrespondence<Corner,Corner>(),new DHash<Corner,Corner>());
      return true;
    }
  }
);
}","/** 
 * @param cap height (flat-topped skeleton) to finish at
 */
public Skeleton(LoopL<Edge> input,final double cap){
  setupForEdges(input);
  qu.add(new HeightEvent(){
    @Override public double getHeight(){
      return cap;
    }
    @Override public boolean process(    Skeleton skel){
      SkeletonCapUpdate capUpdate=new SkeletonCapUpdate(skel);
      flatTop=capUpdate.getCap(cap);
      capUpdate.update(new LoopL(),new SetCorrespondence<Corner,Corner>(),new DHash<Corner,Corner>());
      return true;
    }
  }
);
}",0.9860205032618826
30122,"public static WB_Classification classifyPointToLine2D(final WB_Coordinate p,final WB_Line L){
  final double dist=-L.getDirection().yd() * p.xd() + L.getDirection().xd() * p.yd() + L.getOrigin().xd() * L.getDirection().yd() - L.getOrigin().yd() * L.getDirection().xd();
  if (dist > WB_Epsilon.EPSILON) {
    return WB_Classification.FRONT;
  }
  if (dist < -WB_Epsilon.EPSILON) {
    return WB_Classification.BACK;
  }
  return WB_Classification.ON;
}","/** 
 * Classify 2D point to 2D line.
 * @param p 2D point
 * @param L
 * @return WB_Classification.FRONT, WB_Classification.BACK,WB_Classification.ON
 */
public static WB_Classification classifyPointToLine2D(final WB_Coordinate p,final WB_Line L){
  final double dist=-L.getDirection().yd() * p.xd() + L.getDirection().xd() * p.yd() + L.getOrigin().xd() * L.getDirection().yd() - L.getOrigin().yd() * L.getDirection().xd();
  if (dist > WB_Epsilon.EPSILON) {
    return WB_Classification.FRONT;
  }
  if (dist < -WB_Epsilon.EPSILON) {
    return WB_Classification.BACK;
  }
  return WB_Classification.ON;
}",0.8536355051935789
30123,"public void saveGradleProperties(Properties prop) throws IOException {
  FileOutputStream os=new FileOutputStream(getProjectDir().getAbsolutePath() + ""String_Node_Str"");
  prop.store(os,null);
}","public void saveGradleProperties(Properties prop,File projectPath) throws IOException {
  FileOutputStream os=new FileOutputStream(projectPath.getAbsolutePath() + ""String_Node_Str"");
  prop.store(os,null);
}",0.9226932668329176
30124,"public void updateEngineVersion(File projectPath) throws FileNotFoundException, IOException {
  Properties prop=getGradleProperties(projectPath);
  prop.setProperty(Config.BLADE_ENGINE_VERSION_PROP,Versions.getVersion());
  prop.setProperty(""String_Node_Str"",Versions.getLibgdxVersion());
  prop.setProperty(""String_Node_Str"",Versions.getRoboVMVersion());
  prop.setProperty(""String_Node_Str"",Versions.getROBOVMGradlePluginVersion());
  prop.setProperty(""String_Node_Str"",Versions.getAndroidGradlePluginVersion());
  prop.setProperty(""String_Node_Str"",Versions.getBladeInkVersion());
  saveGradleProperties(prop);
}","public void updateEngineVersion(File projectPath) throws FileNotFoundException, IOException {
  Properties prop=getGradleProperties(projectPath);
  prop.setProperty(Config.BLADE_ENGINE_VERSION_PROP,Versions.getVersion());
  prop.setProperty(""String_Node_Str"",Versions.getLibgdxVersion());
  prop.setProperty(""String_Node_Str"",Versions.getRoboVMVersion());
  prop.setProperty(""String_Node_Str"",Versions.getROBOVMGradlePluginVersion());
  prop.setProperty(""String_Node_Str"",Versions.getAndroidGradlePluginVersion());
  prop.setProperty(""String_Node_Str"",Versions.getBladeInkVersion());
  saveGradleProperties(prop,projectPath);
}",0.9903381642512076
30125,"/** 
 * Saves the selected version
 */
private void setCurrentVersion(String version){
  try {
    Properties prop=Ctx.project.getGradleProperties(Ctx.project.getProjectDir());
    prop.setProperty(""String_Node_Str"",version);
    Ctx.project.saveGradleProperties(prop);
  }
 catch (  IOException e) {
    Message.showMsg(getStage(),""String_Node_Str"",3);
  }
}","/** 
 * Saves the selected version
 */
private void setCurrentVersion(String version){
  try {
    Properties prop=Ctx.project.getGradleProperties(Ctx.project.getProjectDir());
    prop.setProperty(""String_Node_Str"",version);
    Ctx.project.saveGradleProperties(prop,Ctx.project.getProjectDir());
  }
 catch (  IOException e) {
    Message.showMsg(getStage(),""String_Node_Str"",3);
  }
}",0.9624664879356568
30126,"private void updateDesc(){
  String idStr=(String)id.getText();
  int i=((OptionsInputPanel)id).getSelectedIndex();
  if (i == -1) {
    if (idStr.isEmpty())     setInfo(DEFAULT_DESC);
 else     setInfo(CUSTOM_VERB_DESC);
  }
 else {
    if (ScopePanel.SCENE_SCOPE.equals(scope)) {
      setInfo(SCENE_VERBS_INFO[i]);
    }
 else {
      setInfo(VERBS_INFO[i]);
    }
  }
  if (idStr != null && idStr.equals(""String_Node_Str""))   setVisible(target,true);
 else   setVisible(target,false);
  pack();
}","private void updateDesc(){
  String idStr=(String)id.getText();
  int i=((OptionsInputPanel)id).getSelectedIndex();
  if (i == -1) {
    if (idStr != null && idStr.isEmpty())     setInfo(DEFAULT_DESC);
 else     setInfo(CUSTOM_VERB_DESC);
  }
 else {
    if (ScopePanel.SCENE_SCOPE.equals(scope)) {
      setInfo(SCENE_VERBS_INFO[i]);
    }
 else {
      setInfo(VERBS_INFO[i]);
    }
  }
  if (idStr != null && idStr.equals(""String_Node_Str""))   setVisible(target,true);
 else   setVisible(target,false);
  pack();
}",0.983284169124877
30127,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  BladeJson bjson=(BladeJson)json;
  if (bjson.getMode() == Mode.MODEL) {
    id=json.readValue(""String_Node_Str"",String.class,jsonData);
    layers=json.readValue(""String_Node_Str"",ArrayList.class,SceneLayer.class,jsonData);
    actors=json.readValue(""String_Node_Str"",ConcurrentHashMap.class,BaseActor.class,jsonData);
    for (    BaseActor actor : actors.values()) {
      actor.setScene(this);
      actor.setInitScene(id);
      if (actor instanceof InteractiveActor) {
        InteractiveActor ia=(InteractiveActor)actor;
        SceneLayer layer=getLayer(ia.getLayer());
        layer.add(ia);
      }
    }
    orderLayersByZIndex();
    backgroundAtlas=json.readValue(""String_Node_Str"",String.class,jsonData);
    backgroundRegionId=json.readValue(""String_Node_Str"",String.class,jsonData);
    musicDesc=json.readValue(""String_Node_Str"",MusicDesc.class,jsonData);
    depthVector=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
    polygonalNavGraph=json.readValue(""String_Node_Str"",PolygonalNavGraph.class,jsonData);
    sceneSize=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
  }
 else {
    JsonValue jsonValueActors=jsonData.get(""String_Node_Str"");
    SceneActorRef actorRef;
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      Scene sourceScn=w.getScene(actorRef.getSceneId());
      if (sourceScn != this) {
        BaseActor actor=sourceScn.getActor(actorRef.getActorId(),false);
        sourceScn.removeActor(actor);
        addActor(actor);
      }
    }
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      BaseActor actor=getActor(actorRef.getActorId(),false);
      if (actor != null)       actor.read(json,jsonValueAct);
 else       EngineLogger.debug(""String_Node_Str"" + actorRef);
    }
    orderLayersByZIndex();
    camera=json.readValue(""String_Node_Str"",SceneCamera.class,jsonData);
    String followActorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (followActor != null)     setCameraFollowActor((SpriteActor)actors.get(followActorId));
    soundManager.read(json,jsonData);
    if (jsonData.get(""String_Node_Str"") != null)     timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    if (jsonData.get(""String_Node_Str"") != null) {
      textManager.read(json,jsonData.get(""String_Node_Str""));
    }
  }
  verbs.read(json,jsonData);
  state=json.readValue(""String_Node_Str"",String.class,jsonData);
  player=json.readValue(""String_Node_Str"",String.class,jsonData);
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  BladeJson bjson=(BladeJson)json;
  if (bjson.getMode() == Mode.MODEL) {
    id=json.readValue(""String_Node_Str"",String.class,jsonData);
    layers=json.readValue(""String_Node_Str"",ArrayList.class,SceneLayer.class,jsonData);
    actors=json.readValue(""String_Node_Str"",ConcurrentHashMap.class,BaseActor.class,jsonData);
    for (    BaseActor actor : actors.values()) {
      actor.setScene(this);
      actor.setInitScene(id);
      if (actor instanceof InteractiveActor) {
        InteractiveActor ia=(InteractiveActor)actor;
        SceneLayer layer=getLayer(ia.getLayer());
        layer.add(ia);
      }
    }
    orderLayersByZIndex();
    backgroundAtlas=json.readValue(""String_Node_Str"",String.class,jsonData);
    backgroundRegionId=json.readValue(""String_Node_Str"",String.class,jsonData);
    musicDesc=json.readValue(""String_Node_Str"",MusicDesc.class,jsonData);
    depthVector=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
    polygonalNavGraph=json.readValue(""String_Node_Str"",PolygonalNavGraph.class,jsonData);
    sceneSize=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
  }
 else {
    JsonValue jsonValueActors=jsonData.get(""String_Node_Str"");
    SceneActorRef actorRef;
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      Scene sourceScn=w.getScene(actorRef.getSceneId());
      if (sourceScn != this) {
        BaseActor actor=sourceScn.getActor(actorRef.getActorId(),false);
        sourceScn.removeActor(actor);
        addActor(actor);
      }
    }
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      BaseActor actor=getActor(actorRef.getActorId(),false);
      if (actor != null)       actor.read(json,jsonValueAct);
 else       EngineLogger.debug(""String_Node_Str"" + actorRef);
    }
    orderLayersByZIndex();
    camera=json.readValue(""String_Node_Str"",SceneCamera.class,jsonData);
    String followActorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (followActorId != null)     setCameraFollowActor((SpriteActor)actors.get(followActorId));
    soundManager.read(json,jsonData);
    if (jsonData.get(""String_Node_Str"") != null)     timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    if (jsonData.get(""String_Node_Str"") != null) {
      textManager.read(json,jsonData.get(""String_Node_Str""));
    }
  }
  verbs.read(json,jsonData);
  state=json.readValue(""String_Node_Str"",String.class,jsonData);
  player=json.readValue(""String_Node_Str"",String.class,jsonData);
}",0.9996387283236994
30128,"public static Object cloneElement(Object e){
  Json json=new BladeJson(Ctx.project.getWorld(),Mode.MODEL);
  if (e instanceof Action) {
    StringWriter buffer=new StringWriter();
    json.setWriter(buffer);
    ActionUtils.writeJson((Action)e,json);
    String str=buffer.toString();
    EditorLogger.debug(str);
    JsonValue root=new JsonReader().parse(str);
    return ActionUtils.readJson(Ctx.project.getWorld(),json,root);
  }
 else {
    String str=json.toJson(e,(Class<?>)null);
    return json.fromJson(e.getClass(),str);
  }
}","public static Object cloneElement(Object e){
  Json json=new BladeJson(Ctx.project.getWorld(),Mode.MODEL);
  if (e instanceof Action) {
    StringWriter buffer=new StringWriter();
    json.setWriter(buffer);
    ActionUtils.writeJson((Action)e,json);
    String str=buffer.toString();
    EditorLogger.debug(str);
    JsonValue root=new JsonReader().parse(str);
    return ActionUtils.readJson(Ctx.project.getWorld(),json,root);
  }
 else   if (e instanceof Scene) {
    String str=json.toJson(e,(Class<?>)null);
    Scene s=new Scene(((Scene)e).getWorld());
    JsonValue root=new JsonReader().parse(str);
    s.read(json,root);
    return s;
  }
 else {
    String str=json.toJson(e,(Class<?>)null);
    return json.fromJson(e.getClass(),str);
  }
}",0.8329448329448329
30129,"public void setVariable(String name,String value) throws Exception {
  if (story.getVariablesState().get(name) instanceof InkList) {
    InkList rawList=(InkList)story.getVariablesState().get(name);
    if (rawList.getOrigins() == null) {
      List<String> names=rawList.getOriginNames();
      if (names != null) {
        ArrayList<ListDefinition> origins=new ArrayList<ListDefinition>();
        for (        String n : names) {
          ListDefinition def=story.getListDefinitions().getDefinition(n);
          if (!origins.contains(def))           origins.add(def);
        }
        rawList.setOrigins(origins);
      }
    }
    rawList.addItem(value);
  }
 else   story.getVariablesState().set(name,value);
}","public synchronized void setVariable(String name,String value) throws Exception {
  if (story.getVariablesState().get(name) instanceof InkList) {
    InkList rawList=(InkList)story.getVariablesState().get(name);
    if (rawList.getOrigins() == null) {
      List<String> names=rawList.getOriginNames();
      if (names != null) {
        ArrayList<ListDefinition> origins=new ArrayList<ListDefinition>();
        for (        String n : names) {
          ListDefinition def=story.getListDefinitions().getDefinition(n);
          if (!origins.contains(def))           origins.add(def);
        }
        rawList.setOrigins(origins);
      }
    }
    rawList.addItem(value);
  }
 else   story.getVariablesState().set(name,value);
}",0.9910282953761216
30130,"public void cancel(){
  for (  Action c : actions) {
    if (c instanceof VerbRunner)     ((VerbRunner)c).cancel();
  }
  ip=actions.size() + 1;
  EngineLogger.debug(""String_Node_Str"" + id);
  if (cb != null)   cb.resume();
}","public void cancel(){
  ip=actions.size() + 1;
  for (  Action c : actions) {
    if (c instanceof VerbRunner)     ((VerbRunner)c).cancel();
  }
  if (cb != null) {
    ActionCallback cb2=cb;
    cb=null;
    cb2.resume();
  }
  EngineLogger.debug(""String_Node_Str"" + id);
}",0.685370741482966
30131,"public void nextStep(){
  boolean stop=false;
  while (!isFinished() && !stop) {
    Action a=actions.get(ip);
    if (EngineLogger.debugMode())     EngineLogger.debug(ip + ""String_Node_Str"" + a.getClass().getSimpleName());
    try {
      if (a.run(this))       stop=true;
 else       ip++;
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"" + a.getClass().getSimpleName() + ""String_Node_Str""+ e.getMessage(),e);
      ip++;
    }
  }
  if (ip == actions.size()) {
    EngineLogger.debug(""String_Node_Str"" + id);
    if (cb != null)     cb.resume();
  }
}","public void nextStep(){
  boolean stop=false;
  while (!isFinished() && !stop) {
    Action a=actions.get(ip);
    if (EngineLogger.debugMode())     EngineLogger.debug(ip + ""String_Node_Str"" + a.getClass().getSimpleName());
    try {
      if (a.run(this))       stop=true;
 else       ip++;
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"" + a.getClass().getSimpleName() + ""String_Node_Str""+ e.getMessage(),e);
      ip++;
    }
  }
  if (ip == actions.size()) {
    EngineLogger.debug(""String_Node_Str"" + id);
    if (cb != null) {
      ActionCallback cb2=cb;
      cb=null;
      cb2.resume();
    }
  }
}",0.9449465899753492
30132,"@Override public void create(){
  Gdx.graphics.setWindowedMode(Math.max((int)(Gdx.graphics.getDisplayMode().width * 0.9),1920 / 2),Math.max((int)(Gdx.graphics.getDisplayMode().height * 0.9),1080 / 2));
  skin=new BladeSkin(Gdx.files.internal(SKIN));
  VisUI.load();
  FileChooser.setDefaultPrefsName(""String_Node_Str"");
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  setCtx();
  Message.init(skin);
  scnEditor=new ScnEditor(skin);
  scnEditor.setBackground(""String_Node_Str"");
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table(skin);
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill().left();
  rightPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  splitPaneRight.setSplitAmount(0.75f);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table(skin);
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(0).left();
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill().left();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill().left();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill().left();
  leftPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.25f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
      if (!Ctx.project.checkVersion()) {
        new Dialog(""String_Node_Str"",skin){
          protected void result(          Object object){
            if (((Boolean)object).booleanValue()) {
              try {
                Ctx.project.updateEngineVersion();
                Message.showMsg(getStage(),""String_Node_Str"",3);
              }
 catch (              IOException e1) {
                String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                EditorLogger.error(msg,e1);
              }
            }
          }
        }
.text(""String_Node_Str"" + Ctx.project.getProjectBladeEngineVersion() + ""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(stage);
      }
    }
 catch (    Exception e) {
      EditorLogger.error(""String_Node_Str"",e);
      Ctx.project.closeProject();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().initialTime=0.2f;
  TooltipManager.getInstance().hideAll();
  TooltipManager.getInstance().subsequentTime=0.2f;
}","@Override public void create(){
  if (EditorLogger.debugMode()) {
    EngineLogger.setDebug();
  }
  Gdx.graphics.setWindowedMode(Math.max((int)(Gdx.graphics.getDisplayMode().width * 0.9),1920 / 2),Math.max((int)(Gdx.graphics.getDisplayMode().height * 0.9),1080 / 2));
  skin=new BladeSkin(Gdx.files.internal(SKIN));
  VisUI.load();
  FileChooser.setDefaultPrefsName(""String_Node_Str"");
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  setCtx();
  Message.init(skin);
  scnEditor=new ScnEditor(skin);
  scnEditor.setBackground(""String_Node_Str"");
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table(skin);
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill().left();
  rightPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  splitPaneRight.setSplitAmount(0.75f);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table(skin);
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(0).left();
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill().left();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill().left();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill().left();
  leftPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.25f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
      if (!Ctx.project.checkVersion()) {
        new Dialog(""String_Node_Str"",skin){
          protected void result(          Object object){
            if (((Boolean)object).booleanValue()) {
              try {
                Ctx.project.updateEngineVersion();
                Message.showMsg(getStage(),""String_Node_Str"",3);
              }
 catch (              IOException e1) {
                String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                EditorLogger.error(msg,e1);
              }
            }
          }
        }
.text(""String_Node_Str"" + Ctx.project.getProjectBladeEngineVersion() + ""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(stage);
      }
    }
 catch (    Exception e) {
      EditorLogger.error(""String_Node_Str"",e);
      Ctx.project.closeProject();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().initialTime=0.2f;
  TooltipManager.getInstance().hideAll();
  TooltipManager.getInstance().subsequentTime=0.2f;
}",0.9899505024748764
30133,"private static void parseArgs(String[] args){
  for (int i=1; i < args.length; i++) {
    if (args[i - 1].equals(""String_Node_Str"")) {
      try {
        File file=new File(args[i]).getCanonicalFile();
        Ctx.project.loadProject(file);
      }
 catch (      Exception ex) {
        EditorLogger.printStackTrace(ex);
      }
    }
 else     if (args[i].equals(""String_Node_Str"")) {
      EditorLogger.setDebug();
    }
  }
}","private static void parseArgs(String[] args){
  for (int i=0; i < args.length; i++) {
    if (args[i].equals(""String_Node_Str"") && i < args.length - 1) {
      try {
        File file=new File(args[i + 1]).getCanonicalFile();
        Ctx.project.loadProject(file);
      }
 catch (      Exception ex) {
        EditorLogger.printStackTrace(ex);
      }
    }
 else     if (args[i].equals(""String_Node_Str"")) {
      EditorLogger.setDebugLevel(Levels.DEBUG);
    }
  }
}",0.3585746102449889
30134,"public static void setDebug(){
  level=Levels.DEBUG;
  console.setLoggingToSystem(true);
}","public static void setDebug(){
  level=Levels.DEBUG;
  EngineLogger.setDebug();
  console.setLoggingToSystem(true);
}",0.8695652173913043
30135,"@Override public boolean run(VerbRunner cb){
  w.enterScene(scene,init);
  return true;
}","@Override public boolean run(VerbRunner cb){
  w.setCurrentScene(scene,init);
  return true;
}",0.9508196721311476
30136,"private void restoreStandPose(CharacterActor a){
  if (a == null)   return;
  String fa=((AnimationRenderer)a.getRenderer()).getCurrentAnimationId();
  String talkAnim=animation != null ? animation : a.getTalkAnim();
  if (fa.startsWith(talkAnim)) {
    a.stand();
  }
  if (animation != null) {
    a.setTalkAnim(previousDefaultTalkAnim);
  }
}","private void restoreStandPose(CharacterActor a){
  if (a == null)   return;
  if (animation != null) {
    a.setTalkAnim(previousDefaultTalkAnim);
  }
}",0.6116700201207244
30137,"@Override public void resume(){
  BaseActor actor=w.getCurrentScene().getActor(characterName,false);
  if (characterTurn) {
    characterTurn=false;
    if (previousAnim != null) {
      SpriteActor player=w.getCurrentScene().getPlayer();
      player.startAnimation(previousAnim,null);
    }
    if (responseText != null) {
      Rectangle boundingRectangle=actor.getBBox().getBoundingRectangle();
      float x=boundingRectangle.getX() + boundingRectangle.getWidth() / 2;
      float y=boundingRectangle.getY() + boundingRectangle.getHeight();
      w.getCurrentScene().getTextManager().addText(responseText,x,y,false,Text.Type.TALK,((CharacterActor)actor).getTextColor(),null,actor.getId(),responseVoiceId,this);
      if (actor instanceof CharacterActor) {
        startTalkAnim((CharacterActor)actor);
      }
    }
 else {
      previousAnim=null;
      super.resume();
    }
  }
 else {
    if (actor instanceof SpriteActor && previousAnim != null) {
      ((SpriteActor)actor).startAnimation(previousAnim,null);
    }
    super.resume();
  }
}","@Override public void resume(){
  BaseActor actor=w.getCurrentScene().getActor(characterName,false);
  if (characterTurn) {
    characterTurn=false;
    if (previousAnim != null) {
      SpriteActor player=w.getCurrentScene().getPlayer();
      player.startAnimation(previousAnim,null);
    }
    if (responseText != null) {
      Rectangle boundingRectangle=actor.getBBox().getBoundingRectangle();
      float x=boundingRectangle.getX() + boundingRectangle.getWidth() / 2;
      float y=boundingRectangle.getY() + boundingRectangle.getHeight();
      if (actor instanceof CharacterActor) {
        startTalkAnim((CharacterActor)actor);
      }
      w.getCurrentScene().getTextManager().addText(responseText,x,y,false,Text.Type.TALK,((CharacterActor)actor).getTextColor(),null,actor.getId(),responseVoiceId,this);
    }
 else {
      previousAnim=null;
      super.resume();
    }
  }
 else {
    if (actor instanceof SpriteActor && previousAnim != null) {
      ((SpriteActor)actor).startAnimation(previousAnim,null);
    }
    super.resume();
  }
}",0.9058039961941008
30138,"private void restoreStandPose(CharacterActor a){
  if (a == null)   return;
  String fa=((AnimationRenderer)a.getRenderer()).getCurrentAnimationId();
  if (fa.startsWith(a.getTalkAnim())) {
    a.stand();
  }
}","private void restoreStandPose(CharacterActor a){
  if (a == null)   return;
}",0.5365853658536586
30139,"@Override public boolean run(VerbRunner cb){
  if (w.getCurrentDialog() == null || w.getCurrentDialog().getCurrentOption() == null) {
    EngineLogger.debug(""String_Node_Str"");
    return false;
  }
  setVerbCb(cb);
  DialogOption o=w.getCurrentDialog().getCurrentOption();
  String playerText=o.getText();
  responseText=o.getResponseText();
  responseVoiceId=o.getResponseVoiceId();
  characterName=w.getCurrentDialog().getActor().getId();
  characterTurn=true;
  previousAnim=null;
  restoreStandPose(w.getCurrentScene().getPlayer());
  if (w.getCurrentScene().getActor(characterName,false) instanceof SpriteActor)   restoreStandPose((CharacterActor)w.getCurrentScene().getActor(characterName,false));
  if (playerText != null) {
    CharacterActor player=w.getCurrentScene().getPlayer();
    Rectangle boundingRectangle=player.getBBox().getBoundingRectangle();
    float x=boundingRectangle.getX() + boundingRectangle.getWidth() / 2;
    float y=boundingRectangle.getY() + boundingRectangle.getHeight();
    w.getCurrentScene().getTextManager().addText(playerText,x,y,false,Text.Type.TALK,player.getTextColor(),null,player.getId(),o.getVoiceId(),this);
    startTalkAnim(player);
  }
 else {
    resume();
  }
  return getWait();
}","@Override public boolean run(VerbRunner cb){
  if (w.getCurrentDialog() == null || w.getCurrentDialog().getCurrentOption() == null) {
    EngineLogger.debug(""String_Node_Str"");
    return false;
  }
  setVerbCb(cb);
  DialogOption o=w.getCurrentDialog().getCurrentOption();
  String playerText=o.getText();
  responseText=o.getResponseText();
  responseVoiceId=o.getResponseVoiceId();
  characterName=w.getCurrentDialog().getActor().getId();
  characterTurn=true;
  previousAnim=null;
  restoreStandPose(w.getCurrentScene().getPlayer());
  if (w.getCurrentScene().getActor(characterName,false) instanceof SpriteActor)   restoreStandPose((CharacterActor)w.getCurrentScene().getActor(characterName,false));
  if (playerText != null) {
    CharacterActor player=w.getCurrentScene().getPlayer();
    Rectangle boundingRectangle=player.getBBox().getBoundingRectangle();
    float x=boundingRectangle.getX() + boundingRectangle.getWidth() / 2;
    float y=boundingRectangle.getY() + boundingRectangle.getHeight();
    startTalkAnim(player);
    w.getCurrentScene().getTextManager().addText(playerText,x,y,false,Text.Type.TALK,player.getTextColor(),null,player.getId(),o.getVoiceId(),this);
  }
 else {
    resume();
  }
  return getWait();
}",0.9465587044534411
30140,"private void processCommand(HashMap<String,String> params,String line){
  String commandName=null;
  String commandParams[]=null;
  int i=line.indexOf(NAME_VALUE_TAG_SEPARATOR);
  if (i == -1) {
    commandName=line.substring(1).trim();
  }
 else {
    commandName=line.substring(1,i).trim();
    commandParams=line.substring(i + 1).split(PARAM_SEPARATOR);
    processParams(Arrays.asList(commandParams),params);
  }
  if (""String_Node_Str"".equals(commandName)) {
    boolean init=true;
    if (params.get(""String_Node_Str"") != null)     init=Boolean.parseBoolean(params.get(""String_Node_Str""));
    w.enterScene(params.get(""String_Node_Str""),init);
  }
 else   if (""String_Node_Str"".equals(commandName)) {
    w.setModelProp(params.get(""String_Node_Str""),params.get(""String_Node_Str""));
  }
 else {
    if (""String_Node_Str"".equals(commandName)) {
      commandName=commandParams[0].trim();
      params.remove(commandName);
    }
    if (commandName.length() > 0 && Character.isUpperCase(commandName.charAt(0))) {
      Action action;
      try {
        action=ActionFactory.createByClass(""String_Node_Str"" + commandName + ""String_Node_Str"",params);
        action.init(w);
        actions.add(action);
      }
 catch (      ClassNotFoundException|ReflectionException e) {
        EngineLogger.error(e.getMessage(),e);
      }
    }
 else {
      EngineLogger.error(""String_Node_Str"" + commandName);
    }
  }
}","private void processCommand(HashMap<String,String> params,String line){
  String commandName=null;
  String commandParams[]=null;
  int i=line.indexOf(NAME_VALUE_TAG_SEPARATOR);
  if (i == -1) {
    commandName=line.substring(1).trim();
  }
 else {
    commandName=line.substring(1,i).trim();
    commandParams=line.substring(i + 1).split(PARAM_SEPARATOR);
    processParams(Arrays.asList(commandParams),params);
  }
  if (""String_Node_Str"".equals(commandName)) {
    boolean init=true;
    if (params.get(""String_Node_Str"") != null)     init=Boolean.parseBoolean(params.get(""String_Node_Str""));
    w.setCurrentScene(params.get(""String_Node_Str""),init);
  }
 else   if (""String_Node_Str"".equals(commandName)) {
    w.setModelProp(params.get(""String_Node_Str""),params.get(""String_Node_Str""));
  }
 else {
    if (""String_Node_Str"".equals(commandName)) {
      commandName=commandParams[0].trim();
      params.remove(commandName);
    }
    if (commandName.length() > 0 && Character.isUpperCase(commandName.charAt(0))) {
      Action action;
      try {
        action=ActionFactory.createByClass(""String_Node_Str"" + commandName + ""String_Node_Str"",params);
        action.init(w);
        actions.add(action);
      }
 catch (      ClassNotFoundException|ReflectionException e) {
        EngineLogger.error(e.getMessage(),e);
      }
    }
 else {
      EngineLogger.error(""String_Node_Str"" + commandName);
    }
  }
}",0.9947052594422874
30141,"/** 
 * Actions to do when setting an animation: - play animation sound - add 'in' distance
 * @param repeatType
 */
protected void outAnim(Type repeatType){
  AnimationDesc fa=((AnimationRenderer)renderer).getCurrentAnimation();
  if (fa != null) {
    if (fa.sound != null && repeatType != Tween.Type.REVERSE) {
      String sid=fa.sound;
      if (scene != null && scene.getWorld().getSounds().get(sid) == null)       sid=id + ""String_Node_Str"" + fa.sound;
      if (scene != null)       scene.getSoundManager().playSound(sid);
 else       scene.getWorld().getCurrentScene().getSoundManager().playSound(sid);
    }
    Vector2 inD=fa.inD;
    if (inD != null) {
      float s=EngineAssetManager.getInstance().getScale();
      setPosition(getX() + inD.x * s,getY() + inD.y * s);
    }
  }
}","/** 
 * Actions to do when setting an animation: - play animation sound - add 'in' distance
 * @param repeatType
 */
protected void outAnim(Type repeatType){
  AnimationDesc fa=((AnimationRenderer)renderer).getCurrentAnimation();
  if (fa != null) {
    if (fa.sound != null && repeatType != Tween.Type.REVERSE) {
      String sid=fa.sound;
      if (scene != null && scene.getWorld().getSounds().get(sid) == null)       sid=id + ""String_Node_Str"" + fa.sound;
      if (scene != null)       scene.getSoundManager().playSound(sid);
    }
    Vector2 inD=fa.inD;
    if (inD != null) {
      float s=EngineAssetManager.getInstance().getScale();
      setPosition(getX() + inD.x * s,getY() + inD.y * s);
    }
  }
}",0.9461794019933556
30142,"/** 
 * Actions to do when setting an animation: - stop previous animation sound - add 'out' distance from previous animation
 */
protected void inAnim(){
  AnimationDesc fa=((AnimationRenderer)renderer).getCurrentAnimation();
  if (fa != null) {
    if (fa.sound != null) {
      String sid=fa.sound;
      if (scene != null && scene.getWorld().getSounds().get(sid) == null)       sid=id + ""String_Node_Str"" + fa.sound;
      if (scene != null)       scene.getSoundManager().stopSound(sid);
 else       scene.getWorld().getCurrentScene().getSoundManager().stopSound(sid);
    }
    Vector2 outD=fa.outD;
    if (outD != null) {
      float s=EngineAssetManager.getInstance().getScale();
      setPosition(getX() + outD.x * s,getY() + outD.y * s);
    }
  }
}","/** 
 * Actions to do when setting an animation: - stop previous animation sound - add 'out' distance from previous animation
 */
protected void inAnim(){
  AnimationDesc fa=((AnimationRenderer)renderer).getCurrentAnimation();
  if (fa != null) {
    if (fa.sound != null) {
      String sid=fa.sound;
      if (scene != null && scene.getWorld().getSounds().get(sid) == null)       sid=id + ""String_Node_Str"" + fa.sound;
      if (scene != null)       scene.getSoundManager().stopSound(sid);
    }
    Vector2 outD=fa.outD;
    if (outD != null) {
      float s=EngineAssetManager.getInstance().getScale();
      setPosition(getX() + outD.x * s,getY() + outD.y * s);
    }
  }
}",0.9436325678496869
30143,"public void setCurrentScene(Scene s){
  currentScene=s;
}","public void setCurrentScene(String id,boolean init){
  if (id.equals(""String_Node_Str"" + WorldProperties.PREVIOUS_SCENE.toString()))   id=getCustomProperty(WorldProperties.PREVIOUS_SCENE.toString());
  Scene s=scenes.get(id);
  if (s != null) {
    setCurrentScene(s,init);
  }
 else {
    EngineLogger.error(""String_Node_Str"" + id);
  }
}",0.1919191919191919
30144,"public void loadChapter(String chapter,String scene,boolean test) throws Exception {
  if (test)   this.testScene=scene;
  serialization.loadChapter(chapter);
  if (scene != null) {
    currentScene=null;
    enterScene(scene,true);
  }
}","public void loadChapter(String chapter,String scene,boolean test) throws Exception {
  if (test)   this.testScene=scene;
  serialization.loadChapter(chapter);
  if (scene != null) {
    currentScene=null;
    setCurrentScene(scene,true);
  }
}",0.9688149688149688
30145,"@Override public void read(Json json,JsonValue jsonData){
  BladeJson bjson=(BladeJson)json;
  if (bjson.getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    JsonValue jsonSounds=jsonData.get(""String_Node_Str"");
    HashMap<String,SoundDesc> sounds=w.getSounds();
    for (int i=0; i < jsonSounds.size; i++) {
      JsonValue jsonValue=jsonSounds.get(i);
      SoundDesc s=json.readValue(SoundDesc.class,jsonValue);
      sounds.put(jsonValue.name,s);
    }
    JsonValue jsonScenes=jsonData.get(""String_Node_Str"");
    Map<String,Scene> scenes=w.getScenes();
    for (int i=0; i < jsonScenes.size; i++) {
      JsonValue jsonValue=jsonScenes.get(i);
      Scene s=new Scene(w);
      scenes.put(jsonValue.name,s);
      s.read(json,jsonValue);
    }
    w.setInitScene(json.readValue(""String_Node_Str"",String.class,jsonData));
    if (w.getInitScene() == null && w.getScenes().size() > 0) {
      w.setInitScene(w.getScenes().keySet().toArray(new String[0])[0]);
    }
    for (    Scene s : w.getScenes().values()) {
      s.resetCamera(w.getWidth(),w.getHeight());
    }
    w.setCurrentScene(w.getScenes().get(w.getInitScene()));
    cacheSounds();
  }
 else {
    String bladeVersion=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (bladeVersion != null && !bladeVersion.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + bladeVersion + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    String version=json.readValue(Config.VERSION_PROP,String.class,jsonData);
    if (version == null)     version=""String_Node_Str"";
    String currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    w.setCurrentScene(w.getScene(json.readValue(""String_Node_Str"",String.class,jsonData)));
    if (jsonData.get(""String_Node_Str"") != null) {
      w.getInkManager().read(json,jsonData.get(""String_Node_Str""));
    }
    w.setCurrentInventory(json.readValue(""String_Node_Str"",String.class,jsonData));
    JsonValue jsonInventories=jsonData.get(""String_Node_Str"");
    for (int i=0; i < jsonInventories.size; i++) {
      JsonValue jsonValue=jsonInventories.get(i);
      Inventory inv=new Inventory();
      w.getInvetories().put(jsonValue.name,inv);
      inv.read(json,jsonValue);
    }
    if (jsonData.get(""String_Node_Str"") != null) {
      w.getUIActors().read(json,jsonData.get(""String_Node_Str""));
    }
    for (    Scene s : w.getScenes().values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    w.setTimeOfGame(json.readValue(""String_Node_Str"",long.class,0L,jsonData));
    w.setCutMode(json.readValue(""String_Node_Str"",boolean.class,false,jsonData));
    w.getVerbManager().read(json,jsonData);
    JsonValue jsonProperties=jsonData.get(""String_Node_Str"");
    HashMap<String,String> props=w.getCustomProperties();
    for (int i=0; i < jsonProperties.size; i++) {
      JsonValue jsonValue=jsonProperties.get(i);
      props.put(jsonValue.name,json.readValue(""String_Node_Str"",String.class,jsonData));
    }
    props.put(WorldProperties.SAVED_GAME_VERSION.toString(),version);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)w.getCurrentScene().getActor(actorId,false);
      w.setCurrentDialog(actor.getDialog(dialogId));
    }
    w.getTransition().read(json,jsonData.get(""String_Node_Str""));
    w.getMusicManager().read(json,jsonData.get(""String_Node_Str""));
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + w.getCurrentChapter());
  }
}","@Override public void read(Json json,JsonValue jsonData){
  BladeJson bjson=(BladeJson)json;
  if (bjson.getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    JsonValue jsonSounds=jsonData.get(""String_Node_Str"");
    HashMap<String,SoundDesc> sounds=w.getSounds();
    for (int i=0; i < jsonSounds.size; i++) {
      JsonValue jsonValue=jsonSounds.get(i);
      SoundDesc s=json.readValue(SoundDesc.class,jsonValue);
      sounds.put(jsonValue.name,s);
    }
    JsonValue jsonScenes=jsonData.get(""String_Node_Str"");
    Map<String,Scene> scenes=w.getScenes();
    for (int i=0; i < jsonScenes.size; i++) {
      JsonValue jsonValue=jsonScenes.get(i);
      Scene s=new Scene(w);
      scenes.put(jsonValue.name,s);
      s.read(json,jsonValue);
    }
    w.setInitScene(json.readValue(""String_Node_Str"",String.class,jsonData));
    if (w.getInitScene() == null && w.getScenes().size() > 0) {
      w.setInitScene(w.getScenes().keySet().toArray(new String[0])[0]);
    }
    for (    Scene s : w.getScenes().values()) {
      s.resetCamera(w.getWidth(),w.getHeight());
    }
    w.setCurrentScene(w.getScenes().get(w.getInitScene()),true);
    cacheSounds();
  }
 else {
    String bladeVersion=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (bladeVersion != null && !bladeVersion.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + bladeVersion + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    String version=json.readValue(Config.VERSION_PROP,String.class,jsonData);
    if (version == null)     version=""String_Node_Str"";
    String currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    w.setCurrentScene(w.getScene(json.readValue(""String_Node_Str"",String.class,jsonData)),false);
    if (jsonData.get(""String_Node_Str"") != null) {
      w.getInkManager().read(json,jsonData.get(""String_Node_Str""));
    }
    w.setCurrentInventory(json.readValue(""String_Node_Str"",String.class,jsonData));
    JsonValue jsonInventories=jsonData.get(""String_Node_Str"");
    for (int i=0; i < jsonInventories.size; i++) {
      JsonValue jsonValue=jsonInventories.get(i);
      Inventory inv=new Inventory();
      w.getInvetories().put(jsonValue.name,inv);
      inv.read(json,jsonValue);
    }
    if (jsonData.get(""String_Node_Str"") != null) {
      w.getUIActors().read(json,jsonData.get(""String_Node_Str""));
    }
    for (    Scene s : w.getScenes().values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    w.setTimeOfGame(json.readValue(""String_Node_Str"",long.class,0L,jsonData));
    w.setCutMode(json.readValue(""String_Node_Str"",boolean.class,false,jsonData));
    w.getVerbManager().read(json,jsonData);
    JsonValue jsonProperties=jsonData.get(""String_Node_Str"");
    HashMap<String,String> props=w.getCustomProperties();
    for (int i=0; i < jsonProperties.size; i++) {
      JsonValue jsonValue=jsonProperties.get(i);
      props.put(jsonValue.name,json.readValue(""String_Node_Str"",String.class,jsonData));
    }
    props.put(WorldProperties.SAVED_GAME_VERSION.toString(),version);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)w.getCurrentScene().getActor(actorId,false);
      w.setCurrentDialog(actor.getDialog(dialogId));
    }
    w.getTransition().read(json,jsonData.get(""String_Node_Str""));
    w.getMusicManager().read(json,jsonData.get(""String_Node_Str""));
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + w.getCurrentChapter());
  }
}",0.9987357774968394
30146,"private void cacheSounds(){
  for (  Scene s : w.getScenes().values()) {
    HashMap<String,Verb> verbs=s.getVerbManager().getVerbs();
    for (    Verb v : verbs.values()) {
      ArrayList<Action> actions=v.getActions();
      for (      Action act : actions) {
        try {
          if (act instanceof SoundAction) {
            String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
            String play=ActionUtils.getStringValue(act,""String_Node_Str"");
            if (play != null) {
              SoundDesc sd=w.getSounds().get(actor + ""String_Node_Str"" + play);
              if (sd != null)               s.getSoundManager().addSoundToLoad(sd);
            }
          }
 else           if (act instanceof PlaySoundAction) {
            String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
            SoundDesc sd=w.getSounds().get(sound);
            if (sd != null && sd.isPreload())             s.getSoundManager().addSoundToLoad(sd);
          }
        }
 catch (        NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
        }
      }
    }
    for (    BaseActor a : s.getActors().values()) {
      if (a instanceof InteractiveActor) {
        HashMap<String,Verb> actorVerbs=((InteractiveActor)a).getVerbManager().getVerbs();
        for (        Verb v : actorVerbs.values()) {
          ArrayList<Action> actions=v.getActions();
          for (          Action act : actions) {
            try {
              if (act instanceof SoundAction) {
                String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
                String play=ActionUtils.getStringValue(act,""String_Node_Str"");
                if (play != null) {
                  SoundDesc sd=w.getSounds().get(actor + ""String_Node_Str"" + play);
                  if (sd != null)                   s.getSoundManager().addSoundToLoad(sd);
                }
              }
 else               if (act instanceof PlaySoundAction) {
                String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
                SoundDesc sd=w.getSounds().get(sound);
                if (sd != null && sd.isPreload())                 s.getSoundManager().addSoundToLoad(sd);
              }
            }
 catch (            NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
            }
          }
        }
      }
      if (a instanceof SpriteActor && ((SpriteActor)a).getRenderer() instanceof AnimationRenderer) {
        HashMap<String,AnimationDesc> anims=((AnimationRenderer)((SpriteActor)a).getRenderer()).getAnimations();
        for (        AnimationDesc ad : anims.values()) {
          if (ad.sound != null) {
            String sid=ad.sound;
            SoundDesc sd=w.getSounds().get(sid);
            if (sd == null)             sid=a.getId() + ""String_Node_Str"" + sid;
            sd=w.getSounds().get(sid);
            if (sd != null && sd.isPreload())             s.getSoundManager().addSoundToLoad(sd);
 else             EngineLogger.error(a.getId() + ""String_Node_Str"" + ad.sound+ ""String_Node_Str""+ ad.id);
          }
        }
      }
    }
  }
}","private void cacheSounds(){
  for (  Scene s : w.getScenes().values()) {
    HashMap<String,Verb> verbs=s.getVerbManager().getVerbs();
    for (    Verb v : verbs.values()) {
      ArrayList<Action> actions=v.getActions();
      for (int i=0; i < actions.size(); i++) {
        Action act=actions.get(i);
        try {
          if (act instanceof SoundAction) {
            String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
            String play=ActionUtils.getStringValue(act,""String_Node_Str"");
            if (play != null) {
              SoundDesc sd=w.getSounds().get(actor + ""String_Node_Str"" + play);
              if (sd != null)               s.getSoundManager().addSoundToLoad(sd);
              HashMap<String,String> params=new HashMap<String,String>();
              params.put(""String_Node_Str"",sd.getId());
              try {
                Action a2=ActionFactory.createByClass(PlaySoundAction.class.getName(),params);
                actions.set(i,a2);
                a2.init(w);
              }
 catch (              ClassNotFoundException|ReflectionException e) {
                e.printStackTrace();
              }
              EngineLogger.debug(""String_Node_Str"" + s.getId() + ""String_Node_Str""+ v.getId());
            }
 else {
              EngineLogger.debug(""String_Node_Str"" + s.getId() + ""String_Node_Str""+ v.getId());
            }
          }
 else           if (act instanceof PlaySoundAction) {
            String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
            SoundDesc sd=w.getSounds().get(sound);
            if (sd != null && sd.isPreload())             s.getSoundManager().addSoundToLoad(sd);
          }
        }
 catch (        NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
        }
      }
    }
    for (    BaseActor a : s.getActors().values()) {
      if (a instanceof InteractiveActor) {
        HashMap<String,Verb> actorVerbs=((InteractiveActor)a).getVerbManager().getVerbs();
        for (        Verb v : actorVerbs.values()) {
          ArrayList<Action> actions=v.getActions();
          for (int i=0; i < actions.size(); i++) {
            Action act=actions.get(i);
            try {
              if (act instanceof SoundAction) {
                String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
                String play=ActionUtils.getStringValue(act,""String_Node_Str"");
                if (play != null) {
                  SoundDesc sd=w.getSounds().get(actor + ""String_Node_Str"" + play);
                  if (sd != null)                   s.getSoundManager().addSoundToLoad(sd);
                  HashMap<String,String> params=new HashMap<String,String>();
                  params.put(""String_Node_Str"",sd.getId());
                  try {
                    Action a2=ActionFactory.createByClass(PlaySoundAction.class.getName(),params);
                    actions.set(i,a2);
                    a2.init(w);
                  }
 catch (                  ClassNotFoundException|ReflectionException e) {
                    e.printStackTrace();
                  }
                  EngineLogger.debug(""String_Node_Str"" + s.getId() + ""String_Node_Str""+ a.getId()+ ""String_Node_Str""+ v.getId());
                }
 else {
                  EngineLogger.debug(""String_Node_Str"" + s.getId() + ""String_Node_Str""+ a.getId()+ ""String_Node_Str""+ v.getId());
                }
              }
 else               if (act instanceof PlaySoundAction) {
                String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
                SoundDesc sd=w.getSounds().get(sound);
                if (sd != null && sd.isPreload())                 s.getSoundManager().addSoundToLoad(sd);
              }
            }
 catch (            NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
            }
          }
        }
      }
      if (a instanceof SpriteActor && ((SpriteActor)a).getRenderer() instanceof AnimationRenderer) {
        HashMap<String,AnimationDesc> anims=((AnimationRenderer)((SpriteActor)a).getRenderer()).getAnimations();
        for (        AnimationDesc ad : anims.values()) {
          if (ad.sound != null) {
            String sid=ad.sound;
            SoundDesc sd=w.getSounds().get(sid);
            if (sd == null)             sid=a.getId() + ""String_Node_Str"" + sid;
            sd=w.getSounds().get(sid);
            if (sd != null) {
              if (sd.isPreload())               s.getSoundManager().addSoundToLoad(sd);
            }
 else             EngineLogger.error(a.getId() + ""String_Node_Str"" + ad.sound+ ""String_Node_Str""+ ad.id);
          }
        }
      }
    }
  }
}",0.7480214449834056
30147,"@Override public void show(){
  float size=DPIUtils.getPrefButtonSize();
  float margin=DPIUtils.getMarginSize();
  stage=new Stage(new ScreenViewport());
  table=new Table(ui.getSkin());
  table.setFillParent(true);
  table.left().top();
  table.pad(margin);
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setCurrentScreen(Screens.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  Button back=new Button(ui.getSkin(),""String_Node_Str"");
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  Label title=new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  Table header=new Table();
  header.padBottom(margin);
  Container<Button> cont=new Container<Button>(back);
  cont.size(size);
  header.add(cont);
  header.add(title).fillX().expandX().left();
  table.add(header).colspan(3).fillX().expandX().left();
  speedText=new TextField(Float.toString(((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getSpeed()),ui.getSkin());
  TextButton speedButton=new TextButton(""String_Node_Str"",ui.getSkin());
  speedButton.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      scnScr.setSpeed(Float.parseFloat(speedText.getText()));
    }
  }
);
  speedButton.pad(2,3,2,3);
  HorizontalGroup sGroup=new HorizontalGroup();
  sGroup.space(10);
  sGroup.addActor(speedText);
  sGroup.addActor(speedButton);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(sGroup);
  final Recorder r=ui.getRecorder();
  TextButton play=new TextButton(r.isPlaying() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  rec=new TextButton(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  play.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final Recorder r=ui.getRecorder();
      if (!r.isPlaying()) {
        r.setFilename(recordings.getSelected());
        r.load();
        r.setPlaying(true);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
 else {
        r.setPlaying(false);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
    }
  }
);
  rec.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final Recorder r=ui.getRecorder();
      if (r.isPlaying()) {
        r.setPlaying(false);
      }
      if (!r.isRecording())       r.setFilename(recFilename.getText());
      r.setRecording(!r.isRecording());
      rec.setText(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"");
      if (r.isRecording())       ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  recordings=new SelectBox<String>(ui.getSkin());
  String[] testFiles=EngineAssetManager.getInstance().listAssetFiles(""String_Node_Str"");
  ArrayList<String> al=new ArrayList<String>();
  for (  String file : testFiles)   if (file.endsWith(Recorder.RECORD_EXT))   al.add(file.substring(0,file.indexOf(Recorder.RECORD_EXT)));
  FileHandle[] testFiles2=EngineAssetManager.getInstance().getUserFolder().list();
  for (  FileHandle file : testFiles2)   if (file.name().endsWith(Recorder.RECORD_EXT))   al.add(file.name().substring(0,file.name().indexOf(Recorder.RECORD_EXT)));
  recordings.setItems(al.toArray(new String[al.size()]));
  play.pad(2,3,2,3);
  rec.pad(2,3,2,3);
  recFilename=new TextField(r.getFileName(),ui.getSkin());
  HorizontalGroup rGroup=new HorizontalGroup();
  rGroup.space(10);
  rGroup.addActor(recordings);
  rGroup.addActor(play);
  rGroup.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  rGroup.addActor(recFilename);
  rGroup.addActor(rec);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(rGroup);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  HorizontalGroup chGroup=new HorizontalGroup();
  chGroup.space(10);
  final TextField chapter=new TextField(""String_Node_Str"",ui.getSkin());
  chGroup.addActor(chapter);
  TextButton loadButton=new TextButton(""String_Node_Str"",ui.getSkin());
  loadButton.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      String c=chapter.getText();
      if (!c.isEmpty()) {
        try {
          ui.getWorld().getSerializer().loadChapter(c);
          ui.setCurrentScreen(Screens.SCENE_SCREEN);
        }
 catch (        IOException e) {
          EngineLogger.error(""String_Node_Str"",e);
        }
      }
    }
  }
);
  chGroup.addActor(loadButton);
  table.add(chGroup);
  final TextButton testScene=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  final TextButton initScene=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  initScene.setChecked(true);
  TextButton go=new TextButton(""String_Node_Str"",ui.getSkin());
  go.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.getWorld().resume();
      ui.getWorld().setCutMode(false);
      if (testScene.isChecked())       ui.getWorld().setTestScene(scenes.getSelected());
      ui.getWorld().enterScene(scenes.getSelected(),initScene.isChecked());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  go.pad(2,3,2,3);
  scenes=new SelectBox<String>(ui.getSkin());
  scenes.setItems(ui.getWorld().getScenes().keySet().toArray(new String[ui.getWorld().getScenes().size()]));
  HorizontalGroup scGroup=new HorizontalGroup();
  scGroup.space(10);
  scGroup.addActor(scenes);
  scGroup.addActor(go);
  scGroup.addActor(testScene);
  scGroup.addActor(initScene);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(scGroup);
  final TesterBot bot=ui.getTesterBot();
  TextButton runBot=new TextButton(bot.isEnabled() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  runBot.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setMaxWaitInverval(Float.parseFloat(testerTimeConf.getText()));
      bot.setInSceneTime(Float.parseFloat(inSceneTimeConf.getText()));
      bot.setExcludeList(testerExcludeList.getText());
      bot.setEnabled(!bot.isEnabled());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  runBot.pad(2,3,2,3);
  testerTimeConf=new TextField(Float.toString(bot.getMaxWaitInverval()),ui.getSkin());
  inSceneTimeConf=new TextField(Float.toString(bot.getInSceneTime()),ui.getSkin());
  testerExcludeList=new TextField(bot.getExcludeList(),ui.getSkin());
  TextButton testerLeaveConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerLeaveConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setRunLeaveVerbs(!bot.isRunLeaveVerbs());
    }
  }
);
  testerLeaveConf.setChecked(bot.isRunLeaveVerbs());
  TextButton testerGotoConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerGotoConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setRunGoto(!bot.isRunGoto());
    }
  }
);
  testerGotoConf.setChecked(bot.isRunGoto());
  TextButton testerPassText=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerPassText.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setPassTexts(!bot.isPassTexts());
    }
  }
);
  testerPassText.setChecked(bot.isPassTexts());
  TextButton testerWaitWhenWalking=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerWaitWhenWalking.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setWaitWhenWalking(!bot.isWaitWhenWalking());
    }
  }
);
  testerWaitWhenWalking.setChecked(bot.isWaitWhenWalking());
  HorizontalGroup botGroup=new HorizontalGroup();
  botGroup.space(10);
  botGroup.addActor(testerLeaveConf);
  botGroup.addActor(testerGotoConf);
  botGroup.addActor(testerPassText);
  botGroup.addActor(testerWaitWhenWalking);
  HorizontalGroup botGroup2=new HorizontalGroup();
  botGroup2.space(10);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  botGroup2.addActor(testerExcludeList);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  botGroup2.addActor(testerTimeConf);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  botGroup2.addActor(inSceneTimeConf);
  botGroup2.addActor(runBot);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(botGroup);
  table.row().pad(5).align(Align.left);
  table.add();
  table.add(botGroup2);
  String versionString=Config.getProperty(Config.TITLE_PROP,""String_Node_Str"") + ""String_Node_Str"" + Config.getProperty(Config.VERSION_PROP,""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ Config.getProperty(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ Config.getProperty(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  Label version=new Label(versionString,ui.getSkin(),""String_Node_Str"");
  version.setColor(Color.LIGHT_GRAY);
  Table versionStack=new Table();
  versionStack.defaults().pad(DPIUtils.getSpacing());
  versionStack.pad(0);
  versionStack.add(version);
  versionStack.bottom().left();
  versionStack.setFillParent(true);
  versionStack.pack();
  table.row();
  table.add(versionStack).colspan(3).left();
  table.pack();
  ScrollPane scrollPane=new ScrollPane(table);
  scrollPane.setFillParent(true);
  stage.addActor(scrollPane);
  pointer=new Pointer(ui.getSkin());
  stage.addActor(pointer);
  Gdx.input.setInputProcessor(stage);
}","@Override public void show(){
  float size=DPIUtils.getPrefButtonSize();
  float margin=DPIUtils.getMarginSize();
  stage=new Stage(new ScreenViewport());
  table=new Table(ui.getSkin());
  table.setFillParent(true);
  table.left().top();
  table.pad(margin);
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setCurrentScreen(Screens.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  Button back=new Button(ui.getSkin(),""String_Node_Str"");
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  Label title=new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  Table header=new Table();
  header.padBottom(margin);
  Container<Button> cont=new Container<Button>(back);
  cont.size(size);
  header.add(cont);
  header.add(title).fillX().expandX().left();
  table.add(header).colspan(3).fillX().expandX().left();
  speedText=new TextField(Float.toString(((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getSpeed()),ui.getSkin());
  TextButton speedButton=new TextButton(""String_Node_Str"",ui.getSkin());
  speedButton.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      scnScr.setSpeed(Float.parseFloat(speedText.getText()));
    }
  }
);
  speedButton.pad(2,3,2,3);
  HorizontalGroup sGroup=new HorizontalGroup();
  sGroup.space(10);
  sGroup.addActor(speedText);
  sGroup.addActor(speedButton);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(sGroup);
  final Recorder r=ui.getRecorder();
  TextButton play=new TextButton(r.isPlaying() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  rec=new TextButton(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  play.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final Recorder r=ui.getRecorder();
      if (!r.isPlaying()) {
        r.setFilename(recordings.getSelected());
        r.load();
        r.setPlaying(true);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
 else {
        r.setPlaying(false);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
    }
  }
);
  rec.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final Recorder r=ui.getRecorder();
      if (r.isPlaying()) {
        r.setPlaying(false);
      }
      if (!r.isRecording())       r.setFilename(recFilename.getText());
      r.setRecording(!r.isRecording());
      rec.setText(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"");
      if (r.isRecording())       ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  recordings=new SelectBox<String>(ui.getSkin());
  String[] testFiles=EngineAssetManager.getInstance().listAssetFiles(""String_Node_Str"");
  ArrayList<String> al=new ArrayList<String>();
  for (  String file : testFiles)   if (file.endsWith(Recorder.RECORD_EXT))   al.add(file.substring(0,file.indexOf(Recorder.RECORD_EXT)));
  FileHandle[] testFiles2=EngineAssetManager.getInstance().getUserFolder().list();
  for (  FileHandle file : testFiles2)   if (file.name().endsWith(Recorder.RECORD_EXT))   al.add(file.name().substring(0,file.name().indexOf(Recorder.RECORD_EXT)));
  recordings.setItems(al.toArray(new String[al.size()]));
  play.pad(2,3,2,3);
  rec.pad(2,3,2,3);
  recFilename=new TextField(r.getFileName(),ui.getSkin());
  HorizontalGroup rGroup=new HorizontalGroup();
  rGroup.space(10);
  rGroup.addActor(recordings);
  rGroup.addActor(play);
  rGroup.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  rGroup.addActor(recFilename);
  rGroup.addActor(rec);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(rGroup);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  HorizontalGroup chGroup=new HorizontalGroup();
  chGroup.space(10);
  final TextField chapter=new TextField(""String_Node_Str"",ui.getSkin());
  chGroup.addActor(chapter);
  TextButton loadButton=new TextButton(""String_Node_Str"",ui.getSkin());
  loadButton.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      String c=chapter.getText();
      if (!c.isEmpty()) {
        try {
          ui.getWorld().getSerializer().loadChapter(c);
          ui.setCurrentScreen(Screens.SCENE_SCREEN);
        }
 catch (        IOException e) {
          EngineLogger.error(""String_Node_Str"",e);
        }
      }
    }
  }
);
  chGroup.addActor(loadButton);
  table.add(chGroup);
  final TextButton testScene=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  final TextButton initScene=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  initScene.setChecked(true);
  TextButton go=new TextButton(""String_Node_Str"",ui.getSkin());
  go.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.getWorld().resume();
      ui.getWorld().setCutMode(false);
      if (testScene.isChecked())       ui.getWorld().setTestScene(scenes.getSelected());
      ui.getWorld().setCurrentScene(scenes.getSelected(),initScene.isChecked());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  go.pad(2,3,2,3);
  scenes=new SelectBox<String>(ui.getSkin());
  scenes.setItems(ui.getWorld().getScenes().keySet().toArray(new String[ui.getWorld().getScenes().size()]));
  HorizontalGroup scGroup=new HorizontalGroup();
  scGroup.space(10);
  scGroup.addActor(scenes);
  scGroup.addActor(go);
  scGroup.addActor(testScene);
  scGroup.addActor(initScene);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(scGroup);
  final TesterBot bot=ui.getTesterBot();
  TextButton runBot=new TextButton(bot.isEnabled() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  runBot.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setMaxWaitInverval(Float.parseFloat(testerTimeConf.getText()));
      bot.setInSceneTime(Float.parseFloat(inSceneTimeConf.getText()));
      bot.setExcludeList(testerExcludeList.getText());
      bot.setEnabled(!bot.isEnabled());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  runBot.pad(2,3,2,3);
  testerTimeConf=new TextField(Float.toString(bot.getMaxWaitInverval()),ui.getSkin());
  inSceneTimeConf=new TextField(Float.toString(bot.getInSceneTime()),ui.getSkin());
  testerExcludeList=new TextField(bot.getExcludeList(),ui.getSkin());
  TextButton testerLeaveConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerLeaveConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setRunLeaveVerbs(!bot.isRunLeaveVerbs());
    }
  }
);
  testerLeaveConf.setChecked(bot.isRunLeaveVerbs());
  TextButton testerGotoConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerGotoConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setRunGoto(!bot.isRunGoto());
    }
  }
);
  testerGotoConf.setChecked(bot.isRunGoto());
  TextButton testerPassText=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerPassText.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setPassTexts(!bot.isPassTexts());
    }
  }
);
  testerPassText.setChecked(bot.isPassTexts());
  TextButton testerWaitWhenWalking=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerWaitWhenWalking.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      final TesterBot bot=ui.getTesterBot();
      bot.setWaitWhenWalking(!bot.isWaitWhenWalking());
    }
  }
);
  testerWaitWhenWalking.setChecked(bot.isWaitWhenWalking());
  HorizontalGroup botGroup=new HorizontalGroup();
  botGroup.space(10);
  botGroup.addActor(testerLeaveConf);
  botGroup.addActor(testerGotoConf);
  botGroup.addActor(testerPassText);
  botGroup.addActor(testerWaitWhenWalking);
  HorizontalGroup botGroup2=new HorizontalGroup();
  botGroup2.space(10);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  botGroup2.addActor(testerExcludeList);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  botGroup2.addActor(testerTimeConf);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  botGroup2.addActor(inSceneTimeConf);
  botGroup2.addActor(runBot);
  table.row().pad(5).align(Align.left);
  table.add(new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str""));
  table.add(botGroup);
  table.row().pad(5).align(Align.left);
  table.add();
  table.add(botGroup2);
  String versionString=Config.getProperty(Config.TITLE_PROP,""String_Node_Str"") + ""String_Node_Str"" + Config.getProperty(Config.VERSION_PROP,""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ Config.getProperty(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ Config.getProperty(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  Label version=new Label(versionString,ui.getSkin(),""String_Node_Str"");
  version.setColor(Color.LIGHT_GRAY);
  Table versionStack=new Table();
  versionStack.defaults().pad(DPIUtils.getSpacing());
  versionStack.pad(0);
  versionStack.add(version);
  versionStack.bottom().left();
  versionStack.setFillParent(true);
  versionStack.pack();
  table.row();
  table.add(versionStack).colspan(3).left();
  table.pack();
  ScrollPane scrollPane=new ScrollPane(table);
  scrollPane.setFillParent(true);
  stage.addActor(scrollPane);
  pointer=new Pointer(ui.getSkin());
  stage.addActor(pointer);
  Gdx.input.setInputProcessor(stage);
}",0.9992916843745572
30148,"public static Object cloneElement(Object e){
  Json json=new Json();
  if (e instanceof Action) {
    StringWriter buffer=new StringWriter();
    json.setWriter(buffer);
    ActionUtils.writeJson((Action)e,json);
    String str=buffer.toString();
    EditorLogger.debug(str);
    JsonValue root=new JsonReader().parse(str);
    return ActionUtils.readJson(json,root);
  }
 else {
    SerializationHelper.getInstance().setMode(Mode.MODEL);
    String str=json.toJson(e,(Class<?>)null);
    return json.fromJson(e.getClass(),str);
  }
}","public static Object cloneElement(Object e){
  Json json=new Json();
  if (e instanceof Action) {
    StringWriter buffer=new StringWriter();
    json.setWriter(buffer);
    ActionUtils.writeJson((Action)e,json);
    String str=buffer.toString();
    EditorLogger.debug(str);
    JsonValue root=new JsonReader().parse(str);
    return ActionUtils.readJson(World.getInstance(),json,root);
  }
 else {
    SerializationHelper.getInstance().setMode(Mode.MODEL);
    String str=json.toJson(e,(Class<?>)null);
    return json.fromJson(e.getClass(),str);
  }
}",0.9816176470588236
30149,"public void save() throws IOException {
  new JsonSerializer(World.getInstance()).saveModel(id);
}","public void save() throws IOException {
  World.getInstance().getSerializer().saveModel(id);
}",0.8229166666666666
30150,"@Override public int compare(T o1,T o2){
  String s1=cellRenderer.getCellTitle(o1);
  String s2=cellRenderer.getCellTitle(o2);
  return s1.compareTo(s2);
}","@Override public int compare(T o1,T o2){
  String s1=cellRenderer.getCellTitle(o1);
  String s2=cellRenderer.getCellTitle(o2);
  if (s1 == null) {
    System.out.println(""String_Node_Str"");
  }
  return s1.compareTo(s2);
}",0.7586206896551724
30151,"public void sortByTitle(){
  getItems().sort(new Comparator<T>(){
    @Override public int compare(    T o1,    T o2){
      String s1=cellRenderer.getCellTitle(o1);
      String s2=cellRenderer.getCellTitle(o2);
      return s1.compareTo(s2);
    }
  }
);
}","public void sortByTitle(){
  getItems().sort(new Comparator<T>(){
    @Override public int compare(    T o1,    T o2){
      String s1=cellRenderer.getCellTitle(o1);
      String s2=cellRenderer.getCellTitle(o2);
      if (s1 == null) {
        System.out.println(""String_Node_Str"");
      }
      return s1.compareTo(s2);
    }
  }
);
}",0.8672268907563025
30152,"@Override public boolean run(VerbRunner cb){
  String actorId=animation.getActorId();
  SpriteActor a=(SpriteActor)World.getInstance().getCurrentScene().getActor(actorId,true);
  if (a.getRenderer() instanceof SpineRenderer) {
    SpineRenderer r=(SpineRenderer)a.getRenderer();
    String anim=animation.getAnimationId();
    if (anim.isEmpty())     anim=null;
    r.setSecondaryAnimation(anim);
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  String actorId=animation.getActorId();
  SpriteActor a=(SpriteActor)w.getCurrentScene().getActor(actorId,true);
  if (a.getRenderer() instanceof SpineRenderer) {
    SpineRenderer r=(SpineRenderer)a.getRenderer();
    String anim=animation.getAnimationId();
    if (anim.isEmpty())     anim=null;
    r.setSecondaryAnimation(anim);
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
  return false;
}",0.978448275862069
30153,"@Override public boolean run(VerbRunner cb){
  SpriteActor a=(SpriteActor)actor.getActor();
  if (a instanceof SpriteActor && a.getRenderer() instanceof SpineRenderer) {
    SpineRenderer r=(SpineRenderer)a.getRenderer();
    r.setSkin(skin);
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  SpriteActor a=(SpriteActor)actor.getActor(w);
  if (a instanceof SpriteActor && a.getRenderer() instanceof SpineRenderer) {
    SpineRenderer r=(SpineRenderer)a.getRenderer();
    r.setSkin(skin);
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
  return false;
}",0.9984350547730828
30154,"@Override public boolean run(VerbRunner cb){
  String p=World.getInstance().getCustomProperty(prop);
  int v=0;
  if (p != null) {
    try {
      v=Integer.parseInt(p);
    }
 catch (    NumberFormatException e) {
    }
  }
  v+=value;
  World.getInstance().setCustomProperty(prop,Integer.toString(v));
  EngineLogger.debug(""String_Node_Str"" + prop + ""String_Node_Str""+ World.getInstance().getCustomProperty(prop));
  return false;
}","@Override public boolean run(VerbRunner cb){
  String p=w.getCustomProperty(prop);
  int v=0;
  if (p != null) {
    try {
      v=Integer.parseInt(p);
    }
 catch (    NumberFormatException e) {
    }
  }
  v+=value;
  w.setCustomProperty(prop,Integer.toString(v));
  EngineLogger.debug(""String_Node_Str"" + prop + ""String_Node_Str""+ w.getCustomProperty(prop));
  return false;
}",0.9262899262899262
30155,"@Override public boolean run(VerbRunner cb){
  SpriteActor a=(SpriteActor)World.getInstance().getCurrentScene().getActor(actor,true);
  SpriteAlphaTween t=new SpriteAlphaTween();
  t.start(a,repeat,count,alpha,speed,interpolation,wait ? cb : null);
  a.addTween(t);
  return wait;
}","@Override public boolean run(VerbRunner cb){
  SpriteActor a=(SpriteActor)w.getCurrentScene().getActor(actor,true);
  SpriteAlphaTween t=new SpriteAlphaTween();
  t.start(a,repeat,count,alpha,speed,interpolation,wait ? cb : null);
  a.addTween(t);
  return wait;
}",0.4065934065934066
30156,"@Override public boolean run(VerbRunner cb){
  String actorId=animation.getActorId();
  SpriteActor a=(SpriteActor)World.getInstance().getCurrentScene().getActor(actorId,true);
  String anim=animation.getAnimationId();
  if (keepDirection) {
    String c=((AnimationRenderer)a.getRenderer()).getCurrentAnimationId();
    if (anim.endsWith(AnimationRenderer.LEFT) && c.endsWith(AnimationRenderer.RIGHT) || anim.endsWith(AnimationRenderer.RIGHT) && c.endsWith(AnimationRenderer.LEFT)) {
      anim=AnimationRenderer.getFlipId(anim);
    }
  }
  a.startAnimation(anim,repeat,count,wait ? cb : null);
  return wait;
}","@Override public boolean run(VerbRunner cb){
  String actorId=animation.getActorId();
  SpriteActor a=(SpriteActor)w.getCurrentScene().getActor(actorId,true);
  String anim=animation.getAnimationId();
  if (keepDirection) {
    String c=((AnimationRenderer)a.getRenderer()).getCurrentAnimationId();
    if (anim.endsWith(AnimationRenderer.LEFT) && c.endsWith(AnimationRenderer.RIGHT) || anim.endsWith(AnimationRenderer.RIGHT) && c.endsWith(AnimationRenderer.LEFT)) {
      anim=AnimationRenderer.getFlipId(anim);
    }
  }
  a.startAnimation(anim,repeat,count,wait ? cb : null);
  return wait;
}",0.9834437086092715
30157,"@Override public boolean run(VerbRunner cb){
  Vector2 pos2=null;
  Float zoom2=zoom;
  if (pos != null)   pos2=new Vector2(pos);
  float scale=EngineAssetManager.getInstance().getScale();
  SceneCamera camera=World.getInstance().getSceneCamera();
  if (zoom2 == null || zoom2 < 0)   zoom2=camera.getZoom();
  if (pos == null && target == null) {
    pos2=new Vector2(camera.getPosition());
    pos2.x/=scale;
    pos2.y/=scale;
  }
  if (target != null) {
    BaseActor target=World.getInstance().getCurrentScene().getActor(this.target,false);
    float x=target.getX();
    float y=target.getY();
    if (target instanceof InteractiveActor) {
      Vector2 refPoint=((InteractiveActor)target).getRefPoint();
      x+=refPoint.x;
      y+=refPoint.y;
    }
    if (pos2 != null) {
      pos2.x+=x;
      pos2.y+=y;
    }
 else {
      pos2=new Vector2(x,y);
    }
  }
  if (followActor != null) {
    if (followActor.equals(""String_Node_Str""))     World.getInstance().getCurrentScene().setCameraFollowActor(null);
 else {
      World.getInstance().getCurrentScene().setCameraFollowActor((SpriteActor)World.getInstance().getCurrentScene().getActor(followActor,false));
    }
  }
  if (duration == null || duration == 0) {
    camera.setZoom(zoom2);
    camera.setPosition(pos2.x * scale,pos2.y * scale);
    return false;
  }
 else {
    camera.startAnimation(pos2.x * scale,pos2.y * scale,zoom2,duration,interpolation,wait ? cb : null);
  }
  return wait;
}","@Override public boolean run(VerbRunner cb){
  Vector2 pos2=null;
  Float zoom2=zoom;
  if (pos != null)   pos2=new Vector2(pos);
  float scale=EngineAssetManager.getInstance().getScale();
  SceneCamera camera=w.getSceneCamera();
  if (zoom2 == null || zoom2 < 0)   zoom2=camera.getZoom();
  if (pos == null && target == null) {
    pos2=new Vector2(camera.getPosition());
    pos2.x/=scale;
    pos2.y/=scale;
  }
  if (target != null) {
    BaseActor target=w.getCurrentScene().getActor(this.target,false);
    float x=target.getX();
    float y=target.getY();
    if (target instanceof InteractiveActor) {
      Vector2 refPoint=((InteractiveActor)target).getRefPoint();
      x+=refPoint.x;
      y+=refPoint.y;
    }
    if (pos2 != null) {
      pos2.x+=x;
      pos2.y+=y;
    }
 else {
      pos2=new Vector2(x,y);
    }
  }
  if (followActor != null) {
    if (followActor.equals(""String_Node_Str""))     w.getCurrentScene().setCameraFollowActor(null);
 else {
      w.getCurrentScene().setCameraFollowActor((SpriteActor)w.getCurrentScene().getActor(followActor,false));
    }
  }
  if (duration == null || duration == 0) {
    camera.setZoom(zoom2);
    camera.setPosition(pos2.x * scale,pos2.y * scale);
    return false;
  }
 else {
    camera.startAnimation(pos2.x * scale,pos2.y * scale,zoom2,duration,interpolation,wait ? cb : null);
  }
  return wait;
}",0.9646142958244868
30158,"@Override public boolean run(VerbRunner cb){
  VerbRunner v=null;
  if (verb == null) {
    v=(VerbRunner)cb;
  }
  if (v == null && actor != null) {
    BaseActor a=World.getInstance().getCurrentScene().getActor(actor,true);
    v=((InteractiveActor)a).getVerb(verb,target);
  }
  if (v == null) {
    v=World.getInstance().getCurrentScene().getVerb(verb);
  }
  if (v == null) {
    v=World.getInstance().getVerbManager().getVerb(verb,null,null);
  }
  if (v != null) {
    v.cancel();
    World.getInstance().getCurrentScene().getTimers().removeTimerWithCb(v);
  }
 else   EngineLogger.error(""String_Node_Str"" + verb + ""String_Node_Str""+ actor);
  return false;
}","@Override public boolean run(VerbRunner cb){
  VerbRunner v=null;
  if (verb == null) {
    v=(VerbRunner)cb;
  }
  if (v == null && actor != null) {
    BaseActor a=w.getCurrentScene().getActor(actor,true);
    v=((InteractiveActor)a).getVerb(verb,target);
  }
  if (v == null) {
    v=w.getCurrentScene().getVerb(verb);
  }
  if (v == null) {
    v=w.getVerbManager().getVerb(verb,null,null);
  }
  if (v != null) {
    v.cancel();
    w.getCurrentScene().getTimers().removeTimerWithCb(v);
  }
 else   EngineLogger.error(""String_Node_Str"" + verb + ""String_Node_Str""+ actor);
  return false;
}",0.5984126984126984
30159,"@Override public boolean run(VerbRunner cb){
  if (EngineLogger.debugMode() && comment != null) {
    EngineLogger.debug(comment);
    if (debug)     World.getInstance().getCurrentScene().getTextManager().addText(comment,TextManager.POS_SUBTITLE,TextManager.POS_SUBTITLE,false,Text.Type.UI,Color.YELLOW,null,null,null,null);
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  if (EngineLogger.debugMode() && comment != null) {
    EngineLogger.debug(comment);
    if (debug)     w.getCurrentScene().getTextManager().addText(comment,TextManager.POS_SUBTITLE,TextManager.POS_SUBTITLE,false,Text.Type.UI,Color.YELLOW,null,null,null,null);
  }
  return false;
}",0.9703264094955488
30160,"public Action getAction(){
  if (action == null) {
    Json json=new Json();
    JsonValue root=new JsonReader().parse(serializedAction);
    action=ActionUtils.readJson(json,root);
  }
  return action;
}","public Action getAction(){
  if (action == null) {
    Json json=new Json();
    JsonValue root=new JsonReader().parse(serializedAction);
    action=ActionUtils.readJson(w,json,root);
  }
  return action;
}",0.9951219512195122
30161,"private void removeActor(Scene ts,BaseActor a){
  final World w=World.getInstance();
  float scale=EngineAssetManager.getInstance().getScale();
  w.getInventory().removeItem(a.getId());
  if (ts != w.getCurrentScene() && w.getCachedScene(ts.getId()) == null && a instanceof Disposable)   ((Disposable)a).dispose();
  ts.addActor(a);
  if (pos != null)   a.setPosition(pos.x * scale,pos.y * scale);
}","private void removeActor(Scene ts,BaseActor a){
  float scale=EngineAssetManager.getInstance().getScale();
  w.getInventory().removeItem(a.getId());
  if (ts != w.getCurrentScene() && w.getCachedScene(ts.getId()) == null && a instanceof Disposable)   ((Disposable)a).dispose();
  ts.addActor(a);
  if (pos != null)   a.setPosition(pos.x * scale,pos.y * scale);
}",0.9513797634691196
30162,"@Override public boolean run(VerbRunner cb){
  Scene ts=null;
  if (scene == null)   ts=World.getInstance().getCurrentScene();
 else   ts=World.getInstance().getScene(scene);
  BaseActor a;
  if (actor != null) {
    a=World.getInstance().getInventory().get(actor);
    if (a == null) {
      EngineLogger.error(MessageFormat.format(""String_Node_Str"",actor));
      return false;
    }
    removeActor(ts,a);
  }
 else {
    int n=World.getInstance().getInventory().getNumItems();
    for (int i=n - 1; i >= 0; i--) {
      a=World.getInstance().getInventory().get(i);
      removeActor(ts,a);
    }
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  Scene ts=null;
  if (scene == null)   ts=w.getCurrentScene();
 else   ts=w.getScene(scene);
  BaseActor a;
  if (actor != null) {
    a=w.getInventory().get(actor);
    if (a == null) {
      EngineLogger.error(MessageFormat.format(""String_Node_Str"",actor));
      return false;
    }
    removeActor(ts,a);
  }
 else {
    int n=w.getInventory().getNumItems();
    for (int i=n - 1; i >= 0; i--) {
      a=w.getInventory().get(i);
      removeActor(ts,a);
    }
  }
  return false;
}",0.9131944444444444
30163,"public void setVariable(String name,String value) throws Exception {
  if (story.getVariablesState().get(name) instanceof InkList) {
    InkList rawList=(InkList)story.getVariablesState().get(name);
    if (rawList.getOrigins() == null) {
      List<String> names=rawList.getOriginNames();
      if (names != null) {
        ArrayList<ListDefinition> origins=new ArrayList<ListDefinition>();
        for (        String n : names) {
          ListDefinition def=story.getListDefinitions().getDefinition(n);
          if (!origins.contains(def))           origins.add(def);
        }
        rawList.setOrigins(origins);
      }
    }
    rawList.addItem(value);
  }
 else   story.getVariablesState().set(name,value);
}","public synchronized void setVariable(String name,String value) throws Exception {
  if (story.getVariablesState().get(name) instanceof InkList) {
    InkList rawList=(InkList)story.getVariablesState().get(name);
    if (rawList.getOrigins() == null) {
      List<String> names=rawList.getOriginNames();
      if (names != null) {
        ArrayList<ListDefinition> origins=new ArrayList<ListDefinition>();
        for (        String n : names) {
          ListDefinition def=story.getListDefinitions().getDefinition(n);
          if (!origins.contains(def))           origins.add(def);
        }
        rawList.setOrigins(origins);
      }
    }
    rawList.addItem(value);
  }
 else   story.getVariablesState().set(name,value);
}",0.9910282953761216
30164,"public void cancel(){
  for (  Action c : actions) {
    if (c instanceof VerbRunner)     ((VerbRunner)c).cancel();
  }
  ip=actions.size() + 1;
  EngineLogger.debug(""String_Node_Str"" + id);
  if (cb != null)   cb.resume();
}","public void cancel(){
  ip=actions.size() + 1;
  for (  Action c : actions) {
    if (c instanceof VerbRunner)     ((VerbRunner)c).cancel();
  }
  if (cb != null) {
    ActionCallback cb2=cb;
    cb=null;
    cb2.resume();
  }
  EngineLogger.debug(""String_Node_Str"" + id);
}",0.685370741482966
30165,"public void nextStep(){
  boolean stop=false;
  while (!isFinished() && !stop) {
    Action a=actions.get(ip);
    if (EngineLogger.debugMode())     EngineLogger.debug(ip + ""String_Node_Str"" + a.getClass().getSimpleName());
    try {
      if (a.run(this))       stop=true;
 else       ip++;
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"" + a.getClass().getSimpleName() + ""String_Node_Str""+ e.getMessage(),e);
      ip++;
    }
  }
  if (ip == actions.size()) {
    EngineLogger.debug(""String_Node_Str"" + id);
    if (cb != null)     cb.resume();
  }
}","public void nextStep(){
  boolean stop=false;
  while (!isFinished() && !stop) {
    Action a=actions.get(ip);
    if (EngineLogger.debugMode())     EngineLogger.debug(ip + ""String_Node_Str"" + a.getClass().getSimpleName());
    try {
      if (a.run(this))       stop=true;
 else       ip++;
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"" + a.getClass().getSimpleName() + ""String_Node_Str""+ e.getMessage(),e);
      ip++;
    }
  }
  if (ip == actions.size()) {
    EngineLogger.debug(""String_Node_Str"" + id);
    if (cb != null) {
      ActionCallback cb2=cb;
      cb=null;
      cb2.resume();
    }
  }
}",0.9449465899753492
30166,"@Override protected void inputsToModel(boolean create){
  String type=typePanel.getText();
  boolean typeChanged=false;
  BaseActor oldElement=e;
  String oldId=e.getId();
  boolean isPlayer=false;
  if (!create) {
    typeChanged=(type.equals(CHARACTER_TYPE_STR) && !(e instanceof CharacterActor)) || (type.equals(SPRITE_TYPE_STR) && (!(e instanceof SpriteActor) || e instanceof CharacterActor)) || (type.equals(BACKGROUND_TYPE_STR) && (!(e instanceof InteractiveActor) || e instanceof SpriteActor))|| (type.equals(OBSTACLE_TYPE_STR) && !(e instanceof ObstacleActor))|| (type.equals(ANCHOR_TYPE_STR) && !(e instanceof AnchorActor));
    isPlayer=parent.getPlayer() == e;
    parent.removeActor(e);
  }
  if (create || typeChanged) {
    if (type.equals(BACKGROUND_TYPE_STR)) {
      e=new InteractiveActor();
    }
 else     if (type.equals(SPRITE_TYPE_STR)) {
      e=new SpriteActor();
    }
 else     if (type.equals(CHARACTER_TYPE_STR)) {
      e=new CharacterActor();
    }
 else     if (type.equals(OBSTACLE_TYPE_STR)) {
      e=new ObstacleActor();
    }
 else     if (type.equals(ANCHOR_TYPE_STR)) {
      e=new AnchorActor();
    }
    if (!(e instanceof SpriteActor) && !(e instanceof AnchorActor)) {
      Polygon bbox=e.getBBox();
      bbox.setVertices(new float[8]);
      float[] verts=bbox.getVertices();
      verts[0]=-DEFAULT_DIM / 2;
      verts[1]=0f;
      verts[2]=-DEFAULT_DIM / 2;
      verts[3]=DEFAULT_DIM;
      verts[4]=DEFAULT_DIM / 2;
      verts[5]=DEFAULT_DIM;
      verts[6]=DEFAULT_DIM / 2;
      verts[7]=0f;
      bbox.dirty();
    }
  }
  if (typeChanged) {
    if (oldElement instanceof InteractiveActor && e instanceof InteractiveActor) {
      HashMap<String,Verb> verbs=((InteractiveActor)e).getVerbManager().getVerbs();
      HashMap<String,Verb> oldVerbs=((InteractiveActor)oldElement).getVerbManager().getVerbs();
      for (      String k : oldVerbs.keySet()) {
        Verb v=oldVerbs.get(k);
        verbs.put(k,v);
      }
    }
    if (oldElement instanceof SpriteActor && e instanceof SpriteActor) {
      ((SpriteActor)e).setRenderer(((SpriteActor)oldElement).getRenderer());
    }
  }
  e.setId(ElementUtils.getCheckedId(id.getText(),parent.getActors().keySet().toArray(new String[0])));
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  Vector2 p=Param.parseVector2(pos.getText());
  e.setPosition(p.x,p.y);
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    ia.setLayer(layer.getText());
    ia.setInteraction(Boolean.parseBoolean(interaction.getText()));
    Vector2 rp=Param.parseVector2(refPoint.getText());
    ia.setRefPoint(rp.x,rp.y);
    String key=ia.getDesc();
    if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX || !oldId.equals(e.getId()))     key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
    Ctx.project.getI18N().setTranslation(key,desc.getText());
    if (desc.getText() != null)     ia.setDesc(key);
 else     ia.setDesc(null);
    ia.setState(state.getText());
    ia.setZIndex(Float.parseFloat(zIndex.getText()));
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      String rendererType=renderer.getText();
      if (Project.ATLAS_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof AtlasRenderer))         sa.setRenderer(new AtlasRenderer());
      }
 else       if (Project.IMAGE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ImageRenderer))         sa.setRenderer(new ImageRenderer());
      }
 else       if (Project.S3D_RENDERER_STRING.equals(rendererType)) {
        Sprite3DRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof Sprite3DRenderer)) {
          r=new Sprite3DRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(Sprite3DRenderer)sa.getRenderer();
        }
        r.setCameraFOV(Float.parseFloat(fov.getText()));
        r.setCameraName(cameraName.getText());
        r.setSpriteSize(Param.parseVector2(spriteSize.getText()));
      }
 else       if (Project.PARTICLE_RENDERER_STRING.equals(rendererType)) {
        ParticleRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ParticleRenderer)) {
          r=new ParticleRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(ParticleRenderer)sa.getRenderer();
        }
        r.setParticleName(particleName.getText());
        r.setAtlasName(particleAtlas.getText());
      }
 else       if (Project.TEXT_RENDERER_STRING.equals(rendererType)) {
        TextRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof TextRenderer)) {
          r=new TextRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(TextRenderer)sa.getRenderer();
        }
        key=text.getText();
        if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX || !oldId.equals(e.getId()))         key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
        Ctx.project.getI18N().setTranslation(key,text.getText());
        if (text.getText() != null)         r.setText(key,text.getText());
 else         r.setText(null,null);
        r.setFontSize(Integer.parseInt(size.getText()));
        r.setFontName(font.getText());
        r.setAlign(AlignUtils.getAlign(textAlign.getText()));
        r.setBorderWidth(Integer.parseInt(borderWidth.getText()));
        r.setBorderColor(Param.parseColor(borderColor.getText()));
        r.setBorderStraight(Boolean.parseBoolean(borderStraight.getText()));
        r.setShadowOffsetX(Integer.parseInt(shadowOffsetX.getText()));
        r.setShadowOffsetY(Integer.parseInt(shadowOffsetY.getText()));
        r.setShadowColor(Param.parseColor(shadowColor.getText()));
        sa.dispose();
      }
 else       if (Project.SPINE_RENDERER_STRING.equals(rendererType)) {
        SpineRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof SpineRenderer)) {
          r=new SpineRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(SpineRenderer)sa.getRenderer();
        }
        r.setSkin(spineSkin.getText());
      }
      boolean bbfr=Boolean.parseBoolean(bboxFromRenderer.getText());
      if (bbfr != sa.isBboxFromRenderer())       sa.setBboxFromRenderer(bbfr);
      sa.setFakeDepth(Boolean.parseBoolean(fakeDepth.getText()));
      sa.setScale(Float.parseFloat(scale.getText()));
      sa.setRot(Float.parseFloat(rot.getText()));
      sa.getRenderer().setOrgAlign(AlignUtils.getAlign(orgAlign.getText()));
      sa.setTint(Param.parseColor(tint.getText()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        ca.setWalkingSpeed(Float.parseFloat(walkingSpeed.getText()));
        ca.setTextColor(Param.parseColor(textColor.getText()));
        ca.setTextStyle(textStyle.getText());
      }
    }
  }
  parent.addActor(e);
  if (isPlayer && !typeChanged)   parent.setPlayer((CharacterActor)e);
  if (e instanceof InteractiveActor) {
    SceneLayer l=parent.getLayer(((InteractiveActor)e).getLayer());
    l.orderByZIndex();
  }
  if (e instanceof SpriteActor)   ((SpriteActor)e).retrieveAssets();
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  String type=typePanel.getText();
  boolean typeChanged=false;
  BaseActor oldElement=e;
  String oldId=null;
  boolean isPlayer=false;
  if (!create) {
    typeChanged=(type.equals(CHARACTER_TYPE_STR) && !(e instanceof CharacterActor)) || (type.equals(SPRITE_TYPE_STR) && (!(e instanceof SpriteActor) || e instanceof CharacterActor)) || (type.equals(BACKGROUND_TYPE_STR) && (!(e instanceof InteractiveActor) || e instanceof SpriteActor))|| (type.equals(OBSTACLE_TYPE_STR) && !(e instanceof ObstacleActor))|| (type.equals(ANCHOR_TYPE_STR) && !(e instanceof AnchorActor));
    isPlayer=parent.getPlayer() == e;
    parent.removeActor(e);
    oldId=e.getId();
  }
  if (create || typeChanged) {
    if (type.equals(BACKGROUND_TYPE_STR)) {
      e=new InteractiveActor();
    }
 else     if (type.equals(SPRITE_TYPE_STR)) {
      e=new SpriteActor();
    }
 else     if (type.equals(CHARACTER_TYPE_STR)) {
      e=new CharacterActor();
    }
 else     if (type.equals(OBSTACLE_TYPE_STR)) {
      e=new ObstacleActor();
    }
 else     if (type.equals(ANCHOR_TYPE_STR)) {
      e=new AnchorActor();
    }
    if (!(e instanceof SpriteActor) && !(e instanceof AnchorActor)) {
      Polygon bbox=e.getBBox();
      bbox.setVertices(new float[8]);
      float[] verts=bbox.getVertices();
      verts[0]=-DEFAULT_DIM / 2;
      verts[1]=0f;
      verts[2]=-DEFAULT_DIM / 2;
      verts[3]=DEFAULT_DIM;
      verts[4]=DEFAULT_DIM / 2;
      verts[5]=DEFAULT_DIM;
      verts[6]=DEFAULT_DIM / 2;
      verts[7]=0f;
      bbox.dirty();
    }
  }
  if (typeChanged) {
    if (oldElement instanceof InteractiveActor && e instanceof InteractiveActor) {
      HashMap<String,Verb> verbs=((InteractiveActor)e).getVerbManager().getVerbs();
      HashMap<String,Verb> oldVerbs=((InteractiveActor)oldElement).getVerbManager().getVerbs();
      for (      String k : oldVerbs.keySet()) {
        Verb v=oldVerbs.get(k);
        verbs.put(k,v);
      }
    }
    if (oldElement instanceof SpriteActor && e instanceof SpriteActor) {
      ((SpriteActor)e).setRenderer(((SpriteActor)oldElement).getRenderer());
    }
  }
  e.setId(ElementUtils.getCheckedId(id.getText(),parent.getActors().keySet().toArray(new String[0])));
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  Vector2 p=Param.parseVector2(pos.getText());
  e.setPosition(p.x,p.y);
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    ia.setLayer(layer.getText());
    ia.setInteraction(Boolean.parseBoolean(interaction.getText()));
    Vector2 rp=Param.parseVector2(refPoint.getText());
    ia.setRefPoint(rp.x,rp.y);
    String key=ia.getDesc();
    if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX || !e.getId().equals(oldId))     key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
    Ctx.project.getI18N().setTranslation(key,desc.getText());
    if (desc.getText() != null)     ia.setDesc(key);
 else     ia.setDesc(null);
    ia.setState(state.getText());
    ia.setZIndex(Float.parseFloat(zIndex.getText()));
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      String rendererType=renderer.getText();
      if (Project.ATLAS_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof AtlasRenderer))         sa.setRenderer(new AtlasRenderer());
      }
 else       if (Project.IMAGE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ImageRenderer))         sa.setRenderer(new ImageRenderer());
      }
 else       if (Project.S3D_RENDERER_STRING.equals(rendererType)) {
        Sprite3DRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof Sprite3DRenderer)) {
          r=new Sprite3DRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(Sprite3DRenderer)sa.getRenderer();
        }
        r.setCameraFOV(Float.parseFloat(fov.getText()));
        r.setCameraName(cameraName.getText());
        r.setSpriteSize(Param.parseVector2(spriteSize.getText()));
      }
 else       if (Project.PARTICLE_RENDERER_STRING.equals(rendererType)) {
        ParticleRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ParticleRenderer)) {
          r=new ParticleRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(ParticleRenderer)sa.getRenderer();
        }
        r.setParticleName(particleName.getText());
        r.setAtlasName(particleAtlas.getText());
      }
 else       if (Project.TEXT_RENDERER_STRING.equals(rendererType)) {
        TextRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof TextRenderer)) {
          r=new TextRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(TextRenderer)sa.getRenderer();
        }
        key=text.getText();
        if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX || !e.getId().equals(oldId))         key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
        Ctx.project.getI18N().setTranslation(key,text.getText());
        if (text.getText() != null)         r.setText(key,text.getText());
 else         r.setText(null,null);
        r.setFontSize(Integer.parseInt(size.getText()));
        r.setFontName(font.getText());
        r.setAlign(AlignUtils.getAlign(textAlign.getText()));
        r.setBorderWidth(Integer.parseInt(borderWidth.getText()));
        r.setBorderColor(Param.parseColor(borderColor.getText()));
        r.setBorderStraight(Boolean.parseBoolean(borderStraight.getText()));
        r.setShadowOffsetX(Integer.parseInt(shadowOffsetX.getText()));
        r.setShadowOffsetY(Integer.parseInt(shadowOffsetY.getText()));
        r.setShadowColor(Param.parseColor(shadowColor.getText()));
        sa.dispose();
      }
 else       if (Project.SPINE_RENDERER_STRING.equals(rendererType)) {
        SpineRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof SpineRenderer)) {
          r=new SpineRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(SpineRenderer)sa.getRenderer();
        }
        r.setSkin(spineSkin.getText());
      }
      boolean bbfr=Boolean.parseBoolean(bboxFromRenderer.getText());
      if (bbfr != sa.isBboxFromRenderer())       sa.setBboxFromRenderer(bbfr);
      sa.setFakeDepth(Boolean.parseBoolean(fakeDepth.getText()));
      sa.setScale(Float.parseFloat(scale.getText()));
      sa.setRot(Float.parseFloat(rot.getText()));
      sa.getRenderer().setOrgAlign(AlignUtils.getAlign(orgAlign.getText()));
      sa.setTint(Param.parseColor(tint.getText()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        ca.setWalkingSpeed(Float.parseFloat(walkingSpeed.getText()));
        ca.setTextColor(Param.parseColor(textColor.getText()));
        ca.setTextStyle(textStyle.getText());
      }
    }
  }
  parent.addActor(e);
  if (isPlayer && !typeChanged)   parent.setPlayer((CharacterActor)e);
  if (e instanceof InteractiveActor) {
    SceneLayer l=parent.getLayer(((InteractiveActor)e).getLayer());
    l.orderByZIndex();
  }
  if (e instanceof SpriteActor)   ((SpriteActor)e).retrieveAssets();
  Ctx.project.setModified();
}",0.9949370552818828
30167,"public SelectBoxList(final FilteredSelectBox<T> selectBox){
  super(null,selectBox.style.scrollStyle);
  this.selectBox=selectBox;
  setOverscroll(false,false);
  setFadeScrollBars(false);
  setScrollingDisabled(true,false);
  list=new List<T>(selectBox.style.listStyle){
    @Override protected String toString(    T obj){
      return selectBox.toString(obj);
    }
  }
;
  list.setTouchable(Touchable.disabled);
  setActor(list);
  filterField=new TextField(""String_Node_Str"",selectBox.style.textFieldStyle);
  list.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      selectBox.selection.choose(list.getSelected());
      hide();
    }
    public boolean mouseMoved(    InputEvent event,    float x,    float y){
      list.setSelectedIndex(Math.min(selectBox.items.size - 1,(int)((list.getHeight() - y) / list.getItemHeight())));
      return true;
    }
  }
);
  addListener(new InputListener(){
    public void exit(    InputEvent event,    float x,    float y,    int pointer,    Actor toActor){
      if (toActor == null || !isAscendantOf(toActor))       list.getSelection().set(selectBox.getSelected());
    }
  }
);
  hideListener=new InputListener(){
    public boolean touchDown(    InputEvent event,    float x,    float y,    int pointer,    int button){
      Actor target=event.getTarget();
      if (isAscendantOf(target))       return false;
      list.getSelection().set(selectBox.getSelected());
      hide();
      return false;
    }
    public boolean keyDown(    InputEvent event,    int keycode){
      if (keycode == Keys.ESCAPE)       hide();
      return false;
    }
  }
;
  filterField.addListener(new InputListener(){
    public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Keys.ENTER) {
        setSelected(list.getSelected());
        hideList();
        filterField.setCursorPosition(filterField.getText().length());
      }
 else       if (keycode == Keys.UP) {
        int idx=list.getSelectedIndex();
        if (idx > 0)         list.setSelectedIndex(idx - 1);
        return true;
      }
 else       if (keycode == Keys.DOWN) {
        int idx=list.getSelectedIndex();
        if (idx < list.getItems().size - 1)         list.setSelectedIndex(idx + 1);
        return true;
      }
 else {
        if (getStage() == null && list.getItems().size > 0) {
          showList();
        }
        filterItems(filterField.getText());
      }
      return false;
    }
  }
);
}","public SelectBoxList(final FilteredSelectBox<T> selectBox){
  super(null,selectBox.style.scrollStyle);
  this.selectBox=selectBox;
  setOverscroll(false,false);
  setFadeScrollBars(false);
  setScrollingDisabled(true,false);
  list=new List<T>(selectBox.style.listStyle){
    @Override protected String toString(    T obj){
      return selectBox.toString(obj);
    }
  }
;
  list.setTouchable(Touchable.disabled);
  setActor(list);
  filterField=new TextField(""String_Node_Str"",selectBox.style.textFieldStyle);
  list.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      selectBox.selection.choose(list.getSelected());
      hide();
    }
    public boolean mouseMoved(    InputEvent event,    float x,    float y){
      list.setSelectedIndex(Math.min(list.getItems().size - 1,(int)((list.getHeight() - y) / list.getItemHeight())));
      return true;
    }
  }
);
  addListener(new InputListener(){
    public void exit(    InputEvent event,    float x,    float y,    int pointer,    Actor toActor){
      if (toActor == null || !isAscendantOf(toActor))       list.getSelection().set(selectBox.getSelected());
    }
  }
);
  hideListener=new InputListener(){
    public boolean touchDown(    InputEvent event,    float x,    float y,    int pointer,    int button){
      Actor target=event.getTarget();
      if (isAscendantOf(target))       return false;
      list.getSelection().set(selectBox.getSelected());
      hide();
      return false;
    }
    public boolean keyDown(    InputEvent event,    int keycode){
      if (keycode == Keys.ESCAPE)       hide();
      return false;
    }
  }
;
  filterField.addListener(new InputListener(){
    public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Keys.ENTER) {
        setSelected(list.getSelected());
        hideList();
        filterField.setCursorPosition(filterField.getText().length());
      }
 else       if (keycode == Keys.UP) {
        int idx=list.getSelectedIndex();
        if (idx > 0)         list.setSelectedIndex(idx - 1);
        return true;
      }
 else       if (keycode == Keys.DOWN) {
        int idx=list.getSelectedIndex();
        if (idx < list.getItems().size - 1)         list.setSelectedIndex(idx + 1);
        return true;
      }
 else {
        if (getStage() == null && list.getItems().size > 0) {
          showList();
        }
        filterItems(filterField.getText());
      }
      return false;
    }
  }
);
}",0.9955947136563876
30168,"public boolean mouseMoved(InputEvent event,float x,float y){
  list.setSelectedIndex(Math.min(selectBox.items.size - 1,(int)((list.getHeight() - y) / list.getItemHeight())));
  return true;
}","public boolean mouseMoved(InputEvent event,float x,float y){
  list.setSelectedIndex(Math.min(list.getItems().size - 1,(int)((list.getHeight() - y) / list.getItemHeight())));
  return true;
}",0.9581151832460733
30169,"@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",wasInCutmode);
  json.writeValue(""String_Node_Str"",ActionCallbackSerialization.find(cb));
  json.writeArrayStart(""String_Node_Str"");
  for (  Action a : actions) {
    ActionUtils.writeJson(a,json);
  }
  json.writeArrayEnd();
  json.writeValue(""String_Node_Str"",ip);
  json.writeArrayStart(""String_Node_Str"");
  for (  Action a : actions) {
    if (a instanceof Serializable) {
      json.writeObjectStart();
      ((Serializable)a).write(json);
      json.writeObjectEnd();
    }
  }
  json.writeArrayEnd();
  json.writeValue(""String_Node_Str"",storyName);
  if (story != null) {
    try {
      json.writeValue(""String_Node_Str"",story.getState().toJson());
    }
 catch (    Exception e) {
      EngineLogger.error(e.getMessage(),e);
    }
  }
}","@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",wasInCutmode);
  if (cb == null && sCb != null)   cb=ActionCallbackSerialization.find(sCb);
  json.writeValue(""String_Node_Str"",ActionCallbackSerialization.find(cb));
  json.writeArrayStart(""String_Node_Str"");
  for (  Action a : actions) {
    ActionUtils.writeJson(a,json);
  }
  json.writeArrayEnd();
  json.writeValue(""String_Node_Str"",ip);
  json.writeArrayStart(""String_Node_Str"");
  for (  Action a : actions) {
    if (a instanceof Serializable) {
      json.writeObjectStart();
      ((Serializable)a).write(json);
      json.writeObjectEnd();
    }
  }
  json.writeArrayEnd();
  json.writeValue(""String_Node_Str"",storyName);
  if (story != null) {
    try {
      json.writeValue(""String_Node_Str"",story.getState().toJson());
    }
 catch (    Exception e) {
      EngineLogger.error(e.getMessage(),e);
    }
  }
}",0.955310504933256
30170,"public void bindExternalFunctions(InkManager ink) throws Exception {
  this.inkManager=ink;
  inkManager.getStory().bindExternalFunction(""String_Node_Str"",new ExternalFunction(){
    @Override public Object call(    Object[] args) throws Exception {
      try {
        World.getInstance().setModelProp(args[0].toString(),args[1].toString());
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"" + e.getMessage());
      }
      return null;
    }
  }
);
  inkManager.getStory().bindExternalFunction(""String_Node_Str"",new ExternalFunction(){
    @Override public Object call(    Object[] args) throws Exception {
      try {
        return World.getInstance().getModelProp(args[0].toString());
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"" + e.getMessage());
      }
      return null;
    }
  }
);
  inkManager.getStory().bindExternalFunction(""String_Node_Str"",new ExternalFunction(){
    @Override public Object call(    Object[] args) throws Exception {
      return World.getInstance().getInventory().get(args[0].toString()) != null;
    }
  }
);
}","public void bindExternalFunctions(InkManager ink) throws Exception {
  this.inkManager=ink;
  inkManager.getStory().bindExternalFunction(""String_Node_Str"",new ExternalFunction(){
    @Override public Object call(    Object[] args) throws Exception {
      try {
        World.getInstance().setModelProp(args[0].toString(),args[1].toString());
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"" + e.getMessage());
      }
      return null;
    }
  }
);
  inkManager.getStory().bindExternalFunction(""String_Node_Str"",new ExternalFunction(){
    @Override public Object call(    Object[] args) throws Exception {
      try {
        return World.getInstance().getModelProp(args[0].toString());
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"" + e.getMessage(),e);
      }
      return null;
    }
  }
);
  inkManager.getStory().bindExternalFunction(""String_Node_Str"",new ExternalFunction(){
    @Override public Object call(    Object[] args) throws Exception {
      return World.getInstance().getInventory().get(args[0].toString()) != null;
    }
  }
);
}",0.9991055456171736
30171,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    sounds=json.readValue(""String_Node_Str"",HashMap.class,SoundDesc.class,jsonData);
    if (sounds == null)     sounds=new HashMap<String,SoundDesc>();
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
    for (    Scene s : scenes.values()) {
      HashMap<String,Verb> verbs=s.getVerbManager().getVerbs();
      for (      Verb v : verbs.values()) {
        ArrayList<Action> actions=v.getActions();
        for (        Action act : actions) {
          try {
            if (act instanceof SoundAction) {
              String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
              String play=ActionUtils.getStringValue(act,""String_Node_Str"");
              if (play != null) {
                SoundDesc sd=World.getInstance().getSounds().get(actor + ""String_Node_Str"" + play);
                if (sd != null)                 s.getSoundManager().addSoundToLoad(sd);
              }
            }
 else             if (act instanceof PlaySoundAction) {
              String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
              SoundDesc sd=World.getInstance().getSounds().get(sound);
              if (sd != null)               s.getSoundManager().addSoundToLoad(sd);
            }
          }
 catch (          NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
          }
        }
      }
      for (      BaseActor a : s.getActors().values()) {
        if (a instanceof InteractiveActor) {
          HashMap<String,Verb> actorVerbs=((InteractiveActor)a).getVerbManager().getVerbs();
          for (          Verb v : actorVerbs.values()) {
            ArrayList<Action> actions=v.getActions();
            for (            Action act : actions) {
              try {
                if (act instanceof SoundAction) {
                  String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
                  String play=ActionUtils.getStringValue(act,""String_Node_Str"");
                  if (play != null) {
                    SoundDesc sd=World.getInstance().getSounds().get(actor + ""String_Node_Str"" + play);
                    if (sd != null)                     s.getSoundManager().addSoundToLoad(sd);
                  }
                }
 else                 if (act instanceof PlaySoundAction) {
                  String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
                  SoundDesc sd=World.getInstance().getSounds().get(sound);
                  if (sd != null)                   s.getSoundManager().addSoundToLoad(sd);
                }
              }
 catch (              NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
              }
            }
          }
        }
        if (a instanceof SpriteActor && ((SpriteActor)a).getRenderer() instanceof AnimationRenderer) {
          HashMap<String,AnimationDesc> anims=((AnimationRenderer)((SpriteActor)a).getRenderer()).getAnimations();
          for (          AnimationDesc ad : anims.values()) {
            if (ad.sound != null) {
              String sid=ad.sound;
              SoundDesc sd=World.getInstance().getSounds().get(sid);
              if (sd == null)               sid=a.getId() + ""String_Node_Str"" + sid;
              sd=World.getInstance().getSounds().get(sid);
              if (sd != null)               s.getSoundManager().addSoundToLoad(sd);
 else               EngineLogger.error(a.getId() + ""String_Node_Str"" + ad.sound+ ""String_Node_Str""+ ad.id);
            }
          }
        }
      }
    }
  }
 else {
    String bladeVersion=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (bladeVersion != null && !bladeVersion.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + bladeVersion + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    String version=json.readValue(Config.VERSION_PROP,String.class,jsonData);
    if (version == null)     version=""String_Node_Str"";
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    if (jsonData.get(""String_Node_Str"") != null) {
      getInkManager().read(json,jsonData.get(""String_Node_Str""));
    }
    for (    Scene s : scenes.values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    inventories=json.readValue(""String_Node_Str"",HashMap.class,Inventory.class,jsonData);
    currentInventory=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (jsonData.get(""String_Node_Str"") != null) {
      getUIActors().read(json,jsonData.get(""String_Node_Str""));
    }
    timeOfGame=json.readValue(""String_Node_Str"",long.class,0L,jsonData);
    cutMode=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    customProperties.put(WorldProperties.SAVED_GAME_VERSION.toString(),version);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    musicManager=json.readValue(""String_Node_Str"",MusicManager.class,jsonData);
    if (musicManager == null)     musicManager=new MusicManager();
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    sounds=json.readValue(""String_Node_Str"",HashMap.class,SoundDesc.class,jsonData);
    if (sounds == null)     sounds=new HashMap<String,SoundDesc>();
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
    for (    Scene s : scenes.values()) {
      HashMap<String,Verb> verbs=s.getVerbManager().getVerbs();
      for (      Verb v : verbs.values()) {
        ArrayList<Action> actions=v.getActions();
        for (        Action act : actions) {
          try {
            if (act instanceof SoundAction) {
              String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
              String play=ActionUtils.getStringValue(act,""String_Node_Str"");
              if (play != null) {
                SoundDesc sd=World.getInstance().getSounds().get(actor + ""String_Node_Str"" + play);
                if (sd != null)                 s.getSoundManager().addSoundToLoad(sd);
              }
            }
 else             if (act instanceof PlaySoundAction) {
              String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
              SoundDesc sd=World.getInstance().getSounds().get(sound);
              if (sd != null)               s.getSoundManager().addSoundToLoad(sd);
            }
          }
 catch (          NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
          }
        }
      }
      for (      BaseActor a : s.getActors().values()) {
        if (a instanceof InteractiveActor) {
          HashMap<String,Verb> actorVerbs=((InteractiveActor)a).getVerbManager().getVerbs();
          for (          Verb v : actorVerbs.values()) {
            ArrayList<Action> actions=v.getActions();
            for (            Action act : actions) {
              try {
                if (act instanceof SoundAction) {
                  String actor=ActionUtils.getStringValue(act,""String_Node_Str"");
                  String play=ActionUtils.getStringValue(act,""String_Node_Str"");
                  if (play != null) {
                    SoundDesc sd=World.getInstance().getSounds().get(actor + ""String_Node_Str"" + play);
                    if (sd != null)                     s.getSoundManager().addSoundToLoad(sd);
                  }
                }
 else                 if (act instanceof PlaySoundAction) {
                  String sound=ActionUtils.getStringValue(act,""String_Node_Str"");
                  SoundDesc sd=World.getInstance().getSounds().get(sound);
                  if (sd != null)                   s.getSoundManager().addSoundToLoad(sd);
                }
              }
 catch (              NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
              }
            }
          }
        }
        if (a instanceof SpriteActor && ((SpriteActor)a).getRenderer() instanceof AnimationRenderer) {
          HashMap<String,AnimationDesc> anims=((AnimationRenderer)((SpriteActor)a).getRenderer()).getAnimations();
          for (          AnimationDesc ad : anims.values()) {
            if (ad.sound != null) {
              String sid=ad.sound;
              SoundDesc sd=World.getInstance().getSounds().get(sid);
              if (sd == null)               sid=a.getId() + ""String_Node_Str"" + sid;
              sd=World.getInstance().getSounds().get(sid);
              if (sd != null)               s.getSoundManager().addSoundToLoad(sd);
 else               EngineLogger.error(a.getId() + ""String_Node_Str"" + ad.sound+ ""String_Node_Str""+ ad.id);
            }
          }
        }
      }
    }
  }
 else {
    String bladeVersion=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (bladeVersion != null && !bladeVersion.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + bladeVersion + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    String version=json.readValue(Config.VERSION_PROP,String.class,jsonData);
    if (version == null)     version=""String_Node_Str"";
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    if (jsonData.get(""String_Node_Str"") != null) {
      getInkManager().read(json,jsonData.get(""String_Node_Str""));
    }
    inventories=json.readValue(""String_Node_Str"",HashMap.class,Inventory.class,jsonData);
    currentInventory=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (jsonData.get(""String_Node_Str"") != null) {
      getUIActors().read(json,jsonData.get(""String_Node_Str""));
    }
    for (    Scene s : scenes.values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    timeOfGame=json.readValue(""String_Node_Str"",long.class,0L,jsonData);
    cutMode=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    customProperties.put(WorldProperties.SAVED_GAME_VERSION.toString(),version);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    musicManager=json.readValue(""String_Node_Str"",MusicManager.class,jsonData);
    if (musicManager == null)     musicManager=new MusicManager();
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}",0.9656144306651636
30172,"public String getModelProp(String prop){
  return (String)getObjectWrapper().getValue(prop);
}","public String getModelProp(String prop){
  Object value=getObjectWrapper().getValue(prop);
  return value == null ? null : value.toString();
}",0.6949152542372882
30173,"public void takeScreenshot(String filename,int w){
  int h=(int)(w * getSceneCamera().viewportHeight / getSceneCamera().viewportWidth);
  GLFrameBuffer.FrameBufferBuilder frameBufferBuilder=new GLFrameBuffer.FrameBufferBuilder(w,h);
  frameBufferBuilder.addColorTextureAttachment(GL30.GL_RGB565,GL30.GL_RGB,GL30.GL_UNSIGNED_BYTE);
  FrameBuffer fbo=frameBufferBuilder.build();
  fbo.begin();
  Gdx.gl.glClearColor(0,0,0,1);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  draw();
  Pixmap pixmap=ScreenUtils.getFrameBufferPixmap(0,0,w,h);
  fbo.end();
  ByteBuffer pixels=pixmap.getPixels();
  int numBytes=w * h * 4;
  byte[] lines=new byte[numBytes];
  int numBytesPerLine=w * 4;
  for (int i=0; i < h; i++) {
    pixels.position((h - i - 1) * numBytesPerLine);
    pixels.get(lines,i * numBytesPerLine,numBytesPerLine);
  }
  pixels.clear();
  pixels.put(lines);
  PixmapIO.writePNG(EngineAssetManager.getInstance().getUserFile(filename),pixmap);
}","public void takeScreenshot(String filename,int w){
  int h=(int)(w * getSceneCamera().viewportHeight / getSceneCamera().viewportWidth);
  FrameBuffer fbo=FrameBuffer.createFrameBuffer(Format.RGB565,w,h,false);
  fbo.begin();
  Gdx.gl.glClearColor(0,0,0,1);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  draw();
  Pixmap pixmap=ScreenUtils.getFrameBufferPixmap(0,0,w,h);
  fbo.end();
  ByteBuffer pixels=pixmap.getPixels();
  int numBytes=w * h * 4;
  byte[] lines=new byte[numBytes];
  int numBytesPerLine=w * 4;
  for (int i=0; i < h; i++) {
    pixels.position((h - i - 1) * numBytesPerLine);
    pixels.get(lines,i * numBytesPerLine,numBytesPerLine);
  }
  pixels.clear();
  pixels.put(lines);
  PixmapIO.writePNG(EngineAssetManager.getInstance().getUserFile(filename),pixmap);
}",0.8711727325245523
30174,"@Override public boolean run(VerbRunner cb){
  Scene ts=null;
  if (scene == null)   ts=World.getInstance().getCurrentScene();
 else   ts=World.getInstance().getScene(scene);
  BaseActor a;
  if (actor != null) {
    a=World.getInstance().getInventory().get(actor);
    if (a == null) {
      EngineLogger.error(MessageFormat.format(""String_Node_Str"",actor));
      return false;
    }
    removeActor(ts,a);
  }
 else {
    int n=World.getInstance().getInventory().getNumItems();
    for (int i=0; i < n; i++) {
      a=World.getInstance().getInventory().get(i);
      removeActor(ts,a);
    }
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  Scene ts=null;
  if (scene == null)   ts=World.getInstance().getCurrentScene();
 else   ts=World.getInstance().getScene(scene);
  BaseActor a;
  if (actor != null) {
    a=World.getInstance().getInventory().get(actor);
    if (a == null) {
      EngineLogger.error(MessageFormat.format(""String_Node_Str"",actor));
      return false;
    }
    removeActor(ts,a);
  }
 else {
    int n=World.getInstance().getInventory().getNumItems();
    for (int i=n - 1; i >= 0; i--) {
      a=World.getInstance().getInventory().get(i);
      removeActor(ts,a);
    }
  }
  return false;
}",0.9814066289409864
30175,"@Override public void touchUp(InputEvent event,float x,float y,int pointer,int button){
  super.touchUp(event,x,y,pointer,button);
  if (draggingMode == DraggingModes.DRAGGING_ACTOR) {
    Ctx.project.getUndoStack().add(new UndoPosition(selActor,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_REFPOINT) {
    Ctx.project.getUndoStack().add(new UndoRefPosition((InteractiveActor)selActor,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_WALKZONE_POINT) {
    Polygon poly=scnWidget.getScene().getPolygonalNavGraph().getWalkZone();
    Ctx.project.getUndoStack().add(new UndoWalkzonePointPos(poly,vertIndex,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_BBOX_POINT) {
    Ctx.project.getUndoStack().add(new UndoBboxPointPos((InteractiveActor)selActor,vertIndex,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_MARKER_0 || draggingMode == DraggingModes.DRAGGING_MARKER_100) {
    Ctx.project.getUndoStack().add(new UndoDepthVector(scnWidget.getScene(),new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_WALKZONE) {
    Ctx.project.getUndoStack().add(new UndoWalkZonePosition(scnWidget.getScene().getPolygonalNavGraph().getWalkZone(),new Vector2(undoOrg)));
  }
  draggingMode=DraggingModes.NONE;
  return;
}","@Override public void touchUp(InputEvent event,float x,float y,int pointer,int button){
  super.touchUp(event,x,y,pointer,button);
  if (draggingMode == DraggingModes.DRAGGING_ACTOR) {
    Ctx.project.getUndoStack().add(new UndoPosition(selActor,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_REFPOINT) {
    Ctx.project.getUndoStack().add(new UndoRefPosition((InteractiveActor)selActor,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_WALKZONE_POINT) {
    Polygon poly=scnWidget.getScene().getPolygonalNavGraph().getWalkZone();
    Ctx.project.getUndoStack().add(new UndoWalkzonePointPos(poly,vertIndex,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_BBOX_POINT) {
    Ctx.project.getUndoStack().add(new UndoBboxPointPos(selActor,vertIndex,new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_MARKER_0 || draggingMode == DraggingModes.DRAGGING_MARKER_100) {
    Ctx.project.getUndoStack().add(new UndoDepthVector(scnWidget.getScene(),new Vector2(undoOrg)));
  }
 else   if (draggingMode == DraggingModes.DRAGGING_WALKZONE) {
    Ctx.project.getUndoStack().add(new UndoWalkZonePosition(scnWidget.getScene().getPolygonalNavGraph().getWalkZone(),new Vector2(undoOrg)));
  }
  draggingMode=DraggingModes.NONE;
  return;
}",0.9933184855233852
30176,"public UndoBboxPointPos(InteractiveActor a,int i,Vector2 pos){
  this.pos=pos;
  this.a=a;
  this.i=i;
}","public UndoBboxPointPos(BaseActor a,int i,Vector2 pos){
  this.pos=pos;
  this.a=a;
  this.i=i;
}",0.945273631840796
30177,"private void addToolBarButton(Skin skin,ImageButton button,String icon,String text,String tooltip){
  ImageButtonStyle style=new ImageButtonStyle(skin.get(ButtonStyle.class));
  TextureRegion image=Ctx.assetManager.getIcon(icon);
  style.imageUp=new TextureRegionDrawable(image);
  try {
    TextureRegion imageDisabled=Ctx.assetManager.getIcon(icon + ""String_Node_Str"");
    style.imageDisabled=new TextureRegionDrawable(imageDisabled);
  }
 catch (  Exception e) {
  }
  button.setStyle(style);
  add(button);
  button.setDisabled(true);
  TextTooltip t=new TextTooltip(tooltip,skin);
  button.addListener(t);
}","private void addToolBarButton(Skin skin,ImageButton button,String icon,String text,String tooltip){
  ImageButtonStyle style=new ImageButtonStyle(skin.get(ButtonStyle.class));
  TextureRegion image=Ctx.assetManager.getIcon(icon);
  style.imageUp=new TextureRegionDrawable(image);
  try {
    TextureRegion imageDisabled=Ctx.assetManager.getIcon(icon + ""String_Node_Str"");
    if (imageDisabled != null)     style.imageDisabled=new TextureRegionDrawable(imageDisabled);
  }
 catch (  Exception e) {
  }
  button.setStyle(style);
  add(button);
  button.setDisabled(true);
  TextTooltip t=new TextTooltip(tooltip,skin);
  button.addListener(t);
}",0.9753381066030232
30178,"@Override protected String getCellSubTitle(BaseActor e){
  if (e instanceof InteractiveActor)   return Ctx.project.translate(((InteractiveActor)e).getDesc());
  return ""String_Node_Str"";
}","@Override protected String getCellSubTitle(BaseActor e){
  if (e instanceof SpriteActor && ((SpriteActor)e).getRenderer() instanceof TextRenderer && ((TextRenderer)((SpriteActor)e).getRenderer()).getText() != null)   return Ctx.project.translate(((TextRenderer)((SpriteActor)e).getRenderer()).getText()).replace(""String_Node_Str"",""String_Node_Str"");
  if (e instanceof InteractiveActor)   return Ctx.project.translate(((InteractiveActor)e).getDesc());
  return ""String_Node_Str"";
}",0.5620328849028401
30179,"@Override public void create(){
  if (!debug)   debug=Config.getProperty(Config.DEBUG_PROP,debug);
  if (debug)   EngineLogger.setDebug();
  EngineLogger.debug(""String_Node_Str"");
  if (forceRes == null)   forceRes=Config.getProperty(Config.FORCE_RES_PROP,forceRes);
  if (forceRes != null) {
    EngineAssetManager.getInstance().forceResolution(forceRes);
  }
  loadGame(null);
  if (EngineLogger.debugMode()) {
    if (chapter == null)     chapter=Config.getProperty(Config.CHAPTER_PROP,chapter);
    if (testScene == null) {
      testScene=Config.getProperty(Config.TEST_SCENE_PROP,testScene);
    }
    if (testScene != null || chapter != null) {
      try {
        World.getInstance().loadChapter(chapter,testScene);
      }
 catch (      Exception e) {
        dispose();
        EngineLogger.error(""String_Node_Str"" + e.getMessage());
        Gdx.app.exit();
      }
      ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
    }
    if (gameState == null)     gameState=Config.getProperty(Config.LOAD_GAMESTATE_PROP,gameState);
    if (gameState != null) {
      try {
        World.getInstance().loadGameState(gameState);
      }
 catch (      IOException e) {
        EngineLogger.error(e.getMessage());
      }
    }
    if (restart) {
      try {
        World.getInstance().loadChapter(null);
        ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"",e);
        dispose();
        Gdx.app.exit();
      }
    }
    if (recordName == null)     recordName=Config.getProperty(Config.PLAY_RECORD_PROP,recordName);
    if (recordName != null) {
      ui.getRecorder().setFilename(recordName);
      ui.getRecorder().load();
      ui.getRecorder().setPlaying(true);
      ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
    }
  }
  if (EngineLogger.debugMode()) {
    IntBuffer size=BufferUtils.newIntBuffer(16);
    Gdx.gl.glGetIntegerv(GL20.GL_MAX_TEXTURE_SIZE,size);
    int maxSize=size.get();
    EngineLogger.debug(""String_Node_Str"" + maxSize);
    EngineLogger.debug(""String_Node_Str"" + Gdx.graphics.getDensity());
    EngineLogger.debug(""String_Node_Str"" + DPIUtils.getSizeMultiplier());
  }
}","@Override public void create(){
  if (!debug)   debug=Config.getProperty(Config.DEBUG_PROP,debug);
  if (debug)   EngineLogger.setDebug();
  EngineLogger.debug(""String_Node_Str"");
  if (forceRes == null)   forceRes=Config.getProperty(Config.FORCE_RES_PROP,forceRes);
  if (forceRes != null) {
    EngineAssetManager.getInstance().forceResolution(forceRes);
  }
  loadGame(null);
  if (EngineLogger.debugMode()) {
    if (chapter == null)     chapter=Config.getProperty(Config.CHAPTER_PROP,chapter);
    if (testScene == null) {
      testScene=Config.getProperty(Config.TEST_SCENE_PROP,testScene);
    }
    if (testScene != null || chapter != null) {
      try {
        World.getInstance().loadChapter(chapter,testScene,true);
      }
 catch (      Exception e) {
        dispose();
        EngineLogger.error(""String_Node_Str"" + e.getMessage());
        Gdx.app.exit();
      }
      ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
    }
    if (gameState == null)     gameState=Config.getProperty(Config.LOAD_GAMESTATE_PROP,gameState);
    if (gameState != null) {
      try {
        World.getInstance().loadGameState(gameState);
      }
 catch (      IOException e) {
        EngineLogger.error(e.getMessage());
      }
    }
    if (restart) {
      try {
        World.getInstance().loadChapter(null);
        ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"",e);
        dispose();
        Gdx.app.exit();
      }
    }
    if (recordName == null)     recordName=Config.getProperty(Config.PLAY_RECORD_PROP,recordName);
    if (recordName != null) {
      ui.getRecorder().setFilename(recordName);
      ui.getRecorder().load();
      ui.getRecorder().setPlaying(true);
      ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
    }
  }
  if (EngineLogger.debugMode()) {
    IntBuffer size=BufferUtils.newIntBuffer(16);
    Gdx.gl.glGetIntegerv(GL20.GL_MAX_TEXTURE_SIZE,size);
    int maxSize=size.get();
    EngineLogger.debug(""String_Node_Str"" + maxSize);
    EngineLogger.debug(""String_Node_Str"" + Gdx.graphics.getDensity());
    EngineLogger.debug(""String_Node_Str"" + DPIUtils.getSizeMultiplier());
  }
}",0.9988555733577478
30180,"@Override public boolean run(VerbRunner cb){
  try {
    World.getInstance().loadChapter(chapter,scene);
  }
 catch (  Exception e) {
    EngineLogger.error(e.getMessage());
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  try {
    World.getInstance().loadChapter(chapter,scene,false);
  }
 catch (  Exception e) {
    EngineLogger.error(e.getMessage());
  }
  return true;
}",0.9670886075949368
30181,"public void loadChapter(String chapter,String scene) throws Exception {
  this.testScene=scene;
  loadChapter(chapter);
  if (testScene != null) {
    currentScene=null;
    setCurrentScene(testScene);
  }
}","public void loadChapter(String chapter,String scene,boolean test) throws Exception {
  if (test)   this.testScene=scene;
  loadChapter(chapter);
  if (scene != null) {
    currentScene=null;
    setCurrentScene(scene);
  }
}",0.91415313225058
30182,"@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",inScreenTime);
  json.writeValue(""String_Node_Str"",currentText);
  json.writeValue(""String_Node_Str"",new ArrayList<Text>(fifo),ArrayList.class,Text.class);
}","@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",inScreenTime);
  if (currentText != null)   json.writeValue(""String_Node_Str"",currentText);
  json.writeValue(""String_Node_Str"",new ArrayList<Text>(fifo),ArrayList.class,Text.class);
}",0.9452332657200812
30183,"public boolean checkProjectStructure(){
  if (!new File(getModelPath()).exists()) {
    projectFile=projectFile.getParentFile();
    if (new File(getModelPath()).exists())     return true;
 else     return false;
  }
  return true;
}","/** 
 * Checks if the model folder exists in the passed folder or in his parent.
 * @return The correct project folder or null if the model folder is not found.
 */
private File checkProjectStructure(File folder){
  File projectFolder=folder;
  if (!new File(projectFolder.getAbsolutePath() + MODEL_PATH).exists()) {
    projectFolder=projectFolder.getParentFile();
    if (!new File(projectFolder.getAbsolutePath() + MODEL_PATH).exists())     return null;
  }
  return projectFolder;
}",0.0611961057023643
30184,"public void loadProject(File projectFile) throws IOException {
  closeProject();
  File oldProjectFile=this.projectFile;
  this.projectFile=projectFile;
  if (checkProjectStructure()) {
    FolderClassLoader folderClassLoader=new FolderClassLoader(projectFile.getAbsolutePath() + ""String_Node_Str"");
    ActionFactory.setActionClassLoader(folderClassLoader);
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH);
    try {
      World.getInstance().loadWorldDesc();
    }
 catch (    SerializationException ex) {
      if (ex.getCause() != null && ex.getCause() instanceof ClassNotFoundException) {
        EditorLogger.debug(""String_Node_Str"");
        if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
          folderClassLoader.reload();
          World.getInstance().loadWorldDesc();
        }
 else {
          this.projectFile=null;
          throw new IOException(""String_Node_Str"");
        }
      }
 else {
        this.projectFile=null;
        throw ex;
      }
    }
    chapter=new Chapter(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    i18n=new I18NHandler(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    editorConfig.setProperty(LAST_PROJECT_PROP,projectFile.getAbsolutePath());
    projectConfig=new OrderedProperties();
    projectConfig.load(new FileInputStream(projectFile.getAbsolutePath() + ASSETS_PATH + ""String_Node_Str""+ Config.PROPERTIES_FILENAME));
    modified=false;
    Display.setTitle(""String_Node_Str"" + Versions.getVersion() + ""String_Node_Str""+ projectFile.getAbsolutePath());
    firePropertyChange(NOTIFY_PROJECT_LOADED);
  }
 else {
    this.projectFile=oldProjectFile;
    throw new IOException(""String_Node_Str"");
  }
}","public void loadProject(File projectToLoad) throws IOException {
  projectToLoad=checkProjectStructure(projectToLoad);
  if (projectToLoad != null) {
    closeProject();
    this.projectFile=projectToLoad;
    FolderClassLoader folderClassLoader=new FolderClassLoader(projectFile.getAbsolutePath() + ""String_Node_Str"");
    ActionFactory.setActionClassLoader(folderClassLoader);
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH);
    try {
      World.getInstance().loadWorldDesc();
    }
 catch (    SerializationException ex) {
      if (ex.getCause() != null && ex.getCause() instanceof ClassNotFoundException) {
        EditorLogger.debug(""String_Node_Str"");
        if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
          folderClassLoader.reload();
          World.getInstance().loadWorldDesc();
        }
 else {
          this.projectFile=null;
          throw new IOException(""String_Node_Str"");
        }
      }
 else {
        this.projectFile=null;
        throw ex;
      }
    }
    chapter=new Chapter(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    i18n=new I18NHandler(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    editorConfig.setProperty(LAST_PROJECT_PROP,projectFile.getAbsolutePath());
    projectConfig=new OrderedProperties();
    projectConfig.load(new FileInputStream(projectFile.getAbsolutePath() + ASSETS_PATH + ""String_Node_Str""+ Config.PROPERTIES_FILENAME));
    modified=false;
    Display.setTitle(""String_Node_Str"" + Versions.getVersion() + ""String_Node_Str""+ projectFile.getAbsolutePath());
    firePropertyChange(NOTIFY_PROJECT_LOADED);
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}",0.9174363280156732
30185,"public void createProject(String projectDir,String name,String pkg,String sdkLocation,boolean spinePlugin) throws IOException {
  createLibGdxProject(projectDir,name,pkg,""String_Node_Str"",sdkLocation,spinePlugin);
  projectFile=new File(projectDir + ""String_Node_Str"" + name);
  loadProject(projectFile);
}","public void createProject(String projectDir,String name,String pkg,String sdkLocation,boolean spinePlugin) throws IOException {
  closeProject();
  createLibGdxProject(projectDir,name,pkg,""String_Node_Str"",sdkLocation,spinePlugin);
  projectFile=new File(projectDir + ""String_Node_Str"" + name);
  loadProject(projectFile);
}",0.9714285714285714
30186,"public void closeProject(){
  this.projectFile=null;
}","public void closeProject(){
  setSelectedScene(null);
  this.projectFile=null;
}",0.8059701492537313
30187,"public void loadProject(File projectFile) throws IOException {
  File oldProjectFile=this.projectFile;
  this.projectFile=projectFile;
  if (checkProjectStructure()) {
    FolderClassLoader folderClassLoader=new FolderClassLoader(projectFile.getAbsolutePath() + ""String_Node_Str"");
    ActionFactory.setActionClassLoader(folderClassLoader);
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH);
    try {
      World.getInstance().loadWorldDesc();
    }
 catch (    SerializationException ex) {
      if (ex.getCause() != null && ex.getCause() instanceof ClassNotFoundException) {
        EditorLogger.debug(""String_Node_Str"");
        if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
          folderClassLoader.reload();
          World.getInstance().loadWorldDesc();
        }
 else {
          this.projectFile=null;
          throw new IOException(""String_Node_Str"");
        }
      }
 else {
        this.projectFile=null;
        throw ex;
      }
    }
    chapter=new Chapter(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    i18n=new I18NHandler(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    editorConfig.setProperty(LAST_PROJECT_PROP,projectFile.getAbsolutePath());
    projectConfig=new OrderedProperties();
    projectConfig.load(new FileInputStream(projectFile.getAbsolutePath() + ASSETS_PATH + ""String_Node_Str""+ Config.PROPERTIES_FILENAME));
    modified=false;
    Display.setTitle(""String_Node_Str"" + Versions.getVersion() + ""String_Node_Str""+ projectFile.getAbsolutePath());
    firePropertyChange(NOTIFY_PROJECT_LOADED);
  }
 else {
    this.projectFile=oldProjectFile;
    throw new IOException(""String_Node_Str"");
  }
}","public void loadProject(File projectFile) throws IOException {
  closeProject();
  File oldProjectFile=this.projectFile;
  this.projectFile=projectFile;
  if (checkProjectStructure()) {
    FolderClassLoader folderClassLoader=new FolderClassLoader(projectFile.getAbsolutePath() + ""String_Node_Str"");
    ActionFactory.setActionClassLoader(folderClassLoader);
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH);
    try {
      World.getInstance().loadWorldDesc();
    }
 catch (    SerializationException ex) {
      if (ex.getCause() != null && ex.getCause() instanceof ClassNotFoundException) {
        EditorLogger.debug(""String_Node_Str"");
        if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
          folderClassLoader.reload();
          World.getInstance().loadWorldDesc();
        }
 else {
          this.projectFile=null;
          throw new IOException(""String_Node_Str"");
        }
      }
 else {
        this.projectFile=null;
        throw ex;
      }
    }
    chapter=new Chapter(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    i18n=new I18NHandler(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    editorConfig.setProperty(LAST_PROJECT_PROP,projectFile.getAbsolutePath());
    projectConfig=new OrderedProperties();
    projectConfig.load(new FileInputStream(projectFile.getAbsolutePath() + ASSETS_PATH + ""String_Node_Str""+ Config.PROPERTIES_FILENAME));
    modified=false;
    Display.setTitle(""String_Node_Str"" + Versions.getVersion() + ""String_Node_Str""+ projectFile.getAbsolutePath());
    firePropertyChange(NOTIFY_PROJECT_LOADED);
  }
 else {
    this.projectFile=oldProjectFile;
    throw new IOException(""String_Node_Str"");
  }
}",0.9949608062709966
30188,"private void nextStep(){
  if (ip >= actions.size() || ip < 0) {
    continueMaximally();
  }
 else {
    boolean stop=false;
    while (ip < actions.size() && !stop) {
      Action a=actions.get(ip);
      try {
        if (a.run(this))         stop=true;
 else         ip++;
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"" + a.getClass().getSimpleName(),e);
        ip++;
      }
    }
  }
}","private void nextStep(){
  if (ip < 0) {
    continueMaximally();
  }
 else {
    boolean stop=false;
    while (ip < actions.size() && !stop) {
      Action a=actions.get(ip);
      try {
        if (a.run(this))         stop=true;
 else         ip++;
      }
 catch (      Exception e) {
        EngineLogger.error(""String_Node_Str"" + a.getClass().getSimpleName(),e);
        ip++;
      }
    }
    if (ip >= actions.size() && !stop)     continueMaximally();
  }
}",0.1409395973154362
30189,"@Override public void render(float delta){
  SpriteBatch batch=ui.getBatch();
  Gdx.gl.glClearColor(0,0,0,1);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  batch.setProjectionMatrix(viewport.getCamera().combined);
  batch.begin();
  if (time > FADE_TIME * 2 + SCREEN_TIME) {
    batch.setColor(Color.WHITE);
    ui.setCurrentScreen(Screens.MENU_SCREEN);
    return;
  }
 else   if (time > FADE_TIME + SCREEN_TIME) {
    batch.setColor(1,1,1,1 - fadeTime / FADE_TIME);
  }
 else   if (time < FADE_TIME) {
    batch.setColor(1,1,1,fadeTime / FADE_TIME);
  }
 else {
    fadeTime=0;
  }
  final int viewportW=viewport.getScreenWidth();
  final int viewportH=viewport.getScreenHeight();
  final float texW=tex.getWidth() * scale;
  final float texH=tex.getHeight() * scale;
  batch.draw(tex,(viewportW - texW) / 2,(viewportH - texH) / 2,texW,texH);
  batch.setColor(1,1,1,1);
  time+=delta;
  fadeTime+=delta;
  batch.end();
}","@Override public void render(float delta){
  SpriteBatch batch=ui.getBatch();
  Gdx.gl.glClearColor(0,0,0,1);
  Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  batch.setProjectionMatrix(viewport.getCamera().combined);
  batch.begin();
  if (time > FADE_TIME * 2 + SCREEN_TIME) {
    batch.setColor(Color.WHITE);
    ui.setCurrentScreen(Screens.MENU_SCREEN);
    batch.end();
    return;
  }
 else   if (time > FADE_TIME + SCREEN_TIME) {
    batch.setColor(1,1,1,1 - fadeTime / FADE_TIME);
  }
 else   if (time < FADE_TIME) {
    batch.setColor(1,1,1,fadeTime / FADE_TIME);
  }
 else {
    fadeTime=0;
  }
  final int viewportW=viewport.getScreenWidth();
  final int viewportH=viewport.getScreenHeight();
  final float texW=tex.getWidth() * scale;
  final float texH=tex.getHeight() * scale;
  batch.draw(tex,(viewportW - texW) / 2,(viewportH - texH) / 2,texW,texH);
  batch.setColor(Color.WHITE);
  time+=delta;
  fadeTime+=delta;
  batch.end();
}",0.9812332439678284
30190,"public void pause(){
  paused=true;
  if (currentScene != null) {
    musicEngine.pauseMusic();
    for (    BaseActor a : currentScene.getActors().values()) {
      if (a instanceof InteractiveActor) {
        String playingSound=((InteractiveActor)a).getPlayingSound();
        if (playingSound != null)         ((InteractiveActor)a).getSounds().get(playingSound).pause();
      }
    }
  }
}","public void pause(){
  paused=true;
  if (currentScene != null) {
    if (assetState == AssetState.LOADED)     musicEngine.pauseMusic();
    for (    BaseActor a : currentScene.getActors().values()) {
      if (a instanceof InteractiveActor) {
        String playingSound=((InteractiveActor)a).getPlayingSound();
        if (playingSound != null)         ((InteractiveActor)a).getSounds().get(playingSound).pause();
      }
    }
  }
}",0.9505428226779252
30191,"public void loadChapter(String selChapter) throws IOException {
  undoStack.clear();
  try {
    chapter.load(selChapter);
  }
 catch (  SerializationException ex) {
    if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
      EditorLogger.debug(""String_Node_Str"");
      if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
        chapter.load(selChapter);
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      throw ex;
    }
  }
  i18n.load(selChapter);
}","public void loadChapter(String selChapter) throws IOException {
  undoStack.clear();
  try {
    chapter.load(selChapter);
  }
 catch (  SerializationException ex) {
    if (ex.getCause() != null && ex.getCause() instanceof ClassNotFoundException) {
      EditorLogger.debug(""String_Node_Str"");
      if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
        FolderClassLoader folderClassLoader=new FolderClassLoader(projectFile.getAbsolutePath() + ""String_Node_Str"");
        ActionFactory.setActionClassLoader(folderClassLoader);
        chapter.load(selChapter);
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      throw ex;
    }
  }
  i18n.load(selChapter);
}",0.8285714285714286
30192,"@Override protected void delete(){
  if (list.getSelection().size() == 0)   return;
  multiClipboard.clear();
  int pos=list.getSelectedIndex();
  for (  Action e : getSortedSelection()) {
    if (e instanceof EndAction)     continue;
    list.getItems().removeValue(e,true);
    int idx=parent.getActions().indexOf(e);
    parent.getActions().remove(e);
    multiClipboard.add(e);
    if (scope.equals(ScopePanel.WORLD_SCOPE))     Ctx.project.getI18N().putTranslationsInElement(e,true);
 else     Ctx.project.getI18N().putTranslationsInElement(e,false);
    Ctx.project.getUndoStack().add(new UndoDeleteAction(parent,e,idx));
    if (isControlAction(e))     deleteControlAction(list.getItems().indexOf(e,true),(AbstractControlAction)e);
  }
  if (list.getItems().size == 0) {
    list.getSelection().clear();
  }
 else   if (pos >= list.getItems().size) {
    list.getSelection().choose(list.getItems().get(list.getItems().size - 1));
  }
 else {
    list.getSelection().choose(list.getItems().get(pos));
  }
  toolbar.disablePaste(false);
  Ctx.project.setModified();
}","@Override protected void delete(){
  if (list.getSelection().size() == 0)   return;
  multiClipboard.clear();
  int pos=list.getSelectedIndex();
  for (  Action e : getSortedSelection()) {
    if (e instanceof EndAction)     continue;
    int pos2=list.getItems().indexOf(e,true);
    list.getItems().removeValue(e,true);
    int idx=parent.getActions().indexOf(e);
    parent.getActions().remove(e);
    multiClipboard.add(e);
    if (scope.equals(ScopePanel.WORLD_SCOPE))     Ctx.project.getI18N().putTranslationsInElement(e,true);
 else     Ctx.project.getI18N().putTranslationsInElement(e,false);
    Ctx.project.getUndoStack().add(new UndoDeleteAction(parent,e,idx));
    if (isControlAction(e))     deleteControlAction(pos2,(AbstractControlAction)e);
  }
  if (list.getItems().size == 0) {
    list.getSelection().clear();
  }
 else   if (pos >= list.getItems().size) {
    list.getSelection().choose(list.getItems().get(list.getItems().size - 1));
  }
 else {
    list.getSelection().choose(list.getItems().get(pos));
  }
  toolbar.disablePaste(false);
  Ctx.project.setModified();
}",0.962517353077279
30193,"@Override protected void edit(){
  Action e=list.getSelected();
  if (e == null || e instanceof EndAction || e instanceof DisableActionAction)   return;
  editedElement=(Action)ElementUtils.cloneElement(e);
  EditModelDialog<Verb,Action> dialog=getEditElementDialogInstance(e);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @SuppressWarnings(""String_Node_Str"") @Override public void changed(    ChangeEvent event,    Actor actor){
      Action e=((EditModelDialog<Verb,Action>)actor).getElement();
      int pos=list.getSelectedIndex();
      list.getItems().set(pos,e);
      parent.getActions().set(pos,e);
      Ctx.project.setModified();
      if (isControlAction(editedElement)) {
        if (!editedElement.getClass().getName().equals(e.getClass().getName())) {
          deleteControlAction(list.getSelectedIndex(),(AbstractControlAction)editedElement);
          if (isControlAction(e)) {
            insertEndAction(list.getSelectedIndex() + 1,getOrCreateControlActionId((AbstractControlAction)e));
            if (e instanceof AbstractIfAction)             insertEndAction(list.getSelectedIndex() + 2,getOrCreateControlActionId((AbstractControlAction)e));
          }
        }
 else {
          try {
            ActionUtils.setParam(e,CONTROL_ACTION_ID_ATTR,getOrCreateControlActionId((AbstractControlAction)editedElement));
          }
 catch (          NoSuchFieldException|IllegalArgumentException|IllegalAccessException e1) {
            EditorLogger.error(e1.getMessage());
          }
        }
      }
    }
  }
);
}","@Override protected void edit(){
  Action e=list.getSelected();
  if (e == null || e instanceof EndAction || e instanceof DisableActionAction)   return;
  editedElement=(Action)ElementUtils.cloneElement(e);
  EditModelDialog<Verb,Action> dialog=getEditElementDialogInstance(e);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @SuppressWarnings(""String_Node_Str"") @Override public void changed(    ChangeEvent event,    Actor actor){
      Action e=((EditModelDialog<Verb,Action>)actor).getElement();
      int pos=list.getSelectedIndex();
      list.getItems().set(pos,e);
      parent.getActions().set(pos,e);
      Ctx.project.setModified();
      if (isControlAction(editedElement)) {
        if (!editedElement.getClass().getName().equals(e.getClass().getName())) {
          deleteControlAction(pos,(AbstractControlAction)editedElement);
          if (isControlAction(e)) {
            insertEndAction(pos + 1,getOrCreateControlActionId((AbstractControlAction)e));
            if (e instanceof AbstractIfAction)             insertEndAction(pos + 2,getOrCreateControlActionId((AbstractControlAction)e));
          }
        }
 else {
          try {
            ActionUtils.setParam(e,CONTROL_ACTION_ID_ATTR,getOrCreateControlActionId((AbstractControlAction)editedElement));
          }
 catch (          NoSuchFieldException|IllegalArgumentException|IllegalAccessException e1) {
            EditorLogger.error(e1.getMessage());
          }
        }
      }
    }
  }
);
}",0.974559686888454
30194,"@SuppressWarnings(""String_Node_Str"") @Override public void changed(ChangeEvent event,Actor actor){
  Action e=((EditModelDialog<Verb,Action>)actor).getElement();
  int pos=list.getSelectedIndex();
  list.getItems().set(pos,e);
  parent.getActions().set(pos,e);
  Ctx.project.setModified();
  if (isControlAction(editedElement)) {
    if (!editedElement.getClass().getName().equals(e.getClass().getName())) {
      deleteControlAction(list.getSelectedIndex(),(AbstractControlAction)editedElement);
      if (isControlAction(e)) {
        insertEndAction(list.getSelectedIndex() + 1,getOrCreateControlActionId((AbstractControlAction)e));
        if (e instanceof AbstractIfAction)         insertEndAction(list.getSelectedIndex() + 2,getOrCreateControlActionId((AbstractControlAction)e));
      }
    }
 else {
      try {
        ActionUtils.setParam(e,CONTROL_ACTION_ID_ATTR,getOrCreateControlActionId((AbstractControlAction)editedElement));
      }
 catch (      NoSuchFieldException|IllegalArgumentException|IllegalAccessException e1) {
        EditorLogger.error(e1.getMessage());
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void changed(ChangeEvent event,Actor actor){
  Action e=((EditModelDialog<Verb,Action>)actor).getElement();
  int pos=list.getSelectedIndex();
  list.getItems().set(pos,e);
  parent.getActions().set(pos,e);
  Ctx.project.setModified();
  if (isControlAction(editedElement)) {
    if (!editedElement.getClass().getName().equals(e.getClass().getName())) {
      deleteControlAction(pos,(AbstractControlAction)editedElement);
      if (isControlAction(e)) {
        insertEndAction(pos + 1,getOrCreateControlActionId((AbstractControlAction)e));
        if (e instanceof AbstractIfAction)         insertEndAction(pos + 2,getOrCreateControlActionId((AbstractControlAction)e));
      }
    }
 else {
      try {
        ActionUtils.setParam(e,CONTROL_ACTION_ID_ATTR,getOrCreateControlActionId((AbstractControlAction)editedElement));
      }
 catch (      NoSuchFieldException|IllegalArgumentException|IllegalAccessException e1) {
        EditorLogger.error(e1.getMessage());
      }
    }
  }
}",0.9636194029850746
30195,"private void setProject(){
  clearProps();
  if (Ctx.project.getProjectDir() != null) {
    addProperty(Project.WIDTH_PROPERTY,World.getInstance().getWidth());
    addProperty(Project.HEIGHT_PROPERTY,World.getInstance().getHeight());
    addProperty(Config.TITLE_PROP,Ctx.project.getTitle());
    addProperty(Config.INVENTORY_POS_PROP,Ctx.project.getProjectConfig().getProperty(Config.INVENTORY_POS_PROP,""String_Node_Str"").toUpperCase(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    addProperty(Config.INVENTORY_AUTOSIZE_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.INVENTORY_AUTOSIZE_PROP,""String_Node_Str"")));
    addProperty(Config.UI_MODE,Ctx.project.getProjectConfig().getProperty(Config.UI_MODE,""String_Node_Str"").toUpperCase(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    addProperty(Config.SINGLE_ACTION_INVENTORY,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.SINGLE_ACTION_INVENTORY,""String_Node_Str"")));
    addProperty(Config.FAST_LEAVE,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.FAST_LEAVE,""String_Node_Str"")));
    addProperty(Config.DEBUG_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.DEBUG_PROP,""String_Node_Str"")));
    addProperty(Config.SHOW_DESC_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.SHOW_DESC_PROP,""String_Node_Str"")));
    addProperty(Config.CHARACTER_ICON_ATLAS,Ctx.project.getProjectConfig().getProperty(Config.CHARACTER_ICON_ATLAS,""String_Node_Str""));
    addProperty(Config.EXTEND_VIEWPORT_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.EXTEND_VIEWPORT_PROP,""String_Node_Str"")));
  }
  invalidateHierarchy();
}","private void setProject(){
  clearProps();
  if (Ctx.project.getProjectDir() != null) {
    addProperty(Project.WIDTH_PROPERTY,World.getInstance().getWidth());
    addProperty(Project.HEIGHT_PROPERTY,World.getInstance().getHeight());
    addProperty(Config.TITLE_PROP,Ctx.project.getTitle());
    addProperty(Config.INVENTORY_POS_PROP,Ctx.project.getProjectConfig().getProperty(Config.INVENTORY_POS_PROP,""String_Node_Str"").toUpperCase(Locale.ENGLISH),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    addProperty(Config.INVENTORY_AUTOSIZE_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.INVENTORY_AUTOSIZE_PROP,""String_Node_Str"")));
    addProperty(Config.UI_MODE,Ctx.project.getProjectConfig().getProperty(Config.UI_MODE,""String_Node_Str"").toUpperCase(Locale.ENGLISH),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    addProperty(Config.SINGLE_ACTION_INVENTORY,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.SINGLE_ACTION_INVENTORY,""String_Node_Str"")));
    addProperty(Config.FAST_LEAVE,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.FAST_LEAVE,""String_Node_Str"")));
    addProperty(Config.DEBUG_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.DEBUG_PROP,""String_Node_Str"")));
    addProperty(Config.SHOW_DESC_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.SHOW_DESC_PROP,""String_Node_Str"")));
    addProperty(Config.CHARACTER_ICON_ATLAS,Ctx.project.getProjectConfig().getProperty(Config.CHARACTER_ICON_ATLAS,""String_Node_Str""));
    addProperty(Config.EXTEND_VIEWPORT_PROP,Boolean.parseBoolean(Ctx.project.getProjectConfig().getProperty(Config.EXTEND_VIEWPORT_PROP,""String_Node_Str"")));
  }
  invalidateHierarchy();
}",0.9923203510696654
30196,"@Override public void show(){
  final Locale locale=I18N.getCurrentLocale();
  String filename=null;
  UIModes uiMode=UIModes.valueOf(Config.getProperty(Config.UI_MODE,""String_Node_Str"").toUpperCase());
  if (Gdx.input.isPeripheralAvailable(Peripheral.MultitouchScreen) && uiMode == UIModes.TWO_BUTTONS) {
    uiMode=UIModes.PIE;
  }
switch (uiMode) {
case PIE:
    filename=PIE_FILENAME;
  break;
case SINGLE_CLICK:
filename=SINGLE_CLICK_FILENAME;
break;
case TWO_BUTTONS:
filename=TWO_BUTTONS_FILENAME;
break;
}
localeFilename=MessageFormat.format(""String_Node_Str"",filename,locale.getLanguage());
if (!EngineAssetManager.getInstance().assetExists(localeFilename)) localeFilename=MessageFormat.format(""String_Node_Str"",filename);
tex=new Texture(EngineAssetManager.getInstance().getResAsset(localeFilename));
tex.setFilter(TextureFilter.Linear,TextureFilter.Linear);
Gdx.input.setInputProcessor(inputProcessor);
}","@Override public void show(){
  final Locale locale=I18N.getCurrentLocale();
  String filename=null;
  UIModes uiMode=UIModes.valueOf(Config.getProperty(Config.UI_MODE,""String_Node_Str"").toUpperCase(Locale.ENGLISH));
  if (Gdx.input.isPeripheralAvailable(Peripheral.MultitouchScreen) && uiMode == UIModes.TWO_BUTTONS) {
    uiMode=UIModes.PIE;
  }
switch (uiMode) {
case PIE:
    filename=PIE_FILENAME;
  break;
case SINGLE_CLICK:
filename=SINGLE_CLICK_FILENAME;
break;
case TWO_BUTTONS:
filename=TWO_BUTTONS_FILENAME;
break;
}
localeFilename=MessageFormat.format(""String_Node_Str"",filename,locale.getLanguage());
if (!EngineAssetManager.getInstance().assetExists(localeFilename)) localeFilename=MessageFormat.format(""String_Node_Str"",filename);
tex=new Texture(EngineAssetManager.getInstance().getResAsset(localeFilename));
tex.setFilter(TextureFilter.Linear,TextureFilter.Linear);
Gdx.input.setInputProcessor(inputProcessor);
}",0.9924078091106292
30197,"public InventoryUI(SceneScreen scr,ScenePointer pointer){
  style=scr.getUI().getSkin().get(InventoryUIStyle.class);
  sceneScreen=scr;
  this.pointer=pointer;
  inventoryPos=InventoryPos.valueOf(Config.getProperty(Config.INVENTORY_POS_PROP,""String_Node_Str"").toUpperCase());
  autosize=Config.getProperty(Config.INVENTORY_AUTOSIZE_PROP,true);
  addListener(new InputListener(){
    @Override public void touchUp(    InputEvent event,    float x,    float y,    int pointer,    int button){
      if (draggedActor != null) {
        stopDragging(button);
      }
 else {
        InteractiveActor actor=getItemAt(x,y);
        if (actor != null) {
          if (singleAction)           sceneScreen.runVerb(actor,""String_Node_Str"",null);
 else           sceneScreen.actorClick(actor,button);
        }
 else {
          hide();
        }
      }
    }
    @Override public boolean mouseMoved(    InputEvent event,    float x,    float y){
      return true;
    }
    @Override public void touchDragged(    InputEvent event,    float x,    float y,    int pointer){
      if (draggedActor == null)       startDragging(x,y);
    }
    @Override public boolean touchDown(    InputEvent event,    float x,    float y,    int pointer,    int button){
      return true;
    }
    @Override public void exit(    InputEvent event,    float x,    float y,    int pointer,    com.badlogic.gdx.scenes.scene2d.Actor toActor){
      if (!(toActor instanceof PieMenu) && !(toActor instanceof InventoryUI) && draggedActor != null)       hide();
    }
  }
);
  if (style.menuButtonStyle != null) {
    menuButton=new Button(style.menuButtonStyle);
    addActor(menuButton);
    menuButton.addListener(new ChangeListener(){
      @Override public void changed(      ChangeEvent event,      com.badlogic.gdx.scenes.scene2d.Actor actor){
        sceneScreen.getUI().setCurrentScreen(UI.Screens.MENU_SCREEN);
      }
    }
);
    float iconSize=DPIUtils.getPrefButtonSize();
    menuButton.setSize(iconSize,iconSize);
  }
}","public InventoryUI(SceneScreen scr,ScenePointer pointer){
  style=scr.getUI().getSkin().get(InventoryUIStyle.class);
  sceneScreen=scr;
  this.pointer=pointer;
  inventoryPos=InventoryPos.valueOf(Config.getProperty(Config.INVENTORY_POS_PROP,""String_Node_Str"").toUpperCase(Locale.ENGLISH));
  autosize=Config.getProperty(Config.INVENTORY_AUTOSIZE_PROP,true);
  addListener(new InputListener(){
    @Override public void touchUp(    InputEvent event,    float x,    float y,    int pointer,    int button){
      if (draggedActor != null) {
        stopDragging(button);
      }
 else {
        InteractiveActor actor=getItemAt(x,y);
        if (actor != null) {
          if (singleAction)           sceneScreen.runVerb(actor,""String_Node_Str"",null);
 else           sceneScreen.actorClick(actor,button);
        }
 else {
          hide();
        }
      }
    }
    @Override public boolean mouseMoved(    InputEvent event,    float x,    float y){
      return true;
    }
    @Override public void touchDragged(    InputEvent event,    float x,    float y,    int pointer){
      if (draggedActor == null)       startDragging(x,y);
    }
    @Override public boolean touchDown(    InputEvent event,    float x,    float y,    int pointer,    int button){
      return true;
    }
    @Override public void exit(    InputEvent event,    float x,    float y,    int pointer,    com.badlogic.gdx.scenes.scene2d.Actor toActor){
      if (!(toActor instanceof PieMenu) && !(toActor instanceof InventoryUI) && draggedActor != null)       hide();
    }
  }
);
  if (style.menuButtonStyle != null) {
    menuButton=new Button(style.menuButtonStyle);
    addActor(menuButton);
    menuButton.addListener(new ChangeListener(){
      @Override public void changed(      ChangeEvent event,      com.badlogic.gdx.scenes.scene2d.Actor actor){
        sceneScreen.getUI().setCurrentScreen(UI.Screens.MENU_SCREEN);
      }
    }
);
    float iconSize=DPIUtils.getPrefButtonSize();
    menuButton.setSize(iconSize,iconSize);
  }
}",0.9965174129353234
30198,"@Override public void setUI(UI ui){
  this.ui=ui;
  recorder=ui.getRecorder();
  testerBot=ui.getTesterBot();
  pie=new PieMenu(this);
  textManagerUI=new TextManagerUI(ui.getSkin());
  menuButton=new Button(ui.getSkin(),""String_Node_Str"");
  dialogUI=new DialogUI(ui);
  pointer=new ScenePointer(ui.getSkin());
  inventoryUI=new InventoryUI(this,pointer);
  inventoryButton=new InventoryButton(ui.getSkin(),inventoryUI);
  uiMode=UIModes.valueOf(Config.getProperty(Config.UI_MODE,""String_Node_Str"").toUpperCase());
  if (Gdx.input.isPeripheralAvailable(Peripheral.MultitouchScreen) && uiMode == UIModes.TWO_BUTTONS) {
    uiMode=UIModes.PIE;
  }
  pie.setVisible(false);
}","@Override public void setUI(UI ui){
  this.ui=ui;
  recorder=ui.getRecorder();
  testerBot=ui.getTesterBot();
  pie=new PieMenu(this);
  textManagerUI=new TextManagerUI(ui.getSkin());
  menuButton=new Button(ui.getSkin(),""String_Node_Str"");
  dialogUI=new DialogUI(ui);
  pointer=new ScenePointer(ui.getSkin());
  inventoryUI=new InventoryUI(this,pointer);
  inventoryButton=new InventoryButton(ui.getSkin(),inventoryUI);
  uiMode=UIModes.valueOf(Config.getProperty(Config.UI_MODE,""String_Node_Str"").toUpperCase(Locale.ENGLISH));
  if (Gdx.input.isPeripheralAvailable(Peripheral.MultitouchScreen) && uiMode == UIModes.TWO_BUTTONS) {
    uiMode=UIModes.PIE;
  }
  pie.setVisible(false);
}",0.9897058823529412
30199,"@SuppressWarnings(""String_Node_Str"") public static void setParam(Action action,String param,String value) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
  Class<?> clazz=action.getClass();
  Field field=getField(clazz,param);
  if (field == null)   throw new NoSuchFieldException(param);
  final boolean accessible=field.isAccessible();
  field.setAccessible(true);
  if (field.getType().isAssignableFrom(String.class)) {
    field.set(action,value);
  }
 else   if (field.getType().isAssignableFrom(boolean.class)) {
    field.setBoolean(action,Boolean.parseBoolean(value));
  }
 else   if (field.getType().isAssignableFrom(Boolean.class)) {
    Boolean b=null;
    if (value != null)     b=Boolean.valueOf(value);
    field.set(action,b);
  }
 else   if (field.getType().isAssignableFrom(float.class)) {
    try {
      field.setFloat(action,Float.parseFloat(value));
    }
 catch (    NumberFormatException ignored) {
    }
  }
 else   if (field.getType().isAssignableFrom(Float.class)) {
    try {
      Float f=null;
      if (value != null)       f=Float.valueOf(value);
      field.set(action,f);
    }
 catch (    NumberFormatException ignored) {
    }
  }
 else   if (field.getType().isAssignableFrom(int.class)) {
    try {
      Integer i=null;
      if (value != null)       i=Integer.parseInt(value);
      field.setInt(action,i);
    }
 catch (    NumberFormatException ignored) {
    }
  }
 else   if (field.getType().isAssignableFrom(Vector2.class)) {
    field.set(action,Param.parseVector2(value));
  }
 else   if (field.getType().isAssignableFrom(SceneActorRef.class)) {
    if (value == null)     field.set(action,null);
 else     field.set(action,new SceneActorRef(value));
  }
 else   if (field.getType().isAssignableFrom(ActorAnimationRef.class)) {
    if (value == null)     field.set(action,null);
 else     field.set(action,new ActorAnimationRef(value));
  }
 else   if (field.getType().isAssignableFrom(Color.class)) {
    Color a=Param.parseColor(value);
    field.set(action,a);
  }
 else   if (field.getType().isEnum()) {
    field.set(action,Enum.valueOf(field.getType().asSubclass(Enum.class),value.toUpperCase()));
  }
 else {
    EngineLogger.error(""String_Node_Str"" + field.getType());
  }
  field.setAccessible(accessible);
}","@SuppressWarnings(""String_Node_Str"") public static void setParam(Action action,String param,String value) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
  Class<?> clazz=action.getClass();
  Field field=getField(clazz,param);
  if (field == null)   throw new NoSuchFieldException(param);
  final boolean accessible=field.isAccessible();
  field.setAccessible(true);
  if (field.getType().isAssignableFrom(String.class)) {
    field.set(action,value);
  }
 else   if (field.getType().isAssignableFrom(boolean.class)) {
    field.setBoolean(action,Boolean.parseBoolean(value));
  }
 else   if (field.getType().isAssignableFrom(Boolean.class)) {
    Boolean b=null;
    if (value != null)     b=Boolean.valueOf(value);
    field.set(action,b);
  }
 else   if (field.getType().isAssignableFrom(float.class)) {
    try {
      field.setFloat(action,Float.parseFloat(value));
    }
 catch (    NumberFormatException ignored) {
    }
  }
 else   if (field.getType().isAssignableFrom(Float.class)) {
    try {
      Float f=null;
      if (value != null)       f=Float.valueOf(value);
      field.set(action,f);
    }
 catch (    NumberFormatException ignored) {
    }
  }
 else   if (field.getType().isAssignableFrom(int.class)) {
    try {
      Integer i=null;
      if (value != null)       i=Integer.parseInt(value);
      field.setInt(action,i);
    }
 catch (    NumberFormatException ignored) {
    }
  }
 else   if (field.getType().isAssignableFrom(Vector2.class)) {
    field.set(action,Param.parseVector2(value));
  }
 else   if (field.getType().isAssignableFrom(SceneActorRef.class)) {
    if (value == null)     field.set(action,null);
 else     field.set(action,new SceneActorRef(value));
  }
 else   if (field.getType().isAssignableFrom(ActorAnimationRef.class)) {
    if (value == null)     field.set(action,null);
 else     field.set(action,new ActorAnimationRef(value));
  }
 else   if (field.getType().isAssignableFrom(Color.class)) {
    Color a=Param.parseColor(value);
    field.set(action,a);
  }
 else   if (field.getType().isEnum()) {
    field.set(action,Enum.valueOf(field.getType().asSubclass(Enum.class),value.toUpperCase(Locale.ENGLISH)));
  }
 else {
    EngineLogger.error(""String_Node_Str"" + field.getType());
  }
  field.setAccessible(accessible);
}",0.9969578444154716
30200,"@Override public void create(){
  skin=new BladeSkin(Gdx.files.internal(SKIN));
  EditorLogger.setDebug();
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  setCtx();
  Message.init(skin);
  scnEditor=new ScnEditor(skin);
  scnEditor.setBackground(""String_Node_Str"");
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table(skin);
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill().left();
  rightPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  splitPaneRight.setSplitAmount(0.75f);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table(skin);
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(0).left();
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill().left();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill().left();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill().left();
  leftPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.25f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
      if (!Ctx.project.checkVersion()) {
        new Dialog(""String_Node_Str"",skin){
          protected void result(          Object object){
            if (((Boolean)object).booleanValue()) {
              try {
                Ctx.project.updateEngineVersion();
                Message.showMsg(getStage(),""String_Node_Str"",3);
              }
 catch (              IOException e1) {
                String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                EditorLogger.error(msg,e1);
              }
            }
          }
        }
.text(""String_Node_Str"" + Ctx.project.getProjectBladeEngineVersion() + ""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(stage);
      }
    }
 catch (    Exception e) {
      EditorLogger.error(""String_Node_Str"",e);
      Ctx.project.closeProject();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().instant();
}","@Override public void create(){
  Gdx.graphics.setWindowedMode(Math.max((int)(Gdx.graphics.getDisplayMode().width * 0.9),1920 / 2),Math.max((int)(Gdx.graphics.getDisplayMode().height * 0.9),1080 / 2));
  skin=new BladeSkin(Gdx.files.internal(SKIN));
  EditorLogger.setDebug();
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  setCtx();
  Message.init(skin);
  scnEditor=new ScnEditor(skin);
  scnEditor.setBackground(""String_Node_Str"");
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table(skin);
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill().left();
  rightPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  splitPaneRight.setSplitAmount(0.75f);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table(skin);
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(0).left();
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill().left();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill().left();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill().left();
  leftPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.25f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
      if (!Ctx.project.checkVersion()) {
        new Dialog(""String_Node_Str"",skin){
          protected void result(          Object object){
            if (((Boolean)object).booleanValue()) {
              try {
                Ctx.project.updateEngineVersion();
                Message.showMsg(getStage(),""String_Node_Str"",3);
              }
 catch (              IOException e1) {
                String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                EditorLogger.error(msg,e1);
              }
            }
          }
        }
.text(""String_Node_Str"" + Ctx.project.getProjectBladeEngineVersion() + ""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(stage);
      }
    }
 catch (    Exception e) {
      EditorLogger.error(""String_Node_Str"",e);
      Ctx.project.closeProject();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().instant();
}",0.9723217193096712
30201,"public Main(Editor editor,LwjglApplicationConfiguration cfg){
  super(editor,cfg);
  Gdx.graphics.setWindowedMode((int)(Gdx.graphics.getDisplayMode().width * 0.9),(int)(Gdx.graphics.getDisplayMode().height * 0.9));
}","public Main(Editor editor,LwjglApplicationConfiguration cfg){
  super(editor,cfg);
  Gdx.graphics.setWindowedMode(Math.max((int)(Gdx.graphics.getDisplayMode().width * 0.9),1920 / 2),Math.max((int)(Gdx.graphics.getDisplayMode().height * 0.9),1080 / 2));
}",0.9191489361702128
30202,"@Override public void update(float delta){
  if (complete)   return;
  if (currentSource != null && currentSource.skeleton != null) {
    float d=delta;
    if (currentAnimationType == Tween.Type.REVERSE) {
      d=-delta;
      if (lastAnimationTime < 0) {
        lastAnimationTime=0;
        animationListener.complete(0,1);
        return;
      }
    }
    lastAnimationTime+=d;
    if (lastAnimationTime >= 0)     updateAnimation(d);
  }
}","@Override public void update(float delta){
  if (complete) {
    return;
  }
  if (currentSource != null && currentSource.skeleton != null) {
    float d=delta;
    if (currentAnimationType == Tween.Type.REVERSE) {
      d=-delta;
      if (lastAnimationTime < 0) {
        lastAnimationTime=0;
        animationListener.complete(0,1);
        return;
      }
    }
    lastAnimationTime+=d;
    if (lastAnimationTime >= 0)     updateAnimation(d);
  }
}",0.9710467706013364
30203,"@Override public void complete(int trackIndex,int loopCount){
  if (complete)   return;
  if ((currentAnimationType == Tween.Type.REPEAT || currentAnimationType == Tween.Type.REVERSE_REPEAT) && (currentCount == Tween.INFINITY || currentCount > loopCount)) {
    return;
  }
  complete=true;
  computeBbox();
  if (animationCb != null) {
    ActionCallbackQueue.add(animationCb);
    animationCb=null;
  }
}","@Override public void complete(int trackIndex,int loopCount){
  if (complete)   return;
  if ((currentAnimationType == Tween.Type.REPEAT || currentAnimationType == Tween.Type.REVERSE_REPEAT) && (currentCount == Tween.INFINITY || currentCount > loopCount)) {
    currentSource.skeleton.setToSetupPose();
    currentSource.skeleton.setFlipX(flipX);
    complete=true;
    currentSource.animation.update(0);
    currentSource.animation.apply(currentSource.skeleton);
    currentSource.skeleton.updateWorldTransform();
    complete=false;
    return;
  }
  complete=true;
  computeBbox();
  if (animationCb != null) {
    ActionCallbackQueue.add(animationCb);
    animationCb=null;
  }
}",0.7456382001836547
30204,"public void update(AtlasRenderer a,float delta){
  update(delta);
  if (!isComplete())   a.setFrame((int)(getPercent() * a.getNumFrames()));
}","public void update(AtlasRenderer a,float delta){
  update(delta);
  if (!isComplete() && getPercent() < 1.0f)   a.setFrame((int)(getPercent() * a.getNumFrames()));
}",0.9250814332247556
30205,"@Override protected void paste(){
  BaseActor newElement=(BaseActor)ElementUtils.cloneElement(clipboard);
  newElement.setId(ElementUtils.getCheckedId(newElement.getId(),parent.getActors().keySet().toArray(new String[0])));
  int pos=list.getSelectedIndex() + 1;
  list.getItems().insert(pos,newElement);
  parent.addActor(newElement);
  Ctx.project.getI18N().extractStrings(parent.getId(),newElement);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  Ctx.project.setModified();
}","@Override protected void paste(){
  BaseActor newElement=(BaseActor)ElementUtils.cloneElement(clipboard);
  newElement.setId(ElementUtils.getCheckedId(newElement.getId(),parent.getActors().keySet().toArray(new String[0])));
  int pos=list.getSelectedIndex() + 1;
  list.getItems().insert(pos,newElement);
  parent.addActor(newElement);
  Ctx.project.getI18N().extractStrings(parent.getId(),newElement);
  if (newElement instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)newElement;
    ia.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    ia.retrieveAssets();
  }
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  Ctx.project.setModified();
}",0.8271812080536913
30206,"@Override public void create(){
  skin=new BladeSkin(Gdx.files.internal(SKIN));
  EditorLogger.setDebug();
  EditorLogger.debug(""String_Node_Str"");
  Ctx.project=new Project();
  Message.init(skin);
  Ctx.assetManager=new EditorAssetManager();
  scnEditor=new ScnEditor(skin);
  scnEditor.setBackground(""String_Node_Str"");
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table(skin);
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill().left();
  rightPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  splitPaneRight.setSplitAmount(0.75f);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table(skin);
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(0).left();
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill().left();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill().left();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill().left();
  leftPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.25f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
      if (!Ctx.project.checkVersion()) {
        new Dialog(""String_Node_Str"",skin){
          protected void result(          Object object){
            if (((Boolean)object).booleanValue()) {
              try {
                Ctx.project.updateEngineVersion();
              }
 catch (              IOException e1) {
                String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                e1.printStackTrace();
              }
            }
            ((Main)Gdx.app).exitSaved();
          }
        }
.text(""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(stage);
      }
    }
 catch (    Exception e) {
      EditorLogger.debug(""String_Node_Str"" + e.getMessage());
      Ctx.project.closeProject();
      e.printStackTrace();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().instant();
}","@Override public void create(){
  skin=new BladeSkin(Gdx.files.internal(SKIN));
  EditorLogger.setDebug();
  EditorLogger.debug(""String_Node_Str"");
  Ctx.project=new Project();
  Message.init(skin);
  Ctx.assetManager=new EditorAssetManager();
  scnEditor=new ScnEditor(skin);
  scnEditor.setBackground(""String_Node_Str"");
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table(skin);
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill().left();
  rightPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  splitPaneRight.setSplitAmount(0.75f);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table(skin);
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(0).left();
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill().left();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill().left();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill().left();
  leftPanel.setBackground(""String_Node_Str"");
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.25f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
      if (!Ctx.project.checkVersion()) {
        new Dialog(""String_Node_Str"",skin){
          protected void result(          Object object){
            if (((Boolean)object).booleanValue()) {
              try {
                Ctx.project.updateEngineVersion();
              }
 catch (              IOException e1) {
                String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                e1.printStackTrace();
              }
            }
          }
        }
.text(""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(stage);
      }
    }
 catch (    Exception e) {
      EditorLogger.debug(""String_Node_Str"" + e.getMessage());
      Ctx.project.closeProject();
      e.printStackTrace();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().instant();
}",0.993201790747803
30207,"private void loadProject(){
  Platform.runLater(new Runnable(){
    @Override public void run(){
      final DirectoryChooser chooser=new DirectoryChooser();
      chooser.setTitle(""String_Node_Str"");
      chooser.setInitialDirectory(Ctx.project.getProjectDir() != null ? Ctx.project.getProjectDir() : new File(""String_Node_Str""));
      final File dir=chooser.showDialog(null);
      if (dir == null) {
        return;
      }
      Message.showMsg(getStage(),""String_Node_Str"",true);
      Timer.post(new Task(){
        @Override public void run(){
          try {
            Ctx.project.loadProject(dir);
            playBtn.setDisabled(false);
            packageBtn.setDisabled(false);
            Message.showMsg(getStage(),null);
            if (!Ctx.project.checkVersion()) {
              new Dialog(""String_Node_Str"",skin){
                protected void result(                Object object){
                  if (((Boolean)object).booleanValue()) {
                    try {
                      Ctx.project.updateEngineVersion();
                    }
 catch (                    IOException e1) {
                      String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                      Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                      e1.printStackTrace();
                    }
                  }
                  ((Main)Gdx.app).exitSaved();
                }
              }
.text(""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(getStage());
            }
          }
 catch (          Exception ex) {
            if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
              String msg=""String_Node_Str"";
              Message.showMsg(getStage(),msg,true);
              Timer.post(new Task(){
                @Override public void run(){
                  if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
                    try {
                      Ctx.project.loadProject(dir);
                      playBtn.setDisabled(false);
                      packageBtn.setDisabled(false);
                      Message.showMsg(getStage(),""String_Node_Str"",3);
                    }
 catch (                    IOException e) {
                      String msg=e.getClass().getSimpleName() + ""String_Node_Str"" + e.getMessage();
                      Message.hideMsg();
                      Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                    }
                  }
 else {
                    Message.hideMsg();
                    Message.showMsgDialog(getStage(),""String_Node_Str"",""String_Node_Str"");
                  }
                }
              }
);
            }
 else {
              String msg=ex.getClass().getSimpleName() + ""String_Node_Str"" + ex.getMessage();
              Message.hideMsg();
              Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
            }
            ex.printStackTrace();
          }
        }
      }
);
    }
  }
);
}","private void loadProject(){
  Platform.runLater(new Runnable(){
    @Override public void run(){
      final DirectoryChooser chooser=new DirectoryChooser();
      chooser.setTitle(""String_Node_Str"");
      chooser.setInitialDirectory(Ctx.project.getProjectDir() != null ? Ctx.project.getProjectDir() : new File(""String_Node_Str""));
      final File dir=chooser.showDialog(null);
      if (dir == null) {
        return;
      }
      Message.showMsg(getStage(),""String_Node_Str"",true);
      Timer.post(new Task(){
        @Override public void run(){
          try {
            Ctx.project.loadProject(dir);
            playBtn.setDisabled(false);
            packageBtn.setDisabled(false);
            Message.showMsg(getStage(),null);
            if (!Ctx.project.checkVersion()) {
              new Dialog(""String_Node_Str"",skin){
                protected void result(                Object object){
                  if (((Boolean)object).booleanValue()) {
                    try {
                      Ctx.project.updateEngineVersion();
                    }
 catch (                    IOException e1) {
                      String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
                      Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                      e1.printStackTrace();
                    }
                  }
                }
              }
.text(""String_Node_Str"").button(""String_Node_Str"",true).button(""String_Node_Str"",false).key(Keys.ENTER,true).key(Keys.ESCAPE,false).show(getStage());
            }
          }
 catch (          Exception ex) {
            if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
              String msg=""String_Node_Str"";
              Message.showMsg(getStage(),msg,true);
              Timer.post(new Task(){
                @Override public void run(){
                  if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
                    try {
                      Ctx.project.loadProject(dir);
                      playBtn.setDisabled(false);
                      packageBtn.setDisabled(false);
                      Message.showMsg(getStage(),""String_Node_Str"",3);
                    }
 catch (                    IOException e) {
                      String msg=e.getClass().getSimpleName() + ""String_Node_Str"" + e.getMessage();
                      Message.hideMsg();
                      Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
                    }
                  }
 else {
                    Message.hideMsg();
                    Message.showMsgDialog(getStage(),""String_Node_Str"",""String_Node_Str"");
                  }
                }
              }
);
            }
 else {
              String msg=ex.getClass().getSimpleName() + ""String_Node_Str"" + ex.getMessage();
              Message.hideMsg();
              Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
            }
            ex.printStackTrace();
          }
        }
      }
);
    }
  }
);
}",0.9925902569761942
30208,"@Override protected void modelToInputs(){
  id.setText(e.getId());
  filename.setText(e.getFilename());
  loop.setText(Boolean.toString(e.getLoop()));
  volume.setText(Float.toString(e.getVolume()));
  pan.setText(Float.toString(e.getPan()));
  loop.setText(Boolean.toString(e.isPreload()));
}","@Override protected void modelToInputs(){
  id.setText(e.getId());
  filename.setText(e.getFilename());
  loop.setText(Boolean.toString(e.getLoop()));
  volume.setText(Float.toString(e.getVolume()));
  pan.setText(Float.toString(e.getPan()));
  preload.setText(Boolean.toString(e.isPreload()));
}",0.9813242784380306
30209,"public void update(float delta){
  if (complete)   return;
  if (!began) {
    began=true;
  }
  time+=delta;
  if (time >= duration) {
    if (type == Type.NO_REPEAT || type == Type.REVERSE || count == 1) {
      complete=true;
    }
 else     if (count != 1) {
      complete=false;
      count--;
      time=0;
      if (type == Type.YOYO)       reverse=!reverse;
    }
  }
  if (complete) {
    callCb();
  }
}","public void update(float delta){
  if (complete)   return;
  if (!began) {
    began=true;
  }
  time+=delta;
  if (time >= duration) {
    if (type == Type.NO_REPEAT || type == Type.REVERSE || count == 1) {
      complete=true;
    }
 else     if (count != 1) {
      complete=false;
      count--;
      time=0.00001f;
      if (type == Type.YOYO)       reverse=!reverse;
    }
  }
  if (complete) {
    callCb();
  }
}",0.991616766467066
30210,"@Override public void scopeChanged(String scope){
  if (WORLD_SCOPE.equals(scope)) {
    addElements(World.getInstance().getVerbManager(),Arrays.asList(World.getInstance().getVerbManager().getVerbs().values().toArray(new Verb[0])));
  }
 else   if (SCENE_SCOPE.equals(scope)) {
    addElements(Ctx.project.getSelectedScene().getVerbManager(),Arrays.asList(Ctx.project.getSelectedScene().getVerbManager().getVerbs().values().toArray(new Verb[0])));
  }
 else   if (ACTOR_SCOPE.equals(scope)) {
    BaseActor a=Ctx.project.getSelectedActor();
    if (a instanceof InteractiveActor) {
      addElements(((InteractiveActor)a).getVerbManager(),Arrays.asList(((InteractiveActor)a).getVerbManager().getVerbs().values().toArray(new Verb[0])));
    }
 else {
      addElements(null,null);
    }
  }
}","@Override public void scopeChanged(String scope){
  if (WORLD_SCOPE.equals(scope)) {
    addElements(World.getInstance().getVerbManager(),Arrays.asList(World.getInstance().getVerbManager().getVerbs().values().toArray(new Verb[0])));
  }
 else   if (SCENE_SCOPE.equals(scope)) {
    if (Ctx.project.getSelectedScene() != null)     addElements(Ctx.project.getSelectedScene().getVerbManager(),Arrays.asList(Ctx.project.getSelectedScene().getVerbManager().getVerbs().values().toArray(new Verb[0])));
 else     addElements(null,null);
  }
 else   if (ACTOR_SCOPE.equals(scope)) {
    BaseActor a=Ctx.project.getSelectedActor();
    if (a instanceof InteractiveActor) {
      addElements(((InteractiveActor)a).getVerbManager(),Arrays.asList(((InteractiveActor)a).getVerbManager().getVerbs().values().toArray(new Verb[0])));
    }
 else {
      addElements(null,null);
    }
  }
}",0.950721153846154
30211,"public VerbList(Skin skin){
  super(skin,true);
  clearChildren();
  scopePanel=new ScopePanel(skin){
    @Override public void scopeChanged(    String scope){
      if (WORLD_SCOPE.equals(scope)) {
        addElements(World.getInstance().getVerbManager(),Arrays.asList(World.getInstance().getVerbManager().getVerbs().values().toArray(new Verb[0])));
      }
 else       if (SCENE_SCOPE.equals(scope)) {
        addElements(Ctx.project.getSelectedScene().getVerbManager(),Arrays.asList(Ctx.project.getSelectedScene().getVerbManager().getVerbs().values().toArray(new Verb[0])));
      }
 else       if (ACTOR_SCOPE.equals(scope)) {
        BaseActor a=Ctx.project.getSelectedActor();
        if (a instanceof InteractiveActor) {
          addElements(((InteractiveActor)a).getVerbManager(),Arrays.asList(((InteractiveActor)a).getVerbManager().getVerbs().values().toArray(new Verb[0])));
        }
 else {
          addElements(null,null);
        }
      }
    }
  }
;
  add(scopePanel).expandX().fillX();
  row();
  add(toolbar).expandX().fillX();
  row().fill();
  add(container).expandY().fill();
  actionList=new ActionList(skin);
  row();
  add(actionList).expand().fill();
  list.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      addActions();
    }
  }
);
  list.setCellRenderer(listCellRenderer);
  listCellRenderer.layout(list.getStyle());
  container.minHeight(listCellRenderer.getItemHeight() * 5);
  container.maxHeight(listCellRenderer.getItemHeight() * 5);
  Ctx.project.addPropertyChangeListener(Project.NOTIFY_ELEMENT_CREATED,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getNewValue() instanceof Verb && !(evt.getSource() instanceof EditVerbDialog)) {
        if (ScopePanel.WORLD_SCOPE.equals(scopePanel.getScope())) {
          addElements(World.getInstance().getVerbManager(),Arrays.asList(World.getInstance().getVerbManager().getVerbs().values().toArray(new Verb[0])));
        }
 else         if (ScopePanel.SCENE_SCOPE.equals(scopePanel.getScope())) {
          addElements(Ctx.project.getSelectedScene().getVerbManager(),Arrays.asList(Ctx.project.getSelectedScene().getVerbManager().getVerbs().values().toArray(new Verb[0])));
        }
 else         if (ScopePanel.ACTOR_SCOPE.equals(scopePanel.getScope())) {
          BaseActor a=Ctx.project.getSelectedActor();
          if (a instanceof InteractiveActor) {
            addElements(((InteractiveActor)a).getVerbManager(),Arrays.asList(((InteractiveActor)a).getVerbManager().getVerbs().values().toArray(new Verb[0])));
          }
 else {
            addElements(null,null);
          }
        }
      }
    }
  }
);
}","public VerbList(Skin skin){
  super(skin,true);
  clearChildren();
  scopePanel=new ScopePanel(skin){
    @Override public void scopeChanged(    String scope){
      if (WORLD_SCOPE.equals(scope)) {
        addElements(World.getInstance().getVerbManager(),Arrays.asList(World.getInstance().getVerbManager().getVerbs().values().toArray(new Verb[0])));
      }
 else       if (SCENE_SCOPE.equals(scope)) {
        if (Ctx.project.getSelectedScene() != null)         addElements(Ctx.project.getSelectedScene().getVerbManager(),Arrays.asList(Ctx.project.getSelectedScene().getVerbManager().getVerbs().values().toArray(new Verb[0])));
 else         addElements(null,null);
      }
 else       if (ACTOR_SCOPE.equals(scope)) {
        BaseActor a=Ctx.project.getSelectedActor();
        if (a instanceof InteractiveActor) {
          addElements(((InteractiveActor)a).getVerbManager(),Arrays.asList(((InteractiveActor)a).getVerbManager().getVerbs().values().toArray(new Verb[0])));
        }
 else {
          addElements(null,null);
        }
      }
    }
  }
;
  add(scopePanel).expandX().fillX();
  row();
  add(toolbar).expandX().fillX();
  row().fill();
  add(container).expandY().fill();
  actionList=new ActionList(skin);
  row();
  add(actionList).expand().fill();
  list.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      addActions();
    }
  }
);
  list.setCellRenderer(listCellRenderer);
  listCellRenderer.layout(list.getStyle());
  container.minHeight(listCellRenderer.getItemHeight() * 5);
  container.maxHeight(listCellRenderer.getItemHeight() * 5);
  Ctx.project.addPropertyChangeListener(Project.NOTIFY_ELEMENT_CREATED,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getNewValue() instanceof Verb && !(evt.getSource() instanceof EditVerbDialog)) {
        if (ScopePanel.WORLD_SCOPE.equals(scopePanel.getScope())) {
          addElements(World.getInstance().getVerbManager(),Arrays.asList(World.getInstance().getVerbManager().getVerbs().values().toArray(new Verb[0])));
        }
 else         if (ScopePanel.SCENE_SCOPE.equals(scopePanel.getScope())) {
          addElements(Ctx.project.getSelectedScene().getVerbManager(),Arrays.asList(Ctx.project.getSelectedScene().getVerbManager().getVerbs().values().toArray(new Verb[0])));
        }
 else         if (ScopePanel.ACTOR_SCOPE.equals(scopePanel.getScope())) {
          BaseActor a=Ctx.project.getSelectedActor();
          if (a instanceof InteractiveActor) {
            addElements(((InteractiveActor)a).getVerbManager(),Arrays.asList(((InteractiveActor)a).getVerbManager().getVerbs().values().toArray(new Verb[0])));
          }
 else {
            addElements(null,null);
          }
        }
      }
    }
  }
);
}",0.9837720879913452
30212,"private void setAction(){
  String id=actionPanel.getText();
  getCenterPanel().clear();
  addInputPanel(actionPanel);
  Action tmp=null;
  if (id.equals(CUSTOM_ACTION_STR)) {
    addInputPanel(classPanel);
    if (classPanel != null && classPanel.getText() != null && !classPanel.getText().trim().isEmpty())     tmp=ActionFactory.createByClass(classPanel.getText(),null);
    if (tmp == null) {
      classPanel.setError(true);
    }
 else {
      classPanel.setError(false);
    }
    getStage().setKeyboardFocus(classPanel.getField());
    setInfo(CUSTOM_INFO);
  }
 else {
    tmp=ActionFactory.create(id,null);
    setInfo(ActionUtils.getInfo(tmp));
  }
  if (e == null || tmp == null || !(e.getClass().getName().equals(tmp.getClass().getName())))   e=tmp;
  if (e != null) {
    Param[] params=ActionUtils.getParams(e);
    i=new InputPanel[params.length];
    for (int j=0; j < params.length; j++) {
      if (params[j].options instanceof Enum[]) {
        i[j]=InputPanelFactory.createInputPanel(getSkin(),params[j].name,params[j].desc,params[j].type,params[j].mandatory,params[j].defaultValue,(Enum[])params[j].options);
      }
 else {
        i[j]=InputPanelFactory.createInputPanel(getSkin(),params[j].name,params[j].desc,params[j].type,params[j].mandatory,params[j].defaultValue,(String[])params[j].options);
      }
      addInputPanel(i[j]);
      if ((i[j].getField() instanceof TextField && params[j].name.toLowerCase().endsWith(""String_Node_Str"")) || i[j].getField() instanceof ScrollPane) {
        i[j].getCell(i[j].getField()).fillX();
      }
    }
  }
 else {
    i=new InputPanel[0];
  }
}","private void setAction(){
  String id=actionPanel.getText();
  getCenterPanel().clear();
  addInputPanel(actionPanel);
  Action tmp=null;
  if (id.equals(CUSTOM_ACTION_STR)) {
    addInputPanel(classPanel);
    if (classPanel != null && classPanel.getText() != null && !classPanel.getText().trim().isEmpty())     tmp=ActionFactory.createByClass(classPanel.getText(),null);
    if (tmp == null) {
      classPanel.setError(true);
    }
 else {
      classPanel.setError(false);
    }
    if (getStage() != null)     getStage().setKeyboardFocus(classPanel.getField());
    setInfo(CUSTOM_INFO);
  }
 else {
    tmp=ActionFactory.create(id,null);
    setInfo(ActionUtils.getInfo(tmp));
  }
  if (e == null || tmp == null || !(e.getClass().getName().equals(tmp.getClass().getName())))   e=tmp;
  if (e != null) {
    Param[] params=ActionUtils.getParams(e);
    i=new InputPanel[params.length];
    for (int j=0; j < params.length; j++) {
      if (params[j].options instanceof Enum[]) {
        i[j]=InputPanelFactory.createInputPanel(getSkin(),params[j].name,params[j].desc,params[j].type,params[j].mandatory,params[j].defaultValue,(Enum[])params[j].options);
      }
 else {
        i[j]=InputPanelFactory.createInputPanel(getSkin(),params[j].name,params[j].desc,params[j].type,params[j].mandatory,params[j].defaultValue,(String[])params[j].options);
      }
      addInputPanel(i[j]);
      if ((i[j].getField() instanceof TextField && params[j].name.toLowerCase().endsWith(""String_Node_Str"")) || i[j].getField() instanceof ScrollPane) {
        i[j].getCell(i[j].getField()).fillX();
      }
    }
  }
 else {
    i=new InputPanel[0];
  }
}",0.9913952059004304
30213,"@Override public void act(float delta){
  super.act(delta);
  Text currentSubtitle=World.getInstance().getTextManager().getCurrentText();
  if (subtitle != currentSubtitle) {
    subtitle=currentSubtitle;
    if (currentSubtitle == null && isVisible()) {
      setVisible(false);
    }
 else     if (currentSubtitle != null && !isVisible()) {
      setVisible(true);
    }
    if (isVisible()) {
      float posx=currentSubtitle.x;
      float posy=currentSubtitle.y;
      unprojectTmp.set(posx,posy,0);
      World.getInstance().getSceneCamera().scene2screen(getStage().getViewport(),unprojectTmp);
      float maxWidth=currentSubtitle.type == Text.Type.TALK ? maxTalkWidth : maxRectangleWidth;
      final TextManagerUIStyle style=getStyle(currentSubtitle);
      Color color=currentSubtitle.color != null ? currentSubtitle.color : style.defaultColor;
      if (color == null)       color=Color.BLACK;
      layout.setText(style.font,currentSubtitle.str,color,maxWidth,Align.center,true);
      if (posx == TextManager.POS_CENTER || posx == TextManager.POS_SUBTITLE) {
        posx=(getStage().getViewport().getScreenWidth() - layout.width) / 2;
        fontX=(getStage().getViewport().getScreenWidth() - maxWidth) / 2;
      }
 else {
        posx=unprojectTmp.x;
        fontX=unprojectTmp.x;
      }
      if (posy == TextManager.POS_CENTER) {
        posy=(getStage().getViewport().getScreenHeight() - layout.height) / 2;
      }
 else       if (posy == TextManager.POS_SUBTITLE) {
        posy=getStage().getViewport().getScreenHeight() - layout.height - DPIUtils.getMarginSize() * 4;
      }
 else {
        posy=unprojectTmp.y;
      }
      setPosition(posx - PADDING,posy - PADDING);
      setSize(layout.width + PADDING * 2,layout.height + PADDING * 2);
      if (currentSubtitle.type == Text.Type.TALK) {
        if (style.talkBubble != null) {
          setY(getY() + DPIUtils.getTouchMinSize() / 3 + PADDING);
        }
 else {
          setY(getY() + PADDING);
        }
        setX(getX() - layout.width / 2);
        fontX=posx - maxWidth / 2;
        if (getX() < 0 && getX() > -getWidth()) {
          setX(0 + PADDING);
          fontX=getX() + PADDING + (layout.width - maxWidth) / 2;
        }
 else         if (getX() + getWidth() > getStage().getViewport().getScreenWidth() && getX() + getWidth() < getStage().getViewport().getScreenWidth() + getWidth()) {
          setX(getStage().getViewport().getScreenWidth() - getWidth());
          fontX=getStage().getViewport().getScreenWidth() - layout.width / 2 - PADDING - maxWidth / 2;
        }
        if (getY() + getHeight() > getStage().getViewport().getScreenHeight()) {
          setY(getStage().getViewport().getScreenHeight() - getHeight() - PADDING);
        }
      }
    }
  }
}","@Override public void act(float delta){
  super.act(delta);
  Text currentSubtitle=World.getInstance().getTextManager().getCurrentText();
  if (subtitle != currentSubtitle) {
    subtitle=currentSubtitle;
    if (currentSubtitle == null && isVisible()) {
      setVisible(false);
    }
 else     if (currentSubtitle != null && !isVisible()) {
      setVisible(true);
    }
    if (isVisible()) {
      float posx=currentSubtitle.x;
      float posy=currentSubtitle.y;
      unprojectTmp.set(posx,posy,0);
      World.getInstance().getSceneCamera().scene2screen(getStage().getViewport(),unprojectTmp);
      float maxWidth=currentSubtitle.type == Text.Type.TALK ? maxTalkWidth : maxRectangleWidth;
      final TextManagerUIStyle style=getStyle(currentSubtitle);
      Color color=currentSubtitle.color != null ? currentSubtitle.color : style.defaultColor;
      if (color == null)       color=Color.BLACK;
      layout.setText(style.font,currentSubtitle.str,color,maxWidth,Align.center,true);
      if (posx == TextManager.POS_CENTER || posx == TextManager.POS_SUBTITLE) {
        posx=(getStage().getViewport().getScreenWidth() - layout.width) / 2;
        fontX=(getStage().getViewport().getScreenWidth() - maxWidth) / 2;
      }
 else {
        posx=unprojectTmp.x;
        fontX=posx + (layout.width - maxWidth) / 2;
      }
      if (posy == TextManager.POS_CENTER) {
        posy=(getStage().getViewport().getScreenHeight() - layout.height) / 2;
      }
 else       if (posy == TextManager.POS_SUBTITLE) {
        posy=getStage().getViewport().getScreenHeight() - layout.height - DPIUtils.getMarginSize() * 4;
      }
 else {
        posy=unprojectTmp.y;
      }
      setPosition(posx - PADDING,posy - PADDING);
      setSize(layout.width + PADDING * 2,layout.height + PADDING * 2);
      if (currentSubtitle.type == Text.Type.TALK) {
        if (style.talkBubble != null) {
          setY(getY() + DPIUtils.getTouchMinSize() / 3 + PADDING);
        }
 else {
          setY(getY() + PADDING);
        }
        setX(getX() - layout.width / 2);
        fontX=posx - maxWidth / 2;
        if (getX() < 0 && getX() > -getWidth()) {
          setX(0 + PADDING);
          fontX=getX() + PADDING + (layout.width - maxWidth) / 2;
        }
 else         if (getX() + getWidth() > getStage().getViewport().getScreenWidth() && getX() + getWidth() < getStage().getViewport().getScreenWidth() + getWidth()) {
          setX(getStage().getViewport().getScreenWidth() - getWidth());
          fontX=getStage().getViewport().getScreenWidth() - layout.width / 2 - PADDING - maxWidth / 2;
        }
        if (getY() + getHeight() > getStage().getViewport().getScreenHeight()) {
          setY(getStage().getViewport().getScreenHeight() - getHeight() - PADDING);
        }
      }
    }
  }
}",0.9913482335976928
30214,"@Override public boolean keyUp(int keycode){
switch (keycode) {
case Input.Keys.ESCAPE:
case Input.Keys.BACK:
case Input.Keys.MENU:
    showMenu();
  break;
case Input.Keys.SPACE:
if (drawHotspots) drawHotspots=false;
break;
}
return true;
}","@Override public boolean keyUp(int keycode){
switch (keycode) {
case Input.Keys.ESCAPE:
case Input.Keys.BACK:
case Input.Keys.MENU:
    showMenu();
  break;
case Input.Keys.D:
if (UIUtils.ctrl()) EngineLogger.toggle();
break;
case Input.Keys.SPACE:
if (drawHotspots) drawHotspots=false;
break;
}
return true;
}",0.8747731397459165
30215,"@Override public boolean keyTyped(char character){
switch (character) {
case 'd':
    if (UIUtils.ctrl())     EngineLogger.toggle();
  break;
case '1':
EngineLogger.setDebugLevel(EngineLogger.DEBUG0);
break;
case '2':
EngineLogger.setDebugLevel(EngineLogger.DEBUG1);
break;
case '3':
EngineLogger.setDebugLevel(EngineLogger.DEBUG2);
break;
case 'f':
break;
case 's':
try {
World.getInstance().saveGameState();
}
 catch (IOException e) {
EngineLogger.error(e.getMessage());
}
break;
case 'l':
try {
World.getInstance().loadGameState();
}
 catch (IOException e) {
EngineLogger.error(e.getMessage());
}
break;
case 't':
testerBot.setEnabled(!testerBot.isEnabled());
break;
case '.':
if (recorder.isRecording()) recorder.setRecording(false);
 else recorder.setRecording(true);
break;
case ',':
if (recorder.isPlaying()) recorder.setPlaying(false);
 else {
recorder.load();
recorder.setPlaying(true);
}
break;
case 'p':
if (World.getInstance().isPaused()) {
World.getInstance().resume();
}
 else {
World.getInstance().pause();
}
break;
case ' ':
if (state == UIStates.SCENE_MODE) {
drawHotspots=true;
}
break;
}
return false;
}","@Override public boolean keyTyped(char character){
switch (character) {
case '1':
    EngineLogger.setDebugLevel(EngineLogger.DEBUG0);
  break;
case '2':
EngineLogger.setDebugLevel(EngineLogger.DEBUG1);
break;
case '3':
EngineLogger.setDebugLevel(EngineLogger.DEBUG2);
break;
case 'f':
break;
case 's':
try {
World.getInstance().saveGameState();
}
 catch (IOException e) {
EngineLogger.error(e.getMessage());
}
break;
case 'l':
try {
World.getInstance().loadGameState();
}
 catch (IOException e) {
EngineLogger.error(e.getMessage());
}
break;
case 't':
testerBot.setEnabled(!testerBot.isEnabled());
break;
case '.':
if (recorder.isRecording()) recorder.setRecording(false);
 else recorder.setRecording(true);
break;
case ',':
if (recorder.isPlaying()) recorder.setPlaying(false);
 else {
recorder.load();
recorder.setPlaying(true);
}
break;
case 'p':
if (World.getInstance().isPaused()) {
World.getInstance().resume();
}
 else {
World.getInstance().pause();
}
break;
case ' ':
if (state == UIStates.SCENE_MODE) {
drawHotspots=true;
}
break;
}
return false;
}",0.9678899082568808
30216,"private void processCreditMusic(String s){
  if (music != null)   music.dispose();
  music=Gdx.audio.newMusic(EngineAssetManager.getInstance().getAsset(""String_Node_Str"" + s));
  music.play();
}","private void processCreditMusic(String s){
  if (music != null)   music.dispose();
  music=Gdx.audio.newMusic(EngineAssetManager.getInstance().getAsset(""String_Node_Str"" + s));
  music.play();
  stringHead++;
}",0.9603960396039604
30217,"@Override public boolean run(VerbRunner cb){
  Scene s=actor.getScene();
  final String actorId=actor.getActorId();
  if (actorId == null) {
    EngineLogger.error(getClass() + ""String_Node_Str"");
    return false;
  }
  InteractiveActor a=(InteractiveActor)s.getActor(actorId,false);
  s.removeActor(a);
  if (s == World.getInstance().getCurrentScene())   a.dispose();
  Scene ts=null;
  if (scene == null)   ts=World.getInstance().getCurrentScene();
 else   ts=World.getInstance().getScene(scene);
  if (ts == World.getInstance().getCurrentScene()) {
    a.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    a.retrieveAssets();
  }
  ts.addActor(a);
  return false;
}","@Override public boolean run(VerbRunner cb){
  final Scene s=actor.getScene();
  final String actorId=actor.getActorId();
  final World w=World.getInstance();
  if (actorId == null) {
    EngineLogger.error(getClass() + ""String_Node_Str"");
    return false;
  }
  InteractiveActor a=(InteractiveActor)s.getActor(actorId,false);
  s.removeActor(a);
  if (s == w.getCurrentScene())   a.dispose();
  Scene ts=null;
  if (scene == null)   ts=w.getCurrentScene();
 else   ts=w.getScene(scene);
  if (ts == w.getCurrentScene() || (w.getCachedScene(ts.getId()) != null)) {
    a.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    a.retrieveAssets();
  }
  ts.addActor(a);
  return false;
}",0.7451543431442929
30218,"public void lookat(String direction){
  inAnim();
  posTween=null;
  renderer.startAnimation(standAnim,Tween.Type.SPRITE_DEFINED,-1,null,direction);
  outAnim();
}","public void lookat(String direction){
  inAnim();
  posTween=null;
  renderer.startAnimation(standAnim,Tween.Type.SPRITE_DEFINED,-1,null,direction);
  outAnim(Tween.Type.SPRITE_DEFINED);
}",0.9287749287749288
30219,"public void startWalkAnim(Vector2 p0,Vector2 pf){
  inAnim();
  renderer.startAnimation(walkAnim,Tween.Type.SPRITE_DEFINED,-1,null,p0,pf);
  outAnim();
}","public void startWalkAnim(Vector2 p0,Vector2 pf){
  inAnim();
  renderer.startAnimation(walkAnim,Tween.Type.SPRITE_DEFINED,-1,null,p0,pf);
  outAnim(Tween.Type.SPRITE_DEFINED);
}",0.9244712990936556
30220,"public void talk(){
  inAnim();
  posTween=null;
  renderer.startAnimation(talkAnim,Tween.Type.SPRITE_DEFINED,-1,null,null);
  outAnim();
}","public void talk(){
  inAnim();
  posTween=null;
  renderer.startAnimation(talkAnim,Tween.Type.SPRITE_DEFINED,-1,null,null);
  outAnim(Tween.Type.SPRITE_DEFINED);
}",0.9174917491749176
30221,"public void stand(){
  inAnim();
  posTween=null;
  renderer.startAnimation(standAnim,Tween.Type.SPRITE_DEFINED,-1,null,null);
  outAnim();
}","public void stand(){
  inAnim();
  posTween=null;
  renderer.startAnimation(standAnim,Tween.Type.SPRITE_DEFINED,-1,null,null);
  outAnim(Tween.Type.SPRITE_DEFINED);
}",0.9185667752442996
30222,"/** 
 * Actions to do when setting an animation: - play animation sound - add 'in' distance
 */
protected void outAnim(){
  AnimationDesc fa=renderer.getCurrentAnimation();
  if (fa != null) {
    if (fa.sound != null && fa.animationType != Tween.Type.REVERSE) {
      playSound(fa.sound);
    }
    Vector2 inD=fa.inD;
    if (inD != null) {
      float s=EngineAssetManager.getInstance().getScale();
      setPosition(getX() + inD.x * s,getY() + inD.y * s);
    }
  }
}","/** 
 * Actions to do when setting an animation: - play animation sound - add 'in' distance
 * @param repeatType 
 */
protected void outAnim(Type repeatType){
  AnimationDesc fa=renderer.getCurrentAnimation();
  if (fa != null) {
    if (fa.sound != null && repeatType != Tween.Type.REVERSE) {
      playSound(fa.sound);
    }
    Vector2 inD=fa.inD;
    if (inD != null) {
      float s=EngineAssetManager.getInstance().getScale();
      setPosition(getX() + inD.x * s,getY() + inD.y * s);
    }
  }
}",0.9434737923946556
30223,"public void startAnimation(String id,Tween.Type repeatType,int count,ActionCallback cb){
  inAnim();
  if (posTween != null && posTween instanceof WalkTween)   posTween=null;
  EngineLogger.debug(""String_Node_Str"" + this.id + ""String_Node_Str""+ id);
  renderer.startAnimation(id,repeatType,count,cb);
  outAnim();
}","public void startAnimation(String id,Tween.Type repeatType,int count,ActionCallback cb){
  inAnim();
  if (posTween != null && posTween instanceof WalkTween)   posTween=null;
  EngineLogger.debug(""String_Node_Str"" + this.id + ""String_Node_Str""+ id);
  renderer.startAnimation(id,repeatType,count,cb);
  outAnim(repeatType);
}",0.984375
30224,"@Override public boolean run(VerbRunner cb){
  MusicEngine musicEngine=World.getInstance().getMusicEngine();
  if (filename == null) {
    musicEngine.setMusic(null);
  }
 else {
    MusicDesc md=new MusicDesc();
    md.setFilename(filename);
    md.setLoop(loop);
    md.setInitialDelay(initialDelay);
    md.setRepeatDelay(repeatDelay);
    md.setStopWhenLeaving(stopWhenLeaving);
    musicEngine.setMusic(md);
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  MusicEngine musicEngine=World.getInstance().getMusicEngine();
  if (filename == null) {
    musicEngine.setMusic(null);
  }
 else {
    MusicDesc md=new MusicDesc();
    md.setFilename(filename);
    md.setLoop(loop);
    md.setInitialDelay(initialDelay);
    md.setRepeatDelay(repeatDelay);
    md.setStopWhenLeaving(stopWhenLeaving);
    md.setVolume(volume);
    musicEngine.setMusic(md);
  }
  return false;
}",0.970917225950783
30225,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  super.read(json,jsonData);
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    desc=json.readValue(""String_Node_Str"",String.class,jsonData);
    sounds=json.readValue(""String_Node_Str"",HashMap.class,SoundFX.class,jsonData);
    layer=json.readValue(""String_Node_Str"",String.class,jsonData);
  }
 else {
    playingSound=json.readValue(""String_Node_Str"",String.class,jsonData);
    playerInside=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    String newLayer=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (newLayer != null && !newLayer.equals(layer)) {
      scene.getLayer(layer).remove(this);
      scene.getLayer(newLayer).add(this);
      layer=newLayer;
    }
  }
  verbs.read(json,jsonData);
  interaction=json.readValue(""String_Node_Str"",boolean.class,interaction,jsonData);
  state=json.readValue(""String_Node_Str"",String.class,jsonData);
  zIndex=json.readValue(""String_Node_Str"",float.class,zIndex,jsonData);
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  super.read(json,jsonData);
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    desc=json.readValue(""String_Node_Str"",String.class,jsonData);
    sounds=json.readValue(""String_Node_Str"",HashMap.class,SoundFX.class,jsonData);
    layer=json.readValue(""String_Node_Str"",String.class,jsonData);
  }
 else {
    playingSound=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (playingSound != null && (sounds == null || sounds.get(playingSound) == null)) {
      EngineLogger.debug(""String_Node_Str"" + playingSound);
      playingSound=null;
    }
    playerInside=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    String newLayer=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (newLayer != null && !newLayer.equals(layer)) {
      scene.getLayer(layer).remove(this);
      scene.getLayer(newLayer).add(this);
      layer=newLayer;
    }
  }
  verbs.read(json,jsonData);
  interaction=json.readValue(""String_Node_Str"",boolean.class,interaction,jsonData);
  state=json.readValue(""String_Node_Str"",String.class,jsonData);
  zIndex=json.readValue(""String_Node_Str"",float.class,zIndex,jsonData);
}",0.923010752688172
30226,"public MusicDesc(MusicDesc md){
  filename=md.getFilename();
  loop=md.isLoop();
  initialDelay=md.getInitialDelay();
  repeatDelay=md.getRepeatDelay();
  stopWhenLeaving=md.isStopWhenLeaving();
}","public MusicDesc(MusicDesc md){
  filename=md.getFilename();
  loop=md.isLoop();
  initialDelay=md.getInitialDelay();
  repeatDelay=md.getRepeatDelay();
  stopWhenLeaving=md.isStopWhenLeaving();
  volume=md.getVolume();
}",0.9400479616306956
30227,"public void setMusic(MusicDesc d){
  stopMusic();
  currentMusicDelay=0;
  if (d != null) {
    if (!d.getFilename().equals(desc.getFilename())) {
      dispose();
      desc=new MusicDesc(d);
      loadAssets();
      EngineAssetManager.getInstance().finishLoading();
      music=EngineAssetManager.getInstance().getMusic(desc.getFilename());
    }
 else {
      desc=new MusicDesc(d);
    }
  }
 else {
    dispose();
    desc=null;
  }
}","public void setMusic(MusicDesc d){
  stopMusic();
  currentMusicDelay=0;
  if (d != null) {
    if (desc != null)     dispose();
    desc=new MusicDesc(d);
    retrieveAssets();
  }
 else {
    dispose();
    desc=null;
  }
}",0.3398496240601504
30228,"public void leaveScene(MusicDesc newMusicDesc){
  if (newMusicDesc != null) {
    currentMusicDelay=0;
    stopMusic();
    dispose();
    desc=new MusicDesc(newMusicDesc);
  }
 else   if (music != null && desc.isStopWhenLeaving()) {
    currentMusicDelay=0;
    stopMusic();
    dispose();
    desc=null;
  }
}","public void leaveScene(MusicDesc newMusicDesc){
  if (desc != null && !desc.isStopWhenLeaving() && (newMusicDesc == null || newMusicDesc.getFilename().equals(desc.getFilename())))   return;
  if (desc != null) {
    currentMusicDelay=0;
    stopMusic();
    dispose();
  }
  if (newMusicDesc != null) {
    desc=new MusicDesc(newMusicDesc);
  }
 else {
    desc=null;
  }
}",0.4590643274853801
30229,"@Override public void retrieveAssets(){
  if (music == null && desc != null) {
    EngineLogger.debug(""String_Node_Str"" + desc.getFilename());
    music=EngineAssetManager.getInstance().getMusic(desc.getFilename());
    if (isPlayingSer) {
      if (music != null) {
        music.setPosition(musicPosSer);
        musicPosSer=0f;
      }
      playMusic();
      isPlayingSer=false;
    }
  }
}","@Override public void retrieveAssets(){
  if (music == null && desc != null) {
    if (!EngineAssetManager.getInstance().isLoaded(desc.getFilename())) {
      loadAssets();
      EngineAssetManager.getInstance().finishLoading();
    }
    EngineLogger.debug(""String_Node_Str"" + desc.getFilename());
    music=EngineAssetManager.getInstance().getMusic(desc.getFilename());
    music.setVolume(desc.getVolume());
    if (isPlayingSer) {
      if (music != null) {
        music.setPosition(musicPosSer);
        musicPosSer=0f;
      }
      playMusic();
      isPlayingSer=false;
    }
  }
}",0.8020304568527918
30230,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
  }
 else {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    for (    Scene s : scenes.values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    inventory=json.readValue(""String_Node_Str"",Inventory.class,jsonData);
    timeOfGame=json.readValue(""String_Node_Str"",long.class,0L,jsonData);
    cutMode=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    previousScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    musicEngine=json.readValue(""String_Node_Str"",MusicEngine.class,jsonData);
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
  }
 else {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    for (    Scene s : scenes.values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    inventory=json.readValue(""String_Node_Str"",Inventory.class,jsonData);
    timeOfGame=json.readValue(""String_Node_Str"",long.class,0L,jsonData);
    cutMode=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    previousScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    musicEngine=json.readValue(""String_Node_Str"",MusicEngine.class,jsonData);
    if (musicEngine == null)     musicEngine=new MusicEngine();
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}",0.9896507115135834
30231,"@Override public void write(Json json){
  super.write(json);
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    json.writeValue(""String_Node_Str"",desc);
    json.writeValue(""String_Node_Str"",sounds,sounds == null ? null : sounds.getClass(),SoundFX.class);
  }
 else {
    json.writeValue(""String_Node_Str"",playingSound,playingSound == null ? null : playingSound.getClass());
    json.writeValue(""String_Node_Str"",playerInside);
  }
  verbs.write(json);
  json.writeValue(""String_Node_Str"",interaction);
  json.writeValue(""String_Node_Str"",state);
  json.writeValue(""String_Node_Str"",zIndex);
  json.writeValue(""String_Node_Str"",layer);
}","@Override public void write(Json json){
  super.write(json);
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    json.writeValue(""String_Node_Str"",desc);
    json.writeValue(""String_Node_Str"",sounds,sounds == null ? null : sounds.getClass(),SoundFX.class);
  }
 else {
    json.writeValue(""String_Node_Str"",playingSound);
    json.writeValue(""String_Node_Str"",playerInside);
  }
  verbs.write(json);
  json.writeValue(""String_Node_Str"",interaction);
  json.writeValue(""String_Node_Str"",state);
  json.writeValue(""String_Node_Str"",zIndex);
  json.writeValue(""String_Node_Str"",layer);
}",0.9571428571428572
30232,"@Override public void dispose(){
  if (sounds != null) {
    for (    SoundFX s : sounds.values()) {
      s.dispose();
    }
    sounds.clear();
    sounds=null;
    playingSound=null;
  }
}","@Override public void dispose(){
  if (sounds != null) {
    for (    SoundFX s : sounds.values()) {
      s.dispose();
    }
  }
}",0.8136645962732919
30233,"public ToolsWindow(Skin skin,ScnWidget sw){
  scnWidget=sw;
  Table table=new Table(skin);
  TextButton button1=new TextButton(""String_Node_Str"",skin);
  TextButton button2=new TextButton(""String_Node_Str"",skin);
  table.top();
  table.add(new Label(""String_Node_Str"",skin,""String_Node_Str"")).center();
  setActor(table);
  Drawable drawable=skin.getDrawable(""String_Node_Str"");
  setBackground(drawable);
  table.row();
  table.add(button2).expandX().fill();
  button1.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      HashMap<String,Scene> scenes=World.getInstance().getScenes();
      for (      Scene scn : scenes.values()) {
        HashMap<String,BaseActor> actors=scn.getActors();
        for (        BaseActor a : actors.values()) {
          if (a instanceof InteractiveActor) {
            InteractiveActor ia=(InteractiveActor)a;
            HashMap<String,Verb> verbs=ia.getVerbManager().getVerbs();
            for (            Verb v : verbs.values()) {
              ArrayList<Action> actions=v.getActions();
              if (v.getState() != null && v.getState().equalsIgnoreCase(""String_Node_Str""))               continue;
              if (actions.size() == 1) {
                Action act=actions.get(0);
                if (act instanceof LookAtAction || act instanceof SayAction) {
                  actions.clear();
                  SetCutmodeAction cma1=new SetCutmodeAction();
                  SetCutmodeAction cma2=new SetCutmodeAction();
                  try {
                    ActionUtils.setParam(cma1,""String_Node_Str"",""String_Node_Str"");
                    ActionUtils.setParam(cma2,""String_Node_Str"",""String_Node_Str"");
                  }
 catch (                  NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
                    e.printStackTrace();
                  }
                  actions.add(cma1);
                  actions.add(act);
                  actions.add(cma2);
                }
              }
            }
          }
        }
      }
      Ctx.project.setModified();
      Message.showMsg(getStage(),""String_Node_Str"",4);
      event.cancel();
    }
  }
);
  button2.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      if (Ctx.project.getSelectedScene() == null) {
        String msg=""String_Node_Str"";
        Message.showMsg(getStage(),msg,3);
        return;
      }
      Ctx.project.getProjectConfig().setProperty(Config.CHAPTER_PROP,Ctx.project.getChapter().getId());
      Ctx.project.getProjectConfig().setProperty(Config.TEST_SCENE_PROP,Ctx.project.getSelectedScene().getId());
      Ctx.project.setModified();
      try {
        Ctx.project.saveProject();
      }
 catch (      Exception ex) {
        String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
        Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
        return;
      }
      new Thread(new Runnable(){
        Stage stage=getStage();
        @Override public void run(){
          Message.showMsg(stage,""String_Node_Str"",5);
          if (!RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str""))           Message.showMsg(stage,""String_Node_Str"",4);
        }
      }
).start();
      Ctx.project.getProjectConfig().remove(Config.CHAPTER_PROP);
      Ctx.project.getProjectConfig().remove(Config.TEST_SCENE_PROP);
      Ctx.project.setModified();
      event.cancel();
    }
  }
);
  prefSize(200,200);
  setSize(200,200);
}","public ToolsWindow(Skin skin,ScnWidget sw){
  scnWidget=sw;
  Table table=new Table(skin);
  TextButton button1=new TextButton(""String_Node_Str"",skin);
  TextButton button2=new TextButton(""String_Node_Str"",skin);
  table.top();
  table.add(new Label(""String_Node_Str"",skin,""String_Node_Str"")).center();
  setActor(table);
  Drawable drawable=skin.getDrawable(""String_Node_Str"");
  setBackground(drawable);
  table.row();
  table.add(button2).expandX().fill();
  button1.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      HashMap<String,Scene> scenes=World.getInstance().getScenes();
      for (      Scene scn : scenes.values()) {
        HashMap<String,BaseActor> actors=scn.getActors();
        for (        BaseActor a : actors.values()) {
          if (a instanceof InteractiveActor) {
            InteractiveActor ia=(InteractiveActor)a;
            HashMap<String,Verb> verbs=ia.getVerbManager().getVerbs();
            for (            Verb v : verbs.values()) {
              ArrayList<Action> actions=v.getActions();
              if (v.getState() != null && v.getState().equalsIgnoreCase(""String_Node_Str""))               continue;
              if (actions.size() == 1) {
                Action act=actions.get(0);
                if (act instanceof LookAtAction || act instanceof SayAction) {
                  actions.clear();
                  SetCutmodeAction cma1=new SetCutmodeAction();
                  SetCutmodeAction cma2=new SetCutmodeAction();
                  try {
                    ActionUtils.setParam(cma1,""String_Node_Str"",""String_Node_Str"");
                    ActionUtils.setParam(cma2,""String_Node_Str"",""String_Node_Str"");
                  }
 catch (                  NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
                    e.printStackTrace();
                  }
                  actions.add(cma1);
                  actions.add(act);
                  actions.add(cma2);
                }
              }
            }
          }
        }
      }
      Ctx.project.setModified();
      Message.showMsg(getStage(),""String_Node_Str"",4);
      event.cancel();
    }
  }
);
  button2.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      if (Ctx.project.getSelectedScene() == null) {
        String msg=""String_Node_Str"";
        Message.showMsg(getStage(),msg,3);
        return;
      }
      Ctx.project.getProjectConfig().setProperty(Config.CHAPTER_PROP,Ctx.project.getChapter().getId());
      Ctx.project.getProjectConfig().setProperty(Config.TEST_SCENE_PROP,Ctx.project.getSelectedScene().getId());
      Ctx.project.setModified();
      try {
        Ctx.project.saveProject();
      }
 catch (      Exception ex) {
        String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
        Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
        return;
      }
      new Thread(new Runnable(){
        Stage stage=getStage();
        @Override public void run(){
          Message.showMsg(stage,""String_Node_Str"",5);
          if (!RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
            Message.showMsg(stage,""String_Node_Str"",4);
          }
          Ctx.project.getProjectConfig().remove(Config.CHAPTER_PROP);
          Ctx.project.getProjectConfig().remove(Config.TEST_SCENE_PROP);
          Ctx.project.setModified();
          try {
            Ctx.project.saveProject();
          }
 catch (          Exception ex) {
            String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
            EngineLogger.error(msg);
            return;
          }
        }
      }
).start();
      event.cancel();
    }
  }
);
  prefSize(200,200);
  setSize(200,200);
}",0.9547336092936306
30234,"@Override public void run(){
  Message.showMsg(stage,""String_Node_Str"",5);
  if (!RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str""))   Message.showMsg(stage,""String_Node_Str"",4);
}","@Override public void run(){
  Message.showMsg(stage,""String_Node_Str"",5);
  if (!RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
    Message.showMsg(stage,""String_Node_Str"",4);
  }
  Ctx.project.getProjectConfig().remove(Config.CHAPTER_PROP);
  Ctx.project.getProjectConfig().remove(Config.TEST_SCENE_PROP);
  Ctx.project.setModified();
  try {
    Ctx.project.saveProject();
  }
 catch (  Exception ex) {
    String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
    EngineLogger.error(msg);
    return;
  }
}",0.5109114249037228
30235,"@Override public void changed(ChangeEvent event,Actor actor){
  if (Ctx.project.getSelectedScene() == null) {
    String msg=""String_Node_Str"";
    Message.showMsg(getStage(),msg,3);
    return;
  }
  Ctx.project.getProjectConfig().setProperty(Config.CHAPTER_PROP,Ctx.project.getChapter().getId());
  Ctx.project.getProjectConfig().setProperty(Config.TEST_SCENE_PROP,Ctx.project.getSelectedScene().getId());
  Ctx.project.setModified();
  try {
    Ctx.project.saveProject();
  }
 catch (  Exception ex) {
    String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
    Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
    return;
  }
  new Thread(new Runnable(){
    Stage stage=getStage();
    @Override public void run(){
      Message.showMsg(stage,""String_Node_Str"",5);
      if (!RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str""))       Message.showMsg(stage,""String_Node_Str"",4);
    }
  }
).start();
  Ctx.project.getProjectConfig().remove(Config.CHAPTER_PROP);
  Ctx.project.getProjectConfig().remove(Config.TEST_SCENE_PROP);
  Ctx.project.setModified();
  event.cancel();
}","@Override public void changed(ChangeEvent event,Actor actor){
  if (Ctx.project.getSelectedScene() == null) {
    String msg=""String_Node_Str"";
    Message.showMsg(getStage(),msg,3);
    return;
  }
  Ctx.project.getProjectConfig().setProperty(Config.CHAPTER_PROP,Ctx.project.getChapter().getId());
  Ctx.project.getProjectConfig().setProperty(Config.TEST_SCENE_PROP,Ctx.project.getSelectedScene().getId());
  Ctx.project.setModified();
  try {
    Ctx.project.saveProject();
  }
 catch (  Exception ex) {
    String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
    Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
    return;
  }
  new Thread(new Runnable(){
    Stage stage=getStage();
    @Override public void run(){
      Message.showMsg(stage,""String_Node_Str"",5);
      if (!RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
        Message.showMsg(stage,""String_Node_Str"",4);
      }
      Ctx.project.getProjectConfig().remove(Config.CHAPTER_PROP);
      Ctx.project.getProjectConfig().remove(Config.TEST_SCENE_PROP);
      Ctx.project.setModified();
      try {
        Ctx.project.saveProject();
      }
 catch (      Exception ex) {
        String msg=""String_Node_Str"" + ex.getClass().getSimpleName() + ""String_Node_Str""+ ex.getMessage();
        EngineLogger.error(msg);
        return;
      }
    }
  }
).start();
  event.cancel();
}",0.8739821636293137
30236,"@Override public void dispose(){
  for (  String key : sourceCache.keySet()) {
    EngineAssetManager.getInstance().disposeAtlas(key);
  }
  sourceCache.clear();
  currentSource=null;
  renderer=null;
  bounds=null;
}","@Override public void dispose(){
  for (  SkeletonCacheEntry entry : sourceCache.values()) {
    EngineAssetManager.getInstance().disposeAtlas(entry.atlas);
  }
  sourceCache.clear();
  currentSource=null;
  renderer=null;
  bounds=null;
}",0.2675438596491228
30237,"private void loadSource(String source,String atlas){
  SkeletonCacheEntry entry=sourceCache.get(source);
  if (entry == null) {
    entry=new SkeletonCacheEntry();
    entry.atlas=atlas;
    sourceCache.put(source,entry);
  }
  if (entry.refCounter == 0)   EngineAssetManager.getInstance().loadAtlas(atlas == null ? source : atlas);
  entry.refCounter++;
}","private void loadSource(String source,String atlas){
  SkeletonCacheEntry entry=sourceCache.get(source);
  if (entry == null) {
    entry=new SkeletonCacheEntry();
    entry.atlas=atlas == null ? source : atlas;
    sourceCache.put(source,entry);
  }
  if (entry.refCounter == 0)   EngineAssetManager.getInstance().loadAtlas(entry.atlas);
  entry.refCounter++;
}",0.9220055710306406
30238,"@Override public void dispose(){
  renderer.dispose();
}","@Override public void dispose(){
  super.dispose();
  renderer.dispose();
}",0.8549618320610687
30239,"@Override public void retrieveAssets(){
  renderer.retrieveAssets();
  setPosition(bbox.getX(),bbox.getY());
  super.retrieveAssets();
}","@Override public void retrieveAssets(){
  super.retrieveAssets();
  renderer.retrieveAssets();
  setPosition(bbox.getX(),bbox.getY());
}",0.8088235294117647
30240,"@Override public void read(Json json,JsonValue jsonData){
  super.read(json,jsonData);
  startX=json.readValue(""String_Node_Str"",Float.class,jsonData);
  startY=json.readValue(""String_Node_Str"",Float.class,jsonData);
  targetX=json.readValue(""String_Node_Str"",Float.class,jsonData);
  targetY=json.readValue(""String_Node_Str"",Float.class,jsonData);
  interpolationX=json.readValue(""String_Node_Str"",Interpolation.class,jsonData);
  interpolationY=json.readValue(""String_Node_Str"",Interpolation.class,jsonData);
}","@Override public void read(Json json,JsonValue jsonData){
  super.read(json,jsonData);
  startX=json.readValue(""String_Node_Str"",Float.class,jsonData);
  startY=json.readValue(""String_Node_Str"",Float.class,jsonData);
  targetX=json.readValue(""String_Node_Str"",Float.class,jsonData);
  targetY=json.readValue(""String_Node_Str"",Float.class,jsonData);
  interpolationX=json.readValue(""String_Node_Str"",InterpolationMode.class,jsonData);
  interpolationY=json.readValue(""String_Node_Str"",InterpolationMode.class,jsonData);
}",0.992248062015504
30241,"public void start(SpriteActor target,Tween.Type repeatType,int count,float tx,float ty,float duration,Interpolation interpolationX,Interpolation interpolationY,ActionCallback cb){
  startX=target.getX();
  startY=target.getY();
  targetX=tx;
  targetY=ty;
  setDuration(duration);
  setType(repeatType);
  setCount(count);
  this.interpolationX=interpolationX;
  this.interpolationY=interpolationY;
  if (cb != null) {
    setCb(cb);
  }
  restart();
}","public void start(SpriteActor target,Tween.Type repeatType,int count,float tx,float ty,float duration,InterpolationMode interpolationX,InterpolationMode interpolationY,ActionCallback cb){
  startX=target.getX();
  startY=target.getY();
  targetX=tx;
  targetY=ty;
  setDuration(duration);
  setType(repeatType);
  setCount(count);
  this.interpolationX=interpolationX;
  this.interpolationY=interpolationY;
  if (cb != null) {
    setCb(cb);
  }
  restart();
}",0.9912280701754386
30242,"@Override public void read(Json json,JsonValue jsonData){
  duration=json.readValue(""String_Node_Str"",Float.class,jsonData);
  time=json.readValue(""String_Node_Str"",Float.class,jsonData);
  ;
  reverse=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  began=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  complete=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  type=json.readValue(""String_Node_Str"",Type.class,jsonData);
  count=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  interpolation=json.readValue(""String_Node_Str"",Interpolation.class,jsonData);
  String cbSer=json.readValue(""String_Node_Str"",String.class,jsonData);
  cb=ActionCallbackSerialization.find(cbSer);
}","@Override public void read(Json json,JsonValue jsonData){
  duration=json.readValue(""String_Node_Str"",Float.class,jsonData);
  time=json.readValue(""String_Node_Str"",Float.class,jsonData);
  reverse=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  began=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  complete=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  type=json.readValue(""String_Node_Str"",Type.class,jsonData);
  count=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  interpolation=json.readValue(""String_Node_Str"",InterpolationMode.class,jsonData);
  String cbSer=json.readValue(""String_Node_Str"",String.class,jsonData);
  cb=ActionCallbackSerialization.find(cbSer);
}",0.994459833795014
30243,"public void setInterpolation(InterpolationMode interpolation){
  this.interpolation=interpolation.getInterpolation();
}","public void setInterpolation(InterpolationMode i){
  interpolation=i;
}",0.7473684210526316
30244,"public float getPercent(Interpolation i){
  float percent;
  if (complete) {
    percent=1;
  }
 else {
    percent=time / duration;
    if (i != null)     percent=i.apply(percent);
  }
  return (reverse ? 1 - percent : percent);
}","public float getPercent(InterpolationMode i){
  float percent;
  if (complete) {
    percent=1;
  }
 else {
    percent=time / duration;
    if (i != null)     percent=i.getInterpolation().apply(percent);
  }
  return (reverse ? 1 - percent : percent);
}",0.9525773195876288
30245,"private void walkToNextStep(CharacterActor target){
  Vector2 p0=walkingPath.get(currentStep);
  Vector2 pf=walkingPath.get(currentStep + 1);
  target.startWalkAnim(p0,pf);
  float s0=target.getScene().getFakeDepthScale(p0.y);
  float sf=target.getScene().getFakeDepthScale(pf.y);
  float segmentDuration=p0.dst(pf) / (EngineAssetManager.getInstance().getScale() * speed * (s0 + sf) / 2);
  segmentDuration*=(s0 > sf ? s0 / sf : sf / s0);
  Interpolation i=Interpolation.linear;
  if (Math.abs(s0 - sf) > .25)   i=s0 > sf ? Interpolation.pow2Out : Interpolation.pow2In;
  if (currentStep == walkingPath.size() - 2 && walkCb != null) {
    start(target,Type.NO_REPEAT,1,pf.x,pf.y,segmentDuration,Interpolation.linear,i,walkCb);
  }
 else {
    start(target,Type.NO_REPEAT,1,pf.x,pf.y,segmentDuration,Interpolation.linear,i,null);
  }
}","private void walkToNextStep(CharacterActor target){
  Vector2 p0=walkingPath.get(currentStep);
  Vector2 pf=walkingPath.get(currentStep + 1);
  target.startWalkAnim(p0,pf);
  float s0=target.getScene().getFakeDepthScale(p0.y);
  float sf=target.getScene().getFakeDepthScale(pf.y);
  float segmentDuration=p0.dst(pf) / (EngineAssetManager.getInstance().getScale() * speed * (s0 + sf) / 2);
  segmentDuration*=(s0 > sf ? s0 / sf : sf / s0);
  InterpolationMode i=InterpolationMode.LINEAR;
  if (Math.abs(s0 - sf) > .25)   i=s0 > sf ? InterpolationMode.POW2OUT : InterpolationMode.POW2IN;
  if (currentStep == walkingPath.size() - 2 && walkCb != null) {
    start(target,Type.NO_REPEAT,1,pf.x,pf.y,segmentDuration,InterpolationMode.LINEAR,i,walkCb);
  }
 else {
    start(target,Type.NO_REPEAT,1,pf.x,pf.y,segmentDuration,InterpolationMode.LINEAR,i,null);
  }
}",0.9290780141843972
30246,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    id=json.readValue(""String_Node_Str"",String.class,jsonData);
    layers=json.readValue(""String_Node_Str"",ArrayList.class,SceneLayer.class,jsonData);
    actors=json.readValue(""String_Node_Str"",HashMap.class,BaseActor.class,jsonData);
    for (    BaseActor actor : actors.values()) {
      actor.setScene(this);
      actor.setInitScene(id);
      if (actor instanceof InteractiveActor) {
        InteractiveActor ia=(InteractiveActor)actor;
        SceneLayer layer=getLayer(ia.getLayer());
        layer.add(ia);
      }
    }
    orderLayersByZIndex();
    backgroundAtlas=json.readValue(""String_Node_Str"",String.class,jsonData);
    backgroundRegionId=json.readValue(""String_Node_Str"",String.class,jsonData);
    musicFilename=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (musicFilename != null) {
      loopMusic=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
      initialMusicDelay=json.readValue(""String_Node_Str"",Float.class,jsonData);
      repeatMusicDelay=json.readValue(""String_Node_Str"",Float.class,jsonData);
    }
    depthVector=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
    polygonalNavGraph=json.readValue(""String_Node_Str"",PolygonalNavGraph.class,jsonData);
    sceneSize=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
  }
 else {
    JsonValue jsonValueActors=jsonData.get(""String_Node_Str"");
    SceneActorRef actorRef;
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      Scene sourceScn=World.getInstance().getScene(actorRef.getSceneId());
      if (sourceScn != this) {
        BaseActor actor=sourceScn.getActor(actorRef.getActorId(),false);
        sourceScn.removeActor(actor);
        addActor(actor);
      }
    }
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      BaseActor actor=getActor(actorRef.getActorId(),false);
      actor.read(json,jsonValueAct);
    }
    orderLayersByZIndex();
    if (musicFilename != null) {
      isPlayingSer=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
      musicPosSer=json.readValue(""String_Node_Str"",Float.class,jsonData);
    }
    camera=json.readValue(""String_Node_Str"",SceneCamera.class,jsonData);
    String followActorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    setCameraFollowActor((SpriteActor)actors.get(followActorId));
  }
  verbs.read(json,jsonData);
  state=json.readValue(""String_Node_Str"",String.class,jsonData);
  player=json.readValue(""String_Node_Str"",String.class,jsonData);
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    id=json.readValue(""String_Node_Str"",String.class,jsonData);
    layers=json.readValue(""String_Node_Str"",ArrayList.class,SceneLayer.class,jsonData);
    actors=json.readValue(""String_Node_Str"",HashMap.class,BaseActor.class,jsonData);
    for (    BaseActor actor : actors.values()) {
      actor.setScene(this);
      actor.setInitScene(id);
      if (actor instanceof InteractiveActor) {
        InteractiveActor ia=(InteractiveActor)actor;
        SceneLayer layer=getLayer(ia.getLayer());
        layer.add(ia);
      }
    }
    orderLayersByZIndex();
    backgroundAtlas=json.readValue(""String_Node_Str"",String.class,jsonData);
    backgroundRegionId=json.readValue(""String_Node_Str"",String.class,jsonData);
    musicFilename=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (musicFilename != null) {
      loopMusic=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
      initialMusicDelay=json.readValue(""String_Node_Str"",Float.class,jsonData);
      repeatMusicDelay=json.readValue(""String_Node_Str"",Float.class,jsonData);
    }
    depthVector=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
    polygonalNavGraph=json.readValue(""String_Node_Str"",PolygonalNavGraph.class,jsonData);
    sceneSize=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
  }
 else {
    JsonValue jsonValueActors=jsonData.get(""String_Node_Str"");
    SceneActorRef actorRef;
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      Scene sourceScn=World.getInstance().getScene(actorRef.getSceneId());
      if (sourceScn != this) {
        BaseActor actor=sourceScn.getActor(actorRef.getActorId(),false);
        sourceScn.removeActor(actor);
        addActor(actor);
      }
    }
    for (int i=0; i < jsonValueActors.size; i++) {
      JsonValue jsonValueAct=jsonValueActors.get(i);
      actorRef=new SceneActorRef(jsonValueAct.name);
      BaseActor actor=getActor(actorRef.getActorId(),false);
      if (actor != null)       actor.read(json,jsonValueAct);
 else       EngineLogger.debug(""String_Node_Str"" + actorRef);
    }
    orderLayersByZIndex();
    if (musicFilename != null) {
      isPlayingSer=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
      musicPosSer=json.readValue(""String_Node_Str"",Float.class,jsonData);
    }
    camera=json.readValue(""String_Node_Str"",SceneCamera.class,jsonData);
    String followActorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    setCameraFollowActor((SpriteActor)actors.get(followActorId));
  }
  verbs.read(json,jsonData);
  state=json.readValue(""String_Node_Str"",String.class,jsonData);
  player=json.readValue(""String_Node_Str"",String.class,jsonData);
}",0.9752123418270064
30247,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
  }
 else {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    inventory=json.readValue(""String_Node_Str"",Inventory.class,jsonData);
    for (    Scene s : scenes.values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    timeOfGame=json.readValue(""String_Node_Str"",long.class,0L,jsonData);
    cutMode=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
  }
 else {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    for (    Scene s : scenes.values()) {
      JsonValue jsonValue=jsonData.get(""String_Node_Str"").get(s.getId());
      if (jsonValue != null)       s.read(json,jsonValue);
 else       EngineLogger.debug(""String_Node_Str"" + s.getId());
    }
    inventory=json.readValue(""String_Node_Str"",Inventory.class,jsonData);
    timeOfGame=json.readValue(""String_Node_Str"",long.class,0L,jsonData);
    cutMode=json.readValue(""String_Node_Str"",boolean.class,false,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}",0.9160646714826282
30248,"public void resize(int width,int height){
  Inventory inventory=World.getInstance().getInventory();
  tileSize=(int)DPIUtils.getTouchMinSize() * 2;
  margin=(int)DPIUtils.getMarginSize();
  rowSpace=DPIUtils.getSpacing();
  int w=(int)(width * .7f / tileSize) * tileSize;
  int h=(int)(height * .7f / tileSize) * tileSize;
  if (autosize) {
    if (inventoryPos == InventoryPos.LEFT || inventoryPos == InventoryPos.RIGHT) {
      int w2=tileSize * ((inventory.getNumItems() - 1) / (h / tileSize) + 1);
      if (w2 < w)       w=w2;
    }
 else {
      int h2=tileSize * ((inventory.getNumItems() - 1) / (w / tileSize) + 1);
      if (h2 < h)       h=h2;
    }
  }
  cols=w / tileSize;
  rows=h / tileSize;
  setVisible(false);
  setSize(w + (cols - 1) * rowSpace + margin * 2,h + (rows - 1) * rowSpace + margin * 2);
  int capacity=cols * rows;
  if (inventory.getNumItems() > capacity)   EngineLogger.error(""String_Node_Str"");
  if (inventoryPos == InventoryPos.TOP) {
    orgPos.set((width - getWidth()) / 2,height + getHeight());
    targetPos.set((width - getWidth()) / 2,height - getHeight() - DPIUtils.getSpacing());
  }
 else   if (inventoryPos == InventoryPos.DOWN) {
    orgPos.set((width - getWidth()) / 2,-getHeight());
    targetPos.set((width - getWidth()) / 2,DPIUtils.getSpacing());
  }
 else   if (inventoryPos == InventoryPos.LEFT) {
    orgPos.set(-getWidth(),(height - getHeight()) / 2);
    targetPos.set(DPIUtils.getSpacing(),(height - getHeight()) / 2);
  }
 else   if (inventoryPos == InventoryPos.RIGHT) {
    orgPos.set(width + getWidth(),(height - getHeight()) / 2);
    targetPos.set(width - getWidth() - DPIUtils.getSpacing(),(height - getHeight()) / 2);
  }
 else {
    orgPos.set((width - getWidth()) / 2,-getHeight());
    targetPos.set((width - getWidth()) / 2,(height - getHeight()) / 2);
  }
  setX(orgPos.x);
  setY(orgPos.y);
  if (menuButton != null) {
    menuButton.setPosition(getWidth() - menuButton.getWidth() / 2,(getHeight() - menuButton.getHeight()) / 2);
    float iconSize=DPIUtils.getPrefButtonSize();
    menuButton.setSize(iconSize,iconSize);
  }
}","public void resize(int width,int height){
  Inventory inventory=World.getInstance().getInventory();
  tileSize=(int)DPIUtils.getTouchMinSize() * 2;
  margin=(int)DPIUtils.getMarginSize();
  rowSpace=DPIUtils.getSpacing();
  int capacity=0;
  do {
    int w=(int)(width * .7f / tileSize) * tileSize;
    int h=(int)(height * .7f / tileSize) * tileSize;
    if (autosize) {
      if (inventoryPos == InventoryPos.LEFT || inventoryPos == InventoryPos.RIGHT) {
        int w2=tileSize * ((inventory.getNumItems() - 1) / (h / tileSize) + 1);
        if (w2 < w)         w=w2;
      }
 else {
        int h2=tileSize * ((inventory.getNumItems() - 1) / (w / tileSize) + 1);
        if (h2 < h)         h=h2;
      }
    }
    cols=w / tileSize;
    rows=h / tileSize;
    setSize(w + (cols - 1) * rowSpace + margin * 2,h + (rows - 1) * rowSpace + margin * 2);
    capacity=cols * rows;
    if (inventory.getNumItems() > capacity) {
      tileSize*=.8;
    }
  }
 while (inventory.getNumItems() > capacity);
  if (inventory.getNumItems() > capacity)   EngineLogger.error(""String_Node_Str"");
  setVisible(false);
  if (inventoryPos == InventoryPos.TOP) {
    orgPos.set((width - getWidth()) / 2,height + getHeight());
    targetPos.set((width - getWidth()) / 2,height - getHeight() - DPIUtils.getSpacing());
  }
 else   if (inventoryPos == InventoryPos.DOWN) {
    orgPos.set((width - getWidth()) / 2,-getHeight());
    targetPos.set((width - getWidth()) / 2,DPIUtils.getSpacing());
  }
 else   if (inventoryPos == InventoryPos.LEFT) {
    orgPos.set(-getWidth(),(height - getHeight()) / 2);
    targetPos.set(DPIUtils.getSpacing(),(height - getHeight()) / 2);
  }
 else   if (inventoryPos == InventoryPos.RIGHT) {
    orgPos.set(width + getWidth(),(height - getHeight()) / 2);
    targetPos.set(width - getWidth() - DPIUtils.getSpacing(),(height - getHeight()) / 2);
  }
 else {
    orgPos.set((width - getWidth()) / 2,-getHeight());
    targetPos.set((width - getWidth()) / 2,(height - getHeight()) / 2);
  }
  setX(orgPos.x);
  setY(orgPos.y);
  if (menuButton != null) {
    menuButton.setPosition(getWidth() - menuButton.getWidth() / 2,(getHeight() - menuButton.getHeight()) / 2);
    float iconSize=DPIUtils.getPrefButtonSize();
    menuButton.setSize(iconSize,iconSize);
  }
}",0.94967978042086
30249,"@Override protected void inputsToModel(boolean create){
  String type=typePanel.getText();
  boolean typeChanged=false;
  BaseActor oldElement=e;
  boolean isPlayer=false;
  if (!create) {
    typeChanged=(type.equals(CHARACTER_TYPE_STR) && !(e instanceof CharacterActor)) || (type.equals(SPRITE_TYPE_STR) && (!(e instanceof SpriteActor) || e instanceof CharacterActor)) || (type.equals(BACKGROUND_TYPE_STR) && (!(e instanceof InteractiveActor) || e instanceof SpriteActor))|| (type.equals(OBSTACLE_TYPE_STR) && !(e instanceof ObstacleActor))|| (type.equals(ANCHOR_TYPE_STR) && !(e instanceof AnchorActor));
    isPlayer=parent.getPlayer() == e;
    parent.removeActor(e);
  }
  if (create || typeChanged) {
    if (type.equals(BACKGROUND_TYPE_STR)) {
      e=new InteractiveActor();
    }
 else     if (type.equals(SPRITE_TYPE_STR)) {
      e=new SpriteActor();
    }
 else     if (type.equals(CHARACTER_TYPE_STR)) {
      e=new CharacterActor();
    }
 else     if (type.equals(OBSTACLE_TYPE_STR)) {
      e=new ObstacleActor();
    }
 else     if (type.equals(ANCHOR_TYPE_STR)) {
      e=new AnchorActor();
    }
    if (!(e instanceof SpriteActor) && !(e instanceof AnchorActor)) {
      Polygon bbox=e.getBBox();
      bbox.setVertices(new float[8]);
      float[] verts=bbox.getVertices();
      verts[0]=-DEFAULT_DIM / 2;
      verts[1]=0f;
      verts[2]=-DEFAULT_DIM / 2;
      verts[3]=DEFAULT_DIM;
      verts[4]=DEFAULT_DIM / 2;
      verts[5]=DEFAULT_DIM;
      verts[6]=DEFAULT_DIM / 2;
      verts[7]=0f;
      bbox.dirty();
    }
  }
  if (typeChanged) {
    if (oldElement instanceof InteractiveActor && e instanceof InteractiveActor) {
      HashMap<String,Verb> verbs=((InteractiveActor)e).getVerbManager().getVerbs();
      HashMap<String,Verb> oldVerbs=((InteractiveActor)oldElement).getVerbManager().getVerbs();
      for (      String k : oldVerbs.keySet()) {
        Verb v=oldVerbs.get(k);
        verbs.put(k,v);
      }
      HashMap<String,SoundFX> oldSounds=((InteractiveActor)oldElement).getSounds();
      if (oldSounds != null) {
        for (        String k : oldSounds.keySet()) {
          ((InteractiveActor)e).addSound(oldSounds.get(k));
        }
      }
    }
    if (oldElement instanceof SpriteActor && e instanceof SpriteActor) {
      ((SpriteActor)e).setRenderer(((SpriteActor)oldElement).getRenderer());
    }
  }
  e.setId(ElementUtils.getCheckedId(id.getText(),parent.getActors().keySet().toArray(new String[0])));
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    ia.setLayer(layer.getText());
    ia.setInteraction(Boolean.parseBoolean(interaction.getText()));
    String key=desc.getText();
    if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX)     key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
    Ctx.project.getI18N().setTranslation(key,desc.getText());
    if (desc.getText() != null)     ia.setDesc(key);
 else     ia.setDesc(null);
    ia.setState(state.getText());
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      String rendererType=renderer.getText();
      if (Project.ATLAS_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof AtlasRenderer))         sa.setRenderer(new AtlasRenderer());
      }
 else       if (Project.IMAGE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ImageRenderer))         sa.setRenderer(new ImageRenderer());
      }
 else       if (Project.S3D_RENDERER_STRING.equals(rendererType)) {
        Sprite3DRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof Sprite3DRenderer)) {
          r=new Sprite3DRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(Sprite3DRenderer)sa.getRenderer();
        }
        r.setCameraFOV(Float.parseFloat(fov.getText()));
        r.setCameraName(cameraName.getText());
        r.setSpriteSize(Param.parseVector2(spriteSize.getText()));
      }
 else       if (Project.SPINE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof SpineRenderer))         sa.setRenderer(new SpineRenderer());
      }
      sa.setBboxFromRenderer(true);
      sa.setDepthType(DepthType.valueOf(depthType.getText()));
      sa.setScale(Float.parseFloat(scale.getText()));
      sa.setZIndex(Float.parseFloat(zIndex.getText()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        ca.setWalkingSpeed(Float.parseFloat(walkingSpeed.getText()));
        ca.setTextColor(Param.parseColor(textColor.getText()));
      }
    }
  }
  parent.addActor(e);
  if (isPlayer && !typeChanged)   parent.setPlayer((CharacterActor)e);
  if (e instanceof InteractiveActor) {
    SceneLayer l=parent.getLayer(((InteractiveActor)e).getLayer());
    l.orderByZIndex();
  }
  if (e instanceof SpriteActor)   ((SpriteActor)e).retrieveAssets();
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  String type=typePanel.getText();
  boolean typeChanged=false;
  BaseActor oldElement=e;
  boolean isPlayer=false;
  if (!create) {
    typeChanged=(type.equals(CHARACTER_TYPE_STR) && !(e instanceof CharacterActor)) || (type.equals(SPRITE_TYPE_STR) && (!(e instanceof SpriteActor) || e instanceof CharacterActor)) || (type.equals(BACKGROUND_TYPE_STR) && (!(e instanceof InteractiveActor) || e instanceof SpriteActor))|| (type.equals(OBSTACLE_TYPE_STR) && !(e instanceof ObstacleActor))|| (type.equals(ANCHOR_TYPE_STR) && !(e instanceof AnchorActor));
    isPlayer=parent.getPlayer() == e;
    parent.removeActor(e);
  }
  if (create || typeChanged) {
    if (type.equals(BACKGROUND_TYPE_STR)) {
      e=new InteractiveActor();
    }
 else     if (type.equals(SPRITE_TYPE_STR)) {
      e=new SpriteActor();
    }
 else     if (type.equals(CHARACTER_TYPE_STR)) {
      e=new CharacterActor();
    }
 else     if (type.equals(OBSTACLE_TYPE_STR)) {
      e=new ObstacleActor();
    }
 else     if (type.equals(ANCHOR_TYPE_STR)) {
      e=new AnchorActor();
    }
    if (!(e instanceof SpriteActor) && !(e instanceof AnchorActor)) {
      Polygon bbox=e.getBBox();
      bbox.setVertices(new float[8]);
      float[] verts=bbox.getVertices();
      verts[0]=-DEFAULT_DIM / 2;
      verts[1]=0f;
      verts[2]=-DEFAULT_DIM / 2;
      verts[3]=DEFAULT_DIM;
      verts[4]=DEFAULT_DIM / 2;
      verts[5]=DEFAULT_DIM;
      verts[6]=DEFAULT_DIM / 2;
      verts[7]=0f;
      bbox.dirty();
    }
  }
  if (typeChanged) {
    if (oldElement instanceof InteractiveActor && e instanceof InteractiveActor) {
      HashMap<String,Verb> verbs=((InteractiveActor)e).getVerbManager().getVerbs();
      HashMap<String,Verb> oldVerbs=((InteractiveActor)oldElement).getVerbManager().getVerbs();
      for (      String k : oldVerbs.keySet()) {
        Verb v=oldVerbs.get(k);
        verbs.put(k,v);
      }
      HashMap<String,SoundFX> oldSounds=((InteractiveActor)oldElement).getSounds();
      if (oldSounds != null) {
        for (        String k : oldSounds.keySet()) {
          ((InteractiveActor)e).addSound(oldSounds.get(k));
        }
      }
    }
    if (oldElement instanceof SpriteActor && e instanceof SpriteActor) {
      ((SpriteActor)e).setRenderer(((SpriteActor)oldElement).getRenderer());
    }
  }
  e.setId(ElementUtils.getCheckedId(id.getText(),parent.getActors().keySet().toArray(new String[0])));
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    ia.setLayer(layer.getText());
    ia.setInteraction(Boolean.parseBoolean(interaction.getText()));
    String key=desc.getText();
    if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX)     key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
    Ctx.project.getI18N().setTranslation(key,desc.getText());
    if (desc.getText() != null)     ia.setDesc(key);
 else     ia.setDesc(null);
    ia.setState(state.getText());
    ia.setZIndex(Float.parseFloat(zIndex.getText()));
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      String rendererType=renderer.getText();
      if (Project.ATLAS_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof AtlasRenderer))         sa.setRenderer(new AtlasRenderer());
      }
 else       if (Project.IMAGE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ImageRenderer))         sa.setRenderer(new ImageRenderer());
      }
 else       if (Project.S3D_RENDERER_STRING.equals(rendererType)) {
        Sprite3DRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof Sprite3DRenderer)) {
          r=new Sprite3DRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(Sprite3DRenderer)sa.getRenderer();
        }
        r.setCameraFOV(Float.parseFloat(fov.getText()));
        r.setCameraName(cameraName.getText());
        r.setSpriteSize(Param.parseVector2(spriteSize.getText()));
      }
 else       if (Project.SPINE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof SpineRenderer))         sa.setRenderer(new SpineRenderer());
      }
      sa.setBboxFromRenderer(true);
      sa.setDepthType(DepthType.valueOf(depthType.getText()));
      sa.setScale(Float.parseFloat(scale.getText()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        ca.setWalkingSpeed(Float.parseFloat(walkingSpeed.getText()));
        ca.setTextColor(Param.parseColor(textColor.getText()));
      }
    }
  }
  parent.addActor(e);
  if (isPlayer && !typeChanged)   parent.setPlayer((CharacterActor)e);
  if (e instanceof InteractiveActor) {
    SceneLayer l=parent.getLayer(((InteractiveActor)e).getLayer());
    l.orderByZIndex();
  }
  if (e instanceof SpriteActor)   ((SpriteActor)e).retrieveAssets();
  Ctx.project.setModified();
}",0.9891838741396264
30250,"@Override protected void modelToInputs(){
  id.setText(e.getId());
  visible.setText(Boolean.toString(e.isVisible()));
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    layer.setText(ia.getLayer());
    interaction.setText(Boolean.toString(ia.getInteraction()));
    desc.setText(Ctx.project.translate(ia.getDesc()));
    state.setText(ia.getState());
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      ActorRenderer r=sa.getRenderer();
      if (r instanceof AtlasRenderer) {
        renderer.setText(Project.ATLAS_RENDERER_STRING);
      }
 else       if (r instanceof ImageRenderer) {
        renderer.setText(Project.IMAGE_RENDERER_STRING);
      }
 else       if (r instanceof Sprite3DRenderer) {
        renderer.setText(Project.S3D_RENDERER_STRING);
        Sprite3DRenderer s3d=(Sprite3DRenderer)r;
        fov.setText(Float.toString(s3d.getCameraFOV()));
        cameraName.setText(s3d.getCameraName());
        spriteSize.setText(Param.toStringParam(s3d.getSpriteSize()));
      }
 else       if (r instanceof SpineRenderer) {
        renderer.setText(Project.SPINE_RENDERER_STRING);
      }
      depthType.setText(sa.getDepthType().toString());
      scale.setText(Float.toString(sa.getScale()));
      zIndex.setText(Float.toString(sa.getZIndex()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        walkingSpeed.setText(Float.toString(ca.getWalkingSpeed()));
        textColor.setText(ca.getTextColor() == null ? null : ca.getTextColor().toString());
        typePanel.setText(CHARACTER_TYPE_STR);
      }
 else {
        typePanel.setText(SPRITE_TYPE_STR);
      }
    }
 else {
      typePanel.setText(BACKGROUND_TYPE_STR);
    }
  }
 else   if (e instanceof AnchorActor) {
    typePanel.setText(ANCHOR_TYPE_STR);
  }
 else   if (e instanceof ObstacleActor) {
    typePanel.setText(OBSTACLE_TYPE_STR);
  }
}","@Override protected void modelToInputs(){
  id.setText(e.getId());
  visible.setText(Boolean.toString(e.isVisible()));
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    layer.setText(ia.getLayer());
    interaction.setText(Boolean.toString(ia.getInteraction()));
    desc.setText(Ctx.project.translate(ia.getDesc()));
    state.setText(ia.getState());
    zIndex.setText(Float.toString(ia.getZIndex()));
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      ActorRenderer r=sa.getRenderer();
      if (r instanceof AtlasRenderer) {
        renderer.setText(Project.ATLAS_RENDERER_STRING);
      }
 else       if (r instanceof ImageRenderer) {
        renderer.setText(Project.IMAGE_RENDERER_STRING);
      }
 else       if (r instanceof Sprite3DRenderer) {
        renderer.setText(Project.S3D_RENDERER_STRING);
        Sprite3DRenderer s3d=(Sprite3DRenderer)r;
        fov.setText(Float.toString(s3d.getCameraFOV()));
        cameraName.setText(s3d.getCameraName());
        spriteSize.setText(Param.toStringParam(s3d.getSpriteSize()));
      }
 else       if (r instanceof SpineRenderer) {
        renderer.setText(Project.SPINE_RENDERER_STRING);
      }
      depthType.setText(sa.getDepthType().toString());
      scale.setText(Float.toString(sa.getScale()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        walkingSpeed.setText(Float.toString(ca.getWalkingSpeed()));
        textColor.setText(ca.getTextColor() == null ? null : ca.getTextColor().toString());
        typePanel.setText(CHARACTER_TYPE_STR);
      }
 else {
        typePanel.setText(SPRITE_TYPE_STR);
      }
    }
 else {
      typePanel.setText(BACKGROUND_TYPE_STR);
    }
  }
 else   if (e instanceof AnchorActor) {
    typePanel.setText(ANCHOR_TYPE_STR);
  }
 else   if (e instanceof ObstacleActor) {
    typePanel.setText(OBSTACLE_TYPE_STR);
  }
}",0.972567287784679
30251,"public void loadGameState(FileHandle savedFile) throws IOException {
  EngineLogger.debug(""String_Node_Str"");
  if (!disposed)   dispose();
  init();
  if (savedFile.exists()) {
    assetState=AssetState.LOAD_ASSETS;
    SerializationHelper.getInstance().setMode(Mode.STATE);
    JsonValue root=new JsonReader().parse(savedFile.reader(""String_Node_Str""));
    Json json=new Json();
    json.setIgnoreUnknownFields(true);
    read(json,root);
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}","public void loadGameState(FileHandle savedFile) throws IOException {
  EngineLogger.debug(""String_Node_Str"");
  if (!disposed)   dispose();
  init();
  if (savedFile.exists()) {
    SerializationHelper.getInstance().setMode(Mode.STATE);
    JsonValue root=new JsonReader().parse(savedFile.reader(""String_Node_Str""));
    Json json=new Json();
    json.setIgnoreUnknownFields(true);
    read(json,root);
    assetState=AssetState.LOAD_ASSETS;
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
}",0.5544554455445545
30252,"@Override protected void inputsToModel(boolean create){
  if (create) {
    e=new DialogOption();
    parent.addOption(e);
  }
  String key=e.getText();
  if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX)   key=Ctx.project.getI18N().genKey(Ctx.project.getSelectedScene().getId(),Ctx.project.getSelectedActor().getId(),parent.getId(),pos,""String_Node_Str"");
  Ctx.project.getI18N().setTranslation(key,text.getText());
  if (text.getText() != null && !text.getText().isEmpty())   e.setText(key);
 else   e.setText(null);
  String responseKey=e.getResponseText();
  if (responseKey == null || responseKey.isEmpty() || responseKey.charAt(0) != I18N.PREFIX)   responseKey=Ctx.project.getI18N().genKey(Ctx.project.getSelectedScene().getId(),Ctx.project.getSelectedActor().getId(),parent.getId(),pos,""String_Node_Str"");
  Ctx.project.getI18N().setTranslation(responseKey,responseText.getText());
  if (responseText.getText() != null && !responseText.getText().isEmpty())   e.setResponseText(responseKey);
 else   e.setResponseText(null);
  e.setVerbId(verb.getText());
  e.setNext(next.getText());
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  e.setOnce(Boolean.parseBoolean(once.getText()));
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  if (create) {
    e=new DialogOption();
    parent.getOptions().add(pos,e);
  }
  String key=e.getText();
  if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX)   key=Ctx.project.getI18N().genKey(Ctx.project.getSelectedScene().getId(),Ctx.project.getSelectedActor().getId(),parent.getId(),pos,""String_Node_Str"");
  Ctx.project.getI18N().setTranslation(key,text.getText());
  if (text.getText() != null && !text.getText().isEmpty())   e.setText(key);
 else   e.setText(null);
  String responseKey=e.getResponseText();
  if (responseKey == null || responseKey.isEmpty() || responseKey.charAt(0) != I18N.PREFIX)   responseKey=Ctx.project.getI18N().genKey(Ctx.project.getSelectedScene().getId(),Ctx.project.getSelectedActor().getId(),parent.getId(),pos,""String_Node_Str"");
  Ctx.project.getI18N().setTranslation(responseKey,responseText.getText());
  if (responseText.getText() != null && !responseText.getText().isEmpty())   e.setResponseText(responseKey);
 else   e.setResponseText(null);
  e.setVerbId(verb.getText());
  e.setNext(next.getText());
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  e.setOnce(Boolean.parseBoolean(once.getText()));
  Ctx.project.setModified();
}",0.9924030387844862
30253,"@Override protected void create(){
  EditOptionDialog dialog=(EditOptionDialog)getEditElementDialogInstance(null);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      int pos=list.getSelectedIndex() + 1;
      DialogOption e=((EditOptionDialog)actor).getElement();
      list.getItems().insert(pos,e);
      list.setSelectedIndex(pos);
      list.invalidateHierarchy();
      if (pos != 0 && pos < list.getItems().size) {
        DialogOption e2=list.getItems().get(pos);
        parent.getOptions().set(pos,e);
        parent.getOptions().set(list.getItems().size - 1,e2);
      }
    }
  }
);
}","@Override protected void create(){
  EditOptionDialog dialog=(EditOptionDialog)getEditElementDialogInstance(null);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      int pos=list.getSelectedIndex() + 1;
      DialogOption e=((EditOptionDialog)actor).getElement();
      list.getItems().insert(pos,e);
      list.setSelectedIndex(pos);
      list.invalidateHierarchy();
    }
  }
);
}",0.814625850340136
30254,"@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex() + 1;
  DialogOption e=((EditOptionDialog)actor).getElement();
  list.getItems().insert(pos,e);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  if (pos != 0 && pos < list.getItems().size) {
    DialogOption e2=list.getItems().get(pos);
    parent.getOptions().set(pos,e);
    parent.getOptions().set(list.getItems().size - 1,e2);
  }
}","@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex() + 1;
  DialogOption e=((EditOptionDialog)actor).getElement();
  list.getItems().insert(pos,e);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
}",0.7241379310344828
30255,"@Override protected void inputsToModel(boolean create){
  if (create) {
    e=new Dialog();
  }
 else {
    parent.getDialogs().remove(e.getId());
  }
  e.setId(ElementUtils.getCheckedId(id.getText(),parent.getDialogs().keySet().toArray(new String[0])));
  parent.addDialog(e);
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  if (create) {
    e=new Dialog();
  }
 else {
    parent.getDialogs().remove(e.getId());
  }
  if (parent.getDialogs() != null)   e.setId(ElementUtils.getCheckedId(id.getText(),parent.getDialogs().keySet().toArray(new String[0])));
 else   e.setId(id.getText());
  parent.addDialog(e);
  Ctx.project.setModified();
}",0.9032258064516128
30256,"public EditOptionDialog(Skin skin,Dialog parent,DialogOption e,int pos){
  super(skin);
  this.pos=e == null ? pos + 1 : pos;
  text=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Type.SMALL_TEXT,true);
  responseText=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Type.TEXT,false);
  verb=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  next=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",getActorDialogs((CharacterActor)Ctx.project.getSelectedActor()),false);
  visible=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,false);
  once=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,false);
  setInfo(""String_Node_Str"");
  text.getCell(text.getField()).fillX();
  responseText.getCell(responseText.getField()).fillX();
  init(parent,e,new InputPanel[]{text,responseText,verb,next,visible,once});
}","public EditOptionDialog(Skin skin,Dialog parent,DialogOption e,int pos){
  super(skin);
  this.pos=e == null ? pos + 1 : pos;
  text=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Type.SMALL_TEXT,true);
  responseText=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Type.TEXT,false);
  verb=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  next=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",getActorDialogs((CharacterActor)Ctx.project.getSelectedActor()),false);
  visible=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"");
  once=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,false);
  setInfo(""String_Node_Str"");
  text.getCell(text.getField()).fillX();
  responseText.getCell(responseText.getField()).fillX();
  init(parent,e,new InputPanel[]{text,responseText,verb,next,visible,once});
}",0.9867452135493372
30257,"@Override public void act(float delta){
  super.act(delta);
  Text currentSubtitle=World.getInstance().getTextManager().getCurrentText();
  if (subtitle != currentSubtitle) {
    subtitle=currentSubtitle;
    if (currentSubtitle == null && isVisible()) {
      setVisible(false);
    }
 else     if (currentSubtitle != null && !isVisible()) {
      setVisible(true);
    }
    if (isVisible()) {
      float posx=currentSubtitle.x;
      float posy=currentSubtitle.y;
      unprojectTmp.set(posx,posy,0);
      World.getInstance().getSceneCamera().scene2screen(getStage().getViewport(),unprojectTmp);
      float maxWidth=currentSubtitle.type == Text.Type.TALK ? maxTalkWidth : maxRectangleWidth;
      final TextManagerUIStyle style=getStyle(currentSubtitle);
      Color color=currentSubtitle.color != null ? currentSubtitle.color : style.defaultColor;
      if (color == null)       color=Color.BLACK;
      layout.setText(style.font,currentSubtitle.str,color,maxWidth,Align.center,true);
      if (posx == TextManager.POS_CENTER || posx == TextManager.POS_SUBTITLE) {
        posx=(getStage().getViewport().getScreenWidth() - layout.width) / 2;
        fontX=(getStage().getViewport().getScreenWidth() - maxWidth) / 2;
      }
 else {
        posx=unprojectTmp.x;
        fontX=unprojectTmp.x;
      }
      if (posy == TextManager.POS_CENTER) {
        posy=(getStage().getViewport().getScreenHeight() - layout.height) / 2;
      }
 else       if (posy == TextManager.POS_SUBTITLE) {
        posy=getStage().getViewport().getScreenHeight() - layout.height - DPIUtils.getMarginSize() * 4;
      }
 else {
        posy=unprojectTmp.y;
      }
      setPosition(posx - PADDING,posy - PADDING);
      setSize(layout.width + PADDING * 2,layout.height + PADDING * 2);
      if (currentSubtitle.type == Text.Type.TALK) {
        if (style.talkBubble != null) {
          setY(getY() + DPIUtils.getTouchMinSize() / 3 + PADDING);
        }
        setX(getX() - layout.width / 2);
        fontX=posx - maxWidth / 2;
        if (getX() < 0 && getX() > -getWidth()) {
          setX(0);
          fontX=getX() + PADDING;
        }
 else         if (getX() + getWidth() > getStage().getViewport().getScreenWidth() && getX() + getWidth() < getStage().getViewport().getScreenWidth() + getWidth()) {
          setX(getStage().getViewport().getScreenWidth() - getWidth());
          fontX=getStage().getViewport().getScreenWidth() - layout.width / 2 - PADDING - maxWidth / 2;
        }
        if (getY() + getHeight() > getStage().getViewport().getScreenHeight()) {
          setY(getStage().getViewport().getScreenHeight() - getHeight());
        }
      }
    }
  }
}","@Override public void act(float delta){
  super.act(delta);
  Text currentSubtitle=World.getInstance().getTextManager().getCurrentText();
  if (subtitle != currentSubtitle) {
    subtitle=currentSubtitle;
    if (currentSubtitle == null && isVisible()) {
      setVisible(false);
    }
 else     if (currentSubtitle != null && !isVisible()) {
      setVisible(true);
    }
    if (isVisible()) {
      float posx=currentSubtitle.x;
      float posy=currentSubtitle.y;
      unprojectTmp.set(posx,posy,0);
      World.getInstance().getSceneCamera().scene2screen(getStage().getViewport(),unprojectTmp);
      float maxWidth=currentSubtitle.type == Text.Type.TALK ? maxTalkWidth : maxRectangleWidth;
      final TextManagerUIStyle style=getStyle(currentSubtitle);
      Color color=currentSubtitle.color != null ? currentSubtitle.color : style.defaultColor;
      if (color == null)       color=Color.BLACK;
      layout.setText(style.font,currentSubtitle.str,color,maxWidth,Align.center,true);
      if (posx == TextManager.POS_CENTER || posx == TextManager.POS_SUBTITLE) {
        posx=(getStage().getViewport().getScreenWidth() - layout.width) / 2;
        fontX=(getStage().getViewport().getScreenWidth() - maxWidth) / 2;
      }
 else {
        posx=unprojectTmp.x;
        fontX=unprojectTmp.x;
      }
      if (posy == TextManager.POS_CENTER) {
        posy=(getStage().getViewport().getScreenHeight() - layout.height) / 2;
      }
 else       if (posy == TextManager.POS_SUBTITLE) {
        posy=getStage().getViewport().getScreenHeight() - layout.height - DPIUtils.getMarginSize() * 4;
      }
 else {
        posy=unprojectTmp.y;
      }
      setPosition(posx - PADDING,posy - PADDING);
      setSize(layout.width + PADDING * 2,layout.height + PADDING * 2);
      if (currentSubtitle.type == Text.Type.TALK) {
        if (style.talkBubble != null) {
          setY(getY() + DPIUtils.getTouchMinSize() / 3 + PADDING);
        }
        setX(getX() - layout.width / 2);
        fontX=posx - maxWidth / 2;
        if (getX() < 0 && getX() > -getWidth()) {
          setX(0 + PADDING);
          fontX=getX() + PADDING + (layout.width - maxWidth) / 2;
        }
 else         if (getX() + getWidth() > getStage().getViewport().getScreenWidth() && getX() + getWidth() < getStage().getViewport().getScreenWidth() + getWidth()) {
          setX(getStage().getViewport().getScreenWidth() - getWidth());
          fontX=getStage().getViewport().getScreenWidth() - layout.width / 2 - PADDING - maxWidth / 2;
        }
        if (getY() + getHeight() > getStage().getViewport().getScreenHeight()) {
          setY(getStage().getViewport().getScreenHeight() - getHeight());
        }
      }
    }
  }
}",0.8634328358208955
30258,"@Override public void draw(Batch batch,float alpha){
  batch.setColor(Color.WHITE);
  final TextManagerUIStyle style=getStyle(subtitle);
  if (subtitle.type == Text.Type.TALK) {
    if (style.talkBubble != null) {
      float scale=DPIUtils.getTouchMinSize() / 4 / style.talkBubble.getMinHeight();
      unprojectTmp.set(subtitle.x,subtitle.y,0);
      World.getInstance().getSceneCamera().scene2screen(getStage().getViewport(),unprojectTmp);
      float bubbleX=unprojectTmp.x - style.talkBubble.getMinWidth() * scale / 2;
      float bubbleY=getY() - style.talkBubble.getMinHeight() * scale + 2;
      if (bubbleX + style.talkBubble.getMinWidth() * scale < getX() + getWidth() && bubbleX > getX())       style.talkBubble.draw(batch,bubbleX,bubbleY,style.talkBubble.getMinWidth() * scale,style.talkBubble.getMinHeight() * scale);
    }
    if (style.talkBackground != null) {
      style.talkBackground.draw(batch,getX(),getY(),getWidth(),getHeight());
    }
  }
 else   if (subtitle.type == Text.Type.SUBTITLE) {
    if (style.rectBackground != null) {
      style.rectBackground.draw(batch,getX(),getY(),getWidth(),getHeight());
    }
  }
  style.font.draw(batch,layout,fontX,getY() + PADDING + layout.height);
}","@Override public void draw(Batch batch,float alpha){
  batch.setColor(Color.WHITE);
  final TextManagerUIStyle style=getStyle(subtitle);
  if (subtitle.type == Text.Type.TALK) {
    if (getX() < 0 || getX() > getStage().getViewport().getScreenWidth())     return;
    if (style.talkBubble != null) {
      float scale=DPIUtils.getTouchMinSize() / 4 / style.talkBubble.getMinHeight();
      float bubbleX=unprojectTmp.x - style.talkBubble.getMinWidth() * scale / 2;
      bubbleX=Math.max(bubbleX,getX() + PADDING);
      bubbleX=Math.min(bubbleX,getStage().getViewport().getScreenWidth() - PADDING);
      float bubbleY=getY() - style.talkBubble.getMinHeight() * scale + 2;
      style.talkBubble.draw(batch,bubbleX,bubbleY,style.talkBubble.getMinWidth() * scale,style.talkBubble.getMinHeight() * scale);
    }
    if (style.talkBackground != null) {
      style.talkBackground.draw(batch,getX(),getY(),getWidth(),getHeight());
    }
  }
 else   if (subtitle.type == Text.Type.SUBTITLE) {
    if (style.rectBackground != null) {
      style.rectBackground.draw(batch,getX(),getY(),getWidth(),getHeight());
    }
  }
  style.font.draw(batch,layout,fontX,getY() + PADDING + layout.height);
}",0.3344425956738768
30259,"@Override public String toString(){
  StringBuffer sb=new StringBuffer(super.toString());
  sb.append(""String_Node_Str"");
  for (  Animation a : currentSource.modelInstance.animations) {
    sb.append(""String_Node_Str"").append(a.id);
  }
  if (currentSource.controller.current != null)   sb.append(""String_Node_Str"").append(currentSource.controller.current.animation.id);
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer(super.toString());
  sb.append(""String_Node_Str"");
  if (currentSource != null) {
    for (    Animation a : currentSource.modelInstance.animations) {
      sb.append(""String_Node_Str"").append(a.id);
    }
    if (currentSource.controller.current != null)     sb.append(""String_Node_Str"").append(currentSource.controller.current.animation.id);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.6121546961325967
30260,"private int deleteFirstActionNamed(int pos,String actionId){
  while (!(list.getItems().get(pos) instanceof AbstractControlAction || getOrCreateControlActionId((AbstractControlAction)list.getItems().get(pos)).equals(actionId)))   pos++;
  Action e2=list.getItems().removeIndex(pos);
  parent.getActions().remove(e2);
  return pos;
}","private int deleteFirstActionNamed(int pos,String actionId){
  while (!(list.getItems().get(pos) instanceof AbstractControlAction && getOrCreateControlActionId((AbstractControlAction)list.getItems().get(pos)).equals(actionId)))   pos++;
  Action e2=list.getItems().removeIndex(pos);
  parent.getActions().remove(e2);
  return pos;
}",0.993975903614458
30261,"@Override public void read(Json json,JsonValue jsonData){
  visible=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  items.clear();
  JsonValue jsonValueActors=jsonData.get(""String_Node_Str"");
  SceneActorRef actorRef;
  for (int i=0; i < jsonValueActors.size; i++) {
    JsonValue jsonValueAct=jsonValueActors.get(i);
    actorRef=new SceneActorRef(jsonValueAct.name);
    Scene sourceScn=World.getInstance().getScene(actorRef.getSceneId());
    BaseActor actor=sourceScn.getActor(actorRef.getActorId(),false);
    actor.read(json,jsonValueAct);
    items.add((SpriteActor)actor);
  }
}","@Override public void read(Json json,JsonValue jsonData){
  visible=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  items.clear();
  JsonValue jsonValueActors=jsonData.get(""String_Node_Str"");
  SceneActorRef actorRef;
  for (int i=0; i < jsonValueActors.size; i++) {
    JsonValue jsonValueAct=jsonValueActors.get(i);
    actorRef=new SceneActorRef(jsonValueAct.name);
    Scene sourceScn=World.getInstance().getScene(actorRef.getSceneId());
    BaseActor actor=sourceScn.getActor(actorRef.getActorId(),false);
    sourceScn.removeActor(actor);
    addItem((SpriteActor)actor);
  }
  for (int i=0; i < jsonValueActors.size; i++) {
    JsonValue jsonValueAct=jsonValueActors.get(i);
    actorRef=new SceneActorRef(jsonValueAct.name);
    SpriteActor actor=items.get(i);
    actor.read(json,jsonValueAct);
  }
}",0.7935165609584214
30262,"@Override public void write(Json json){
  SceneActorRef actorRef;
  json.writeValue(""String_Node_Str"",visible);
  json.writeObjectStart(""String_Node_Str"");
  for (  SpriteActor a : items) {
    actorRef=new SceneActorRef(a.getInitScene(),a.getId());
    json.writeValue(actorRef.toString(),a);
  }
  json.writeObjectEnd();
}","@Override public void write(Json json){
  SceneActorRef actorRef;
  json.writeValue(""String_Node_Str"",visible);
  ;
  json.writeObjectStart(""String_Node_Str"");
  for (  SpriteActor a : items) {
    actorRef=new SceneActorRef(a.getInitScene(),a.getId());
    json.writeValue(actorRef.toString(),a);
  }
  json.writeObjectEnd();
}",0.9938650306748468
30263,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
  }
 else {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    assetState=AssetState.LOAD_ASSETS;
    for (    Scene s : scenes.values()) {
      s.read(json,jsonData.get(""String_Node_Str"").get(s.getId()));
    }
    inventory=json.readValue(""String_Node_Str"",Inventory.class,jsonData);
    timeOfGame=json.readValue(""String_Node_Str"",Float.class,jsonData);
    cutMode=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  if (SerializationHelper.getInstance().getMode() == Mode.MODEL) {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    scenes=json.readValue(""String_Node_Str"",HashMap.class,Scene.class,jsonData);
    initScene=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (initScene == null && scenes.size() > 0) {
      initScene=scenes.keySet().toArray(new String[0])[0];
    }
    for (    Scene s : scenes.values()) {
      s.resetCamera(width,height);
    }
    setCurrentScene(initScene);
  }
 else {
    String version=json.readValue(Config.BLADE_ENGINE_VERSION_PROP,String.class,jsonData);
    if (version != null && !version.equals(Config.getProperty(Config.VERSION_PROP,""String_Node_Str""))) {
      EngineLogger.debug(""String_Node_Str"" + version + ""String_Node_Str""+ Config.getProperty(Config.BLADE_ENGINE_VERSION_PROP,""String_Node_Str""));
    }
    currentChapter=json.readValue(""String_Node_Str"",String.class,jsonData);
    try {
      loadChapter(currentChapter);
    }
 catch (    IOException e1) {
      EngineLogger.error(""String_Node_Str"");
      return;
    }
    SerializationHelper.getInstance().setMode(Mode.STATE);
    currentScene=scenes.get(json.readValue(""String_Node_Str"",String.class,jsonData));
    assetState=AssetState.LOAD_ASSETS;
    inventory=json.readValue(""String_Node_Str"",Inventory.class,jsonData);
    for (    Scene s : scenes.values()) {
      s.read(json,jsonData.get(""String_Node_Str"").get(s.getId()));
    }
    timeOfGame=json.readValue(""String_Node_Str"",Float.class,jsonData);
    cutMode=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
    verbs.read(json,jsonData);
    timers=json.readValue(""String_Node_Str"",Timers.class,jsonData);
    textManager=json.readValue(""String_Node_Str"",TextManager.class,jsonData);
    customProperties=json.readValue(""String_Node_Str"",HashMap.class,String.class,jsonData);
    String actorId=json.readValue(""String_Node_Str"",String.class,jsonData);
    String dialogId=json.readValue(""String_Node_Str"",String.class,jsonData);
    if (dialogId != null) {
      CharacterActor actor=(CharacterActor)getCurrentScene().getActor(actorId,false);
      currentDialog=actor.getDialog(dialogId);
    }
    transition=json.readValue(""String_Node_Str"",Transition.class,jsonData);
    ActionCallbackQueue.read(json,jsonData);
    I18N.loadChapter(EngineAssetManager.MODEL_DIR + instance.currentChapter);
  }
}",0.9588698140200286
30264,"/** 
 * Extract an image from a texture atlas.
 * @param page The image file related to the page the region is in
 * @param region The region to extract
 * @param outputDirFile The output directory
 * @param padding padding (in pixels) to apply to the image
 * @return The extracted image
 */
private BufferedImage extractImage(BufferedImage page,Region region,File outputDirFile,int padding){
  BufferedImage splitImage=null;
  if (region.rotate) {
    BufferedImage srcImage=page.getSubimage(region.left,region.top,region.height,region.width);
    splitImage=new BufferedImage(region.width,region.height,page.getType());
    AffineTransform transform=new AffineTransform();
    transform.rotate(Math.toRadians(90.0));
    transform.translate(0,-region.width);
    AffineTransformOp op=new AffineTransformOp(transform,AffineTransformOp.TYPE_BILINEAR);
    op.filter(srcImage,splitImage);
  }
 else {
    splitImage=page.getSubimage(region.left,region.top,region.width,region.height);
  }
  if (padding > 0) {
    BufferedImage paddedImage=new BufferedImage(splitImage.getWidth() + padding * 2,splitImage.getHeight() + padding * 2,page.getType());
    Graphics2D g2=paddedImage.createGraphics();
    g2.drawImage(splitImage,padding,padding,null);
    g2.dispose();
    return paddedImage;
  }
 else   if (region.originalWidth != region.width || region.originalHeight != region.height) {
    BufferedImage paddedImage=new BufferedImage(region.originalWidth,region.originalHeight,page.getType());
    Graphics2D g2=paddedImage.createGraphics();
    g2.drawImage(splitImage,(int)region.offsetX,region.originalHeight - region.height,null);
    g2.dispose();
    return paddedImage;
  }
 else {
    return splitImage;
  }
}","/** 
 * Extract an image from a texture atlas.
 * @param page The image file related to the page the region is in
 * @param region The region to extract
 * @param outputDirFile The output directory
 * @param padding padding (in pixels) to apply to the image
 * @return The extracted image
 */
private BufferedImage extractImage(BufferedImage page,Region region,File outputDirFile,int padding){
  BufferedImage splitImage=null;
  if (region.rotate) {
    BufferedImage srcImage=page.getSubimage(region.left,region.top,region.height,region.width);
    splitImage=new BufferedImage(region.width,region.height,page.getType());
    AffineTransform transform=new AffineTransform();
    transform.rotate(Math.toRadians(90.0));
    transform.translate(0,-region.width);
    AffineTransformOp op=new AffineTransformOp(transform,AffineTransformOp.TYPE_BILINEAR);
    op.filter(srcImage,splitImage);
  }
 else {
    splitImage=page.getSubimage(region.left,region.top,region.width,region.height);
  }
  if (padding > 0) {
    BufferedImage paddedImage=new BufferedImage(splitImage.getWidth() + padding * 2,splitImage.getHeight() + padding * 2,page.getType());
    Graphics2D g2=paddedImage.createGraphics();
    g2.drawImage(splitImage,padding,padding,null);
    g2.dispose();
    return paddedImage;
  }
 else   if (region.originalWidth != region.width || region.originalHeight != region.height) {
    BufferedImage paddedImage=new BufferedImage(region.originalWidth,region.originalHeight,page.getType());
    Graphics2D g2=paddedImage.createGraphics();
    g2.drawImage(splitImage,(int)region.offsetX,region.originalHeight - region.height - (int)region.offsetY,null);
    g2.dispose();
    return paddedImage;
  }
 else {
    return splitImage;
  }
}",0.993637941006362
30265,"@Override protected void paste(){
  Scene newElement=(Scene)ElementUtils.cloneElement(clipboard);
  newElement.setId(ElementUtils.getCheckedId(newElement.getId(),World.getInstance().getScenes().keySet().toArray(new String[0])));
  int pos=list.getSelectedIndex() + 1;
  list.getItems().insert(pos,newElement);
  World.getInstance().addScene(newElement);
  Ctx.project.getI18N().extractStrings(newElement);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  Ctx.project.setModified();
}","@Override protected void paste(){
  Scene newElement=(Scene)ElementUtils.cloneElement(clipboard);
  newElement.setId(ElementUtils.getCheckedId(newElement.getId(),World.getInstance().getScenes().keySet().toArray(new String[0])));
  int pos=list.getSelectedIndex() + 1;
  list.getItems().insert(pos,newElement);
  World.getInstance().addScene(newElement);
  Ctx.project.getI18N().extractStrings(newElement);
  if (parent.getInitScene() == null) {
    parent.setInitScene(newElement.getId());
  }
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  Ctx.project.setModified();
}",0.9185185185185184
30266,"@Override protected void delete(){
  Scene s=removeSelected();
  parent.getScenes().remove(s.getId());
  if (parent.getInitScene().equals(s.getId())) {
    parent.setInitScene(null);
  }
  Ctx.project.getI18N().putTranslationsInElement(s);
  UndoOp undoOp=new UndoDeleteScene(s);
  Ctx.project.getUndoStack().add(undoOp);
  Ctx.project.setModified();
}","@Override protected void delete(){
  Scene s=removeSelected();
  parent.getScenes().remove(s.getId());
  if (parent.getInitScene() != null && parent.getInitScene().equals(s.getId())) {
    if (parent.getScenes().size() > 0)     parent.setInitScene(parent.getScenes().values().iterator().next().getId());
 else     parent.setInitScene(null);
  }
  Ctx.project.getI18N().putTranslationsInElement(s);
  UndoOp undoOp=new UndoDeleteScene(s);
  Ctx.project.getUndoStack().add(undoOp);
  Ctx.project.setModified();
}",0.8167053364269141
30267,"protected T removeSelected(){
  int pos=list.getSelectedIndex();
  if (pos == -1)   return null;
  T e=list.getItems().removeIndex(pos);
  clipboard=e;
  if (pos > 0)   list.setSelectedIndex(pos - 1);
 else   if (pos == 0 && list.getItems().size > 0)   list.setSelectedIndex(0);
  toolbar.disablePaste(false);
  return e;
}","protected T removeSelected(){
  int pos=list.getSelectedIndex();
  if (pos == -1)   return null;
  T e=list.getItems().removeIndex(pos);
  clipboard=e;
  if (pos > 0)   list.setSelectedIndex(pos - 1);
 else   if (pos == 0 && list.getItems().size > 0)   list.setSelectedIndex(0);
 else   list.getSelection().clear();
  toolbar.disablePaste(false);
  return e;
}",0.945827232796486
30268,"public static Action readJson(Json json,JsonValue jsonData){
  String className=jsonData.getString(""String_Node_Str"",null);
  Action action=null;
  if (className != null) {
    jsonData.remove(""String_Node_Str"");
    Class<?> clazz=null;
    try {
      clazz=ClassReflection.forName(className);
      action=(Action)clazz.newInstance();
    }
 catch (    ReflectionException|InstantiationException|IllegalAccessException ex) {
      throw new SerializationException(ex);
    }
    for (int j=0; j < jsonData.size; j++) {
      JsonValue v=jsonData.get(j);
      try {
        if (v.isNull())         ActionUtils.setParam(action,v.name,null);
 else         ActionUtils.setParam(action,v.name,v.asString());
      }
 catch (      NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
        throw new SerializationException(e);
      }
    }
  }
  return action;
}","public static Action readJson(Json json,JsonValue jsonData){
  String className=jsonData.getString(""String_Node_Str"",null);
  Action action=null;
  if (className != null) {
    jsonData.remove(""String_Node_Str"");
    Class<?> clazz=null;
    try {
      clazz=ClassReflection.forName(className);
      action=(Action)clazz.newInstance();
    }
 catch (    ReflectionException|InstantiationException|IllegalAccessException ex) {
      throw new SerializationException(ex);
    }
    for (int j=0; j < jsonData.size; j++) {
      JsonValue v=jsonData.get(j);
      try {
        if (v.isNull())         ActionUtils.setParam(action,v.name,null);
 else         ActionUtils.setParam(action,v.name,v.asString());
      }
 catch (      NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
        throw new SerializationException(""String_Node_Str"" + action.getClass().getCanonicalName() + ""String_Node_Str""+ v.name,e);
      }
    }
  }
  return action;
}",0.9541284403669724
30269,"private void edit(){
  if (Desktop.isDesktopSupported()) {
    try {
      Desktop.getDesktop().open(new File(Ctx.project.getProjectDir().getAbsoluteFile() + ""String_Node_Str""));
    }
 catch (    IOException e1) {
      String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
      Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
    }
  }
}","private void edit(){
  if (Desktop.isDesktopSupported()) {
    String type=assetTypes.getSelected();
    String dir=getAssetDir(type);
    if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str""))     dir+=""String_Node_Str"";
    try {
      Desktop.getDesktop().open(new File(dir));
    }
 catch (    IOException e1) {
      String msg=""String_Node_Str"" + e1.getClass().getSimpleName() + ""String_Node_Str""+ e1.getMessage();
      Message.showMsgDialog(getStage(),""String_Node_Str"",msg);
    }
  }
}",0.7234513274336283
30270,"public ProjectToolbar(Skin skin){
  super(skin);
  this.skin=skin;
  left();
  newBtn=new ImageButton(skin);
  saveBtn=new ImageButton(skin);
  loadBtn=new ImageButton(skin);
  packageBtn=new ImageButton(skin);
  exitBtn=new ImageButton(skin);
  playBtn=new ImageButton(skin);
  assetsBtn=new ImageButton(skin);
  atlasBtn=new ImageButton(skin);
  addToolBarButton(skin,newBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,loadBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,saveBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,exitBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  row();
  addToolBarButton(skin,playBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,packageBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,assetsBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,atlasBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  newBtn.setDisabled(false);
  loadBtn.setDisabled(false);
  exitBtn.setDisabled(false);
  newBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      newProject();
    }
  }
);
  loadBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      loadProject();
    }
  }
);
  exitBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      exit();
    }
  }
);
  saveBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      saveProject();
    }
  }
);
  playBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      play();
    }
  }
);
  packageBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      packageProject();
    }
  }
);
  assetsBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      openProjectFolder();
    }
  }
);
  atlasBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      createAtlas();
    }
  }
);
  Ctx.project.addPropertyChangeListener(new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent e){
      saveBtn.setDisabled(!Ctx.project.isModified());
    }
  }
);
  Ctx.project.addPropertyChangeListener(Project.NOTIFY_PROJECT_LOADED,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent arg0){
      packageBtn.setDisabled(Ctx.project.getProjectDir() == null);
      playBtn.setDisabled(Ctx.project.getProjectDir() == null);
      assetsBtn.setDisabled(Ctx.project.getProjectDir() == null);
      atlasBtn.setDisabled(Ctx.project.getProjectDir() == null);
    }
  }
);
}","public ProjectToolbar(Skin skin){
  super(skin);
  this.skin=skin;
  left();
  newBtn=new ImageButton(skin);
  saveBtn=new ImageButton(skin);
  loadBtn=new ImageButton(skin);
  packageBtn=new ImageButton(skin);
  exitBtn=new ImageButton(skin);
  playBtn=new ImageButton(skin);
  assetsBtn=new ImageButton(skin);
  atlasBtn=new ImageButton(skin);
  addToolBarButton(skin,newBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,loadBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,saveBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,exitBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  row();
  addToolBarButton(skin,playBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,packageBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,assetsBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addToolBarButton(skin,atlasBtn,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  newBtn.setDisabled(false);
  loadBtn.setDisabled(false);
  exitBtn.setDisabled(false);
  newBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      newProject();
    }
  }
);
  loadBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      loadProject();
    }
  }
);
  exitBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      exit();
    }
  }
);
  saveBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      saveProject();
    }
  }
);
  playBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      play();
    }
  }
);
  packageBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      packageProject();
    }
  }
);
  assetsBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      openAssetFolder();
    }
  }
);
  atlasBtn.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      createAtlas();
    }
  }
);
  Ctx.project.addPropertyChangeListener(new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent e){
      saveBtn.setDisabled(!Ctx.project.isModified());
    }
  }
);
  Ctx.project.addPropertyChangeListener(Project.NOTIFY_PROJECT_LOADED,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent arg0){
      packageBtn.setDisabled(Ctx.project.getProjectDir() == null);
      playBtn.setDisabled(Ctx.project.getProjectDir() == null);
      assetsBtn.setDisabled(Ctx.project.getProjectDir() == null);
      atlasBtn.setDisabled(Ctx.project.getProjectDir() == null);
    }
  }
);
}",0.9983449189010262
30271,"@Override protected void paste(){
  Action newElement=(Action)ElementUtils.cloneElement(clipboard);
  int pos=list.getSelectedIndex() + 1;
  list.getItems().insert(pos,newElement);
  parent.getActions().add(pos,newElement);
  if (scope.equals(ScopePanel.WORLD_SCOPE))   Ctx.project.getI18N().extractStrings(null,null,parent.getHashKey(),pos,newElement);
 else   if (scope.equals(ScopePanel.SCENE_SCOPE))   Ctx.project.getI18N().extractStrings(Ctx.project.getSelectedScene().getId(),null,parent.getHashKey(),pos,newElement);
 else   Ctx.project.getI18N().extractStrings(Ctx.project.getSelectedScene().getId(),Ctx.project.getSelectedActor().getId(),parent.getHashKey(),pos,newElement);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  Ctx.project.setModified();
  if (isControlAction(newElement)) {
    try {
      ActionUtils.setParam(newElement,CONTROL_ACTION_ID_ATTR,null);
    }
 catch (    NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
      EditorLogger.error(e.getMessage());
    }
    insertEndAction(pos + 1,getOrCreateControlActionId((AbstractControlAction)newElement));
  }
}","@Override protected void paste(){
  Action newElement=(Action)ElementUtils.cloneElement(clipboard);
  int pos=list.getSelectedIndex() + 1;
  list.getItems().insert(pos,newElement);
  parent.getActions().add(pos,newElement);
  if (scope.equals(ScopePanel.WORLD_SCOPE))   Ctx.project.getI18N().extractStrings(null,null,parent.getHashKey(),pos,newElement);
 else   if (scope.equals(ScopePanel.SCENE_SCOPE))   Ctx.project.getI18N().extractStrings(Ctx.project.getSelectedScene().getId(),null,parent.getHashKey(),pos,newElement);
 else   Ctx.project.getI18N().extractStrings(Ctx.project.getSelectedScene().getId(),Ctx.project.getSelectedActor().getId(),parent.getHashKey(),pos,newElement);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
  Ctx.project.setModified();
  if (isControlAction(newElement)) {
    try {
      ActionUtils.setParam(newElement,CONTROL_ACTION_ID_ATTR,null);
    }
 catch (    NoSuchFieldException|IllegalArgumentException|IllegalAccessException e) {
      EditorLogger.error(e.getMessage());
    }
    insertEndAction(pos + 1,getOrCreateControlActionId((AbstractControlAction)newElement));
    if (newElement instanceof AbstractIfAction)     insertEndAction(pos + 2,getOrCreateControlActionId((AbstractControlAction)newElement));
  }
}",0.9414225941422594
30272,"public void loadProject(File projectFile) throws IOException {
  File oldProjectFile=this.projectFile;
  this.projectFile=projectFile;
  if (checkProjectStructure()) {
    try {
      DinamicClassPath.addFile(projectFile.getAbsolutePath() + ""String_Node_Str"");
      DinamicClassPath.addFile(projectFile.getAbsolutePath() + ""String_Node_Str"");
      DinamicClassPath.addFile(projectFile.getAbsolutePath() + ""String_Node_Str"");
    }
 catch (    IOException e) {
      e.printStackTrace();
      System.exit(0);
    }
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH);
    try {
      World.getInstance().loadWorldDesc();
    }
 catch (    SerializationException ex) {
      if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
        EditorLogger.debug(""String_Node_Str"");
        if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
          loadProject(projectFile);
        }
 else {
          throw new IOException(""String_Node_Str"");
        }
      }
 else {
        throw ex;
      }
    }
    chapter=new Chapter(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    i18n=new I18NHandler(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    editorConfig.setProperty(LAST_PROJECT_PROP,projectFile.getAbsolutePath());
    projectConfig=new Properties();
    projectConfig.load(new FileInputStream(projectFile.getAbsolutePath() + ASSETS_PATH + ""String_Node_Str""+ Config.PROPERTIES_FILENAME));
    firePropertyChange(NOTIFY_PROJECT_LOADED);
  }
 else {
    this.projectFile=oldProjectFile;
    throw new IOException(""String_Node_Str"");
  }
}","public void loadProject(File projectFile) throws IOException {
  File oldProjectFile=this.projectFile;
  this.projectFile=projectFile;
  if (checkProjectStructure()) {
    try {
      DinamicClassPath.addFile(projectFile.getAbsolutePath() + ""String_Node_Str"");
      DinamicClassPath.addFile(projectFile.getAbsolutePath() + ""String_Node_Str"");
      DinamicClassPath.addFile(projectFile.getAbsolutePath() + ""String_Node_Str"");
    }
 catch (    IOException e) {
      e.printStackTrace();
      System.exit(0);
    }
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH);
    try {
      World.getInstance().loadWorldDesc();
    }
 catch (    SerializationException ex) {
      if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
        EditorLogger.debug(""String_Node_Str"");
        if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
          World.getInstance().loadWorldDesc();
        }
 else {
          throw new IOException(""String_Node_Str"");
        }
      }
 else {
        throw ex;
      }
    }
    chapter=new Chapter(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    i18n=new I18NHandler(Ctx.project.getProjectDir().getAbsolutePath() + Project.MODEL_PATH);
    editorConfig.setProperty(LAST_PROJECT_PROP,projectFile.getAbsolutePath());
    projectConfig=new Properties();
    projectConfig.load(new FileInputStream(projectFile.getAbsolutePath() + ASSETS_PATH + ""String_Node_Str""+ Config.PROPERTIES_FILENAME));
    firePropertyChange(NOTIFY_PROJECT_LOADED);
  }
 else {
    this.projectFile=oldProjectFile;
    throw new IOException(""String_Node_Str"");
  }
}",0.9837096313232352
30273,"public void loadChapter(String selChapter) throws IOException {
  undoStack.clear();
  try {
    chapter.load(selChapter);
  }
 catch (  SerializationException ex) {
    if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
      EditorLogger.debug(""String_Node_Str"");
      if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
        loadProject(projectFile);
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      throw ex;
    }
  }
  i18n.load(selChapter);
}","public void loadChapter(String selChapter) throws IOException {
  undoStack.clear();
  try {
    chapter.load(selChapter);
  }
 catch (  SerializationException ex) {
    if (ex.getCause() != null && ex.getCause().getCause() != null && ex.getCause().getCause() instanceof ClassNotFoundException) {
      EditorLogger.debug(""String_Node_Str"");
      if (RunProccess.runGradle(Ctx.project.getProjectDir(),""String_Node_Str"")) {
        chapter.load(selChapter);
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      throw ex;
    }
  }
  i18n.load(selChapter);
}",0.9615384615384616
30274,"public void layout(){
  final BitmapFont font=style.font;
  final Drawable selectedDrawable=style.selection;
  cellRenderer.layout(style);
  GlyphLayout textLayout=new GlyphLayout();
  prefWidth=0;
  for (int i=0; i < items.size; i++) {
    textLayout.setText(font,cellRenderer.getCellTitle(items.get(i)));
    prefWidth=Math.max(textLayout.width,prefWidth);
    if (cellRenderer.hasSubtitle()) {
      String subtitle=cellRenderer.getCellSubTitle(items.get(i));
      if (subtitle != null) {
        textLayout.setText(font,subtitle);
        prefWidth=Math.max(textLayout.width,prefWidth);
      }
    }
    if (cellRenderer.hasImage()) {
      TextureRegion r=cellRenderer.getCellImage(items.get(i));
      float ih=r.getRegionHeight();
      float iw=r.getRegionWidth();
      if (ih > getItemHeight() - 10) {
        ih=getItemHeight() - 10;
        iw*=ih / r.getRegionHeight();
      }
      prefWidth=Math.max(iw,prefWidth);
    }
  }
  prefWidth+=selectedDrawable.getLeftWidth() + selectedDrawable.getRightWidth();
  prefHeight=items.size * cellRenderer.getItemHeight();
  Drawable background=style.background;
  if (background != null) {
    prefWidth+=background.getLeftWidth() + background.getRightWidth();
    prefHeight+=background.getTopHeight() + background.getBottomHeight();
  }
}","public void layout(){
  final BitmapFont font=style.font;
  final BitmapFont subfont=style.subtitleFont;
  final Drawable selectedDrawable=style.selection;
  cellRenderer.layout(style);
  GlyphLayout textLayout=new GlyphLayout();
  prefWidth=0;
  for (int i=0; i < items.size; i++) {
    textLayout.setText(font,cellRenderer.getCellTitle(items.get(i)));
    prefWidth=Math.max(textLayout.width,prefWidth);
    if (cellRenderer.hasImage()) {
      TextureRegion r=cellRenderer.getCellImage(items.get(i));
      float ih=r.getRegionHeight();
      float iw=r.getRegionWidth();
      if (ih > getItemHeight() - 10) {
        ih=getItemHeight() - 10;
        iw*=ih / r.getRegionHeight();
      }
      prefWidth=Math.max(iw + textLayout.width,prefWidth);
    }
    if (cellRenderer.hasSubtitle()) {
      String subtitle=cellRenderer.getCellSubTitle(items.get(i));
      if (subtitle != null) {
        textLayout.setText(subfont,subtitle);
        prefWidth=Math.max(textLayout.width,prefWidth);
      }
    }
  }
  prefWidth+=selectedDrawable.getLeftWidth() + selectedDrawable.getRightWidth();
  prefHeight=items.size * cellRenderer.getItemHeight();
  Drawable background=style.background;
  if (background != null) {
    prefWidth+=background.getLeftWidth() + background.getRightWidth();
    prefHeight+=background.getTopHeight() + background.getBottomHeight();
  }
}",0.7887429643527204
30275,"protected void init(PARENT parent,T e,InputPanel[] inputs){
  this.e=e;
  this.parent=parent;
  this.i=inputs;
  getCenterPanel().clear();
  for (  InputPanel i : inputs) {
    addInputPanel(i);
  }
  if (e == null) {
    setTitle(""String_Node_Str"");
  }
 else {
    setTitle(""String_Node_Str"" + e.getClass().getSimpleName());
    try {
      modelToInputs();
    }
 catch (    Exception e1) {
      Message.showMsg(getStage(),""String_Node_Str"" + e1.getMessage(),4);
      e1.printStackTrace();
    }
  }
}","protected void init(PARENT parent,T e,InputPanel[] inputs){
  this.e=e;
  this.parent=parent;
  this.i=inputs;
  getCenterPanel().clear();
  for (  InputPanel i : inputs) {
    addInputPanel(i);
  }
  if (e == null) {
    setTitle(""String_Node_Str"");
  }
 else {
    setTitle(""String_Node_Str"" + e.getClass().getSimpleName());
    try {
      modelToInputs();
    }
 catch (    Exception e1) {
      EditorLogger.error(e1.getMessage());
      e1.printStackTrace();
    }
  }
}",0.8981670061099797
30276,"public void setText(String s){
  input.setText(s.replaceAll(""String_Node_Str"",""String_Node_Str""));
}","public void setText(String s){
  if (s == null)   s=""String_Node_Str"";
  input.setText(s.replaceAll(""String_Node_Str"",""String_Node_Str""));
}",0.8333333333333334
30277,"@Override public void changed(ChangeEvent event,Actor actor){
  setPlayer();
}","@SuppressWarnings(""String_Node_Str"") @Override public void changed(ChangeEvent event,Actor actor){
  BaseActor e=((EditModelDialog<Scene,BaseActor>)actor).getElement();
  if (e != list.getSelected()) {
    int i=list.getSelectedIndex();
    getItems().set(i,e);
    list.setSelectedIndex(i);
    list.invalidateHierarchy();
  }
}",0.3243243243243243
30278,"@Override public boolean run(ActionCallback cb){
  setVerbCb(cb);
  World w=World.getInstance();
  DialogOption o=World.getInstance().getCurrentDialog().getCurrentOption();
  String playerText=o.getText();
  responseText=o.getResponseText();
  characterName=w.getCurrentDialog().getActor();
  characterTurn=true;
  previousAnim=null;
  restoreStandPose(w.getCurrentScene().getPlayer());
  if (w.getCurrentScene().getActor(characterName,false) instanceof SpriteActor)   restoreStandPose((CharacterActor)w.getCurrentScene().getActor(characterName,false));
  if (playerText != null) {
    CharacterActor player=World.getInstance().getCurrentScene().getPlayer();
    World.getInstance().getTextManager().addText(playerText,player.getX(),player.getY() + player.getHeight(),false,Text.Type.TALK,player.getTextColor(),null,this);
    startTalkAnim(player);
  }
 else {
    resume();
  }
  return getWait();
}","@Override public boolean run(ActionCallback cb){
  setVerbCb(cb);
  World w=World.getInstance();
  DialogOption o=w.getCurrentDialog().getCurrentOption();
  String playerText=o.getText();
  responseText=o.getResponseText();
  characterName=w.getCurrentDialog().getActor();
  characterTurn=true;
  previousAnim=null;
  restoreStandPose(w.getCurrentScene().getPlayer());
  if (w.getCurrentScene().getActor(characterName,false) instanceof SpriteActor)   restoreStandPose((CharacterActor)w.getCurrentScene().getActor(characterName,false));
  if (playerText != null) {
    CharacterActor player=w.getCurrentScene().getPlayer();
    w.getTextManager().addText(playerText,player.getX(),player.getY() + player.getHeight(),false,Text.Type.TALK,player.getTextColor(),null,this);
    startTalkAnim(player);
  }
 else {
    resume();
  }
  return getWait();
}",0.965675057208238
30279,"public void setCurrentDialog(Dialog dialog){
  this.currentDialog=dialog;
  if (dialog != null) {
    dialog.reset();
    int visibleOptions=dialog.getNumVisibleOptions();
    if (visibleOptions == 0)     currentDialog=null;
 else     if (visibleOptions == 1) {
      selectVisibleDialogOption(0);
    }
  }
}","public void setCurrentDialog(Dialog dialog){
  this.currentDialog=dialog;
  if (dialog != null) {
    dialog.reset();
    int visibleOptions=dialog.getNumVisibleOptions();
    if (visibleOptions == 0)     currentDialog=null;
  }
}",0.8534322820037106
30280,"@Override protected void inputsToModel(boolean create){
  if (create) {
    e=new Verb();
  }
  e.setId(id.getText());
  e.setState(state.getText());
  e.setTarget(target.getText());
  if (create) {
    parent.addVerb(e);
  }
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  if (create) {
    e=new Verb();
  }
 else {
    HashMap<String,Verb> verbs=parent.getVerbs();
    verbs.remove(e.getHashKey());
  }
  e.setId(id.getText());
  e.setState(state.getText());
  e.setTarget(target.getText());
  parent.addVerb(e);
  Ctx.project.setModified();
}",0.6416382252559727
30281,"public FileInputPanel(Skin skin,String title,String desc,File current,final DialogType dialogType){
  init(skin,title,desc,new TextButton(dialogType == DialogType.DIRECTORY ? DIR_TEXT : FILE_TEXT,skin),true,null);
  this.cd=current;
  ((TextButton)getField()).addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Platform.runLater(new Runnable(){
        @Override public void run(){
          final File result;
switch (dialogType) {
case DIRECTORY:
{
              DirectoryChooser chooser=new DirectoryChooser();
              chooser.setTitle(DIR_TEXT);
              result=chooser.showDialog(null);
              break;
            }
case OPEN_FILE:
case SAVE_FILE:
{
            FileChooser chooser=new FileChooser();
            chooser.setInitialDirectory(cd);
            chooser.setTitle(FILE_TEXT);
            result=dialogType == DialogType.OPEN_FILE ? chooser.showOpenDialog(null) : chooser.showSaveDialog(null);
            break;
          }
default :
        throw new RuntimeException(""String_Node_Str"");
    }
    if (result != null) {
      ((TextButton)getField()).setText(result.getAbsolutePath());
      selected=cd=result;
    }
  }
}
);
}
}
);
}","public FileInputPanel(Skin skin,String title,String desc,File current,final DialogType dialogType){
  init(skin,title,desc,new TextButton(dialogType == DialogType.DIRECTORY ? DIR_TEXT : FILE_TEXT,skin),true,null);
  this.cd=current;
  ((TextButton)getField()).addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Platform.runLater(new Runnable(){
        @Override public void run(){
          final File result;
switch (dialogType) {
case DIRECTORY:
{
              DirectoryChooser chooser=new DirectoryChooser();
              chooser.setTitle(DIR_TEXT);
              result=chooser.showDialog(null);
              break;
            }
case OPEN_FILE:
case SAVE_FILE:
{
            FileChooser chooser=new FileChooser();
            chooser.setTitle(FILE_TEXT);
            result=dialogType == DialogType.OPEN_FILE ? chooser.showOpenDialog(null) : chooser.showSaveDialog(null);
            break;
          }
default :
        throw new RuntimeException(""String_Node_Str"");
    }
    if (result != null) {
      ((TextButton)getField()).setText(result.getAbsolutePath());
      selected=cd=result;
    }
  }
}
);
}
}
);
}",0.9813355454168396
30282,"@Override public void run(){
  final File result;
switch (dialogType) {
case DIRECTORY:
{
      DirectoryChooser chooser=new DirectoryChooser();
      chooser.setTitle(DIR_TEXT);
      result=chooser.showDialog(null);
      break;
    }
case OPEN_FILE:
case SAVE_FILE:
{
    FileChooser chooser=new FileChooser();
    chooser.setInitialDirectory(cd);
    chooser.setTitle(FILE_TEXT);
    result=dialogType == DialogType.OPEN_FILE ? chooser.showOpenDialog(null) : chooser.showSaveDialog(null);
    break;
  }
default :
throw new RuntimeException(""String_Node_Str"");
}
if (result != null) {
((TextButton)getField()).setText(result.getAbsolutePath());
selected=cd=result;
}
}","@Override public void run(){
  final File result;
switch (dialogType) {
case DIRECTORY:
{
      DirectoryChooser chooser=new DirectoryChooser();
      chooser.setTitle(DIR_TEXT);
      result=chooser.showDialog(null);
      break;
    }
case OPEN_FILE:
case SAVE_FILE:
{
    FileChooser chooser=new FileChooser();
    chooser.setTitle(FILE_TEXT);
    result=dialogType == DialogType.OPEN_FILE ? chooser.showOpenDialog(null) : chooser.showSaveDialog(null);
    break;
  }
default :
throw new RuntimeException(""String_Node_Str"");
}
if (result != null) {
((TextButton)getField()).setText(result.getAbsolutePath());
selected=cd=result;
}
}",0.9716908951798012
30283,"public void clicked(InputEvent event,float x,float y){
  Platform.runLater(new Runnable(){
    @Override public void run(){
      final File result;
switch (dialogType) {
case DIRECTORY:
{
          DirectoryChooser chooser=new DirectoryChooser();
          chooser.setTitle(DIR_TEXT);
          result=chooser.showDialog(null);
          break;
        }
case OPEN_FILE:
case SAVE_FILE:
{
        FileChooser chooser=new FileChooser();
        chooser.setInitialDirectory(cd);
        chooser.setTitle(FILE_TEXT);
        result=dialogType == DialogType.OPEN_FILE ? chooser.showOpenDialog(null) : chooser.showSaveDialog(null);
        break;
      }
default :
    throw new RuntimeException(""String_Node_Str"");
}
if (result != null) {
  ((TextButton)getField()).setText(result.getAbsolutePath());
  selected=cd=result;
}
}
}
);
}","public void clicked(InputEvent event,float x,float y){
  Platform.runLater(new Runnable(){
    @Override public void run(){
      final File result;
switch (dialogType) {
case DIRECTORY:
{
          DirectoryChooser chooser=new DirectoryChooser();
          chooser.setTitle(DIR_TEXT);
          result=chooser.showDialog(null);
          break;
        }
case OPEN_FILE:
case SAVE_FILE:
{
        FileChooser chooser=new FileChooser();
        chooser.setTitle(FILE_TEXT);
        result=dialogType == DialogType.OPEN_FILE ? chooser.showOpenDialog(null) : chooser.showSaveDialog(null);
        break;
      }
default :
    throw new RuntimeException(""String_Node_Str"");
}
if (result != null) {
  ((TextButton)getField()).setText(result.getAbsolutePath());
  selected=cd=result;
}
}
}
);
}",0.97467572575664
30284,"public void setSelectedActor(BaseActor actor){
  BaseActor a=null;
  if (scn != null && actor != null) {
    a=actor;
  }
  selectedActor=a;
  faRenderer.setActor(a);
  setAnimation(null);
}","public void setSelectedActor(BaseActor actor){
  BaseActor a=null;
  if (scn != null && actor != null) {
    a=actor;
  }
  selectedActor=a;
  setAnimationRenderer(null,null);
}",0.8937329700272479
30285,"@Override public void act(float delta){
  if (projectLoadedFlag) {
    projectLoadedFlag=false;
    if (scn != null) {
      scn.dispose();
      scn=null;
    }
    setSelectedScene(Ctx.project.getSelectedScene());
    setSelectedActor(Ctx.project.getSelectedActor());
    setSelectedFA(Ctx.project.getSelectedFA());
  }
  if (scn != null && !loading && !loadingError) {
    if (!inScene)     faRenderer.update(delta);
    for (    SceneLayer layer : scn.getLayers())     layer.update();
    if (animation) {
      for (      BaseActor a : scn.getActors().values()) {
        a.update(delta);
      }
    }
    handleKeyPositioning();
  }
}","@Override public void act(float delta){
  if (projectLoadedFlag) {
    projectLoadedFlag=false;
    if (scn != null) {
      scn.dispose();
      scn=null;
    }
    setSelectedScene(Ctx.project.getSelectedScene());
    setSelectedActor(Ctx.project.getSelectedActor());
    setSelectedFA(Ctx.project.getSelectedFA());
  }
  if (scn != null && !loading && !loadingError) {
    if (!inScene)     faRenderer.update(delta);
    for (    SceneLayer layer : scn.getLayers())     layer.update();
    if (animation) {
      for (      BaseActor a : scn.getActors().values()) {
        boolean v=a.isVisible();
        a.setVisible(true);
        a.update(delta);
        a.setVisible(v);
      }
    }
    handleKeyPositioning();
  }
}",0.9166666666666666
30286,"@Override public void propertyChange(PropertyChangeEvent e){
  EditorLogger.debug(""String_Node_Str"" + e.getPropertyName());
  if (e.getPropertyName().equals(Project.NOTIFY_SCENE_SELECTED)) {
    if (!projectLoadedFlag)     setSelectedScene(Ctx.project.getSelectedScene());
  }
 else   if (e.getPropertyName().equals(Project.NOTIFY_ACTOR_SELECTED)) {
    if (!projectLoadedFlag)     setSelectedActor(Ctx.project.getSelectedActor());
  }
 else   if (e.getPropertyName().equals(Project.NOTIFY_ANIM_SELECTED)) {
    if (!projectLoadedFlag)     setSelectedFA(Ctx.project.getSelectedFA());
  }
 else   if (e.getPropertyName().equals(Project.NOTIFY_PROJECT_LOADED)) {
    projectLoadedFlag=true;
  }
 else   if (e.getPropertyName().equals(""String_Node_Str"")) {
    setSelectedScene(Ctx.project.getSelectedScene());
    setSelectedActor(Ctx.project.getSelectedActor());
  }
 else   if (e.getPropertyName().equals(""String_Node_Str"")) {
    if (!inScene)     setSelectedFA(null);
  }
}","@Override public void propertyChange(PropertyChangeEvent e){
  EditorLogger.debug(""String_Node_Str"" + e.getPropertyName());
  if (e.getPropertyName().equals(Project.NOTIFY_SCENE_SELECTED)) {
    if (!projectLoadedFlag)     setSelectedScene(Ctx.project.getSelectedScene());
  }
 else   if (e.getPropertyName().equals(Project.NOTIFY_ACTOR_SELECTED)) {
    if (!projectLoadedFlag)     setSelectedActor(Ctx.project.getSelectedActor());
  }
 else   if (e.getPropertyName().equals(Project.NOTIFY_ANIM_SELECTED)) {
    if (!projectLoadedFlag && Ctx.project.getSelectedFA() != null)     setSelectedFA(Ctx.project.getSelectedFA());
  }
 else   if (e.getPropertyName().equals(Project.NOTIFY_PROJECT_LOADED)) {
    projectLoadedFlag=true;
  }
 else   if (e.getPropertyName().equals(""String_Node_Str"")) {
    setSelectedScene(Ctx.project.getSelectedScene());
    setSelectedActor(Ctx.project.getSelectedActor());
  }
 else   if (e.getPropertyName().equals(""String_Node_Str"")) {
    if (!inScene)     setSelectedFA(null);
  }
}",0.9803921568627452
30287,"public void setSelectedFA(String selFA){
  if (selectedActor instanceof SpriteActor) {
    ActorRenderer s=((SpriteActor)selectedActor).getRenderer();
    if (selFA == null || (s.getAnimations().get(selFA) == null && s.getAnimations().get(AnimationDesc.getFlipId(selFA)) == null)) {
      selFA=((SpriteActor)selectedActor).getRenderer().getInitAnimation();
    }
    if (selFA != null && (s.getAnimations().get(selFA) != null || s.getAnimations().get(AnimationDesc.getFlipId(selFA)) != null)) {
      setAnimation(s.getAnimations().get(selFA));
      if (inScene || s.getCurrentAnimation() == null || ((SpriteActor)selectedActor).getRenderer().getInitAnimation().equals(selFA)) {
        try {
          ((SpriteActor)selectedActor).startAnimation(selFA,Tween.Type.REPEAT,Tween.INFINITY,null);
        }
 catch (        Exception e) {
          setAnimation(null);
          ((SpriteActor)selectedActor).getRenderer().getAnimations().remove(selFA);
        }
      }
    }
 else {
      setAnimation(null);
    }
  }
 else {
    setAnimation(null);
  }
}","public void setSelectedFA(String selFA){
  if (selectedActor instanceof SpriteActor) {
    ActorRenderer s=((SpriteActor)selectedActor).getRenderer();
    if (selFA == null || (s.getAnimations().get(selFA) == null && s.getAnimations().get(AnimationDesc.getFlipId(selFA)) == null)) {
      selFA=((SpriteActor)selectedActor).getRenderer().getInitAnimation();
    }
    if (selFA != null && (s.getAnimations().get(selFA) != null || s.getAnimations().get(AnimationDesc.getFlipId(selFA)) != null)) {
      setAnimationRenderer(selectedActor,s.getAnimations().get(selFA));
      if (inScene || s.getCurrentAnimation() == null || ((SpriteActor)selectedActor).getRenderer().getInitAnimation().equals(selFA)) {
        try {
          ((SpriteActor)selectedActor).startAnimation(selFA,Tween.Type.REPEAT,Tween.INFINITY,null);
        }
 catch (        Exception e) {
          setAnimationRenderer(selectedActor,null);
          ((SpriteActor)selectedActor).getRenderer().getAnimations().remove(selFA);
        }
      }
    }
 else {
      setAnimationRenderer(selectedActor,null);
    }
  }
 else {
    setAnimationRenderer(selectedActor,null);
  }
}",0.9563239308462238
30288,"@Override public void draw(Batch batch,float parentAlpha){
  validate();
  Color tmp=batch.getColor();
  batch.setColor(Color.WHITE);
  batch.disableBlending();
  tile.draw(batch,getX(),getY(),getWidth(),getHeight());
  batch.enableBlending();
  if (scn != null && !loading && !loadingError) {
    Vector3 v=new Vector3(getX(),getY(),0);
    v=v.prj(batch.getTransformMatrix());
    batch.end();
    Gdx.gl.glViewport((int)v.x,(int)v.y,(int)getWidth(),(int)(getHeight()));
    getStage().calculateScissors(bounds,scissors);
    if (ScissorStack.pushScissors(scissors)) {
      sceneBatch.setProjectionMatrix(camera.combined);
      sceneBatch.begin();
      scn.draw(sceneBatch);
      for (      BaseActor a : scn.getActors().values()) {
        if (a instanceof SpriteActor && !a.isVisible()) {
          SpriteActor sa=(SpriteActor)a;
          sa.setVisible(true);
          sa.draw(sceneBatch);
          sa.setVisible(false);
        }
      }
      sceneBatch.end();
      ScissorStack.popScissors();
    }
    drawer.drawBGBounds();
    if (showWalkZone && scn.getPolygonalNavGraph() != null) {
      drawer.drawBBoxWalkZone(scn,false);
      drawer.drawPolygonVertices(scn.getPolygonalNavGraph().getWalkZone(),Color.GREEN);
    }
    drawer.drawBBoxActors(scn);
    if (selectedActor != null) {
      drawer.drawSelectedActor(selectedActor);
    }
    getStage().getViewport().apply();
    batch.begin();
    drawFakeDepthMarkers((SpriteBatch)batch);
    if (!inScene) {
      faRenderer.draw((SpriteBatch)batch);
    }
    Vector2 coords=new Vector2(Gdx.input.getX(),Gdx.input.getY());
    screenToWorldCoords(coords);
    String str=MessageFormat.format(""String_Node_Str"",(int)coords.x,(int)coords.y);
    textLayout.setText(defaultFont,str);
    RectangleRenderer.draw((SpriteBatch)batch,0f,getY() + getHeight() - textLayout.height - 15,textLayout.width + 10,textLayout.height + 10,BLACK_TRANSPARENT);
    defaultFont.draw(batch,textLayout,5,getHeight() + getY() - 10);
    batch.setColor(tmp);
  }
 else {
    RectangleRenderer.draw((SpriteBatch)batch,getX(),getY(),getWidth(),getHeight(),Color.BLACK);
    String s;
    if (loading) {
      s=""String_Node_Str"";
      try {
        if (!EngineAssetManager.getInstance().isLoading()) {
          loading=false;
          scn.retrieveAssets();
          drawer.setCamera(camera);
          invalidate();
        }
      }
 catch (      Exception e) {
        Ctx.msg.show(getStage(),""String_Node_Str"",4);
        e.printStackTrace();
        loadingError=true;
        loading=false;
      }
    }
 else     if (loadingError) {
      s=""String_Node_Str"";
    }
 else     if (Ctx.project.getProjectDir() == null) {
      s=""String_Node_Str"";
    }
 else {
      s=""String_Node_Str"";
    }
    textLayout.setText(bigFont,s);
    bigFont.draw(batch,textLayout,(getWidth() - textLayout.width) / 2,getHeight() / 2 + bigFont.getLineHeight() * 3);
  }
}","@Override public void draw(Batch batch,float parentAlpha){
  validate();
  Color tmp=batch.getColor();
  batch.setColor(Color.WHITE);
  batch.disableBlending();
  tile.draw(batch,getX(),getY(),getWidth(),getHeight());
  batch.enableBlending();
  if (scn != null && !loading && !loadingError) {
    Vector3 v=new Vector3(getX(),getY(),0);
    v=v.prj(batch.getTransformMatrix());
    batch.end();
    Gdx.gl.glViewport((int)v.x,(int)v.y,(int)getWidth(),(int)(getHeight()));
    getStage().calculateScissors(bounds,scissors);
    if (ScissorStack.pushScissors(scissors)) {
      sceneBatch.setProjectionMatrix(camera.combined);
      sceneBatch.begin();
      scn.draw(sceneBatch);
      List<SceneLayer> layers=scn.getLayers();
      for (int i=layers.size() - 1; i >= 0; i--) {
        SceneLayer layer=layers.get(i);
        List<InteractiveActor> actors=layer.getActors();
        for (        BaseActor a : actors) {
          if (a instanceof SpriteActor && !a.isVisible()) {
            a.setVisible(true);
            ((SpriteActor)a).draw(sceneBatch);
            a.setVisible(false);
          }
        }
      }
      sceneBatch.end();
      ScissorStack.popScissors();
    }
    drawer.drawBGBounds();
    if (showWalkZone && scn.getPolygonalNavGraph() != null) {
      drawer.drawBBoxWalkZone(scn,false);
      drawer.drawPolygonVertices(scn.getPolygonalNavGraph().getWalkZone(),Color.GREEN);
    }
    drawer.drawBBoxActors(scn);
    if (selectedActor != null) {
      drawer.drawSelectedActor(selectedActor);
    }
    getStage().getViewport().apply();
    batch.begin();
    drawFakeDepthMarkers((SpriteBatch)batch);
    if (!inScene) {
      faRenderer.draw((SpriteBatch)batch);
    }
    Vector2 coords=new Vector2(Gdx.input.getX(),Gdx.input.getY());
    screenToWorldCoords(coords);
    String str=MessageFormat.format(""String_Node_Str"",(int)coords.x,(int)coords.y);
    textLayout.setText(defaultFont,str);
    RectangleRenderer.draw((SpriteBatch)batch,0f,getY() + getHeight() - textLayout.height - 15,textLayout.width + 10,textLayout.height + 10,BLACK_TRANSPARENT);
    defaultFont.draw(batch,textLayout,5,getHeight() + getY() - 10);
    batch.setColor(tmp);
  }
 else {
    RectangleRenderer.draw((SpriteBatch)batch,getX(),getY(),getWidth(),getHeight(),Color.BLACK);
    String s;
    if (loading) {
      s=""String_Node_Str"";
      try {
        if (!EngineAssetManager.getInstance().isLoading()) {
          loading=false;
          scn.retrieveAssets();
          drawer.setCamera(camera);
          invalidate();
        }
      }
 catch (      Exception e) {
        Ctx.msg.show(getStage(),""String_Node_Str"",4);
        e.printStackTrace();
        loadingError=true;
        loading=false;
      }
    }
 else     if (loadingError) {
      s=""String_Node_Str"";
    }
 else     if (Ctx.project.getProjectDir() == null) {
      s=""String_Node_Str"";
    }
 else {
      s=""String_Node_Str"";
    }
    textLayout.setText(bigFont,s);
    bigFont.draw(batch,textLayout,(getWidth() - textLayout.width) / 2,getHeight() / 2 + bigFont.getLineHeight() * 3);
  }
}",0.9321977287909152
30289,"public void setAnimation(AnimationDesc fa){
  try {
    faRenderer.setAnimation(fa);
  }
 catch (  Exception e) {
    Ctx.msg.show(getStage(),""String_Node_Str"" + fa.id,4);
    e.printStackTrace();
    faRenderer.setAnimation(null);
  }
}","public void setAnimation(boolean v){
  animation=v;
}",0.2482758620689655
30290,"public ScnWidget(Skin skin){
  bigFont=skin.get(""String_Node_Str"",BitmapFont.class);
  defaultFont=skin.get(""String_Node_Str"",BitmapFont.class);
  setSize(150,150);
  tile=new TiledDrawable(Ctx.assetManager.getIcon(""String_Node_Str""));
  faRenderer.setViewport(getWidth(),getHeight());
  setLayoutEnabled(true);
  addListener(inputListner);
  Ctx.project.addPropertyChangeListener(new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent e){
      EditorLogger.debug(""String_Node_Str"" + e.getPropertyName());
      if (e.getPropertyName().equals(Project.NOTIFY_SCENE_SELECTED)) {
        if (!projectLoadedFlag)         setSelectedScene(Ctx.project.getSelectedScene());
      }
 else       if (e.getPropertyName().equals(Project.NOTIFY_ACTOR_SELECTED)) {
        if (!projectLoadedFlag)         setSelectedActor(Ctx.project.getSelectedActor());
      }
 else       if (e.getPropertyName().equals(Project.NOTIFY_ANIM_SELECTED)) {
        if (!projectLoadedFlag)         setSelectedFA(Ctx.project.getSelectedFA());
      }
 else       if (e.getPropertyName().equals(Project.NOTIFY_PROJECT_LOADED)) {
        projectLoadedFlag=true;
      }
 else       if (e.getPropertyName().equals(""String_Node_Str"")) {
        setSelectedScene(Ctx.project.getSelectedScene());
        setSelectedActor(Ctx.project.getSelectedActor());
      }
 else       if (e.getPropertyName().equals(""String_Node_Str"")) {
        if (!inScene)         setSelectedFA(null);
      }
    }
  }
);
  walkZoneWindow=new WalkZoneWindow(skin,inputListner);
}","public ScnWidget(Skin skin){
  bigFont=skin.get(""String_Node_Str"",BitmapFont.class);
  defaultFont=skin.get(""String_Node_Str"",BitmapFont.class);
  setSize(150,150);
  tile=new TiledDrawable(Ctx.assetManager.getIcon(""String_Node_Str""));
  faRenderer.setViewport(getWidth(),getHeight());
  setLayoutEnabled(true);
  addListener(inputListner);
  Ctx.project.addPropertyChangeListener(new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent e){
      EditorLogger.debug(""String_Node_Str"" + e.getPropertyName());
      if (e.getPropertyName().equals(Project.NOTIFY_SCENE_SELECTED)) {
        if (!projectLoadedFlag)         setSelectedScene(Ctx.project.getSelectedScene());
      }
 else       if (e.getPropertyName().equals(Project.NOTIFY_ACTOR_SELECTED)) {
        if (!projectLoadedFlag)         setSelectedActor(Ctx.project.getSelectedActor());
      }
 else       if (e.getPropertyName().equals(Project.NOTIFY_ANIM_SELECTED)) {
        if (!projectLoadedFlag && Ctx.project.getSelectedFA() != null)         setSelectedFA(Ctx.project.getSelectedFA());
      }
 else       if (e.getPropertyName().equals(Project.NOTIFY_PROJECT_LOADED)) {
        projectLoadedFlag=true;
      }
 else       if (e.getPropertyName().equals(""String_Node_Str"")) {
        setSelectedScene(Ctx.project.getSelectedScene());
        setSelectedActor(Ctx.project.getSelectedActor());
      }
 else       if (e.getPropertyName().equals(""String_Node_Str"")) {
        if (!inScene)         setSelectedFA(null);
      }
    }
  }
);
  walkZoneWindow=new WalkZoneWindow(skin,inputListner);
}",0.9876464998416218
30291,"@Override protected void inputsToModel(boolean create){
  if (create) {
    String type=typePanel.getText();
    if (type.equals(BACKGROUND_TYPE_STR)) {
      e=new InteractiveActor();
    }
 else     if (type.equals(SPRITE_TYPE_STR)) {
      e=new SpriteActor();
    }
 else     if (type.equals(CHARACTER_TYPE_STR)) {
      e=new CharacterActor();
    }
 else     if (type.equals(OBSTACLE_TYPE_STR)) {
      e=new ObstacleActor();
    }
 else     if (type.equals(ANCHOR_TYPE_STR)) {
      e=new AnchorActor();
    }
    if (!(e instanceof SpriteActor) && !(e instanceof AnchorActor)) {
      Polygon bbox=e.getBBox();
      bbox.setVertices(new float[8]);
      float[] verts=bbox.getVertices();
      verts[0]=-DEFAULT_DIM / 2;
      verts[1]=0f;
      verts[2]=-DEFAULT_DIM / 2;
      verts[3]=DEFAULT_DIM;
      verts[4]=DEFAULT_DIM / 2;
      verts[5]=DEFAULT_DIM;
      verts[6]=DEFAULT_DIM / 2;
      verts[7]=0f;
      bbox.dirty();
    }
  }
  e.setId(id.getText());
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    ia.setLayer(layer.getText());
    ia.setInteraction(Boolean.parseBoolean(interaction.getText()));
    String key=desc.getText();
    if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX)     key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
    Ctx.project.getI18N().setTranslation(key,desc.getText());
    if (desc.getText() != null)     ia.setDesc(key);
 else     ia.setDesc(null);
    ia.setState(state.getText());
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      String rendererType=renderer.getText();
      if (Project.ATLAS_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof AtlasRenderer))         sa.setRenderer(new AtlasRenderer());
      }
 else       if (Project.IMAGE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ImageRenderer))         sa.setRenderer(new ImageRenderer());
      }
 else       if (Project.S3D_RENDERER_STRING.equals(rendererType)) {
        Sprite3DRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof Sprite3DRenderer)) {
          r=new Sprite3DRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(Sprite3DRenderer)sa.getRenderer();
        }
        r.setCameraFOV(Float.parseFloat(fov.getText()));
        r.setCameraName(cameraName.getText());
        r.setSpriteSize(Param.parseVector2(spriteSize.getText()));
      }
 else       if (Project.SPINE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof SpineRenderer))         sa.setRenderer(new SpineRenderer());
      }
      sa.setBboxFromRenderer(true);
      sa.setDepthType(DepthType.valueOf(depthType.getText()));
      sa.setScale(Float.parseFloat(scale.getText()));
      sa.setZIndex(Float.parseFloat(zIndex.getText()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        ca.setWalkingSpeed(Float.parseFloat(walkingSpeed.getText()));
        ca.setTextColor(Param.parseColor(textColor.getText()));
      }
    }
  }
  if (create) {
    parent.addActor(e);
  }
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  if (create) {
    String type=typePanel.getText();
    if (type.equals(BACKGROUND_TYPE_STR)) {
      e=new InteractiveActor();
    }
 else     if (type.equals(SPRITE_TYPE_STR)) {
      e=new SpriteActor();
    }
 else     if (type.equals(CHARACTER_TYPE_STR)) {
      e=new CharacterActor();
    }
 else     if (type.equals(OBSTACLE_TYPE_STR)) {
      e=new ObstacleActor();
    }
 else     if (type.equals(ANCHOR_TYPE_STR)) {
      e=new AnchorActor();
    }
    if (!(e instanceof SpriteActor) && !(e instanceof AnchorActor)) {
      Polygon bbox=e.getBBox();
      bbox.setVertices(new float[8]);
      float[] verts=bbox.getVertices();
      verts[0]=-DEFAULT_DIM / 2;
      verts[1]=0f;
      verts[2]=-DEFAULT_DIM / 2;
      verts[3]=DEFAULT_DIM;
      verts[4]=DEFAULT_DIM / 2;
      verts[5]=DEFAULT_DIM;
      verts[6]=DEFAULT_DIM / 2;
      verts[7]=0f;
      bbox.dirty();
    }
  }
  e.setId(id.getText());
  e.setVisible(Boolean.parseBoolean(visible.getText()));
  if (e instanceof InteractiveActor) {
    InteractiveActor ia=(InteractiveActor)e;
    ia.setLayer(layer.getText());
    ia.setInteraction(Boolean.parseBoolean(interaction.getText()));
    String key=desc.getText();
    if (key == null || key.isEmpty() || key.charAt(0) != I18N.PREFIX)     key=Ctx.project.getI18N().genKey(parent.getId(),e.getId(),""String_Node_Str"");
    Ctx.project.getI18N().setTranslation(key,desc.getText());
    if (desc.getText() != null)     ia.setDesc(key);
 else     ia.setDesc(null);
    ia.setState(state.getText());
    if (e instanceof SpriteActor) {
      SpriteActor sa=(SpriteActor)e;
      String rendererType=renderer.getText();
      if (Project.ATLAS_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof AtlasRenderer))         sa.setRenderer(new AtlasRenderer());
      }
 else       if (Project.IMAGE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof ImageRenderer))         sa.setRenderer(new ImageRenderer());
      }
 else       if (Project.S3D_RENDERER_STRING.equals(rendererType)) {
        Sprite3DRenderer r;
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof Sprite3DRenderer)) {
          r=new Sprite3DRenderer();
          sa.setRenderer(r);
        }
 else {
          r=(Sprite3DRenderer)sa.getRenderer();
        }
        r.setCameraFOV(Float.parseFloat(fov.getText()));
        r.setCameraName(cameraName.getText());
        r.setSpriteSize(Param.parseVector2(spriteSize.getText()));
      }
 else       if (Project.SPINE_RENDERER_STRING.equals(rendererType)) {
        if (sa.getRenderer() == null || !(sa.getRenderer() instanceof SpineRenderer))         sa.setRenderer(new SpineRenderer());
      }
      sa.setBboxFromRenderer(true);
      sa.setDepthType(DepthType.valueOf(depthType.getText()));
      sa.setScale(Float.parseFloat(scale.getText()));
      sa.setZIndex(Float.parseFloat(zIndex.getText()));
      if (e instanceof CharacterActor) {
        CharacterActor ca=(CharacterActor)e;
        ca.setWalkingSpeed(Float.parseFloat(walkingSpeed.getText()));
        ca.setTextColor(Param.parseColor(textColor.getText()));
      }
    }
  }
  if (!create) {
    parent.removeActor(e);
  }
  parent.addActor(e);
  if (e instanceof InteractiveActor) {
    SceneLayer l=parent.getLayer(((InteractiveActor)e).getLayer());
    l.orderByZIndex();
  }
  if (e instanceof SpriteActor)   ((SpriteActor)e).retrieveAssets();
  Ctx.project.setModified();
}",0.966055178390871
30292,"@SuppressWarnings(""String_Node_Str"") public EditAnimationDialog(Skin skin,SpriteActor p,AnimationDesc e){
  super(skin);
  setInfo(INFO);
  source=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0],true);
  atlas=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",getAtlases(),true);
  id=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0],true);
  repeat=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.OPTION,true,Tween.Type.NO_REPEAT.toString(),Tween.Type.class.getEnumConstants());
  speed=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,true,""String_Node_Str"");
  delay=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,false);
  count=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.INTEGER,false);
  in=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  out=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  sound=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  preload=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"");
  dispose=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"");
  ((SelectBox<String>)repeat.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      String type=repeat.getText();
      if (type.equals(Tween.Type.REPEAT.toString()) || type.equals(Tween.Type.YOYO.toString())) {
        setVisible(delay,true);
        setVisible(count,true);
      }
 else {
        setVisible(delay,false);
        setVisible(count,false);
      }
    }
  }
);
  ((SelectBox<String>)source.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      EditorLogger.debug(""String_Node_Str"" + source.getText());
      setSource();
      fillAnimations();
    }
  }
);
  ((SelectBox<String>)id.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setAnimation();
    }
  }
);
  ((SelectBox<String>)atlas.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setSource();
      fillAnimations();
    }
  }
);
  ((TextField)speed.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setAnimation();
    }
  }
);
  setInfoWidget(spriteWidget);
  init(p,e,new InputPanel[]{source,atlas,id,repeat,speed,delay,count,in,out,sound,preload,dispose});
  setVisible(delay,false);
  setVisible(count,false);
  setVisible(atlas,false);
  addSources();
  if (e != null) {
    source.setText(e.source);
  }
  if (source.getText() != null && !source.getText().isEmpty()) {
    setSource();
    fillAnimations();
    if (e != null) {
      id.setText(e.id);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public EditAnimationDialog(Skin skin,SpriteActor p,AnimationDesc e){
  super(skin);
  setInfo(INFO);
  source=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0],true);
  atlas=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",getAtlases(),true);
  id=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0],true);
  repeat=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.OPTION,true,Tween.Type.NO_REPEAT.toString(),Tween.Type.class.getEnumConstants());
  speed=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,true,""String_Node_Str"");
  delay=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,true,""String_Node_Str"");
  count=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.INTEGER,true,""String_Node_Str"");
  in=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  out=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  sound=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  preload=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"");
  dispose=InputPanelFactory.createInputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"");
  ((SelectBox<String>)repeat.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      showHideFieldsDelayCountFields();
    }
  }
);
  ((SelectBox<String>)source.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      EditorLogger.debug(""String_Node_Str"" + source.getText());
      setSource();
      fillAnimations();
    }
  }
);
  ((SelectBox<String>)id.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setAnimation();
    }
  }
);
  ((SelectBox<String>)atlas.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setSource();
      fillAnimations();
    }
  }
);
  ((TextField)speed.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setAnimation();
    }
  }
);
  setInfoWidget(spriteWidget);
  init(p,e,new InputPanel[]{source,atlas,id,repeat,speed,delay,count,in,out,sound,preload,dispose});
  setVisible(delay,false);
  setVisible(count,false);
  setVisible(atlas,false);
  addSources();
  if (e != null) {
    source.setText(e.source);
  }
  if (source.getText() != null && !source.getText().isEmpty()) {
    setSource();
    fillAnimations();
    if (e != null) {
      id.setText(e.id);
    }
  }
}",0.941904761904762
30293,"@Override protected void inputsToModel(boolean create){
  String sourceStr=source.getText();
  if (create) {
    ActorRenderer renderer=parent.getRenderer();
    if (renderer instanceof SpineRenderer) {
      e=new SpineAnimationDesc();
      if (spineAtlasExists(sourceStr)) {
        ((SpineAnimationDesc)e).atlas=null;
        setVisible(atlas,false);
      }
 else {
        if (!atlas.isVisible()) {
          setVisible(atlas,true);
        }
        ((SpineAnimationDesc)e).atlas=atlas.getText();
      }
    }
 else     if (renderer instanceof AtlasRenderer) {
      e=new AtlasAnimationDesc();
    }
 else {
      e=new AnimationDesc();
    }
  }
  e.id=id.getText();
  e.sound=sound.getText();
  e.source=sourceStr;
  e.count=Integer.parseInt(count.getText());
  e.preload=Boolean.parseBoolean(preload.getText());
  e.disposeWhenPlayed=Boolean.parseBoolean(dispose.getText());
  e.animationType=Type.valueOf(repeat.getText());
  e.inD=Param.parseVector2(in.getText());
  e.outD=Param.parseVector2(out.getText());
  e.duration=Float.parseFloat(speed.getText());
  if (delay.getText() == null || delay.getText().isEmpty())   e.delay=Float.parseFloat(delay.getText());
  if (create) {
    parent.getRenderer().getAnimations().put(e.id,e);
  }
  Ctx.project.setModified();
}","@Override protected void inputsToModel(boolean create){
  String sourceStr=source.getText();
  if (create) {
    ActorRenderer renderer=parent.getRenderer();
    if (renderer instanceof SpineRenderer) {
      e=new SpineAnimationDesc();
      if (spineAtlasExists(sourceStr)) {
        ((SpineAnimationDesc)e).atlas=null;
        setVisible(atlas,false);
      }
 else {
        if (!atlas.isVisible()) {
          setVisible(atlas,true);
        }
        ((SpineAnimationDesc)e).atlas=atlas.getText();
      }
    }
 else     if (renderer instanceof AtlasRenderer) {
      e=new AtlasAnimationDesc();
    }
 else {
      e=new AnimationDesc();
    }
  }
  e.id=id.getText();
  e.sound=sound.getText();
  e.source=sourceStr;
  e.count=Integer.parseInt(count.getText());
  e.preload=Boolean.parseBoolean(preload.getText());
  e.disposeWhenPlayed=Boolean.parseBoolean(dispose.getText());
  e.animationType=Type.valueOf(repeat.getText());
  e.inD=Param.parseVector2(in.getText());
  e.outD=Param.parseVector2(out.getText());
  e.duration=Float.parseFloat(speed.getText());
  if (delay.getText() == null || delay.getText().isEmpty())   e.delay=Float.parseFloat(delay.getText());
  if (create) {
    parent.getRenderer().addAnimation(e);
  }
  Ctx.project.setModified();
}",0.9921507064364208
30294,"@Override protected void modelToInputs(){
  source.setText(e.source);
  if (atlas.isVisible() && e instanceof SpineAnimationDesc)   atlas.setText(((SpineAnimationDesc)e).atlas);
  id.setText(e.id);
  repeat.setText(e.animationType.toString());
  speed.setText(Float.toString(e.duration));
  delay.setText(Float.toString(e.delay));
  count.setText(Integer.toString(e.count));
  in.setText(Param.toStringParam(e.inD));
  out.setText(Param.toStringParam(e.outD));
  sound.setText(e.sound);
  preload.setText(Boolean.toString(e.preload));
  dispose.setText(Boolean.toString(e.disposeWhenPlayed));
}","@Override protected void modelToInputs(){
  source.setText(e.source);
  if (atlas.isVisible() && e instanceof SpineAnimationDesc)   atlas.setText(((SpineAnimationDesc)e).atlas);
  id.setText(e.id);
  repeat.setText(e.animationType.toString());
  speed.setText(Float.toString(e.duration));
  delay.setText(Float.toString(e.delay));
  count.setText(Integer.toString(e.count));
  in.setText(Param.toStringParam(e.inD));
  out.setText(Param.toStringParam(e.outD));
  sound.setText(e.sound);
  preload.setText(Boolean.toString(e.preload));
  dispose.setText(Boolean.toString(e.disposeWhenPlayed));
  showHideFieldsDelayCountFields();
}",0.9705882352941176
30295,"protected void init(PARENT parent,T e,InputPanel[] inputs){
  this.e=e;
  this.parent=parent;
  this.i=inputs;
  getCenterPanel().clear();
  for (  InputPanel i : inputs) {
    addInputPanel(i);
  }
  if (e == null) {
    setTitle(""String_Node_Str"");
  }
 else {
    setTitle(""String_Node_Str"" + e.getClass().getSimpleName());
    modelToInputs();
  }
}","protected void init(PARENT parent,T e,InputPanel[] inputs){
  this.e=e;
  this.parent=parent;
  this.i=inputs;
  getCenterPanel().clear();
  for (  InputPanel i : inputs) {
    addInputPanel(i);
  }
  if (e == null) {
    setTitle(""String_Node_Str"");
  }
 else {
    setTitle(""String_Node_Str"" + e.getClass().getSimpleName());
    try {
      modelToInputs();
    }
 catch (    Exception e1) {
      Ctx.msg.show(getStage(),""String_Node_Str"" + e1.getMessage(),4);
    }
  }
}",0.8454106280193237
30296,"@Override protected void ok(){
  inputsToModel(e == null);
  if (listener != null)   listener.changed(new ChangeEvent(),this);
}","@Override protected void ok(){
  try {
    inputsToModel(e == null);
  }
 catch (  Exception e1) {
    Ctx.msg.show(getStage(),""String_Node_Str"" + e1.getMessage(),4);
  }
  if (listener != null)   listener.changed(new ChangeEvent(),this);
}",0.6956521739130435
30297,"/** 
 * Execute the action
 * @param cb
 * @return If 'true', the verb must stops the execution and waitfor the action to call the cb.resume()
 */
public boolean run(ActionCallback cb);","/** 
 * Execute the action
 * @param cb
 * @return If 'true', the verb must stops the execution and waitfor the action to call the cb.resume()
 */
public boolean run(VerbRunner cb);",0.9398907103825136
30298,"@Override public boolean run(ActionCallback cb){
  EngineLogger.debug(MessageFormat.format(""String_Node_Str"",animation.getAnimationId()));
  String actorId=animation.getActorId();
  SpriteActor a=(SpriteActor)World.getInstance().getCurrentScene().getActor(actorId,true);
  a.startAnimation(animation.getAnimationId(),repeat,count,wait ? cb : null);
  return wait;
}","@Override public boolean run(VerbRunner cb){
  EngineLogger.debug(MessageFormat.format(""String_Node_Str"",animation.getAnimationId()));
  String actorId=animation.getActorId();
  SpriteActor a=(SpriteActor)World.getInstance().getCurrentScene().getActor(actorId,true);
  a.startAnimation(animation.getAnimationId(),repeat,count,wait ? cb : null);
  return wait;
}",0.9669421487603306
30299,"@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  SceneCamera camera=World.getInstance().getSceneCamera();
  if (zoom == -1)   zoom=camera.getZoom();
  if (pos == null) {
    pos=camera.getPosition();
    pos.x/=scale;
    pos.y/=scale;
  }
  if (followActor != null) {
    if (followActor.equals(""String_Node_Str""))     World.getInstance().getCurrentScene().setCameraFollowActor(null);
 else     camera.updatePos((SpriteActor)World.getInstance().getCurrentScene().getActor(followActor,false));
  }
  if (duration == 0) {
    camera.setZoom(zoom);
    camera.setPosition(pos.x * scale,pos.y * scale);
    return false;
  }
 else {
    camera.startAnimation(pos.x * scale,pos.y * scale,zoom,duration,wait ? cb : null);
  }
  return wait;
}","@Override public boolean run(VerbRunner cb){
  float scale=EngineAssetManager.getInstance().getScale();
  SceneCamera camera=World.getInstance().getSceneCamera();
  if (zoom == -1)   zoom=camera.getZoom();
  if (pos == null) {
    pos=camera.getPosition();
    pos.x/=scale;
    pos.y/=scale;
  }
  if (followActor != null) {
    if (followActor.equals(""String_Node_Str""))     World.getInstance().getCurrentScene().setCameraFollowActor(null);
 else     camera.updatePos((SpriteActor)World.getInstance().getCurrentScene().getActor(followActor,false));
  }
  if (duration == 0) {
    camera.setZoom(zoom);
    camera.setPosition(pos.x * scale,pos.y * scale);
    return false;
  }
 else {
    camera.startAnimation(pos.x * scale,pos.y * scale,zoom,duration,wait ? cb : null);
  }
  return wait;
}",0.9861809045226132
30300,"@Override public boolean run(ActionCallback cb){
  VerbRunner v=null;
  if (verb == null) {
    v=(VerbRunner)cb;
  }
  if (v == null && actor != null) {
    BaseActor a=World.getInstance().getCurrentScene().getActor(actor,true);
    v=((InteractiveActor)a).getVerb(verb,target);
  }
  if (v == null) {
    v=World.getInstance().getCurrentScene().getVerb(verb);
  }
  if (v == null) {
    v=World.getInstance().getVerbManager().getVerb(verb,null,null);
  }
  if (v != null)   v.cancel();
 else   EngineLogger.error(""String_Node_Str"" + verb + ""String_Node_Str""+ actor);
  return false;
}","@Override public boolean run(VerbRunner cb){
  VerbRunner v=null;
  if (verb == null) {
    v=(VerbRunner)cb;
  }
  if (v == null && actor != null) {
    BaseActor a=World.getInstance().getCurrentScene().getActor(actor,true);
    v=((InteractiveActor)a).getVerb(verb,target);
  }
  if (v == null) {
    v=World.getInstance().getCurrentScene().getVerb(verb);
  }
  if (v == null) {
    v=World.getInstance().getVerbManager().getVerb(verb,null,null);
  }
  if (v != null)   v.cancel();
 else   EngineLogger.error(""String_Node_Str"" + verb + ""String_Node_Str""+ actor);
  return false;
}",0.9794520547945206
30301,"@Override public boolean run(ActionCallback cb){
  VerbRunner v=(VerbRunner)cb;
  int startIp=v.getIP();
  int ip0=startIp + 1;
  final List<Action> actions=v.getActions();
  int ip=skipControlIdBlock(actions,startIp);
  int numActions=ip - startIp - 1;
  if (numActions <= 0)   return false;
switch (chooseCriteria) {
case ITERATE:
    chooseCount++;
  break;
case RANDOM:
chooseCount=MathUtils.random(0,numActions - 1);
break;
case CYCLE:
chooseCount=(chooseCount + 1) % numActions;
break;
}
v.setIP(ip);
if (chooseCount < numActions) {
return actions.get(ip0 + chooseCount).run(v);
}
return false;
}","@Override public boolean run(VerbRunner cb){
  VerbRunner v=(VerbRunner)cb;
  int startIp=v.getIP();
  int ip0=startIp + 1;
  final List<Action> actions=v.getActions();
  int ip=skipControlIdBlock(actions,startIp);
  int numActions=ip - startIp - 1;
  if (numActions <= 0)   return false;
switch (chooseCriteria) {
case ITERATE:
    chooseCount++;
  break;
case RANDOM:
chooseCount=MathUtils.random(0,numActions - 1);
break;
case CYCLE:
chooseCount=(chooseCount + 1) % numActions;
break;
}
v.setIP(ip);
if (chooseCount < numActions) {
return actions.get(ip0 + chooseCount).run(v);
}
return false;
}",0.98
30302,"@Override public boolean run(ActionCallback cb){
  return false;
}","@Override public boolean run(VerbRunner cb){
  return false;
}",0.828125
30303,"@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getInventory().getItem(this.actor);
  if (actor == null) {
    EngineLogger.error(MessageFormat.format(""String_Node_Str"",this.actor));
    return false;
  }
  World.getInstance().getInventory().removeItem(this.actor);
  World.getInstance().getCurrentScene().addActor(actor);
  if (pos != null)   actor.setPosition(pos.x * scale,pos.y * scale);
  return false;
}","@Override public boolean run(VerbRunner cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getInventory().getItem(this.actor);
  if (actor == null) {
    EngineLogger.error(MessageFormat.format(""String_Node_Str"",this.actor));
    return false;
  }
  World.getInstance().getInventory().removeItem(this.actor);
  World.getInstance().getCurrentScene().addActor(actor);
  if (pos != null)   actor.setPosition(pos.x * scale,pos.y * scale);
  return false;
}",0.9782178217821782
30304,"@Override public boolean run(ActionCallback cb){
  final VerbRunner v=(VerbRunner)cb;
  final List<Action> actions=v.getActions();
  final int ip=v.getIP();
  final int parentIp=getParentControlAction(caID,actions,ip);
  final AbstractControlAction parent=(AbstractControlAction)actions.get(parentIp);
  if (parent instanceof RepeatAction) {
    v.setIP(parentIp - 1);
  }
 else   if (parent instanceof AbstractIfAction) {
    int newIp=skipControlIdBlock(actions,parentIp);
    newIp=skipControlIdBlock(actions,newIp);
    v.setIP(newIp);
  }
  return false;
}","@Override public boolean run(VerbRunner cb){
  final VerbRunner v=(VerbRunner)cb;
  final List<Action> actions=v.getActions();
  final int ip=v.getIP();
  final int parentIp=getParentControlAction(caID,actions,ip);
  final AbstractControlAction parent=(AbstractControlAction)actions.get(parentIp);
  if (parent instanceof RepeatAction) {
    v.setIP(parentIp - 1);
  }
 else   if (parent instanceof AbstractIfAction) {
    int newIp=skipControlIdBlock(actions,parentIp);
    newIp=skipControlIdBlock(actions,newIp);
    v.setIP(newIp);
  }
  return false;
}",0.9785330948121646
30305,"@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getCurrentScene().getActor(actorId,false);
  if (speed == 0 || !(actor instanceof SpriteActor)) {
    actor.setPosition(pos.x * scale,pos.y * scale);
    return false;
  }
 else {
    float s;
    if (mode != null && mode == Mode.SPEED) {
      Vector2 p0=new Vector2(actor.getX(),actor.getY());
      s=p0.dst(pos.x * scale,pos.y * scale) / (scale * speed);
    }
 else {
      s=speed;
    }
    ((SpriteActor)actor).startPosAnimation(repeat,count,s,pos.x * scale,pos.y * scale,interpolation,wait ? cb : null);
  }
  return wait;
}","@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getCurrentScene().getActor(actorId,false);
  if (speed == 0 || !(actor instanceof SpriteActor)) {
    if (target == null) {
      actor.setPosition(pos.x * scale,pos.y * scale);
    }
 else {
      BaseActor target=World.getInstance().getCurrentScene().getActor(this.target,false);
      actor.setPosition(target.getX(),target.getY());
    }
    return false;
  }
 else {
    float s;
    if (mode != null && mode == Mode.SPEED) {
      Vector2 p0=new Vector2(actor.getX(),actor.getY());
      s=p0.dst(pos.x * scale,pos.y * scale) / (scale * speed);
    }
 else {
      s=speed;
    }
    if (target == null) {
      ((SpriteActor)actor).startPosAnimation(repeat,count,s,pos.x * scale,pos.y * scale,interpolation,wait ? cb : null);
    }
 else {
      BaseActor target=World.getInstance().getCurrentScene().getActor(this.target,false);
      ((SpriteActor)actor).startPosAnimation(repeat,count,s,target.getX(),target.getY(),interpolation,wait ? cb : null);
    }
  }
  return wait;
}",0.7396351575456053
30306,"@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getCurrentScene().getActor(actorId,false);
  if (speed == 0 || !(actor instanceof SpriteActor)) {
    actor.setPosition(pos.x * scale,pos.y * scale);
    return false;
  }
 else {
    float s;
    if (mode != null && mode == Mode.SPEED) {
      Vector2 p0=new Vector2(actor.getX(),actor.getY());
      s=p0.dst(pos.x * scale,pos.y * scale) / (scale * speed);
    }
 else {
      s=speed;
    }
    ((SpriteActor)actor).startPosAnimation(repeat,count,s,pos.x * scale,pos.y * scale,interpolation,wait ? cb : null);
  }
  return wait;
}","@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getCurrentScene().getActor(actorId,false);
  if (speed == 0 || !(actor instanceof SpriteActor)) {
    if (target == null) {
      actor.setPosition(pos.x * scale,pos.y * scale);
    }
 else {
      BaseActor target=World.getInstance().getCurrentScene().getActor(this.target,false);
      actor.setPosition(target.getX(),target.getY());
    }
    return false;
  }
 else {
    float s;
    if (mode != null && mode == Mode.SPEED) {
      Vector2 p0=new Vector2(actor.getX(),actor.getY());
      s=p0.dst(pos.x * scale,pos.y * scale) / (scale * speed);
    }
 else {
      s=speed;
    }
    if (target == null) {
      ((SpriteActor)actor).startPosAnimation(repeat,count,s,pos.x * scale,pos.y * scale,interpolation,wait ? cb : null);
    }
 else {
      BaseActor target=World.getInstance().getCurrentScene().getActor(this.target,false);
      actor.setPosition(target.getX(),target.getY());
    }
  }
  return wait;
}",0.7795637198622273
30307,"@Override public boolean run(ActionCallback cb){
  VerbRunner v=(VerbRunner)cb;
  int startIp=v.getIP();
  int ip0=startIp + 1;
  final List<Action> actions=v.getActions();
  int ip=skipControlIdBlock(actions,startIp);
  int numActions=ip - startIp;
  if (numActions <= 0)   return false;
switch (chooseCriteria) {
case ITERATE:
    chooseCount++;
  break;
case RANDOM:
chooseCount=MathUtils.random(0,numActions - 1);
break;
case CYCLE:
chooseCount=(chooseCount + 1) % numActions;
break;
}
v.setIP(ip);
if (chooseCount < numActions) {
return actions.get(ip0 + chooseCount).run(v);
}
return false;
}","@Override public boolean run(ActionCallback cb){
  VerbRunner v=(VerbRunner)cb;
  int startIp=v.getIP();
  int ip0=startIp + 1;
  final List<Action> actions=v.getActions();
  int ip=skipControlIdBlock(actions,startIp);
  int numActions=ip - startIp - 1;
  if (numActions <= 0)   return false;
switch (chooseCriteria) {
case ITERATE:
    chooseCount++;
  break;
case RANDOM:
chooseCount=MathUtils.random(0,numActions - 1);
break;
case CYCLE:
chooseCount=(chooseCount + 1) % numActions;
break;
}
v.setIP(ip);
if (chooseCount < numActions) {
return actions.get(ip0 + chooseCount).run(v);
}
return false;
}",0.9966666666666668
30308,"@Override protected void updateModel(String property,String value){
  if (property.equals(DESC_PROP)) {
    doc.setRootAttr(actor,""String_Node_Str"",value);
  }
 else   if (property.equals(POS_X_PROP)) {
    Vector2 pos=doc.getPos(actor);
    UndoOp undoOp=new UndoSetAttr(Ctx.project.getSelectedChapter(),Ctx.project.getSelectedActor(),""String_Node_Str"",Param.toStringParam(pos));
    Ctx.project.getUndoStack().add(undoOp);
    try {
      pos.x=Float.parseFloat(value);
    }
 catch (    NumberFormatException e) {
    }
    doc.setPos(actor,pos);
  }
 else   if (property.equals(POS_Y_PROP)) {
    Vector2 pos=doc.getPos(actor);
    UndoOp undoOp=new UndoSetAttr(Ctx.project.getSelectedChapter(),Ctx.project.getSelectedActor(),""String_Node_Str"",Param.toStringParam(pos));
    Ctx.project.getUndoStack().add(undoOp);
    try {
      pos.y=Float.parseFloat(value);
    }
 catch (    NumberFormatException e) {
    }
    doc.setPos(actor,pos);
  }
 else   if (property.equals(VISIBLE_PROP)) {
    doc.setRootAttr(actor,XMLConstants.VISIBLE_ATTR,value);
  }
 else   if (property.equals(ACTIVE_PROP)) {
    doc.setRootAttr(actor,""String_Node_Str"",value);
  }
 else   if (property.equals(STATE_PROP)) {
    doc.setRootAttr(actor,""String_Node_Str"",value);
  }
}","@Override protected void updateModel(String property,String value){
  if (property.equals(DESC_PROP)) {
    doc.setRootAttr(actor,XMLConstants.DESC_ATTR,value);
  }
 else   if (property.equals(POS_X_PROP)) {
    Vector2 pos=doc.getPos(actor);
    UndoOp undoOp=new UndoSetAttr(Ctx.project.getSelectedChapter(),Ctx.project.getSelectedActor(),XMLConstants.POS_ATTR,Param.toStringParam(pos));
    Ctx.project.getUndoStack().add(undoOp);
    try {
      pos.x=Float.parseFloat(value);
    }
 catch (    NumberFormatException e) {
    }
    doc.setPos(actor,pos);
  }
 else   if (property.equals(POS_Y_PROP)) {
    Vector2 pos=doc.getPos(actor);
    UndoOp undoOp=new UndoSetAttr(Ctx.project.getSelectedChapter(),Ctx.project.getSelectedActor(),XMLConstants.POS_ATTR,Param.toStringParam(pos));
    Ctx.project.getUndoStack().add(undoOp);
    try {
      pos.y=Float.parseFloat(value);
    }
 catch (    NumberFormatException e) {
    }
    doc.setPos(actor,pos);
  }
 else   if (property.equals(VISIBLE_PROP)) {
    doc.setRootAttr(actor,XMLConstants.VISIBLE_ATTR,value);
  }
 else   if (property.equals(INTERACTION_PROP)) {
    doc.setRootAttr(actor,XMLConstants.INTERACTION_ATTR,value);
  }
 else   if (property.equals(STATE_PROP)) {
    doc.setRootAttr(actor,XMLConstants.STATE_ATTR,value);
  }
 else   if (property.equals(BBOX_FROM_RENDERER_PROP)) {
    boolean v=true;
    try {
      v=Boolean.parseBoolean(value);
    }
 catch (    ParseException e) {
    }
    if (v)     doc.setBbox(actor,null);
 else     doc.setRootAttr(actor,XMLConstants.BBOX_ATTR,null);
  }
}",0.6907545164718385
30309,"public void setActorDocument(ChapterDocument doc,Element a){
  this.doc=doc;
  this.actor=a;
  clearProps();
  if (a != null) {
    Vector2 pos=doc.getPos(a);
    addProperty(POS_X_PROP,Float.toString(pos.x),Types.FLOAT);
    addProperty(POS_Y_PROP,Float.toString(pos.y),Types.FLOAT);
    addProperty(VISIBLE_PROP,doc.getRootAttr(a,XMLConstants.VISIBLE_ATTR),Types.BOOLEAN);
    if (!a.getAttribute(XMLConstants.TYPE_ATTR).equals(XMLConstants.OBSTACLE_VALUE)) {
      addProperty(DESC_PROP,doc.getRootAttr(a,""String_Node_Str""));
      addProperty(ACTIVE_PROP,doc.getRootAttr(a,""String_Node_Str""),Types.BOOLEAN);
      addProperty(STATE_PROP,doc.getRootAttr(a,""String_Node_Str""));
    }
    doc.addPropertyChangeListener(propertyChangeListener);
    invalidateHierarchy();
  }
}","public void setActorDocument(ChapterDocument doc,Element a){
  this.doc=doc;
  this.actor=a;
  clearProps();
  if (a != null) {
    Vector2 pos=doc.getPos(a);
    addProperty(POS_X_PROP,Float.toString(pos.x),Types.FLOAT);
    addProperty(POS_Y_PROP,Float.toString(pos.y),Types.FLOAT);
    addProperty(VISIBLE_PROP,doc.getRootAttr(a,XMLConstants.VISIBLE_ATTR),Types.BOOLEAN);
    if (!a.getAttribute(XMLConstants.TYPE_ATTR).equals(XMLConstants.OBSTACLE_VALUE)) {
      addProperty(DESC_PROP,doc.getRootAttr(a,XMLConstants.DESC_ATTR));
      addProperty(INTERACTION_PROP,doc.getRootAttr(a,XMLConstants.INTERACTION_ATTR),Types.BOOLEAN);
      addProperty(STATE_PROP,doc.getRootAttr(a,XMLConstants.STATE_ATTR));
    }
    if (a.getAttribute(XMLConstants.TYPE_ATTR).equals(XMLConstants.SPRITE_VALUE)) {
      boolean v=doc.getRootAttr(a,XMLConstants.BBOX_ATTR) == null;
      addProperty(BBOX_FROM_RENDERER_PROP,Boolean.toString(v),Types.BOOLEAN);
    }
    doc.addPropertyChangeListener(propertyChangeListener);
    invalidateHierarchy();
  }
}",0.6846450192625206
30310,"@Override public void propertyChange(PropertyChangeEvent evt){
  EditorLogger.debug(""String_Node_Str"" + evt.getPropertyName());
  setActorDocument(doc,actor);
}","@Override public void propertyChange(PropertyChangeEvent evt){
  EditorLogger.debug(""String_Node_Str"" + evt.getPropertyName());
  updateField(evt.getPropertyName());
}",0.8562691131498471
30311,"public void setSceneDocument(ChapterDocument doc,Element scn){
  this.scn=scn;
  this.doc=doc;
  clearProps();
  if (scn != null) {
    addProperty(MUSIC_PROP,doc.getMusic(scn));
    addProperty(LOOP_MUSIC_PROP,doc.getRootAttr(scn,""String_Node_Str""),Types.BOOLEAN);
    addProperty(INITIAL_MUSIC_DELAY_PROP,doc.getRootAttr(scn,""String_Node_Str""),Types.FLOAT);
    addProperty(REPEAT_MUSIC_DELAY_PROP,doc.getRootAttr(scn,""String_Node_Str""),Types.FLOAT);
    this.doc.addPropertyChangeListener(""String_Node_Str"",propertyChangeListener);
    invalidateHierarchy();
  }
}","public void setSceneDocument(ChapterDocument doc,Element scn){
  this.scn=scn;
  this.doc=doc;
  clearProps();
  if (scn != null) {
    addProperty(MUSIC_PROP,doc.getMusic(scn));
    addProperty(LOOP_MUSIC_PROP,doc.getRootAttr(scn,XMLConstants.LOOP_MUSIC_ATTR),Types.BOOLEAN);
    addProperty(INITIAL_MUSIC_DELAY_PROP,doc.getRootAttr(scn,XMLConstants.INITIAL_MUSIC_DELAY_ATTR),Types.FLOAT);
    addProperty(REPEAT_MUSIC_DELAY_PROP,doc.getRootAttr(scn,XMLConstants.REPEAT_MUSIC_DELAY_ATTR),Types.FLOAT);
    this.doc.addPropertyChangeListener(""String_Node_Str"",propertyChangeListener);
    invalidateHierarchy();
  }
}",0.4408783783783784
30312,"@Override protected void updateModel(String property,String value){
  if (property.equals(MUSIC_PROP)) {
    doc.setRootAttr(scn,""String_Node_Str"",value);
  }
 else   if (property.equals(LOOP_MUSIC_PROP)) {
    doc.setRootAttr(scn,""String_Node_Str"",value);
  }
 else   if (property.equals(INITIAL_MUSIC_DELAY_PROP)) {
    doc.setRootAttr(scn,""String_Node_Str"",value);
  }
 else   if (property.equals(REPEAT_MUSIC_DELAY_PROP)) {
    doc.setRootAttr(scn,""String_Node_Str"",value);
  }
}","@Override protected void updateModel(String property,String value){
  if (property.equals(MUSIC_PROP)) {
    doc.setRootAttr(scn,""String_Node_Str"",value);
  }
 else   if (property.equals(LOOP_MUSIC_PROP)) {
    doc.setRootAttr(scn,XMLConstants.LOOP_MUSIC_ATTR,value);
  }
 else   if (property.equals(INITIAL_MUSIC_DELAY_PROP)) {
    doc.setRootAttr(scn,XMLConstants.INITIAL_MUSIC_DELAY_ATTR,value);
  }
 else   if (property.equals(REPEAT_MUSIC_DELAY_PROP)) {
    doc.setRootAttr(scn,XMLConstants.REPEAT_MUSIC_DELAY_ATTR,value);
  }
}",0.655511811023622
30313,"@Override public void keyTyped(TextField actor,char c){
  updateModel(actor.getName(),((TextField)actor).getText());
}","@Override public void keyTyped(TextField actor,char c){
}",0.6514285714285715
30314,"private void typeChanged(){
  int i=((OptionsInputPanel)typePanel).getSelectedIndex();
  setInfo(TYPES_INFO[i]);
  hideAllInputs();
  if (!ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.OBSTACLE_VALUE)) {
    setVisible(inputs[4],true);
    setVisible(inputs[5],true);
    setVisible(inputs[6],true);
  }
  if (ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.SPRITE_VALUE) || ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.CHARACTER_VALUE)) {
    setVisible(inputs[7],true);
    setVisible(inputs[8],true);
    setVisible(inputs[9],true);
    setVisible(inputs[10],true);
  }
  if (ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.CHARACTER_VALUE)) {
    setVisible(inputs[11],true);
  }
  rendererChanged();
}","private void typeChanged(){
  int i=((OptionsInputPanel)typePanel).getSelectedIndex();
  setInfo(TYPES_INFO[i]);
  hideAllInputs();
  if (!ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.OBSTACLE_VALUE)) {
    setVisible(inputs[4],true);
    setVisible(inputs[5],true);
    setVisible(inputs[6],true);
    setVisible(inputs[10],true);
  }
  if (ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.SPRITE_VALUE) || ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.CHARACTER_VALUE)) {
    setVisible(inputs[7],true);
    setVisible(inputs[8],true);
    setVisible(inputs[9],true);
  }
  if (ChapterDocument.ACTOR_TYPES[i].equals(XMLConstants.CHARACTER_VALUE)) {
    setVisible(inputs[11],true);
  }
  rendererChanged();
}",0.9543568464730292
30315,"@Override public void update(int screenWidth,int screenHeight,boolean centerCamera){
  super.setWorldSize(minWorldWidth,minWorldHeight);
  Vector2 scaled=Scaling.fit.apply(getWorldWidth(),getWorldHeight(),screenWidth,screenHeight);
  setScreenWidth(Math.round(scaled.x));
  setScreenHeight(Math.round(scaled.y));
  if (getScreenWidth() < screenWidth) {
    float toViewportSpace=getScreenHeight() / getWorldHeight();
    float toWorldSpace=getWorldHeight() / getScreenHeight();
    float lengthen=(screenWidth - getScreenWidth()) * toWorldSpace;
    if (maxWorldWidth > 0)     lengthen=Math.min(lengthen,maxWorldWidth - minWorldWidth);
    setWorldWidth(getWorldWidth() + lengthen);
    setScreenWidth(getScreenWidth() + Math.round(lengthen * toViewportSpace));
  }
 else   if (getScreenHeight() < screenHeight) {
    float toViewportSpace=getScreenWidth() / getWorldWidth();
    float toWorldSpace=getWorldWidth() / getScreenWidth();
    float lengthen=(screenHeight - getScreenHeight()) * toWorldSpace;
    if (maxWorldHeight > 0)     lengthen=Math.min(lengthen,maxWorldHeight - minWorldHeight);
    setWorldHeight(getWorldHeight() + lengthen);
    setScreenHeight(getScreenHeight() + Math.round(lengthen * toViewportSpace));
  }
  setScreenX((screenWidth - getScreenWidth()) / 2);
  setScreenY((screenHeight - getScreenHeight()) / 2);
  apply(centerCamera);
  EngineLogger.debug(""String_Node_Str"" + getScreenWidth() + ""String_Node_Str""+ getScreenHeight());
}","@Override public void update(int screenWidth,int screenHeight,boolean centerCamera){
  Vector2 s=Scaling.fill.apply(getWorldWidth(),getWorldHeight(),screenWidth,screenHeight);
  if (s.x > screenWidth)   setWorldWidth(minWorldWidth);
 else   setWorldHeight(minWorldHeight);
  Vector2 scaled=Scaling.fit.apply(getWorldWidth(),getWorldHeight(),screenWidth,screenHeight);
  setScreenWidth(Math.round(scaled.x));
  setScreenHeight(Math.round(scaled.y));
  if (getScreenWidth() < screenWidth) {
    float toViewportSpace=getScreenHeight() / getWorldHeight();
    float toWorldSpace=getWorldHeight() / getScreenHeight();
    float lengthen=(screenWidth - getScreenWidth()) * toWorldSpace;
    if (maxWorldWidth > 0)     lengthen=Math.min(lengthen,maxWorldWidth - minWorldWidth);
    setWorldWidth(getWorldWidth() + lengthen);
    setScreenWidth(getScreenWidth() + Math.round(lengthen * toViewportSpace));
  }
 else   if (getScreenHeight() < screenHeight) {
    float toViewportSpace=getScreenWidth() / getWorldWidth();
    float toWorldSpace=getWorldWidth() / getScreenWidth();
    float lengthen=(screenHeight - getScreenHeight()) * toWorldSpace;
    if (maxWorldHeight > 0)     lengthen=Math.min(lengthen,maxWorldHeight - minWorldHeight);
    setWorldHeight(getWorldHeight() + lengthen);
    setScreenHeight(getScreenHeight() + Math.round(lengthen * toViewportSpace));
  }
  setScreenX((screenWidth - getScreenWidth()) / 2);
  setScreenY((screenHeight - getScreenHeight()) / 2);
  apply(centerCamera);
  EngineLogger.debug(""String_Node_Str"" + getScreenWidth() + ""String_Node_Str""+ getScreenHeight());
  EngineLogger.debug(""String_Node_Str"" + getWorldWidth() + ""String_Node_Str""+ getWorldHeight());
}",0.3366085578446909
30316,"public void setSelectedFA(String selFA){
  if (selectedActor instanceof SpriteActor) {
    ActorRenderer s=((SpriteActor)selectedActor).getRenderer();
    if (selFA == null || s.getAnimations().get(selFA) == null || s.getAnimations().get(AnimationDesc.getFlipId(selFA)) == null) {
      selFA=((SpriteActor)selectedActor).getRenderer().getInitAnimation();
    }
    if (selFA != null && (s.getAnimations().get(selFA) != null || s.getAnimations().get(AnimationDesc.getFlipId(selFA)) != null)) {
      setAnimation(s.getAnimations().get(selFA));
      if (inScene || s.getCurrentAnimation() == null || ((SpriteActor)selectedActor).getRenderer().getInitAnimation().equals(selFA)) {
        try {
          ((SpriteActor)selectedActor).startAnimation(selFA,Tween.Type.REPEAT,Tween.INFINITY,null);
        }
 catch (        Exception e) {
          setAnimation(null);
          ((SpriteActor)selectedActor).getRenderer().getAnimations().remove(selFA);
        }
      }
    }
 else {
      setAnimation(null);
    }
  }
 else {
    setAnimation(null);
  }
}","public void setSelectedFA(String selFA){
  if (selectedActor instanceof SpriteActor) {
    ActorRenderer s=((SpriteActor)selectedActor).getRenderer();
    if (selFA == null || (s.getAnimations().get(selFA) == null && s.getAnimations().get(AnimationDesc.getFlipId(selFA)) == null)) {
      selFA=((SpriteActor)selectedActor).getRenderer().getInitAnimation();
    }
    if (selFA != null && (s.getAnimations().get(selFA) != null || s.getAnimations().get(AnimationDesc.getFlipId(selFA)) != null)) {
      setAnimation(s.getAnimations().get(selFA));
      if (inScene || s.getCurrentAnimation() == null || ((SpriteActor)selectedActor).getRenderer().getInitAnimation().equals(selFA)) {
        try {
          ((SpriteActor)selectedActor).startAnimation(selFA,Tween.Type.REPEAT,Tween.INFINITY,null);
        }
 catch (        Exception e) {
          setAnimation(null);
          ((SpriteActor)selectedActor).getRenderer().getAnimations().remove(selFA);
        }
      }
    }
 else {
      setAnimation(null);
    }
  }
 else {
    setAnimation(null);
  }
}",0.9620493358633776
30317,"private void computeBbox(){
  float minX, minY, maxX, maxY;
  if (bbox != null && (bbox.getVertices() == null || bbox.getVertices().length != 8)) {
    bbox.setVertices(new float[8]);
  }
  if (currentSource == null || currentSource.skeleton == null) {
    if (bbox != null) {
      float[] verts=bbox.getVertices();
      verts[0]=-getWidth() / 2;
      verts[1]=0f;
      verts[2]=-getWidth() / 2;
      verts[3]=getHeight();
      verts[4]=getWidth() / 2;
      verts[5]=getHeight();
      verts[6]=getWidth() / 2;
      verts[7]=0f;
      bbox.dirty();
    }
    return;
  }
  currentSource.skeleton.setPosition(0,0);
  currentSource.skeleton.updateWorldTransform();
  bounds.update(currentSource.skeleton,true);
  if (bounds.getWidth() > 0 && bounds.getHeight() > 0) {
    width=bounds.getWidth();
    height=bounds.getHeight();
    minX=bounds.getMinX();
    minY=bounds.getMinY();
    maxX=bounds.getMaxX();
    maxY=bounds.getMaxY();
  }
 else {
    minX=Float.MAX_VALUE;
    minY=Float.MAX_VALUE;
    maxX=Float.MIN_VALUE;
    maxY=Float.MIN_VALUE;
    Array<Slot> slots=currentSource.skeleton.getSlots();
    for (int i=0, n=slots.size; i < n; i++) {
      Slot slot=slots.get(i);
      Attachment attachment=slot.getAttachment();
      if (attachment == null)       continue;
      if (!(attachment instanceof RegionAttachment))       continue;
      ((RegionAttachment)attachment).updateWorldVertices(slot,false);
      float[] vertices=((RegionAttachment)attachment).getWorldVertices();
      for (int ii=0, nn=vertices.length; ii < nn; ii+=5) {
        minX=Math.min(minX,vertices[ii]);
        minY=Math.min(minY,vertices[ii + 1]);
        maxX=Math.max(maxX,vertices[ii]);
        maxY=Math.max(maxY,vertices[ii + 1]);
      }
    }
    width=(maxX - minX);
    height=(maxY - minY);
    if (width <= 0 || height <= 0) {
      width=height=DEFAULT_DIM;
    }
  }
  if (bbox != null) {
    float[] verts=bbox.getVertices();
    verts[0]=minX;
    verts[1]=minY;
    verts[2]=minX;
    verts[3]=maxY;
    verts[4]=maxX;
    verts[5]=maxY;
    verts[6]=maxX;
    verts[7]=minY;
    bbox.dirty();
  }
}","private void computeBbox(){
  float minX, minY, maxX, maxY;
  if (bbox != null && (bbox.getVertices() == null || bbox.getVertices().length != 8)) {
    bbox.setVertices(new float[8]);
  }
  if (currentSource == null || currentSource.skeleton == null) {
    if (bbox != null) {
      float[] verts=bbox.getVertices();
      verts[0]=-getWidth() / 2;
      verts[1]=0f;
      verts[2]=-getWidth() / 2;
      verts[3]=getHeight();
      verts[4]=getWidth() / 2;
      verts[5]=getHeight();
      verts[6]=getWidth() / 2;
      verts[7]=0f;
      bbox.dirty();
    }
    return;
  }
  currentSource.skeleton.setPosition(0,0);
  currentSource.skeleton.updateWorldTransform();
  bounds.update(currentSource.skeleton,true);
  if (bounds.getWidth() > 0 && bounds.getHeight() > 0) {
    width=bounds.getWidth();
    height=bounds.getHeight();
    minX=bounds.getMinX();
    minY=bounds.getMinY();
    maxX=bounds.getMaxX();
    maxY=bounds.getMaxY();
  }
 else {
    minX=Float.MAX_VALUE;
    minY=Float.MAX_VALUE;
    maxX=Float.MIN_VALUE;
    maxY=Float.MIN_VALUE;
    Array<Slot> slots=currentSource.skeleton.getSlots();
    for (int i=0, n=slots.size; i < n; i++) {
      Slot slot=slots.get(i);
      Attachment attachment=slot.getAttachment();
      if (attachment == null)       continue;
      if (!(attachment instanceof RegionAttachment))       continue;
      ((RegionAttachment)attachment).updateWorldVertices(slot,false);
      float[] vertices=((RegionAttachment)attachment).getWorldVertices();
      for (int ii=0, nn=vertices.length; ii < nn; ii+=5) {
        minX=Math.min(minX,vertices[ii]);
        minY=Math.min(minY,vertices[ii + 1]);
        maxX=Math.max(maxX,vertices[ii]);
        maxY=Math.max(maxY,vertices[ii + 1]);
      }
    }
    width=(maxX - minX);
    height=(maxY - minY);
    if (width <= minX || height <= minY) {
      width=height=DEFAULT_DIM;
      float dim2=DEFAULT_DIM / 2;
      minX=-dim2;
      minY=-dim2;
      maxX=dim2;
      maxY=dim2;
    }
  }
  if (bbox != null) {
    float[] verts=bbox.getVertices();
    verts[0]=minX;
    verts[1]=minY;
    verts[2]=minX;
    verts[3]=maxY;
    verts[4]=maxX;
    verts[5]=maxY;
    verts[6]=maxX;
    verts[7]=minY;
    bbox.dirty();
  }
}",0.9737206085753805
30318,"private String[] getSources(){
  String path=null;
  String renderer=parent.getAttribute(XMLConstants.RENDERER_ATTR);
  if (renderer.equals(XMLConstants.ATLAS_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.ATLASES_PATH + ""String_Node_Str""+ Ctx.project.getResDir();
    ext=""String_Node_Str"";
  }
 else   if (renderer.equals(XMLConstants.S3D_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.SPRITE3D_PATH;
    ext=""String_Node_Str"";
  }
 else   if (renderer.equals(XMLConstants.SPINE_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.SPINE_PATH;
    ext=""String_Node_Str"";
  }
 else   if (renderer.equals(XMLConstants.IMAGE_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.IMAGE_PATH + ""String_Node_Str""+ Ctx.project.getResDir();
    ext=""String_Node_Str"";
  }
  File f=new File(path);
  String sources[]=f.list(new FilenameFilter(){
    @Override public boolean accept(    File arg0,    String arg1){
      if (arg1.endsWith(ext))       return true;
      return false;
    }
  }
);
  if (sources != null) {
    Arrays.sort(sources);
    for (int i=0; i < sources.length; i++)     sources[i]=sources[i].substring(0,sources[i].length() - ext.length());
  }
 else {
    sources=new String[0];
  }
  return sources;
}","private String[] getSources(){
  String path=null;
  String renderer=parent.getAttribute(XMLConstants.RENDERER_ATTR);
  if (renderer.equals(XMLConstants.ATLAS_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.ATLASES_PATH + ""String_Node_Str""+ Ctx.project.getResDir();
    ext=ATLAS_EXT;
  }
 else   if (renderer.equals(XMLConstants.S3D_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.SPRITE3D_PATH;
    ext=G3DB_EXT;
  }
 else   if (renderer.equals(XMLConstants.SPINE_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.SPINE_PATH;
    ext=SPINE_EXT;
  }
 else   if (renderer.equals(XMLConstants.IMAGE_VALUE)) {
    path=Ctx.project.getProjectPath() + Project.IMAGE_PATH + ""String_Node_Str""+ Ctx.project.getResDir();
    ext=""String_Node_Str"";
  }
  File f=new File(path);
  String sources[]=f.list(new FilenameFilter(){
    @Override public boolean accept(    File arg0,    String arg1){
      if (arg1.endsWith(ext))       return true;
      return false;
    }
  }
);
  if (sources != null) {
    Arrays.sort(sources);
    for (int i=0; i < sources.length; i++)     sources[i]=sources[i].substring(0,sources[i].length() - ext.length());
  }
 else {
    sources=new String[0];
  }
  return sources;
}",0.9697214372224464
30319,"@Override public String getText(){
  return input.getSelected();
}","@Override public String getText(){
  return input.getSelected() == null ? ""String_Node_Str"" : input.getSelected();
}",0.7252747252747253
30320,"@Override public void create(){
  skin=new Skin(Gdx.files.internal(SKIN));
  EditorLogger.setDebug();
  EditorLogger.debug(""String_Node_Str"");
  Ctx.project=new Project();
  Ctx.msg=new Message(skin);
  Ctx.assetManager=new EditorAssetManager();
  scnEditor=new ScnEditor(skin);
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table();
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill();
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table();
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(20);
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill();
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.3f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
    }
 catch (    Exception e) {
      EditorLogger.debug(""String_Node_Str"" + e.getMessage());
      Ctx.project.closeProject();
      e.printStackTrace();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().instant();
  TooltipManager.getInstance().enabled=false;
}","@Override public void create(){
  skin=new Skin(Gdx.files.internal(SKIN));
  EditorLogger.setDebug();
  EditorLogger.debug(""String_Node_Str"");
  Ctx.project=new Project();
  Ctx.msg=new Message(skin);
  Ctx.assetManager=new EditorAssetManager();
  scnEditor=new ScnEditor(skin);
  skin.getFont(""String_Node_Str"").getData().markupEnabled=true;
  stage=new Stage(new ScreenViewport());
  Gdx.input.setInputProcessor(stage);
  ScenePanel scenePanel=new ScenePanel(skin);
  ActorPanel actorPanel=new ActorPanel(skin);
  Table rightPanel=new Table();
  rightPanel.top().left();
  rightPanel.add(actorPanel).expand().fill();
  SplitPane splitPaneRight=new SplitPane(scnEditor,rightPanel,false,skin);
  ProjectPanel projectPanel=new ProjectPanel(skin);
  Image img=new Image(Ctx.assetManager.getIcon(""String_Node_Str""));
  img.setScaling(Scaling.none);
  img.setAlign(Align.left);
  Table leftPanel=new Table();
  leftPanel.top().left().padLeft(10);
  leftPanel.add(img).expand().fill().padBottom(20).padTop(20).padLeft(20);
  leftPanel.row();
  leftPanel.add(new ProjectToolbar(skin)).expandX().fill();
  leftPanel.row();
  leftPanel.add(projectPanel).expand().fill();
  leftPanel.row();
  leftPanel.add(scenePanel).expand().fill();
  SplitPane splitPaneLeft=new SplitPane(leftPanel,splitPaneRight,false,skin);
  splitPaneLeft.setFillParent(true);
  splitPaneLeft.setSplitAmount(0.3f);
  stage.addActor(splitPaneLeft);
  String lastProject=Ctx.project.getEditorConfig().getProperty(Project.LAST_PROJECT_PROP,""String_Node_Str"");
  if (!lastProject.isEmpty() && new File(lastProject).exists()) {
    try {
      EditorLogger.debug(""String_Node_Str"" + lastProject);
      Ctx.project.loadProject(new File(lastProject));
    }
 catch (    Exception e) {
      EditorLogger.debug(""String_Node_Str"" + e.getMessage());
      Ctx.project.closeProject();
      e.printStackTrace();
    }
  }
  stage.setScrollFocus(scnEditor.getScnWidget());
  stage.setKeyboardFocus(scnEditor.getScnWidget());
  TooltipManager.getInstance().instant();
}",0.9887530562347188
30321,"@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",fanims,HashMap.class,AnimationDesc.class);
  String currentAnimationId=null;
  if (currentAnimation != null)   currentAnimationId=currentAnimation.id;
  json.writeValue(""String_Node_Str"",currentAnimationId,currentAnimationId == null ? null : String.class);
  json.writeValue(""String_Node_Str"",initAnimation);
  json.writeValue(""String_Node_Str"",flipX);
  if (animationCbSer != null)   json.writeValue(""String_Node_Str"",animationCbSer);
 else   json.writeValue(""String_Node_Str"",ActionCallbackSerialization.find(animationCb),animationCb == null ? null : String.class);
  json.writeValue(""String_Node_Str"",currentCount);
  json.writeValue(""String_Node_Str"",currentAnimationType.getTweenId());
  json.writeValue(""String_Node_Str"",lastAnimationTime);
  json.writeValue(""String_Node_Str"",complete);
}","@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",fanims,HashMap.class,AnimationDesc.class);
  String currentAnimationId=null;
  if (currentAnimation != null)   currentAnimationId=currentAnimation.id;
  json.writeValue(""String_Node_Str"",currentAnimationId,currentAnimationId == null ? null : String.class);
  json.writeValue(""String_Node_Str"",initAnimation);
  json.writeValue(""String_Node_Str"",flipX);
  if (animationCbSer != null)   json.writeValue(""String_Node_Str"",animationCbSer);
 else   json.writeValue(""String_Node_Str"",ActionCallbackSerialization.find(animationCb),animationCb == null ? null : String.class);
  json.writeValue(""String_Node_Str"",currentCount);
  if (currentAnimationId != null)   json.writeValue(""String_Node_Str"",currentAnimationType.getTweenId());
  json.writeValue(""String_Node_Str"",lastAnimationTime);
  json.writeValue(""String_Node_Str"",complete);
}",0.980855855855856
30322,"@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  fanims=json.readValue(""String_Node_Str"",HashMap.class,AnimationDesc.class,jsonData);
  String currentAnimationId=json.readValue(""String_Node_Str"",String.class,jsonData);
  if (currentAnimationId != null)   currentAnimation=fanims.get(currentAnimationId);
  initAnimation=json.readValue(""String_Node_Str"",String.class,jsonData);
  flipX=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  animationCbSer=json.readValue(""String_Node_Str"",String.class,jsonData);
  currentCount=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  currentAnimationType=Tween.Type.fromTweenId(json.readValue(""String_Node_Str"",Integer.class,jsonData));
  lastAnimationTime=json.readValue(""String_Node_Str"",Float.class,jsonData);
  complete=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
}","@SuppressWarnings(""String_Node_Str"") @Override public void read(Json json,JsonValue jsonData){
  fanims=json.readValue(""String_Node_Str"",HashMap.class,AnimationDesc.class,jsonData);
  String currentAnimationId=json.readValue(""String_Node_Str"",String.class,jsonData);
  if (currentAnimationId != null)   currentAnimation=fanims.get(currentAnimationId);
  initAnimation=json.readValue(""String_Node_Str"",String.class,jsonData);
  flipX=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  animationCbSer=json.readValue(""String_Node_Str"",String.class,jsonData);
  currentCount=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  if (currentAnimationId != null)   currentAnimationType=Tween.Type.fromTweenId(json.readValue(""String_Node_Str"",Integer.class,jsonData));
  lastAnimationTime=json.readValue(""String_Node_Str"",Float.class,jsonData);
  complete=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
}",0.9812362030905076
30323,"@Override public void setParams(HashMap<String,String> params){
  actor=params.get(""String_Node_Str"");
  if (params.get(""String_Node_Str"") != null) {
    pos=Param.parseVector2(params.get(""String_Node_Str""));
  }
 else   if (params.get(""String_Node_Str"") != null) {
    target=params.get(""String_Node_Str"");
    if (anchor == null) {
      anchor=Anchor.CENTER;
    }
 else {
      anchor=Anchor.valueOf(params.get(""String_Node_Str"").toUpperCase());
    }
    distance=Param.parseVector2(params.get(""String_Node_Str""));
    if (distance == null)     distance=new Vector2();
  }
  if (params.get(""String_Node_Str"") != null) {
    wait=Boolean.parseBoolean(params.get(""String_Node_Str""));
  }
}","@Override public void setParams(HashMap<String,String> params){
  actor=params.get(""String_Node_Str"");
  if (params.get(""String_Node_Str"") != null) {
    pos=Param.parseVector2(params.get(""String_Node_Str""));
  }
 else   if (params.get(""String_Node_Str"") != null) {
    target=params.get(""String_Node_Str"");
    if (params.get(""String_Node_Str"") == null) {
      anchor=Anchor.CENTER;
    }
 else {
      anchor=Anchor.valueOf(params.get(""String_Node_Str"").toUpperCase());
    }
    distance=Param.parseVector2(params.get(""String_Node_Str""));
    if (distance == null)     distance=new Vector2();
  }
  if (params.get(""String_Node_Str"") != null) {
    wait=Boolean.parseBoolean(params.get(""String_Node_Str""));
  }
}",0.9751243781094528
30324,"@Override public boolean run(ActionCallback cb){
  Scene scn=this.sceneActorRef.getScene();
  InteractiveActor actor=(InteractiveActor)scn.getActor(this.sceneActorRef.getActorId(),false);
  if (this.sceneActorRef.getSceneId() != null) {
    actor.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    actor.retrieveAssets();
  }
  scn.removeActor(actor);
  if (actor instanceof SpriteActor) {
    SpriteActor a=(SpriteActor)actor;
    if (animation != null)     a.startAnimation(animation,null);
 else     if (a.getRenderer().getAnimations().get(a.getId() + ""String_Node_Str"") != null)     a.startAnimation(a.getId() + ""String_Node_Str"",null);
    World.getInstance().getInventory().addItem(a);
  }
  return false;
}","@Override public boolean run(ActionCallback cb){
  Scene scn=this.sceneActorRef.getScene();
  InteractiveActor actor=(InteractiveActor)scn.getActor(this.sceneActorRef.getActorId(),false);
  scn.removeActor(actor);
  if (scn != World.getInstance().getCurrentScene()) {
    actor.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    actor.retrieveAssets();
  }
  if (actor instanceof SpriteActor) {
    SpriteActor a=(SpriteActor)actor;
    if (animation != null)     a.startAnimation(animation,null);
 else     if (a.getRenderer().getAnimations().get(a.getId() + ""String_Node_Str"") != null)     a.startAnimation(a.getId() + ""String_Node_Str"",null);
    World.getInstance().getInventory().addItem(a);
  }
  return false;
}",0.9097080787508486
30325,"@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getCurrentScene().getActor(actorId,false);
  if (speed == 0 || !(actor instanceof SpriteActor)) {
    actor.setPosition(pos.x * scale,pos.y * scale);
    return false;
  }
 else {
    float s;
    if (mode != null && mode.equals(""String_Node_Str"")) {
      Vector2 p0=new Vector2(actor.getX(),actor.getY());
      s=p0.dst(pos.x * scale,pos.y * scale) / (scale * speed);
    }
 else {
      s=speed;
    }
    ((SpriteActor)actor).startPosAnimation(repeat,count,s,pos.x * scale,pos.y * scale,interpolation,wait ? cb : null);
  }
  return wait;
}","@Override public boolean run(ActionCallback cb){
  float scale=EngineAssetManager.getInstance().getScale();
  BaseActor actor=World.getInstance().getCurrentScene().getActor(actorId,false);
  if (speed == 0 || !(actor instanceof SpriteActor)) {
    actor.setPosition(pos.x * scale,pos.y * scale);
    return false;
  }
 else {
    float s;
    if (mode != null && mode == Mode.SPEED) {
      Vector2 p0=new Vector2(actor.getX(),actor.getY());
      s=p0.dst(pos.x * scale,pos.y * scale) / (scale * speed);
    }
 else {
      s=speed;
    }
    ((SpriteActor)actor).startPosAnimation(repeat,count,s,pos.x * scale,pos.y * scale,interpolation,wait ? cb : null);
  }
  return wait;
}",0.5489051094890511
30326,"private String[] getMusicList(){
  String path=Ctx.project.getProjectPath() + Project.MUSIC_PATH;
  File f=new File(path);
  String musicFiles[]=f.list(new FilenameFilter(){
    @Override public boolean accept(    File arg0,    String arg1){
      if (arg1.endsWith(""String_Node_Str"") || arg1.endsWith(""String_Node_Str""))       return true;
      return false;
    }
  }
);
  Arrays.sort(musicFiles);
  String musicFiles2[]=new String[musicFiles.length + 1];
  musicFiles2[0]=""String_Node_Str"";
  for (int i=0; i < musicFiles.length; i++)   musicFiles2[i + 1]=musicFiles[i];
  return musicFiles2;
}","private String[] getMusicList(){
  String path=Ctx.project.getProjectPath() + Project.MUSIC_PATH;
  File f=new File(path);
  String musicFiles[]=f.list(new FilenameFilter(){
    @Override public boolean accept(    File arg0,    String arg1){
      if (arg1.endsWith(""String_Node_Str"") || arg1.endsWith(""String_Node_Str""))       return true;
      return false;
    }
  }
);
  if (musicFiles == null)   return new String[0];
  Arrays.sort(musicFiles);
  String musicFiles2[]=new String[musicFiles.length + 1];
  musicFiles2[0]=""String_Node_Str"";
  for (int i=0; i < musicFiles.length; i++)   musicFiles2[i + 1]=musicFiles[i];
  return musicFiles2;
}",0.9598715890850722
30327,"private void computeBbox(){
  if (bbox.getVertices() == null || bbox.getVertices().length != 8) {
    bbox.setVertices(new float[8]);
  }
  float[] verts=bbox.getVertices();
  verts[0]=-getWidth() / 2;
  verts[1]=0f;
  verts[2]=-getWidth() / 2;
  verts[3]=getHeight();
  verts[4]=getWidth() / 2;
  verts[5]=getHeight();
  verts[6]=getWidth() / 2;
  verts[7]=0f;
  bbox.dirty();
}","private void computeBbox(){
  if (bbox == null)   return;
  if (bbox.getVertices() == null || bbox.getVertices().length != 8) {
    bbox.setVertices(new float[8]);
  }
  float[] verts=bbox.getVertices();
  verts[0]=-getWidth() / 2;
  verts[1]=0f;
  verts[2]=-getWidth() / 2;
  verts[3]=getHeight();
  verts[4]=getWidth() / 2;
  verts[5]=getHeight();
  verts[6]=getWidth() / 2;
  verts[7]=0f;
  bbox.dirty();
}",0.9263959390862944
30328,"/** 
 * If 'player' if far from 'actor', we bring it close.  If 'player' is closed from 'actor' do nothing. TODO: DOESN'T WORK NOW
 * @param player
 * @param actor
 */
@SuppressWarnings(""String_Node_Str"") private void goNear(CharacterActor player,BaseActor actor,ActionCallback cb){
  Rectangle rdest=actor.getBBox().getBoundingRectangle();
  Vector2 p0=new Vector2(player.getX(),player.getY());
  Vector2 p1=new Vector2(rdest.x,rdest.y);
  Vector2 p2=new Vector2(rdest.x + rdest.width,rdest.y);
  Vector2 p3=new Vector2(rdest.x + rdest.width / 2,rdest.y);
  float d1=p0.dst(p1);
  float d2=p0.dst(p2);
  float d3=p0.dst(p3);
  Vector2 pf;
  if (d1 < d2 && d1 < d3) {
    pf=p1;
  }
 else   if (d2 < d1 && d2 < d3) {
    pf=p2;
  }
 else {
    pf=p3;
  }
  player.goTo(pf,cb);
}","/** 
 * If 'player' if far from 'actor', we bring it close. If 'player' is closed from 'actor' do nothing. TODO: DOESN'T WORK NOW
 * @param player
 * @param actor
 */
@SuppressWarnings(""String_Node_Str"") private void goNear(CharacterActor player,BaseActor actor,ActionCallback cb){
  Rectangle rdest=actor.getBBox().getBoundingRectangle();
  Vector2 p0=new Vector2(player.getX(),player.getY());
  Vector2 p1=new Vector2(rdest.x,rdest.y);
  Vector2 p2=new Vector2(rdest.x + rdest.width,rdest.y);
  Vector2 p3=new Vector2(rdest.x + rdest.width / 2,rdest.y);
  float d1=p0.dst(p1);
  float d2=p0.dst(p2);
  float d3=p0.dst(p3);
  Vector2 pf;
  if (d1 < d2 && d1 < d3) {
    pf=p1;
  }
 else   if (d2 < d1 && d2 < d3) {
    pf=p2;
  }
 else {
    pf=p3;
  }
  player.goTo(pf,cb);
}",0.9993569131832798
30329,"@Override public void setParams(HashMap<String,String> params){
  actor=params.get(""String_Node_Str"");
  if (params.get(""String_Node_Str"") != null) {
    pos=Param.parseVector2(params.get(""String_Node_Str""));
  }
 else   if (params.get(""String_Node_Str"") != null) {
    target=params.get(""String_Node_Str"");
    anchor=Anchor.valueOf(params.get(""String_Node_Str"").toUpperCase());
    if (anchor == null)     anchor=Anchor.CENTER;
    distance=Param.parseVector2(params.get(""String_Node_Str""));
    if (distance == null)     distance=new Vector2();
  }
  if (params.get(""String_Node_Str"") != null) {
    wait=Boolean.parseBoolean(params.get(""String_Node_Str""));
  }
}","@Override public void setParams(HashMap<String,String> params){
  actor=params.get(""String_Node_Str"");
  if (params.get(""String_Node_Str"") != null) {
    pos=Param.parseVector2(params.get(""String_Node_Str""));
  }
 else   if (params.get(""String_Node_Str"") != null) {
    target=params.get(""String_Node_Str"");
    if (anchor == null) {
      anchor=Anchor.CENTER;
    }
 else {
      anchor=Anchor.valueOf(params.get(""String_Node_Str"").toUpperCase());
    }
    distance=Param.parseVector2(params.get(""String_Node_Str""));
    if (distance == null)     distance=new Vector2();
  }
  if (params.get(""String_Node_Str"") != null) {
    wait=Boolean.parseBoolean(params.get(""String_Node_Str""));
  }
}",0.8571428571428571
30330,"@Override public boolean run(ActionCallback cb){
  Scene scn=this.sceneActorRef.getScene();
  InteractiveActor actor=(InteractiveActor)scn.getActor(this.sceneActorRef.getSceneId(),false);
  if (this.sceneActorRef.getSceneId() != null) {
    actor.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    actor.retrieveAssets();
  }
  scn.removeActor(actor);
  if (actor instanceof SpriteActor) {
    SpriteActor a=(SpriteActor)actor;
    if (animation != null)     a.startAnimation(animation,null);
 else     if (a.getRenderer().getAnimations().get(a.getId() + ""String_Node_Str"") != null)     a.startAnimation(a.getId() + ""String_Node_Str"",null);
    World.getInstance().getInventory().addItem(a);
  }
  return false;
}","@Override public boolean run(ActionCallback cb){
  Scene scn=this.sceneActorRef.getScene();
  InteractiveActor actor=(InteractiveActor)scn.getActor(this.sceneActorRef.getActorId(),false);
  if (this.sceneActorRef.getSceneId() != null) {
    actor.loadAssets();
    EngineAssetManager.getInstance().finishLoading();
    actor.retrieveAssets();
  }
  scn.removeActor(actor);
  if (actor instanceof SpriteActor) {
    SpriteActor a=(SpriteActor)actor;
    if (animation != null)     a.startAnimation(animation,null);
 else     if (a.getRenderer().getAnimations().get(a.getId() + ""String_Node_Str"") != null)     a.startAnimation(a.getId() + ""String_Node_Str"",null);
    World.getInstance().getInventory().addItem(a);
  }
  return false;
}",0.9931880108991824
30331,"@Override public void setParams(HashMap<String,String> params){
  actorId=params.get(""String_Node_Str"");
  pos=Param.parseVector2(params.get(""String_Node_Str""));
  speed=Float.parseFloat(params.get(""String_Node_Str""));
  if (params.get(""String_Node_Str"") != null) {
    count=Integer.parseInt(params.get(""String_Node_Str""));
  }
  mode=Mode.valueOf(params.get(""String_Node_Str"").trim().toUpperCase());
  if (params.get(""String_Node_Str"") != null) {
    wait=Boolean.parseBoolean(params.get(""String_Node_Str""));
  }
  if (params.get(""String_Node_Str"") != null) {
    String repeatStr=params.get(""String_Node_Str"");
    repeat=Tween.Type.valueOf(repeatStr.trim().toUpperCase());
  }
  interpolation=InterpolationMode.valueOf(params.get(""String_Node_Str"").trim().toUpperCase());
}","@Override public void setParams(HashMap<String,String> params){
  actorId=params.get(""String_Node_Str"");
  pos=Param.parseVector2(params.get(""String_Node_Str""));
  speed=Float.parseFloat(params.get(""String_Node_Str""));
  if (params.get(""String_Node_Str"") != null) {
    count=Integer.parseInt(params.get(""String_Node_Str""));
  }
  if (params.get(""String_Node_Str"") != null) {
    mode=Mode.valueOf(params.get(""String_Node_Str"").trim().toUpperCase());
  }
  if (params.get(""String_Node_Str"") != null) {
    wait=Boolean.parseBoolean(params.get(""String_Node_Str""));
  }
  if (params.get(""String_Node_Str"") != null) {
    String repeatStr=params.get(""String_Node_Str"");
    repeat=Tween.Type.valueOf(repeatStr.trim().toUpperCase());
  }
  if (params.get(""String_Node_Str"") != null) {
    interpolation=InterpolationMode.valueOf(params.get(""String_Node_Str"").trim().toUpperCase());
  }
}",0.936144578313253
30332,"public Scene getScene(){
  final World world=World.getInstance();
  if (sceneId != null && sceneId.trim().isEmpty()) {
    return world.getScene(sceneId);
  }
 else {
    return world.getCurrentScene();
  }
}","public Scene getScene(){
  final World world=World.getInstance();
  if (sceneId != null && !sceneId.trim().isEmpty()) {
    return world.getScene(sceneId);
  }
 else {
    return world.getCurrentScene();
  }
}",0.9976019184652278
30333,"@Override public void create(){
  if (!debug)   debug=Config.getProperty(Config.DEBUG_PROP,debug);
  if (debug)   EngineLogger.setDebug();
  EngineLogger.debug(""String_Node_Str"");
  if (forceRes == null)   forceRes=Config.getProperty(Config.FORCE_RES_PROP,forceRes);
  if (forceRes != null) {
    EngineAssetManager.getInstance().forceResolution(forceRes);
  }
  World.getInstance().loadXMLWorld();
  ui=new UI();
  if (chapter == null)   chapter=Config.getProperty(Config.CHAPTER_PROP,chapter);
  if (testScene == null) {
    testScene=Config.getProperty(Config.TEST_SCENE_PROP,testScene);
  }
  if (testScene != null || chapter != null) {
    World.getInstance().loadXMLChapter(chapter,testScene);
    ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
  }
  if (gameState == null)   gameState=Config.getProperty(Config.LOAD_GAMESTATE_PROP,gameState);
  if (gameState != null) {
    World.getInstance().loadGameState(gameState);
  }
  if (restart) {
    try {
      World.getInstance().loadXMLChapter(null);
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"",e);
      dispose();
      Gdx.app.exit();
    }
  }
  if (recordName == null)   recordName=Config.getProperty(Config.PLAY_RECORD_PROP,recordName);
  if (recordName != null) {
    SceneScreen scr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
    scr.getRecorder().load(recordName);
    scr.getRecorder().setPlaying(true);
  }
  if (EngineLogger.debugMode()) {
    IntBuffer size=BufferUtils.newIntBuffer(16);
    Gdx.gl.glGetIntegerv(GL20.GL_MAX_TEXTURE_SIZE,size);
    int maxSize=size.get();
    EngineLogger.debug(""String_Node_Str"" + maxSize);
    EngineLogger.debug(""String_Node_Str"" + Gdx.graphics.getDensity());
  }
}","@Override public void create(){
  if (!debug)   debug=Config.getProperty(Config.DEBUG_PROP,debug);
  if (debug)   EngineLogger.setDebug();
  EngineLogger.debug(""String_Node_Str"");
  if (forceRes == null)   forceRes=Config.getProperty(Config.FORCE_RES_PROP,forceRes);
  if (forceRes != null) {
    EngineAssetManager.getInstance().forceResolution(forceRes);
  }
  World.getInstance().loadXMLWorld();
  ui=new UI();
  if (chapter == null)   chapter=Config.getProperty(Config.CHAPTER_PROP,chapter);
  if (testScene == null) {
    testScene=Config.getProperty(Config.TEST_SCENE_PROP,testScene);
  }
  if (testScene != null || chapter != null) {
    World.getInstance().loadXMLChapter(chapter,testScene);
    ui.setCurrentScreen(UI.Screens.SCENE_SCREEN);
  }
  if (gameState == null)   gameState=Config.getProperty(Config.LOAD_GAMESTATE_PROP,gameState);
  if (gameState != null) {
    World.getInstance().loadGameState(gameState);
  }
  if (restart) {
    try {
      World.getInstance().loadXMLChapter(null);
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"",e);
      dispose();
      Gdx.app.exit();
    }
  }
  if (recordName == null)   recordName=Config.getProperty(Config.PLAY_RECORD_PROP,recordName);
  if (recordName != null) {
    SceneScreen scr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
    scr.getRecorder().setFilename(recordName);
    scr.getRecorder().load();
    scr.getRecorder().setPlaying(true);
  }
  if (EngineLogger.debugMode()) {
    IntBuffer size=BufferUtils.newIntBuffer(16);
    Gdx.gl.glGetIntegerv(GL20.GL_MAX_TEXTURE_SIZE,size);
    int maxSize=size.get();
    EngineLogger.debug(""String_Node_Str"" + maxSize);
    EngineLogger.debug(""String_Node_Str"" + Gdx.graphics.getDensity());
  }
}",0.986960301361924
30334,"@Override public void show(){
  stage=new Stage(new ScreenViewport());
  Table table=new Table(ui.getSkin());
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setCurrentScreen(Screens.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  Label title=new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  table.add(title).padBottom(DPIUtils.getMarginSize() * 2).colspan(3).center();
  speedText=new TextField(Float.toString(((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getSpeed()),ui.getSkin());
  TextButton speedButton=new TextButton(""String_Node_Str"",ui.getSkin());
  speedButton.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      scnScr.setSpeed(Float.parseFloat(speedText.getText()));
    }
  }
);
  speedButton.pad(2,3,2,3);
  HorizontalGroup sGroup=new HorizontalGroup();
  sGroup.space(10);
  sGroup.addActor(speedText);
  sGroup.addActor(speedButton);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(sGroup);
  Recorder r=((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getRecorder();
  TextButton play=new TextButton(r.isPlaying() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  rec=new TextButton(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  play.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      Recorder r=scnScr.getRecorder();
      if (!r.isPlaying()) {
        r.load(recordings.getSelected());
        r.setPlaying(true);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
 else {
        r.setPlaying(false);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
    }
  }
);
  rec.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      Recorder r=scnScr.getRecorder();
      if (r.isPlaying()) {
        r.setPlaying(false);
      }
      r.setRecording(!r.isRecording());
      rec.setText(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"");
    }
  }
);
  recordings=new SelectBox<String>(ui.getSkin());
  String[] testFiles=EngineAssetManager.getInstance().listAssetFiles(""String_Node_Str"");
  ArrayList<String> al=new ArrayList<String>();
  for (  String file : testFiles)   if (file.endsWith(""String_Node_Str""))   al.add(file.substring(0,file.indexOf(Recorder.RECORD_EXT)));
  recordings.setItems(al.toArray(new String[al.size()]));
  play.pad(2,3,2,3);
  rec.pad(2,3,2,3);
  recFilename=new TextField(""String_Node_Str"",ui.getSkin());
  HorizontalGroup rGroup=new HorizontalGroup();
  rGroup.space(10);
  rGroup.addActor(recordings);
  rGroup.addActor(play);
  rGroup.addActor(recFilename);
  rGroup.addActor(rec);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(rGroup);
  TextButton go=new TextButton(""String_Node_Str"",ui.getSkin());
  go.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      World.getInstance().setCurrentScene(scenes.getSelected());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  go.pad(2,3,2,3);
  scenes=new SelectBox<String>(ui.getSkin());
  scenes.setItems(World.getInstance().getScenes().keySet().toArray(new String[World.getInstance().getScenes().size()]));
  HorizontalGroup scGroup=new HorizontalGroup();
  scGroup.space(10);
  scGroup.addActor(scenes);
  scGroup.addActor(go);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(scGroup);
  TesterBot bot=((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getTesterBot();
  TextButton runBot=new TextButton(bot.isEnabled() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  runBot.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setMaxWaitInverval(Float.parseFloat(testerTimeConf.getText()));
      bot.setInSceneTime(Float.parseFloat(inSceneTimeConf.getText()));
      bot.setExcludeList(testerExcludeList.getText());
      bot.setEnabled(!bot.isEnabled());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  runBot.pad(2,3,2,3);
  scenes=new SelectBox<String>(ui.getSkin());
  scenes.setItems(World.getInstance().getScenes().keySet().toArray(new String[World.getInstance().getScenes().size()]));
  testerTimeConf=new TextField(Float.toString(bot.getMaxWaitInverval()),ui.getSkin());
  inSceneTimeConf=new TextField(Float.toString(bot.getInSceneTime()),ui.getSkin());
  testerExcludeList=new TextField(bot.getExcludeList(),ui.getSkin());
  TextButton testerLeaveConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerLeaveConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setRunLeaveVerbs(!bot.isRunLeaveVerbs());
    }
  }
);
  testerLeaveConf.setChecked(bot.isRunLeaveVerbs());
  TextButton testerGotoConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerGotoConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setRunGoto(!bot.isRunGoto());
    }
  }
);
  testerGotoConf.setChecked(bot.isRunGoto());
  TextButton testerPassText=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerPassText.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setPassTexts(!bot.isPassTexts());
    }
  }
);
  testerPassText.setChecked(bot.isPassTexts());
  TextButton testerWaitWhenWalking=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerWaitWhenWalking.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setWaitWhenWalking(!bot.isWaitWhenWalking());
    }
  }
);
  testerWaitWhenWalking.setChecked(bot.isWaitWhenWalking());
  HorizontalGroup botGroup=new HorizontalGroup();
  botGroup.space(10);
  botGroup.addActor(testerLeaveConf);
  botGroup.addActor(testerGotoConf);
  botGroup.addActor(testerPassText);
  botGroup.addActor(testerWaitWhenWalking);
  HorizontalGroup botGroup2=new HorizontalGroup();
  botGroup2.space(10);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  botGroup2.addActor(testerExcludeList);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  botGroup2.addActor(testerTimeConf);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  botGroup2.addActor(inSceneTimeConf);
  botGroup2.addActor(runBot);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(botGroup);
  table.row().pad(5).align(Align.left);
  table.add();
  table.add(botGroup2);
  TextButton back=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  back.getLabelCell().padLeft(DPIUtils.MARGIN_SIZE);
  back.getLabelCell().padRight(DPIUtils.MARGIN_SIZE);
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  back.pad(4,4,4,4);
  table.row().pad(5);
  table.add(back).colspan(3).center();
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}","@Override public void show(){
  stage=new Stage(new ScreenViewport());
  Table table=new Table(ui.getSkin());
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setCurrentScreen(Screens.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  Label title=new Label(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  table.add(title).padBottom(DPIUtils.getMarginSize() * 2).colspan(3).center();
  speedText=new TextField(Float.toString(((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getSpeed()),ui.getSkin());
  TextButton speedButton=new TextButton(""String_Node_Str"",ui.getSkin());
  speedButton.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      scnScr.setSpeed(Float.parseFloat(speedText.getText()));
    }
  }
);
  speedButton.pad(2,3,2,3);
  HorizontalGroup sGroup=new HorizontalGroup();
  sGroup.space(10);
  sGroup.addActor(speedText);
  sGroup.addActor(speedButton);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(sGroup);
  Recorder r=((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getRecorder();
  TextButton play=new TextButton(r.isPlaying() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  rec=new TextButton(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  play.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      Recorder r=scnScr.getRecorder();
      if (!r.isPlaying()) {
        r.setFilename(recordings.getSelected());
        r.load();
        r.setPlaying(true);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
 else {
        r.setPlaying(false);
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
    }
  }
);
  rec.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      Recorder r=scnScr.getRecorder();
      if (r.isPlaying()) {
        r.setPlaying(false);
      }
      if (!r.isRecording())       r.setFilename(recFilename.getText());
      r.setRecording(!r.isRecording());
      rec.setText(r.isRecording() ? ""String_Node_Str"" : ""String_Node_Str"");
      if (r.isRecording())       ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  recordings=new SelectBox<String>(ui.getSkin());
  String[] testFiles=EngineAssetManager.getInstance().listAssetFiles(""String_Node_Str"");
  ArrayList<String> al=new ArrayList<String>();
  for (  String file : testFiles)   if (file.endsWith(Recorder.RECORD_EXT))   al.add(file.substring(0,file.indexOf(Recorder.RECORD_EXT)));
  FileHandle[] testFiles2=EngineAssetManager.getInstance().getUserFolder().list();
  for (  FileHandle file : testFiles2)   if (file.name().endsWith(Recorder.RECORD_EXT))   al.add(file.name().substring(0,file.name().indexOf(Recorder.RECORD_EXT)));
  recordings.setItems(al.toArray(new String[al.size()]));
  play.pad(2,3,2,3);
  rec.pad(2,3,2,3);
  recFilename=new TextField(r.getFileName(),ui.getSkin());
  HorizontalGroup rGroup=new HorizontalGroup();
  rGroup.space(10);
  rGroup.addActor(recordings);
  rGroup.addActor(play);
  rGroup.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  rGroup.addActor(recFilename);
  rGroup.addActor(rec);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(rGroup);
  TextButton go=new TextButton(""String_Node_Str"",ui.getSkin());
  go.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      World.getInstance().resume();
      World.getInstance().setCutMode(false);
      World.getInstance().setCurrentScene(scenes.getSelected());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  go.pad(2,3,2,3);
  scenes=new SelectBox<String>(ui.getSkin());
  scenes.setItems(World.getInstance().getScenes().keySet().toArray(new String[World.getInstance().getScenes().size()]));
  HorizontalGroup scGroup=new HorizontalGroup();
  scGroup.space(10);
  scGroup.addActor(scenes);
  scGroup.addActor(go);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(scGroup);
  TesterBot bot=((SceneScreen)ui.getScreen(Screens.SCENE_SCREEN)).getTesterBot();
  TextButton runBot=new TextButton(bot.isEnabled() ? ""String_Node_Str"" : ""String_Node_Str"",ui.getSkin());
  runBot.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setMaxWaitInverval(Float.parseFloat(testerTimeConf.getText()));
      bot.setInSceneTime(Float.parseFloat(inSceneTimeConf.getText()));
      bot.setExcludeList(testerExcludeList.getText());
      bot.setEnabled(!bot.isEnabled());
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  runBot.pad(2,3,2,3);
  scenes=new SelectBox<String>(ui.getSkin());
  scenes.setItems(World.getInstance().getScenes().keySet().toArray(new String[World.getInstance().getScenes().size()]));
  testerTimeConf=new TextField(Float.toString(bot.getMaxWaitInverval()),ui.getSkin());
  inSceneTimeConf=new TextField(Float.toString(bot.getInSceneTime()),ui.getSkin());
  testerExcludeList=new TextField(bot.getExcludeList(),ui.getSkin());
  TextButton testerLeaveConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerLeaveConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setRunLeaveVerbs(!bot.isRunLeaveVerbs());
    }
  }
);
  testerLeaveConf.setChecked(bot.isRunLeaveVerbs());
  TextButton testerGotoConf=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerGotoConf.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setRunGoto(!bot.isRunGoto());
    }
  }
);
  testerGotoConf.setChecked(bot.isRunGoto());
  TextButton testerPassText=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerPassText.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setPassTexts(!bot.isPassTexts());
    }
  }
);
  testerPassText.setChecked(bot.isPassTexts());
  TextButton testerWaitWhenWalking=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  testerWaitWhenWalking.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      SceneScreen scnScr=(SceneScreen)ui.getScreen(Screens.SCENE_SCREEN);
      TesterBot bot=scnScr.getTesterBot();
      bot.setWaitWhenWalking(!bot.isWaitWhenWalking());
    }
  }
);
  testerWaitWhenWalking.setChecked(bot.isWaitWhenWalking());
  HorizontalGroup botGroup=new HorizontalGroup();
  botGroup.space(10);
  botGroup.addActor(testerLeaveConf);
  botGroup.addActor(testerGotoConf);
  botGroup.addActor(testerPassText);
  botGroup.addActor(testerWaitWhenWalking);
  HorizontalGroup botGroup2=new HorizontalGroup();
  botGroup2.space(10);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  botGroup2.addActor(testerExcludeList);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  botGroup2.addActor(testerTimeConf);
  botGroup2.addActor(new Label(""String_Node_Str"",ui.getSkin()));
  botGroup2.addActor(inSceneTimeConf);
  botGroup2.addActor(runBot);
  table.row().pad(5).align(Align.left);
  table.add(""String_Node_Str"");
  table.add(botGroup);
  table.row().pad(5).align(Align.left);
  table.add();
  table.add(botGroup2);
  TextButton back=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  back.getLabelCell().padLeft(DPIUtils.MARGIN_SIZE);
  back.getLabelCell().padRight(DPIUtils.MARGIN_SIZE);
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  back.pad(4,4,4,4);
  table.row().pad(5);
  table.add(back).colspan(3).center();
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}",0.9472512015004104
30335,"@SuppressWarnings(""String_Node_Str"") public void load(String name){
  String gameStateFileName;
  String recordFileName;
  if (name != null) {
    gameStateFileName=name + GAMESTATE_EXT;
    recordFileName=name + RECORD_EXT;
  }
 else {
    gameStateFileName=DEFAULT_RECORD_FILENAME + GAMESTATE_EXT;
    recordFileName=DEFAULT_RECORD_FILENAME + RECORD_EXT;
  }
  FileHandle verbsFile=EngineAssetManager.getInstance().getUserFile(recordFileName);
  if (!verbsFile.exists())   verbsFile=Gdx.files.internal(""String_Node_Str"" + recordFileName);
  if (verbsFile.exists()) {
    FileHandle gameStateFile=EngineAssetManager.getInstance().getUserFile(gameStateFileName);
    if (!gameStateFile.exists())     gameStateFile=Gdx.files.internal(""String_Node_Str"" + gameStateFileName);
    if (gameStateFile.exists())     World.getInstance().loadGameState(gameStateFile);
 else     EngineLogger.error(""String_Node_Str"");
    list=new Json().fromJson(ArrayList.class,TimeVerb.class,verbsFile.reader(""String_Node_Str""));
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
}","@SuppressWarnings(""String_Node_Str"") public void load(){
  String gameStateFileName=fileName + GAMESTATE_EXT;
  String recordFileName=fileName + RECORD_EXT;
  FileHandle verbsFile=EngineAssetManager.getInstance().getUserFile(recordFileName);
  if (!verbsFile.exists())   verbsFile=Gdx.files.internal(""String_Node_Str"" + recordFileName);
  if (verbsFile.exists()) {
    FileHandle gameStateFile=EngineAssetManager.getInstance().getUserFile(gameStateFileName);
    if (!gameStateFile.exists())     gameStateFile=Gdx.files.internal(""String_Node_Str"" + gameStateFileName);
    if (gameStateFile.exists())     World.getInstance().loadGameState(gameStateFile);
 else     EngineLogger.error(""String_Node_Str"");
    list=new Json().fromJson(ArrayList.class,TimeVerb.class,verbsFile.reader(""String_Node_Str""));
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
}",0.8775933609958506
30336,"public void setRecording(boolean recording){
  this.recording=recording;
  time=0;
  pos=0;
  if (recording) {
    EngineLogger.debug(""String_Node_Str"");
    World.getInstance().saveGameState(DEFAULT_RECORD_FILENAME + GAMESTATE_EXT);
  }
 else   save();
}","public void setRecording(boolean recording){
  this.recording=recording;
  time=0;
  pos=0;
  if (recording) {
    EngineLogger.debug(""String_Node_Str"");
    World.getInstance().saveGameState(fileName + GAMESTATE_EXT);
  }
 else   save();
}",0.9414141414141414
30337,"public void save(){
  Json json=new Json();
  String s=json.prettyPrint(list);
  Writer w=EngineAssetManager.getInstance().getUserFile(DEFAULT_RECORD_FILENAME + RECORD_EXT).writer(false,""String_Node_Str"");
  try {
    w.write(s);
    w.close();
  }
 catch (  IOException e) {
    EngineLogger.error(""String_Node_Str"",e);
  }
}","public void save(){
  Json json=new Json();
  String s=json.prettyPrint(list);
  Writer w=EngineAssetManager.getInstance().getUserFile(fileName + RECORD_EXT).writer(false,""String_Node_Str"");
  try {
    w.write(s);
    w.close();
  }
 catch (  IOException e) {
    EngineLogger.error(""String_Node_Str"",e);
  }
}",0.9419152276295132
30338,"@Override public void act(float delta){
  if (projectLoadedFlag) {
    projectLoadedFlag=false;
    if (scn != null) {
      scn.dispose();
      EngineAssetManager.getInstance().dispose();
      scn=null;
    }
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH,Ctx.project.getWorld().getWidth(),Ctx.project.getWorld().getHeight());
    setSelectedScene(Ctx.project.getSelectedScene());
    setSelectedActor(Ctx.project.getSelectedActor());
    setSelectedFA(Ctx.project.getSelectedFA());
  }
  if (scn != null && animation && !loading && !loadingError) {
    faRenderer.update(delta);
    scn.update(delta);
  }
}","@Override public void act(float delta){
  if (projectLoadedFlag) {
    projectLoadedFlag=false;
    if (scn != null) {
      scn.dispose();
      EngineAssetManager.getInstance().dispose();
      scn=null;
    }
    EngineAssetManager.createEditInstance(Ctx.project.getProjectDir().getAbsolutePath() + Project.ASSETS_PATH,Ctx.project.getWorld().getWidth(),Ctx.project.getWorld().getHeight());
    setSelectedScene(Ctx.project.getSelectedScene());
    setSelectedActor(Ctx.project.getSelectedActor());
    setSelectedFA(Ctx.project.getSelectedFA());
  }
  if (scn != null && animation && !loading && !loadingError) {
    if (!inScene)     faRenderer.update(delta);
    scn.update(delta);
  }
}",0.986822840409956
30339,"public void setTab(int i){
  Actor panel=tabs.get(i).content;
  tabs.get(i).button.setChecked(true);
  body.clear();
  body.setActor(panel);
}","public void setTab(int i){
  Actor panel=tabs.get(i).content;
  tabs.get(i).button.setChecked(true);
  body.setActor(null);
  body.clear();
  body.setActor(panel);
}",0.9250814332247556
30340,"public void clear(){
  Array<Button> buttons=buttonGroup.getButtons();
  buttons.clear();
  header.clear();
  tabs.clear();
  body.clear();
}","public void clear(){
  Array<Button> buttons=buttonGroup.getButtons();
  buttons.clear();
  header.clear();
  tabs.clear();
  body.setActor(null);
  body.clear();
}",0.9245901639344264
30341,"@Override public void setParams(HashMap<String,String> params){
  actorId=params.get(""String_Node_Str"");
  animation=params.get(""String_Node_Str"");
  String a[]=Param.parseString2(animation);
  if (a[0] != null)   actorId=a[0];
  animation=a[1];
  if (params.get(""String_Node_Str"") != null) {
    Vector2 p=Param.parseVector2(params.get(""String_Node_Str""));
    posx=p.x;
    posy=p.y;
  }
  if (params.get(""String_Node_Str"") != null) {
    boolean absolute=Boolean.parseBoolean(params.get(""String_Node_Str""));
    if (absolute)     setPos=SET_POS_ABSOLUTE;
 else     setPos=SET_POS_RELATIVE;
  }
  if (params.get(""String_Node_Str"") != null) {
    count=Integer.parseInt(params.get(""String_Node_Str""));
  }
  if (params.get(""String_Node_Str"") != null) {
    setWait(Boolean.parseBoolean(params.get(""String_Node_Str"")));
  }
  if (params.get(""String_Node_Str"") != null) {
    String repeatStr=params.get(""String_Node_Str"");
    if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.REPEAT;
    }
 else     if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.PINGPONG;
    }
 else     if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.NO_REPEAT;
    }
 else     if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.REVERSE;
    }
 else {
      repeat=Tween.FROM_FA;
    }
  }
}","@Override public void setParams(HashMap<String,String> params){
  actorId=params.get(""String_Node_Str"");
  animation=params.get(""String_Node_Str"");
  String a[]=Param.parseString2(animation);
  if (a[0] != null)   actorId=a[0];
  animation=a[1];
  if (params.get(""String_Node_Str"") != null) {
    Vector2 p=Param.parseVector2(params.get(""String_Node_Str""));
    posx=p.x;
    posy=p.y;
    setPos=SET_POS_ABSOLUTE;
  }
  if (params.get(""String_Node_Str"") != null) {
    boolean absolute=Boolean.parseBoolean(params.get(""String_Node_Str""));
    if (absolute)     setPos=SET_POS_ABSOLUTE;
 else     setPos=SET_POS_RELATIVE;
  }
  if (params.get(""String_Node_Str"") != null) {
    count=Integer.parseInt(params.get(""String_Node_Str""));
  }
  if (params.get(""String_Node_Str"") != null) {
    setWait(Boolean.parseBoolean(params.get(""String_Node_Str"")));
  }
  if (params.get(""String_Node_Str"") != null) {
    String repeatStr=params.get(""String_Node_Str"");
    if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.REPEAT;
    }
 else     if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.PINGPONG;
    }
 else     if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.NO_REPEAT;
    }
 else     if (repeatStr.equalsIgnoreCase(""String_Node_Str"")) {
      repeat=Tween.REVERSE;
    }
 else {
      repeat=Tween.FROM_FA;
    }
  }
}",0.989404457435148
30342,"private static void getUsedKeys(Element e,ArrayList<String> usedKeys){
  NamedNodeMap attrs=e.getAttributes();
  for (int i=0; i < attrs.getLength(); i++) {
    if (attrs.item(i).getNodeValue().charAt(0) == BaseDocument.I18NPREFIX) {
      usedKeys.add(attrs.item(i).getNodeValue().substring(1));
    }
  }
  NodeList childs=e.getChildNodes();
  for (int i=0; i < childs.getLength(); i++) {
    if (childs.item(i) instanceof Element)     getUsedKeys((Element)childs.item(i),usedKeys);
  }
}","private static void getUsedKeys(Element e,ArrayList<String> usedKeys){
  NamedNodeMap attrs=e.getAttributes();
  for (int i=0; i < attrs.getLength(); i++) {
    if (attrs.item(i).getNodeValue().length() > 0 && attrs.item(i).getNodeValue().charAt(0) == BaseDocument.I18NPREFIX) {
      usedKeys.add(attrs.item(i).getNodeValue().substring(1));
    }
  }
  NodeList childs=e.getChildNodes();
  for (int i=0; i < childs.getLength(); i++) {
    if (childs.item(i) instanceof Element)     getUsedKeys((Element)childs.item(i),usedKeys);
  }
}",0.9560975609756096
30343,"private void fillAnimations(){
  @SuppressWarnings(""String_Node_Str"") SelectBox<String> cb=(SelectBox<String>)inputs[1].getField();
  cb.clearItems();
  if (e == null)   cb.getItems().add(""String_Node_Str"");
  String ids[]=spriteWidget.getAnimations();
  for (  String s : ids)   cb.getItems().add(s);
  cb.getList().setItems(cb.getItems());
  cb.invalidateHierarchy();
  setAnimation();
}","private void fillAnimations(){
  @SuppressWarnings(""String_Node_Str"") SelectBox<String> cb=(SelectBox<String>)inputs[1].getField();
  cb.clearItems();
  if (e == null)   cb.getItems().add(""String_Node_Str"");
  String ids[]=spriteWidget.getAnimations();
  for (  String s : ids)   cb.getItems().add(s);
  cb.getList().setItems(cb.getItems());
  if (cb.getItems().size > 0)   cb.setSelectedIndex(0);
  cb.invalidateHierarchy();
  setAnimation();
}",0.9328537170263788
30344,"/** 
 * Extract an image from a texture atlas.
 * @param page The image file related to the page the region is in
 * @param region The region to extract
 * @param outputDirFile The output directory
 * @param padding padding (in pixels) to apply to the image
 * @return The extracted image
 */
private BufferedImage extractImage(BufferedImage page,Region region,File outputDirFile,int padding){
  BufferedImage splitImage=null;
  if (region.rotate) {
    BufferedImage srcImage=page.getSubimage(region.left,region.top,region.height,region.width);
    splitImage=new BufferedImage(region.height,region.width,page.getType());
    AffineTransform transform=new AffineTransform();
    transform.rotate(Math.toRadians(90.0));
    transform.translate(0,-region.width);
    AffineTransformOp op=new AffineTransformOp(transform,AffineTransformOp.TYPE_BILINEAR);
    op.filter(srcImage,splitImage);
  }
 else {
    splitImage=page.getSubimage(region.left,region.top,region.width,region.height);
  }
  if (padding > 0) {
    BufferedImage paddedImage=new BufferedImage(splitImage.getWidth() + padding * 2,splitImage.getHeight() + padding * 2,page.getType());
    Graphics2D g2=paddedImage.createGraphics();
    g2.drawImage(splitImage,padding,padding,null);
    g2.dispose();
    return paddedImage;
  }
 else {
    return splitImage;
  }
}","/** 
 * Extract an image from a texture atlas.
 * @param page The image file related to the page the region is in
 * @param region The region to extract
 * @param outputDirFile The output directory
 * @param padding padding (in pixels) to apply to the image
 * @return The extracted image
 */
private BufferedImage extractImage(BufferedImage page,Region region,File outputDirFile,int padding){
  BufferedImage splitImage=null;
  if (region.rotate) {
    BufferedImage srcImage=page.getSubimage(region.left,region.top,region.height,region.width);
    splitImage=new BufferedImage(region.width,region.height,page.getType());
    AffineTransform transform=new AffineTransform();
    transform.rotate(Math.toRadians(90.0));
    transform.translate(0,-region.width);
    AffineTransformOp op=new AffineTransformOp(transform,AffineTransformOp.TYPE_BILINEAR);
    op.filter(srcImage,splitImage);
  }
 else {
    splitImage=page.getSubimage(region.left,region.top,region.width,region.height);
  }
  if (padding > 0) {
    BufferedImage paddedImage=new BufferedImage(splitImage.getWidth() + padding * 2,splitImage.getHeight() + padding * 2,page.getType());
    Graphics2D g2=paddedImage.createGraphics();
    g2.drawImage(splitImage,padding,padding,null);
    g2.dispose();
    return paddedImage;
  }
 else {
    return splitImage;
  }
}",0.9894657637321296
30345,"/** 
 * Try to load the save game if exists. In other case, load the game from XML.
 * @throws IOException
 * @throws SAXException
 * @throws ParserConfigurationException
 */
public void load(){
  if (FileUtils.exists(EngineAssetManager.getInstance().getUserFile(GAMESTATE_FILENAME))) {
    try {
      instance.loadGameState();
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"",e);
      instance.loadXMLChapter(null);
    }
  }
 else {
    instance.loadXMLChapter(null);
  }
}","/** 
 * Try to load the save game if exists. In other case, load the game from XML.
 * @throws IOException
 * @throws SAXException
 * @throws ParserConfigurationException
 */
public void load(){
  if (EngineAssetManager.getInstance().getUserFile(GAMESTATE_FILENAME).exists()) {
    try {
      instance.loadGameState();
    }
 catch (    Exception e) {
      EngineLogger.error(""String_Node_Str"",e);
      instance.loadXMLChapter(null);
    }
  }
 else {
    instance.loadXMLChapter(null);
  }
}",0.974974974974975
30346,"public boolean savedGameExists(){
  return FileUtils.exists(EngineAssetManager.getInstance().getUserFile(GAMESTATE_FILENAME));
}","public boolean savedGameExists(){
  return EngineAssetManager.getInstance().getUserFile(GAMESTATE_FILENAME).exists();
}",0.8987854251012146
30347,"public void loadGameState(FileHandle savedFile){
  EngineLogger.debug(""String_Node_Str"");
  if (!disposed)   dispose();
  init();
  if (FileUtils.exists(savedFile)) {
    assetState=AssetState.LOAD_ASSETS;
    new Json().fromJson(World.class,savedFile.reader(""String_Node_Str""));
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
}","public void loadGameState(FileHandle savedFile){
  EngineLogger.debug(""String_Node_Str"");
  if (!disposed)   dispose();
  init();
  if (savedFile.exists()) {
    assetState=AssetState.LOAD_ASSETS;
    new Json().fromJson(World.class,savedFile.reader(""String_Node_Str""));
  }
 else {
    EngineLogger.error(""String_Node_Str"");
  }
}",0.9716840536512668
30348,"@Override public void show(){
  stage=new Stage(new ScreenViewport());
  Table table=new Table();
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       if (World.getInstance().getCurrentScene() != null)       ui.setCurrentScreen(Screens.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  Label title=new Label(Config.getProperty(Config.TITLE_PROP,""String_Node_Str""),ui.getSkin(),""String_Node_Str"");
  table.add(title).padBottom(DPIUtils.getMarginSize() * 2);
  if (World.getInstance().savedGameExists()) {
    TextButton continueGame=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
    continueGame.addListener(new ClickListener(){
      public void clicked(      InputEvent event,      float x,      float y){
        if (World.getInstance().getCurrentScene() == null)         World.getInstance().load();
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
    }
);
    table.row();
    table.add(continueGame);
  }
  TextButton newGame=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  newGame.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      World.getInstance().newGame();
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  table.row();
  table.add(newGame);
  TextButton help=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  help.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.HELP_SCREEN);
    }
  }
);
  table.row();
  table.add(help);
  TextButton credits=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  credits.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.CREDIT_SCREEN);
    }
  }
);
  table.row();
  table.add(credits);
  if (EngineLogger.debugMode()) {
    TextButton debug=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
    debug.addListener(new ClickListener(){
      public void clicked(      InputEvent event,      float x,      float y){
        DebugScreen debugScr=new DebugScreen();
        debugScr.setUI(ui);
        ui.setCurrentScreen(debugScr);
      }
    }
);
    table.row();
    table.add(debug);
  }
  TextButton quit=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  quit.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      World.getInstance().dispose();
      Gdx.app.exit();
    }
  }
);
  table.row();
  table.add(quit);
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}","@Override public void show(){
  stage=new Stage(new ScreenViewport());
  Table table=new Table();
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       if (World.getInstance().getCurrentScene() != null)       ui.setCurrentScreen(Screens.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  Label title=new Label(Config.getProperty(Config.TITLE_PROP,""String_Node_Str""),ui.getSkin(),""String_Node_Str"");
  table.add(title).padBottom(DPIUtils.getMarginSize() * 2);
  if (World.getInstance().savedGameExists() || World.getInstance().getCurrentScene() != null) {
    TextButton continueGame=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
    continueGame.addListener(new ClickListener(){
      public void clicked(      InputEvent event,      float x,      float y){
        if (World.getInstance().getCurrentScene() == null)         World.getInstance().load();
        ui.setCurrentScreen(Screens.SCENE_SCREEN);
      }
    }
);
    table.row();
    table.add(continueGame);
  }
  TextButton newGame=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  newGame.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      World.getInstance().newGame();
      ui.setCurrentScreen(Screens.SCENE_SCREEN);
    }
  }
);
  table.row();
  table.add(newGame);
  TextButton help=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  help.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.HELP_SCREEN);
    }
  }
);
  table.row();
  table.add(help);
  TextButton credits=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  credits.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setCurrentScreen(Screens.CREDIT_SCREEN);
    }
  }
);
  table.row();
  table.add(credits);
  if (EngineLogger.debugMode()) {
    TextButton debug=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
    debug.addListener(new ClickListener(){
      public void clicked(      InputEvent event,      float x,      float y){
        DebugScreen debugScr=new DebugScreen();
        debugScr.setUI(ui);
        ui.setCurrentScreen(debugScr);
      }
    }
);
    table.row();
    table.add(debug);
  }
  TextButton quit=new TextButton(""String_Node_Str"",ui.getSkin(),""String_Node_Str"");
  quit.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Gdx.app.exit();
    }
  }
);
  table.row();
  table.add(quit);
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}",0.9373702422145328
30349,"public void clicked(InputEvent event,float x,float y){
  World.getInstance().dispose();
  Gdx.app.exit();
}","public void clicked(InputEvent event,float x,float y){
  Gdx.app.exit();
}",0.8176795580110497
30350,"public void play(){
  if (loop)   s.loop();
 else   s.play(volume);
}","public void play(){
  if (s == null)   return;
  if (loop)   s.loop();
 else   s.play(volume);
}",0.8363636363636363
30351,"public void stop(){
  s.stop();
}","public void stop(){
  if (s == null)   return;
  s.stop();
}",0.7096774193548387
30352,"public static boolean runGradle(File workingDir,String parameters){
  String exec=workingDir.getAbsolutePath() + ""String_Node_Str"" + (System.getProperty(""String_Node_Str"").contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  String command=exec + ""String_Node_Str"" + parameters;
  EditorLogger.debug(""String_Node_Str"" + command + ""String_Node_Str"");
  try {
    final Process process=new ProcessBuilder(command.split(""String_Node_Str"")).directory(workingDir).inheritIO().start();
    process.waitFor();
    return process.exitValue() == 0;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return false;
  }
}","public static boolean runGradle(File workingDir,String parameters){
  String exec=workingDir.getAbsolutePath() + ""String_Node_Str"" + (System.getProperty(""String_Node_Str"").contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  String command=exec + ""String_Node_Str"" + parameters;
  EditorLogger.debug(""String_Node_Str"" + command + ""String_Node_Str"");
  try {
    final Process process=new ProcessBuilder(command.split(""String_Node_Str"")).directory(workingDir).start();
    process.waitFor();
    return process.exitValue() == 0;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return false;
  }
}",0.9904761904761904
30353,"public ActorPanel(Skin skin){
  super(skin,""String_Node_Str"");
  tabPanel=new TabPanel(skin);
  verbList=new VerbList(skin);
  dialogList=new DialogList(skin);
  faList=new SpriteList(skin);
  props=new ActorProps(skin);
  soundList=new SoundList(skin);
  setContent(tabPanel);
  Ctx.project.addPropertyChangeListener(Project.NOTIFY_ACTOR_SELECTED,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent e){
      Element a=(Element)e.getNewValue();
      ChapterDocument doc=Ctx.project.getSelectedChapter();
      faList.addElements(doc,a,""String_Node_Str"");
      verbList.addElements(doc,a,""String_Node_Str"");
      dialogList.addElements(doc,a,""String_Node_Str"");
      soundList.addElements(doc,a,""String_Node_Str"");
      props.setActorDocument(doc,a);
      String selTitle=tabPanel.getSelectedIndex() == -1 ? null : tabPanel.getTitleAt(tabPanel.getSelectedIndex());
      tabPanel.clear();
      if (a != null) {
        String type=doc.getType(a);
        if (!type.equals(ChapterDocument.NO_RENDERER_ACTOR_TYPE))         tabPanel.addTab(""String_Node_Str"",faList);
        if (!type.equals(""String_Node_Str"")) {
          tabPanel.addTab(""String_Node_Str"",verbList);
          tabPanel.addTab(""String_Node_Str"",soundList);
        }
        tabPanel.addTab(""String_Node_Str"",dialogList);
        tabPanel.addTab(""String_Node_Str"",props);
        setTile(""String_Node_Str"" + doc.getId(a));
        if (selTitle != null) {
          for (int i=0; i < tabPanel.getTabCount(); i++) {
            if (tabPanel.getTitleAt(i).equals(selTitle)) {
              tabPanel.setTab(i);
            }
          }
        }
      }
 else {
        setTile(""String_Node_Str"");
      }
    }
  }
);
}","public ActorPanel(Skin skin){
  super(skin,""String_Node_Str"");
  tabPanel=new TabPanel(skin);
  verbList=new VerbList(skin);
  dialogList=new DialogList(skin);
  faList=new SpriteList(skin);
  props=new ActorProps(skin);
  soundList=new SoundList(skin);
  setContent(tabPanel);
  Ctx.project.addPropertyChangeListener(Project.NOTIFY_ACTOR_SELECTED,new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent e){
      Element a=(Element)e.getNewValue();
      ChapterDocument doc=Ctx.project.getSelectedChapter();
      String selTitle=tabPanel.getSelectedIndex() == -1 ? null : tabPanel.getTitleAt(tabPanel.getSelectedIndex());
      tabPanel.clear();
      if (a != null) {
        String type=doc.getType(a);
        if (!type.equals(ChapterDocument.NO_RENDERER_ACTOR_TYPE))         tabPanel.addTab(""String_Node_Str"",faList);
        if (!type.equals(""String_Node_Str"")) {
          tabPanel.addTab(""String_Node_Str"",verbList);
          tabPanel.addTab(""String_Node_Str"",soundList);
        }
        tabPanel.addTab(""String_Node_Str"",dialogList);
        tabPanel.addTab(""String_Node_Str"",props);
        setTile(""String_Node_Str"" + doc.getId(a));
        if (selTitle != null) {
          for (int i=0; i < tabPanel.getTabCount(); i++) {
            if (tabPanel.getTitleAt(i).equals(selTitle)) {
              tabPanel.setTab(i);
            }
          }
        }
      }
 else {
        setTile(""String_Node_Str"");
      }
      faList.addElements(doc,a,""String_Node_Str"");
      verbList.addElements(doc,a,""String_Node_Str"");
      dialogList.addElements(doc,a,""String_Node_Str"");
      soundList.addElements(doc,a,""String_Node_Str"");
      props.setActorDocument(doc,a);
    }
  }
);
}",0.8556581986143187
30354,"@Override public void propertyChange(PropertyChangeEvent e){
  Element a=(Element)e.getNewValue();
  ChapterDocument doc=Ctx.project.getSelectedChapter();
  faList.addElements(doc,a,""String_Node_Str"");
  verbList.addElements(doc,a,""String_Node_Str"");
  dialogList.addElements(doc,a,""String_Node_Str"");
  soundList.addElements(doc,a,""String_Node_Str"");
  props.setActorDocument(doc,a);
  String selTitle=tabPanel.getSelectedIndex() == -1 ? null : tabPanel.getTitleAt(tabPanel.getSelectedIndex());
  tabPanel.clear();
  if (a != null) {
    String type=doc.getType(a);
    if (!type.equals(ChapterDocument.NO_RENDERER_ACTOR_TYPE))     tabPanel.addTab(""String_Node_Str"",faList);
    if (!type.equals(""String_Node_Str"")) {
      tabPanel.addTab(""String_Node_Str"",verbList);
      tabPanel.addTab(""String_Node_Str"",soundList);
    }
    tabPanel.addTab(""String_Node_Str"",dialogList);
    tabPanel.addTab(""String_Node_Str"",props);
    setTile(""String_Node_Str"" + doc.getId(a));
    if (selTitle != null) {
      for (int i=0; i < tabPanel.getTabCount(); i++) {
        if (tabPanel.getTitleAt(i).equals(selTitle)) {
          tabPanel.setTab(i);
        }
      }
    }
  }
 else {
    setTile(""String_Node_Str"");
  }
}","@Override public void propertyChange(PropertyChangeEvent e){
  Element a=(Element)e.getNewValue();
  ChapterDocument doc=Ctx.project.getSelectedChapter();
  String selTitle=tabPanel.getSelectedIndex() == -1 ? null : tabPanel.getTitleAt(tabPanel.getSelectedIndex());
  tabPanel.clear();
  if (a != null) {
    String type=doc.getType(a);
    if (!type.equals(ChapterDocument.NO_RENDERER_ACTOR_TYPE))     tabPanel.addTab(""String_Node_Str"",faList);
    if (!type.equals(""String_Node_Str"")) {
      tabPanel.addTab(""String_Node_Str"",verbList);
      tabPanel.addTab(""String_Node_Str"",soundList);
    }
    tabPanel.addTab(""String_Node_Str"",dialogList);
    tabPanel.addTab(""String_Node_Str"",props);
    setTile(""String_Node_Str"" + doc.getId(a));
    if (selTitle != null) {
      for (int i=0; i < tabPanel.getTabCount(); i++) {
        if (tabPanel.getTitleAt(i).equals(selTitle)) {
          tabPanel.setTab(i);
        }
      }
    }
  }
 else {
    setTile(""String_Node_Str"");
  }
  faList.addElements(doc,a,""String_Node_Str"");
  verbList.addElements(doc,a,""String_Node_Str"");
  dialogList.addElements(doc,a,""String_Node_Str"");
  soundList.addElements(doc,a,""String_Node_Str"");
  props.setActorDocument(doc,a);
}",0.8103874690849134
30355,"@Override public void create(){
  Node sel=tree.getSelection().getLastSelected();
  Element parent=dialog;
  if (sel != null) {
    parent=(Element)sel.getParent().getObject();
  }
  EditDialogOptionDialog o=new EditDialogOptionDialog(skin,doc,parent,null);
  o.show(getStage());
  o.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      Node sel=tree.getSelection().getLastSelected();
      Element e=((EditElementDialog)actor).getElement();
      Node n=createNode(e);
      if (sel != null) {
        sel.add(n);
      }
 else {
        tree.add(n);
      }
    }
  }
);
}","@Override public void create(){
  Element parent=dialog;
  if (!tree.getSelection().isEmpty()) {
    Node sel=tree.getSelection().getLastSelected();
    parent=(Element)sel.getParent().getObject();
  }
  EditDialogOptionDialog o=new EditDialogOptionDialog(skin,doc,parent,null);
  o.show(getStage());
  o.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      Node sel=tree.getSelection().getLastSelected();
      Element e=((EditElementDialog)actor).getElement();
      Node n=createNode(e);
      if (sel != null) {
        sel.add(n);
      }
 else {
        tree.add(n);
      }
    }
  }
);
}",0.9124709527498064
30356,"public void layout(){
  final BitmapFont font=style.font;
  final Drawable selectedDrawable=style.selection;
  prefWidth=0;
  for (int i=0; i < items.size; i++) {
    TextBounds bounds=font.getBounds(cellRenderer.getCellTitle(items.get(i)));
    prefWidth=Math.max(bounds.width,prefWidth);
    if (cellRenderer.hasSubtitle()) {
      bounds=font.getBounds(cellRenderer.getCellSubTitle(items.get(i)));
      prefWidth=Math.max(bounds.width,prefWidth);
    }
    if (cellRenderer.hasImage()) {
      TextureRegion r=cellRenderer.getCellImage(items.get(i));
      float ih=r.getRegionHeight();
      float iw=r.getRegionWidth();
      if (ih > getItemHeight() - 10) {
        ih=getItemHeight() - 10;
        iw*=ih / r.getRegionHeight();
      }
      prefWidth=Math.max(iw,prefWidth);
    }
  }
  prefWidth+=selectedDrawable.getLeftWidth() + selectedDrawable.getRightWidth();
  prefHeight=items.size * cellRenderer.getItemHeight();
  Drawable background=style.background;
  if (background != null) {
    prefWidth+=background.getLeftWidth() + background.getRightWidth();
    prefHeight+=background.getTopHeight() + background.getBottomHeight();
  }
  cellRenderer.layout(style);
}","public void layout(){
  final BitmapFont font=style.font;
  final Drawable selectedDrawable=style.selection;
  cellRenderer.layout(style);
  prefWidth=0;
  for (int i=0; i < items.size; i++) {
    TextBounds bounds=font.getBounds(cellRenderer.getCellTitle(items.get(i)));
    prefWidth=Math.max(bounds.width,prefWidth);
    if (cellRenderer.hasSubtitle()) {
      bounds=font.getBounds(cellRenderer.getCellSubTitle(items.get(i)));
      prefWidth=Math.max(bounds.width,prefWidth);
    }
    if (cellRenderer.hasImage()) {
      TextureRegion r=cellRenderer.getCellImage(items.get(i));
      float ih=r.getRegionHeight();
      float iw=r.getRegionWidth();
      if (ih > getItemHeight() - 10) {
        ih=getItemHeight() - 10;
        iw*=ih / r.getRegionHeight();
      }
      prefWidth=Math.max(iw,prefWidth);
    }
  }
  prefWidth+=selectedDrawable.getLeftWidth() + selectedDrawable.getRightWidth();
  prefHeight=items.size * cellRenderer.getItemHeight();
  Drawable background=style.background;
  if (background != null) {
    prefWidth+=background.getLeftWidth() + background.getRightWidth();
    prefHeight+=background.getTopHeight() + background.getBottomHeight();
  }
}",0.9745547073791349
30357,"private FrameAnimation getFrameAnimation(String id){
  FrameAnimation fa=fanims.get(id);
  flipX=false;
  if (fa == null) {
    String flipId=FrameAnimation.getFlipId(id);
    fa=fanims.get(flipId);
    if (fa != null)     flipX=true;
 else {
      StringBuilder sb=new StringBuilder();
      if (id.endsWith(FrameAnimation.FRONTLEFT) || id.endsWith(FrameAnimation.FRONTRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONT);
      }
 else       if (id.endsWith(FrameAnimation.BACKLEFT) || id.endsWith(FrameAnimation.BACKRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.BACK);
      }
 else       if (id.endsWith(FrameAnimation.LEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTLEFT);
      }
 else       if (id.endsWith(FrameAnimation.RIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTRIGHT);
      }
      String s=sb.toString();
      fa=fanims.get(s);
      if (fa == null) {
        flipId=FrameAnimation.getFlipId(s);
        fa=fanims.get(flipId);
        if (fa != null) {
          flipX=true;
        }
 else         if (s.endsWith(FrameAnimation.FRONT) || s.endsWith(FrameAnimation.BACK)) {
          if (id.endsWith(FrameAnimation.LEFT)) {
            sb.append(id.substring(0,id.lastIndexOf('.') + 1));
            sb.append(FrameAnimation.LEFT);
          }
 else {
            sb.append(id.substring(0,id.lastIndexOf('.') + 1));
            sb.append(FrameAnimation.RIGHT);
          }
          s=sb.toString();
          fa=fanims.get(s);
          if (fa == null) {
            flipId=FrameAnimation.getFlipId(s);
            fa=fanims.get(flipId);
            if (fa != null) {
              flipX=true;
            }
          }
        }
      }
    }
  }
  return fa;
}","private FrameAnimation getFrameAnimation(String id){
  FrameAnimation fa=fanims.get(id);
  flipX=false;
  if (fa == null && id.indexOf('.') != -1) {
    String flipId=FrameAnimation.getFlipId(id);
    fa=fanims.get(flipId);
    if (fa != null)     flipX=true;
 else {
      StringBuilder sb=new StringBuilder();
      if (id.endsWith(FrameAnimation.FRONTLEFT) || id.endsWith(FrameAnimation.FRONTRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONT);
      }
 else       if (id.endsWith(FrameAnimation.BACKLEFT) || id.endsWith(FrameAnimation.BACKRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.BACK);
      }
 else       if (id.endsWith(FrameAnimation.LEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTLEFT);
      }
 else       if (id.endsWith(FrameAnimation.RIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTRIGHT);
      }
      String s=sb.toString();
      fa=fanims.get(s);
      if (fa == null) {
        flipId=FrameAnimation.getFlipId(s);
        fa=fanims.get(flipId);
        if (fa != null) {
          flipX=true;
        }
 else         if (s.endsWith(FrameAnimation.FRONT) || s.endsWith(FrameAnimation.BACK)) {
          if (id.endsWith(FrameAnimation.LEFT)) {
            sb.append(id.substring(0,id.lastIndexOf('.') + 1));
            sb.append(FrameAnimation.LEFT);
          }
 else {
            sb.append(id.substring(0,id.lastIndexOf('.') + 1));
            sb.append(FrameAnimation.RIGHT);
          }
          s=sb.toString();
          fa=fanims.get(s);
          if (fa == null) {
            flipId=FrameAnimation.getFlipId(s);
            fa=fanims.get(flipId);
            if (fa != null) {
              flipX=true;
            }
          }
        }
      }
    }
  }
  return fa;
}",0.993514915693904
30358,"@Override public TextureRegion getCellImage(Element e){
  String iconName=MessageFormat.format(""String_Node_Str"",e.getAttribute(""String_Node_Str""));
  TextureRegion image=null;
  image=Ctx.assetManager.getIcon(iconName);
  if (image == null)   image=Ctx.assetManager.getIcon(""String_Node_Str"");
  return image;
}","@Override public TextureRegion getCellImage(Element e){
  boolean custom=true;
  String verbName=e.getAttribute(""String_Node_Str"");
  for (  String v : VERBS) {
    if (v.equals(verbName)) {
      custom=false;
      break;
    }
  }
  String iconName=MessageFormat.format(""String_Node_Str"",e.getAttribute(""String_Node_Str""));
  TextureRegion image=null;
  if (!custom)   image=Ctx.assetManager.getIcon(iconName);
 else   image=Ctx.assetManager.getIcon(""String_Node_Str"");
  return image;
}",0.7306733167082294
30359,"@Override public void changed(ChangeEvent event,Actor actor){
  down();
}","@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex();
  if (pos == -1)   pos=0;
 else   pos++;
  Element e=((EditElementDialog)actor).getElement();
  list.getItems().insert(pos,e);
  int i=getItems().indexOf(e,true);
  if (i != -1)   list.setSelectedIndex(i);
  list.invalidateHierarchy();
}",0.339066339066339
30360,"public EditList(Skin skin){
  super(skin);
  this.skin=skin;
  list=new CustomList<T>(skin);
  Array<T> items=new Array<T>();
  list.setItems(items);
  ScrollPane scrollPane=new ScrollPane(list,skin);
  container=new Container(scrollPane);
  container.fill();
  container.prefHeight(100);
  toolbar=new EditToolbar(skin);
  add(toolbar).expandX().fillX();
  row().fill();
  add(container).expandY().fill();
  toolbar.addCreateListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      create();
    }
  }
);
  toolbar.addEditListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      edit();
    }
  }
);
  toolbar.addDeleteListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      delete();
    }
  }
);
  toolbar.addCopyListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      copy();
    }
  }
);
  toolbar.addPasteListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      paste();
    }
  }
);
  list.addListener(new InputListener(){
    @Override public void enter(    InputEvent event,    float x,    float y,    int pointer,    com.badlogic.gdx.scenes.scene2d.Actor fromActor){
      EditorLogger.debug(""String_Node_Str"" + x + ""String_Node_Str""+ y);
      getStage().setScrollFocus(list);
    }
  }
);
}","public EditList(Skin skin){
  super(skin);
  this.skin=skin;
  list=new CustomList<T>(skin);
  Array<T> items=new Array<T>();
  list.setItems(items);
  ScrollPane scrollPane=new ScrollPane(list,skin);
  container=new Container<ScrollPane>(scrollPane);
  container.fill();
  container.prefHeight(100);
  toolbar=new EditToolbar(skin);
  add(toolbar).expandX().fillX();
  row().fill();
  add(container).expandY().fill();
  toolbar.addCreateListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      create();
    }
  }
);
  toolbar.addEditListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      edit();
    }
  }
);
  toolbar.addDeleteListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      delete();
    }
  }
);
  toolbar.addCopyListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      copy();
    }
  }
);
  toolbar.addPasteListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      paste();
    }
  }
);
  list.addListener(new InputListener(){
    @Override public void enter(    InputEvent event,    float x,    float y,    int pointer,    com.badlogic.gdx.scenes.scene2d.Actor fromActor){
      EditorLogger.debug(""String_Node_Str"" + x + ""String_Node_Str""+ y);
      getStage().setScrollFocus(list);
    }
  }
);
}",0.995945945945946
30361,"@Override public float getWidth(){
  if (bounds != null && bounds.getWidth() != 0)   return bounds.getWidth();
  return 200;
}","@Override public float getWidth(){
  if (bounds != null && bounds.getWidth() > 0) {
    return bounds.getWidth();
  }
  return 200;
}",0.9575289575289576
30362,"@Override public float getHeight(){
  if (bounds != null && bounds.getWidth() != 0)   return bounds.getHeight();
  return 200;
}","@Override public float getHeight(){
  if (bounds != null && bounds.getHeight() > 0)   return bounds.getHeight();
  return 200;
}",0.9609375
30363,"@Override public void draw(SpriteBatch batch,float x,float y,float scale){
  if (currentSkeleton != null && currentSkeleton.skeleton != null) {
    currentSkeleton.skeleton.setX(x / scale);
    currentSkeleton.skeleton.setY(y / scale);
    batch.setTransformMatrix(batch.getTransformMatrix().scale(scale,scale,1.0f));
    renderer.draw(batch,currentSkeleton.skeleton);
    batch.setTransformMatrix(batch.getTransformMatrix().scale(1 / scale,1 / scale,1.0f));
  }
 else {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
  }
}","@Override public void draw(SpriteBatch batch,float x,float y,float scale){
  if (currentSkeleton != null && currentSkeleton.skeleton != null) {
    currentSkeleton.skeleton.setX(x / scale);
    currentSkeleton.skeleton.setY(y / scale);
    batch.setTransformMatrix(batch.getTransformMatrix().scale(scale,scale,1.0f));
    renderer.draw(batch,currentSkeleton.skeleton);
    batch.setTransformMatrix(batch.getTransformMatrix().scale(1 / scale,1 / scale,1.0f));
  }
 else {
    x=x - getWidth() / 2 * scale;
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
  }
}",0.9707401032702238
30364,"@Override protected void create(){
  EditElementDialog dialog=getEditElementDialogInstance(null);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      int pos=list.getSelectedIndex();
      Element e2=null;
      pos++;
      if (pos != 0 && pos < list.getItems().size)       e2=list.getItems().get(pos);
      Element e=((EditElementDialog)actor).getElement();
      list.getItems().insert(pos,e);
      Node parent=e.getParentNode();
      parent.removeChild(e);
      parent.insertBefore(e,e2);
      int i=getItems().indexOf(e,true);
      if (i != -1)       list.setSelectedIndex(i);
      list.invalidateHierarchy();
    }
  }
);
}","@Override protected void create(){
  EditElementDialog dialog=getEditElementDialogInstance(null);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      int pos=list.getSelectedIndex() + 1;
      Element e2=null;
      if (pos != 0 && pos < list.getItems().size)       e2=list.getItems().get(pos);
      Element e=((EditElementDialog)actor).getElement();
      list.getItems().insert(pos,e);
      Node parent=e.getParentNode();
      parent.removeChild(e);
      parent.insertBefore(e,e2);
      list.setSelectedIndex(pos);
      list.invalidateHierarchy();
    }
  }
);
}",0.9186875891583453
30365,"@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex();
  Element e2=null;
  pos++;
  if (pos != 0 && pos < list.getItems().size)   e2=list.getItems().get(pos);
  Element e=((EditElementDialog)actor).getElement();
  list.getItems().insert(pos,e);
  Node parent=e.getParentNode();
  parent.removeChild(e);
  parent.insertBefore(e,e2);
  int i=getItems().indexOf(e,true);
  if (i != -1)   list.setSelectedIndex(i);
  list.invalidateHierarchy();
}","@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex() + 1;
  Element e2=null;
  if (pos != 0 && pos < list.getItems().size)   e2=list.getItems().get(pos);
  Element e=((EditElementDialog)actor).getElement();
  list.getItems().insert(pos,e);
  Node parent=e.getParentNode();
  parent.removeChild(e);
  parent.insertBefore(e,e2);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
}",0.888646288209607
30366,"@Override protected void paste(){
  Element newElement=doc.cloneNode(parent,clipboard);
  addItem(newElement);
  int i=getItems().indexOf(newElement,true);
  list.setSelectedIndex(i);
}","@Override protected void paste(){
  Element newElement=doc.cloneNode(parent,clipboard);
  int pos=list.getSelectedIndex() + 1;
  Element e2=null;
  if (pos != 0 && pos < list.getItems().size)   e2=list.getItems().get(pos);
  list.getItems().insert(pos,newElement);
  Node parent=newElement.getParentNode();
  parent.insertBefore(newElement,e2);
  list.setSelectedIndex(pos);
  list.invalidateHierarchy();
}",0.3925549915397631
30367,"@Override public void dispose(){
  for (  String key : sourceCache.keySet()) {
    EngineAssetManager.getInstance().disposeAtlas(key);
  }
  sourceCache.clear();
  currentSource=null;
}","@Override public void dispose(){
  for (  ImageCacheEntry entry : sourceCache.values()) {
    EngineAssetManager.getInstance().disposeTexture(entry.tex);
  }
  sourceCache.clear();
  currentSource=null;
}",0.2365038560411311
30368,"@Override public void show(){
  int wWidth=EngineAssetManager.getInstance().getResolution().portraitWidth;
  int wHeight=EngineAssetManager.getInstance().getResolution().portraitHeight;
  stage=new Stage(new ExtendViewport(wWidth,wHeight));
  Table table=new Table();
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setScreen(State.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  ImageButton back=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(BACK_COMMAND)));
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.SCENE_SCREEN);
    }
  }
);
  table.add(back).pad(MARGIN);
  ImageButton reload=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(RELOAD_COMMAND)));
  reload.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.RESTART_SCREEN);
    }
  }
);
  table.add(reload).pad(MARGIN);
  ImageButton help=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(HELP_COMMAND)));
  help.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.HELP_SCREEN);
    }
  }
);
  table.add(help).pad(MARGIN);
  ImageButton credits=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(CREDITS_COMMAND)));
  credits.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.CREDIT_SCREEN);
    }
  }
);
  table.add(credits).pad(MARGIN);
  ImageButton quit=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(QUIT_COMMAND)));
  quit.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Gdx.app.exit();
    }
  }
);
  table.add(quit).pad(MARGIN);
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}","@Override public void show(){
  int wWidth=EngineAssetManager.getInstance().getResolution().portraitWidth;
  int wHeight=EngineAssetManager.getInstance().getResolution().portraitHeight;
  stage=new Stage(new ExtendViewport(wWidth,wHeight / 2));
  Table table=new Table();
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setScreen(State.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  ImageButton back=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(BACK_COMMAND)));
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.SCENE_SCREEN);
    }
  }
);
  table.add(back).pad(MARGIN);
  ImageButton reload=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(RELOAD_COMMAND)));
  reload.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.RESTART_SCREEN);
    }
  }
);
  table.add(reload).pad(MARGIN);
  ImageButton help=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(HELP_COMMAND)));
  help.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.HELP_SCREEN);
    }
  }
);
  table.add(help).pad(MARGIN);
  ImageButton credits=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(CREDITS_COMMAND)));
  credits.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.CREDIT_SCREEN);
    }
  }
);
  table.add(credits).pad(MARGIN);
  ImageButton quit=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(QUIT_COMMAND)));
  quit.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Gdx.app.exit();
    }
  }
);
  table.add(quit).pad(MARGIN);
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}",0.9990871748060246
30369,"@Override public void dispose(){
  for (  String key : sourceCache.keySet()) {
    EngineAssetManager.getInstance().disposeAtlas(key);
  }
  sourceCache.clear();
  currentSource=null;
}","@Override public void dispose(){
  for (  String key : sourceCache.keySet()) {
    disposeSource(key);
  }
  sourceCache.clear();
  currentSource=null;
}",0.8698224852071006
30370,"@Override public void show(){
  int wWidth=EngineAssetManager.getInstance().getResolution().portraitWidth;
  int wHeight=EngineAssetManager.getInstance().getResolution().portraitHeight;
  stage=new Stage(new ExtendViewport(wWidth,wHeight));
  Table table=new Table();
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setScreen(State.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  ImageButton back=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(BACK_COMMAND)));
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.SCENE_SCREEN);
    }
  }
);
  table.add(back).pad(MARGIN);
  ImageButton reload=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(RELOAD_COMMAND)));
  reload.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.RESTART_SCREEN);
    }
  }
);
  table.add(reload).pad(MARGIN);
  ImageButton help=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(HELP_COMMAND)));
  help.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.HELP_SCREEN);
    }
  }
);
  table.add(help).pad(MARGIN);
  ImageButton credits=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(CREDITS_COMMAND)));
  credits.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.CREDIT_SCREEN);
    }
  }
);
  table.add(credits).pad(MARGIN);
  ImageButton quit=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(QUIT_COMMAND)));
  quit.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Gdx.app.exit();
    }
  }
);
  table.add(quit).pad(MARGIN);
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}","@Override public void show(){
  int wWidth=EngineAssetManager.getInstance().getResolution().portraitWidth;
  int wHeight=EngineAssetManager.getInstance().getResolution().portraitHeight;
  stage=new Stage(new ExtendViewport(wWidth,wHeight / 2));
  Table table=new Table();
  table.setFillParent(true);
  table.center();
  table.addListener(new InputListener(){
    @Override public boolean keyUp(    InputEvent event,    int keycode){
      if (keycode == Input.Keys.ESCAPE || keycode == Input.Keys.BACK)       ui.setScreen(State.SCENE_SCREEN);
      return true;
    }
  }
);
  stage.setKeyboardFocus(table);
  ImageButton back=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(BACK_COMMAND)));
  back.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.SCENE_SCREEN);
    }
  }
);
  table.add(back).pad(MARGIN);
  ImageButton reload=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(RELOAD_COMMAND)));
  reload.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.RESTART_SCREEN);
    }
  }
);
  table.add(reload).pad(MARGIN);
  ImageButton help=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(HELP_COMMAND)));
  help.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.HELP_SCREEN);
    }
  }
);
  table.add(help).pad(MARGIN);
  ImageButton credits=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(CREDITS_COMMAND)));
  credits.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      ui.setScreen(State.CREDIT_SCREEN);
    }
  }
);
  table.add(credits).pad(MARGIN);
  ImageButton quit=new ImageButton(new TextureRegionDrawable(ui.getUIAtlas().findRegion(QUIT_COMMAND)));
  quit.addListener(new ClickListener(){
    public void clicked(    InputEvent event,    float x,    float y){
      Gdx.app.exit();
    }
  }
);
  table.add(quit).pad(MARGIN);
  table.pack();
  stage.addActor(table);
  Gdx.input.setInputProcessor(stage);
}",0.9990871748060246
30371,"@Override protected void create(){
  EditElementDialog dialog=getEditElementDialogInstance(null);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      int pos=list.getSelectedIndex();
      if (pos == -1)       pos=0;
 else       pos++;
      Element e=((EditElementDialog)actor).getElement();
      list.getItems().insert(pos,e);
      int i=getItems().indexOf(e,true);
      if (i != -1)       list.setSelectedIndex(i);
      list.invalidateHierarchy();
    }
  }
);
}","@Override protected void create(){
  EditElementDialog dialog=getEditElementDialogInstance(null);
  dialog.show(getStage());
  dialog.setListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      int pos=list.getSelectedIndex();
      Element e2=null;
      pos++;
      if (pos != 0 && pos < list.getItems().size)       e2=list.getItems().get(pos);
      Element e=((EditElementDialog)actor).getElement();
      list.getItems().insert(pos,e);
      Node parent=e.getParentNode();
      parent.removeChild(e);
      parent.insertBefore(e,e2);
      int i=getItems().indexOf(e,true);
      if (i != -1)       list.setSelectedIndex(i);
      list.invalidateHierarchy();
    }
  }
);
}",0.819369715603382
30372,"@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex();
  if (pos == -1)   pos=0;
 else   pos++;
  Element e=((EditElementDialog)actor).getElement();
  list.getItems().insert(pos,e);
  int i=getItems().indexOf(e,true);
  if (i != -1)   list.setSelectedIndex(i);
  list.invalidateHierarchy();
}","@Override public void changed(ChangeEvent event,Actor actor){
  int pos=list.getSelectedIndex();
  Element e2=null;
  pos++;
  if (pos != 0 && pos < list.getItems().size)   e2=list.getItems().get(pos);
  Element e=((EditElementDialog)actor).getElement();
  list.getItems().insert(pos,e);
  Node parent=e.getParentNode();
  parent.removeChild(e);
  parent.insertBefore(e,e2);
  int i=getItems().indexOf(e,true);
  if (i != -1)   list.setSelectedIndex(i);
  list.invalidateHierarchy();
}",0.7423687423687424
30373,"@Override public TextureRegion getCellImage(Element e){
  String iconName=MessageFormat.format(""String_Node_Str"",e.getAttribute(""String_Node_Str""));
  TextureRegion image=null;
  try {
    image=Ctx.assetManager.getIcon(iconName);
  }
 catch (  GdxRuntimeException e1) {
    image=Ctx.assetManager.getIcon(""String_Node_Str"");
  }
  return image;
}","@Override public TextureRegion getCellImage(Element e){
  String iconName=MessageFormat.format(""String_Node_Str"",e.getAttribute(""String_Node_Str""));
  TextureRegion image=null;
  image=Ctx.assetManager.getIcon(iconName);
  if (image == null)   image=Ctx.assetManager.getIcon(""String_Node_Str"");
  return image;
}",0.6798179059180577
30374,"public void addElements(BaseDocument doc,Element parent,String tag){
  this.doc=doc;
  this.parent=parent;
  list.getItems().clear();
  list.getSelection().clear();
  if (parent != null) {
    NodeList nl;
    if (tag == null)     nl=parent.getChildNodes();
 else {
      nl=doc.getChildrenByTag(parent,tag);
    }
    for (int i=0; i < nl.getLength(); i++) {
      if (nl.item(i) instanceof Element)       addItem((Element)nl.item(i));
    }
  }
  if (getItems().size > 0)   list.setSelectedIndex(0);
  toolbar.disableEdit(list.getSelectedIndex() < 0);
  if (sorted) {
    list.getItems().sort(new Comparator<Element>(){
      @Override public int compare(      Element o1,      Element o2){
        return o1.getAttribute(""String_Node_Str"").compareTo(o2.getAttribute(""String_Node_Str""));
      }
    }
);
  }
  toolbar.disableCreate(parent == null);
  invalidateHierarchy();
}","public void addElements(BaseDocument doc,Element parent,String tag){
  this.doc=doc;
  this.parent=parent;
  list.getItems().clear();
  list.getSelection().clear();
  if (parent != null) {
    NodeList nl;
    if (tag == null)     nl=parent.getChildNodes();
 else {
      nl=doc.getChildrenByTag(parent,tag);
    }
    for (int i=0; i < nl.getLength(); i++) {
      if (nl.item(i) instanceof Element)       addItem((Element)nl.item(i));
    }
  }
  if (getItems().size > 0)   list.setSelectedIndex(0);
  toolbar.disableEdit(list.getSelectedIndex() < 0);
  if (sorted) {
    list.getItems().sort(new Comparator<Element>(){
      @Override public int compare(      Element o1,      Element o2){
        return o1.getAttribute(""String_Node_Str"").compareTo(o2.getAttribute(""String_Node_Str""));
      }
    }
);
  }
  toolbar.disableCreate(parent == null);
  list.invalidateHierarchy();
}",0.997160704145372
30375,"public void removeActor(Actor a){
  Actor res=null;
  if (a.getId().equals(player)) {
    player=null;
  }
  res=actors.remove(a.getId());
  if (res == null)   fgActors.remove(a);
 else   dynamicActors.remove(a);
  if (a.isWalkObstacle() && polygonalNavGraph != null)   polygonalNavGraph.removeDinamicObstacle(a.getBBox());
}","public void removeActor(Actor a){
  if (a.getId().equals(player)) {
    player=null;
  }
  actors.remove(a.getId());
switch (a.getLayer()) {
case BACKGROUND:
    bgActors.remove(a);
  break;
case DYNAMIC:
dynamicActors.remove(a);
break;
case FOREGROUND:
fgActors.remove(a);
break;
}
if (a.isWalkObstacle() && polygonalNavGraph != null) polygonalNavGraph.removeDinamicObstacle(a.getBBox());
}",0.6312849162011173
30376,"private void init(){
  scenes=new HashMap<String,Scene>();
  inventory=new Inventory();
  textManager=new TextManager();
  timers=new Timers();
  cutMode=false;
  timeOfGame=0;
  customProperties=new HashMap<String,String>();
  spriteBatch=new SpriteBatch();
  disposed=false;
}","private void init(){
  scenes=new HashMap<String,Scene>();
  inventory=new Inventory();
  textManager=new TextManager();
  timers=new Timers();
  cutMode=false;
  timeOfGame=0;
  chapter=null;
  customProperties=new HashMap<String,String>();
  spriteBatch=new SpriteBatch();
  disposed=false;
}",0.972027972027972
30377,"@Override public void clicked(InputEvent event,float x,float y){
  Scene scn=scnWidget.getScene();
  if (scn == null)   return;
  Vector2 p=new Vector2(Gdx.input.getX(),Gdx.input.getY());
  scnWidget.screenToWorldCoords(p);
  if (deleteObstacle) {
    deleteObstacle=false;
    Ctx.msg.hide();
    PolygonalNavGraph pf=scn.getPolygonalNavGraph();
    ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
    for (int j=0; j < obstacles.size(); j++) {
      Polygon o=obstacles.get(j);
      if (o.contains(p.x,p.y)) {
        Ctx.project.getSelectedChapter().deleteObstacle(Ctx.project.getSelectedScene(),j);
        pf.getObstacles().remove(j);
        return;
      }
    }
  }
  if (getTapCount() == 2) {
    Polygon poly=scnWidget.getSelectedActor().getBBox();
    if (scn.getPolygonalNavGraph() != null && scnWidget.getShowWalkZone()) {
      poly=scn.getPolygonalNavGraph().getWalkZone();
      ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
          return;
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            deleted=PolygonUtils.deletePoint(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (deleted) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              return;
            }
          }
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
          return;
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            created=PolygonUtils.addClampPointIfTolerance(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (created) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              return;
            }
          }
        }
      }
    }
    if (!(scnWidget.getSelectedActor() instanceof SpriteActor) || !((SpriteActor)scnWidget.getSelectedActor()).isBboxFromRenderer()) {
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted) {
          Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
          return;
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
          return;
        }
      }
    }
  }
}","@Override public void clicked(InputEvent event,float x,float y){
  Scene scn=scnWidget.getScene();
  if (scn == null)   return;
  Vector2 p=new Vector2(Gdx.input.getX(),Gdx.input.getY());
  scnWidget.screenToWorldCoords(p);
  if (deleteObstacle) {
    deleteObstacle=false;
    Ctx.msg.hide();
    PolygonalNavGraph pf=scn.getPolygonalNavGraph();
    ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
    for (int j=0; j < obstacles.size(); j++) {
      Polygon o=obstacles.get(j);
      if (o.contains(p.x,p.y)) {
        Ctx.project.getSelectedChapter().deleteObstacle(Ctx.project.getSelectedScene(),j);
        pf.getObstacles().remove(j);
        return;
      }
    }
  }
  if (getTapCount() == 2) {
    if (scn.getPolygonalNavGraph() != null && scnWidget.getShowWalkZone()) {
      Polygon poly=scn.getPolygonalNavGraph().getWalkZone();
      ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
          return;
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            deleted=PolygonUtils.deletePoint(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (deleted) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              return;
            }
          }
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
          return;
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            created=PolygonUtils.addClampPointIfTolerance(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (created) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              return;
            }
          }
        }
      }
    }
    if (scnWidget.getSelectedActor() != null) {
      Polygon poly=scnWidget.getSelectedActor().getBBox();
      if (!(scnWidget.getSelectedActor() instanceof SpriteActor) || !((SpriteActor)scnWidget.getSelectedActor()).isBboxFromRenderer()) {
        if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
          boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
          if (deleted) {
            Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
            return;
          }
        }
 else {
          boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
          if (created) {
            Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
            return;
          }
        }
      }
    }
  }
}",0.9661016949152542
30378,"public Element cloneNode(Element e){
  Element cloned;
  if (e.getOwnerDocument() != doc) {
    cloned=(Element)doc.importNode(e,true);
  }
 else {
    cloned=(Element)e.cloneNode(true);
  }
  return cloned;
}","public Element cloneNode(Element parent,Element e){
  Element cloned;
  if (e.getOwnerDocument() != doc) {
    cloned=(Element)doc.importNode(e,true);
  }
 else {
    cloned=(Element)e.cloneNode(true);
  }
  parent.appendChild(cloned);
  if (cloned.getAttribute(""String_Node_Str"") != null && !cloned.getAttribute(""String_Node_Str"").isEmpty()) {
    cloned.setAttribute(""String_Node_Str"",getCheckedId(cloned,cloned.getAttribute(""String_Node_Str"")));
  }
  setModified(cloned);
  return cloned;
}",0.5519203413940256
30379,"/** 
 * Sets the element id avoiding duplicated ids
 * @param e
 * @param id
 */
public void setId(Element e,String id){
  String idChecked=id;
  if (e.getParentNode() instanceof Element) {
    NodeList nl=((Element)e.getParentNode()).getElementsByTagName(e.getTagName());
    boolean checked=false;
    int i=1;
    while (!checked) {
      checked=true;
      for (int j=0; j < nl.getLength(); j++) {
        Element e2=(Element)nl.item(j);
        if (e2.getAttribute(""String_Node_Str"").equals(idChecked) && e != e2) {
          i++;
          idChecked=id + i;
          checked=false;
          break;
        }
      }
    }
  }
  setRootAttr(e,""String_Node_Str"",idChecked);
}","/** 
 * Sets the element id avoiding duplicated ids
 * @param e
 * @param id
 */
public void setId(Element e,String id){
  String idChecked=getCheckedId(e,id);
  setRootAttr(e,""String_Node_Str"",idChecked);
}",0.3509561304836895
30380,"@Override public void clicked(InputEvent event,float x,float y){
  Scene scn=scnWidget.getScene();
  if (scn == null)   return;
  Vector2 p=new Vector2(Gdx.input.getX(),Gdx.input.getY());
  scnWidget.screenToWorldCoords(p);
  if (deleteObstacle) {
    deleteObstacle=false;
    Ctx.msg.hide();
    PolygonalNavGraph pf=scn.getPolygonalNavGraph();
    ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
    for (int j=0; j < obstacles.size(); j++) {
      Polygon o=obstacles.get(j);
      if (o.contains(p.x,p.y)) {
        Ctx.project.getSelectedChapter().deleteObstacle(Ctx.project.getSelectedScene(),j);
        pf.getObstacles().remove(j);
        return;
      }
    }
  }
  if (getTapCount() == 2) {
    Polygon poly=scnWidget.getSelectedActor().getBBox();
    if (scn.getPolygonalNavGraph() != null && scnWidget.getShowWalkZone()) {
      poly=scn.getPolygonalNavGraph().getWalkZone();
      ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted)         Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            deleted=PolygonUtils.deletePoint(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (deleted) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              break;
            }
          }
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            created=PolygonUtils.addClampPointIfTolerance(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (created) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              break;
            }
          }
        }
      }
    }
    if (!(scnWidget.getSelectedActor() instanceof SpriteActor) || !((SpriteActor)scnWidget.getSelectedActor()).isBboxFromRenderer()) {
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted) {
          Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
          return;
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
          return;
        }
      }
    }
  }
}","@Override public void clicked(InputEvent event,float x,float y){
  Scene scn=scnWidget.getScene();
  if (scn == null)   return;
  Vector2 p=new Vector2(Gdx.input.getX(),Gdx.input.getY());
  scnWidget.screenToWorldCoords(p);
  if (deleteObstacle) {
    deleteObstacle=false;
    Ctx.msg.hide();
    PolygonalNavGraph pf=scn.getPolygonalNavGraph();
    ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
    for (int j=0; j < obstacles.size(); j++) {
      Polygon o=obstacles.get(j);
      if (o.contains(p.x,p.y)) {
        Ctx.project.getSelectedChapter().deleteObstacle(Ctx.project.getSelectedScene(),j);
        pf.getObstacles().remove(j);
        return;
      }
    }
  }
  if (getTapCount() == 2) {
    Polygon poly=scnWidget.getSelectedActor().getBBox();
    if (scn.getPolygonalNavGraph() != null && scnWidget.getShowWalkZone()) {
      poly=scn.getPolygonalNavGraph().getWalkZone();
      ArrayList<Polygon> obstacles=scn.getPolygonalNavGraph().getObstacles();
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
          return;
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            deleted=PolygonUtils.deletePoint(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (deleted) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              return;
            }
          }
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setWalkZonePolygon(Ctx.project.getSelectedScene(),poly);
          return;
        }
 else {
          for (int i=0; i < obstacles.size(); i++) {
            Polygon o=obstacles.get(i);
            created=PolygonUtils.addClampPointIfTolerance(o,p.x,p.y,CanvasDrawer.CORNER_DIST);
            if (created) {
              Ctx.project.getSelectedChapter().setObstaclePolygon(Ctx.project.getSelectedScene(),i,o);
              return;
            }
          }
        }
      }
    }
    if (!(scnWidget.getSelectedActor() instanceof SpriteActor) || !((SpriteActor)scnWidget.getSelectedActor()).isBboxFromRenderer()) {
      if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) {
        boolean deleted=PolygonUtils.deletePoint(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (deleted) {
          Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
          return;
        }
      }
 else {
        boolean created=PolygonUtils.addClampPointIfTolerance(poly,p.x,p.y,CanvasDrawer.CORNER_DIST);
        if (created) {
          Ctx.project.getSelectedChapter().setBbox(Ctx.project.getSelectedActor(),poly);
          return;
        }
      }
    }
  }
}",0.9879799666110184
30381,"public void addElements(BaseDocument doc,Element parent,String tag){
  this.doc=doc;
  this.parent=parent;
  list.getItems().clear();
  list.getSelection().clear();
  ;
  if (parent != null) {
    NodeList nl;
    if (tag == null)     nl=parent.getChildNodes();
 else {
      nl=doc.getChildrenByTag(parent,tag);
    }
    for (int i=0; i < nl.getLength(); i++) {
      if (nl.item(i) instanceof Element)       addItem((Element)nl.item(i));
    }
  }
  if (getItems().size > 0)   list.setSelectedIndex(0);
  toolbar.disableEdit(list.getSelectedIndex() < 0);
  if (sorted) {
    list.getItems().sort(new Comparator<Element>(){
      @Override public int compare(      Element o1,      Element o2){
        return o1.getAttribute(""String_Node_Str"").compareTo(o2.getAttribute(""String_Node_Str""));
      }
    }
);
  }
  toolbar.disableCreate(parent == null);
  invalidateHierarchy();
}","public void addElements(BaseDocument doc,Element parent,String tag){
  this.doc=doc;
  this.parent=parent;
  list.getItems().clear();
  list.getSelection().clear();
  if (parent != null) {
    NodeList nl;
    if (tag == null)     nl=parent.getChildNodes();
 else {
      nl=doc.getChildrenByTag(parent,tag);
    }
    for (int i=0; i < nl.getLength(); i++) {
      if (nl.item(i) instanceof Element)       addItem((Element)nl.item(i));
    }
  }
  if (getItems().size > 0)   list.setSelectedIndex(0);
  toolbar.disableEdit(list.getSelectedIndex() < 0);
  if (sorted) {
    list.getItems().sort(new Comparator<Element>(){
      @Override public int compare(      Element o1,      Element o2){
        return o1.getAttribute(""String_Node_Str"").compareTo(o2.getAttribute(""String_Node_Str""));
      }
    }
);
  }
  toolbar.disableCreate(parent == null);
  invalidateHierarchy();
}",0.9977272727272728
30382,"@Override protected void paste(){
  Element newElement=doc.cloneNode(clipboard);
  parent.appendChild(newElement);
  if (newElement.getAttribute(""String_Node_Str"") != null && !newElement.getAttribute(""String_Node_Str"").isEmpty()) {
    doc.setId(newElement,newElement.getAttribute(""String_Node_Str""));
  }
  addItem(newElement);
  int i=getItems().indexOf(newElement,true);
  list.setSelectedIndex(i);
}","@Override protected void paste(){
  Element newElement=doc.cloneNode(parent,clipboard);
  addItem(newElement);
  int i=getItems().indexOf(newElement,true);
  list.setSelectedIndex(i);
}",0.6054421768707483
30383,"@SuppressWarnings(""String_Node_Str"") public EditActionDialog(Skin skin,BaseDocument doc,Element parent,Element e){
  super(skin);
  String[] actions=ActionFactory.getActionList();
  Arrays.sort(actions);
  String[] actions2=new String[actions.length + 1];
  System.arraycopy(actions,0,actions2,0,actions.length);
  actions2[actions2.length - 1]=""String_Node_Str"";
  actionPanel=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",actions2);
  actorPanel=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  classPanel=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",true);
  customParams=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  setAction();
  ((SelectBox<String>)actionPanel.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setAction();
    }
  }
);
  if (e != null) {
    actionPanel.setText(e.getTagName());
    actorPanel.setText(e.getAttribute(""String_Node_Str""));
    classPanel.setText(e.getAttribute(""String_Node_Str""));
  }
  init(parameters,getAttrs(),doc,parent,""String_Node_Str"",e);
}","@SuppressWarnings(""String_Node_Str"") public EditActionDialog(Skin skin,BaseDocument doc,Element parent,Element e){
  super(skin);
  String[] actions=ActionFactory.getActionList();
  Arrays.sort(actions);
  String[] actions2=new String[actions.length + 1];
  System.arraycopy(actions,0,actions2,0,actions.length);
  actions2[actions2.length - 1]=""String_Node_Str"";
  actionPanel=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",actions2);
  actorPanel=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  classPanel=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",true);
  customParams=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  setAction();
  ((SelectBox<String>)actionPanel.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setAction();
    }
  }
);
  if (e != null) {
    actionPanel.setText(e.getTagName());
    actorPanel.setText(e.getAttribute(""String_Node_Str""));
    classPanel.setText(e.getAttribute(""String_Node_Str""));
  }
  if (e != null && !e.getAttribute(""String_Node_Str"").isEmpty()) {
    actionPanel.setText(e.getAttribute(""String_Node_Str""));
    setAction();
  }
  init(parameters,getAttrs(),doc,parent,""String_Node_Str"",e);
}",0.8945147679324894
30384,"@Override protected void fill(){
  String actor=actorPanel.getText().trim();
  NamedNodeMap attributes=e.getAttributes();
  int l=attributes.getLength();
  for (int i=0; i < l; i++)   e.removeAttribute(attributes.item(i).getLocalName());
  if (!actor.isEmpty())   e.setAttribute(""String_Node_Str"",actor);
  String id=actionPanel.getText();
  if (id.equals(""String_Node_Str"")) {
    e.setAttribute(""String_Node_Str"",classPanel.getText());
  }
 else {
    e.setAttribute(""String_Node_Str"",id);
    super.fill();
  }
}","@Override protected void fill(){
  String actor=actorPanel.getText().trim();
  while (e.getAttributes().getLength() > 0) {
    e.removeAttribute(e.getAttributes().item(0).getNodeName());
  }
  if (!actor.isEmpty())   e.setAttribute(""String_Node_Str"",actor);
  String id=actionPanel.getText();
  if (id.equals(""String_Node_Str"")) {
    e.setAttribute(""String_Node_Str"",classPanel.getText());
  }
 else {
    e.setAttribute(""String_Node_Str"",id);
    super.fill();
  }
}",0.7324516785350966
30385,"public void setDesc(String s){
  if (!freezeHotSpot) {
    desc=s;
    if (desc.charAt(0) == '@')     desc=I18N.getString(desc.substring(1));
  }
}","public void setDesc(String s){
  if (!freezeHotSpot) {
    desc=s;
    if (desc != null && desc.charAt(0) == '@')     desc=I18N.getString(desc.substring(1));
  }
}",0.9483870967741936
30386,"@Override public void resize(int width,int height){
  viewport.update(width,height,true);
  ui.getPointer().resize(width,height);
}","@Override public void resize(int width,int height){
  viewport.update(width,height,true);
}",0.8198198198198198
30387,"@Override public void resize(int width,int height){
  stage.getViewport().update(width,height,true);
  ui.getPointer().resize(width,height);
}","@Override public void resize(int width,int height){
  stage.getViewport().update(width,height,true);
}",0.8360655737704918
30388,"private void getInputUnproject(Viewport v,Vector2 out){
  out.set(Gdx.input.getX(),Gdx.input.getY());
  v.unproject(out);
  if (out.x >= v.getWorldWidth())   out.x=v.getWorldWidth() - 1;
 else   if (out.x < 0)   out.x=0;
  if (out.y >= v.getWorldHeight())   out.y=v.getWorldHeight() - 1;
 else   if (out.y < 0)   out.y=0;
}","private void getInputUnproject(Viewport v,Vector2 out){
  out.set(Gdx.input.getX(),Gdx.input.getY());
  v.unproject(out);
}",0.5515695067264574
30389,"public void getInputUnProject(Vector3 out){
  out.set(Gdx.input.getX(),Gdx.input.getY(),0);
  unproject(out);
  if (out.x >= viewportWidth)   out.x=viewportWidth - 1;
 else   if (out.x < 0)   out.x=0;
  if (out.y >= viewportHeight)   out.y=viewportHeight - 1;
 else   if (out.y < 0)   out.y=0;
}","public void getInputUnProject(Vector3 out){
  out.set(Gdx.input.getX(),Gdx.input.getY(),0);
  unproject(out);
}",0.5467980295566502
30390,"public void touchEvent(int type,float x,float y,int pointer,int button){
switch (type) {
case SceneInputProcessor.TOUCH_UP:
    if (draggedActor != null) {
      stopDragging((int)x,(int)y);
    }
 else     if (collapsedBbox.contains(x,y)) {
      if (collapsed)       collapse(false);
 else       collapse(true);
    }
 else     if (configBbox.contains(x,y)) {
      sceneScreen.showMenu();
    }
 else {
      Actor actor=getItemAt(x,y);
      if (actor != null) {
        sceneScreen.actorClick(actor,pointer == 1);
      }
 else {
        updateScroll(x,y);
      }
    }
  break;
case SceneInputProcessor.TOUCH_DOWN:
break;
case SceneInputProcessor.DRAG:
startDragging(x,y);
break;
}
}","public void touchEvent(int type,float x,float y,int pointer,int button){
switch (type) {
case SceneInputProcessor.TOUCH_UP:
    if (draggedActor != null) {
      stopDragging((int)x,(int)y);
    }
 else     if (collapsedBbox.contains(x,y)) {
      if (collapsed)       collapse(false);
 else       collapse(true);
    }
 else     if (configBbox.contains(x,y)) {
      sceneScreen.showMenu();
    }
 else {
      Actor actor=getItemAt(x,y);
      if (actor != null) {
        sceneScreen.actorClick(actor,button == 1);
      }
 else {
        updateScroll(x,y);
      }
    }
  break;
case SceneInputProcessor.TOUCH_DOWN:
break;
case SceneInputProcessor.DRAG:
startDragging(x,y);
break;
}
}",0.990572878897752
30391,"@SuppressWarnings(""String_Node_Str"") public EditFADialog(Skin skin,BaseDocument doc,Element p,Element e){
  super(skin);
  setInfo(INFO);
  inputs[0]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0]);
  inputs[1]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0]);
  inputs[2]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",ChapterDocument.ANIMATION_TYPES);
  inputs[3]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,true,""String_Node_Str"");
  inputs[4]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,false);
  inputs[5]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.INTEGER,false);
  inputs[6]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  inputs[7]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  inputs[8]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  inputs[9]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"",null);
  inputs[10]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"",null);
  typePanel=inputs[2];
  ((SelectBox<String>)typePanel.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      String type=typePanel.getText();
      if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
        inputs[4].setVisible(true);
        inputs[5].setVisible(true);
      }
 else {
        inputs[4].setVisible(false);
        inputs[5].setVisible(false);
      }
    }
  }
);
  ((SelectBox<String>)inputs[0].getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      EditorLogger.debug(""String_Node_Str"" + inputs[0].getText());
      spriteWidget.setSource(parent.getAttribute(""String_Node_Str""),inputs[0].getText());
      fillAnimations();
    }
  }
);
  ((SelectBox<String>)inputs[1].getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setSprite();
    }
  }
);
  ((TextField)inputs[3].getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setSprite();
    }
  }
);
  inputs[4].setVisible(false);
  inputs[5].setVisible(false);
  init(inputs,attrs,doc,p,""String_Node_Str"",e);
  setInfoWidget(spriteWidget);
  addSources();
  if (inputs[0].getText() != null && !inputs[0].getText().isEmpty()) {
    spriteWidget.setSource(parent.getAttribute(""String_Node_Str""),inputs[0].getText());
    fillAnimations();
  }
}","@SuppressWarnings(""String_Node_Str"") public EditFADialog(Skin skin,BaseDocument doc,Element p,Element e){
  super(skin);
  setInfo(INFO);
  inputs[0]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0]);
  inputs[1]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",new String[0]);
  inputs[2]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",ChapterDocument.ANIMATION_TYPES);
  inputs[3]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,true,""String_Node_Str"");
  inputs[4]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.FLOAT,false);
  inputs[5]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.INTEGER,false);
  inputs[6]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  inputs[7]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.VECTOR2,false);
  inputs[8]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"");
  inputs[9]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"",null);
  inputs[10]=new InputPanel(skin,""String_Node_Str"",""String_Node_Str"",Param.Type.BOOLEAN,true,""String_Node_Str"",null);
  typePanel=inputs[2];
  ((SelectBox<String>)typePanel.getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      String type=typePanel.getText();
      if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
        inputs[4].setVisible(true);
        inputs[5].setVisible(true);
      }
 else {
        inputs[4].setVisible(false);
        inputs[5].setVisible(false);
      }
    }
  }
);
  ((SelectBox<String>)inputs[0].getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      EditorLogger.debug(""String_Node_Str"" + inputs[0].getText());
      spriteWidget.setSource(parent.getAttribute(""String_Node_Str""),inputs[0].getText());
      fillAnimations();
    }
  }
);
  ((SelectBox<String>)inputs[1].getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setSprite();
    }
  }
);
  ((TextField)inputs[3].getField()).addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      setSprite();
    }
  }
);
  inputs[4].setVisible(false);
  inputs[5].setVisible(false);
  setInfoWidget(spriteWidget);
  init(inputs,attrs,doc,p,""String_Node_Str"",e);
  addSources();
  if (e != null) {
    inputs[0].setText(e.getAttribute(attrs[0]));
  }
  if (inputs[0].getText() != null && !inputs[0].getText().isEmpty()) {
    spriteWidget.setSource(parent.getAttribute(""String_Node_Str""),inputs[0].getText());
    fillAnimations();
    if (e != null) {
      inputs[1].setText(e.getAttribute(attrs[1]));
    }
  }
}",0.9485714285714286
30392,"@SuppressWarnings(""String_Node_Str"") public void setText(String text){
  if (field instanceof TextField)   ((TextField)field).setText(text);
 else   if (field instanceof SelectBox<?>)   ((SelectBox<String>)field).setSelected(text);
 else   if (field instanceof Vector2Panel)   ((Vector2Panel)field).setText(text);
 else   if (field instanceof DimPanel)   ((DimPanel)field).setText(text);
}","@SuppressWarnings(""String_Node_Str"") public void setText(String text){
  if (field instanceof TextField)   ((TextField)field).setText(text);
 else   if (field instanceof SelectBox) {
    int idx=((SelectBox<String>)field).getItems().indexOf(text,false);
    if (idx != -1)     ((SelectBox<String>)field).setSelectedIndex(idx);
  }
 else   if (field instanceof Vector2Panel)   ((Vector2Panel)field).setText(text);
 else   if (field instanceof DimPanel)   ((DimPanel)field).setText(text);
}",0.8734321550741163
30393,"private void loadChapter(String id) throws ParserConfigurationException, SAXException, IOException {
  SAXParserFactory spf=SAXParserFactory.newInstance();
  spf.setNamespaceAware(true);
  SAXParser saxParser=spf.newSAXParser();
  ChapterXMLLoader parser=new ChapterXMLLoader();
  XMLReader xmlReader=saxParser.getXMLReader();
  xmlReader.setContentHandler(parser);
  xmlReader.parse(new InputSource(EngineAssetManager.getInstance().getModelFile(id + ""String_Node_Str"").read()));
  I18N.load(EngineAssetManager.MODEL_DIR + ""String_Node_Str"",EngineAssetManager.MODEL_DIR + id);
  scenes=parser.getScenes();
  initScene=parser.getInitScene();
}","private void loadChapter(String id) throws ParserConfigurationException, SAXException, IOException {
  SAXParserFactory spf=SAXParserFactory.newInstance();
  spf.setNamespaceAware(true);
  SAXParser saxParser=spf.newSAXParser();
  ChapterXMLLoader parser=new ChapterXMLLoader();
  XMLReader xmlReader=saxParser.getXMLReader();
  xmlReader.setContentHandler(parser);
  xmlReader.parse(new InputSource(EngineAssetManager.getInstance().getModelFile(id + ""String_Node_Str"").read()));
  I18N.load(EngineAssetManager.MODEL_DIR + ""String_Node_Str"",EngineAssetManager.MODEL_DIR + id);
  scenes=parser.getScenes();
  initScene=parser.getInitScene();
  if (initScene == null && scenes.size() > 0)   initScene=scenes.get(0).getId();
}",0.9406593406593406
30394,"private AtlasFrameAnimation getFrameAnimation(String id){
  AtlasFrameAnimation fa=(AtlasFrameAnimation)fanims.get(id);
  flipX=false;
  if (fa == null && id != null) {
    String flipId=FrameAnimation.getFlipId(id);
    fa=(AtlasFrameAnimation)fanims.get(flipId);
    if (fa != null)     flipX=true;
 else {
      StringBuilder sb=new StringBuilder();
      if (id.endsWith(FrameAnimation.LEFT)) {
        sb.append(id.substring(0,id.length() - 4));
        sb.append(""String_Node_Str"");
      }
 else       if (id.endsWith(FrameAnimation.FRONTLEFT)) {
        sb.append(id.substring(0,id.length() - 9));
        sb.append(""String_Node_Str"");
      }
 else       if (id.endsWith(FrameAnimation.RIGHT)) {
        sb.append(id.substring(0,id.length() - 5));
        sb.append(""String_Node_Str"");
      }
 else       if (id.endsWith(FrameAnimation.FRONTRIGHT)) {
        sb.append(id.substring(0,id.length() - 10));
        sb.append(""String_Node_Str"");
      }
      String s=sb.toString();
      fa=(AtlasFrameAnimation)fanims.get(s);
      if (fa == null) {
        flipId=FrameAnimation.getFlipId(s);
        fa=(AtlasFrameAnimation)fanims.get(flipId);
        if (fa != null)         flipX=true;
      }
    }
  }
  return fa;
}","private AtlasFrameAnimation getFrameAnimation(String id){
  FrameAnimation fa=fanims.get(id);
  flipX=false;
  if (fa == null) {
    String flipId=FrameAnimation.getFlipId(id);
    fa=fanims.get(flipId);
    if (fa != null)     flipX=true;
 else {
      StringBuilder sb=new StringBuilder();
      if (id.endsWith(FrameAnimation.FRONTLEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.LEFT);
      }
 else       if (id.endsWith(FrameAnimation.FRONTRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.RIGHT);
      }
 else       if (id.endsWith(FrameAnimation.BACKLEFT) || id.endsWith(FrameAnimation.BACKRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.BACK);
      }
 else       if (id.endsWith(FrameAnimation.LEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTLEFT);
      }
 else       if (id.endsWith(FrameAnimation.RIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTRIGHT);
      }
      String s=sb.toString();
      fa=fanims.get(s);
      if (fa == null) {
        flipId=FrameAnimation.getFlipId(s);
        fa=fanims.get(flipId);
        if (fa != null)         flipX=true;
      }
    }
  }
  return (AtlasFrameAnimation)fa;
}",0.3793626707132018
30395,"@Override public void update(float delta){
  if (currentSkeleton != null && currentSkeleton.skeleton != null) {
    currentSkeleton.animation.update(delta);
    currentSkeleton.animation.apply(currentSkeleton.skeleton);
    currentSkeleton.skeleton.updateWorldTransform();
    bounds.update(currentSkeleton.skeleton,true);
  }
}","@Override public void update(float delta){
  if (currentSkeleton != null && currentSkeleton.skeleton != null) {
    currentSkeleton.skeleton.update(delta);
    currentSkeleton.animation.update(delta);
    currentSkeleton.animation.apply(currentSkeleton.skeleton);
    currentSkeleton.skeleton.updateWorldTransform();
    bounds.update(currentSkeleton.skeleton,true);
  }
}",0.9371428571428572
30396,"private FrameAnimation getFrameAnimation(String id){
  FrameAnimation fa=fanims.get(id);
  flipX=false;
  if (fa == null) {
    String flipId=FrameAnimation.getFlipId(id);
    fa=fanims.get(flipId);
    if (fa != null)     flipX=true;
 else {
      StringBuilder sb=new StringBuilder();
      if (id.endsWith(FrameAnimation.FRONTLEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.LEFT);
      }
 else       if (id.endsWith(FrameAnimation.FRONTRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.RIGHT);
      }
 else       if (id.endsWith(FrameAnimation.BACKLEFT) || id.endsWith(FrameAnimation.BACKRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.BACK);
      }
 else       if (id.endsWith(FrameAnimation.LEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTLEFT);
      }
 else       if (id.endsWith(FrameAnimation.RIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTRIGHT);
      }
      String s=sb.toString();
      fa=fanims.get(s);
      if (fa == null) {
        flipId=FrameAnimation.getFlipId(s);
        fa=fanims.get(flipId);
        if (fa != null)         flipX=true;
      }
    }
  }
  return fa;
}","private FrameAnimation getFrameAnimation(String id){
  FrameAnimation fa=fanims.get(id);
  flipX=false;
  if (fa == null) {
    String flipId=FrameAnimation.getFlipId(id);
    fa=fanims.get(flipId);
    if (fa != null)     flipX=true;
 else {
      StringBuilder sb=new StringBuilder();
      if (id.endsWith(FrameAnimation.FRONTLEFT) || id.endsWith(FrameAnimation.FRONTRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONT);
      }
 else       if (id.endsWith(FrameAnimation.BACKLEFT) || id.endsWith(FrameAnimation.BACKRIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.BACK);
      }
 else       if (id.endsWith(FrameAnimation.LEFT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTLEFT);
      }
 else       if (id.endsWith(FrameAnimation.RIGHT)) {
        sb.append(id.substring(0,id.lastIndexOf('.') + 1));
        sb.append(FrameAnimation.FRONTRIGHT);
      }
      String s=sb.toString();
      fa=fanims.get(s);
      if (fa == null) {
        flipId=FrameAnimation.getFlipId(s);
        fa=fanims.get(flipId);
        if (fa != null)         flipX=true;
      }
    }
  }
  return fa;
}",0.9476082004555808
30397,"private void retrieveSource(String source){
  SkeletonCacheEntry entry=skeletonCache.get(source);
  if (entry == null || entry.refCounter < 1) {
    loadSource(source);
    EngineAssetManager.getInstance().getManager().finishLoading();
    entry=skeletonCache.get(source);
  }
  if (entry.skeleton == null) {
    TextureAtlas atlas=EngineAssetManager.getInstance().getTextureAtlas(source);
    SkeletonBinary skel=new SkeletonBinary(atlas);
    SkeletonData skeletonData=skel.readSkeletonData(EngineAssetManager.getInstance().getSpine(source));
    entry.skeleton=new Skeleton(skeletonData);
    AnimationStateData stateData=new AnimationStateData(skeletonData);
    stateData.setDefaultMix(0);
    entry.animation=new AnimationState(stateData);
    entry.animation.addListener(animationListener);
  }
}","private void retrieveSource(String source){
  SkeletonCacheEntry entry=skeletonCache.get(source);
  if (entry == null || entry.refCounter < 1) {
    loadSource(source);
    EngineAssetManager.getInstance().getManager().finishLoading();
    entry=skeletonCache.get(source);
  }
  if (entry.skeleton == null) {
    TextureAtlas atlas=EngineAssetManager.getInstance().getTextureAtlas(source);
    SkeletonBinary skel=new SkeletonBinary(atlas);
    SkeletonData skeletonData=skel.readSkeletonData(EngineAssetManager.getInstance().getSpine(source));
    entry.skeleton=new Skeleton(skeletonData);
    AnimationStateData stateData=new AnimationStateData(skeletonData);
    stateData.setDefaultMix(0f);
    entry.animation=new AnimationState(stateData);
    entry.animation.addListener(animationListener);
  }
}",0.9993777224642192
30398,"@Override public void startFrameAnimation(String id,int repeatType,int count,ActionCallback cb){
  FrameAnimation fa=getFrameAnimation(id);
  if (fa == null) {
    EngineLogger.error(""String_Node_Str"" + id);
    return;
  }
  if (currentFrameAnimation != null && currentFrameAnimation.disposeWhenPlayed)   disposeSource(currentFrameAnimation.source);
  currentFrameAnimation=fa;
  currentSkeleton=skeletonCache.get(fa.source);
  animationCb=cb;
  if (currentSkeleton == null || currentSkeleton.refCounter < 1) {
    loadSource(fa.source);
    EngineAssetManager.getInstance().getManager().finishLoading();
    retrieveSource(fa.source);
    currentSkeleton=skeletonCache.get(fa.source);
    if (currentSkeleton == null) {
      EngineLogger.error(""String_Node_Str"" + id);
      currentFrameAnimation=null;
      return;
    }
  }
  if (repeatType == Tween.FROM_FA) {
    currentAnimationType=currentFrameAnimation.animationType;
    currentCount=currentFrameAnimation.count;
  }
 else {
    currentCount=count;
    currentAnimationType=repeatType;
  }
  currentSkeleton.skeleton.setFlipX(flipX);
  currentSkeleton.animation.setAnimation(0,fa.id,currentAnimationType == Tween.REPEAT);
}","@Override public void startFrameAnimation(String id,int repeatType,int count,ActionCallback cb){
  FrameAnimation fa=getFrameAnimation(id);
  if (fa == null) {
    EngineLogger.error(""String_Node_Str"" + id);
    return;
  }
  if (currentFrameAnimation != null && currentFrameAnimation.disposeWhenPlayed)   disposeSource(currentFrameAnimation.source);
  currentFrameAnimation=fa;
  currentSkeleton=skeletonCache.get(fa.source);
  animationCb=cb;
  if (currentSkeleton == null || currentSkeleton.refCounter < 1) {
    loadSource(fa.source);
    EngineAssetManager.getInstance().getManager().finishLoading();
    retrieveSource(fa.source);
    currentSkeleton=skeletonCache.get(fa.source);
    if (currentSkeleton == null) {
      EngineLogger.error(""String_Node_Str"" + id);
      currentFrameAnimation=null;
      return;
    }
  }
  if (repeatType == Tween.FROM_FA) {
    currentAnimationType=currentFrameAnimation.animationType;
    currentCount=currentFrameAnimation.count;
  }
 else {
    currentCount=count;
    currentAnimationType=repeatType;
  }
  currentSkeleton.skeleton.setFlipX(flipX);
  currentSkeleton.animation.setAnimation(0,fa.id,currentAnimationType == Tween.REPEAT);
  currentSkeleton.animation.setTimeScale(fa.duration);
  currentSkeleton.animation.apply(currentSkeleton.skeleton);
}",0.9533386967015286
30399,"@Override public void read(Json json,JsonValue jsonData){
  super.read(json,jsonData);
  scale=json.readValue(""String_Node_Str"",Float.class,jsonData);
  pos=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
  float worldScale=EngineAssetManager.getInstance().getScale();
  pos.x*=worldScale;
  pos.y*=worldScale;
  walkingSpeed=json.readValue(""String_Node_Str"",Float.class,jsonData);
  posTween=json.readValue(""String_Node_Str"",Tween.class,jsonData);
  depthType=json.readValue(""String_Node_Str"",DepthType.class,jsonData);
  renderer=json.readValue(""String_Node_Str"",SpriteRenderer.class,jsonData);
}","@Override public void read(Json json,JsonValue jsonData){
  super.read(json,jsonData);
  scale=json.readValue(""String_Node_Str"",Float.class,jsonData);
  pos=json.readValue(""String_Node_Str"",Vector2.class,jsonData);
  float worldScale=EngineAssetManager.getInstance().getScale();
  pos.x*=worldScale;
  pos.y*=worldScale;
  walkingSpeed=json.readValue(""String_Node_Str"",Float.class,jsonData);
  posTween=json.readValue(""String_Node_Str"",Tween.class,jsonData);
  depthType=json.readValue(""String_Node_Str"",DepthType.class,jsonData);
  renderer=json.readValue(""String_Node_Str"",null,jsonData);
}",0.98
30400,"@Override public void draw(SpriteBatch batch,float x,float y,float originX,float originY,float scale){
  x=x - getWidth() / 2 * scale;
  if (tex == null) {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
    return;
  }
  if (!flipX) {
    batch.draw(tex,x,y,originX,originY,tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
 else {
    batch.draw(tex,x + tex.getRegionWidth() * scale,y,originX,originY,-tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
}","@Override public void draw(SpriteBatch batch,float x,float y,float scale){
  x=x - getWidth() / 2 * scale;
  if (tex == null) {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
    return;
  }
  if (!flipX) {
    batch.draw(tex,x,y,0,0,tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
 else {
    batch.draw(tex,x + tex.getRegionWidth() * scale,y,0,0,-tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
}",0.9353535353535354
30401,"@Override public void draw(SpriteBatch batch,float x,float y,float originX,float originY,float scale){
  if (currentSkeleton != null) {
    currentSkeleton.skeleton.setX(x);
    currentSkeleton.skeleton.setY(y);
    renderer.draw(batch,currentSkeleton.skeleton);
  }
 else {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
  }
}","@Override public void draw(SpriteBatch batch,float x,float y,float scale){
  if (currentSkeleton != null) {
    currentSkeleton.skeleton.setX(x);
    currentSkeleton.skeleton.setY(y);
    renderer.draw(batch,currentSkeleton.skeleton);
  }
 else {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
  }
}",0.96045197740113
30402,"@Override public void draw(SpriteBatch batch,float x,float y,float originX,float originY,float scale){
  x=x - getWidth() / 2 * scale;
  if (USE_FBO) {
    batch.draw(tex,x,y,originX,originY,width,height,scale,scale,0);
  }
 else {
    float p0x, p0y, pfx, pfy;
    Vector3 tmp=new Vector3();
    updateViewport();
    tmp.set(x,y,0);
    tmp.prj(batch.getProjectionMatrix());
    p0x=VIEWPORT.width * (tmp.x + 1) / 2;
    p0y=VIEWPORT.height * (tmp.y + 1) / 2;
    tmp.set(x + width,y + height,0);
    tmp.prj(batch.getProjectionMatrix());
    pfx=VIEWPORT.width * (tmp.x + 1) / 2;
    pfy=VIEWPORT.height * (tmp.y + 1) / 2;
    batch.end();
    Gdx.gl20.glViewport((int)(p0x + VIEWPORT.x),(int)(p0y + VIEWPORT.y),(int)(pfx - p0x),(int)(pfy - p0y));
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | (Gdx.graphics.getBufferFormat().coverageSampling ? GL20.GL_COVERAGE_BUFFER_BIT_NV : 0));
    drawModel();
    Gdx.gl20.glViewport((int)VIEWPORT.x,(int)VIEWPORT.y,(int)VIEWPORT.width,(int)VIEWPORT.height);
    batch.begin();
  }
}","@Override public void draw(SpriteBatch batch,float x,float y,float scale){
  x=x - getWidth() / 2 * scale;
  if (USE_FBO) {
    batch.draw(tex,x,y,0,0,width,height,scale,scale,0);
  }
 else {
    float p0x, p0y, pfx, pfy;
    Vector3 tmp=new Vector3();
    updateViewport();
    tmp.set(x,y,0);
    tmp.prj(batch.getProjectionMatrix());
    p0x=VIEWPORT.width * (tmp.x + 1) / 2;
    p0y=VIEWPORT.height * (tmp.y + 1) / 2;
    tmp.set(x + width,y + height,0);
    tmp.prj(batch.getProjectionMatrix());
    pfx=VIEWPORT.width * (tmp.x + 1) / 2;
    pfy=VIEWPORT.height * (tmp.y + 1) / 2;
    batch.end();
    Gdx.gl20.glViewport((int)(p0x + VIEWPORT.x),(int)(p0y + VIEWPORT.y),(int)(pfx - p0x),(int)(pfy - p0y));
    Gdx.gl.glClear(GL20.GL_DEPTH_BUFFER_BIT | (Gdx.graphics.getBufferFormat().coverageSampling ? GL20.GL_COVERAGE_BUFFER_BIT_NV : 0));
    drawModel();
    Gdx.gl20.glViewport((int)VIEWPORT.x,(int)VIEWPORT.y,(int)VIEWPORT.width,(int)VIEWPORT.height);
    batch.begin();
  }
}",0.9771371769383698
30403,"public void draw(SpriteBatch batch){
  if (isVisible()) {
    renderer.draw(batch,pos.x,pos.y,0,0,scale);
  }
}","public void draw(SpriteBatch batch){
  if (isVisible()) {
    renderer.draw(batch,pos.x,pos.y,scale);
  }
}",0.981651376146789
30404,"public void draw(SpriteBatch batch,float x,float y,float originX,float originY,float scale);","public void draw(SpriteBatch batch,float x,float y,float scale);",0.8205128205128205
30405,"public void draw(SpriteBatch batch,int inputX,int inputY){
  Inventory inventory=World.getInstance().getInventory();
  if (!inventory.isVisible())   return;
  if (autoCollapse) {
    if (previousNumItems != inventory.getNumItems()) {
      previousNumItems=inventory.getNumItems();
      collapse(false);
    }
    updateAutocollapse(inputX,inputY);
  }
  if (collapsed) {
    batch.draw(uncollapseIcon,collapsedBbox.x,collapsedBbox.y,collapsedBbox.width,collapsedBbox.height);
  }
 else {
    boolean horizontal=bbox.width > bbox.height;
    RectangleRenderer.draw(batch,bbox.getX(),bbox.getY(),bbox.getWidth(),bbox.getHeight(),BG_COLOR);
    batch.draw(uncollapseIcon,collapsedBbox.x,collapsedBbox.y,tileSize,tileSize);
    batch.draw(configIcon,configBbox.x,configBbox.y,configBbox.width,configBbox.height);
    if (scrollItemPos == 0) {
      batch.setColor(GRAY);
      batch.draw(leftArrowIcon,horizontal ? (itemsPos - 1) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos - 1) * tileSize,tileSize,tileSize);
      batch.setColor(Color.WHITE);
    }
 else {
      batch.draw(leftArrowIcon,horizontal ? (itemsPos - 1) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos - 1) * tileSize,tileSize,tileSize);
    }
    if (scrollItemPos + itemsSize >= inventory.getNumItems()) {
      batch.setColor(GRAY);
      batch.draw(rightArrowIcon,horizontal ? (itemsPos + itemsSize) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos + itemsSize) * tileSize,tileSize,tileSize);
      batch.setColor(Color.WHITE);
    }
 else {
      batch.draw(rightArrowIcon,horizontal ? (itemsPos + itemsSize) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos + itemsSize) * tileSize,tileSize,tileSize);
    }
    for (int i=scrollItemPos; i < inventory.getNumItems() && itemsSize > i - scrollItemPos; i++) {
      SpriteActor a=inventory.getItem(i);
      float size=tileSize / a.getHeight() / a.getScale();
      a.getRenderer().draw(batch,horizontal ? (i + itemsPos - scrollItemPos) * tileSize : bbox.x,horizontal ? bbox.y : (i + itemsPos - scrollItemPos) * tileSize,0,0,size);
    }
  }
  if (draggedActor != null) {
    float w=draggedActor.getWidth() / draggedActor.getScale();
    float h=draggedActor.getHeight() / draggedActor.getScale();
    float size=tileSize / h * 1.3f;
    draggedActor.getRenderer().draw(batch,inputX - w / 2,inputY - h / 2,w / 2,h / 2,size);
    scrollTime+=Gdx.graphics.getDeltaTime();
    if (scrollTime > SCROLL_TIME) {
      scrollTime=0;
      updateScroll(inputX,inputY);
    }
  }
}","public void draw(SpriteBatch batch,int inputX,int inputY){
  Inventory inventory=World.getInstance().getInventory();
  if (!inventory.isVisible())   return;
  if (autoCollapse) {
    if (previousNumItems != inventory.getNumItems()) {
      previousNumItems=inventory.getNumItems();
      collapse(false);
    }
    updateAutocollapse(inputX,inputY);
  }
  if (collapsed) {
    batch.draw(uncollapseIcon,collapsedBbox.x,collapsedBbox.y,collapsedBbox.width,collapsedBbox.height);
  }
 else {
    boolean horizontal=bbox.width > bbox.height;
    RectangleRenderer.draw(batch,bbox.getX(),bbox.getY(),bbox.getWidth(),bbox.getHeight(),BG_COLOR);
    batch.draw(uncollapseIcon,collapsedBbox.x,collapsedBbox.y,tileSize,tileSize);
    batch.draw(configIcon,configBbox.x,configBbox.y,configBbox.width,configBbox.height);
    if (scrollItemPos == 0) {
      batch.setColor(GRAY);
      batch.draw(leftArrowIcon,horizontal ? (itemsPos - 1) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos - 1) * tileSize,tileSize,tileSize);
      batch.setColor(Color.WHITE);
    }
 else {
      batch.draw(leftArrowIcon,horizontal ? (itemsPos - 1) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos - 1) * tileSize,tileSize,tileSize);
    }
    if (scrollItemPos + itemsSize >= inventory.getNumItems()) {
      batch.setColor(GRAY);
      batch.draw(rightArrowIcon,horizontal ? (itemsPos + itemsSize) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos + itemsSize) * tileSize,tileSize,tileSize);
      batch.setColor(Color.WHITE);
    }
 else {
      batch.draw(rightArrowIcon,horizontal ? (itemsPos + itemsSize) * tileSize : bbox.x,horizontal ? bbox.y : (itemsPos + itemsSize) * tileSize,tileSize,tileSize);
    }
    for (int i=scrollItemPos; i < inventory.getNumItems() && itemsSize > i - scrollItemPos; i++) {
      SpriteActor a=inventory.getItem(i);
      float size=tileSize / a.getHeight() / a.getScale();
      a.getRenderer().draw(batch,horizontal ? (i + itemsPos - scrollItemPos) * tileSize + a.getWidth() * size / 2 : bbox.x + a.getWidth() * size / 2,horizontal ? bbox.y : (i + itemsPos - scrollItemPos) * tileSize,size);
    }
  }
  if (draggedActor != null) {
    float h=draggedActor.getHeight() / draggedActor.getScale();
    float size=tileSize / h * 1.3f;
    draggedActor.getRenderer().draw(batch,inputX,inputY - h * size / 2,size);
    scrollTime+=Gdx.graphics.getDeltaTime();
    if (scrollTime > SCROLL_TIME) {
      scrollTime=0;
      updateScroll(inputX,inputY);
    }
  }
}",0.967482938578884
30406,"@Override public void render(){
  testSourceChanged();
  testFaChanged();
  if (renderer == null || renderer.getCurrentFrameAnimation() == null)   return;
  renderer.update(Gdx.graphics.getDeltaTime());
  GL20 gl=Gdx.gl20;
  gl.glClearColor(Color.MAGENTA.r,Color.MAGENTA.g,Color.MAGENTA.b,1);
  gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  float scalew=Gdx.graphics.getWidth() / renderer.getWidth();
  float scaleh=Gdx.graphics.getHeight() / renderer.getHeight();
  float scale=scalew > scaleh ? scaleh : scalew;
  batch.setProjectionMatrix(screenCamera.combined);
  batch.begin();
  renderer.draw(batch,renderer.getWidth() * scale / 2,0f,0f,0f,scale);
  batch.end();
}","@Override public void render(){
  testSourceChanged();
  testFaChanged();
  if (renderer == null || renderer.getCurrentFrameAnimation() == null)   return;
  renderer.update(Gdx.graphics.getDeltaTime());
  GL20 gl=Gdx.gl20;
  gl.glClearColor(Color.MAGENTA.r,Color.MAGENTA.g,Color.MAGENTA.b,1);
  gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
  float scalew=Gdx.graphics.getWidth() / renderer.getWidth();
  float scaleh=Gdx.graphics.getHeight() / renderer.getHeight();
  float scale=scalew > scaleh ? scaleh : scalew;
  batch.setProjectionMatrix(screenCamera.combined);
  batch.begin();
  renderer.draw(batch,renderer.getWidth() * scale / 2,0f,scale);
  batch.end();
}",0.9954614220877458
30407,"public void draw(SpriteBatch batch){
  if (renderer != null && currentFrameAnimation != null) {
    float screenWidth=Gdx.graphics.getWidth();
    float screenHeight=Gdx.graphics.getHeight();
    float width=HEIGHT / renderer.getHeight() * renderer.getWidth();
    RectangleRenderer.draw(batch,screenWidth - width - 5,screenHeight - HEIGHT - 55,width + 10,HEIGHT + 10,Color.BLACK);
    RectangleRenderer.draw(batch,screenWidth - width,screenHeight - HEIGHT - 50,width,HEIGHT,BG_COLOR);
    float scaleh=width / renderer.getWidth();
    renderer.draw(batch,screenWidth - width / 2,screenHeight - HEIGHT - 50,0,0,scaleh);
  }
}","public void draw(SpriteBatch batch){
  if (renderer != null && currentFrameAnimation != null) {
    float screenWidth=Gdx.graphics.getWidth();
    float screenHeight=Gdx.graphics.getHeight();
    float width=HEIGHT / renderer.getHeight() * renderer.getWidth();
    RectangleRenderer.draw(batch,screenWidth - width - 5,screenHeight - HEIGHT - 55,width + 10,HEIGHT + 10,Color.BLACK);
    RectangleRenderer.draw(batch,screenWidth - width,screenHeight - HEIGHT - 50,width,HEIGHT,BG_COLOR);
    float scaleh=width / renderer.getWidth();
    renderer.draw(batch,screenWidth - width / 2,screenHeight - HEIGHT - 50,scaleh);
  }
}",0.9967897271268058
30408,"@Override public void onEvent(int type,BaseTween<?> source){
  if (cb != null) {
    cb.onEvent();
  }
}","@Override public void onEvent(int type,BaseTween<?> source){
  if (cb != null) {
    ActionCallbackQueue.add(cb);
  }
}",0.852017937219731
30409,"public void update(float delta){
  for (int i=0; i < timers.size(); i++) {
    Timer t=timers.get(i);
    t.currentTime+=delta;
    if (t.currentTime >= t.time) {
      timers.remove(i);
      t.cb.onEvent();
      i--;
    }
  }
}","public void update(float delta){
  for (int i=0; i < timers.size(); i++) {
    Timer t=timers.get(i);
    t.currentTime+=delta;
    if (t.currentTime >= t.time) {
      timers.remove(i);
      ActionCallbackQueue.add(t.cb);
      i--;
    }
  }
}",0.9182389937106918
30410,"public void update(float delta){
  timer=timer - delta;
  if (isFinish() && cb != null) {
    ActionCallback cb2=cb;
    cb=null;
    cb2.onEvent();
  }
}","public void update(float delta){
  timer=timer - delta;
  if (isFinish() && cb != null) {
    ActionCallbackQueue.add(cb);
    cb=null;
  }
}",0.8813559322033898
30411,"public void update(float delta){
  if (controller.current != null && controller.current.loopCount != 0) {
    controller.update(delta);
    genShadowMap();
    if (USE_FBO)     renderTex();
  }
  if (callCb) {
    callCb=false;
    if (animationCb == null) {
      animationCb=ActionCallbackSerialization.find(animationCbSer);
      animationCbSer=null;
    }
    animationCb.onEvent();
  }
}","public void update(float delta){
  if (controller.current != null && controller.current.loopCount != 0) {
    controller.update(delta);
    genShadowMap();
    if (USE_FBO)     renderTex();
  }
}",0.6643952299829642
30412,"@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",modelFileName);
  json.writeValue(""String_Node_Str"",width);
  json.writeValue(""String_Node_Str"",height);
  json.writeValue(""String_Node_Str"",cameraPos,cameraPos == null ? null : Vector3.class);
  json.writeValue(""String_Node_Str"",cameraRot,cameraRot == null ? null : Vector3.class);
  json.writeValue(""String_Node_Str"",cameraName,cameraName == null ? null : String.class);
  json.writeValue(""String_Node_Str"",cameraFOV);
  json.writeValue(""String_Node_Str"",modelRotation);
  json.writeValue(""String_Node_Str"",callCb);
  json.writeValue(""String_Node_Str"",ActionCallbackSerialization.find(animationCb),animationCb == null ? null : String.class);
}","@Override public void write(Json json){
  json.writeValue(""String_Node_Str"",modelFileName);
  json.writeValue(""String_Node_Str"",width);
  json.writeValue(""String_Node_Str"",height);
  json.writeValue(""String_Node_Str"",cameraPos,cameraPos == null ? null : Vector3.class);
  json.writeValue(""String_Node_Str"",cameraRot,cameraRot == null ? null : Vector3.class);
  json.writeValue(""String_Node_Str"",cameraName,cameraName == null ? null : String.class);
  json.writeValue(""String_Node_Str"",cameraFOV);
  json.writeValue(""String_Node_Str"",modelRotation);
  json.writeValue(""String_Node_Str"",ActionCallbackSerialization.find(animationCb),animationCb == null ? null : String.class);
}",0.9062276306370796
30413,"@Override public void read(Json json,JsonValue jsonData){
  modelFileName=json.readValue(""String_Node_Str"",String.class,jsonData);
  width=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  height=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  cameraPos=json.readValue(""String_Node_Str"",Vector3.class,jsonData);
  cameraRot=json.readValue(""String_Node_Str"",Vector3.class,jsonData);
  cameraName=json.readValue(""String_Node_Str"",String.class,jsonData);
  cameraFOV=json.readValue(""String_Node_Str"",Float.class,jsonData);
  modelRotation=json.readValue(""String_Node_Str"",Float.class,jsonData);
  callCb=json.readValue(""String_Node_Str"",Boolean.class,jsonData);
  animationCbSer=json.readValue(""String_Node_Str"",String.class,jsonData);
}","@Override public void read(Json json,JsonValue jsonData){
  modelFileName=json.readValue(""String_Node_Str"",String.class,jsonData);
  width=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  height=json.readValue(""String_Node_Str"",Integer.class,jsonData);
  cameraPos=json.readValue(""String_Node_Str"",Vector3.class,jsonData);
  cameraRot=json.readValue(""String_Node_Str"",Vector3.class,jsonData);
  cameraName=json.readValue(""String_Node_Str"",String.class,jsonData);
  cameraFOV=json.readValue(""String_Node_Str"",Float.class,jsonData);
  modelRotation=json.readValue(""String_Node_Str"",Float.class,jsonData);
  animationCbSer=json.readValue(""String_Node_Str"",String.class,jsonData);
}",0.9411764705882352
30414,"@Override public void onEnd(AnimationDesc animation){
  if (animationCb != null || animationCbSer != null) {
    callCb=true;
  }
}","@Override public void onEnd(AnimationDesc animation){
  if (animationCb != null || animationCbSer != null) {
    if (animationCb == null) {
      animationCb=ActionCallbackSerialization.find(animationCbSer);
      animationCbSer=null;
    }
    ActionCallbackQueue.add(animationCb);
  }
}",0.5727923627684964
30415,"public void startFrameAnimation(String id,int repeatType,int count,ActionCallback cb){
  boolean reverse=false;
  if (repeatType == EngineTween.REVERSE || repeatType == EngineTween.REVERSE_REPEAT)   reverse=true;
  if (modelInstance.getAnimation(id) != null) {
    animationCb=cb;
    callCb=false;
    controller.setAnimation(id,count,reverse ? -1 : 1,animationListener);
    return;
  }
  int idx=id.indexOf('.');
  if (idx != -1) {
    String s=id.substring(0,idx);
    String dir=id.substring(idx + 1);
    lookat(dir);
    if (modelInstance.getAnimation(s) != null) {
      animationCb=cb;
      callCb=false;
      controller.setAnimation(s,count,reverse ? -1 : 1,animationListener);
      return;
    }
  }
  EngineLogger.error(""String_Node_Str"" + id);
  for (  Animation a : modelInstance.animations) {
    EngineLogger.debug(a.id);
  }
  if (cb != null)   cb.onEvent();
}","public void startFrameAnimation(String id,int repeatType,int count,ActionCallback cb){
  boolean reverse=false;
  animationCb=cb;
  if (repeatType == EngineTween.REVERSE || repeatType == EngineTween.REVERSE_REPEAT)   reverse=true;
  if (modelInstance.getAnimation(id) != null) {
    animationCb=cb;
    controller.setAnimation(id,count,reverse ? -1 : 1,animationListener);
    return;
  }
  int idx=id.indexOf('.');
  if (idx != -1) {
    String s=id.substring(0,idx);
    String dir=id.substring(idx + 1);
    lookat(dir);
    if (modelInstance.getAnimation(s) != null) {
      controller.setAnimation(s,count,reverse ? -1 : 1,animationListener);
      return;
    }
  }
  EngineLogger.error(""String_Node_Str"" + id);
  for (  Animation a : modelInstance.animations) {
    EngineLogger.debug(a.id);
  }
  if (cb != null) {
    ActionCallbackQueue.add(cb);
  }
}",0.9236071223434807
30416,"@Override public void loadAssets(){
  renderer.loadAssets();
}","@Override public void loadAssets(){
  super.loadAssets();
  renderer.loadAssets();
}",0.8493150684931506
30417,"@Override public void retrieveAssets(){
  super.retrieveAssets();
  renderer.retrieveAssets();
  if (renderer.getCurrentFrameAnimation() == null && initFrameAnimation != null) {
    startFrameAnimation(initFrameAnimation,null);
  }
}","@Override public void retrieveAssets(){
  super.retrieveAssets();
  renderer.retrieveAssets();
  if (renderer.getCurrentFrameAnimation() == null) {
    startFrameAnimation(initFrameAnimation,null);
  }
}",0.8577981651376146
30418,"public void goTo(Vector2 pf,ActionCallback cb){
  EngineLogger.debug(MessageFormat.format(""String_Node_Str"",pf.x,pf.y));
  Vector2 p0=getPosition();
  ArrayList<Vector2> walkingPath=null;
  PixTileMap bgMap=scene.getBackgroundMap();
  if (bgMap != null)   walkingPath=bgMap.findPath(scene,p0,pf);
  if (walkingPath == null || walkingPath.size() == 0) {
    if (cb != null)     cb.onEvent();
    return;
  }
  TweenManager manager=TweenManagerSingleton.getInstance();
  manager.killTarget(this);
  WalkTween t=new WalkTween();
  t.start(this,walkingPath,walkingSpeed,cb);
  manager.add(t);
}","public void goTo(Vector2 pf,ActionCallback cb){
  EngineLogger.debug(MessageFormat.format(""String_Node_Str"",pf.x,pf.y));
  Vector2 p0=getPosition();
  ArrayList<Vector2> walkingPath=null;
  PixTileMap bgMap=scene.getBackgroundMap();
  if (bgMap != null)   walkingPath=bgMap.findPath(scene,p0,pf);
  if (walkingPath == null || walkingPath.size() == 0) {
    if (cb != null)     ActionCallbackQueue.add(cb);
    return;
  }
  TweenManager manager=TweenManagerSingleton.getInstance();
  manager.killTarget(this);
  WalkTween t=new WalkTween();
  t.start(this,walkingPath,walkingSpeed,cb);
  manager.add(t);
}",0.9690376569037656
30419,"@Override public void update(float delta){
  if (currentAnimation != null) {
    animationTime+=delta;
    tex=currentAnimation.getKeyFrame(animationTime);
    if (currentAnimation.isAnimationFinished(animationTime) && (animationCb != null || animationCbSer != null)) {
      if (animationCb == null) {
        animationCb=ActionCallbackSerialization.find(animationCbSer);
        animationCbSer=null;
      }
      ActionCallback cb2=animationCb;
      animationCb=null;
      cb2.onEvent();
    }
  }
}","@Override public void update(float delta){
  if (currentAnimation != null) {
    animationTime+=delta;
    tex=currentAnimation.getKeyFrame(animationTime);
    if (currentAnimation.isAnimationFinished(animationTime) && (animationCb != null || animationCbSer != null)) {
      if (animationCb == null) {
        animationCb=ActionCallbackSerialization.find(animationCbSer);
        animationCbSer=null;
      }
      ActionCallbackQueue.add(animationCb);
      animationCb=null;
      currentAnimation=null;
    }
  }
}",0.8688845401174168
30420,"@Override public void draw(SpriteBatch batch,float x,float y,float originX,float originY,float scale){
  if (tex == null) {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
  }
  if (!flipX) {
    batch.draw(tex,x,y,originX,originY,tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
 else {
    batch.draw(tex,x + tex.getRegionWidth() * scale,y,originX,originY,-tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
}","@Override public void draw(SpriteBatch batch,float x,float y,float originX,float originY,float scale){
  if (tex == null) {
    RectangleRenderer.draw(batch,x,y,getWidth() * scale,getHeight() * scale,Color.RED);
    return;
  }
  if (!flipX) {
    batch.draw(tex,x,y,originX,originY,tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
 else {
    batch.draw(tex,x + tex.getRegionWidth() * scale,y,originX,originY,-tex.getRegionWidth(),tex.getRegionHeight(),scale,scale,0);
  }
}",0.9875776397515528
30421,"private void startCurrentFrameAnimation(int repeatType,int count,ActionCallback cb){
  if (notPreloadedAtlas != null && !currentFrameAnimation.atlas.equals(notPreloadedAtlas)) {
    EngineAssetManager.getInstance().disposeAtlas(notPreloadedAtlas);
    notPreloadedAtlas=null;
  }
  if (currentFrameAnimation != null && currentFrameAnimation.regions == null) {
    retrieveFA(currentFrameAnimation.id,true);
  }
  if (currentFrameAnimation == null || currentFrameAnimation.regions == null) {
    tex=null;
    return;
  }
  currentAnimation=null;
  animationTime=0;
  animationCb=cb;
  if (currentFrameAnimation.regions.size <= 1 || currentFrameAnimation.duration == 0.0) {
    tex=currentFrameAnimation.regions.first();
    if (cb != null) {
      cb.onEvent();
    }
    return;
  }
  if (repeatType != EngineTween.FROM_FA) {
    currentFrameAnimation.animationType=repeatType;
    currentFrameAnimation.count=count;
  }
  newCurrentAnimation(currentFrameAnimation.animationType,count);
}","private void startCurrentFrameAnimation(int repeatType,int count,ActionCallback cb){
  animationCb=cb;
  if (notPreloadedAtlas != null && !currentFrameAnimation.atlas.equals(notPreloadedAtlas)) {
    EngineAssetManager.getInstance().disposeAtlas(notPreloadedAtlas);
    notPreloadedAtlas=null;
  }
  if (currentFrameAnimation != null && currentFrameAnimation.regions == null) {
    retrieveFA(currentFrameAnimation.id,true);
  }
  if (currentFrameAnimation == null || currentFrameAnimation.regions == null) {
    tex=null;
    return;
  }
  currentAnimation=null;
  animationTime=0;
  if (currentFrameAnimation.regions.size <= 1 || currentFrameAnimation.duration == 0.0) {
    tex=currentFrameAnimation.regions.first();
    if (cb != null) {
      ActionCallbackQueue.add(cb);
    }
    return;
  }
  if (repeatType != EngineTween.FROM_FA) {
    currentFrameAnimation.animationType=repeatType;
    currentFrameAnimation.count=count;
  }
  newCurrentAnimation(currentFrameAnimation.animationType,count);
}",0.9643753135975917
30422,"public void startFrameAnimation(String id,int repeatType,int count,ActionCallback cb){
  AtlasFrameAnimation fa=getFrameAnimation(id);
  if (fa == null) {
    EngineLogger.error(""String_Node_Str"" + id);
    return;
  }
  currentFrameAnimation=fa;
  startCurrentFrameAnimation(repeatType,count,cb);
}","public void startFrameAnimation(String id,int repeatType,int count,ActionCallback cb){
  AtlasFrameAnimation fa=null;
  if (id == null) {
    fa=fanims.values().iterator().next();
  }
 else {
    fa=getFrameAnimation(id);
  }
  if (fa == null) {
    EngineLogger.error(""String_Node_Str"" + id);
    return;
  }
  currentFrameAnimation=fa;
  startCurrentFrameAnimation(repeatType,count,cb);
}",0.8040638606676342
30423,"public void callCb(){
  if (cb != null) {
    cb.onEvent();
  }
}","public void callCb(){
  if (cb != null) {
    ActionCallbackQueue.add(cb);
  }
}",0.7724137931034483
30424,"public void update(float delta){
  currentTime+=delta;
  if (isFinish() && cb != null) {
    ActionCallback cb2=cb;
    cb=null;
    cb2.onEvent();
  }
}","public void update(float delta){
  currentTime+=delta;
  if (isFinish() && cb != null) {
    ActionCallbackQueue.add(cb);
    cb=null;
  }
}",0.8805460750853242
30425,"public void update(float delta){
  if (assetState == AssetState.LOAD_ASSETS || assetState == AssetState.LOAD_ASSETS_AND_INIT_SCENE) {
    loadAssets();
    if (assetState == AssetState.LOAD_ASSETS)     assetState=AssetState.LOADING;
 else     assetState=AssetState.LOADING_AND_INIT_SCENE;
    initLoadingTime=System.currentTimeMillis();
  }
 else   if ((assetState == AssetState.LOADING || assetState == AssetState.LOADING_AND_INIT_SCENE) && !EngineAssetManager.getInstance().isLoading()) {
    retrieveAssets();
    boolean initScene=(assetState == AssetState.LOADING_AND_INIT_SCENE);
    assetState=AssetState.LOADED;
    EngineLogger.debug(""String_Node_Str"" + (System.currentTimeMillis() - initLoadingTime));
    if (initScene) {
      initCurrentScene();
    }
  }
  if (paused || assetState != AssetState.LOADED)   return;
  timeOfGame+=delta;
  getCurrentScene().update(delta);
  textManager.update(delta);
  timers.update(delta);
  TweenManagerSingleton.getInstance().update(delta);
}","public void update(float delta){
  if (assetState == AssetState.LOAD_ASSETS || assetState == AssetState.LOAD_ASSETS_AND_INIT_SCENE) {
    loadAssets();
    if (assetState == AssetState.LOAD_ASSETS)     assetState=AssetState.LOADING;
 else     assetState=AssetState.LOADING_AND_INIT_SCENE;
    initLoadingTime=System.currentTimeMillis();
  }
 else   if ((assetState == AssetState.LOADING || assetState == AssetState.LOADING_AND_INIT_SCENE) && !EngineAssetManager.getInstance().isLoading()) {
    retrieveAssets();
    boolean initScene=(assetState == AssetState.LOADING_AND_INIT_SCENE);
    assetState=AssetState.LOADED;
    EngineLogger.debug(""String_Node_Str"" + (System.currentTimeMillis() - initLoadingTime));
    if (initScene) {
      initCurrentScene();
    }
  }
  if (paused || assetState != AssetState.LOADED)   return;
  timeOfGame+=delta;
  getCurrentScene().update(delta);
  textManager.update(delta);
  timers.update(delta);
  TweenManagerSingleton.getInstance().update(delta);
  ActionCallbackQueue.run();
}",0.9855793137742416
30426,"@Override public void afterProcess(Page page){
  System.out.println(page);
}","@Override public void afterProcess(Page page){
}",0.7741935483870968
30427,"/** 
 * @return all of the VCF FILTER lines in their original file order, or an empty list if none were present
 */
public List<VCFIDHeaderLine> getIDHeaderLines(){
  final List<VCFIDHeaderLine> filters=new ArrayList<VCFIDHeaderLine>();
  for (  final VCFHeaderLine line : mMetaData) {
    if (line instanceof VCFIDHeaderLine) {
      filters.add((VCFIDHeaderLine)line);
    }
  }
  return filters;
}","/** 
 * @return all of the VCF ID-based header lines in their original file order, or an empty list if none were present
 */
public List<VCFIDHeaderLine> getIDHeaderLines(){
  final List<VCFIDHeaderLine> lines=new ArrayList<VCFIDHeaderLine>();
  for (  final VCFHeaderLine line : mMetaData) {
    if (line instanceof VCFIDHeaderLine) {
      lines.add((VCFIDHeaderLine)line);
    }
  }
  return lines;
}",0.9364881693648816
30428,"/** 
 * Requires that the accumulator for the record is previously fill with  {@link #accumulateSamRecord(htsjdk.samtools.SAMRecord)}. Include in the LocusInfo the indels; the quality threshold does not affect insertions/deletions
 */
@Override void accumulateIndels(SAMRecord rec){
  final List<CigarElement> cigar=rec.getCigar().getCigarElements();
  int readBase=0;
  int refBase=rec.getAlignmentStart() - getAccumulatorOffset(rec);
  for (int elementIndex=0; elementIndex < cigar.size(); elementIndex++) {
    final CigarElement e=cigar.get(elementIndex);
    final CigarOperator operator=e.getOperator();
    if (operator.equals(CigarOperator.I)) {
      System.err.println(""String_Node_Str"");
      accumulator.get(refBase - 1).addInserted(rec,readBase);
      readBase+=e.getLength();
    }
 else     if (operator.equals(CigarOperator.D)) {
      for (int i=0; i < e.getLength(); i++) {
        accumulator.get(refBase + i).addDeleted(rec,readBase - 1);
      }
      refBase+=e.getLength();
    }
 else {
      if (operator.consumesReadBases())       readBase+=e.getLength();
      if (operator.consumesReferenceBases())       refBase+=e.getLength();
    }
  }
}","/** 
 * Requires that the accumulator for the record is previously fill with  {@link #accumulateSamRecord(htsjdk.samtools.SAMRecord)}. Include in the LocusInfo the indels; the quality threshold does not affect insertions/deletions
 */
@Override void accumulateIndels(SAMRecord rec){
  final List<CigarElement> cigar=rec.getCigar().getCigarElements();
  int readBase=0;
  int refBase=rec.getAlignmentStart() - getAccumulatorOffset(rec);
  for (int elementIndex=0; elementIndex < cigar.size(); elementIndex++) {
    final CigarElement e=cigar.get(elementIndex);
    final CigarOperator operator=e.getOperator();
    if (operator.equals(CigarOperator.I)) {
      accumulator.get(refBase - 1).addInserted(rec,readBase);
      readBase+=e.getLength();
    }
 else     if (operator.equals(CigarOperator.D)) {
      for (int i=0; i < e.getLength(); i++) {
        accumulator.get(refBase + i).addDeleted(rec,readBase - 1);
      }
      refBase+=e.getLength();
    }
 else {
      if (operator.consumesReadBases())       readBase+=e.getLength();
      if (operator.consumesReferenceBases())       refBase+=e.getLength();
    }
  }
}",0.9803921568627452
30429,"/** 
 * Pop the first entry from the AbstractLocusInfo<T> accumulator into the complete queue.  In addition, check the ReferenceSequenceMask and if there are intervening mask positions between the last popped base and the one about to be popped, put those on the complete queue as well. Note that a single call to this method may not empty the accumulator completely, or even empty it at all, because it may just put a zero-coverage AbstractLocusInfo<T> into the complete queue.
 * @param stopBeforeLocus don't go up to this sequence and position
 */
private void populateCompleteQueue(final Locus stopBeforeLocus){
  while (!accumulator.isEmpty() && accumulator.get(0).isEmpty() && locusComparator.compare(accumulator.get(0),stopBeforeLocus) < 0) {
    accumulator.remove(0);
  }
  if (accumulator.isEmpty()) {
    return;
  }
  final K locusInfo=accumulator.get(0);
  if (locusComparator.compare(stopBeforeLocus,locusInfo) <= 0) {
    return;
  }
  if (emitUncoveredLoci) {
    final K zeroCoverage=createNextUncoveredLocusInfo(locusInfo);
    if (zeroCoverage != null) {
      complete.add(zeroCoverage);
      return;
    }
  }
  accumulator.remove(0);
  final int sequenceIndex=locusInfo.getSequenceIndex();
  if (referenceSequenceMask.get(locusInfo.getSequenceIndex(),locusInfo.getPosition())) {
    complete.add(locusInfo);
  }
  lastReferenceSequence=sequenceIndex;
  lastPosition=locusInfo.getPosition();
}","/** 
 * Pop the first entry from the AbstractLocusInfo<T> accumulator into the complete queue.  In addition, check the ReferenceSequenceMask and if there are intervening mask positions between the last popped base and the one about to be popped, put those on the complete queue as well. Note that a single call to this method may not empty the accumulator completely, or even empty it at all, because it may just put a zero-coverage AbstractLocusInfo<T> into the complete queue.
 * @param stopBeforeLocus don't go up to this sequence and position
 */
private void populateCompleteQueue(final Locus stopBeforeLocus){
  removeSkippedRegion(stopBeforeLocus);
  if (accumulator.isEmpty()) {
    return;
  }
  final K locusInfo=accumulator.get(0);
  if (locusComparator.compare(stopBeforeLocus,locusInfo) <= 0) {
    return;
  }
  if (emitUncoveredLoci) {
    final K zeroCoverage=createNextUncoveredLocusInfo(locusInfo);
    if (zeroCoverage != null) {
      complete.add(zeroCoverage);
      return;
    }
  }
  accumulator.remove(0);
  final int sequenceIndex=locusInfo.getSequenceIndex();
  if (referenceSequenceMask.get(locusInfo.getSequenceIndex(),locusInfo.getPosition())) {
    complete.add(locusInfo);
  }
  lastReferenceSequence=sequenceIndex;
  lastPosition=locusInfo.getPosition();
}",0.9390018484288356
30430,"/** 
 * Add a contig header line to the lookup list for contig lines (contigMetaData). If there's already a contig line with the same ID, does not add the line. Note: does not add the contig line to the master list of header lines in mMetaData -- this must be done separately if desired.
 * @param line contig header line to add
 * @return true if line was added to the list of contig lines, otherwise false
 */
private boolean addContigMetaDataLineLookupEntry(final VCFContigHeaderLine line){
  for (  VCFContigHeaderLine vcfContigHeaderLine : contigMetaData) {
    if (vcfContigHeaderLine.getID().equals(line.getID())) {
      if (GeneralUtils.DEBUG_MODE_ENABLED) {
        System.err.println(""String_Node_Str"" + line.getID() + ""String_Node_Str"");
      }
      return false;
    }
  }
  contigMetaData.add(line);
  return true;
}","/** 
 * Add a contig header line to the lookup list for contig lines (contigMetaData). If there's already a contig line with the same ID, does not add the line. Note: does not add the contig line to the master list of header lines in mMetaData -- this must be done separately if desired.
 * @param line contig header line to add
 * @return true if line was added to the list of contig lines, otherwise false
 */
private boolean addContigMetaDataLineLookupEntry(final VCFContigHeaderLine line){
  if (contigMetaData.containsKey(line.getID())) {
    if (GeneralUtils.DEBUG_MODE_ENABLED) {
      System.err.println(""String_Node_Str"" + line.getID() + ""String_Node_Str"");
    }
    return false;
  }
  contigMetaData.put(line.getID(),line);
  return true;
}",0.8434343434343434
30431,"/** 
 * Completely replaces the contig records in this header with those in the given SAMSequenceDictionary.
 */
public void setSequenceDictionary(final SAMSequenceDictionary dictionary){
  this.contigMetaData.clear();
  final List<VCFHeaderLine> toRemove=new ArrayList<VCFHeaderLine>();
  for (  final VCFHeaderLine line : mMetaData) {
    if (line instanceof VCFContigHeaderLine) {
      toRemove.add(line);
    }
  }
  mMetaData.removeAll(toRemove);
  for (  final SAMSequenceRecord record : dictionary.getSequences()) {
    contigMetaData.add(new VCFContigHeaderLine(record,record.getAssembly()));
  }
  this.mMetaData.addAll(contigMetaData);
}","/** 
 * Completely replaces the contig records in this header with those in the given SAMSequenceDictionary.
 */
public void setSequenceDictionary(final SAMSequenceDictionary dictionary){
  this.contigMetaData.clear();
  final List<VCFHeaderLine> toRemove=new ArrayList<VCFHeaderLine>();
  for (  final VCFHeaderLine line : mMetaData) {
    if (line instanceof VCFContigHeaderLine) {
      toRemove.add(line);
    }
  }
  mMetaData.removeAll(toRemove);
  for (  final SAMSequenceRecord record : dictionary.getSequences()) {
    addMetaDataLine(new VCFContigHeaderLine(record,record.getAssembly()));
  }
}",0.9536741214057508
30432,"/** 
 * @return all of the VCF header lines of the ##contig form in order, or an empty list if none were present
 */
public List<VCFContigHeaderLine> getContigLines(){
  return Collections.unmodifiableList(contigMetaData);
}","/** 
 * @return all of the VCF header lines of the ##contig form in order, or an empty list if none were present
 */
public List<VCFContigHeaderLine> getContigLines(){
  return Collections.unmodifiableList(new ArrayList<>(contigMetaData.values()));
}",0.9451476793248944
30433,"@Test public void testVCFHeaderAddContigLine(){
  final VCFHeader header=getHiSeqVCFHeader();
  final VCFContigHeaderLine contigLine=new VCFContigHeaderLine(""String_Node_Str"",VCFHeaderVersion.VCF4_0,""String_Node_Str"",0);
  header.addMetaDataLine(contigLine);
  Assert.assertTrue(header.getContigLines().contains(contigLine),""String_Node_Str"");
  Assert.assertTrue(header.getMetaDataInInputOrder().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getInfoHeaderLines().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getFormatHeaderLines().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getFilterLines().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getOtherHeaderLines().contains(contigLine),""String_Node_Str"");
}","@Test public void testVCFHeaderAddContigLine(){
  final VCFHeader header=getHiSeqVCFHeader();
  final VCFContigHeaderLine contigLine=new VCFContigHeaderLine(""String_Node_Str"",VCFHeaderVersion.VCF4_0,VCFHeader.CONTIG_KEY,0);
  header.addMetaDataLine(contigLine);
  Assert.assertTrue(header.getContigLines().contains(contigLine),""String_Node_Str"");
  Assert.assertTrue(header.getMetaDataInInputOrder().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getInfoHeaderLines().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getFormatHeaderLines().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getFilterLines().contains(contigLine),""String_Node_Str"");
  Assert.assertFalse(header.getOtherHeaderLines().contains(contigLine),""String_Node_Str"");
}",0.9781113195747342
30434,"/** 
 * Creates the BAMIndexContent for this reference. Requires all features of the reference have already been processed.
 */
public BinningIndexContent generateIndexContent(){
  if (binsSeen == 0)   return null;
  final long[] newIndex=new long[largestIndexSeen + 1];
  long lastNonZeroOffset=0;
  for (int i=0; i <= largestIndexSeen; i++) {
    if (index[i] == 0) {
      index[i]=lastNonZeroOffset;
    }
 else {
      lastNonZeroOffset=index[i];
    }
    newIndex[i]=index[i];
  }
  final LinearIndex linearIndex=new LinearIndex(referenceSequence,0,newIndex);
  return new BinningIndexContent(referenceSequence,new BinningIndexContent.BinList(bins,binsSeen),linearIndex);
}","/** 
 * Creates the BAMIndexContent for this reference. Requires all features of the reference have already been processed.
 */
public BinningIndexContent generateIndexContent(){
  if (binsSeen == 0)   return null;
  final long[] newIndex=new long[largestIndexSeen + 1];
  long lastNonZeroOffset=0;
  for (int i=0; i <= largestIndexSeen; i++) {
    if (index[i] == UNINITIALIZED_WINDOW) {
      index[i]=lastNonZeroOffset;
    }
 else {
      lastNonZeroOffset=index[i];
    }
    newIndex[i]=index[i];
  }
  final LinearIndex linearIndex=new LinearIndex(referenceSequence,0,newIndex);
  return new BinningIndexContent(referenceSequence,new BinningIndexContent.BinList(bins,binsSeen),linearIndex);
}",0.9847715736040608
30435,"public void processFeature(final FeatureToBeIndexed feature){
  final Integer binNumber=feature.getIndexingBin();
  final int binNum=binNumber == null ? computeIndexingBin(feature) : binNumber;
  final Bin bin;
  if (bins[binNum] != null) {
    bin=bins[binNum];
  }
 else {
    bin=new Bin(referenceSequence,binNum);
    bins[binNum]=bin;
    binsSeen++;
  }
  final Chunk newChunk=feature.getChunk();
  final long chunkStart=newChunk.getChunkStart();
  final long chunkEnd=newChunk.getChunkEnd();
  final List<Chunk> oldChunks=bin.getChunkList();
  if (!bin.containsChunks()) {
    bin.addInitialChunk(newChunk);
  }
 else {
    final Chunk lastChunk=bin.getLastChunk();
    if (BlockCompressedFilePointerUtil.areInSameOrAdjacentBlocks(lastChunk.getChunkEnd(),chunkStart)) {
      lastChunk.setChunkEnd(chunkEnd);
    }
 else {
      oldChunks.add(newChunk);
      bin.setLastChunk(newChunk);
    }
  }
  final int featureEnd=feature.getEnd();
  int startWindow=LinearIndex.convertToLinearIndexOffset(feature.getStart());
  final int endWindow;
  if (featureEnd == GenomicIndexUtil.UNSET_GENOMIC_LOCATION) {
    startWindow=LinearIndex.convertToLinearIndexOffset(feature.getStart() - 1);
    endWindow=startWindow;
  }
 else {
    endWindow=LinearIndex.convertToLinearIndexOffset(featureEnd);
  }
  if (endWindow > largestIndexSeen) {
    largestIndexSeen=endWindow;
  }
  for (int win=startWindow; win <= endWindow; win++) {
    if (index[win] == 0 || chunkStart < index[win]) {
      index[win]=chunkStart;
    }
  }
}","public void processFeature(final FeatureToBeIndexed feature){
  final Integer binNumber=feature.getIndexingBin();
  final int binNum=binNumber == null ? computeIndexingBin(feature) : binNumber;
  final Bin bin;
  if (bins[binNum] != null) {
    bin=bins[binNum];
  }
 else {
    bin=new Bin(referenceSequence,binNum);
    bins[binNum]=bin;
    binsSeen++;
  }
  final Chunk newChunk=feature.getChunk();
  final long chunkStart=newChunk.getChunkStart();
  final long chunkEnd=newChunk.getChunkEnd();
  final List<Chunk> oldChunks=bin.getChunkList();
  if (!bin.containsChunks()) {
    bin.addInitialChunk(newChunk);
  }
 else {
    final Chunk lastChunk=bin.getLastChunk();
    if (BlockCompressedFilePointerUtil.areInSameOrAdjacentBlocks(lastChunk.getChunkEnd(),chunkStart)) {
      lastChunk.setChunkEnd(chunkEnd);
    }
 else {
      oldChunks.add(newChunk);
      bin.setLastChunk(newChunk);
    }
  }
  final int featureEnd=feature.getEnd();
  int startWindow=LinearIndex.convertToLinearIndexOffset(feature.getStart());
  final int endWindow;
  if (featureEnd == GenomicIndexUtil.UNSET_GENOMIC_LOCATION) {
    startWindow=LinearIndex.convertToLinearIndexOffset(feature.getStart() - 1);
    endWindow=startWindow;
  }
 else {
    endWindow=LinearIndex.convertToLinearIndexOffset(featureEnd);
  }
  if (endWindow > largestIndexSeen) {
    largestIndexSeen=endWindow;
  }
  for (int win=startWindow; win <= endWindow; win++) {
    if (index[win] == UNINITIALIZED_WINDOW || chunkStart < index[win]) {
      index[win]=chunkStart;
    }
  }
}",0.9931439764936336
30436,"/** 
 * Builds a FastaSequenceIndex on the fly from a FASTA file. Note: this also alows to create an index for a compressed file, but does not generate the .gzi index required for use it with samtools.
 * @param fastaFile the FASTA file.
 * @return a fai index.
 * @throws SAMException for formatting errors.
 * @throws IOException  if an IO error occurs.
 */
public static FastaSequenceIndex buildFromFasta(final Path fastaFile) throws IOException {
  try (final AsciiLineReader in=new AsciiLineReader(IOUtil.openFileForReading(fastaFile))){
    String previous=in.readLine();
    if (previous == null) {
      throw new SAMException(""String_Node_Str"" + fastaFile);
    }
 else     if (previous.charAt(0) != '>') {
      throw new SAMException(""String_Node_Str"" + previous);
    }
    int sequenceIndex=-1;
    long location=in.getPosition();
    final FastaSequenceIndex index=new FastaSequenceIndex();
    FaiEntryBuilder entry=null;
    for (String line=in.readLine(); previous != null; line=in.readLine()) {
      if (previous.charAt(0) == '>') {
        if (entry != null)         index.add(entry.build());
        entry=new FaiEntryBuilder(sequenceIndex++,previous,line,in.getLineTerminatorLength(),location);
      }
 else       if (line != null && line.charAt(0) == '>') {
        location=in.getPosition();
      }
 else       if (line != null && !line.isEmpty()) {
        entry.updateWithSequence(line,in.getLineTerminatorLength());
      }
      previous=line;
    }
    index.add(entry.build());
    return index;
  }
 }","/** 
 * Builds a FastaSequenceIndex on the fly from a FASTA file. Note: this also alows to create an index for a compressed file, but does not generate the .gzi index required for use it with samtools.
 * @param fastaFile the FASTA file.
 * @return a fai index.
 * @throws SAMException for formatting errors.
 * @throws IOException  if an IO error occurs.
 */
public static FastaSequenceIndex buildFromFasta(final Path fastaFile) throws IOException {
  try (final AsciiLineReader in=AsciiLineReader.from(IOUtil.openFileForReading(fastaFile))){
    String previous=in.readLine();
    if (previous == null) {
      throw new SAMException(""String_Node_Str"" + fastaFile);
    }
 else     if (previous.charAt(0) != '>') {
      throw new SAMException(""String_Node_Str"" + previous);
    }
    int sequenceIndex=-1;
    long location=in.getPosition();
    final FastaSequenceIndex index=new FastaSequenceIndex();
    FaiEntryBuilder entry=null;
    for (String line=in.readLine(); previous != null; line=in.readLine()) {
      if (previous.charAt(0) == '>') {
        if (entry != null)         index.add(entry.build());
        entry=new FaiEntryBuilder(sequenceIndex++,previous,line,in.getLineTerminatorLength(),location);
      }
 else       if (line != null && line.charAt(0) == '>') {
        location=in.getPosition();
      }
 else       if (line != null && !line.isEmpty()) {
        entry.updateWithSequence(line,in.getLineTerminatorLength());
      }
      previous=line;
    }
    index.add(entry.build());
    return index;
  }
 }",0.997067448680352
30437,"@Override public LocationAware makeIndexableSourceFromStream(final InputStream bufferedInputStream){
  final PositionalBufferedStream pbs;
  if (bufferedInputStream instanceof PositionalBufferedStream) {
    pbs=(PositionalBufferedStream)bufferedInputStream;
  }
 else {
    pbs=new PositionalBufferedStream(bufferedInputStream);
  }
  return new AsciiLineReaderIterator(new AsciiLineReader(pbs));
}","@Override public LocationAware makeIndexableSourceFromStream(final InputStream inputStream){
  return new AsciiLineReaderIterator(AsciiLineReader.from(inputStream));
}",0.5335689045936396
30438,"/** 
 * Generates a   {@link LocationAware} reader of type {@link SOURCE}.  Like   {@link #makeSourceFromStream(java.io.InputStream)}, except the   {@link LocationAware} compatibility is required for creating indexes.Implementers of this method must return a type that is both  {@link LocationAware} as well as {@link SOURCE}.  Note that this  requirement cannot be enforced via the method signature due to limitations in Java's generic typing system.  Instead, consumers should cast the call result into a   {@link SOURCE} when applicable.
 */
public LocationAware makeIndexableSourceFromStream(final InputStream bufferedInputStream);","/** 
 * Return a   {@link SOURCE} for this {@link FeatureCodec} that implements {@link LocationAware}, and is thus suitable for use during indexing. Like   {@link #makeSourceFromStream(java.io.InputStream)}, except the   {@link LocationAware} compatibility is required for creating indexes.</p> Implementers of this method must return a type that is both  {@link LocationAware} as well as {@link SOURCE}.  Note that this  requirement cannot be enforced via the method signature due to limitations in Java's generic typing system.  Instead, consumers should cast the call result into a   {@link SOURCE} when applicable.</p> NOTE: During the indexing process, the indexer passes the  {@link SOURCE} to the codecto consume Features from the underlying  {@link SOURCE}, one at a time, recording the Feature location via the   {@link SOURCE}'s  {@link LocationAware} interface. Therefore, it is essential that the {@link SOURCE} implementation, the {@link #readHeader}method, and the   {@link #decodeLoc} method, which are used during indexing, not introduce any buffering that would thatwould advance the  {@link SOURCE} more than a single feature (or the more than the size of the header, in the case of{@link #readHeader}).
 */
public LocationAware makeIndexableSourceFromStream(final InputStream inputStream);",0.5918682449819866
30439,"@Override public Object readActualHeader(LineIterator reader){
  return null;
}","/** 
 * The BED codec doesn't retain the actual header, but we need to parse through it and advance to the beginning of the first feature. This is especially true if we're indexing, since we want to underlying stream offset to be established correctly, but is also the case for when we're simply iterating to satisfy a feature query (otherwise the feature reader can terminate prematurely if the header is large).
 * @param lineIterator
 * @return Always null. The BEDCodec currently doesn't model or preserve the BED header.
 */
@Override public Object readActualHeader(final LineIterator lineIterator){
  while (lineIterator.hasNext()) {
    final String nextLine=lineIterator.peek();
    if (isBEDHeaderLine(nextLine)) {
      this.readHeaderLine(lineIterator.next());
    }
 else {
      return null;
    }
  }
  return null;
}",0.1384615384615384
30440,"/** 
 * @param inputFile The file from which to read. Stream for reading is opened on construction.
 * @param codec
 */
public FeatureIterator(final File inputFile,final FeatureCodec<FEATURE_TYPE,SOURCE> codec){
  this.codec=codec;
  this.inputFile=inputFile;
  final FeatureCodecHeader header=readHeader();
  source=(SOURCE)codec.makeIndexableSourceFromStream(initStream(inputFile,header.getHeaderEnd()));
  readNextFeature();
}","/** 
 * @param inputFile The file from which to read. Stream for reading is opened on construction. May not be null.
 * @param codec
 */
public FeatureIterator(final File inputFile,final FeatureCodec<FEATURE_TYPE,SOURCE> codec){
  if (inputFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.codec=codec;
  this.inputFile=inputFile;
  try {
    if (AbstractFeatureReader.hasBlockCompressedExtension(inputFile)) {
      final BlockCompressedInputStream bcs=initIndexableBlockCompressedStream(inputFile);
      source=(SOURCE)codec.makeIndexableSourceFromStream(bcs);
    }
 else {
      final PositionalBufferedStream ps=initIndexablePositionalStream(inputFile);
      source=(SOURCE)codec.makeIndexableSourceFromStream(ps);
    }
    this.codec.readHeader(source);
    readNextFeature();
  }
 catch (  final IOException e) {
    throw new TribbleException.InvalidHeader(""String_Node_Str"" + e.getMessage());
  }
}",0.48
30441,"private static Index createIndex(final File inputFile,final FeatureIterator iterator,final IndexCreator creator){
  Feature lastFeature=null;
  Feature currentFeature;
  final Map<String,Feature> visitedChromos=new HashMap<String,Feature>(40);
  while (iterator.hasNext()) {
    final long position=iterator.getPosition();
    currentFeature=iterator.next();
    checkSorted(inputFile,lastFeature,currentFeature);
    final String curChr=currentFeature.getContig();
    final String lastChr=lastFeature != null ? lastFeature.getContig() : null;
    if (!curChr.equals(lastChr)) {
      if (visitedChromos.containsKey(curChr)) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"" + featToString(visitedChromos.get(curChr));
        msg+=""String_Node_Str"" + featToString(lastFeature);
        msg+=""String_Node_Str"" + featToString(currentFeature);
        throw new TribbleException.MalformedFeatureFile(msg,inputFile.getAbsolutePath());
      }
 else {
        visitedChromos.put(curChr,currentFeature);
      }
    }
    creator.addFeature(currentFeature,position);
    lastFeature=currentFeature;
  }
  iterator.close();
  return creator.finalizeIndex(iterator.getPosition());
}","private static Index createIndex(final File inputFile,final FeatureIterator iterator,final IndexCreator creator){
  Feature lastFeature=null;
  Feature currentFeature;
  final Map<String,Feature> visitedChromos=new HashMap<String,Feature>(40);
  while (iterator.hasNext()) {
    final long position=iterator.getPosition();
    currentFeature=iterator.next();
    checkSorted(inputFile,lastFeature,currentFeature);
    final String curChr=currentFeature.getContig();
    final String lastChr=lastFeature != null ? lastFeature.getContig() : null;
    if (!curChr.equals(lastChr)) {
      if (visitedChromos.containsKey(curChr)) {
        String msg=""String_Node_Str"";
        msg+=""String_Node_Str"" + featToString(visitedChromos.get(curChr));
        msg+=""String_Node_Str"" + featToString(lastFeature);
        msg+=""String_Node_Str"" + featToString(currentFeature);
        throw new TribbleException.MalformedFeatureFile(msg,inputFile.getAbsolutePath());
      }
 else {
        visitedChromos.put(curChr,currentFeature);
      }
    }
    creator.addFeature(currentFeature,position);
    lastFeature=currentFeature;
  }
  long finalPosition=iterator.getPosition();
  iterator.close();
  return creator.finalizeIndex(finalPosition);
}",0.9736625514403292
30442,"/** 
 * Get reference sequence without validating name or length.  This is OK if the entire sequence dictionary was validated before reading sequences.
 */
public ReferenceSequence get(final int sequenceIndex){
  if (referenceSequence != null && referenceSequence.getContigIndex() == sequenceIndex) {
    return referenceSequence;
  }
  if (referenceSequence != null && referenceSequence.getContigIndex() > sequenceIndex) {
    throw new SAMException(""String_Node_Str"" + sequenceIndex + ""String_Node_Str""+ referenceSequence.getContigIndex());
  }
  referenceSequence=null;
  if (referenceSequenceFile.isIndexed()) {
    final SAMSequenceRecord samSequenceRecord=referenceSequenceFile.getSequenceDictionary().getSequence(sequenceIndex);
    if (samSequenceRecord != null) {
      referenceSequence=referenceSequenceFile.getSequence(samSequenceRecord.getSequenceName());
    }
  }
 else {
    do {
      referenceSequence=referenceSequenceFile.nextSequence();
    }
 while (referenceSequence != null && referenceSequence.getContigIndex() < sequenceIndex);
  }
  if (referenceSequence == null || referenceSequence.getContigIndex() != sequenceIndex) {
    throw new SAMException(""String_Node_Str"" + sequenceIndex + ""String_Node_Str""+ referenceSequenceFile.toString());
  }
  return referenceSequence;
}","/** 
 * Get reference sequence without validating name or length.  This is OK if the entire sequence dictionary was validated before reading sequences.
 */
public ReferenceSequence get(final int sequenceIndex){
  if (referenceSequence != null && referenceSequence.getContigIndex() == sequenceIndex) {
    return referenceSequence;
  }
  if (referenceSequence != null && referenceSequence.getContigIndex() > sequenceIndex) {
    throw new SAMException(""String_Node_Str"" + sequenceIndex + ""String_Node_Str""+ referenceSequence.getContigIndex());
  }
  referenceSequence=null;
  if (referenceSequenceFile.isIndexed() && referenceSequenceFile.getSequenceDictionary() != null) {
    final SAMSequenceRecord samSequenceRecord=referenceSequenceFile.getSequenceDictionary().getSequence(sequenceIndex);
    if (samSequenceRecord != null) {
      referenceSequence=referenceSequenceFile.getSequence(samSequenceRecord.getSequenceName());
    }
  }
 else {
    do {
      referenceSequence=referenceSequenceFile.nextSequence();
    }
 while (referenceSequence != null && referenceSequence.getContigIndex() < sequenceIndex);
  }
  if (referenceSequence == null || referenceSequence.getContigIndex() != sequenceIndex) {
    throw new SAMException(""String_Node_Str"" + sequenceIndex + ""String_Node_Str""+ referenceSequenceFile.toString());
  }
  return referenceSequence;
}",0.9785148888051264
30443,"@Override public SAMRecordIterator assertSorted(final SortOrder sortOrder){
  return null;
}","@Override public SAMRecordIterator assertSorted(final SortOrder sortOrder){
  return this;
}",0.9565217391304348
30444,"@Override public SAMRecordIterator assertSorted(final SortOrder sortOrder){
  throw new RuntimeException(""String_Node_Str"");
}","@Override public SAMRecordIterator assertSorted(final SortOrder sortOrder){
  return SamReader.AssertingIterator.of(this).assertSorted(sortOrder);
}",0.6861313868613139
30445,"/** 
 * Merges a sorted collection of intervals and optionally concatenates unique names or takes the first name. 
 */
static Interval merge(final SortedSet<Interval> intervals,final boolean concatenateNames){
  final String chrom=intervals.first().getContig();
  int start=intervals.first().getStart();
  int end=intervals.last().getEnd();
  final boolean neg=intervals.first().isNegativeStrand();
  final LinkedHashSet<String> names=new LinkedHashSet<String>();
  final String name;
  for (  final Interval i : intervals) {
    if (i.getName() != null)     names.add(i.getName());
    start=Math.min(start,i.getStart());
    end=Math.max(end,i.getEnd());
  }
  if (concatenateNames) {
    if (names.isEmpty())     name=null;
 else     name=StringUtil.join(""String_Node_Str"",names);
  }
 else {
    name=names.iterator().next();
  }
  return new Interval(chrom,start,end,neg,name);
}","/** 
 * Merges a sorted collection of intervals and optionally concatenates unique names or takes the first name. 
 */
static Interval merge(final SortedSet<Interval> intervals,final boolean concatenateNames){
  final String chrom=intervals.first().getContig();
  int start=intervals.first().getStart();
  int end=intervals.last().getEnd();
  final boolean neg=intervals.first().isNegativeStrand();
  final LinkedHashSet<String> names=new LinkedHashSet<String>();
  final String name;
  for (  final Interval i : intervals) {
    if (i.getName() != null)     names.add(i.getName());
    start=Math.min(start,i.getStart());
    end=Math.max(end,i.getEnd());
  }
  if (names.isEmpty())   name=null;
 else   if (concatenateNames)   name=StringUtil.join(""String_Node_Str"",names);
 else   name=names.iterator().next();
  return new Interval(chrom,start,end,neg,name);
}",0.8421052631578947
30446,"public boolean isAdjacent(final Node<V1> interval){
  return mStart == interval.getEnd() || mEnd == interval.getStart();
}","public boolean isAdjacent(final Node<V1> interval){
  return mStart == interval.getEnd() + 1 || mEnd + 1 == interval.getStart();
}",0.9682539682539684
30447,"public int getLength(){
  return mEnd - mStart;
}","public int getLength(){
  return mEnd - mStart + 1;
}",0.9607843137254902
30448,"public int getRelationship(final Node<V1> interval){
  int result=0;
  if (mStart < interval.getStart())   result=HAS_LESSER_PART;
  if (mEnd > interval.getEnd())   result|=HAS_GREATER_PART;
  if (mStart < interval.getEnd() && interval.getStart() < mEnd)   result|=HAS_OVERLAPPING_PART;
  return result;
}","public int getRelationship(final Node<V1> interval){
  int result=0;
  if (mStart < interval.getStart())   result=HAS_LESSER_PART;
  if (mEnd > interval.getEnd())   result|=HAS_GREATER_PART;
  if (mStart <= interval.getEnd() && interval.getStart() <= mEnd)   result|=HAS_OVERLAPPING_PART;
  return result;
}",0.9967320261437908
30449,"/** 
 * Reverses the quals in place. 
 */
public static void reverseQualities(final byte[] quals){
  final int lastIndex=quals.length - 1;
  int i, j;
  for (i=0, j=lastIndex; i < j; ++i, --j) {
    final byte tmp=quals[i];
    quals[i]=quals[j];
    quals[j]=tmp;
  }
}","/** 
 * Reverses the quals in place. 
 */
public static void reverseQualities(final byte[] quals){
  reverse(quals,0,quals.length);
}",0.5905707196029777
30450,"@Override public SamReader open(final SamInputResource resource){
  final SamReader.PrimitiveSamReader primitiveSamReader;
  try {
    final InputResource data=resource.data();
    final InputResource indexMaybe=resource.indexMaybe();
    final boolean indexDefined=indexMaybe != null;
    final InputResource.Type type=data.type();
    if (type == InputResource.Type.URL) {
      SamReader reader=customReaderFactory.maybeOpen(data.asUrl());
      if (reader != null) {
        return reader;
      }
    }
    if (type == InputResource.Type.SEEKABLE_STREAM || type == InputResource.Type.URL) {
      if (SamStreams.sourceLikeBam(data.asUnbufferedSeekableStream())) {
        final SeekableStream bufferedIndexStream;
        if (indexDefined && indexMaybe.asUnbufferedSeekableStream() != null) {
          bufferedIndexStream=IOUtil.maybeBufferedSeekableStream(indexMaybe.asUnbufferedSeekableStream());
        }
 else {
          bufferedIndexStream=null;
        }
        primitiveSamReader=new BAMFileReader(IOUtil.maybeBufferedSeekableStream(data.asUnbufferedSeekableStream()),bufferedIndexStream,false,asynchronousIO,validationStringency,this.samRecordFactory);
      }
 else       if (SamStreams.sourceLikeCram(data.asUnbufferedSeekableStream())) {
        if (referenceSource == null) {
          referenceSource=ReferenceSource.getDefaultCRAMReferenceSource();
        }
        SeekableStream bufferedIndexStream=indexDefined ? IOUtil.maybeBufferedSeekableStream(indexMaybe.asUnbufferedSeekableStream()) : null;
        primitiveSamReader=new CRAMFileReader(IOUtil.maybeBufferedSeekableStream(data.asUnbufferedSeekableStream()),bufferedIndexStream,referenceSource,validationStringency);
      }
 else {
        LOG.warn(""String_Node_Str"");
        primitiveSamReader=new SAMTextReader(IOUtil.toBufferedStream(data.asUnbufferedInputStream()),validationStringency,this.samRecordFactory);
      }
    }
 else     if (type == InputResource.Type.SRA_ACCESSION) {
      primitiveSamReader=new SRAFileReader(data.asSRAAccession());
    }
 else {
      InputStream bufferedStream=IOUtil.maybeBufferInputStream(data.asUnbufferedInputStream(),Math.max(Defaults.BUFFER_SIZE,BlockCompressedStreamConstants.MAX_COMPRESSED_BLOCK_SIZE));
      File sourceFile=data.asFile();
      final File indexFile=indexMaybe == null ? null : indexMaybe.asFile();
      if (SamStreams.isBAMFile(bufferedStream)) {
        if (sourceFile == null || !sourceFile.isFile()) {
          final SeekableStream indexSeekable=indexMaybe == null ? null : indexMaybe.asUnbufferedSeekableStream();
          SeekableStream sourceSeekable=data.asUnbufferedSeekableStream();
          if (indexFile != null || null == sourceSeekable || null == indexSeekable) {
            primitiveSamReader=new BAMFileReader(bufferedStream,indexFile,false,asynchronousIO,validationStringency,this.samRecordFactory);
          }
 else {
            sourceSeekable.seek(0);
            primitiveSamReader=new BAMFileReader(sourceSeekable,indexSeekable,false,asynchronousIO,validationStringency,this.samRecordFactory);
          }
        }
 else {
          bufferedStream.close();
          primitiveSamReader=new BAMFileReader(sourceFile,indexFile,false,asynchronousIO,validationStringency,this.samRecordFactory);
        }
      }
 else       if (BlockCompressedInputStream.isValidFile(bufferedStream)) {
        primitiveSamReader=new SAMTextReader(new BlockCompressedInputStream(bufferedStream),validationStringency,this.samRecordFactory);
      }
 else       if (SamStreams.isGzippedSAMFile(bufferedStream)) {
        primitiveSamReader=new SAMTextReader(new GZIPInputStream(bufferedStream),validationStringency,this.samRecordFactory);
      }
 else       if (SamStreams.isCRAMFile(bufferedStream)) {
        if (referenceSource == null) {
          referenceSource=ReferenceSource.getDefaultCRAMReferenceSource();
        }
        if (sourceFile == null || !sourceFile.isFile()) {
          primitiveSamReader=new CRAMFileReader(bufferedStream,indexFile,referenceSource,validationStringency);
        }
 else {
          bufferedStream.close();
          primitiveSamReader=new CRAMFileReader(sourceFile,indexFile,referenceSource,validationStringency);
        }
      }
 else       if (sourceFile != null && isSra(sourceFile)) {
        if (bufferedStream != null) {
          bufferedStream.close();
        }
        primitiveSamReader=new SRAFileReader(new SRAAccession(sourceFile.getPath()));
      }
 else {
        if (indexDefined) {
          bufferedStream.close();
          throw new RuntimeException(""String_Node_Str"");
        }
        primitiveSamReader=new SAMTextReader(bufferedStream,sourceFile,validationStringency,this.samRecordFactory);
      }
    }
    final SamReader.PrimitiveSamReaderToSamReaderAdapter reader=new SamReader.PrimitiveSamReaderToSamReaderAdapter(primitiveSamReader,resource);
    for (    final Option option : enabledOptions) {
      option.applyTo(reader);
    }
    return reader;
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
}","@Override public SamReader open(final SamInputResource resource){
  final SamReader.PrimitiveSamReader primitiveSamReader;
  try {
    final InputResource data=resource.data();
    final InputResource indexMaybe=resource.indexMaybe();
    final boolean indexDefined=indexMaybe != null;
    final InputResource.Type type=data.type();
    if (type == InputResource.Type.URL) {
      SamReader reader=customReaderFactory.maybeOpen(data.asUrl());
      if (reader != null) {
        return reader;
      }
    }
    if (type == InputResource.Type.SEEKABLE_STREAM || type == InputResource.Type.URL) {
      if (SamStreams.sourceLikeBam(data.asUnbufferedSeekableStream())) {
        final SeekableStream bufferedIndexStream;
        if (indexDefined && indexMaybe.asUnbufferedSeekableStream() != null) {
          bufferedIndexStream=IOUtil.maybeBufferedSeekableStream(indexMaybe.asUnbufferedSeekableStream());
        }
 else {
          bufferedIndexStream=null;
        }
        primitiveSamReader=new BAMFileReader(IOUtil.maybeBufferedSeekableStream(data.asUnbufferedSeekableStream()),bufferedIndexStream,false,asynchronousIO,validationStringency,this.samRecordFactory);
      }
 else       if (SamStreams.sourceLikeCram(data.asUnbufferedSeekableStream())) {
        if (referenceSource == null) {
          referenceSource=ReferenceSource.getDefaultCRAMReferenceSource();
        }
        SeekableStream bufferedIndexStream=indexDefined ? IOUtil.maybeBufferedSeekableStream(indexMaybe.asUnbufferedSeekableStream()) : null;
        primitiveSamReader=new CRAMFileReader(IOUtil.maybeBufferedSeekableStream(data.asUnbufferedSeekableStream()),bufferedIndexStream,referenceSource,validationStringency);
      }
 else {
        LOG.warn(""String_Node_Str"");
        primitiveSamReader=new SAMTextReader(IOUtil.toBufferedStream(data.asUnbufferedInputStream()),validationStringency,this.samRecordFactory);
      }
    }
 else     if (type == InputResource.Type.SRA_ACCESSION) {
      primitiveSamReader=new SRAFileReader(data.asSRAAccession());
    }
 else {
      InputStream bufferedStream=IOUtil.maybeBufferInputStream(data.asUnbufferedInputStream(),Math.max(Defaults.BUFFER_SIZE,BlockCompressedStreamConstants.MAX_COMPRESSED_BLOCK_SIZE));
      File sourceFile=data.asFile();
      final File indexFile=indexMaybe == null ? null : indexMaybe.asFile();
      if (SamStreams.isBAMFile(bufferedStream)) {
        if (sourceFile == null || !sourceFile.isFile()) {
          final SeekableStream indexSeekable=indexMaybe == null ? null : indexMaybe.asUnbufferedSeekableStream();
          SeekableStream sourceSeekable=data.asUnbufferedSeekableStream();
          if (null == sourceSeekable || null == indexSeekable) {
            primitiveSamReader=new BAMFileReader(bufferedStream,indexFile,false,asynchronousIO,validationStringency,this.samRecordFactory);
          }
 else {
            sourceSeekable.seek(0);
            primitiveSamReader=new BAMFileReader(sourceSeekable,indexSeekable,false,asynchronousIO,validationStringency,this.samRecordFactory);
          }
        }
 else {
          bufferedStream.close();
          primitiveSamReader=new BAMFileReader(sourceFile,indexFile,false,asynchronousIO,validationStringency,this.samRecordFactory);
        }
      }
 else       if (BlockCompressedInputStream.isValidFile(bufferedStream)) {
        primitiveSamReader=new SAMTextReader(new BlockCompressedInputStream(bufferedStream),validationStringency,this.samRecordFactory);
      }
 else       if (SamStreams.isGzippedSAMFile(bufferedStream)) {
        primitiveSamReader=new SAMTextReader(new GZIPInputStream(bufferedStream),validationStringency,this.samRecordFactory);
      }
 else       if (SamStreams.isCRAMFile(bufferedStream)) {
        if (referenceSource == null) {
          referenceSource=ReferenceSource.getDefaultCRAMReferenceSource();
        }
        if (sourceFile == null || !sourceFile.isFile()) {
          primitiveSamReader=new CRAMFileReader(bufferedStream,indexFile,referenceSource,validationStringency);
        }
 else {
          bufferedStream.close();
          primitiveSamReader=new CRAMFileReader(sourceFile,indexFile,referenceSource,validationStringency);
        }
      }
 else       if (sourceFile != null && isSra(sourceFile)) {
        if (bufferedStream != null) {
          bufferedStream.close();
        }
        primitiveSamReader=new SRAFileReader(new SRAAccession(sourceFile.getPath()));
      }
 else {
        if (indexDefined) {
          bufferedStream.close();
          throw new RuntimeException(""String_Node_Str"");
        }
        primitiveSamReader=new SAMTextReader(bufferedStream,sourceFile,validationStringency,this.samRecordFactory);
      }
    }
    final SamReader.PrimitiveSamReaderToSamReaderAdapter reader=new SamReader.PrimitiveSamReaderToSamReaderAdapter(primitiveSamReader,resource);
    for (    final Option option : enabledOptions) {
      option.applyTo(reader);
    }
    return reader;
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
}",0.9979230540994956
30451,"/** 
 * Reads text SAM header and converts to a SAMFileHeader object.
 * @param reader Where to get header text from.
 * @param source Name of the input file, for error messages.  May be null.
 * @return complete header object.
 */
public SAMFileHeader decode(final LineReader reader,final String source){
  mFileHeader=new SAMFileHeader();
  mReader=reader;
  mSource=source;
  sequences=new ArrayList<SAMSequenceRecord>();
  readGroups=new ArrayList<SAMReadGroupRecord>();
  while (advanceLine() != null) {
    final ParsedHeaderLine parsedHeaderLine=new ParsedHeaderLine(mCurrentLine);
    if (!parsedHeaderLine.isLineValid()) {
      continue;
    }
switch (parsedHeaderLine.getHeaderRecordType()) {
case HD:
      parseHDLine(parsedHeaderLine);
    break;
case PG:
  parsePGLine(parsedHeaderLine);
break;
case RG:
parseRGLine(parsedHeaderLine);
break;
case SQ:
parseSQLine(parsedHeaderLine);
break;
case CO:
mFileHeader.addComment(mCurrentLine);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + parsedHeaderLine.getHeaderRecordType());
}
}
mFileHeader.setSequenceDictionary(new SAMSequenceDictionary(sequences));
mFileHeader.setReadGroups(readGroups);
if (!mFileHeader.getValidationErrors().isEmpty() || textHeader.length() < (1024 * 1024)) {
mFileHeader.setTextHeader(textHeader.toString());
}
SAMUtils.processValidationErrors(mFileHeader.getValidationErrors(),-1,validationStringency);
return mFileHeader;
}","/** 
 * Reads text SAM header and converts to a SAMFileHeader object.
 * @param reader Where to get header text from.
 * @param source Name of the input file, for error messages.  May be null.
 * @return complete header object.
 */
public SAMFileHeader decode(final LineReader reader,final String source){
  mFileHeader=new SAMFileHeader();
  mReader=reader;
  mSource=source;
  sequences=new ArrayList<>();
  readGroups=new ArrayList<>();
  while (advanceLine() != null) {
    final ParsedHeaderLine parsedHeaderLine=new ParsedHeaderLine(mCurrentLine);
    if (!parsedHeaderLine.isLineValid()) {
      continue;
    }
switch (parsedHeaderLine.getHeaderRecordType()) {
case HD:
      parseHDLine(parsedHeaderLine);
    break;
case PG:
  parsePGLine(parsedHeaderLine);
break;
case RG:
parseRGLine(parsedHeaderLine);
break;
case SQ:
parseSQLine(parsedHeaderLine);
break;
case CO:
mFileHeader.addComment(mCurrentLine);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + parsedHeaderLine.getHeaderRecordType());
}
}
mFileHeader.setSequenceDictionary(new SAMSequenceDictionary(sequences));
mFileHeader.setReadGroups(readGroups);
if (!mFileHeader.getValidationErrors().isEmpty() || textHeader.length() < (1024 * 1024)) {
mFileHeader.setTextHeader(textHeader.toString());
}
SAMUtils.processValidationErrors(mFileHeader.getValidationErrors(),-1,validationStringency);
return mFileHeader;
}",0.9721143663960466
30452,"/** 
 * Create a CRAMFileReader from a CRAM file and optional index file using the supplied reference source and validation stringency.
 * @param cramFile        CRAM stream to read. May not be null.
 * @param indexFile       index file to be used for random access. May be null.
 * @param referenceSource a {@link htsjdk.samtools.cram.ref.CRAMReferenceSource source} ofreference sequences. May not be null.
 * @param validationStringency Validation stringency to be used when reading
 * @throws IllegalArgumentException if the {@code cramFile} or the {@code CRAMReferenceSource} is null
 */
public CRAMFileReader(final File cramFile,final File indexFile,final CRAMReferenceSource referenceSource,final ValidationStringency validationStringency) throws IOException {
  this(new FileInputStream(cramFile),indexFile,referenceSource,validationStringency);
  this.cramFile=cramFile;
}","/** 
 * Create a CRAMFileReader from a CRAM file and optional index file using the supplied reference source and validation stringency.
 * @param cramFile        CRAM stream to read. May not be null.
 * @param indexFile       index file to be used for random access. May be null.
 * @param referenceSource a {@link htsjdk.samtools.cram.ref.CRAMReferenceSource source} ofreference sequences. May not be null.
 * @param validationStringency Validation stringency to be used when reading
 * @throws IllegalArgumentException if the {@code cramFile} or the {@code CRAMReferenceSource} is null
 */
public CRAMFileReader(final File cramFile,final File indexFile,final CRAMReferenceSource referenceSource,final ValidationStringency validationStringency) throws IOException {
  if (cramFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (referenceSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.cramFile=cramFile;
  this.referenceSource=referenceSource;
  this.mIndexFile=findIndexForFile(indexFile,cramFile);
  final SeekableFileStream indexStream=this.mIndexFile == null ? null : new SeekableFileStream(this.mIndexFile);
  initWithStreams(new FileInputStream(cramFile),indexStream,validationStringency);
}",0.7726638772663877
30453,"private ReferenceSource createReferenceSource(){
  byte[] refBases=new byte[10 * 10];
  Arrays.fill(refBases,(byte)'A');
  InMemoryReferenceSequenceFile rsf=new InMemoryReferenceSequenceFile();
  rsf.add(""String_Node_Str"",refBases);
  return new ReferenceSource(rsf);
}","private static ReferenceSource createReferenceSource(){
  byte[] refBases=new byte[10 * 10];
  Arrays.fill(refBases,(byte)'A');
  InMemoryReferenceSequenceFile rsf=new InMemoryReferenceSequenceFile();
  rsf.add(""String_Node_Str"",refBases);
  return new ReferenceSource(rsf);
}",0.9871559633027523
30454,"@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader6_InputRequired() throws IOException {
  InputStream bis=null;
  File file=null;
  ReferenceSource refSource=null;
  new CRAMFileReader(bis,file,createReferenceSource(),ValidationStringency.STRICT);
}","@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader6_InputRequired() throws IOException {
  InputStream bis=null;
  File file=null;
  new CRAMFileReader(bis,file,createReferenceSource(),ValidationStringency.STRICT);
}",0.9425675675675677
30455,"@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader7_ReferenceRequired() throws IOException {
  InputStream bis=new ByteArrayInputStream(new byte[0]);
  File file=new File(TEST_DATA_DIR,""String_Node_Str"");
  ReferenceSource refSource=null;
  new CRAMFileReader(file,file,refSource,ValidationStringency.STRICT);
}","@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader7_ReferenceRequired() throws IOException {
  ReferenceSource refSource=null;
  new CRAMFileReader(CRAM_WITH_CRAI,CRAM_WITH_CRAI,refSource,ValidationStringency.STRICT);
}",0.6432926829268293
30456,"@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader3_RequiredReference(){
  File inputFile=new File(TEST_DATA_DIR,""String_Node_Str"");
  File indexFile=null;
  ReferenceSource refSource=null;
  new CRAMFileReader(inputFile,indexFile,refSource);
}","@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader3_RequiredReference(){
  File indexFile=null;
  ReferenceSource refSource=null;
  new CRAMFileReader(CRAM_WITH_CRAI,indexFile,refSource);
}",0.5617173524150268
30457,"@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader4_ReferenceRequired(){
  File inputFile=new File(TEST_DATA_DIR,""String_Node_Str"");
  ReferenceSource refSource=null;
  new CRAMFileReader(inputFile,refSource);
}","@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader4_ReferenceRequired(){
  ReferenceSource refSource=null;
  new CRAMFileReader(CRAM_WITH_CRAI,refSource);
}",0.7221095334685599
30458,"@Test(description=""String_Node_Str"",expectedExceptions=IllegalStateException.class) public void testCRAMReader1_ReferenceRequired(){
  File file=new File(TEST_DATA_DIR,""String_Node_Str"");
  InputStream bis=null;
  new CRAMFileReader(file,bis);
}","@Test(description=""String_Node_Str"",expectedExceptions=IllegalStateException.class) public void testCRAMReader1_ReferenceRequired(){
  InputStream bis=null;
  new CRAMFileReader(CRAM_WITH_CRAI,bis);
}",0.755056179775281
30459,"@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader2ReferenceRequired(){
  File file=new File(TEST_DATA_DIR,""String_Node_Str"");
  InputStream bis=null;
  new CRAMFileReader(file,bis,null);
}","@Test(description=""String_Node_Str"",expectedExceptions=IllegalArgumentException.class) public void testCRAMReader2ReferenceRequired(){
  InputStream bis=null;
  new CRAMFileReader(CRAM_WITH_CRAI,bis,null);
}",0.7625272331154684
30460,"/** 
 * Checks to see if an exception has been raised in the writer thread and if so rethrows it as an Error or RuntimeException as appropriate.
 */
private final void checkAndRethrow(){
  final Throwable t=this.ex.get();
  if (t != null) {
    if (t instanceof Error)     throw (Error)t;
    if (t instanceof RuntimeException)     throw (RuntimeException)t;
 else     throw new RuntimeException(t);
  }
}","/** 
 * Checks to see if an exception has been raised in the writer thread and if so rethrows it as an Error or RuntimeException as appropriate.
 */
private final void checkAndRethrow(){
  final Throwable t=this.ex.getAndSet(null);
  if (t != null) {
    this.isClosed.set(true);
    if (t instanceof Error)     throw (Error)t;
    if (t instanceof RuntimeException)     throw (RuntimeException)t;
 else     throw new RuntimeException(t);
  }
}",0.8527679623085983
30461,"/** 
 * Create a CRAMContainerStreamWriter for writing SAM records into a series of CRAM containers on output stream, with an optional index.
 * @param outputStream where to write the CRAM stream.
 * @param indexStream where to write the output index. Can be null if no index is required.
 * @param source reference source
 * @param samFileHeader {@link SAMFileHeader} to be used. Sort order is determined by the sortOrder property of this arg.
 * @param cramId used for display in error message display
 */
public CRAMContainerStreamWriter(final OutputStream outputStream,final OutputStream indexStream,final ReferenceSource source,final SAMFileHeader samFileHeader,final String cramId){
  this.outputStream=outputStream;
  this.samFileHeader=samFileHeader;
  this.cramID=cramId;
  this.source=source;
  containerFactory=new ContainerFactory(samFileHeader,recordsPerSlice);
  if (indexStream != null) {
    indexer=new CRAMBAIIndexer(indexStream,samFileHeader);
  }
}","/** 
 * Create a CRAMContainerStreamWriter for writing SAM records into a series of CRAM containers on output stream, with an optional index.
 * @param outputStream where to write the CRAM stream.
 * @param indexStream where to write the output index. Can be null if no index is required.
 * @param source reference source
 * @param samFileHeader {@link SAMFileHeader} to be used. Sort order is determined by the sortOrder property of this arg.
 * @param cramId used for display in error message display
 */
public CRAMContainerStreamWriter(final OutputStream outputStream,final OutputStream indexStream,final CRAMReferenceSource source,final SAMFileHeader samFileHeader,final String cramId){
  this.outputStream=outputStream;
  this.samFileHeader=samFileHeader;
  this.cramID=cramId;
  this.source=source;
  containerFactory=new ContainerFactory(samFileHeader,recordsPerSlice);
  if (indexStream != null) {
    indexer=new CRAMBAIIndexer(indexStream,samFileHeader);
  }
}",0.9979381443298968
30462,"/** 
 * Create a CRAMFileReader from a CRAM file and optional index file using the supplied reference source and validation stringency.
 * @param cramFile        CRAM stream to read. May not be null.
 * @param indexFile       index file to be used for random access. May be null.
 * @param referenceSource a {@link htsjdk.samtools.cram.ref.ReferenceSource source} ofreference sequences. May not be null.
 * @param validationStringency Validation stringency to be used when reading
 * @throws IllegalArgumentException if the {@code cramFile} or the {@code ReferenceSource} is null
 */
public CRAMFileReader(final File cramFile,final File indexFile,final ReferenceSource referenceSource,final ValidationStringency validationStringency) throws IOException {
  this(new FileInputStream(cramFile),indexFile,referenceSource,validationStringency);
  this.cramFile=cramFile;
}","/** 
 * Create a CRAMFileReader from a CRAM file and optional index file using the supplied reference source and validation stringency.
 * @param cramFile        CRAM stream to read. May not be null.
 * @param indexFile       index file to be used for random access. May be null.
 * @param referenceSource a {@link htsjdk.samtools.cram.ref.CRAMReferenceSource source} ofreference sequences. May not be null.
 * @param validationStringency Validation stringency to be used when reading
 * @throws IllegalArgumentException if the {@code cramFile} or the {@code CRAMReferenceSource} is null
 */
public CRAMFileReader(final File cramFile,final File indexFile,final CRAMReferenceSource referenceSource,final ValidationStringency validationStringency) throws IOException {
  this(new FileInputStream(cramFile),indexFile,referenceSource,validationStringency);
  this.cramFile=cramFile;
}",0.9931350114416476
30463,"/** 
 * Create a CRAMFileWriter and optional index on output streams.
 * @param outputStream where to write the output. Can not be null.
 * @param indexOS where to write the output index. Can be null if no index is required.
 * @param presorted if true records written to this writer must already be sorted in the order specified by the header
 * @param referenceSource reference source
 * @param samFileHeader {@link SAMFileHeader} to be used. Can not be null. Sort order is determined by the sortOrder property of this arg.
 * @param fileName used for display in error message display
 * @throws IllegalArgumentException if the {@code outputStream},   {@code referenceSource} or {@code samFileHeader} are null
 */
public CRAMFileWriter(final OutputStream outputStream,final OutputStream indexOS,final boolean presorted,final ReferenceSource referenceSource,final SAMFileHeader samFileHeader,final String fileName){
  if (outputStream == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (referenceSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (samFileHeader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.samFileHeader=samFileHeader;
  this.fileName=fileName;
  setSortOrder(samFileHeader.getSortOrder(),presorted);
  cramContainerStream=new CRAMContainerStreamWriter(outputStream,indexOS,referenceSource,samFileHeader,fileName);
  setHeader(samFileHeader);
}","/** 
 * Create a CRAMFileWriter and optional index on output streams.
 * @param outputStream where to write the output. Can not be null.
 * @param indexOS where to write the output index. Can be null if no index is required.
 * @param presorted if true records written to this writer must already be sorted in the order specified by the header
 * @param referenceSource reference source
 * @param samFileHeader {@link SAMFileHeader} to be used. Can not be null. Sort order is determined by the sortOrder property of this arg.
 * @param fileName used for display in error message display
 * @throws IllegalArgumentException if the {@code outputStream},   {@code referenceSource} or {@code samFileHeader} are null
 */
public CRAMFileWriter(final OutputStream outputStream,final OutputStream indexOS,final boolean presorted,final CRAMReferenceSource referenceSource,final SAMFileHeader samFileHeader,final String fileName){
  if (outputStream == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (referenceSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (samFileHeader == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.samFileHeader=samFileHeader;
  this.fileName=fileName;
  setSortOrder(samFileHeader.getSortOrder(),presorted);
  cramContainerStream=new CRAMContainerStreamWriter(outputStream,indexOS,referenceSource,samFileHeader,fileName);
  setHeader(samFileHeader);
}",0.9986329460013672
30464,"@Deprecated public CRAMIterator(final SeekableStream seekableStream,final ReferenceSource referenceSource,final long[] coordinates) throws IOException {
  this(seekableStream,referenceSource,coordinates,ValidationStringency.DEFAULT_STRINGENCY);
}","@Deprecated public CRAMIterator(final SeekableStream seekableStream,final CRAMReferenceSource referenceSource,final long[] coordinates) throws IOException {
  this(seekableStream,referenceSource,coordinates,ValidationStringency.DEFAULT_STRINGENCY);
}",0.9919354838709676
30465,"@Override public SamReaderFactory referenceSource(final ReferenceSource referenceSource){
  this.referenceSource=referenceSource;
  return this;
}","@Override public SamReaderFactory referenceSource(final CRAMReferenceSource referenceSource){
  this.referenceSource=referenceSource;
  return this;
}",0.9864864864864864
30466,"public CramNormalizer(final SAMFileHeader header,final ReferenceSource referenceSource){
  if (referenceSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.header=header;
  this.referenceSource=referenceSource;
}","public CramNormalizer(final SAMFileHeader header,final CRAMReferenceSource referenceSource){
  if (referenceSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.header=header;
  this.referenceSource=referenceSource;
}",0.992
30467,"/** 
 * Attempts to construct a default ReferenceSource for use with CRAM files when one has not been explicitly provided.
 * @return ReferenceSource if one can be acquired. Guaranteed to no be null if noneof the listed exceptions is thrown.
 * @throws IllegalStateException if no default reference source can be acquired
 * @throws IllegalArgumentException if the reference_fasta environment variable refers to aa file that doesn't exist <p> Construct a default reference source to use when an explicit reference has not been provided by checking for fallback sources in this order: <p><ul> <li>Defaults.REFERENCE_FASTA - the value of the system property ""reference_fasta"". If set, must refer to a valid reference file.</li> <li>ENA Reference Service if it is enabled</li> </ul>
 */
public static ReferenceSource getDefaultCRAMReferenceSource(){
  if (null != Defaults.REFERENCE_FASTA) {
    if (Defaults.REFERENCE_FASTA.exists()) {
      return new ReferenceSource(Defaults.REFERENCE_FASTA);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + Defaults.REFERENCE_FASTA.getName());
    }
  }
 else   if (Defaults.USE_CRAM_REF_DOWNLOAD) {
    return new ReferenceSource();
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","/** 
 * Attempts to construct a default CRAMReferenceSource for use with CRAM files when one has not been explicitly provided.
 * @return CRAMReferenceSource if one can be acquired. Guaranteed to not be null if noneof the listed exceptions is thrown.
 * @throws IllegalStateException if no default reference source can be acquired
 * @throws IllegalArgumentException if the reference_fasta environment variable refers to aa file that doesn't exist <p> Construct a default reference source to use when an explicit reference has not been provided by checking for fallback sources in this order: <p><ul> <li>Defaults.REFERENCE_FASTA - the value of the system property ""reference_fasta"". If set, must refer to a valid reference file.</li> <li>ENA Reference Service if it is enabled</li> </ul>
 */
public static CRAMReferenceSource getDefaultCRAMReferenceSource(){
  if (null != Defaults.REFERENCE_FASTA) {
    if (Defaults.REFERENCE_FASTA.exists()) {
      return new ReferenceSource(Defaults.REFERENCE_FASTA);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + Defaults.REFERENCE_FASTA.getName());
    }
  }
 else   if (Defaults.USE_CRAM_REF_DOWNLOAD) {
    return new ReferenceSource();
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.994903959231674
30468,"/** 
 * If true, uses the caching version of the index reader.
 * @param enabled true to write source information into each SAMRecord.
 */
protected void enableIndexCaching(final boolean enabled){
  if (mIndex != null)   throw new SAMException(""String_Node_Str"");
  this.mEnableIndexCaching=enabled;
}","/** 
 * If true, uses the caching version of the index reader.
 * @param enabled true to use the caching version of the reader.
 */
protected void enableIndexCaching(final boolean enabled){
  if (mIndex != null)   throw new SAMException(""String_Node_Str"");
  this.mEnableIndexCaching=enabled;
}",0.8638655462184874
30469,"/** 
 * Prepare to index a BAM.
 * @param output     Index will be written here.  output will be closed when finish() method is called.
 * @param fileHeader header for the corresponding bam file.
 */
public BAMIndexer(final OutputStream output,final SAMFileHeader fileHeader){
  numReferences=fileHeader.getSequenceDictionary().size();
  indexBuilder=new BAMIndexBuilder(fileHeader.getSequenceDictionary());
  outputWriter=new BinaryBAMIndexWriter(numReferences,output);
}","private BAMIndexer(final SAMFileHeader fileHeader,Function<Integer,BinaryBAMIndexWriter> createWriter){
  if (fileHeader.getSortOrder() != SAMFileHeader.SortOrder.coordinate) {
    if (fileHeader.getSortOrder() == SAMFileHeader.SortOrder.unsorted) {
      log.warn(""String_Node_Str"");
    }
 else {
      throw new SAMException(""String_Node_Str"");
    }
  }
  numReferences=fileHeader.getSequenceDictionary().size();
  indexBuilder=new BAMIndexBuilder(fileHeader.getSequenceDictionary());
  outputWriter=createWriter.apply(numReferences);
}",0.341897233201581
30470,"public SAMBinaryTagAndUnsignedArrayValue(final short tag,final Object value){
  super(tag,value);
}","public SAMBinaryTagAndUnsignedArrayValue(final short tag,final Object value){
  super(tag,value);
  if (!value.getClass().isArray() || value instanceof float[]) {
    throw new IllegalArgumentException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
  }
}",0.4817518248175182
30471,"@Override public int hashCode(){
  int result=(int)tag;
  result=31 * result + value.hashCode();
  return result;
}","@Override public int hashCode(){
  int valueHash;
  if (this.value instanceof byte[]) {
    valueHash=Arrays.hashCode((byte[])this.value);
  }
 else   if (this.value instanceof short[]) {
    valueHash=Arrays.hashCode((short[])this.value);
  }
 else   if (this.value instanceof int[]) {
    valueHash=Arrays.hashCode((int[])this.value);
  }
 else   if (this.value instanceof float[]) {
    valueHash=Arrays.hashCode((float[])this.value);
  }
 else {
    valueHash=value.hashCode();
  }
  return 31 * tag + valueHash;
}",0.1800947867298578
30472,"/** 
 * Type safe equals method that recurses down the list looking for equality. 
 */
private boolean typeSafeEquals(final SAMBinaryTagAndValue that){
  if (this.tag != that.tag)   return false;
  if ((this.value == null) ? that.value == null : this.value.equals(that.value)) {
    if (this.next == null)     return that.next == null;
 else     return this.next.equals(that.next);
  }
 else {
    return false;
  }
}","/** 
 * Type safe equals method that recurses down the list looking for equality. 
 */
private boolean typeSafeEquals(final SAMBinaryTagAndValue that){
  if (this.tag != that.tag)   return false;
  if (this.valueEquals(that)) {
    if (this.next == null)     return that.next == null;
 else     return this.next.equals(that.next);
  }
 else {
    return false;
  }
}",0.9067688378033204
30473,"/** 
 * @param tag tagname (in binary form) for this attribute
 * @param value value for this attribute (must be of a type that implements {@link Serializable} or else serialization will fail)Cannot be null.
 */
public SAMBinaryTagAndValue(final short tag,final Object value){
  if (null == value) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tag=tag;
  this.value=value;
}","/** 
 * @param tag tagname (in binary form) for this attribute
 * @param value value for this attribute (must be of a type that implements {@link Serializable}or else serialization will fail). Cannot be null.
 */
public SAMBinaryTagAndValue(final short tag,final Object value){
  if (null == value) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!isAllowedAttributeValue(value)) {
    throw new IllegalArgumentException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
  }
  this.tag=tag;
  this.value=value;
}",0.806060606060606
30474,"/** 
 * If true, uses the caching version of the index reader.
 * @param enabled true to write source information into each SAMRecord.
 */
public void enableIndexCaching(final boolean enabled){
  if (mIndex != null)   throw new SAMException(""String_Node_Str"");
  mReader.enableIndexCaching(enabled);
}","/** 
 * If true, uses the caching version of the index reader.
 * @param enabled true to use the caching version of the reader.
 */
public void enableIndexCaching(final boolean enabled){
  if (mIndex != null)   throw new SAMException(""String_Node_Str"");
  mReader.enableIndexCaching(enabled);
}",0.8638655462184874
30475,"/** 
 * Checks if the value is allowed as an attribute value.
 * @param value the value to be checked
 * @return true if the value is valid and false otherwise
 */
protected static boolean isAllowedAttributeValue(final Object value){
  if (value instanceof Byte || value instanceof Short || value instanceof Integer|| value instanceof String|| value instanceof Character|| value instanceof Float|| value instanceof byte[]|| value instanceof short[]|| value instanceof int[]|| value instanceof float[]) {
    return true;
  }
  if (value instanceof Long) {
    return SAMUtils.isValidUnsignedIntegerAttribute((Long)value) || ((Long)value >= Integer.MIN_VALUE && (Long)value <= Integer.MAX_VALUE);
  }
  return false;
}","/** 
 * Checks if the value is allowed as an attribute value.
 * @param value the value to be checked
 * @return true if the value is valid and false otherwise
 * @deprecated The attribute type and value checks have been moved directly into {@code SAMBinaryTagAndValue}.
 */
@Deprecated protected static boolean isAllowedAttributeValue(final Object value){
  return SAMBinaryTagAndValue.isAllowedAttributeValue(value);
}",0.4327176781002638
30476,"protected void setAttribute(final short tag,final Object value,final boolean isUnsignedArray){
  if (value == null) {
    if (this.mAttributes != null) {
      this.mAttributes=this.mAttributes.remove(tag);
    }
    return;
  }
  if (isAllowedAttributeValue(value)) {
    final SAMBinaryTagAndValue tmp;
    if (!isUnsignedArray) {
      tmp=new SAMBinaryTagAndValue(tag,value);
    }
 else {
      if (!value.getClass().isArray() || value instanceof float[]) {
        throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
      }
      tmp=new SAMBinaryTagAndUnsignedArrayValue(tag,value);
    }
    if (this.mAttributes == null) {
      this.mAttributes=tmp;
    }
 else {
      this.mAttributes=this.mAttributes.insert(tmp);
    }
  }
 else {
    throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
  }
}","protected void setAttribute(final short tag,final Object value,final boolean isUnsignedArray){
  if (value == null) {
    if (this.mAttributes != null) {
      this.mAttributes=this.mAttributes.remove(tag);
    }
  }
 else {
    final SAMBinaryTagAndValue tmp;
    if (!isUnsignedArray) {
      tmp=new SAMBinaryTagAndValue(tag,value);
    }
 else {
      tmp=new SAMBinaryTagAndUnsignedArrayValue(tag,value);
    }
    if (this.mAttributes == null) {
      this.mAttributes=tmp;
    }
 else {
      this.mAttributes=this.mAttributes.insert(tmp);
    }
  }
}",0.7251153592617007
30477,"/** 
 * Returns a deep copy of the SAM record, with the following exceptions: - The header field, which shares the reference with the original record - The file source field, which will always always be set to null in the copy Note that some fields, i.e. the cigar elements, alignment blocks, and indexing bin, are not explicitly populated in the copy since they are lazily generated on demand. Also note that this fails: original.deepCopy().equals(original) due to the fact that SAMBinaryTagAndValue.equals winds up calling object.equals on the value field, which uses reference equality.
 */
public SAMRecord deepCopy(){
  final SAMRecord newSAM=new SAMRecord(getHeader());
  newSAM.setReadName(getReadName());
  newSAM.setReadBases(Arrays.copyOf(getReadBases(),getReadLength()));
  final byte baseQualities[]=getBaseQualities();
  newSAM.setBaseQualities(Arrays.copyOf(baseQualities,baseQualities.length));
  newSAM.setReferenceName(getReferenceName());
  newSAM.setAlignmentStart(getAlignmentStart());
  newSAM.setMappingQuality(getMappingQuality());
  newSAM.setCigarString(getCigarString());
  newSAM.setFileSource(null);
  newSAM.setFlags(getFlags());
  newSAM.setMateReferenceName(getMateReferenceName());
  newSAM.setMateAlignmentStart(getMateAlignmentStart());
  newSAM.setInferredInsertSize(getInferredInsertSize());
  if (null != getHeader()) {
    newSAM.setReferenceIndex(getReferenceIndex());
    newSAM.setMateReferenceIndex(getMateReferenceIndex());
  }
 else {
    newSAM.mReferenceIndex=null;
    newSAM.mMateReferenceIndex=null;
  }
  newSAM.setValidationStringency(getValidationStringency());
  SAMBinaryTagAndValue attributes=getBinaryAttributes();
  if (null != attributes) {
    newSAM.setAttributes(attributes.deepCopy());
  }
  return newSAM;
}","/** 
 * Returns a deep copy of the SAM record, with the following exceptions: - The header field, which shares the header reference with the original record - The file source field, which will always always be set to null in the copy
 */
public SAMRecord deepCopy(){
  final SAMRecord newSAM=new SAMRecord(getHeader());
  newSAM.setReadName(getReadName());
  newSAM.setReadBases(Arrays.copyOf(getReadBases(),getReadLength()));
  final byte baseQualities[]=getBaseQualities();
  newSAM.setBaseQualities(Arrays.copyOf(baseQualities,baseQualities.length));
  newSAM.setReferenceName(getReferenceName());
  newSAM.setAlignmentStart(getAlignmentStart());
  newSAM.setMappingQuality(getMappingQuality());
  newSAM.setCigarString(getCigarString());
  newSAM.setFileSource(null);
  newSAM.setFlags(getFlags());
  newSAM.setMateReferenceName(getMateReferenceName());
  newSAM.setMateAlignmentStart(getMateAlignmentStart());
  newSAM.setInferredInsertSize(getInferredInsertSize());
  newSAM.mReferenceIndex=this.mReferenceIndex;
  newSAM.mMateReferenceIndex=this.mMateReferenceIndex;
  newSAM.setValidationStringency(getValidationStringency());
  SAMBinaryTagAndValue attributes=getBinaryAttributes();
  if (null != attributes) {
    newSAM.setAttributes(attributes.deepCopy());
  }
  newSAM.setIndexingBin(getIndexingBin());
  return newSAM;
}",0.6494845360824743
30478,"void setAttribute(final short tag,final Object value,final boolean isUnsignedArray){
  if (value != null && !(value instanceof Byte || value instanceof Short || value instanceof Integer|| value instanceof String|| value instanceof Character|| value instanceof Float|| value instanceof byte[]|| value instanceof short[]|| value instanceof int[]|| value instanceof float[])) {
    throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
  }
  if (value == null) {
    if (this.sliceTags != null)     this.sliceTags=this.sliceTags.remove(tag);
  }
 else {
    final SAMBinaryTagAndValue tmp;
    if (!isUnsignedArray) {
      tmp=new SAMBinaryTagAndValue(tag,value);
    }
 else {
      if (!value.getClass().isArray() || value instanceof float[]) {
        throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
      }
      tmp=new SAMBinaryTagAndUnsignedArrayValue(tag,value);
    }
    if (this.sliceTags == null)     this.sliceTags=tmp;
 else     this.sliceTags=this.sliceTags.insert(tmp);
  }
}","void setAttribute(final short tag,final Object value,final boolean isUnsignedArray){
  if (value == null) {
    if (this.sliceTags != null)     this.sliceTags=this.sliceTags.remove(tag);
  }
 else {
    final SAMBinaryTagAndValue tmp;
    if (!isUnsignedArray) {
      tmp=new SAMBinaryTagAndValue(tag,value);
    }
 else {
      tmp=new SAMBinaryTagAndUnsignedArrayValue(tag,value);
    }
    if (this.sliceTags == null)     this.sliceTags=tmp;
 else     this.sliceTags=this.sliceTags.insert(tmp);
  }
}",0.6120218579234973
30479,"/** 
 * @param chr   the chromosome
 * @param start the start position, one-based, inclusive.
 * @param end   the end position, one-based, inclusive.
 * @return List of regions of file that are candidates for the given query.<p/> TODO: This method has not yet been tested, since the primary task is index writing.
 */
@Override public List<Block> getBlocks(final String chr,final int start,final int end){
  final int sequenceIndex=sequenceNames.indexOf(chr);
  if (sequenceIndex == -1 || indices[sequenceIndex] == null) {
    return Collections.emptyList();
  }
  final List<Chunk> chunks=indices[sequenceIndex].getChunksOverlapping(start,end);
  final List<Block> ret=new ArrayList<Block>(chunks.size());
  for (  final Chunk chunk : chunks) {
    ret.add(new Block(chunk.getChunkStart(),chunk.getChunkEnd() - chunk.getChunkStart()));
  }
  return ret;
}","/** 
 * @param chr   the chromosome
 * @param start the start position, one-based, inclusive.
 * @param end   the end position, one-based, inclusive.
 * @return List of regions of file that are candidates for the given query.<p/> TODO: This method has not yet been tested, since the primary task is index writing.
 */
@Override public List<Block> getBlocks(final String chr,final int start,final int end){
  final int sequenceIndex=sequenceNames.indexOf(chr);
  if (sequenceIndex == -1 || indices[sequenceIndex] == null) {
    return Collections.emptyList();
  }
  final List<Chunk> chunks=indices[sequenceIndex].getChunksOverlapping(start,end);
  if (chunks == null) {
    return Collections.emptyList();
  }
 else {
    final List<Block> ret=new ArrayList<>(chunks.size());
    chunks.stream().map(chunk -> new Block(chunk.getChunkStart(),chunk.getChunkEnd() - chunk.getChunkStart())).forEach(ret::add);
    return ret;
  }
}",0.786315199102636
30480,"public final static boolean canDecodeFile(final String potentialInput,final String MAGIC_HEADER_LINE){
  try (final FileInputStream fis=new FileInputStream(potentialInput);final GZIPInputStream gis=new GZIPInputStream(new FileInputStream(potentialInput));final BlockCompressedInputStream bcis=new BlockCompressedInputStream(new FileInputStream(potentialInput))){
    return isVCFStream(fis,MAGIC_HEADER_LINE) || isVCFStream(gis,MAGIC_HEADER_LINE) || isVCFStream(bcis,MAGIC_HEADER_LINE);
  }
 catch (  FileNotFoundException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
}","public static boolean canDecodeFile(final String potentialInput,final String MAGIC_HEADER_LINE){
  try {
    return isVCFStream(new FileInputStream(potentialInput),MAGIC_HEADER_LINE) || isVCFStream(new GZIPInputStream(new FileInputStream(potentialInput)),MAGIC_HEADER_LINE) || isVCFStream(new BlockCompressedInputStream(new FileInputStream(potentialInput)),MAGIC_HEADER_LINE);
  }
 catch (  FileNotFoundException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
}",0.4889705882352941
30481,"private final static boolean isVCFStream(final InputStream stream,final String MAGIC_HEADER_LINE){
  try {
    byte[] buff=new byte[MAGIC_HEADER_LINE.length()];
    int nread=stream.read(buff,0,MAGIC_HEADER_LINE.length());
    boolean eq=Arrays.equals(buff,MAGIC_HEADER_LINE.getBytes());
    return eq;
  }
 catch (  IOException e) {
    return false;
  }
catch (  RuntimeException e) {
    return false;
  }
 finally {
    try {
      stream.close();
    }
 catch (    IOException e) {
    }
  }
}","private static boolean isVCFStream(final InputStream stream,final String MAGIC_HEADER_LINE){
  try {
    byte[] buff=new byte[MAGIC_HEADER_LINE.length()];
    int nread=stream.read(buff,0,MAGIC_HEADER_LINE.length());
    boolean eq=Arrays.equals(buff,MAGIC_HEADER_LINE.getBytes());
    return eq;
  }
 catch (  IOException e) {
    return false;
  }
catch (  RuntimeException e) {
    return false;
  }
 finally {
    try {
      stream.close();
    }
 catch (    IOException e) {
    }
  }
}",0.993939393939394
30482,"public final static boolean canDecodeFile(final String potentialInput,final String MAGIC_HEADER_LINE){
  try (final FileInputStream fis=new FileInputStream(potentialInput);final GZIPInputStream gis=new GZIPInputStream(new FileInputStream(potentialInput));final BlockCompressedInputStream bcis=new BlockCompressedInputStream(new FileInputStream(potentialInput))){
    return isVCFStream(fis,MAGIC_HEADER_LINE) || isVCFStream(gis,MAGIC_HEADER_LINE) || isVCFStream(bcis,MAGIC_HEADER_LINE);
  }
 catch (  FileNotFoundException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
}","public static boolean canDecodeFile(final String potentialInput,final String MAGIC_HEADER_LINE){
  try {
    return isVCFStream(new FileInputStream(potentialInput),MAGIC_HEADER_LINE) || isVCFStream(new GZIPInputStream(new FileInputStream(potentialInput)),MAGIC_HEADER_LINE) || isVCFStream(new BlockCompressedInputStream(new FileInputStream(potentialInput)),MAGIC_HEADER_LINE);
  }
 catch (  FileNotFoundException e) {
    return false;
  }
catch (  IOException e) {
    return false;
  }
}",0.4889705882352941
30483,"private final static boolean isVCFStream(final InputStream stream,final String MAGIC_HEADER_LINE){
  try {
    byte[] buff=new byte[MAGIC_HEADER_LINE.length()];
    int nread=stream.read(buff,0,MAGIC_HEADER_LINE.length());
    boolean eq=Arrays.equals(buff,MAGIC_HEADER_LINE.getBytes());
    return eq;
  }
 catch (  IOException e) {
    return false;
  }
catch (  RuntimeException e) {
    return false;
  }
 finally {
    try {
      stream.close();
    }
 catch (    IOException e) {
    }
  }
}","private static boolean isVCFStream(final InputStream stream,final String MAGIC_HEADER_LINE){
  try {
    byte[] buff=new byte[MAGIC_HEADER_LINE.length()];
    int nread=stream.read(buff,0,MAGIC_HEADER_LINE.length());
    boolean eq=Arrays.equals(buff,MAGIC_HEADER_LINE.getBytes());
    return eq;
  }
 catch (  IOException e) {
    return false;
  }
catch (  RuntimeException e) {
    return false;
  }
 finally {
    try {
      stream.close();
    }
 catch (    IOException e) {
    }
  }
}",0.993939393939394
30484,"/** 
 * Establishes the SAMFileHeader for this record and forces resolution of the record's reference and mate reference names against the header using the sequence dictionary in the new header. If either the reference or mate reference name does not appear in the new header's sequence dictionary, an IllegalArgumentException is thrown.
 * @param header new header for this record. Can not be null.
 * @throws IllegalArgumentException if the record has reference or mate reference names that cannot be resolvedto indices using the new header.
 */
public void setHeaderStrict(final SAMFileHeader header){
  if (null == header) {
    mReferenceIndex=null;
    mMateReferenceIndex=null;
  }
 else {
    Integer referenceIndex=resolveIndexFromName(mReferenceName,header,true);
    Integer mateReferenceIndex=resolveIndexFromName(mMateReferenceName,header,true);
    mReferenceIndex=referenceIndex;
    mMateReferenceIndex=mateReferenceIndex;
    this.mHeader=header;
  }
}","/** 
 * Establishes the SAMFileHeader for this record and forces resolution of the record's reference and mate reference names against the header using the sequence dictionary in the new header. If either the reference or mate reference name does not appear in the new header's sequence dictionary, an IllegalArgumentException is thrown.
 * @param header new header for this record. May be null.
 * @throws IllegalArgumentException if the record has reference or mate reference names that cannot be resolvedto indices using the new header.
 */
public void setHeaderStrict(final SAMFileHeader header){
  if (null == header) {
    mReferenceIndex=null;
    mMateReferenceIndex=null;
  }
 else {
    Integer referenceIndex=resolveIndexFromName(mReferenceName,header,true);
    Integer mateReferenceIndex=resolveIndexFromName(mMateReferenceName,header,true);
    mReferenceIndex=referenceIndex;
    mMateReferenceIndex=mateReferenceIndex;
  }
  this.mHeader=header;
}",0.9917184265010353
30485,"@Test public void testSetHeaderStrictNull(){
  SAMRecord sam=createTestRecordHelper();
  sam.setHeaderStrict(null);
  Assert.assertEquals(sam.mReferenceIndex,null);
}","@Test public void testSetHeaderStrictNull(){
  SAMRecord sam=createTestRecordHelper();
  Assert.assertNotNull(sam.getHeader());
  sam.setHeaderStrict(null);
  Assert.assertNull(sam.getHeader());
  Assert.assertNull(sam.mReferenceIndex);
}",0.7673267326732673
30486,"/** 
 * Gets the subsequence of the contig in the range [start,stop]
 * @param contig Contig whose subsequence to retrieve.
 * @param start inclusive, 1-based start of region.
 * @param stop inclusive, 1-based stop of region.
 * @return The partial reference sequence associated with this range.
 */
public ReferenceSequence getSubsequenceAt(String contig,long start,long stop){
  if (start > stop + 1)   throw new SAMException(String.format(""String_Node_Str"",start,stop));
  FastaSequenceIndexEntry indexEntry=index.getIndexEntry(contig);
  if (stop > indexEntry.getSize())   throw new SAMException(""String_Node_Str"");
  int length=(int)(stop - start + 1);
  byte[] target=new byte[length];
  ByteBuffer targetBuffer=ByteBuffer.wrap(target);
  final int basesPerLine=indexEntry.getBasesPerLine();
  final int bytesPerLine=indexEntry.getBytesPerLine();
  final int terminatorLength=bytesPerLine - basesPerLine;
  long startOffset=((start - 1) / basesPerLine) * bytesPerLine + (start - 1) % basesPerLine;
  final long minBufferSize=Math.min((long)Defaults.NON_ZERO_BUFFER_SIZE,(long)(length % basesPerLine + 2) * (long)bytesPerLine);
  if (minBufferSize > Integer.MAX_VALUE)   throw new SAMException(""String_Node_Str"" + minBufferSize);
  final ByteBuffer channelBuffer=ByteBuffer.allocate((int)minBufferSize);
  while (targetBuffer.position() < length) {
    startOffset+=Math.max((int)(startOffset % bytesPerLine - basesPerLine + 1),0);
    try {
      startOffset+=readFromPosition(channel,channelBuffer,indexEntry.getLocation() + startOffset);
    }
 catch (    IOException ex) {
      throw new SAMException(""String_Node_Str"" + contig + ""String_Node_Str""+ start+ ""String_Node_Str""+ stop+ ""String_Node_Str""+ getAbsolutePath(),ex);
    }
    channelBuffer.flip();
    final int positionInContig=(int)start - 1 + targetBuffer.position();
    final int nextBaseSpan=Math.min(basesPerLine - positionInContig % basesPerLine,length - targetBuffer.position());
    int bytesToTransfer=Math.min(nextBaseSpan,channelBuffer.capacity());
    channelBuffer.limit(channelBuffer.position() + bytesToTransfer);
    while (channelBuffer.hasRemaining()) {
      targetBuffer.put(channelBuffer);
      bytesToTransfer=Math.min(basesPerLine,length - targetBuffer.position());
      channelBuffer.limit(Math.min(channelBuffer.position() + bytesToTransfer + terminatorLength,channelBuffer.capacity()));
      channelBuffer.position(Math.min(channelBuffer.position() + terminatorLength,channelBuffer.capacity()));
    }
    channelBuffer.flip();
  }
  return new ReferenceSequence(contig,indexEntry.getSequenceIndex(),target);
}","/** 
 * Gets the subsequence of the contig in the range [start,stop]
 * @param contig Contig whose subsequence to retrieve.
 * @param start inclusive, 1-based start of region.
 * @param stop inclusive, 1-based stop of region.
 * @return The partial reference sequence associated with this range.
 */
public ReferenceSequence getSubsequenceAt(String contig,long start,long stop){
  if (start > stop + 1)   throw new SAMException(String.format(""String_Node_Str"",start,stop));
  FastaSequenceIndexEntry indexEntry=index.getIndexEntry(contig);
  if (stop > indexEntry.getSize())   throw new SAMException(""String_Node_Str"");
  int length=(int)(stop - start + 1);
  byte[] target=new byte[length];
  ByteBuffer targetBuffer=ByteBuffer.wrap(target);
  final int basesPerLine=indexEntry.getBasesPerLine();
  final int bytesPerLine=indexEntry.getBytesPerLine();
  final int terminatorLength=bytesPerLine - basesPerLine;
  long startOffset=((start - 1) / basesPerLine) * bytesPerLine + (start - 1) % basesPerLine;
  final long minBufferSize=Math.min((long)Defaults.NON_ZERO_BUFFER_SIZE,(long)(length / basesPerLine + 2) * (long)bytesPerLine);
  if (minBufferSize > Integer.MAX_VALUE)   throw new SAMException(""String_Node_Str"" + minBufferSize);
  final ByteBuffer channelBuffer=ByteBuffer.allocate((int)minBufferSize);
  while (targetBuffer.position() < length) {
    startOffset+=Math.max((int)(startOffset % bytesPerLine - basesPerLine + 1),0);
    try {
      startOffset+=readFromPosition(channel,channelBuffer,indexEntry.getLocation() + startOffset);
    }
 catch (    IOException ex) {
      throw new SAMException(""String_Node_Str"" + contig + ""String_Node_Str""+ start+ ""String_Node_Str""+ stop+ ""String_Node_Str""+ getAbsolutePath(),ex);
    }
    channelBuffer.flip();
    final int positionInContig=(int)start - 1 + targetBuffer.position();
    final int nextBaseSpan=Math.min(basesPerLine - positionInContig % basesPerLine,length - targetBuffer.position());
    int bytesToTransfer=Math.min(nextBaseSpan,channelBuffer.capacity());
    channelBuffer.limit(channelBuffer.position() + bytesToTransfer);
    while (channelBuffer.hasRemaining()) {
      targetBuffer.put(channelBuffer);
      bytesToTransfer=Math.min(basesPerLine,length - targetBuffer.position());
      channelBuffer.limit(Math.min(channelBuffer.position() + bytesToTransfer + terminatorLength,channelBuffer.capacity()));
      channelBuffer.position(Math.min(channelBuffer.position() + terminatorLength,channelBuffer.capacity()));
    }
    channelBuffer.flip();
  }
  return new ReferenceSequence(contig,indexEntry.getSequenceIndex(),target);
}",0.999616564417178
30487,"public CRAMFileWriter(final OutputStream outputStream,final OutputStream indexOS,final ReferenceSource source,final SAMFileHeader samFileHeader,final String fileName){
  this.outputStream=outputStream;
  this.source=source;
  this.samFileHeader=samFileHeader;
  this.fileName=fileName;
  setSortOrder(samFileHeader.getSortOrder(),true);
  setHeader(samFileHeader);
  if (this.source == null)   this.source=new ReferenceSource(Defaults.REFERENCE_FASTA);
  containerFactory=new ContainerFactory(samFileHeader,recordsPerSlice);
  if (indexOS != null)   indexer=new CRAMIndexer(indexOS,samFileHeader);
}","/** 
 * Create a CRAMFileWriter and index on output streams.
 * @param outputStream where to write the output.
 * @param indexOS where to write the output index. Can be null if no index is required.
 * @param presorted if true records written to this writer must already be sorted in the order specified by the header
 * @param source reference source
 * @param samFileHeader {@link SAMFileHeader} to be used. Sort order is determined by the sortOrder property of this arg.
 * @param fileName used for display in error message display
 */
public CRAMFileWriter(final OutputStream outputStream,final OutputStream indexOS,final boolean presorted,final ReferenceSource source,final SAMFileHeader samFileHeader,final String fileName){
  this.outputStream=outputStream;
  this.samFileHeader=samFileHeader;
  this.fileName=fileName;
  initCRAMWriter(indexOS,source,samFileHeader,presorted);
}",0.1104377104377104
30488,"@Override protected void finish(){
  try {
    if (!samRecords.isEmpty())     flushContainer();
    CramIO.issueEOF(cramVersion,outputStream);
    outputStream.flush();
    if (indexer != null)     indexer.finish();
  }
 catch (  final RuntimeException re) {
    throw re;
  }
catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}","@Override protected void finish(){
  try {
    if (!samRecords.isEmpty()) {
      flushContainer();
    }
    CramIO.issueEOF(cramVersion,outputStream);
    outputStream.flush();
    if (indexer != null) {
      indexer.finish();
    }
    outputStream.close();
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
catch (  final IllegalAccessException e) {
    throw new RuntimeException(e);
  }
}",0.6987012987012987
30489,"/** 
 * Write an alignment record.
 * @param alignment must not be null and must have a valid SAMFileHeader.
 */
@Override protected void writeAlignment(final SAMRecord alignment){
  if (shouldFlushContainer(alignment))   try {
    flushContainer();
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
  updateReferenceContext(alignment.getReferenceIndex());
  samRecords.add(alignment);
}","/** 
 * Write an alignment record.
 * @param alignment must not be null and must have a valid SAMFileHeader.
 */
@Override protected void writeAlignment(final SAMRecord alignment){
  if (shouldFlushContainer(alignment)) {
    try {
      flushContainer();
    }
 catch (    IOException e) {
      throw new RuntimeIOException(e);
    }
catch (    IllegalAccessException e) {
      throw new RuntimeException(e);
    }
  }
  updateReferenceContext(alignment.getReferenceIndex());
  samRecords.add(alignment);
}",0.8630434782608696
30490,"/** 
 * Convenience method allowing newSAMFileWriterFactory().setCreateIndex(true); Equivalent to SAMFileWriterFactory.setDefaultCreateIndexWhileWriting(true); newSAMFileWriterFactory(); If a BAM (not SAM) file is created, the setting is true, and the file header specifies coordinate order, then a BAM index file will be written along with the BAM file.
 * @param setting whether to attempt to create a BAM index while creating the BAM file.
 * @return this factory object
 */
public SAMFileWriterFactory setCreateIndex(final boolean setting){
  this.createIndex=setting;
  return this;
}","/** 
 * Convenience method allowing newSAMFileWriterFactory().setCreateIndex(true); Equivalent to SAMFileWriterFactory.setDefaultCreateIndexWhileWriting(true); newSAMFileWriterFactory(); If a BAM or CRAM (not SAM) file is created, the setting is true, and the file header specifies coordinate order, then a BAM index file will be written along with the BAM file.
 * @param setting whether to attempt to create a BAM index while creating the BAM file.
 * @return this factory object
 */
public SAMFileWriterFactory setCreateIndex(final boolean setting){
  this.createIndex=setting;
  return this;
}",0.9932546374367622
30491,"public CRAMFileWriter makeCRAMWriter(final SAMFileHeader header,final File outputFile,final File referenceFasta){
  final boolean createIndex=this.createIndex && IOUtil.isRegularPath(outputFile);
  if (this.createIndex && !createIndex) {
    System.err.println(""String_Node_Str"" + outputFile.getAbsolutePath());
  }
  try {
    OutputStream indexOS=null;
    if (createIndex) {
      File indexFile=new File(outputFile.getAbsolutePath() + ""String_Node_Str"");
      indexOS=new FileOutputStream(indexFile);
    }
    final CRAMFileWriter writer=new CRAMFileWriter(new FileOutputStream(outputFile),indexOS,new ReferenceSource(referenceFasta),header,null);
    writer.setPreserveReadNames(true);
    writer.setCaptureAllTags(true);
    return writer;
  }
 catch (  final IOException ioe) {
    throw new RuntimeIOException(""String_Node_Str"" + outputFile.getAbsolutePath());
  }
}","/** 
 * Create a CRAMFileWriter on an output file. Note: does not honor factory setting for USE_ASYNC_IO.
 * @param header entire header. Sort order is determined by the sortOrder property of this arg.
 * @param presorted  if true, SAMRecords must be added to the SAMFileWriter in order that agrees with header.sortOrder.
 * @param outputFile where to write the output.  Must end with .sam, .bam or .cram.
 * @param referenceFasta reference sequence file
 * @return CRAMFileWriter
 */
public CRAMFileWriter makeCRAMWriter(final SAMFileHeader header,final boolean presorted,final File outputFile,final File referenceFasta){
  return createCRAMWriterWithSettings(header,presorted,outputFile,referenceFasta);
}",0.1427668982943777
30492,"public SAMFileWriter makeWriter(final SAMFileHeader header,final boolean presorted,final File outputFile,final File referenceFasta){
  if (outputFile.getName().endsWith(SamReader.Type.CRAM_TYPE.fileExtension()))   try {
    return makeCRAMWriter(header,new FileOutputStream(outputFile),referenceFasta);
  }
 catch (  final FileNotFoundException e) {
    throw new RuntimeIOException(e);
  }
  return makeSAMOrBAMWriter(header,presorted,outputFile);
}","/** 
 * Create a SAM, BAM or CRAM writer based on examination of the outputFile extension.
 * @param header header. Sort order is determined by the sortOrder property of this arg.
 * @param presorted if true, SAMRecords must be added to the SAMFileWriter in order that agrees with header.sortOrder.
 * @param outputFile where to write the output.  Must end with .sam, .bam or .cram.
 * @param referenceFasta reference sequence file
 * @return SAMFileWriter appropriate for the file type specified in outputFile
 */
public SAMFileWriter makeWriter(final SAMFileHeader header,final boolean presorted,final File outputFile,final File referenceFasta){
  if (outputFile.getName().endsWith(SamReader.Type.CRAM_TYPE.fileExtension())) {
    return makeCRAMWriter(header,presorted,outputFile,referenceFasta);
  }
 else {
    return makeSAMOrBAMWriter(header,presorted,outputFile);
  }
}",0.4220045214770158
30493,"private void validateSortOrder(final SAMRecord record,final long recordNumber){
  final SAMRecord prev=orderChecker.getPreviousRecord();
  if (!orderChecker.isSorted(record)) {
    addError(new SAMValidationError(Type.RECORD_OUT_OF_ORDER,String.format(""String_Node_Str"",record.getHeader().getSortOrder().name(),prev.getReadName(),prev.getReferenceIndex(),prev.getAlignmentStart()),record.getReadName(),recordNumber));
  }
}","private boolean validateSortOrder(final SAMRecord record,final long recordNumber){
  final SAMRecord prev=orderChecker.getPreviousRecord();
  boolean isValidSortOrder=orderChecker.isSorted(record);
  if (!isValidSortOrder) {
    addError(new SAMValidationError(Type.RECORD_OUT_OF_ORDER,String.format(""String_Node_Str"",record.getHeader().getSortOrder().name(),prev.getReadName(),prev.getReferenceIndex(),prev.getAlignmentStart()),record.getReadName(),recordNumber));
  }
  return isValidSortOrder;
}",0.8990228013029316
30494,"/** 
 * SAM record and quality format validations are combined into a single method because validation must be completed in only a single pass of the SamRecords (because a SamReader's iterator() method may not return the same records on a subsequent call).
 */
private void validateSamRecordsAndQualityFormat(final Iterable<SAMRecord> samRecords,final SAMFileHeader header){
  final SAMRecordIterator iter=(SAMRecordIterator)samRecords.iterator();
  final ProgressLogger progress=new ProgressLogger(log,10000000,""String_Node_Str"");
  final QualityEncodingDetector qualityDetector=new QualityEncodingDetector();
  try {
    while (iter.hasNext()) {
      final SAMRecord record=iter.next();
      qualityDetector.add(record);
      final long recordNumber=progress.getCount() + 1;
      final Collection<SAMValidationError> errors=record.isValid();
      if (errors != null) {
        for (        final SAMValidationError error : errors) {
          error.setRecordNumber(recordNumber);
          addError(error);
        }
      }
      validateMateFields(record,recordNumber);
      validateSortOrder(record,recordNumber);
      validateReadGroup(record,header);
      final boolean cigarIsValid=validateCigar(record,recordNumber);
      if (cigarIsValid) {
        validateNmTag(record,recordNumber);
      }
      validateSecondaryBaseCalls(record,recordNumber);
      validateTags(record,recordNumber);
      if (sequenceDictionaryEmptyAndNoWarningEmitted && !record.getReadUnmappedFlag()) {
        addError(new SAMValidationError(Type.MISSING_SEQUENCE_DICTIONARY,""String_Node_Str"",null));
        sequenceDictionaryEmptyAndNoWarningEmitted=false;
      }
      progress.record(record);
    }
    try {
      if (progress.getCount() > 0) {
        final FastqQualityFormat format=qualityDetector.generateBestGuess(QualityEncodingDetector.FileContext.SAM,FastqQualityFormat.Standard);
        if (format != FastqQualityFormat.Standard) {
          addError(new SAMValidationError(Type.INVALID_QUALITY_FORMAT,String.format(""String_Node_Str"",format,FastqQualityFormat.Standard),null));
        }
      }
    }
 catch (    SAMException e) {
      addError(new SAMValidationError(Type.INVALID_QUALITY_FORMAT,e.getMessage(),null));
    }
  }
 catch (  SAMFormatException e) {
    final String msg=""String_Node_Str"" + progress.getCount() + 1;
    out.println(msg);
    throw new SAMException(msg,e);
  }
catch (  FileTruncatedException e) {
    addError(new SAMValidationError(Type.TRUNCATED_FILE,""String_Node_Str"",null));
  }
 finally {
    iter.close();
  }
}","/** 
 * SAM record and quality format validations are combined into a single method because validation must be completed in only a single pass of the SamRecords (because a SamReader's iterator() method may not return the same records on a subsequent call).
 */
private void validateSamRecordsAndQualityFormat(final Iterable<SAMRecord> samRecords,final SAMFileHeader header){
  final SAMRecordIterator iter=(SAMRecordIterator)samRecords.iterator();
  final ProgressLogger progress=new ProgressLogger(log,10000000,""String_Node_Str"");
  final QualityEncodingDetector qualityDetector=new QualityEncodingDetector();
  try {
    while (iter.hasNext()) {
      final SAMRecord record=iter.next();
      qualityDetector.add(record);
      final long recordNumber=progress.getCount() + 1;
      final Collection<SAMValidationError> errors=record.isValid();
      if (errors != null) {
        for (        final SAMValidationError error : errors) {
          error.setRecordNumber(recordNumber);
          addError(error);
        }
      }
      validateMateFields(record,recordNumber);
      final boolean hasValidSortOrder=validateSortOrder(record,recordNumber);
      validateReadGroup(record,header);
      final boolean cigarIsValid=validateCigar(record,recordNumber);
      if (cigarIsValid) {
        try {
          validateNmTag(record,recordNumber);
        }
 catch (        SAMException e) {
          if (hasValidSortOrder) {
            throw e;
          }
        }
      }
      validateSecondaryBaseCalls(record,recordNumber);
      validateTags(record,recordNumber);
      if (sequenceDictionaryEmptyAndNoWarningEmitted && !record.getReadUnmappedFlag()) {
        addError(new SAMValidationError(Type.MISSING_SEQUENCE_DICTIONARY,""String_Node_Str"",null));
        sequenceDictionaryEmptyAndNoWarningEmitted=false;
      }
      progress.record(record);
    }
    try {
      if (progress.getCount() > 0) {
        final FastqQualityFormat format=qualityDetector.generateBestGuess(QualityEncodingDetector.FileContext.SAM,FastqQualityFormat.Standard);
        if (format != FastqQualityFormat.Standard) {
          addError(new SAMValidationError(Type.INVALID_QUALITY_FORMAT,String.format(""String_Node_Str"",format,FastqQualityFormat.Standard),null));
        }
      }
    }
 catch (    SAMException e) {
      addError(new SAMValidationError(Type.INVALID_QUALITY_FORMAT,e.getMessage(),null));
    }
  }
 catch (  SAMFormatException e) {
    final String msg=""String_Node_Str"" + progress.getCount() + 1;
    out.println(msg);
    throw new SAMException(msg,e);
  }
catch (  FileTruncatedException e) {
    addError(new SAMValidationError(Type.TRUNCATED_FILE,""String_Node_Str"",null));
  }
 finally {
    iter.close();
  }
}",0.9678638941398866
30495,"/** 
 * Run all validations of the mate's CIGAR.  These include validation that the CIGAR makes sense independent of placement, plus validation that CIGAR + placement yields all bases with M operator within the range of the reference.
 * @param rec the SAM record
 * @param recordNumber For error reporting.  -1 if not known.
 * @return List of errors, or null if no errors.
 */
public static List<SAMValidationError> validateMateCigar(final SAMRecord rec,final long recordNumber){
  List<SAMValidationError> ret=null;
  if (rec.getValidationStringency() != ValidationStringency.SILENT) {
    if (rec.getReadPairedFlag() && !rec.getMateUnmappedFlag()) {
      if (getMateCigarString(rec) != null) {
        ret=SAMUtils.validateCigar(rec,getMateCigar(rec),rec.getMateReferenceIndex(),getMateAlignmentBlocks(rec),recordNumber,""String_Node_Str"");
      }
    }
 else {
      if (getMateCigarString(rec) != null) {
        ret=new ArrayList<SAMValidationError>();
        if (rec.getMateUnmappedFlag()) {
          ret.add(new SAMValidationError(SAMValidationError.Type.MATE_CIGAR_STRING_INVALID_PRESENCE,""String_Node_Str"",rec.getReadName(),recordNumber));
        }
 else {
          ret.add(new SAMValidationError(SAMValidationError.Type.MATE_CIGAR_STRING_INVALID_PRESENCE,""String_Node_Str"",rec.getReadName(),recordNumber));
        }
      }
    }
  }
  return ret;
}","/** 
 * Run all validations of the mate's CIGAR.  These include validation that the CIGAR makes sense independent of placement, plus validation that CIGAR + placement yields all bases with M operator within the range of the reference.
 * @param rec the SAM record
 * @param recordNumber For error reporting.  -1 if not known.
 * @return List of errors, or null if no errors.
 */
public static List<SAMValidationError> validateMateCigar(final SAMRecord rec,final long recordNumber){
  List<SAMValidationError> ret=null;
  if (rec.getValidationStringency() != ValidationStringency.SILENT) {
    if (rec.getReadPairedFlag() && !rec.getMateUnmappedFlag()) {
      if (getMateCigarString(rec) != null) {
        ret=SAMUtils.validateCigar(rec,getMateCigar(rec),rec.getMateReferenceIndex(),getMateAlignmentBlocks(rec),recordNumber,""String_Node_Str"");
      }
    }
 else {
      if (getMateCigarString(rec) != null) {
        ret=new ArrayList<SAMValidationError>();
        if (!rec.getReadPairedFlag()) {
          ret.add(new SAMValidationError(SAMValidationError.Type.MATE_CIGAR_STRING_INVALID_PRESENCE,""String_Node_Str"",rec.getReadName(),recordNumber));
        }
 else {
          ret.add(new SAMValidationError(SAMValidationError.Type.MATE_CIGAR_STRING_INVALID_PRESENCE,""String_Node_Str"",rec.getReadName(),recordNumber));
        }
      }
    }
  }
  return ret;
}",0.9879253567508232
30496,"/** 
 * Read value of specified non-array type.
 * @param tagType What type to read.
 * @param byteBuffer Little-ending byte buffer to read value from.
 * @return Value in in-memory Object form.
 */
private static Object readSingleValue(final byte tagType,final ByteBuffer byteBuffer,final ValidationStringency validationStringency){
switch (tagType) {
case 'Z':
    return readNullTerminatedString(byteBuffer);
case 'A':
  return (char)byteBuffer.get();
case 'I':
final long val=byteBuffer.getInt() & 0xffffffffL;
if (val <= Integer.MAX_VALUE) {
return (int)val;
}
SAMUtils.processValidationError(new SAMValidationError(SAMValidationError.Type.TAG_VALUE_TOO_LARGE,""String_Node_Str"" + val + ""String_Node_Str"",null),validationStringency);
return val;
case 'i':
return byteBuffer.getInt();
case 's':
return (int)byteBuffer.getShort();
case 'S':
return byteBuffer.getShort() & 0xffff;
case 'c':
return (int)byteBuffer.get();
case 'C':
return (int)byteBuffer.get() & 0xff;
case 'f':
return byteBuffer.getFloat();
case 'H':
final String hexRep=readNullTerminatedString(byteBuffer);
return StringUtil.hexStringToBytes(hexRep);
default :
throw new SAMFormatException(""String_Node_Str"" + (char)tagType);
}
}","/** 
 * Read value of specified non-array type.
 * @param tagType What type to read.
 * @param byteBuffer Little-ending byte buffer to read value from.
 * @return Value in in-memory Object form.
 */
private static Object readSingleValue(final byte tagType,final ByteBuffer byteBuffer,final ValidationStringency validationStringency){
switch (tagType) {
case 'Z':
    return readNullTerminatedString(byteBuffer);
case 'A':
  return (char)byteBuffer.get();
case 'I':
final long val=byteBuffer.getInt() & 0xffffffffL;
if (val <= Integer.MAX_VALUE) {
return (int)val;
}
if (!SAMUtils.isValidUnsignedIntegerAttribute(val)) {
SAMUtils.processValidationError(new SAMValidationError(SAMValidationError.Type.TAG_VALUE_TOO_LARGE,""String_Node_Str"" + val,null),validationStringency);
}
return val;
case 'i':
return byteBuffer.getInt();
case 's':
return (int)byteBuffer.getShort();
case 'S':
return byteBuffer.getShort() & 0xffff;
case 'c':
return (int)byteBuffer.get();
case 'C':
return (int)byteBuffer.get() & 0xff;
case 'f':
return byteBuffer.getFloat();
case 'H':
final String hexRep=readNullTerminatedString(byteBuffer);
return StringUtil.hexStringToBytes(hexRep);
default :
throw new SAMFormatException(""String_Node_Str"" + (char)tagType);
}
}",0.9687756778964668
30497,"@Override protected void finish(){
  try {
    if (!samRecords.isEmpty())     flushContainer();
    CramIO.issueEOF(cramVersion,outputStream);
    outputStream.flush();
    if (indexer != null)     indexer.finish();
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}","@Override protected void finish(){
  try {
    if (!samRecords.isEmpty())     flushContainer();
    CramIO.issueEOF(cramVersion,outputStream);
    outputStream.flush();
    if (indexer != null)     indexer.finish();
  }
 catch (  final RuntimeException re) {
    throw re;
  }
catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}",0.8746081504702194
30498,"@Override public boolean hasNext(){
  if (container != null && container.isEOF())   return false;
  if (!iterator.hasNext()) {
    try {
      nextContainer();
    }
 catch (    final Exception e) {
      throw new RuntimeEOFException(e);
    }
  }
  return !records.isEmpty();
}","@Override public boolean hasNext(){
  if (container != null && container.isEOF())   return false;
  if (!iterator.hasNext()) {
    try {
      nextContainer();
    }
 catch (    CRAMException ce) {
      throw ce;
    }
catch (    SAMFormatException se) {
      throw se;
    }
catch (    final Exception e) {
      throw new RuntimeEOFException(e);
    }
  }
  return !records.isEmpty();
}",0.8340807174887892
30499,"private void nextContainer() throws IOException, IllegalArgumentException, IllegalAccessException, CRAMException {
  if (containerIterator != null) {
    if (!containerIterator.hasNext()) {
      records.clear();
      nextRecord=null;
      return;
    }
    container=containerIterator.next();
    if (container.isEOF()) {
      records.clear();
      nextRecord=null;
      return;
    }
  }
 else {
    container=ContainerIO.readContainer(cramHeader.getVersion(),countingInputStream);
    if (container.isEOF()) {
      records.clear();
      nextRecord=null;
      return;
    }
  }
  if (records == null)   records=new ArrayList<SAMRecord>(container.nofRecords);
 else   records.clear();
  if (cramRecords == null)   cramRecords=new ArrayList<CramCompressionRecord>(container.nofRecords);
 else   cramRecords.clear();
  parser.getRecords(container,cramRecords);
  if (container.sequenceId == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX) {
    refs=new byte[]{};
  }
 else   if (container.sequenceId == -2) {
    refs=null;
    prevSeqId=-2;
  }
 else   if (prevSeqId < 0 || prevSeqId != container.sequenceId) {
    final SAMSequenceRecord sequence=cramHeader.getSamFileHeader().getSequence(container.sequenceId);
    refs=referenceSource.getReferenceBases(sequence,true);
    if (refs == null) {
      throw new CRAMException(String.format(""String_Node_Str"",sequence.getSequenceName()));
    }
    prevSeqId=container.sequenceId;
  }
  for (int i=0; i < container.slices.length; i++) {
    final Slice slice=container.slices[i];
    if (slice.sequenceId < 0)     continue;
    if (validationStringency != ValidationStringency.SILENT && !slice.validateRefMD5(refs)) {
      log.error(String.format(""String_Node_Str"",slice.sequenceId,slice.alignmentStart,slice.alignmentSpan,String.format(""String_Node_Str"",new BigInteger(1,slice.refMD5))));
    }
  }
  normalizer.normalize(cramRecords,refs,0,container.header.substitutionMatrix);
  final Cram2SamRecordFactory cramToSamRecordFactory=new Cram2SamRecordFactory(cramHeader.getSamFileHeader());
  for (  final CramCompressionRecord cramRecord : cramRecords) {
    final SAMRecord samRecord=cramToSamRecordFactory.create(cramRecord);
    if (!cramRecord.isSegmentUnmapped()) {
      final SAMSequenceRecord sequence=cramHeader.getSamFileHeader().getSequence(cramRecord.sequenceId);
      refs=referenceSource.getReferenceBases(sequence,true);
      if (samRecord.getReadBases() != SAMRecord.NULL_SEQUENCE)       SequenceUtil.calculateMdAndNmTags(samRecord,refs,restoreMDTag,restoreNMTag);
    }
    samRecord.setValidationStringency(validationStringency);
    if (validationStringency != ValidationStringency.SILENT) {
      final List<SAMValidationError> validationErrors=samRecord.isValid();
      SAMUtils.processValidationErrors(validationErrors,samRecordIndex,validationStringency);
    }
    if (mReader != null) {
      final long chunkStart=(container.offset << 16) | cramRecord.sliceIndex;
      final long chunkEnd=((container.offset << 16) | cramRecord.sliceIndex) + 1;
      nextRecord.setFileSource(new SAMFileSource(mReader,new BAMFileSpan(new Chunk(chunkStart,chunkEnd))));
    }
    records.add(samRecord);
    samRecordIndex++;
  }
  cramRecords.clear();
  iterator=records.iterator();
}","private void nextContainer() throws IOException, IllegalArgumentException, IllegalAccessException, CRAMException {
  if (containerIterator != null) {
    if (!containerIterator.hasNext()) {
      records.clear();
      nextRecord=null;
      return;
    }
    container=containerIterator.next();
    if (container.isEOF()) {
      records.clear();
      nextRecord=null;
      return;
    }
  }
 else {
    container=ContainerIO.readContainer(cramHeader.getVersion(),countingInputStream);
    if (container.isEOF()) {
      records.clear();
      nextRecord=null;
      return;
    }
  }
  if (records == null)   records=new ArrayList<SAMRecord>(container.nofRecords);
 else   records.clear();
  if (cramRecords == null)   cramRecords=new ArrayList<CramCompressionRecord>(container.nofRecords);
 else   cramRecords.clear();
  parser.getRecords(container,cramRecords,validationStringency);
  if (container.sequenceId == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX) {
    refs=new byte[]{};
  }
 else   if (container.sequenceId == -2) {
    refs=null;
    prevSeqId=-2;
  }
 else   if (prevSeqId < 0 || prevSeqId != container.sequenceId) {
    final SAMSequenceRecord sequence=cramHeader.getSamFileHeader().getSequence(container.sequenceId);
    refs=referenceSource.getReferenceBases(sequence,true);
    if (refs == null) {
      throw new CRAMException(String.format(""String_Node_Str"",sequence.getSequenceName()));
    }
    prevSeqId=container.sequenceId;
  }
  for (int i=0; i < container.slices.length; i++) {
    final Slice slice=container.slices[i];
    if (slice.sequenceId < 0)     continue;
    if (validationStringency != ValidationStringency.SILENT && !slice.validateRefMD5(refs)) {
      log.error(String.format(""String_Node_Str"",slice.sequenceId,slice.alignmentStart,slice.alignmentSpan,String.format(""String_Node_Str"",new BigInteger(1,slice.refMD5))));
    }
  }
  normalizer.normalize(cramRecords,refs,0,container.header.substitutionMatrix);
  final Cram2SamRecordFactory cramToSamRecordFactory=new Cram2SamRecordFactory(cramHeader.getSamFileHeader());
  for (  final CramCompressionRecord cramRecord : cramRecords) {
    final SAMRecord samRecord=cramToSamRecordFactory.create(cramRecord);
    if (!cramRecord.isSegmentUnmapped()) {
      final SAMSequenceRecord sequence=cramHeader.getSamFileHeader().getSequence(cramRecord.sequenceId);
      refs=referenceSource.getReferenceBases(sequence,true);
      if (samRecord.getReadBases() != SAMRecord.NULL_SEQUENCE)       SequenceUtil.calculateMdAndNmTags(samRecord,refs,restoreMDTag,restoreNMTag);
    }
    samRecord.setValidationStringency(validationStringency);
    if (validationStringency != ValidationStringency.SILENT) {
      final List<SAMValidationError> validationErrors=samRecord.isValid();
      SAMUtils.processValidationErrors(validationErrors,samRecordIndex,validationStringency);
    }
    if (mReader != null) {
      final long chunkStart=(container.offset << 16) | cramRecord.sliceIndex;
      final long chunkEnd=((container.offset << 16) | cramRecord.sliceIndex) + 1;
      nextRecord.setFileSource(new SAMFileSource(mReader,new BAMFileSpan(new Chunk(chunkStart,chunkEnd))));
    }
    records.add(samRecord);
    samRecordIndex++;
  }
  cramRecords.clear();
  iterator=records.iterator();
}",0.9967796350253028
30500,"/** 
 * Get the tag value and attempt to coerce it into the requested type.
 * @param tag The requested tag.
 * @return The value of a tag, converted into an Integer if possible.
 * @throws RuntimeException If the value is not an integer type, or will not fit in an Integer.
 */
public Integer getIntegerAttribute(final String tag){
  final Object val=getAttribute(tag);
  if (val == null)   return null;
  if (val instanceof Integer) {
    return (Integer)val;
  }
  if (!(val instanceof Number)) {
    throw new RuntimeException(""String_Node_Str"" + tag + ""String_Node_Str""+ val.getClass());
  }
  final long longVal=((Number)val).longValue();
  if (longVal < Integer.MIN_VALUE || longVal > Integer.MAX_VALUE) {
    throw new RuntimeException(""String_Node_Str"" + tag + ""String_Node_Str""+ longVal);
  }
  return (int)longVal;
}","/** 
 * Get the tag value and attempt to coerce it into the requested type.
 * @param tag The requested tag.
 * @return The value of a tag, converted into a signed Integer if possible.
 * @throws RuntimeException If the value is not an integer type, or will not fit in a signed Integer.
 */
public Integer getIntegerAttribute(final String tag){
  final Object val=getAttribute(tag);
  if (val == null)   return null;
  if (val instanceof Integer) {
    return (Integer)val;
  }
  if (!(val instanceof Number)) {
    throw new RuntimeException(""String_Node_Str"" + tag + ""String_Node_Str""+ val.getClass());
  }
  final long longVal=((Number)val).longValue();
  if (longVal < Integer.MIN_VALUE || longVal > Integer.MAX_VALUE) {
    throw new RuntimeException(""String_Node_Str"" + tag + ""String_Node_Str""+ longVal);
  }
  return (int)longVal;
}",0.9903961584633854
30501,"protected void setAttribute(final short tag,final Object value,final boolean isUnsignedArray){
  if (value != null && !(value instanceof Byte || value instanceof Short || value instanceof Integer|| value instanceof String|| value instanceof Character|| value instanceof Float|| value instanceof byte[]|| value instanceof short[]|| value instanceof int[]|| value instanceof float[])) {
    throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
  }
  if (value == null) {
    if (this.mAttributes != null)     this.mAttributes=this.mAttributes.remove(tag);
  }
 else {
    final SAMBinaryTagAndValue tmp;
    if (!isUnsignedArray) {
      tmp=new SAMBinaryTagAndValue(tag,value);
    }
 else {
      if (!value.getClass().isArray() || value instanceof float[]) {
        throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
      }
      tmp=new SAMBinaryTagAndUnsignedArrayValue(tag,value);
    }
    if (this.mAttributes == null)     this.mAttributes=tmp;
 else     this.mAttributes=this.mAttributes.insert(tmp);
  }
}","protected void setAttribute(final short tag,final Object value,final boolean isUnsignedArray){
  if (value == null) {
    if (this.mAttributes != null) {
      this.mAttributes=this.mAttributes.remove(tag);
    }
    return;
  }
  if (isAllowedAttributeValue(value)) {
    final SAMBinaryTagAndValue tmp;
    if (!isUnsignedArray) {
      tmp=new SAMBinaryTagAndValue(tag,value);
    }
 else {
      if (!value.getClass().isArray() || value instanceof float[]) {
        throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
      }
      tmp=new SAMBinaryTagAndUnsignedArrayValue(tag,value);
    }
    if (this.mAttributes == null) {
      this.mAttributes=tmp;
    }
 else {
      this.mAttributes=this.mAttributes.insert(tmp);
    }
  }
 else {
    throw new SAMException(""String_Node_Str"" + value.getClass() + ""String_Node_Str""+ SAMTagUtil.getSingleton().makeStringTag(tag));
  }
}",0.4609595484477893
30502,"/** 
 * Convert in-memory representation of tag to SAM text representation.
 * @param tagName Two-character tag name.
 * @param value Tag value as approriate Object subclass.
 * @return SAM text String representation, i.e. name:type:value
 */
public String encode(final String tagName,Object value){
  final StringBuilder sb=new StringBuilder(tagName);
  sb.append(':');
  char tagType=BinaryTagCodec.getTagValueType(value);
switch (tagType) {
case 'c':
case 'C':
case 's':
case 'S':
case 'I':
    tagType='i';
}
if (tagType == 'H') {
  value=StringUtil.bytesToHexString((byte[])value);
}
 else if (tagType == 'B') {
  value=getArrayType(value,false) + ""String_Node_Str"" + encodeArrayValue(value);
}
 else if (tagType == 'i') {
  final long longVal=((Number)value).longValue();
  if (longVal > Integer.MAX_VALUE || longVal < Integer.MIN_VALUE) {
    throw new SAMFormatException(""String_Node_Str"" + tagName + ""String_Node_Str""+ longVal);
  }
}
sb.append(tagType);
sb.append(':');
sb.append(value.toString());
return sb.toString();
}","/** 
 * Convert in-memory representation of tag to SAM text representation.
 * @param tagName Two-character tag name.
 * @param value Tag value as approriate Object subclass.
 * @return SAM text String representation, i.e. name:type:value
 */
public String encode(final String tagName,Object value){
  final StringBuilder sb=new StringBuilder(tagName);
  sb.append(':');
  char tagType=BinaryTagCodec.getTagValueType(value);
switch (tagType) {
case 'c':
case 'C':
case 's':
case 'S':
case 'I':
    tagType='i';
}
if (tagType == 'H') {
  value=StringUtil.bytesToHexString((byte[])value);
}
 else if (tagType == 'B') {
  value=getArrayType(value,false) + ""String_Node_Str"" + encodeArrayValue(value);
}
 else if (tagType == 'i') {
  final long longVal=((Number)value).longValue();
  if (longVal < Integer.MIN_VALUE || longVal > BinaryCodec.MAX_UINT) {
    throw new IllegalArgumentException(""String_Node_Str"" + tagName + ""String_Node_Str""+ longVal);
  }
}
sb.append(tagType);
sb.append(':');
sb.append(value.toString());
return sb.toString();
}",0.9589966232513266
30503,"private Object convertStringToObject(final String type,final String stringVal){
  if (type.equals(""String_Node_Str"")) {
    return stringVal;
  }
 else   if (type.equals(""String_Node_Str"")) {
    if (stringVal.length() != 1) {
      throw new SAMFormatException(""String_Node_Str"");
    }
    return stringVal.charAt(0);
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return new Integer(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return new Float(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return StringUtil.hexStringToBytes(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    return covertStringArrayToObject(stringVal);
  }
 else {
    throw new SAMFormatException(""String_Node_Str"" + type);
  }
}","private Object convertStringToObject(final String type,final String stringVal){
  if (type.equals(""String_Node_Str"")) {
    return stringVal;
  }
 else   if (type.equals(""String_Node_Str"")) {
    if (stringVal.length() != 1) {
      throw new SAMFormatException(""String_Node_Str"");
    }
    return stringVal.charAt(0);
  }
 else   if (type.equals(""String_Node_Str"")) {
    final long lValue;
    try {
      lValue=Long.valueOf(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
    if (lValue >= Integer.MIN_VALUE && lValue <= Integer.MAX_VALUE) {
      return (int)lValue;
    }
 else     if (SAMUtils.isValidUnsignedIntegerAttribute(lValue)) {
      return lValue;
    }
 else {
      throw new SAMFormatException(""String_Node_Str"" + stringVal);
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return new Float(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      return StringUtil.hexStringToBytes(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    return covertStringArrayToObject(stringVal);
  }
 else {
    throw new SAMFormatException(""String_Node_Str"" + type);
  }
}",0.7533490937746257
30504,"List<CramCompressionRecord> getRecords(final Slice slice,final CompressionHeader header) throws IllegalArgumentException, IllegalAccessException {
  return getRecords(null,slice,header);
}","List<CramCompressionRecord> getRecords(final Slice slice,final CompressionHeader header,ValidationStringency validationStringency) throws IllegalArgumentException, IllegalAccessException {
  return getRecords(null,slice,header,validationStringency);
}",0.856492027334852
30505,"@SuppressWarnings(""String_Node_Str"") public void read(final CramCompressionRecord cramRecord){
  try {
    cramRecord.flags=bitFlagsCodec.readData();
    cramRecord.compressionFlags=compressionBitFlagsCodec.readData();
    if (refId == -2)     cramRecord.sequenceId=refIdCodec.readData();
 else     cramRecord.sequenceId=refId;
    cramRecord.readLength=readLengthCodec.readData();
    if (APDelta)     cramRecord.alignmentDelta=alignmentStartCodec.readData();
 else     cramRecord.alignmentStart=alignmentStartCodec.readData();
    cramRecord.readGroupID=readGroupCodec.readData();
    if (captureReadNames)     cramRecord.readName=new String(readNameCodec.readData(),charset);
    if (cramRecord.isDetached()) {
      cramRecord.mateFlags=mateBitFlagCodec.readData();
      if (!captureReadNames)       cramRecord.readName=new String(readNameCodec.readData(),charset);
      cramRecord.mateSequenceID=mateReferenceIdCodec.readData();
      cramRecord.mateAlignmentStart=mateAlignmentStartCodec.readData();
      cramRecord.templateSize=insertSizeCodec.readData();
      detachedCount++;
    }
 else     if (cramRecord.isHasMateDownStream())     cramRecord.recordsToNextFragment=distanceToNextFragmentCodec.readData();
    final Integer tagIdList=tagIdListCodec.readData();
    final byte[][] ids=tagIdDictionary[tagIdList];
    if (ids.length > 0) {
      final int tagCount=ids.length;
      cramRecord.tags=new ReadTag[tagCount];
      for (int i=0; i < ids.length; i++) {
        final int id=ReadTag.name3BytesToInt(ids[i]);
        final DataReader<byte[]> dataReader=tagValueCodecs.get(id);
        final ReadTag tag=new ReadTag(id,dataReader.readData());
        cramRecord.tags[i]=tag;
      }
    }
    if (!cramRecord.isSegmentUnmapped()) {
      final int size=numberOfReadFeaturesCodec.readData();
      int prevPos=0;
      final java.util.List<ReadFeature> readFeatures=new LinkedList<ReadFeature>();
      cramRecord.readFeatures=readFeatures;
      for (int i=0; i < size; i++) {
        final Byte operator=readFeatureCodeCodec.readData();
        final int pos=prevPos + readFeaturePositionCodec.readData();
        prevPos=pos;
switch (operator) {
case ReadBase.operator:
          final ReadBase readBase=new ReadBase(pos,baseCodec.readData(),qualityScoreCodec.readData());
        readFeatures.add(readBase);
      break;
case Substitution.operator:
    final Substitution substitution=new Substitution();
  substitution.setPosition(pos);
final byte code=baseSubstitutionCodec.readData();
substitution.setCode(code);
readFeatures.add(substitution);
break;
case Insertion.operator:
final Insertion insertion=new Insertion(pos,insertionCodec.readData());
readFeatures.add(insertion);
break;
case SoftClip.operator:
final SoftClip softClip=new SoftClip(pos,softClipCodec.readData());
readFeatures.add(softClip);
break;
case HardClip.operator:
final HardClip hardCLip=new HardClip(pos,hardClipCodec.readData());
readFeatures.add(hardCLip);
break;
case Padding.operator:
final Padding padding=new Padding(pos,paddingCodec.readData());
readFeatures.add(padding);
break;
case Deletion.operator:
final Deletion deletion=new Deletion(pos,deletionLengthCodec.readData());
readFeatures.add(deletion);
break;
case RefSkip.operator:
final RefSkip refSkip=new RefSkip(pos,refSkipCodec.readData());
readFeatures.add(refSkip);
break;
case InsertBase.operator:
final InsertBase insertBase=new InsertBase(pos,baseCodec.readData());
readFeatures.add(insertBase);
break;
case BaseQualityScore.operator:
final BaseQualityScore baseQualityScore=new BaseQualityScore(pos,qualityScoreCodec.readData());
readFeatures.add(baseQualityScore);
break;
case Bases.operator:
final Bases bases=new Bases(pos,basesCodec.readData());
readFeatures.add(bases);
break;
case Scores.operator:
final Scores scores=new Scores(pos,scoresCodec.readData());
readFeatures.add(scores);
break;
default :
throw new RuntimeException(""String_Node_Str"" + operator);
}
}
cramRecord.mappingQuality=mappingScoreCodec.readData();
if (cramRecord.isForcePreserveQualityScores()) {
cramRecord.qualityScores=qualityScoresCodec.readDataArray(cramRecord.readLength);
}
}
 else {
if (cramRecord.isUnknownBases()) {
cramRecord.readBases=SAMRecord.NULL_SEQUENCE;
cramRecord.qualityScores=SAMRecord.NULL_QUALS;
}
 else {
final byte[] bases=new byte[cramRecord.readLength];
for (int i=0; i < bases.length; i++) bases[i]=baseCodec.readData();
cramRecord.readBases=bases;
if (cramRecord.isForcePreserveQualityScores()) {
cramRecord.qualityScores=qualityScoresCodec.readDataArray(cramRecord.readLength);
}
}
}
recordCounter++;
prevRecord=cramRecord;
}
 catch (final Exception e) {
if (prevRecord != null) System.err.printf(""String_Node_Str"",recordCounter,prevRecord.toString());
throw new RuntimeException(e);
}
}","@SuppressWarnings(""String_Node_Str"") public void read(final CramCompressionRecord cramRecord){
  try {
    cramRecord.flags=bitFlagsCodec.readData();
    cramRecord.compressionFlags=compressionBitFlagsCodec.readData();
    if (refId == -2)     cramRecord.sequenceId=refIdCodec.readData();
 else     cramRecord.sequenceId=refId;
    cramRecord.readLength=readLengthCodec.readData();
    if (APDelta)     cramRecord.alignmentDelta=alignmentStartCodec.readData();
 else     cramRecord.alignmentStart=alignmentStartCodec.readData();
    cramRecord.readGroupID=readGroupCodec.readData();
    if (captureReadNames)     cramRecord.readName=new String(readNameCodec.readData(),charset);
    if (cramRecord.isDetached()) {
      cramRecord.mateFlags=mateBitFlagCodec.readData();
      if (!captureReadNames)       cramRecord.readName=new String(readNameCodec.readData(),charset);
      cramRecord.mateSequenceID=mateReferenceIdCodec.readData();
      cramRecord.mateAlignmentStart=mateAlignmentStartCodec.readData();
      cramRecord.templateSize=insertSizeCodec.readData();
      detachedCount++;
    }
 else     if (cramRecord.isHasMateDownStream())     cramRecord.recordsToNextFragment=distanceToNextFragmentCodec.readData();
    final Integer tagIdList=tagIdListCodec.readData();
    final byte[][] ids=tagIdDictionary[tagIdList];
    if (ids.length > 0) {
      final int tagCount=ids.length;
      cramRecord.tags=new ReadTag[tagCount];
      for (int i=0; i < ids.length; i++) {
        final int id=ReadTag.name3BytesToInt(ids[i]);
        final DataReader<byte[]> dataReader=tagValueCodecs.get(id);
        final ReadTag tag=new ReadTag(id,dataReader.readData(),validationStringency);
        cramRecord.tags[i]=tag;
      }
    }
    if (!cramRecord.isSegmentUnmapped()) {
      final int size=numberOfReadFeaturesCodec.readData();
      int prevPos=0;
      final java.util.List<ReadFeature> readFeatures=new LinkedList<ReadFeature>();
      cramRecord.readFeatures=readFeatures;
      for (int i=0; i < size; i++) {
        final Byte operator=readFeatureCodeCodec.readData();
        final int pos=prevPos + readFeaturePositionCodec.readData();
        prevPos=pos;
switch (operator) {
case ReadBase.operator:
          final ReadBase readBase=new ReadBase(pos,baseCodec.readData(),qualityScoreCodec.readData());
        readFeatures.add(readBase);
      break;
case Substitution.operator:
    final Substitution substitution=new Substitution();
  substitution.setPosition(pos);
final byte code=baseSubstitutionCodec.readData();
substitution.setCode(code);
readFeatures.add(substitution);
break;
case Insertion.operator:
final Insertion insertion=new Insertion(pos,insertionCodec.readData());
readFeatures.add(insertion);
break;
case SoftClip.operator:
final SoftClip softClip=new SoftClip(pos,softClipCodec.readData());
readFeatures.add(softClip);
break;
case HardClip.operator:
final HardClip hardCLip=new HardClip(pos,hardClipCodec.readData());
readFeatures.add(hardCLip);
break;
case Padding.operator:
final Padding padding=new Padding(pos,paddingCodec.readData());
readFeatures.add(padding);
break;
case Deletion.operator:
final Deletion deletion=new Deletion(pos,deletionLengthCodec.readData());
readFeatures.add(deletion);
break;
case RefSkip.operator:
final RefSkip refSkip=new RefSkip(pos,refSkipCodec.readData());
readFeatures.add(refSkip);
break;
case InsertBase.operator:
final InsertBase insertBase=new InsertBase(pos,baseCodec.readData());
readFeatures.add(insertBase);
break;
case BaseQualityScore.operator:
final BaseQualityScore baseQualityScore=new BaseQualityScore(pos,qualityScoreCodec.readData());
readFeatures.add(baseQualityScore);
break;
case Bases.operator:
final Bases bases=new Bases(pos,basesCodec.readData());
readFeatures.add(bases);
break;
case Scores.operator:
final Scores scores=new Scores(pos,scoresCodec.readData());
readFeatures.add(scores);
break;
default :
throw new RuntimeException(""String_Node_Str"" + operator);
}
}
cramRecord.mappingQuality=mappingScoreCodec.readData();
if (cramRecord.isForcePreserveQualityScores()) {
cramRecord.qualityScores=qualityScoresCodec.readDataArray(cramRecord.readLength);
}
}
 else {
if (cramRecord.isUnknownBases()) {
cramRecord.readBases=SAMRecord.NULL_SEQUENCE;
cramRecord.qualityScores=SAMRecord.NULL_QUALS;
}
 else {
final byte[] bases=new byte[cramRecord.readLength];
for (int i=0; i < bases.length; i++) bases[i]=baseCodec.readData();
cramRecord.readBases=bases;
if (cramRecord.isForcePreserveQualityScores()) {
cramRecord.qualityScores=qualityScoresCodec.readDataArray(cramRecord.readLength);
}
}
}
recordCounter++;
prevRecord=cramRecord;
}
 catch (final SAMFormatException e) {
if (prevRecord != null) {
System.err.printf(""String_Node_Str"",recordCounter,prevRecord.toString());
}
throw e;
}
catch (final Exception e) {
if (prevRecord != null) {
System.err.printf(""String_Node_Str"",recordCounter,prevRecord.toString());
}
throw new RuntimeException(e);
}
}",0.9792932934995364
30506,"/** 
 * Add the record to the tail of the queue, spilling to disk if necessary Must check that (canAdd() == true) before calling this method
 * @param record The record to be added to the queue
 * @return true (if add successful)
 * @throws IllegalStateException if the queue cannot be added to
 */
public boolean add(final E record) throws IllegalStateException {
  if (!canAdd)   throw new IllegalStateException(""String_Node_Str"");
  if (this.headRecord == null) {
    this.headRecord=record;
  }
 else   if (this.ramRecords.size() == this.maxRecordsInRamQueue) {
    spillToDisk(record);
  }
 else {
    this.ramRecords.add(record);
  }
  return true;
}","/** 
 * Add the record to the tail of the queue, spilling to disk if necessary Must check that (canAdd() == true) before calling this method
 * @param record The record to be added to the queue
 * @return true (if add successful)
 * @throws IllegalStateException if the queue cannot be added to
 */
public boolean add(final E record) throws IllegalStateException {
  if (!canAdd)   throw new IllegalStateException(""String_Node_Str"");
  if (this.headRecord == null) {
    if (0 < this.numRecordsOnDisk)     throw new SAMException(""String_Node_Str"");
    this.headRecord=record;
  }
 else   if (this.ramRecords.size() == this.maxRecordsInRamQueue) {
    spillToDisk(record);
  }
 else {
    if (0 < this.numRecordsOnDisk)     throw new SAMException(""String_Node_Str"");
    this.ramRecords.add(record);
  }
  return true;
}",0.8292682926829268
30507,"/** 
 * Syntactic sugar around the ctor, to save some typing of type parameters
 * @param codec For writing records to file and reading them back into RAM
 * @param maxRecordsInRAM how many records to accumulate in memory before spilling to disk
 * @param tmpDir Where to write files of records that will not fit in RAM
 */
public static <T>DiskBackedQueue<T> newInstance(final SortingCollection.Codec<T> codec,final int maxRecordsInRAM,final List<File> tmpDir){
  return new DiskBackedQueue<T>(codec,maxRecordsInRAM,tmpDir);
}","/** 
 * Syntactic sugar around the ctor, to save some typing of type parameters
 * @param codec For writing records to file and reading them back into RAM
 * @param maxRecordsInRam how many records to accumulate in memory before spilling to disk
 * @param tmpDir Where to write files of records that will not fit in RAM
 */
public static <T>DiskBackedQueue<T> newInstance(final SortingCollection.Codec<T> codec,final int maxRecordsInRam,final List<File> tmpDir){
  return new DiskBackedQueue<T>(codec,maxRecordsInRam,tmpDir);
}",0.9886148007590132
30508,"/** 
 * Update the head of the queue with the next record in memory or on disk. Sets headRecord to null if the queue is now empty
 */
private void updateQueueHead(){
  if (!this.ramRecords.isEmpty()) {
    this.headRecord=this.ramRecords.poll();
  }
 else   if (this.diskRecords != null) {
    this.headRecord=this.readFileRecord(this.diskRecords);
  }
 else {
    this.headRecord=null;
  }
}","/** 
 * Update the head of the queue with the next record in memory or on disk. Sets headRecord to null if the queue is now empty
 */
private void updateQueueHead(){
  if (!this.ramRecords.isEmpty()) {
    this.headRecord=this.ramRecords.poll();
    if (0 < numRecordsOnDisk)     this.canAdd=false;
  }
 else   if (this.diskRecords != null) {
    this.headRecord=this.readFileRecord(this.diskRecords);
    this.canAdd=false;
  }
 else {
    this.canAdd=true;
    this.headRecord=null;
  }
}",0.8888888888888888
30509,"@Test public void testReadOnlyQueueJustBeforeReadingFromDisk(){
  DiskBackedQueue<String> queue=makeDiskBackedQueue(2);
  queue.add(""String_Node_Str"");
  queue.add(""String_Node_Str"");
  queue.add(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",queue.poll());
  Assert.assertEquals(""String_Node_Str"",queue.poll());
  Assert.assertFalse(queue.canAdd());
  Assert.assertEquals(""String_Node_Str"",queue.poll());
  Assert.assertEquals(queue.size(),0);
  Assert.assertTrue(queue.isEmpty());
  Assert.assertEquals(queue.poll(),null);
  queue.clear();
  Assert.assertTrue(queue.canAdd());
}","@Test public void testReadOnlyQueueJustBeforeReadingFromDisk(){
  final DiskBackedQueue<String> queue=makeDiskBackedQueue(2);
  queue.add(""String_Node_Str"");
  queue.add(""String_Node_Str"");
  queue.add(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",queue.poll());
  Assert.assertEquals(""String_Node_Str"",queue.poll());
  Assert.assertFalse(queue.canAdd());
  Assert.assertEquals(""String_Node_Str"",queue.poll());
  Assert.assertEquals(queue.size(),0);
  Assert.assertTrue(queue.isEmpty());
  Assert.assertEquals(queue.poll(),null);
  queue.clear();
  Assert.assertTrue(queue.canAdd());
}",0.9949664429530202
30510,"private DiskBackedQueue<String> makeDiskBackedQueue(final int maxRecordsInRam){
  return DiskBackedQueue.newInstance(new StringCodec(),maxRecordsInRam,Collections.singletonList(tmpDir));
}","private DiskBackedQueue<String> makeDiskBackedQueue(final int maxRecordsInRam){
  return DiskBackedQueue.newInstance(new StringCodec(),maxRecordsInRam,Collections.singletonList(tmpDir()));
}",0.9947089947089948
30511,"protected boolean tmpDirIsEmpty(){
  System.err.println(""String_Node_Str"" + tmpDir);
  return tmpDir.listFiles().length == 0;
}","protected boolean tmpDirIsEmpty(){
  return tmpDir().listFiles().length == 0;
}",0.7475728155339806
30512,"private SortingCollection<String> makeSortingCollection(final int maxRecordsInRam){
  return SortingCollection.newInstance(String.class,new StringCodec(),new StringComparator(),maxRecordsInRam,tmpDir);
}","private SortingCollection<String> makeSortingCollection(final int maxRecordsInRam){
  return SortingCollection.newInstance(String.class,new StringCodec(),new StringComparator(),maxRecordsInRam,tmpDir());
}",0.9950980392156864
30513,"/** 
 * Generate some strings, put into SortingCollection, confirm that the right number of Strings come out, and in the right order.
 * @param numStringsToGenerate
 * @param maxRecordsInRam
 */
@Test(dataProvider=""String_Node_Str"") public void testPositive(final String testName,final int numStringsToGenerate,final int maxRecordsInRam){
  final String[] strings=new String[numStringsToGenerate];
  int numStringsGenerated=0;
  final SortingCollection<String> sortingCollection=makeSortingCollection(maxRecordsInRam);
  for (  final String s : new RandomStringGenerator(numStringsToGenerate)) {
    sortingCollection.add(s);
    strings[numStringsGenerated++]=s;
  }
  Arrays.sort(strings,new StringComparator());
  Assert.assertEquals(tmpDirIsEmpty(),numStringsToGenerate <= maxRecordsInRam);
  sortingCollection.setDestructiveIteration(false);
  assertIteratorEqualsList(strings,sortingCollection.iterator());
  assertIteratorEqualsList(strings,sortingCollection.iterator());
  sortingCollection.cleanup();
  Assert.assertEquals(tmpDir.list().length,0);
}","/** 
 * Generate some strings, put into SortingCollection, confirm that the right number of Strings come out, and in the right order.
 * @param numStringsToGenerate
 * @param maxRecordsInRam
 */
@Test(dataProvider=""String_Node_Str"") public void testPositive(final String testName,final int numStringsToGenerate,final int maxRecordsInRam){
  final String[] strings=new String[numStringsToGenerate];
  int numStringsGenerated=0;
  final SortingCollection<String> sortingCollection=makeSortingCollection(maxRecordsInRam);
  for (  final String s : new RandomStringGenerator(numStringsToGenerate)) {
    sortingCollection.add(s);
    strings[numStringsGenerated++]=s;
  }
  Arrays.sort(strings,new StringComparator());
  Assert.assertEquals(tmpDirIsEmpty(),numStringsToGenerate <= maxRecordsInRam);
  sortingCollection.setDestructiveIteration(false);
  assertIteratorEqualsList(strings,sortingCollection.iterator());
  assertIteratorEqualsList(strings,sortingCollection.iterator());
  sortingCollection.cleanup();
  Assert.assertEquals(tmpDir().list().length,0);
}",0.9990557129367328
30514,"@AfterTest void tearDown(){
  System.err.println(""String_Node_Str"" + tmpDir);
  if (tmpDir.exists()) {
    for (    final File f : tmpDir.listFiles()) {
      f.delete();
    }
    tmpDir.delete();
  }
}","@AfterMethod void tearDown(){
  resetTmpDir();
}",0.3187250996015936
30515,"@BeforeTest void setup(){
  if (tmpDir.exists()) {
    for (    final File f : tmpDir.listFiles()) {
      f.delete();
    }
  }
  tmpDir.mkdirs();
}","@BeforeMethod void setup(){
  resetTmpDir();
}",0.3794871794871794
30516,"/** 
 * Complete the current container and flush it to the output stream.
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws IOException
 */
protected void flushContainer() throws IllegalArgumentException, IllegalAccessException, IOException {
  final byte[] refs;
  String refSeqName=null;
  if (refSeqIndex == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX)   refs=new byte[0];
 else {
    final SAMSequenceRecord sequence=samFileHeader.getSequence(refSeqIndex);
    refs=source.getReferenceBases(sequence,true);
    refSeqName=sequence.getSequenceName();
  }
  int start=SAMRecord.NO_ALIGNMENT_START;
  int stop=SAMRecord.NO_ALIGNMENT_START;
  for (  final SAMRecord r : samRecords) {
    if (r.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START)     continue;
    if (start == SAMRecord.NO_ALIGNMENT_START)     start=r.getAlignmentStart();
    start=Math.min(r.getAlignmentStart(),start);
    stop=Math.max(r.getAlignmentEnd(),stop);
  }
  ReferenceTracks tracks=null;
  if (preservation != null && preservation.areReferenceTracksRequired()) {
    tracks=new ReferenceTracks(refSeqIndex,refSeqName,refs);
    tracks.ensureRange(start,stop - start + 1);
    updateTracks(samRecords,tracks);
  }
  final List<CramCompressionRecord> cramRecords=new ArrayList<CramCompressionRecord>(samRecords.size());
  final Sam2CramRecordFactory sam2CramRecordFactory=new Sam2CramRecordFactory(refs,samFileHeader,cramVersion);
  sam2CramRecordFactory.preserveReadNames=preserveReadNames;
  sam2CramRecordFactory.captureAllTags=captureAllTags;
  sam2CramRecordFactory.captureTags.addAll(captureTags);
  sam2CramRecordFactory.ignoreTags.addAll(ignoreTags);
  containerFactory.setPreserveReadNames(preserveReadNames);
  int index=0;
  int prevAlStart=start;
  for (  final SAMRecord samRecord : samRecords) {
    final CramCompressionRecord cramRecord=sam2CramRecordFactory.createCramRecord(samRecord);
    cramRecord.index=++index;
    cramRecord.alignmentDelta=samRecord.getAlignmentStart() - prevAlStart;
    cramRecord.alignmentStart=samRecord.getAlignmentStart();
    prevAlStart=samRecord.getAlignmentStart();
    cramRecords.add(cramRecord);
    if (preservation != null)     preservation.addQualityScores(samRecord,cramRecord,tracks);
 else     if (cramRecord.qualityScores != SAMRecord.NULL_QUALS)     cramRecord.setForcePreserveQualityScores(true);
  }
  if (sam2CramRecordFactory.getBaseCount() < 3 * sam2CramRecordFactory.getFeatureCount())   log.warn(""String_Node_Str"");
{
    if (samFileHeader.getSortOrder() == SAMFileHeader.SortOrder.coordinate) {
      final Map<String,CramCompressionRecord> primaryMateMap=new TreeMap<String,CramCompressionRecord>();
      final Map<String,CramCompressionRecord> secondaryMateMap=new TreeMap<String,CramCompressionRecord>();
      for (      final CramCompressionRecord r : cramRecords) {
        if (!r.isMultiFragment()) {
          r.setDetached(true);
          r.setHasMateDownStream(false);
          r.recordsToNextFragment=-1;
          r.next=null;
          r.previous=null;
        }
 else {
          final String name=r.readName;
          final Map<String,CramCompressionRecord> mateMap=r.isSecondaryAlignment() ? secondaryMateMap : primaryMateMap;
          final CramCompressionRecord mate=mateMap.get(name);
          if (mate == null) {
            mateMap.put(name,r);
          }
 else {
            CramCompressionRecord prev=mate;
            while (prev.next != null)             prev=prev.next;
            prev.recordsToNextFragment=r.index - prev.index - 1;
            prev.next=r;
            r.previous=prev;
            r.previous.setHasMateDownStream(true);
            r.setHasMateDownStream(false);
            r.setDetached(false);
            r.previous.setDetached(false);
          }
        }
      }
      for (      final CramCompressionRecord cramRecord : cramRecords) {
        if (cramRecord.next == null || cramRecord.previous != null)         continue;
        CramCompressionRecord last=cramRecord;
        while (last.next != null)         last=last.next;
        if (cramRecord.isFirstSegment() && last.isLastSegment()) {
          final int templateLength=CramNormalizer.computeInsertSize(cramRecord,last);
          if (cramRecord.templateSize == templateLength) {
            last=cramRecord.next;
            while (last.next != null) {
              if (last.templateSize != -templateLength)               break;
              last=last.next;
            }
            if (last.templateSize != -templateLength)             detach(cramRecord);
          }
        }
 else         detach(cramRecord);
      }
      for (      final CramCompressionRecord cramRecord : primaryMateMap.values()) {
        if (cramRecord.next != null)         continue;
        cramRecord.setDetached(true);
        cramRecord.setHasMateDownStream(false);
        cramRecord.recordsToNextFragment=-1;
        cramRecord.next=null;
        cramRecord.previous=null;
      }
      for (      final CramCompressionRecord cramRecord : secondaryMateMap.values()) {
        if (cramRecord.next != null)         continue;
        cramRecord.setDetached(true);
        cramRecord.setHasMateDownStream(false);
        cramRecord.recordsToNextFragment=-1;
        cramRecord.next=null;
        cramRecord.previous=null;
      }
    }
 else {
      for (      final CramCompressionRecord cramRecord : cramRecords) {
        cramRecord.setDetached(true);
      }
    }
  }
{
    @SuppressWarnings(""String_Node_Str"") boolean assertsEnabled=false;
    assert assertsEnabled=true;
    if (assertsEnabled) {
      final Cram2SamRecordFactory f=new Cram2SamRecordFactory(samFileHeader);
      for (int i=0; i < samRecords.size(); i++) {
        final SAMRecord restoredSamRecord=f.create(cramRecords.get(i));
        assert(restoredSamRecord.getAlignmentStart() == samRecords.get(i).getAlignmentStart());
        assert(restoredSamRecord.getReferenceName().equals(samRecords.get(i).getReferenceName()));
        assert(restoredSamRecord.getReadString().equals(samRecords.get(i).getReadString()));
        assert(restoredSamRecord.getBaseQualityString().equals(samRecords.get(i).getBaseQualityString()));
      }
    }
  }
  final Container container=containerFactory.buildContainer(cramRecords);
  for (  final Slice slice : container.slices)   slice.setRefMD5(refs);
  container.offset=offset;
  offset+=ContainerIO.writeContainer(cramVersion,container,outputStream);
  if (indexer != null) {
    for (    final Slice slice : container.slices) {
      indexer.processAlignment(slice);
    }
  }
  samRecords.clear();
}","/** 
 * Complete the current container and flush it to the output stream.
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws IOException
 */
protected void flushContainer() throws IllegalArgumentException, IllegalAccessException, IOException {
  final byte[] refs;
  String refSeqName=null;
  if (refSeqIndex == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX)   refs=new byte[0];
 else {
    final SAMSequenceRecord sequence=samFileHeader.getSequence(refSeqIndex);
    refs=source.getReferenceBases(sequence,true);
    refSeqName=sequence.getSequenceName();
  }
  int start=SAMRecord.NO_ALIGNMENT_START;
  int stop=SAMRecord.NO_ALIGNMENT_START;
  for (  final SAMRecord r : samRecords) {
    if (r.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START)     continue;
    if (start == SAMRecord.NO_ALIGNMENT_START)     start=r.getAlignmentStart();
    start=Math.min(r.getAlignmentStart(),start);
    stop=Math.max(r.getAlignmentEnd(),stop);
  }
  ReferenceTracks tracks=null;
  if (preservation != null && preservation.areReferenceTracksRequired()) {
    tracks=new ReferenceTracks(refSeqIndex,refSeqName,refs);
    tracks.ensureRange(start,stop - start + 1);
    updateTracks(samRecords,tracks);
  }
  final List<CramCompressionRecord> cramRecords=new ArrayList<CramCompressionRecord>(samRecords.size());
  final Sam2CramRecordFactory sam2CramRecordFactory=new Sam2CramRecordFactory(refs,samFileHeader,cramVersion);
  sam2CramRecordFactory.preserveReadNames=preserveReadNames;
  sam2CramRecordFactory.captureAllTags=captureAllTags;
  sam2CramRecordFactory.captureTags.addAll(captureTags);
  sam2CramRecordFactory.ignoreTags.addAll(ignoreTags);
  containerFactory.setPreserveReadNames(preserveReadNames);
  int index=0;
  int prevAlStart=start;
  for (  final SAMRecord samRecord : samRecords) {
    final CramCompressionRecord cramRecord=sam2CramRecordFactory.createCramRecord(samRecord);
    cramRecord.index=++index;
    cramRecord.alignmentDelta=samRecord.getAlignmentStart() - prevAlStart;
    cramRecord.alignmentStart=samRecord.getAlignmentStart();
    prevAlStart=samRecord.getAlignmentStart();
    cramRecords.add(cramRecord);
    if (preservation != null)     preservation.addQualityScores(samRecord,cramRecord,tracks);
 else     if (cramRecord.qualityScores != SAMRecord.NULL_QUALS)     cramRecord.setForcePreserveQualityScores(true);
  }
  if (sam2CramRecordFactory.getBaseCount() < 3 * sam2CramRecordFactory.getFeatureCount())   log.warn(""String_Node_Str"");
{
    if (samFileHeader.getSortOrder() == SAMFileHeader.SortOrder.coordinate) {
      final Map<String,CramCompressionRecord> primaryMateMap=new TreeMap<String,CramCompressionRecord>();
      final Map<String,CramCompressionRecord> secondaryMateMap=new TreeMap<String,CramCompressionRecord>();
      for (      final CramCompressionRecord r : cramRecords) {
        if (!r.isMultiFragment()) {
          r.setDetached(true);
          r.setHasMateDownStream(false);
          r.recordsToNextFragment=-1;
          r.next=null;
          r.previous=null;
        }
 else {
          final String name=r.readName;
          final Map<String,CramCompressionRecord> mateMap=r.isSecondaryAlignment() ? secondaryMateMap : primaryMateMap;
          final CramCompressionRecord mate=mateMap.get(name);
          if (mate == null) {
            mateMap.put(name,r);
          }
 else {
            CramCompressionRecord prev=mate;
            while (prev.next != null)             prev=prev.next;
            prev.recordsToNextFragment=r.index - prev.index - 1;
            prev.next=r;
            r.previous=prev;
            r.previous.setHasMateDownStream(true);
            r.setHasMateDownStream(false);
            r.setDetached(false);
            r.previous.setDetached(false);
          }
        }
      }
      for (      final CramCompressionRecord cramRecord : cramRecords) {
        if (cramRecord.next == null || cramRecord.previous != null)         continue;
        CramCompressionRecord last=cramRecord;
        while (last.next != null)         last=last.next;
        if (cramRecord.isFirstSegment() && last.isLastSegment()) {
          final int templateLength=CramNormalizer.computeInsertSize(cramRecord,last);
          if (cramRecord.templateSize == templateLength) {
            last=cramRecord.next;
            while (last.next != null) {
              if (last.templateSize != -templateLength)               break;
              last=last.next;
            }
            if (last.templateSize != -templateLength)             detach(cramRecord);
          }
 else           detach(cramRecord);
        }
 else         detach(cramRecord);
      }
      for (      final CramCompressionRecord cramRecord : primaryMateMap.values()) {
        if (cramRecord.next != null)         continue;
        cramRecord.setDetached(true);
        cramRecord.setHasMateDownStream(false);
        cramRecord.recordsToNextFragment=-1;
        cramRecord.next=null;
        cramRecord.previous=null;
      }
      for (      final CramCompressionRecord cramRecord : secondaryMateMap.values()) {
        if (cramRecord.next != null)         continue;
        cramRecord.setDetached(true);
        cramRecord.setHasMateDownStream(false);
        cramRecord.recordsToNextFragment=-1;
        cramRecord.next=null;
        cramRecord.previous=null;
      }
    }
 else {
      for (      final CramCompressionRecord cramRecord : cramRecords) {
        cramRecord.setDetached(true);
      }
    }
  }
{
    @SuppressWarnings(""String_Node_Str"") boolean assertsEnabled=false;
    assert assertsEnabled=true;
    if (assertsEnabled) {
      final Cram2SamRecordFactory f=new Cram2SamRecordFactory(samFileHeader);
      for (int i=0; i < samRecords.size(); i++) {
        final SAMRecord restoredSamRecord=f.create(cramRecords.get(i));
        assert(restoredSamRecord.getAlignmentStart() == samRecords.get(i).getAlignmentStart());
        assert(restoredSamRecord.getReferenceName().equals(samRecords.get(i).getReferenceName()));
        assert(restoredSamRecord.getReadString().equals(samRecords.get(i).getReadString()));
        assert(restoredSamRecord.getBaseQualityString().equals(samRecords.get(i).getBaseQualityString()));
      }
    }
  }
  final Container container=containerFactory.buildContainer(cramRecords);
  for (  final Slice slice : container.slices)   slice.setRefMD5(refs);
  container.offset=offset;
  offset+=ContainerIO.writeContainer(cramVersion,container,outputStream);
  if (indexer != null) {
    for (    final Slice slice : container.slices) {
      indexer.processAlignment(slice);
    }
  }
  samRecords.clear();
}",0.9972768532526476
30517,"private List<SAMRecord> createRecords(int count) throws Exception {
  List<SAMRecord> list=new ArrayList<SAMRecord>(count);
  final SAMRecordSetBuilder builder=new SAMRecordSetBuilder();
  if (builder.getHeader().getReadGroups().isEmpty()) {
    throw new Exception(""String_Node_Str"");
  }
  int posInRef=1;
  for (int i=0; i < count / 2; i++)   builder.addPair(Integer.toString(i),0,posInRef+=1,posInRef+=3);
  list.addAll(builder.getRecords());
  Collections.sort(list,new SAMRecordCoordinateComparator());
  return list;
}","private List<SAMRecord> createRecords(int count) throws Exception {
  List<SAMRecord> list=new ArrayList<SAMRecord>(count);
  final SAMRecordSetBuilder builder=new SAMRecordSetBuilder();
  if (builder.getHeader().getReadGroups().isEmpty()) {
    throw new Exception(""String_Node_Str"");
  }
  int posInRef=1;
  for (int i=0; i < count / 2; i++) {
    builder.addPair(Integer.toString(i),0,posInRef+=1,posInRef+=3);
  }
  list.addAll(builder.getRecords());
  Collections.sort(list,new SAMRecordCoordinateComparator());
  return list;
}",0.9924385633270322
30518,"/** 
 * Remove all options from the set of <code>Options</code> for the <code>VariantContextWriterBuilder</code>.
 * @return this VariantContextWriterBuilder
 */
public VariantContextWriterBuilder clearOptions(){
  this.options=NO_OPTIONS;
  return this;
}","/** 
 * Remove all options from the set of <code>Options</code> for the <code>VariantContextWriterBuilder</code>.
 * @return this VariantContextWriterBuilder
 */
public VariantContextWriterBuilder clearOptions(){
  this.options=NO_OPTIONS.clone();
  return this;
}",0.9846153846153848
30519,"protected AbstractBAMFileIndex(final File file,final SAMSequenceDictionary dictionary,final boolean useMemoryMapping){
  mBamDictionary=dictionary;
  mIndexBuffer=(useMemoryMapping ? new MemoryMappedFileBuffer(file) : new RandomAccessFileBuffer(file));
  seek(0);
  final byte[] buffer=new byte[4];
  readBytes(buffer);
  if (!Arrays.equals(buffer,BAMFileConstants.BAM_INDEX_MAGIC)) {
    throw new RuntimeIOException(""String_Node_Str"" + file + ""String_Node_Str""+ new String(buffer));
  }
  sequenceIndexes=new int[readInteger() + 1];
  Arrays.fill(sequenceIndexes,-1);
}","protected AbstractBAMFileIndex(final File file,final SAMSequenceDictionary dictionary,final boolean useMemoryMapping){
  mBamDictionary=dictionary;
  mIndexBuffer=(useMemoryMapping ? new MemoryMappedFileBuffer(file) : new RandomAccessFileBuffer(file));
  verifyBAMMagicNumber(file.getName());
  sequenceIndexes=new int[readInteger() + 1];
  Arrays.fill(sequenceIndexes,-1);
}",0.7209302325581395
30520,"public CRAMIterator(final SeekableStream seekableStream,final ReferenceSource referenceSource,final long[] coordinates) throws IOException {
  this.countingInputStream=new CountingInputStream(seekableStream);
  this.referenceSource=referenceSource;
  final CramSpanContainerIterator containerIterator=CramSpanContainerIterator.fromFileSpan(seekableStream,coordinates);
  cramHeader=containerIterator.getCramHeader();
  this.containerIterator=containerIterator;
  firstContainerOffset=containerIterator.getFirstContainerOffset();
  records=new ArrayList<SAMRecord>(10000);
  normalizer=new CramNormalizer(cramHeader.getSamFileHeader(),referenceSource);
  parser=new ContainerParser(cramHeader.getSamFileHeader());
}","public CRAMIterator(final SeekableStream seekableStream,final ReferenceSource referenceSource,final long[] coordinates) throws IOException {
  if (null == referenceSource) {
    throw new CRAMException(""String_Node_Str"");
  }
  this.countingInputStream=new CountingInputStream(seekableStream);
  this.referenceSource=referenceSource;
  final CramSpanContainerIterator containerIterator=CramSpanContainerIterator.fromFileSpan(seekableStream,coordinates);
  cramHeader=containerIterator.getCramHeader();
  this.containerIterator=containerIterator;
  firstContainerOffset=containerIterator.getFirstContainerOffset();
  records=new ArrayList<SAMRecord>(10000);
  normalizer=new CramNormalizer(cramHeader.getSamFileHeader(),referenceSource);
  parser=new ContainerParser(cramHeader.getSamFileHeader());
}",0.9438202247191012
30521,"@Override public int compareTo(final CRAIEntry o){
  if (o == null) {
    return 1;
  }
  if (sequenceId != o.sequenceId) {
    return o.sequenceId - sequenceId;
  }
  if (alignmentStart != o.alignmentStart) {
    return alignmentStart - o.alignmentStart;
  }
  return (int)(containerStartOffset - o.containerStartOffset);
}","@Override public int compareTo(final CRAIEntry o){
  if (o == null) {
    return 1;
  }
  if (sequenceId != o.sequenceId) {
    return sequenceId - o.sequenceId;
  }
  if (alignmentStart != o.alignmentStart) {
    return alignmentStart - o.alignmentStart;
  }
  return (int)(containerStartOffset - o.containerStartOffset);
}",0.9938271604938272
30522,"@Test(dataProvider=""String_Node_Str"") public void CRAMIndexTest(final String inputFile){
  final File input=new File(TEST_DATA_DIR,inputFile);
  final SamReader reader=SamReaderFactory.makeDefault().open(input);
  Assert.assertTrue(reader.hasIndex());
  CloserUtil.close(reader);
}","@Test(dataProvider=""String_Node_Str"") public void CRAMIndexTest(final String inputFile,final String referenceFile,QueryInterval queryInterval,String expectedReadName){
  final File input=new File(TEST_DATA_DIR,inputFile);
  final File reference=new File(TEST_DATA_DIR,referenceFile);
  final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(reference).open(input);
  Assert.assertTrue(reader.hasIndex());
  final CloseableIterator<SAMRecord> iterator=reader.query(new QueryInterval[]{queryInterval},false);
  Assert.assertTrue(iterator.hasNext());
  SAMRecord r1=iterator.next();
  Assert.assertEquals(r1.getReadName(),expectedReadName);
  CloserUtil.close(reader);
}",0.5823834196891192
30523,"@DataProvider(name=""String_Node_Str"") public Object[][] CRAMIndexTestData(){
  final Object[][] testFiles=new Object[][]{{""String_Node_Str""}};
  return testFiles;
}","@DataProvider(name=""String_Node_Str"") public Object[][] CRAMIndexTestData(){
  final Object[][] testFiles=new Object[][]{{""String_Node_Str"",""String_Node_Str"",new QueryInterval(0,12,13),""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",new QueryInterval(3,700,0),""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",new QueryInterval(2,350,0),""String_Node_Str""}};
  return testFiles;
}",0.5888689407540395
30524,"@DataProvider(name=""String_Node_Str"") public Object[][] CRAMNoIndexTestData(){
  final Object[][] testFiles=new Object[][]{{""String_Node_Str""}};
  return testFiles;
}","@DataProvider(name=""String_Node_Str"") public Object[][] CRAMNoIndexTestData(){
  final Object[][] testFiles=new Object[][]{{""String_Node_Str"",""String_Node_Str""}};
  return testFiles;
}",0.9485714285714286
30525,"@Test(dataProvider=""String_Node_Str"") public void CRAMNoIndexTest(final String inputFile){
  final File input=new File(TEST_DATA_DIR,inputFile);
  final SamReader reader=SamReaderFactory.makeDefault().open(input);
  Assert.assertFalse(reader.hasIndex());
  CloserUtil.close(reader);
}","@Test(dataProvider=""String_Node_Str"") public void CRAMNoIndexTest(final String inputFile,final String referenceFile){
  final File input=new File(TEST_DATA_DIR,inputFile);
  final File reference=new File(TEST_DATA_DIR,referenceFile);
  final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(reference).open(input);
  Assert.assertFalse(reader.hasIndex());
  CloserUtil.close(reader);
}",0.8279883381924198
30526,"/** 
 * Read bases from input
 * @param knownLength For performance:: -1 if length is not known, otherwise the length of the sequence.
 * @return ASCII bases for sequence
 */
private byte[] readSequence(final int knownLength){
  byte[] bases=(knownLength == -1) ? basesBuffer : new byte[knownLength];
  int sequenceLength=0;
  while (!in.eof()) {
    final boolean sawEoln=in.skipNewlines();
    if (in.eof()) {
      break;
    }
    if (sawEoln && in.peekByte() == '>') {
      break;
    }
    sequenceLength+=in.readToEndOfOutputBufferOrEoln(bases,sequenceLength);
    while (sequenceLength > 0 && Character.isWhitespace(StringUtil.byteToChar(bases[sequenceLength - 1]))) {
      --sequenceLength;
    }
    if (sequenceLength == knownLength) {
      break;
    }
    if (sequenceLength == bases.length) {
      final byte[] tmp=new byte[bases.length * 2];
      System.arraycopy(bases,0,tmp,0,sequenceLength);
      bases=tmp;
    }
  }
  if (sequenceLength != bases.length || bases == basesBuffer) {
    final byte[] tmp=new byte[sequenceLength];
    System.arraycopy(bases,0,tmp,0,sequenceLength);
    bases=tmp;
  }
  return bases;
}","/** 
 * Read bases from input
 * @param knownLength For performance:: -1 if length is not known, otherwise the length of the sequence.
 * @return ASCII bases for sequence
 */
private byte[] readSequence(final int knownLength){
  byte[] bases=(knownLength == -1) ? basesBuffer : new byte[knownLength];
  int sequenceLength=0;
  while (!in.eof()) {
    final boolean sawEoln=in.skipNewlines();
    if (in.eof()) {
      break;
    }
    if (sawEoln && in.peekByte() == '>') {
      break;
    }
    sequenceLength+=in.readToEndOfOutputBufferOrEoln(bases,sequenceLength);
    while (sequenceLength > 0 && Character.isWhitespace(StringUtil.byteToChar(bases[sequenceLength - 1]))) {
      --sequenceLength;
    }
    if (sequenceLength == knownLength) {
      skipToEoln();
      break;
    }
    if (sequenceLength == bases.length) {
      final byte[] tmp=new byte[bases.length * 2];
      System.arraycopy(bases,0,tmp,0,sequenceLength);
      bases=tmp;
    }
  }
  if (sequenceLength != bases.length || bases == basesBuffer) {
    final byte[] tmp=new byte[sequenceLength];
    System.arraycopy(bases,0,tmp,0,sequenceLength);
    bases=tmp;
  }
  return bases;
}",0.9913119026933102
30527,"public int hashCode(){
  int result=0;
  for (  final Field f : getClass().getFields()) {
    try {
      result=31 * result + f.get(this).hashCode();
    }
 catch (    IllegalAccessException e) {
      throw new SAMException(""String_Node_Str"" + f.getName() + ""String_Node_Str""+ getClass().getSimpleName());
    }
  }
  return result;
}","/** 
 * Computes a hashcode by formatting each field into its on disk representation  and summing the hashcodes of all the fields.
 */
public int hashCode(){
  int result=0;
  FormatUtil formatter=new FormatUtil();
  for (  final Field f : getClass().getFields()) {
    try {
      Object value=f.get(this);
      value=formatter.format(value);
      final int fieldHash=value != null ? value.hashCode() : 0;
      result=31 * result + fieldHash;
    }
 catch (    IllegalAccessException e) {
      throw new SAMException(""String_Node_Str"" + f.getName() + ""String_Node_Str""+ getClass().getSimpleName());
    }
  }
  return result;
}",0.6239669421487604
30528,"public boolean equals(MetricBase that){
  for (  Field field : this.getClass().getFields()) {
    try {
      if (!Objects.equals(field.get(this),field.get(that))) {
        return false;
      }
    }
 catch (    IllegalAccessException ex) {
      return false;
    }
  }
  return true;
}","/** 
 * An equals method that checks equality by asserting that the classes are of the exact same type and that all public fields are equivalent.  Equivalence is checked by formatting the field as it would be written to disk and then checking String equality.
 * @param o an instance to compare to
 * @return true if they are equal, false otherwise
 */
public boolean equals(final Object o){
  if (o == null)   return false;
  if (o.getClass() != getClass())   return false;
  final FormatUtil formatter=new FormatUtil();
  for (  final Field f : getClass().getFields()) {
    try {
      final Object lhs=f.get(this);
      final Object rhs=f.get(o);
      if (lhs == null) {
        if (rhs == null) {
        }
 else {
          return false;
        }
      }
 else {
        if (formatter.format(lhs).equals(formatter.format(rhs))) {
        }
 else {
          return false;
        }
      }
    }
 catch (    IllegalAccessException iae) {
      throw new SAMException(""String_Node_Str"" + f.getName() + ""String_Node_Str""+ getClass().getSimpleName());
    }
  }
  return true;
}",0.202476329206118
30529,"/** 
 * Constructs a new FormatUtil and initializes various internal formatters. 
 */
public FormatUtil(){
  this.dateFormat=new SimpleDateFormat(""String_Node_Str"");
  this.integerFormat=NumberFormat.getIntegerInstance();
  this.integerFormat.setGroupingUsed(false);
  this.floatFormat=NumberFormat.getNumberInstance();
  this.floatFormat.setGroupingUsed(false);
  this.floatFormat.setMaximumFractionDigits(6);
  this.floatFormat.setRoundingMode(RoundingMode.HALF_DOWN);
  if (this.floatFormat instanceof DecimalFormat) {
    final DecimalFormat decimalFormat=(DecimalFormat)this.floatFormat;
    final DecimalFormatSymbols decimalFormatSymbols=decimalFormat.getDecimalFormatSymbols();
    decimalFormatSymbols.setNaN(""String_Node_Str"");
    decimalFormatSymbols.setInfinity(""String_Node_Str"");
    decimalFormat.setDecimalFormatSymbols(decimalFormatSymbols);
  }
}","/** 
 * Constructs a new FormatUtil and initializes various internal formatters.  This is necessary because SimpleDateFormat and other formatters are not threadsafe.
 */
public FormatUtil(){
  this.dateFormat=new SimpleDateFormat(""String_Node_Str"");
  this.integerFormat=NumberFormat.getIntegerInstance();
  this.integerFormat.setGroupingUsed(false);
  this.floatFormat=NumberFormat.getNumberInstance();
  this.floatFormat.setGroupingUsed(false);
  this.floatFormat.setMaximumFractionDigits(DECIMAL_DIGITS_TO_PRINT);
  this.floatFormat.setRoundingMode(RoundingMode.HALF_DOWN);
  if (this.floatFormat instanceof DecimalFormat) {
    final DecimalFormat decimalFormat=(DecimalFormat)this.floatFormat;
    final DecimalFormatSymbols decimalFormatSymbols=decimalFormat.getDecimalFormatSymbols();
    decimalFormatSymbols.setNaN(""String_Node_Str"");
    decimalFormatSymbols.setInfinity(""String_Node_Str"");
    decimalFormat.setDecimalFormatSymbols(decimalFormatSymbols);
  }
}",0.9411764705882352
30530,"@Test public void testWriteMetricsFile() throws Exception {
  MetricsFile<TestMetric,Integer> file=new MetricsFile<TestMetric,Integer>();
  TestMetric metric=new TestMetric();
  metric.STRING_PROP=""String_Node_Str"";
  metric.DATE_PROP=new FormatUtil().parseDate(""String_Node_Str"");
  metric.SHORT_PROP=123;
  metric.INTEGER_PROP=null;
  metric.LONG_PROP=Long.MAX_VALUE;
  metric.FLOAT_PROP=456.789f;
  metric.DOUBLE_PROP=0.713487;
  metric.ENUM_PROP=TestEnum.Two;
  metric.BOOLEAN_PROP=false;
  metric.CHARACTER_PROP='A';
  metric.SHORT_PRIMITIVE=123;
  metric.INT_PRIMITIVE=919834781;
  metric.LONG_PRIMITIVE=Long.MAX_VALUE - Integer.MAX_VALUE;
  metric.FLOAT_PRIMITIVE=0.55694f;
  metric.DOUBLE_PRIMITIVE=0.229233;
  metric.BOOLEAN_PRIMITIVE=true;
  metric.CHAR_PRIMITIVE='B';
  file.addMetric(metric);
  MetricsFile<TestMetric,Integer> file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  StringHeader stringHeader=new StringHeader();
  stringHeader.setValue(""String_Node_Str"");
  file.addHeader(stringHeader);
  VersionHeader version=new VersionHeader();
  version.setVersionedItem(""String_Node_Str"");
  version.setVersionString(""String_Node_Str"");
  file.addHeader(version);
  version=new VersionHeader();
  version.setVersionedItem(""String_Node_Str"");
  version.setVersionString(""String_Node_Str"");
  file.addHeader(version);
  file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  Histogram<Integer> histo=new Histogram<Integer>();
  histo.setBinLabel(""String_Node_Str"");
  histo.setValueLabel(""String_Node_Str"");
  histo.increment(1,101);
  histo.increment(2,202);
  histo.increment(3,4000);
  histo.increment(5,123981);
  histo.increment(1000,10981982);
  file.setHistogram(histo);
  file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  TestMetric metric2=metric.clone();
  metric2.ENUM_PROP=TestEnum.One;
  metric2.FLOAT_PROP=0.998f;
  metric2.STRING_PROP=""String_Node_Str"";
  file.addMetric(metric2);
  metric2=metric.clone();
  metric2.ENUM_PROP=TestEnum.Three;
  metric2.DOUBLE_PRIMITIVE=1.299d;
  file.addMetric(metric2);
  file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  MetricsFile<TestMetric,Integer> file3=TestUtil.serializeAndDeserialize(file);
  Assert.assertEquals(file,file3);
}","@Test public void testWriteMetricsFile() throws IOException, ClassNotFoundException {
  MetricsFile<TestMetric,Integer> file=new MetricsFile<TestMetric,Integer>();
  TestMetric metric=new TestMetric();
  metric.STRING_PROP=""String_Node_Str"";
  metric.DATE_PROP=new FormatUtil().parseDate(""String_Node_Str"");
  metric.SHORT_PROP=123;
  metric.INTEGER_PROP=null;
  metric.LONG_PROP=Long.MAX_VALUE;
  metric.FLOAT_PROP=456.789f;
  metric.DOUBLE_PROP=0.713487;
  metric.ENUM_PROP=TestEnum.Two;
  metric.BOOLEAN_PROP=false;
  metric.CHARACTER_PROP='A';
  metric.SHORT_PRIMITIVE=123;
  metric.INT_PRIMITIVE=919834781;
  metric.LONG_PRIMITIVE=Long.MAX_VALUE - Integer.MAX_VALUE;
  metric.FLOAT_PRIMITIVE=0.55694f;
  metric.DOUBLE_PRIMITIVE=0.229233;
  metric.BOOLEAN_PRIMITIVE=true;
  metric.CHAR_PRIMITIVE='B';
  file.addMetric(metric);
  MetricsFile<TestMetric,Integer> file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  StringHeader stringHeader=new StringHeader();
  stringHeader.setValue(""String_Node_Str"");
  file.addHeader(stringHeader);
  VersionHeader version=new VersionHeader();
  version.setVersionedItem(""String_Node_Str"");
  version.setVersionString(""String_Node_Str"");
  file.addHeader(version);
  version=new VersionHeader();
  version.setVersionedItem(""String_Node_Str"");
  version.setVersionString(""String_Node_Str"");
  file.addHeader(version);
  file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  Histogram<Integer> histo=new Histogram<Integer>();
  histo.setBinLabel(""String_Node_Str"");
  histo.setValueLabel(""String_Node_Str"");
  histo.increment(1,101);
  histo.increment(2,202);
  histo.increment(3,4000);
  histo.increment(5,123981);
  histo.increment(1000,10981982);
  file.setHistogram(histo);
  file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  TestMetric metric2=metric.clone();
  metric2.ENUM_PROP=TestEnum.One;
  metric2.FLOAT_PROP=0.998f;
  metric2.STRING_PROP=""String_Node_Str"";
  file.addMetric(metric2);
  metric2=metric.clone();
  metric2.ENUM_PROP=TestEnum.Three;
  metric2.DOUBLE_PRIMITIVE=1.299d;
  file.addMetric(metric2);
  file2=writeThenReadBack(file);
  Assert.assertEquals(file,file2);
  MetricsFile<TestMetric,Integer> file3=TestUtil.serializeAndDeserialize(file);
  Assert.assertEquals(file,file3);
}",0.9942907334211682
30531,"/** 
 * Helper method to persist metrics to file and read them back again. 
 */
private MetricsFile<TestMetric,Integer> writeThenReadBack(MetricsFile<TestMetric,Integer> in) throws Exception {
  File f=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  f.deleteOnExit();
  FileWriter out=new FileWriter(f);
  in.write(out);
  MetricsFile<TestMetric,Integer> retval=new MetricsFile<TestMetric,Integer>();
  retval.read(new FileReader(f));
  return retval;
}","/** 
 * Helper method to persist metrics to file and read them back again. 
 */
private <METRIC extends MetricBase>MetricsFile<METRIC,Integer> writeThenReadBack(MetricsFile<METRIC,Integer> in) throws IOException {
  File f=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  f.deleteOnExit();
  FileWriter out=new FileWriter(f);
  in.write(out);
  MetricsFile<METRIC,Integer> retval=new MetricsFile<METRIC,Integer>();
  retval.read(new FileReader(f));
  return retval;
}",0.8780487804878049
30532,"/** 
 * @param cigarette CIGAR element (operator + length) encoded as an unsigned int.
 * @return Object representation of the CIGAR element.
 */
private static CigarElement binaryCigarToCigarElement(final int cigarette){
  final int binaryOp=cigarette & 0xf;
  final int length=cigarette >> 4;
  return new CigarElement(length,CigarOperator.binaryToEnum(binaryOp));
}","/** 
 * @param cigarette CIGAR element (operator + length) encoded as an unsigned int.
 * @return Object representation of the CIGAR element.
 */
private static CigarElement binaryCigarToCigarElement(final int cigarette){
  final int binaryOp=cigarette & 0xf;
  final int length=cigarette >>> 4;
  return new CigarElement(length,CigarOperator.binaryToEnum(binaryOp));
}",0.9986431478968792
30533,"/** 
 * Generates a BAM index file from an input BAM file
 * @param reader SAMFileReader for input BAM file
 * @param output File for output index file
 */
public static void createIndex(SamReader reader,File output,Log log){
  BAMIndexer indexer=new BAMIndexer(output,reader.getFileHeader());
  int totalRecords=0;
  for (  SAMRecord rec : reader) {
    if (++totalRecords % 1000000 == 0) {
      if (null != log)       log.info(totalRecords + ""String_Node_Str"");
    }
    indexer.processAlignment(rec);
  }
  indexer.finish();
}","/** 
 * Generates a BAM index file from an input BAM file
 * @param reader SAMFileReader for input BAM file
 * @param output File for output index file
 */
public static void createIndex(SamReader reader,File output,Log log){
  BAMIndexer indexer=new BAMIndexer(output,reader.getFileHeader());
  long totalRecords=0;
  for (  SAMRecord rec : reader) {
    if (++totalRecords % 1000000 == 0) {
      if (null != log)       log.info(totalRecords + ""String_Node_Str"");
    }
    indexer.processAlignment(rec);
  }
  indexer.finish();
}",0.993414863593603
30534,"/** 
 * Sets a header line in the header metadata. This is essentially a Set.add call, which means that equals() and hashCode() are used to determine whether an additional header line is added or an existing header line is replaced.
 */
public void addMetaDataLine(final VCFHeaderLine headerLine){
  addMetadataHeaderLine(headerLine);
}","/** 
 * Adds a new line to the VCFHeader. If there is an existing header line of the same type with the same key, the new line is not added and the existing line is preserved.
 * @param headerLine header line to attempt to add
 */
public void addMetaDataLine(final VCFHeaderLine headerLine){
  if (addMetadataLineLookupEntry(headerLine)) {
    mMetaData.add(headerLine);
    checkForDeprecatedGenotypeLikelihoodsKey();
  }
}",0.1710526315789473
30535,"/** 
 * Sets a header line in the header metadata. This is essentially a Set.add call, which means that equals() and hashCode() are used to determine whether an additional header line is added or an existing header line is replaced.
 */
public void addMetaDataLine(final VCFHeaderLine headerLine){
  addMetadataHeaderLine(headerLine);
}","/** 
 * Adds a new line to the VCFHeader. If there is an existing header line of the same type with the same key, the new line is not added and the existing line is preserved.
 * @param headerLine header line to attempt to add
 */
public void addMetaDataLine(final VCFHeaderLine headerLine){
  if (addMetadataLineLookupEntry(headerLine)) {
    mMetaData.add(headerLine);
    checkForDeprecatedGenotypeLikelihoodsKey();
  }
}",0.1710526315789473
30536,"/** 
 * @see {@link AsciiFeatureCodec#decode(htsjdk.tribble.readers.LineIterator)} 
 */
public abstract T decode(String s);","/** 
 * @see AsciiFeatureCodec#decode(htsjdk.tribble.readers.LineIterator) 
 */
public abstract T decode(String s);",0.9663865546218487
30537,"/** 
 * This function returns true iff the File potentialInput can be parsed by this codec. <p/> There is an assumption that there's never a situation where two different Codecs return true for the same file.  If this occurs, the recommendation would be to error out. <p/> Note this function must never throw an error.  All errors should be trapped and false returned.
 * @param path the file to test for parsability with this codec
 * @return true if potentialInput can be parsed, false otherwise
 */
public boolean canDecode(final String path);","/** 
 * <p> This function returns true iff the File potentialInput can be parsed by this codec. </p> <p> There is an assumption that there's never a situation where two different Codecs return true for the same file.  If this occurs, the recommendation would be to error out. </p> Note this function must never throw an error.  All errors should be trapped and false returned.
 * @param path the file to test for parsability with this codec
 * @return true if potentialInput can be parsed, false otherwise
 */
public boolean canDecode(final String path);",0.9890909090909092
30538,"/** 
 * This function returns the object the codec generates.  This is allowed to be Feature in the case where conditionally different types are generated.  Be as specific as you can though. <p/> This function is used by reflections based tools, so we can know the underlying type
 * @return the feature type this codec generates.
 */
public Class<FEATURE_TYPE> getFeatureType();","/** 
 * <p> This function returns the object the codec generates.  This is allowed to be Feature in the case where conditionally different types are generated.  Be as specific as you can though. </p> <p> This function is used by reflections based tools, so we can know the underlying type </p>
 * @return the feature type this codec generates.
 */
public Class<FEATURE_TYPE> getFeatureType();",0.980544747081712
30539,"/** 
 * Reads the next record from input stream and prepare this decoder to decode values from it
 * @param stream
 * @return
 */
public void readNextBlock(final int blockSizeInBytes,final InputStream stream){
  if (blockSizeInBytes < 0)   throw new TribbleException(""String_Node_Str"" + blockSizeInBytes);
  setRecordBytes(readRecordBytes(blockSizeInBytes,stream));
}","/** 
 * Reads the next record from input stream and prepare this decoder to decode values from it
 * @param stream
 */
public void readNextBlock(final int blockSizeInBytes,final InputStream stream){
  if (blockSizeInBytes < 0)   throw new TribbleException(""String_Node_Str"" + blockSizeInBytes);
  setRecordBytes(readRecordBytes(blockSizeInBytes,stream));
}",0.9847856154910096
30540,"/** 
 * Skips the next record from input stream, invalidating current block data
 * @param stream
 * @return
 */
public void skipNextBlock(final int blockSizeInBytes,final InputStream stream){
  try {
    final int bytesRead=(int)stream.skip(blockSizeInBytes);
    validateReadBytes(bytesRead,1,blockSizeInBytes);
  }
 catch (  IOException e) {
    throw new TribbleException(""String_Node_Str"",e);
  }
  this.recordBytes=null;
  this.recordStream=null;
}","/** 
 * Skips the next record from input stream, invalidating current block data
 * @param stream
 */
public void skipNextBlock(final int blockSizeInBytes,final InputStream stream){
  try {
    final int bytesRead=(int)stream.skip(blockSizeInBytes);
    validateReadBytes(bytesRead,1,blockSizeInBytes);
  }
 catch (  IOException e) {
    throw new TribbleException(""String_Node_Str"",e);
  }
  this.recordBytes=null;
  this.recordStream=null;
}",0.987736900780379
30541,"/** 
 * Collapse multiple strings into a comma separated list [""s1"", ""s2"", ""s3""] => "",s1,s2,s3""
 * @param strings size > 1 list of strings
 * @return
 */
public static String collapseStringList(final List<String> strings){
}","/** 
 * Collapse multiple strings into a comma separated list [""s1"", ""s2"", ""s3""] =&gt; "",s1,s2,s3""
 * @param strings size &gt; 1 list of strings
 * @return
 */
public static String collapseStringList(final List<String> strings){
}",0.9779735682819384
30542,"/** 
 * Returns a good name for a shadow BCF file for vcfFile. foo.vcf => foo.bcf foo.xxx => foo.xxx.bcf If the resulting BCF file cannot be written, return null.  Happens when vcfFile = /dev/null for example
 * @param vcfFile
 * @return the BCF
 */
public static final File shadowBCF(final File vcfFile){
  final String path=vcfFile.getAbsolutePath();
  if (path.contains(""String_Node_Str""))   return new File(path.replace(""String_Node_Str"",""String_Node_Str""));
 else {
    final File bcf=new File(path + ""String_Node_Str"");
    if (bcf.canRead())     return bcf;
 else {
      try {
        final FileOutputStream o=new FileOutputStream(bcf);
        o.close();
        bcf.delete();
        return bcf;
      }
 catch (      FileNotFoundException e) {
        return null;
      }
catch (      IOException e) {
        return null;
      }
    }
  }
}","/** 
 * Returns a good name for a shadow BCF file for vcfFile. foo.vcf =&gt; foo.bcf foo.xxx =&gt; foo.xxx.bcf If the resulting BCF file cannot be written, return null.  Happens when vcfFile = /dev/null for example
 * @param vcfFile
 * @return the BCF
 */
public static final File shadowBCF(final File vcfFile){
  final String path=vcfFile.getAbsolutePath();
  if (path.contains(""String_Node_Str""))   return new File(path.replace(""String_Node_Str"",""String_Node_Str""));
 else {
    final File bcf=new File(path + ""String_Node_Str"");
    if (bcf.canRead())     return bcf;
 else {
      try {
        final FileOutputStream o=new FileOutputStream(bcf);
        o.close();
        bcf.delete();
        return bcf;
      }
 catch (      FileNotFoundException e) {
        return null;
      }
catch (      IOException e) {
        return null;
      }
    }
  }
}",0.9941656942823804
30543,"/** 
 * Helper function that takes an object and returns a list representation of it: o == null => [] o is a list => o else => [o]
 * @param c  the class of the object
 * @param o  the object to convert to a Java List
 * @return
 */
public static <T>List<T> toList(final Class<T> c,final Object o){
  if (o == null)   return Collections.emptyList();
 else   if (o instanceof List)   return (List<T>)o;
 else   if (o.getClass().isArray()) {
    final int arraySize=Array.getLength(o);
    final List<T> list=new ArrayList<T>(arraySize);
    for (int i=0; i < arraySize; i++)     list.add((T)Array.get(o,i));
    return list;
  }
 else   return Collections.singletonList((T)o);
}","/** 
 * Helper function that takes an object and returns a list representation of it: o == null =&gt; [] o is a list =&gt; o else =&gt; [o]
 * @param c  the class of the object
 * @param o  the object to convert to a Java List
 * @return
 */
public static <T>List<T> toList(final Class<T> c,final Object o){
  if (o == null)   return Collections.emptyList();
 else   if (o instanceof List)   return (List<T>)o;
 else   if (o.getClass().isArray()) {
    final int arraySize=Array.getLength(o);
    final List<T> list=new ArrayList<T>(arraySize);
    for (int i=0; i < arraySize; i++)     list.add((T)Array.get(o,i));
    return list;
  }
 else   return Collections.singletonList((T)o);
}",0.975788701393984
30544,"/** 
 * Inverse operation of collapseStringList. "",s1,s2,s3"" => [""s1"", ""s2"", ""s3""]
 * @param collapsed
 * @return
 */
public static List<String> explodeStringList(final String collapsed){
}","/** 
 * Inverse operation of collapseStringList. "",s1,s2,s3"" =&gt; [""s1"", ""s2"", ""s3""]
 * @param collapsed
 * @return
 */
public static List<String> explodeStringList(final String collapsed){
}",0.9868766404199476
30545,"/** 
 * Make all combinations of N size of objects if objects = [A, B, C] if N = 1 => [[A], [B], [C]] if N = 2 => [[A, A], [B, A], [C, A], [A, B], [B, B], [C, B], [A, C], [B, C], [C, C]]
 * @param objects
 * @param n
 * @param < T >
 * @param withReplacement if false, the resulting permutations will only contain unique objects from objects
 * @return
 */
public static <T>List<List<T>> makePermutations(final List<T> objects,final int n,final boolean withReplacement){
  final List<List<T>> combinations=new ArrayList<List<T>>();
  if (n <= 0)   ;
 else   if (n == 1) {
    for (    final T o : objects)     combinations.add(Collections.singletonList(o));
  }
 else {
    final List<List<T>> sub=makePermutations(objects,n - 1,withReplacement);
    for (    List<T> subI : sub) {
      for (      final T a : objects) {
        if (withReplacement || !subI.contains(a))         combinations.add(cons(a,subI));
      }
    }
  }
  return combinations;
}","/** 
 * Make all combinations of N size of objects if objects = [A, B, C] if N = 1 =&gt; [[A], [B], [C]] if N = 2 =&gt; [[A, A], [B, A], [C, A], [A, B], [B, B], [C, B], [A, C], [B, C], [C, C]]
 * @param objects
 * @param n
 * @param < T >
 * @param withReplacement if false, the resulting permutations will only contain unique objects from objects
 * @return
 */
public static <T>List<List<T>> makePermutations(final List<T> objects,final int n,final boolean withReplacement){
  final List<List<T>> combinations=new ArrayList<List<T>>();
  if (n <= 0)   ;
 else   if (n == 1) {
    for (    final T o : objects)     combinations.add(Collections.singletonList(o));
  }
 else {
    final List<List<T>> sub=makePermutations(objects,n - 1,withReplacement);
    for (    List<T> subI : sub) {
      for (      final T a : objects) {
        if (withReplacement || !subI.contains(a))         combinations.add(cons(a,subI));
      }
    }
  }
  return combinations;
}",0.994775339602926
30546,"/** 
 * Return the printed representation of this allele. Same as getBaseString(), except for symbolic alleles. For symbolic alleles, the base string is empty while the display string contains <TAG>.
 * @return the allele string representation
 */
public String getDisplayString(){
  return new String(bases);
}","/** 
 * Return the printed representation of this allele. Same as getBaseString(), except for symbolic alleles. For symbolic alleles, the base string is empty while the display string contains &lt;TAG&gt;.
 * @return the allele string representation
 */
public String getDisplayString(){
  return new String(bases);
}",0.9840764331210192
30547,"/** 
 * Adds a fragment record (mapped or unmapped) to the set using the provided contig start and optionally the strand, cigar string, quality string or default quality score.  This does not modify the flag field, which should be updated if desired before adding the return to the list of records.
 */
private SAMRecord createReadNoFlag(final String name,final int contig,final int start,final boolean negativeStrand,final boolean recordUnmapped,final String cigar,final String qualityString,final int defaultQuality) throws SAMException {
  final SAMRecord rec=new SAMRecord(this.header);
  rec.setReadName(name);
  if (chroms.length <= contig) {
    throw new SAMException(""String_Node_Str"" + chroms.length + ""String_Node_Str""+ contig);
  }
  if (0 <= contig) {
    rec.setReferenceIndex(contig);
    rec.setReferenceName(chroms[contig]);
    rec.setAlignmentStart(start);
  }
  if (!recordUnmapped) {
    rec.setReadNegativeStrandFlag(negativeStrand);
    if (null != cigar) {
      rec.setCigarString(cigar);
    }
 else     if (!rec.getReadUnmappedFlag()) {
      rec.setCigarString(readLength + ""String_Node_Str"");
    }
    rec.setMappingQuality(255);
  }
 else {
    rec.setReadUnmappedFlag(true);
  }
  rec.setAttribute(SAMTag.RG.name(),READ_GROUP_ID);
  if (programRecord != null) {
    rec.setAttribute(SAMTag.PG.name(),programRecord.getProgramGroupId());
  }
  if (readGroup != null) {
    rec.setAttribute(SAMTag.RG.name(),readGroup.getReadGroupId());
  }
  fillInBasesAndQualities(rec,qualityString,defaultQuality);
  return rec;
}","/** 
 * Adds a fragment record (mapped or unmapped) to the set using the provided contig start and optionally the strand, cigar string, quality string or default quality score.  This does not modify the flag field, which should be updated if desired before adding the return to the list of records.
 */
private SAMRecord createReadNoFlag(final String name,final int contig,final int start,final boolean negativeStrand,final boolean recordUnmapped,final String cigar,final String qualityString,final int defaultQuality) throws SAMException {
  final SAMRecord rec=new SAMRecord(this.header);
  rec.setReadName(name);
  if (chroms.length <= contig) {
    throw new SAMException(""String_Node_Str"" + chroms.length + ""String_Node_Str""+ contig);
  }
  if (0 <= contig) {
    rec.setReferenceIndex(contig);
    rec.setReferenceName(chroms[contig]);
    rec.setAlignmentStart(start);
  }
  if (!recordUnmapped) {
    rec.setReadNegativeStrandFlag(negativeStrand);
    if (null != cigar) {
      rec.setCigarString(cigar);
    }
 else     if (!rec.getReadUnmappedFlag()) {
      rec.setCigarString(readLength + ""String_Node_Str"");
    }
    rec.setMappingQuality(255);
  }
 else {
    rec.setReadUnmappedFlag(true);
  }
  rec.setAttribute(SAMTag.RG.name(),READ_GROUP_ID);
  if (useNmFlag) {
    rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTagFromCigar(rec));
  }
  if (programRecord != null) {
    rec.setAttribute(SAMTag.PG.name(),programRecord.getProgramGroupId());
  }
  if (readGroup != null) {
    rec.setAttribute(SAMTag.RG.name(),readGroup.getReadGroupId());
  }
  fillInBasesAndQualities(rec,qualityString,defaultQuality);
  return rec;
}",0.925625
30548,"/** 
 * Sadly, this is a duplicate of the method above, except that it takes char[] for referenceBases rather than byte[].  This is because GATK needs it this way. <p/> TODO: Remove this method when GATK map method is changed to take refseq as byte[].
 */
public static int calculateSamNmTag(final SAMRecord read,final char[] referenceBases,final int referenceOffset){
  int samNm=countMismatches(read,referenceBases,referenceOffset);
  for (  final CigarElement el : read.getCigar().getCigarElements()) {
    if (el.getOperator() == CigarOperator.INSERTION || el.getOperator() == CigarOperator.DELETION) {
      samNm+=el.getLength();
    }
  }
  return samNm;
}","/** 
 * Sadly, this is a duplicate of the method above, except that it takes char[] for referenceBases rather than byte[].  This is because GATK needs it this way. <p/> TODO: Remove this method when GATK map method is changed to take refseq as byte[]. TODO: UPDATE: Seems to be removed from GATK. Deprecated now to be removed in a future version.
 */
@Deprecated public static int calculateSamNmTag(final SAMRecord read,final char[] referenceBases,final int referenceOffset){
  int samNm=countMismatches(read,referenceBases,referenceOffset);
  for (  final CigarElement el : read.getCigar().getCigarElements()) {
    if (el.getOperator() == CigarOperator.INSERTION || el.getOperator() == CigarOperator.DELETION) {
      samNm+=el.getLength();
    }
  }
  return samNm;
}",0.92533147243545
30549,"/** 
 * Sadly, this is a duplicate of the method above, except that it takes char[] for referenceBases rather than byte[].  This is because GATK needs it this way. <p/> TODO: Remove this method when GATK map method is changed to take refseq as byte[].
 */
private static int countMismatches(final SAMRecord read,final char[] referenceBases,final int referenceOffset){
  int mismatches=0;
  final byte[] readBases=read.getReadBases();
  for (  final AlignmentBlock block : read.getAlignmentBlocks()) {
    final int readBlockStart=block.getReadStart() - 1;
    final int referenceBlockStart=block.getReferenceStart() - 1 - referenceOffset;
    final int length=block.getLength();
    for (int i=0; i < length; ++i) {
      if (!basesEqual(readBases[readBlockStart + i],StringUtil.charToByte(referenceBases[referenceBlockStart + i]))) {
        ++mismatches;
      }
    }
  }
  return mismatches;
}","/** 
 * Sadly, this is a duplicate of the method above, except that it takes char[] for referenceBases rather than byte[].  This is because GATK needs it this way. <p/> TODO: Remove this method when GATK map method is changed to take refseq as byte[]. TODO: UPDATE: Seems to be removed from GATK. Deprecated now to be removed in a future version.
 */
@Deprecated private static int countMismatches(final SAMRecord read,final char[] referenceBases,final int referenceOffset){
  int mismatches=0;
  final byte[] readBases=read.getReadBases();
  for (  final AlignmentBlock block : read.getAlignmentBlocks()) {
    final int readBlockStart=block.getReadStart() - 1;
    final int referenceBlockStart=block.getReferenceStart() - 1 - referenceOffset;
    final int length=block.getLength();
    for (int i=0; i < length; ++i) {
      if (!basesEqual(readBases[readBlockStart + i],StringUtil.charToByte(referenceBases[referenceBlockStart + i]))) {
        ++mismatches;
      }
    }
  }
  return mismatches;
}",0.9437138348237768
30550,"/** 
 * Sadly, this is a duplicate of the method above, except that it takes char[] for referenceBases rather than byte[].  This is because GATK needs it this way. <p/> TODO: Remove this method when GATK map method is changed to take refseq as byte[].
 */
public static int sumQualitiesOfMismatches(final SAMRecord read,final char[] referenceBases,final int referenceOffset){
  int qualities=0;
  final byte[] readBases=read.getReadBases();
  final byte[] readQualities=read.getBaseQualities();
  if (read.getAlignmentStart() <= referenceOffset) {
    throw new IllegalArgumentException(""String_Node_Str"" + read.getAlignmentStart() + ""String_Node_Str""+ referenceOffset+ ""String_Node_Str"");
  }
  for (  final AlignmentBlock block : read.getAlignmentBlocks()) {
    final int readBlockStart=block.getReadStart() - 1;
    final int referenceBlockStart=block.getReferenceStart() - 1 - referenceOffset;
    final int length=block.getLength();
    for (int i=0; i < length; ++i) {
      if (!basesEqual(readBases[readBlockStart + i],StringUtil.charToByte(referenceBases[referenceBlockStart + i]))) {
        qualities+=readQualities[readBlockStart + i];
      }
    }
  }
  return qualities;
}","/** 
 * Sadly, this is a duplicate of the method above, except that it takes char[] for referenceBases rather than byte[].  This is because GATK needs it this way. <p/> TODO: Remove this method when GATK map method is changed to take refseq as byte[]. TODO: UPDATE: Seems to be removed from GATK. Deprecated now to be removed in a future version.
 */
@Deprecated public static int sumQualitiesOfMismatches(final SAMRecord read,final char[] referenceBases,final int referenceOffset){
  int qualities=0;
  final byte[] readBases=read.getReadBases();
  final byte[] readQualities=read.getBaseQualities();
  if (read.getAlignmentStart() <= referenceOffset) {
    throw new IllegalArgumentException(""String_Node_Str"" + read.getAlignmentStart() + ""String_Node_Str""+ referenceOffset+ ""String_Node_Str"");
  }
  for (  final AlignmentBlock block : read.getAlignmentBlocks()) {
    final int readBlockStart=block.getReadStart() - 1;
    final int referenceBlockStart=block.getReferenceStart() - 1 - referenceOffset;
    final int length=block.getLength();
    for (int i=0; i < length; ++i) {
      if (!basesEqual(readBases[readBlockStart + i],StringUtil.charToByte(referenceBases[referenceBlockStart + i]))) {
        qualities+=readQualities[readBlockStart + i];
      }
    }
  }
  return qualities;
}",0.9569069673781716
30551,"/** 
 * Takes all of the builder data provided up to this point, and instantiates a freshly allocated VariantContext with all of the builder data.  This VariantContext is validated as appropriate and if not failing QC (and throwing an exception) is returned. Note that this function can be called multiple times to create multiple VariantContexts from the same builder.
 */
public VariantContext make(){
  return new VariantContext(source,ID,contig,start,stop,alleles,genotypes,log10PError,filters,attributes,fullyDecoded,toValidate);
}","public VariantContext make(final boolean leaveModifyableAsIs){
  if (!leaveModifyableAsIs)   attributesCanBeModified=false;
  return new VariantContext(source,ID,contig,start,stop,alleles,genotypes,log10PError,filters,attributes,fullyDecoded,toValidate);
}",0.351010101010101
30552,"/** 
 * Return a VCF-like string representation for the alleles of this genotype. If ignoreRefState is true, will not append the reference * marker on the alleles.
 * @return a string representing the genotypes, or null if the type is unavailable.
 */
public String getGenotypeString(boolean ignoreRefState){
  if (getPloidy() == 0)   return ""String_Node_Str"";
  return ParsingUtils.join(isPhased() ? PHASED_ALLELE_SEPARATOR : UNPHASED_ALLELE_SEPARATOR,ignoreRefState ? (Collection)getAlleleStrings() : (isPhased() ? getAlleles() : ParsingUtils.sortList(getAlleles())));
}","/** 
 * Return a VCF-like string representation for the alleles of this genotype. If ignoreRefState is true, will not append the reference * marker on the alleles.
 * @return a string representing the genotypes, or null if the type is unavailable.
 */
public String getGenotypeString(boolean ignoreRefState){
  if (getPloidy() == 0)   return ""String_Node_Str"";
  final String separator=isPhased() ? PHASED_ALLELE_SEPARATOR : UNPHASED_ALLELE_SEPARATOR;
  if (ignoreRefState) {
    return ParsingUtils.join(separator,getAlleleStrings());
  }
  List<Allele> alleles=isPhased() ? getAlleles() : ParsingUtils.sortList(getAlleles());
  return ParsingUtils.join(separator,alleles);
}",0.657051282051282
30553,"/** 
 * Allows construction of a VCFFileReader with a specified index file. 
 */
public VCFFileReader(final File file,final File indexFile,final boolean requireIndex){
  this.reader=AbstractFeatureReader.getFeatureReader(file.getAbsolutePath(),indexFile.getAbsolutePath(),isBCF(file) ? (FeatureCodec)new BCF2Codec() : new VCFCodec(),requireIndex);
}","/** 
 * Allows construction of a VCFFileReader with a specified index file. 
 */
public VCFFileReader(final File file,final File indexFile,final boolean requireIndex){
  FeatureCodec<VariantContext,?> codec=isBCF(file) ? new BCF2Codec() : new VCFCodec();
  this.reader=AbstractFeatureReader.getFeatureReader(file.getAbsolutePath(),indexFile.getAbsolutePath(),codec,requireIndex);
}",0.7917808219178082
30554,"public SAMSequenceRecord getSAMSequenceRecord(){
  final String lengthString=this.getGenericFieldValue(""String_Node_Str"");
  if (lengthString == null)   throw new TribbleException(""String_Node_Str"" + this.getID() + ""String_Node_Str"");
  final SAMSequenceRecord record=new SAMSequenceRecord(this.getID(),Integer.valueOf(lengthString));
  record.setSequenceIndex(this.contigIndex);
  return record;
}","public SAMSequenceRecord getSAMSequenceRecord(){
  final String lengthString=this.getGenericFieldValue(""String_Node_Str"");
  if (lengthString == null)   throw new TribbleException(""String_Node_Str"" + this.getID() + ""String_Node_Str"");
  final SAMSequenceRecord record=new SAMSequenceRecord(this.getID(),Integer.valueOf(lengthString));
  record.setAssembly(this.getGenericFieldValue(""String_Node_Str""));
  record.setSequenceIndex(this.contigIndex);
  return record;
}",0.9212962962962964
30555,"VCFContigHeaderLine(final SAMSequenceRecord sequenceRecord,final String assembly){
  super(VCFHeader.CONTIG_KEY,new HashMap<String,String>(){
{
      this.put(""String_Node_Str"",sequenceRecord.getSequenceName());
      this.put(""String_Node_Str"",Integer.toString(sequenceRecord.getSequenceLength()));
      if (assembly != null)       this.put(""String_Node_Str"",assembly);
    }
  }
);
  this.contigIndex=sequenceRecord.getSequenceIndex();
}","VCFContigHeaderLine(final SAMSequenceRecord sequenceRecord,final String assembly){
  super(VCFHeader.CONTIG_KEY,new LinkedHashMap<String,String>(){
{
      this.put(""String_Node_Str"",sequenceRecord.getSequenceName());
      this.put(""String_Node_Str"",Integer.toString(sequenceRecord.getSequenceLength()));
      if (assembly != null)       this.put(""String_Node_Str"",assembly);
    }
  }
);
  this.contigIndex=sequenceRecord.getSequenceIndex();
}",0.9932279909706546
30556,"/** 
 * Completely replaces the contig records in this header with those in the given SAMSequenceDictionary.
 */
public void setSequenceDictionary(final SAMSequenceDictionary dictionary){
  this.contigMetaData.clear();
  for (  final SAMSequenceRecord record : dictionary.getSequences()) {
    contigMetaData.add(new VCFContigHeaderLine(record,null));
  }
  this.mMetaData.addAll(contigMetaData);
}","/** 
 * Completely replaces the contig records in this header with those in the given SAMSequenceDictionary.
 */
public void setSequenceDictionary(final SAMSequenceDictionary dictionary){
  this.contigMetaData.clear();
  final List<VCFHeaderLine> toRemove=new ArrayList<VCFHeaderLine>();
  for (  final VCFHeaderLine line : mMetaData) {
    if (line instanceof VCFContigHeaderLine) {
      toRemove.add(line);
    }
  }
  mMetaData.removeAll(toRemove);
  for (  final SAMSequenceRecord record : dictionary.getSequences()) {
    contigMetaData.add(new VCFContigHeaderLine(record,record.getAssembly()));
  }
  this.mMetaData.addAll(contigMetaData);
}",0.7533460803059273
30557,"public static Set<VCFHeaderLine> withUpdatedContigsAsLines(final Set<VCFHeaderLine> oldLines,final File referenceFile,final SAMSequenceDictionary refDict,boolean referenceNameOnly){
  final Set<VCFHeaderLine> lines=new LinkedHashSet<VCFHeaderLine>(oldLines.size());
  for (  final VCFHeaderLine line : oldLines) {
    if (line instanceof VCFContigHeaderLine)     continue;
    if (line.getKey().equals(VCFHeader.REFERENCE_KEY))     continue;
    lines.add(line);
  }
  for (  final VCFHeaderLine contigLine : makeContigHeaderLines(refDict,referenceFile))   lines.add(contigLine);
  String referenceValue;
  if (referenceFile != null) {
    if (referenceNameOnly) {
      int extensionStart=referenceFile.getName().lastIndexOf(""String_Node_Str"");
      referenceValue=extensionStart == -1 ? referenceFile.getName() : referenceFile.getName().substring(0,extensionStart);
    }
 else {
      referenceValue=""String_Node_Str"" + referenceFile.getAbsolutePath();
    }
    lines.add(new VCFHeaderLine(VCFHeader.REFERENCE_KEY,referenceValue));
  }
  return lines;
}","public static Set<VCFHeaderLine> withUpdatedContigsAsLines(final Set<VCFHeaderLine> oldLines,final File referenceFile,final SAMSequenceDictionary refDict,final boolean referenceNameOnly){
  final Set<VCFHeaderLine> lines=new LinkedHashSet<VCFHeaderLine>(oldLines.size());
  for (  final VCFHeaderLine line : oldLines) {
    if (line instanceof VCFContigHeaderLine)     continue;
    if (line.getKey().equals(VCFHeader.REFERENCE_KEY))     continue;
    lines.add(line);
  }
  for (  final VCFHeaderLine contigLine : makeContigHeaderLines(refDict,referenceFile))   lines.add(contigLine);
  final String referenceValue;
  if (referenceFile != null) {
    if (referenceNameOnly) {
      final int extensionStart=referenceFile.getName().lastIndexOf(""String_Node_Str"");
      referenceValue=extensionStart == -1 ? referenceFile.getName() : referenceFile.getName().substring(0,extensionStart);
    }
 else {
      referenceValue=""String_Node_Str"" + referenceFile.getAbsolutePath();
    }
    lines.add(new VCFHeaderLine(VCFHeader.REFERENCE_KEY,referenceValue));
  }
  return lines;
}",0.9915651358950328
30558,"public static Set<VCFHeaderLine> smartMergeHeaders(Collection<VCFHeader> headers,boolean emitWarnings) throws IllegalStateException {
  HashMap<String,VCFHeaderLine> map=new HashMap<String,VCFHeaderLine>();
  HeaderConflictWarner conflictWarner=new HeaderConflictWarner(emitWarnings);
  for (  VCFHeader source : headers) {
    for (    VCFHeaderLine line : source.getMetaDataInSortedOrder()) {
      String key=line.getKey();
      if (line instanceof VCFIDHeaderLine)       key=key + ""String_Node_Str"" + ((VCFIDHeaderLine)line).getID();
      if (map.containsKey(key)) {
        VCFHeaderLine other=map.get(key);
        if (line.equals(other)) {
        }
 else         if (!line.getClass().equals(other.getClass())) {
          throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFFilterHeaderLine) {
          String lineName=((VCFFilterHeaderLine)line).getID();
          String otherName=((VCFFilterHeaderLine)other).getID();
          if (!lineName.equals(otherName))           throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFCompoundHeaderLine) {
          VCFCompoundHeaderLine compLine=(VCFCompoundHeaderLine)line;
          VCFCompoundHeaderLine compOther=(VCFCompoundHeaderLine)other;
          if (!(compLine).equalsExcludingDescription(compOther)) {
            if (compLine.getType().equals(compOther.getType())) {
              conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
              compOther.setNumberToUnbounded();
            }
 else             if (compLine.getType() == VCFHeaderLineType.Integer && compOther.getType() == VCFHeaderLineType.Float) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
              map.put(key,compOther);
            }
 else             if (compLine.getType() == VCFHeaderLineType.Float && compOther.getType() == VCFHeaderLineType.Integer) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
            }
 else {
              throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
            }
          }
          if (!compLine.getDescription().equals(compOther.getDescription()))           conflictWarner.warn(line,""String_Node_Str"" + compOther + ""String_Node_Str""+ compLine);
        }
 else {
          conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
      }
 else {
        map.put(key,line);
      }
    }
  }
  return new HashSet<VCFHeaderLine>(map.values());
}","public static Set<VCFHeaderLine> smartMergeHeaders(final Collection<VCFHeader> headers,final boolean emitWarnings) throws IllegalStateException {
  final TreeMap<String,VCFHeaderLine> map=new TreeMap<String,VCFHeaderLine>();
  final HeaderConflictWarner conflictWarner=new HeaderConflictWarner(emitWarnings);
  for (  final VCFHeader source : headers) {
    for (    final VCFHeaderLine line : source.getMetaDataInSortedOrder()) {
      String key=line.getKey();
      if (line instanceof VCFIDHeaderLine)       key=key + ""String_Node_Str"" + ((VCFIDHeaderLine)line).getID();
      if (map.containsKey(key)) {
        final VCFHeaderLine other=map.get(key);
        if (line.equals(other)) {
        }
 else         if (!line.getClass().equals(other.getClass())) {
          throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFFilterHeaderLine) {
          final String lineName=((VCFFilterHeaderLine)line).getID();
          final String otherName=((VCFFilterHeaderLine)other).getID();
          if (!lineName.equals(otherName))           throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFCompoundHeaderLine) {
          final VCFCompoundHeaderLine compLine=(VCFCompoundHeaderLine)line;
          final VCFCompoundHeaderLine compOther=(VCFCompoundHeaderLine)other;
          if (!(compLine).equalsExcludingDescription(compOther)) {
            if (compLine.getType().equals(compOther.getType())) {
              conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
              compOther.setNumberToUnbounded();
            }
 else             if (compLine.getType() == VCFHeaderLineType.Integer && compOther.getType() == VCFHeaderLineType.Float) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
              map.put(key,compOther);
            }
 else             if (compLine.getType() == VCFHeaderLineType.Float && compOther.getType() == VCFHeaderLineType.Integer) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
            }
 else {
              throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
            }
          }
          if (!compLine.getDescription().equals(compOther.getDescription()))           conflictWarner.warn(line,""String_Node_Str"" + compOther + ""String_Node_Str""+ compLine);
        }
 else {
          conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
      }
 else {
        map.put(key,line);
      }
    }
  }
  return new LinkedHashSet<VCFHeaderLine>(map.values());
}",0.9835759611795446
30559,"/** 
 * Create VCFHeaderLines for each refDict entry, and optionally the assembly if referenceFile != null
 * @param refDict reference dictionary
 * @param referenceFile for assembly name.  May be null
 * @return list of vcf contig header lines
 */
public static List<VCFContigHeaderLine> makeContigHeaderLines(final SAMSequenceDictionary refDict,final File referenceFile){
  final List<VCFContigHeaderLine> lines=new ArrayList<VCFContigHeaderLine>();
  final String assembly=referenceFile != null ? getReferenceAssembly(referenceFile.getName()) : null;
  for (  SAMSequenceRecord contig : refDict.getSequences())   lines.add(makeContigHeaderLine(contig,assembly));
  return lines;
}","/** 
 * Create VCFHeaderLines for each refDict entry, and optionally the assembly if referenceFile != null
 * @param refDict reference dictionary
 * @param referenceFile for assembly name.  May be null
 * @return list of vcf contig header lines
 */
public static List<VCFContigHeaderLine> makeContigHeaderLines(final SAMSequenceDictionary refDict,final File referenceFile){
  final List<VCFContigHeaderLine> lines=new ArrayList<VCFContigHeaderLine>();
  final String assembly=referenceFile != null ? getReferenceAssembly(referenceFile.getName()) : null;
  for (  final SAMSequenceRecord contig : refDict.getSequences())   lines.add(makeContigHeaderLine(contig,assembly));
  return lines;
}",0.9956268221574344
30560,"public static Set<VCFHeaderLine> withUpdatedContigsAsLines(final Set<VCFHeaderLine> oldLines,final File referenceFile,final SAMSequenceDictionary refDict,boolean referenceNameOnly){
  final Set<VCFHeaderLine> lines=new LinkedHashSet<VCFHeaderLine>(oldLines.size());
  for (  final VCFHeaderLine line : oldLines) {
    if (line instanceof VCFContigHeaderLine)     continue;
    if (line.getKey().equals(VCFHeader.REFERENCE_KEY))     continue;
    lines.add(line);
  }
  for (  final VCFHeaderLine contigLine : makeContigHeaderLines(refDict,referenceFile))   lines.add(contigLine);
  String referenceValue;
  if (referenceFile != null) {
    if (referenceNameOnly) {
      int extensionStart=referenceFile.getName().lastIndexOf(""String_Node_Str"");
      referenceValue=extensionStart == -1 ? referenceFile.getName() : referenceFile.getName().substring(0,extensionStart);
    }
 else {
      referenceValue=""String_Node_Str"" + referenceFile.getAbsolutePath();
    }
    lines.add(new VCFHeaderLine(VCFHeader.REFERENCE_KEY,referenceValue));
  }
  return lines;
}","public static Set<VCFHeaderLine> withUpdatedContigsAsLines(final Set<VCFHeaderLine> oldLines,final File referenceFile,final SAMSequenceDictionary refDict,final boolean referenceNameOnly){
  final Set<VCFHeaderLine> lines=new LinkedHashSet<VCFHeaderLine>(oldLines.size());
  for (  final VCFHeaderLine line : oldLines) {
    if (line instanceof VCFContigHeaderLine)     continue;
    if (line.getKey().equals(VCFHeader.REFERENCE_KEY))     continue;
    lines.add(line);
  }
  for (  final VCFHeaderLine contigLine : makeContigHeaderLines(refDict,referenceFile))   lines.add(contigLine);
  final String referenceValue;
  if (referenceFile != null) {
    if (referenceNameOnly) {
      final int extensionStart=referenceFile.getName().lastIndexOf(""String_Node_Str"");
      referenceValue=extensionStart == -1 ? referenceFile.getName() : referenceFile.getName().substring(0,extensionStart);
    }
 else {
      referenceValue=""String_Node_Str"" + referenceFile.getAbsolutePath();
    }
    lines.add(new VCFHeaderLine(VCFHeader.REFERENCE_KEY,referenceValue));
  }
  return lines;
}",0.9915651358950328
30561,"public static Set<VCFHeaderLine> smartMergeHeaders(Collection<VCFHeader> headers,boolean emitWarnings) throws IllegalStateException {
  HashMap<String,VCFHeaderLine> map=new HashMap<String,VCFHeaderLine>();
  HeaderConflictWarner conflictWarner=new HeaderConflictWarner(emitWarnings);
  for (  VCFHeader source : headers) {
    for (    VCFHeaderLine line : source.getMetaDataInSortedOrder()) {
      String key=line.getKey();
      if (line instanceof VCFIDHeaderLine)       key=key + ""String_Node_Str"" + ((VCFIDHeaderLine)line).getID();
      if (map.containsKey(key)) {
        VCFHeaderLine other=map.get(key);
        if (line.equals(other)) {
        }
 else         if (!line.getClass().equals(other.getClass())) {
          throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFFilterHeaderLine) {
          String lineName=((VCFFilterHeaderLine)line).getID();
          String otherName=((VCFFilterHeaderLine)other).getID();
          if (!lineName.equals(otherName))           throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFCompoundHeaderLine) {
          VCFCompoundHeaderLine compLine=(VCFCompoundHeaderLine)line;
          VCFCompoundHeaderLine compOther=(VCFCompoundHeaderLine)other;
          if (!(compLine).equalsExcludingDescription(compOther)) {
            if (compLine.getType().equals(compOther.getType())) {
              conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
              compOther.setNumberToUnbounded();
            }
 else             if (compLine.getType() == VCFHeaderLineType.Integer && compOther.getType() == VCFHeaderLineType.Float) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
              map.put(key,compOther);
            }
 else             if (compLine.getType() == VCFHeaderLineType.Float && compOther.getType() == VCFHeaderLineType.Integer) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
            }
 else {
              throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
            }
          }
          if (!compLine.getDescription().equals(compOther.getDescription()))           conflictWarner.warn(line,""String_Node_Str"" + compOther + ""String_Node_Str""+ compLine);
        }
 else {
          conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
      }
 else {
        map.put(key,line);
      }
    }
  }
  return new HashSet<VCFHeaderLine>(map.values());
}","public static Set<VCFHeaderLine> smartMergeHeaders(final Collection<VCFHeader> headers,final boolean emitWarnings) throws IllegalStateException {
  final TreeMap<String,VCFHeaderLine> map=new TreeMap<String,VCFHeaderLine>();
  final HeaderConflictWarner conflictWarner=new HeaderConflictWarner(emitWarnings);
  for (  final VCFHeader source : headers) {
    for (    final VCFHeaderLine line : source.getMetaDataInSortedOrder()) {
      String key=line.getKey();
      if (line instanceof VCFIDHeaderLine)       key=key + ""String_Node_Str"" + ((VCFIDHeaderLine)line).getID();
      if (map.containsKey(key)) {
        final VCFHeaderLine other=map.get(key);
        if (line.equals(other)) {
        }
 else         if (!line.getClass().equals(other.getClass())) {
          throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFFilterHeaderLine) {
          final String lineName=((VCFFilterHeaderLine)line).getID();
          final String otherName=((VCFFilterHeaderLine)other).getID();
          if (!lineName.equals(otherName))           throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
 else         if (line instanceof VCFCompoundHeaderLine) {
          final VCFCompoundHeaderLine compLine=(VCFCompoundHeaderLine)line;
          final VCFCompoundHeaderLine compOther=(VCFCompoundHeaderLine)other;
          if (!(compLine).equalsExcludingDescription(compOther)) {
            if (compLine.getType().equals(compOther.getType())) {
              conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
              compOther.setNumberToUnbounded();
            }
 else             if (compLine.getType() == VCFHeaderLineType.Integer && compOther.getType() == VCFHeaderLineType.Float) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
              map.put(key,compOther);
            }
 else             if (compLine.getType() == VCFHeaderLineType.Float && compOther.getType() == VCFHeaderLineType.Integer) {
              conflictWarner.warn(line,""String_Node_Str"" + compOther);
            }
 else {
              throw new IllegalStateException(""String_Node_Str"" + line + ""String_Node_Str""+ other);
            }
          }
          if (!compLine.getDescription().equals(compOther.getDescription()))           conflictWarner.warn(line,""String_Node_Str"" + compOther + ""String_Node_Str""+ compLine);
        }
 else {
          conflictWarner.warn(line,""String_Node_Str"" + line + ""String_Node_Str""+ other);
        }
      }
 else {
        map.put(key,line);
      }
    }
  }
  return new LinkedHashSet<VCFHeaderLine>(map.values());
}",0.9835759611795446
30562,"/** 
 * Create VCFHeaderLines for each refDict entry, and optionally the assembly if referenceFile != null
 * @param refDict reference dictionary
 * @param referenceFile for assembly name.  May be null
 * @return list of vcf contig header lines
 */
public static List<VCFContigHeaderLine> makeContigHeaderLines(final SAMSequenceDictionary refDict,final File referenceFile){
  final List<VCFContigHeaderLine> lines=new ArrayList<VCFContigHeaderLine>();
  final String assembly=referenceFile != null ? getReferenceAssembly(referenceFile.getName()) : null;
  for (  SAMSequenceRecord contig : refDict.getSequences())   lines.add(makeContigHeaderLine(contig,assembly));
  return lines;
}","/** 
 * Create VCFHeaderLines for each refDict entry, and optionally the assembly if referenceFile != null
 * @param refDict reference dictionary
 * @param referenceFile for assembly name.  May be null
 * @return list of vcf contig header lines
 */
public static List<VCFContigHeaderLine> makeContigHeaderLines(final SAMSequenceDictionary refDict,final File referenceFile){
  final List<VCFContigHeaderLine> lines=new ArrayList<VCFContigHeaderLine>();
  final String assembly=referenceFile != null ? getReferenceAssembly(referenceFile.getName()) : null;
  for (  final SAMSequenceRecord contig : refDict.getSequences())   lines.add(makeContigHeaderLine(contig,assembly));
  return lines;
}",0.9956268221574344
30563,"public boolean equals(MetricBase that){
  for (  Field field : this.getClass().getFields()) {
    try {
      if (!field.get(this).equals(field.get(that))) {
        return false;
      }
    }
 catch (    IllegalAccessException ex) {
      return false;
    }
  }
  return true;
}","public boolean equals(MetricBase that){
  for (  Field field : this.getClass().getFields()) {
    try {
      if (!Objects.equals(field.get(this),field.get(that))) {
        return false;
      }
    }
 catch (    IllegalAccessException ex) {
      return false;
    }
  }
  return true;
}",0.9333333333333332
30564,"@Override public int readInteger(){
  try {
    final int r=in.read(tmpBuf.array(),0,4);
    if (r != 4)     throw new RuntimeIOException(""String_Node_Str"" + r);
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
  return tmpBuf.getInt(0);
}","@Override public int readInteger(){
  readFully(in,tmpBuf.array(),0,4);
  return tmpBuf.getInt(0);
}",0.5
30565,"@Override public long readLong(){
  try {
    final int r=in.read(tmpBuf.array(),0,8);
    if (r != 8)     throw new RuntimeIOException(""String_Node_Str"" + r);
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
  return tmpBuf.getLong(0);
}","@Override public long readLong(){
  readFully(in,tmpBuf.array(),0,8);
  return tmpBuf.getLong(0);
}",0.4972677595628415
30566,"@Override public void readBytes(final byte[] bytes){
  try {
    in.read(bytes);
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
}","@Override public void readBytes(final byte[] bytes){
  readFully(in,bytes,0,bytes.length);
}",0.5476190476190477
30567,"@Override public int readInteger(){
  try {
    final int r=in.read(tmpBuf.array(),0,4);
    if (r != 4)     throw new RuntimeIOException(""String_Node_Str"" + r);
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
  return tmpBuf.getInt(0);
}","@Override public int readInteger(){
  readFully(in,tmpBuf.array(),0,4);
  return tmpBuf.getInt(0);
}",0.5
30568,"@Override public long readLong(){
  try {
    final int r=in.read(tmpBuf.array(),0,8);
    if (r != 8)     throw new RuntimeIOException(""String_Node_Str"" + r);
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
  return tmpBuf.getLong(0);
}","@Override public long readLong(){
  readFully(in,tmpBuf.array(),0,8);
  return tmpBuf.getLong(0);
}",0.4972677595628415
30569,"@Override public void readBytes(final byte[] bytes){
  try {
    in.read(bytes);
  }
 catch (  final IOException e) {
    throw new RuntimeIOException(e);
  }
}","@Override public void readBytes(final byte[] bytes){
  readFully(in,bytes,0,bytes.length);
}",0.5476190476190477
30570,"public boolean equals(MetricBase that){
  for (  Field field : this.getClass().getFields()) {
    try {
      if (!field.get(this).equals(field.get(that))) {
        return false;
      }
    }
 catch (    IllegalAccessException ex) {
      return false;
    }
  }
  return true;
}","public boolean equals(MetricBase that){
  for (  Field field : this.getClass().getFields()) {
    try {
      if (!Objects.equals(field.get(this),field.get(that))) {
        return false;
      }
    }
 catch (    IllegalAccessException ex) {
      return false;
    }
  }
  return true;
}",0.9333333333333332
30571,"/** 
 * @return A single BAMFileSpan that is an intelligent merge of the input spans, i.e. contiguous, overlappingand contained chunks are intelligently merged, and the chunks are sorted.
 */
public static BAMFileSpan merge(final BAMFileSpan[] spans){
  int numInputChunks=0;
  for (  final BAMFileSpan span : spans)   numInputChunks+=span.chunks.size();
  final ArrayList<Chunk> inputChunks=new ArrayList<Chunk>(numInputChunks);
  for (  final BAMFileSpan span : spans)   inputChunks.addAll(span.chunks);
  return new BAMFileSpan(Chunk.optimizeChunkList(inputChunks,0));
}","/** 
 * @return A single BAMFileSpan that is an intelligent merge of the input spans, i.e. contiguous, overlappingand contained chunks are intelligently merged, and the chunks are sorted.
 */
public static BAMFileSpan merge(final BAMFileSpan[] spans){
  final ArrayList<Chunk> inputChunks=new ArrayList<Chunk>();
  for (  final BAMFileSpan span : spans) {
    if (span != null) {
      inputChunks.addAll(span.chunks);
    }
  }
  return new BAMFileSpan(Chunk.optimizeChunkList(inputChunks,0));
}",0.695977549111319
30572,"/** 
 * Updates the time stored by this instance if it's a ""lazy now"" instance and has never been stored. 
 */
private synchronized void conditionallyUpdateTime(){
  if (!doSetTimeNextQuery) {
    super.setTime(System.currentTimeMillis());
    doSetTimeNextQuery=false;
  }
}","/** 
 * Updates the time stored by this instance if it's a ""lazy now"" instance and has never been stored. 
 */
private synchronized void conditionallyUpdateTime(){
  if (doSetTimeNextQuery) {
    super.setTime(System.currentTimeMillis());
    doSetTimeNextQuery=false;
  }
}",0.9981785063752276
30573,"@Test public void testLazyInstance(){
  final RelativeIso8601Date lazy=RelativeIso8601Date.generateLazyNowInstance();
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals((double)lazy.getTime(),(double)System.currentTimeMillis(),2000d);
  new RelativeIso8601Date(lazy.toString());
}","@Test public void testLazyInstance(){
  final RelativeIso8601Date lazy=RelativeIso8601Date.generateLazyNowInstance();
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.getTime(),new Iso8601Date(new Date(System.currentTimeMillis())).getTime(),1000);
  new Iso8601Date(lazy.toString());
}",0.9273858921161826
30574,"@Test public void testNonLazyInstance(){
  final List<RelativeIso8601Date> testDates=Arrays.<RelativeIso8601Date>asList(new RelativeIso8601Date(new Date()),new RelativeIso8601Date(new Iso8601Date(new Date()).toString()));
  for (  final RelativeIso8601Date nonLazy : testDates) {
    Assert.assertFalse(nonLazy.toString().equals(RelativeIso8601Date.LAZY_NOW_LABEL));
    Assert.assertEquals((double)nonLazy.getTime(),(double)System.currentTimeMillis(),1d);
    new RelativeIso8601Date(nonLazy.toString());
  }
}","@Test public void testNonLazyInstance(){
  final long time=new Iso8601Date(new Date(System.currentTimeMillis())).getTime();
  final List<RelativeIso8601Date> testDates=Arrays.<RelativeIso8601Date>asList(new RelativeIso8601Date(new Date(time)),new RelativeIso8601Date(new Iso8601Date(new Date(time)).toString()));
  for (  final RelativeIso8601Date nonLazy : testDates) {
    Assert.assertFalse(nonLazy.toString().equals(RelativeIso8601Date.LAZY_NOW_LABEL));
    Assert.assertEquals((double)nonLazy.getTime(),(double)time);
    new RelativeIso8601Date(nonLazy.toString());
  }
}",0.7977941176470589
30575,"/** 
 * Updates the time stored by this instance if it's a ""lazy now"" instance and has never been stored. 
 */
private synchronized void conditionallyUpdateTime(){
  if (!doSetTimeNextQuery) {
    super.setTime(System.currentTimeMillis());
    doSetTimeNextQuery=false;
  }
}","/** 
 * Updates the time stored by this instance if it's a ""lazy now"" instance and has never been stored. 
 */
private synchronized void conditionallyUpdateTime(){
  if (doSetTimeNextQuery) {
    super.setTime(System.currentTimeMillis());
    doSetTimeNextQuery=false;
  }
}",0.9981785063752276
30576,"@Test public void testLazyInstance(){
  final RelativeIso8601Date lazy=RelativeIso8601Date.generateLazyNowInstance();
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals((double)lazy.getTime(),(double)System.currentTimeMillis(),2000d);
  new RelativeIso8601Date(lazy.toString());
}","@Test public void testLazyInstance(){
  final RelativeIso8601Date lazy=RelativeIso8601Date.generateLazyNowInstance();
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.toString(),RelativeIso8601Date.LAZY_NOW_LABEL);
  Assert.assertEquals(lazy.getTime(),new Iso8601Date(new Date(System.currentTimeMillis())).getTime(),1000);
  new Iso8601Date(lazy.toString());
}",0.9273858921161826
30577,"@Test public void testNonLazyInstance(){
  final List<RelativeIso8601Date> testDates=Arrays.<RelativeIso8601Date>asList(new RelativeIso8601Date(new Date()),new RelativeIso8601Date(new Iso8601Date(new Date()).toString()));
  for (  final RelativeIso8601Date nonLazy : testDates) {
    Assert.assertFalse(nonLazy.toString().equals(RelativeIso8601Date.LAZY_NOW_LABEL));
    Assert.assertEquals((double)nonLazy.getTime(),(double)System.currentTimeMillis(),1d);
    new RelativeIso8601Date(nonLazy.toString());
  }
}","@Test public void testNonLazyInstance(){
  final long time=new Iso8601Date(new Date(System.currentTimeMillis())).getTime();
  final List<RelativeIso8601Date> testDates=Arrays.<RelativeIso8601Date>asList(new RelativeIso8601Date(new Date(time)),new RelativeIso8601Date(new Iso8601Date(new Date(time)).toString()));
  for (  final RelativeIso8601Date nonLazy : testDates) {
    Assert.assertFalse(nonLazy.toString().equals(RelativeIso8601Date.LAZY_NOW_LABEL));
    Assert.assertEquals((double)nonLazy.getTime(),(double)time);
    new RelativeIso8601Date(nonLazy.toString());
  }
}",0.7977941176470589
30578,"/** 
 * Attempts to load a class, taking into account that some classes have ""migrated"" from the broad to sf. 
 */
private Class<?> loadClass(final String className,final boolean tryOtherPackages) throws ClassNotFoundException {
  final String[] packages=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  try {
    return Class.forName(className);
  }
 catch (  ClassNotFoundException cnfe) {
    if (tryOtherPackages) {
      for (      final String p : packages) {
        try {
          return loadClass(p + className.substring(className.lastIndexOf(""String_Node_Str"")),false);
        }
 catch (        ClassNotFoundException cnf2) {
        }
        if (className.indexOf(""String_Node_Str"") > -1) {
          try {
            return loadClass(p + ""String_Node_Str"" + className.substring(className.lastIndexOf(""String_Node_Str"") + 1),false);
          }
 catch (          ClassNotFoundException cnf2) {
          }
        }
      }
    }
    throw cnfe;
  }
}","/** 
 * Attempts to load a class, taking into account that some classes have ""migrated"" from the broad to sf. 
 */
private Class<?> loadClass(final String className,final boolean tryOtherPackages) throws ClassNotFoundException {
  final String[] packages=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  try {
    return Class.forName(className);
  }
 catch (  ClassNotFoundException cnfe) {
    if (tryOtherPackages) {
      for (      final String p : packages) {
        try {
          return loadClass(p + className.substring(className.lastIndexOf(""String_Node_Str"")),false);
        }
 catch (        ClassNotFoundException cnf2) {
        }
        if (className.indexOf(""String_Node_Str"") > -1) {
          try {
            return loadClass(p + ""String_Node_Str"" + className.substring(className.lastIndexOf(""String_Node_Str"") + 1),false);
          }
 catch (          ClassNotFoundException cnf2) {
          }
        }
      }
    }
    throw cnfe;
  }
}",0.9617672047578588
30579,"private String makeOptionDescription(final OptionDefinition optionDefinition){
  final StringBuilder sb=new StringBuilder();
  if (optionDefinition.doc.length() > 0) {
    sb.append(optionDefinition.doc);
    sb.append(""String_Node_Str"");
  }
  if (optionDefinition.optional && !optionDefinition.isCollection) {
    sb.append(""String_Node_Str"");
    sb.append(optionDefinition.defaultValue);
    sb.append(""String_Node_Str"");
    if (!optionDefinition.defaultValue.equals(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
  }
 else   if (!optionDefinition.isCollection) {
    sb.append(""String_Node_Str"");
  }
  Object[] enumConstants=getUnderlyingType(optionDefinition.field).getEnumConstants();
  if (enumConstants == null && getUnderlyingType(optionDefinition.field) == Boolean.class) {
    enumConstants=TRUE_FALSE_VALUES;
  }
  if (enumConstants != null) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < enumConstants.length; ++i) {
      if (i > 0) {
        sb.append(""String_Node_Str"");
      }
      sb.append(enumConstants[i].toString());
    }
    sb.append(""String_Node_Str"");
  }
  if (optionDefinition.isCollection) {
    if (optionDefinition.minElements == 0) {
      if (optionDefinition.maxElements == Integer.MAX_VALUE) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"" + optionDefinition.maxElements + ""String_Node_Str"");
      }
    }
 else     if (optionDefinition.maxElements == Integer.MAX_VALUE) {
      sb.append(""String_Node_Str"" + optionDefinition.minElements + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + optionDefinition.minElements + ""String_Node_Str""+ optionDefinition.maxElements+ ""String_Node_Str"");
    }
    if (!optionDefinition.defaultValue.equals(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
  }
  if (!optionDefinition.mutuallyExclusive.isEmpty()) {
    sb.append(""String_Node_Str"");
    for (    final String option : optionDefinition.mutuallyExclusive) {
      final OptionDefinition mutextOptionDefinition=optionMap.get(option);
      if (mutextOptionDefinition == null) {
        throw new PicardException(""String_Node_Str"" + option + ""String_Node_Str"");
      }
      sb.append(""String_Node_Str"").append(mutextOptionDefinition.name);
      if (mutextOptionDefinition.shortName.length() > 0) {
        sb.append(""String_Node_Str"").append(mutextOptionDefinition.shortName).append(""String_Node_Str"");
      }
    }
  }
  return sb.toString();
}","private String makeOptionDescription(final OptionDefinition optionDefinition){
  final StringBuilder sb=new StringBuilder();
  if (optionDefinition.doc.length() > 0) {
    sb.append(optionDefinition.doc);
    sb.append(""String_Node_Str"");
  }
  if (optionDefinition.optional && !optionDefinition.isCollection) {
    sb.append(""String_Node_Str"");
    sb.append(optionDefinition.defaultValue);
    sb.append(""String_Node_Str"");
    if (!optionDefinition.defaultValue.equals(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
  }
 else   if (!optionDefinition.isCollection) {
    sb.append(""String_Node_Str"");
  }
  Object[] enumConstants=getUnderlyingType(optionDefinition.field).getEnumConstants();
  if (enumConstants == null && getUnderlyingType(optionDefinition.field) == Boolean.class) {
    enumConstants=TRUE_FALSE_VALUES;
  }
  if (enumConstants != null) {
    final Boolean isClpEnum=enumConstants.length > 0 && (enumConstants[0] instanceof ClpEnum);
    sb.append(""String_Node_Str"");
    if (isClpEnum)     sb.append(""String_Node_Str"");
    for (int i=0; i < enumConstants.length; ++i) {
      if (i > 0 && !isClpEnum) {
        sb.append(""String_Node_Str"");
      }
      sb.append(enumConstants[i].toString());
      if (isClpEnum) {
        sb.append(""String_Node_Str"" + ((ClpEnum)enumConstants[i]).getHelpDoc() + ""String_Node_Str"");
      }
    }
    sb.append(""String_Node_Str"");
  }
  if (optionDefinition.isCollection) {
    if (optionDefinition.minElements == 0) {
      if (optionDefinition.maxElements == Integer.MAX_VALUE) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"" + optionDefinition.maxElements + ""String_Node_Str"");
      }
    }
 else     if (optionDefinition.maxElements == Integer.MAX_VALUE) {
      sb.append(""String_Node_Str"" + optionDefinition.minElements + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"" + optionDefinition.minElements + ""String_Node_Str""+ optionDefinition.maxElements+ ""String_Node_Str"");
    }
    if (!optionDefinition.defaultValue.equals(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
  }
  if (!optionDefinition.mutuallyExclusive.isEmpty()) {
    sb.append(""String_Node_Str"");
    for (    final String option : optionDefinition.mutuallyExclusive) {
      final OptionDefinition mutextOptionDefinition=optionMap.get(option);
      if (mutextOptionDefinition == null) {
        throw new PicardException(""String_Node_Str"" + option + ""String_Node_Str"");
      }
      sb.append(""String_Node_Str"").append(mutextOptionDefinition.name);
      if (mutextOptionDefinition.shortName.length() > 0) {
        sb.append(""String_Node_Str"").append(mutextOptionDefinition.shortName).append(""String_Node_Str"");
      }
    }
  }
  return sb.toString();
}",0.9443603330809992
30580,"private OptionDefinition(final Field field,final String name,final String shortName,final String doc,final boolean optional,final boolean collection,final int minElements,final int maxElements,final Object defaultValue,final boolean isCommon,final String[] mutuallyExclusive){
  this.field=field;
  this.name=name.toUpperCase();
  this.shortName=shortName.toUpperCase();
  this.doc=doc;
  this.optional=optional;
  isCollection=collection;
  this.minElements=minElements;
  this.maxElements=maxElements;
  if (defaultValue != null) {
    if (isCollection && ((Collection)defaultValue).isEmpty()) {
      this.defaultValue=""String_Node_Str"";
    }
 else     if (defaultValue.getClass().isEnum()) {
      this.defaultValue=((Enum)defaultValue).name();
    }
 else {
      this.defaultValue=defaultValue.toString();
    }
  }
 else {
    this.defaultValue=""String_Node_Str"";
  }
  this.isCommon=isCommon;
  this.mutuallyExclusive=new HashSet<String>(Arrays.asList(mutuallyExclusive));
}","private OptionDefinition(final Field field,final String name,final String shortName,final String doc,final boolean optional,final boolean collection,final int minElements,final int maxElements,final Object defaultValue,final boolean isCommon,final String[] mutuallyExclusive){
  this.field=field;
  this.name=name.toUpperCase();
  this.shortName=shortName.toUpperCase();
  this.doc=doc;
  this.optional=optional;
  isCollection=collection;
  this.minElements=minElements;
  this.maxElements=maxElements;
  if (defaultValue != null) {
    if (isCollection && ((Collection)defaultValue).isEmpty()) {
      this.defaultValue=""String_Node_Str"";
    }
 else {
      this.defaultValue=defaultValue.toString();
    }
  }
 else {
    this.defaultValue=""String_Node_Str"";
  }
  this.isCommon=isCommon;
  this.mutuallyExclusive=new HashSet<String>(Arrays.asList(mutuallyExclusive));
}",0.9413031771674744
30581,"/** 
 * Run all validations of the mate's CIGAR.  These include validation that the CIGAR makes sense independent of placement, plus validation that CIGAR + placement yields all bases with M operator within the range of the reference.
 * @return List of errors, or null if no errors.
 * @param cigar The cigar containing the alignment information
 * @param referenceIndex The reference index
 * @param alignmentBlocks The alignment blocks (parsed from the cigar)
 * @param recordNumber For error reporting.  -1 if not known.
 * @param cigarTypeName For error reporting.  ""Read CIGAR"" or ""Mate Cigar""
 * @return
 */
private List<SAMValidationError> validateCigar(final Cigar cigar,final Integer referenceIndex,final List<AlignmentBlock> alignmentBlocks,final long recordNumber,final String cigarTypeName){
  List<SAMValidationError> ret=cigar.isValid(getReadName(),recordNumber);
  if (referenceIndex != NO_ALIGNMENT_REFERENCE_INDEX) {
    final SAMSequenceRecord sequence=getHeader().getSequence(getReferenceIndex());
    final int referenceSequenceLength=sequence.getSequenceLength();
    for (    final AlignmentBlock alignmentBlock : alignmentBlocks) {
      if (alignmentBlock.getReferenceStart() + alignmentBlock.getLength() - 1 > referenceSequenceLength) {
        if (ret == null)         ret=new ArrayList<SAMValidationError>();
        ret.add(new SAMValidationError(SAMValidationError.Type.CIGAR_MAPS_OFF_REFERENCE,cigarTypeName + ""String_Node_Str"",getReadName(),recordNumber));
        break;
      }
    }
  }
  return ret;
}","/** 
 * Run all validations of the mate's CIGAR.  These include validation that the CIGAR makes sense independent of placement, plus validation that CIGAR + placement yields all bases with M operator within the range of the reference.
 * @return List of errors, or null if no errors.
 * @param cigar The cigar containing the alignment information
 * @param referenceIndex The reference index
 * @param alignmentBlocks The alignment blocks (parsed from the cigar)
 * @param recordNumber For error reporting.  -1 if not known.
 * @param cigarTypeName For error reporting.  ""Read CIGAR"" or ""Mate Cigar""
 * @return
 */
private List<SAMValidationError> validateCigar(final Cigar cigar,final Integer referenceIndex,final List<AlignmentBlock> alignmentBlocks,final long recordNumber,final String cigarTypeName){
  List<SAMValidationError> ret=cigar.isValid(getReadName(),recordNumber);
  if (referenceIndex != NO_ALIGNMENT_REFERENCE_INDEX) {
    final SAMSequenceRecord sequence=getHeader().getSequence(referenceIndex);
    final int referenceSequenceLength=sequence.getSequenceLength();
    for (    final AlignmentBlock alignmentBlock : alignmentBlocks) {
      if (alignmentBlock.getReferenceStart() + alignmentBlock.getLength() - 1 > referenceSequenceLength) {
        if (ret == null)         ret=new ArrayList<SAMValidationError>();
        ret.add(new SAMValidationError(SAMValidationError.Type.CIGAR_MAPS_OFF_REFERENCE,cigarTypeName + ""String_Node_Str"",getReadName(),recordNumber));
        break;
      }
    }
  }
  return ret;
}",0.9977191267513849
30582,"@Override public void run(){
  try {
    for (; ; ) {
      final String line=bufferedReader.readLine();
      if (line == null) {
        eofReached=true;
        break;
      }
 else {
        try {
          lineQueue.put(line);
        }
 catch (        InterruptedException e) {
          break;
        }
      }
    }
  }
 catch (  Exception e) {
    AsynchronousLineReader.this.workerException=e;
  }
 finally {
    CloserUtil.close(AsynchronousLineReader.this.bufferedReader);
  }
}","@Override public void run(){
  try {
    for (; ; ) {
      final String line=bufferedReader.readLine();
      if (line == null) {
        eofReached=true;
        break;
      }
 else {
        try {
          lineQueue.put(line);
        }
 catch (        final InterruptedException e) {
          break;
        }
      }
    }
  }
 catch (  final Throwable e) {
    AsynchronousLineReader.this.workerException=e;
  }
 finally {
    CloserUtil.close(AsynchronousLineReader.this.bufferedReader);
  }
}",0.7686116700201208
30583,"@Override public String readLine(){
  try {
    for (; ; ) {
      checkAndThrowIfWorkerException();
      final String pollResult=this.lineQueue.poll(100,TimeUnit.MILLISECONDS);
      if (pollResult == null) {
        if (eofReached) {
          checkAndThrowIfWorkerException();
          return lineQueue.poll();
        }
      }
 else {
        return pollResult;
      }
    }
  }
 catch (  InterruptedException e) {
    throw new TribbleException(""String_Node_Str"",e);
  }
}","@Override public String readLine(){
  try {
    for (; ; ) {
      checkAndThrowIfWorkerException();
      final String pollResult=this.lineQueue.poll(100,TimeUnit.MILLISECONDS);
      if (pollResult == null) {
        if (eofReached) {
          checkAndThrowIfWorkerException();
          return lineQueue.poll();
        }
      }
 else {
        return pollResult;
      }
    }
  }
 catch (  final InterruptedException e) {
    throw new TribbleException(""String_Node_Str"",e);
  }
}",0.993801652892562
30584,"private IntervalComparison compareIntervalToRecord(final SAMFileReader.QueryInterval interval,final SAMRecord record){
  final int intervalEnd=(interval.end <= 0 ? Integer.MAX_VALUE : interval.end);
  if (interval.referenceIndex < record.getReferenceIndex())   return IntervalComparison.BEFORE;
 else   if (interval.referenceIndex > record.getReferenceIndex())   return IntervalComparison.AFTER;
 else   if (intervalEnd < record.getAlignmentStart())   return IntervalComparison.BEFORE;
 else   if (record.getAlignmentEnd() < interval.start)   return IntervalComparison.AFTER;
 else   if (CoordMath.encloses(interval.start,intervalEnd,record.getAlignmentStart(),record.getAlignmentEnd())) {
    return IntervalComparison.CONTAINED;
  }
 else   return IntervalComparison.OVERLAPPING;
}","private IntervalComparison compareIntervalToRecord(final SAMFileReader.QueryInterval interval,final SAMRecord record){
  final int intervalEnd=(interval.end <= 0 ? Integer.MAX_VALUE : interval.end);
  final int alignmentEnd;
  if (record.getReadUnmappedFlag() && record.getAlignmentStart() != SAMRecord.NO_ALIGNMENT_START) {
    alignmentEnd=record.getAlignmentStart();
  }
 else {
    alignmentEnd=record.getAlignmentEnd();
  }
  if (interval.referenceIndex < record.getReferenceIndex())   return IntervalComparison.BEFORE;
 else   if (interval.referenceIndex > record.getReferenceIndex())   return IntervalComparison.AFTER;
 else   if (intervalEnd < record.getAlignmentStart())   return IntervalComparison.BEFORE;
 else   if (alignmentEnd < interval.start)   return IntervalComparison.AFTER;
 else   if (CoordMath.encloses(interval.start,intervalEnd,record.getAlignmentStart(),alignmentEnd)) {
    return IntervalComparison.CONTAINED;
  }
 else   return IntervalComparison.OVERLAPPING;
}",0.8295711060948081
30585,"private int countElements(final CloseableIterator<SAMRecord> it){
  int num;
  for (num=0; it.hasNext(); ++num, it.next()) {
  }
  return num;
}","private int countElements(final CloseableIterator<SAMRecord> it){
  int num;
  for (num=0; it.hasNext(); ++num, it.next()) {
  }
  it.close();
  return num;
}",0.9536423841059604
30586,"/** 
 * @return true if there are more aligned reads in the SAM file, LocusInfos in some stage of accumulation,or loci in the target mask that have yet to be covered.
 */
public boolean hasNext(){
  while (complete.isEmpty() && ((!accumulator.isEmpty()) || samHasMore() || hasRemainingMaskBases())) {
    final LocusInfo locusInfo=next();
    if (locusInfo != null) {
      complete.addFirst(locusInfo);
    }
  }
  return !complete.isEmpty();
}","/** 
 * @return true if there are more aligned reads in the SAM file, LocusInfos in some stage of accumulation,or loci in the target mask that have yet to be covered.
 */
public boolean hasNext(){
  if (this.samIterator == null) {
    iterator();
  }
  while (complete.isEmpty() && ((!accumulator.isEmpty()) || samHasMore() || hasRemainingMaskBases())) {
    final LocusInfo locusInfo=next();
    if (locusInfo != null) {
      complete.addFirst(locusInfo);
    }
  }
  return !complete.isEmpty();
}",0.9427966101694916
30587,"public static File getTempDirecory(final String prefix,final String suffix){
  final File tempDirectory;
  try {
    tempDirectory=File.createTempFile(prefix,suffix);
  }
 catch (  IOException e) {
    throw new SAMException(""String_Node_Str"",e);
  }
  if (!tempDirectory.delete())   throw new SAMException(""String_Node_Str"" + tempDirectory);
  if (!tempDirectory.mkdir())   throw new SAMException(""String_Node_Str"" + tempDirectory);
  tempDirectory.deleteOnExit();
  return tempDirectory;
}","/** 
 * @deprecated Use properly spelled method.
 */
public static File getTempDirecory(final String prefix,final String suffix){
  return getTempDirectory(prefix,suffix);
}",0.3403614457831325
30588,"@Test(enabled=true) public void TestWritingLargeVCF() throws FileNotFoundException, InterruptedException {
  Set<VCFHeaderLine> metaData=new HashSet<VCFHeaderLine>();
  final Set<String> Columns=new HashSet<String>();
  for (int i=0; i < 123; i++) {
    Columns.add(String.format(""String_Node_Str"",i));
  }
  final VCFHeader header=createFakeHeader(metaData,Columns);
  final EnumSet<Options> options=EnumSet.of(Options.ALLOW_MISSING_FIELDS_IN_HEADER,Options.INDEX_ON_THE_FLY);
  final File tempDir=TestUtil.getTempDirecory(""String_Node_Str"",""String_Node_Str"");
  tempDir.deleteOnExit();
  final File vcf=new File(tempDir,""String_Node_Str"");
  final File vcfIndex=new File(tempDir,""String_Node_Str"");
  final SAMSequenceDictionary dict=createArtificialSequenceDictionary();
  for (int count=1; count < 2; count++) {
    final VariantContextWriter writer=VariantContextWriterFactory.create(vcf,dict,options);
    writer.writeHeader(header);
    for (int i=1; i < 17; i++) {
      for (int j=1; j < 10; j++) {
        writer.add(createVCGeneral(header,String.format(""String_Node_Str"",i),j * 100));
      }
    }
    writer.close();
    Assert.assertTrue(vcf.lastModified() <= vcfIndex.lastModified());
  }
}","@Test(enabled=true) public void TestWritingLargeVCF() throws FileNotFoundException, InterruptedException {
  Set<VCFHeaderLine> metaData=new HashSet<VCFHeaderLine>();
  final Set<String> Columns=new HashSet<String>();
  for (int i=0; i < 123; i++) {
    Columns.add(String.format(""String_Node_Str"",i));
  }
  final VCFHeader header=createFakeHeader(metaData,Columns);
  final EnumSet<Options> options=EnumSet.of(Options.ALLOW_MISSING_FIELDS_IN_HEADER,Options.INDEX_ON_THE_FLY);
  final File tempDir=TestUtil.getTempDirectory(""String_Node_Str"",""String_Node_Str"");
  tempDir.deleteOnExit();
  final File vcf=new File(tempDir,""String_Node_Str"");
  final File vcfIndex=new File(tempDir,""String_Node_Str"");
  final SAMSequenceDictionary dict=createArtificialSequenceDictionary();
  for (int count=1; count < 2; count++) {
    final VariantContextWriter writer=VariantContextWriterFactory.create(vcf,dict,options);
    writer.writeHeader(header);
    for (int i=1; i < 17; i++) {
      for (int j=1; j < 10; j++) {
        writer.add(createVCGeneral(header,String.format(""String_Node_Str"",i),j * 100));
      }
    }
    writer.close();
    Assert.assertTrue(vcf.lastModified() <= vcfIndex.lastModified());
  }
}",0.9995852343425964
30589,"public String toString(){
  return String.format(""String_Node_Str"",getSource(),contig + ""String_Node_Str"" + (start - stop == 0 ? start : start + ""String_Node_Str"" + stop),hasLog10PError() ? String.format(""String_Node_Str"",getPhredScaledQual()) : ""String_Node_Str"",this.getType(),ParsingUtils.sortList(this.getAlleles()),ParsingUtils.sortedString(this.getAttributes()),this.getGenotypes());
}","public String toString(){
  return genotypes.isLazyWithData() ? toStringUnparsedGenotypes() : toStringDecodeGenotypes();
}",0.2456140350877192
30590,"private final static int[] decodeInts(final String string){
  final int nValues=ParsingUtils.split(string,INT_DECODE_ARRAY,',');
  final int[] values=new int[nValues];
  try {
    for (int i=0; i < nValues; i++)     values[i]=Integer.valueOf(INT_DECODE_ARRAY[i]);
  }
 catch (  final NumberFormatException e) {
    return null;
  }
  return values;
}","private final int[] decodeInts(final String string){
  final int nValues=ParsingUtils.split(string,INT_DECODE_ARRAY,',');
  final int[] values=new int[nValues];
  try {
    for (int i=0; i < nValues; i++)     values[i]=Integer.valueOf(INT_DECODE_ARRAY[i]);
  }
 catch (  final NumberFormatException e) {
    return null;
  }
  return values;
}",0.98989898989899
30591,"public void validateChromosomeCounts(){
  if (!hasGenotypes())   return;
  if (hasAttribute(VCFConstants.ALLELE_NUMBER_KEY)) {
    int reportedAN=Integer.valueOf(getAttribute(VCFConstants.ALLELE_NUMBER_KEY).toString());
    int observedAN=getCalledChrCount();
    if (reportedAN != observedAN)     throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedAN,observedAN));
  }
  if (hasAttribute(VCFConstants.ALLELE_COUNT_KEY)) {
    ArrayList<Integer> observedACs=new ArrayList<Integer>();
    if (getAlternateAlleles().size() > 0) {
      for (      Allele allele : getAlternateAlleles()) {
        observedACs.add(getCalledChrCount(allele));
      }
    }
 else {
      observedACs.add(0);
    }
    if (getAttribute(VCFConstants.ALLELE_COUNT_KEY) instanceof List) {
      Collections.sort(observedACs);
      List reportedACs=(List)getAttribute(VCFConstants.ALLELE_COUNT_KEY);
      Collections.sort(reportedACs);
      if (observedACs.size() != reportedACs.size())       throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedACs.size(),observedACs.size()));
      for (int i=0; i < observedACs.size(); i++) {
        if (Integer.valueOf(reportedACs.get(i).toString()) != observedACs.get(i))         throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedACs.get(i),observedACs.get(i)));
      }
    }
 else {
      if (observedACs.size() != 1)       throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart()));
      int reportedAC=Integer.valueOf(getAttribute(VCFConstants.ALLELE_COUNT_KEY).toString());
      if (reportedAC != observedACs.get(0))       throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedAC,observedACs.get(0)));
    }
  }
}","public void validateChromosomeCounts(){
  if (!hasGenotypes())   return;
  if (hasAttribute(VCFConstants.ALLELE_NUMBER_KEY)) {
    int reportedAN=Integer.valueOf(getAttribute(VCFConstants.ALLELE_NUMBER_KEY).toString());
    int observedAN=getCalledChrCount();
    if (reportedAN != observedAN)     throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedAN,observedAN));
  }
  if (hasAttribute(VCFConstants.ALLELE_COUNT_KEY)) {
    ArrayList<Integer> observedACs=new ArrayList<Integer>();
    if (getAlternateAlleles().size() > 0) {
      for (      Allele allele : getAlternateAlleles()) {
        observedACs.add(getCalledChrCount(allele));
      }
    }
 else {
      observedACs.add(0);
    }
    if (getAttribute(VCFConstants.ALLELE_COUNT_KEY) instanceof List) {
      final List reportedACs=(List)getAttribute(VCFConstants.ALLELE_COUNT_KEY);
      if (observedACs.size() != reportedACs.size())       throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedACs.size(),observedACs.size()));
      for (int i=0; i < observedACs.size(); i++) {
        final int reportedAC=Integer.valueOf(reportedACs.get(i).toString());
        if (reportedAC != observedACs.get(i))         throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedAC,observedACs.get(i)));
      }
    }
 else {
      if (observedACs.size() != 1)       throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart()));
      int reportedAC=Integer.valueOf(getAttribute(VCFConstants.ALLELE_COUNT_KEY).toString());
      if (reportedAC != observedACs.get(0))       throw new TribbleException.InternalCodecException(String.format(""String_Node_Str"",getChr(),getStart(),reportedAC,observedACs.get(0)));
    }
  }
}",0.9643893431812188
30592,"/** 
 * Reads all of the stream into a String, decoding with the provided   {@link Charset} then closes the stream quietly. 
 */
public static String slurp(final InputStream is,final Charset charSet){
  return CollectionUtil.getSoleElement(tokenSlurp(is,charSet,""String_Node_Str""));
}","/** 
 * Reads all of the stream into a String, decoding with the provided   {@link Charset} then closes the stream quietly. 
 */
public static String slurp(final InputStream is,final Charset charSet){
  final List<String> tokenOrEmpty=tokenSlurp(is,charSet,""String_Node_Str"");
  return tokenOrEmpty.isEmpty() ? StringUtil.EMPTY_STRING : CollectionUtil.getSoleElement(tokenOrEmpty);
}",0.7406296851574213
30593,"@Override protected int doWork(){
  IoUtil.assertFileIsReadable(INPUT);
  IoUtil.assertFileIsReadable(SEQUENCE_DICTIONARY);
  IoUtil.assertFileIsWritable(OUTPUT);
  final VCFFileReader reader=new VCFFileReader(INPUT);
  final VCFHeader header=new VCFHeader(reader.getFileHeader());
  final SAMSequenceDictionary sequenceDictionary=SEQUENCE_DICTIONARY != null ? SAMFileReader.getSequenceDictionary(SEQUENCE_DICTIONARY) : header.getSequenceDictionary();
  if (CREATE_INDEX && sequenceDictionary == null) {
    throw new PicardException(""String_Node_Str"");
  }
  final EnumSet<Options> options=CREATE_INDEX ? EnumSet.of(Options.INDEX_ON_THE_FLY) : EnumSet.noneOf(Options.class);
  final VariantContextWriter writer=VariantContextWriterFactory.create(OUTPUT,sequenceDictionary,options);
  writer.writeHeader(header);
  final ProgressLogger progress=new ProgressLogger(Log.getInstance(MakeSitesOnlyVcf.class),10000);
  final CloseableIterator<VariantContext> iterator=reader.iterator();
  while (iterator.hasNext()) {
    final VariantContext context=iterator.next();
    writer.add(context.subContextFromSamples(NO_SAMPLES,false));
    progress.record(context.getChr(),context.getStart());
  }
  CloserUtil.close(iterator);
  CloserUtil.close(reader);
  writer.close();
  return 0;
}","@Override protected int doWork(){
  IoUtil.assertFileIsReadable(INPUT);
  if (SEQUENCE_DICTIONARY != null)   IoUtil.assertFileIsReadable(SEQUENCE_DICTIONARY);
  IoUtil.assertFileIsWritable(OUTPUT);
  final VCFFileReader reader=new VCFFileReader(INPUT);
  final VCFHeader header=new VCFHeader(reader.getFileHeader());
  final SAMSequenceDictionary sequenceDictionary=SEQUENCE_DICTIONARY != null ? SAMFileReader.getSequenceDictionary(SEQUENCE_DICTIONARY) : header.getSequenceDictionary();
  if (CREATE_INDEX && sequenceDictionary == null) {
    throw new PicardException(""String_Node_Str"");
  }
  final EnumSet<Options> options=CREATE_INDEX ? EnumSet.of(Options.INDEX_ON_THE_FLY) : EnumSet.noneOf(Options.class);
  final VariantContextWriter writer=VariantContextWriterFactory.create(OUTPUT,sequenceDictionary,options);
  writer.writeHeader(header);
  final ProgressLogger progress=new ProgressLogger(Log.getInstance(MakeSitesOnlyVcf.class),10000);
  final CloseableIterator<VariantContext> iterator=reader.iterator();
  while (iterator.hasNext()) {
    final VariantContext context=iterator.next();
    writer.add(context.subContextFromSamples(NO_SAMPLES,false));
    progress.record(context.getChr(),context.getStart());
  }
  CloserUtil.close(iterator);
  CloserUtil.close(reader);
  writer.close();
  return 0;
}",0.9865021210952564
30594,"@Override protected int doWork(){
  IoUtil.assertFileIsReadable(INPUT);
  if (SEQUENCE_DICTIONARY != null)   IoUtil.assertFileIsReadable(SEQUENCE_DICTIONARY);
  IoUtil.assertFileIsWritable(OUTPUT);
  final VCFFileReader reader=new VCFFileReader(INPUT);
  final VCFHeader header=new VCFHeader(reader.getFileHeader());
  final SAMSequenceDictionary sequenceDictionary=SEQUENCE_DICTIONARY != null ? SAMFileReader.getSequenceDictionary(SEQUENCE_DICTIONARY) : header.getSequenceDictionary();
  if (CREATE_INDEX && sequenceDictionary == null) {
    throw new PicardException(""String_Node_Str"");
  }
  final EnumSet<Options> options=CREATE_INDEX ? EnumSet.of(Options.INDEX_ON_THE_FLY) : EnumSet.noneOf(Options.class);
  final VariantContextWriter writer=VariantContextWriterFactory.create(OUTPUT,sequenceDictionary,options);
  writer.writeHeader(header);
  final ProgressLogger progress=new ProgressLogger(Log.getInstance(MakeSitesOnlyVcf.class),10000);
  final CloseableIterator<VariantContext> iterator=reader.iterator();
  while (iterator.hasNext()) {
    final VariantContext context=iterator.next();
    writer.add(context.subContextFromSamples(NO_SAMPLES,false));
    progress.record(context.getChr(),context.getStart());
  }
  CloserUtil.close(iterator);
  CloserUtil.close(reader);
  writer.close();
  return 0;
}","@Override protected int doWork(){
  IoUtil.assertFileIsReadable(INPUT);
  if (SEQUENCE_DICTIONARY != null)   IoUtil.assertFileIsReadable(SEQUENCE_DICTIONARY);
  IoUtil.assertFileIsWritable(OUTPUT);
  final VCFFileReader reader=new VCFFileReader(INPUT);
  final VCFHeader header=new VCFHeader(reader.getFileHeader().getMetaDataInInputOrder());
  final SAMSequenceDictionary sequenceDictionary=SEQUENCE_DICTIONARY != null ? SAMFileReader.getSequenceDictionary(SEQUENCE_DICTIONARY) : header.getSequenceDictionary();
  if (CREATE_INDEX && sequenceDictionary == null) {
    throw new PicardException(""String_Node_Str"");
  }
  final EnumSet<Options> options=CREATE_INDEX ? EnumSet.of(Options.INDEX_ON_THE_FLY) : EnumSet.noneOf(Options.class);
  final VariantContextWriter writer=VariantContextWriterFactory.create(OUTPUT,sequenceDictionary,options);
  writer.writeHeader(header);
  final ProgressLogger progress=new ProgressLogger(Log.getInstance(MakeSitesOnlyVcf.class),10000);
  final CloseableIterator<VariantContext> iterator=reader.iterator();
  while (iterator.hasNext()) {
    final VariantContext context=iterator.next();
    writer.add(context.subContextFromSamples(NO_SAMPLES,false));
    progress.record(context.getChr(),context.getStart());
  }
  CloserUtil.close(iterator);
  CloserUtil.close(reader);
  writer.close();
  return 0;
}",0.990203466465712
30595,"public Map.Entry<Interval,T> next(){
  if (!hasNext()) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
  final IntervalTree.Node<T> node=mTreeIterator.next();
  if (!mTreeIterator.hasNext()) {
    advanceSequence();
  }
  final Interval key=new Interval(mSequence,node.getStart(),node.getEnd());
  final T value=node.getValue();
  return new MapEntry(key,value);
}","public Map.Entry<Interval,T> next(){
  if (!hasNext()) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
  final IntervalTree.Node<T> node=mTreeIterator.next();
  final String sequence=mSequence;
  if (!mTreeIterator.hasNext()) {
    advanceSequence();
  }
  final Interval key=new Interval(sequence,node.getStart(),node.getEnd());
  final T value=node.getValue();
  return new MapEntry(key,value);
}",0.952020202020202
30596,"Histogram<Integer> getMeanQualityHistogram(){
  final String label=useOriginalQualities ? ""String_Node_Str"" : ""String_Node_Str"";
  final Histogram<Integer> meanQualities=new Histogram<Integer>(""String_Node_Str"",label);
  int firstReadLength=0;
  for (int cycle=0; cycle < firstReadTotalsByCycle.length; ++cycle) {
    if (firstReadTotalsByCycle[cycle] > 0) {
      meanQualities.increment(cycle,firstReadTotalsByCycle[cycle] / firstReadCountsByCycle[cycle]);
      firstReadLength=cycle;
    }
  }
  for (int i=0; i < secondReadTotalsByCycle.length; ++i) {
    final int cycle=firstReadLength + i;
    if (secondReadCountsByCycle[i] > 0) {
      meanQualities.increment(cycle,secondReadTotalsByCycle[i] / firstReadCountsByCycle[i]);
    }
  }
  return meanQualities;
}","Histogram<Integer> getMeanQualityHistogram(){
  final String label=useOriginalQualities ? ""String_Node_Str"" : ""String_Node_Str"";
  final Histogram<Integer> meanQualities=new Histogram<Integer>(""String_Node_Str"",label);
  int firstReadLength=0;
  for (int cycle=0; cycle < firstReadTotalsByCycle.length; ++cycle) {
    if (firstReadTotalsByCycle[cycle] > 0) {
      meanQualities.increment(cycle,firstReadTotalsByCycle[cycle] / firstReadCountsByCycle[cycle]);
      firstReadLength=cycle;
    }
  }
  for (int i=0; i < secondReadTotalsByCycle.length; ++i) {
    if (secondReadCountsByCycle[i] > 0) {
      final int cycle=firstReadLength + i;
      meanQualities.increment(cycle,secondReadTotalsByCycle[i] / secondReadCountsByCycle[i]);
    }
  }
  return meanQualities;
}",0.9382716049382716
30597,"/** 
 * run method which extracts barcodes and accumulates metrics for an entire tile
 */
synchronized public void run(){
  log.info(""String_Node_Str"" + tile);
  final IlluminaDataProvider provider=factory.makeDataProvider(Arrays.asList(tile));
  final int[] barcodeIndices=outputReadStructure.barcodes.getIndices();
  final BufferedWriter writer=IoUtil.openFileForBufferedWriting(barcodeFile);
  try {
    final byte barcodeSubsequences[][]=new byte[barcodeIndices.length][];
    final byte qualityScores[][]=usingQualityScores ? new byte[barcodeIndices.length][] : null;
    while (provider.hasNext()) {
      final ClusterData cluster=provider.next();
      for (int i=0; i < barcodeIndices.length; i++) {
        barcodeSubsequences[i]=cluster.getRead(barcodeIndices[i]).getBases();
        if (usingQualityScores)         qualityScores[i]=cluster.getRead(barcodeIndices[i]).getQualities();
      }
      final boolean passingFilter=cluster.isPf();
      final BarcodeMatch match=findBestBarcodeAndUpdateMetrics(barcodeSubsequences,qualityScores,passingFilter,metrics,noMatchMetric);
      final String yOrN=(match.matched ? ""String_Node_Str"" : ""String_Node_Str"");
      for (      final byte[] bc : barcodeSubsequences) {
        writer.write(StringUtil.bytesToString(bc));
      }
      writer.write(""String_Node_Str"" + yOrN + ""String_Node_Str""+ match.barcode+ ""String_Node_Str""+ String.valueOf(match.mismatches)+ ""String_Node_Str""+ String.valueOf(match.mismatchesToSecondBest));
      writer.newLine();
    }
    writer.close();
  }
 catch (  Exception e) {
    log.error(e,""String_Node_Str"",this.tile);
    this.exception=e;
  }
}","/** 
 * run method which extracts barcodes and accumulates metrics for an entire tile
 */
synchronized public void run(){
  try {
    log.info(""String_Node_Str"" + tile);
    final IlluminaDataProvider provider=factory.makeDataProvider(Arrays.asList(tile));
    final int[] barcodeIndices=outputReadStructure.barcodes.getIndices();
    final BufferedWriter writer=IoUtil.openFileForBufferedWriting(barcodeFile);
    final byte barcodeSubsequences[][]=new byte[barcodeIndices.length][];
    final byte qualityScores[][]=usingQualityScores ? new byte[barcodeIndices.length][] : null;
    while (provider.hasNext()) {
      final ClusterData cluster=provider.next();
      for (int i=0; i < barcodeIndices.length; i++) {
        barcodeSubsequences[i]=cluster.getRead(barcodeIndices[i]).getBases();
        if (usingQualityScores)         qualityScores[i]=cluster.getRead(barcodeIndices[i]).getQualities();
      }
      final boolean passingFilter=cluster.isPf();
      final BarcodeMatch match=findBestBarcodeAndUpdateMetrics(barcodeSubsequences,qualityScores,passingFilter,metrics,noMatchMetric);
      final String yOrN=(match.matched ? ""String_Node_Str"" : ""String_Node_Str"");
      for (      final byte[] bc : barcodeSubsequences) {
        writer.write(StringUtil.bytesToString(bc));
      }
      writer.write(""String_Node_Str"" + yOrN + ""String_Node_Str""+ match.barcode+ ""String_Node_Str""+ String.valueOf(match.mismatches)+ ""String_Node_Str""+ String.valueOf(match.mismatchesToSecondBest));
      writer.newLine();
    }
    writer.close();
  }
 catch (  Exception e) {
    log.error(e,""String_Node_Str"",this.tile);
    this.exception=e;
  }
}",0.9926918392204628
30598,"@Test public void testNegative(){
  List<SAMValidationError> errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
}","@Test public void testNegative(){
  List<SAMValidationError> errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.ADJACENT_INDEL_IN_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
}",0.986335403726708
30599,"/** 
 * Perform various validations of SAMRecord. Note that this method deliberately returns null rather than Collections.emptyList() if there are no validation errors, because callers tend to assume that if a non-null list is returned, it is modifiable.
 * @return null if valid.  If invalid, returns a list of error messages.
 */
public List<SAMValidationError> isValid(){
  ArrayList<SAMValidationError> ret=null;
  if (!getReadPairedFlag()) {
    if (getProperPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_PROPER_PAIR,""String_Node_Str"",getReadName()));
    }
    if (getMateUnmappedFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_MATE_UNMAPPED,""String_Node_Str"",getReadName()));
    }
    if (getMateNegativeStrandFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_MATE_NEG_STRAND,""String_Node_Str"",getReadName()));
    }
    if (getFirstOfPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_FIRST_OF_PAIR,""String_Node_Str"",getReadName()));
    }
    if (getSecondOfPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_SECOND_OF_PAIR,""String_Node_Str"",getReadName()));
    }
    if (getMateReferenceIndex() != NO_ALIGNMENT_REFERENCE_INDEX) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_MATE_REF_INDEX,""String_Node_Str"",getReadName()));
    }
  }
 else {
    final List<SAMValidationError> errors=isValidReferenceIndexAndPosition(mMateReferenceIndex,mMateReferenceName,getMateAlignmentStart(),true);
    if (errors != null) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.addAll(errors);
    }
    if (!hasMateReferenceName() && !getMateUnmappedFlag()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_MATE_UNMAPPED,""String_Node_Str"",getReadName()));
    }
    if (!getFirstOfPairFlagUnchecked() && !getSecondOfPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.PAIRED_READ_NOT_MARKED_AS_FIRST_OR_SECOND,""String_Node_Str"",getReadName()));
    }
  }
  if (getInferredInsertSize() > MAX_INSERT_SIZE || getInferredInsertSize() < -MAX_INSERT_SIZE) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_INSERT_SIZE,""String_Node_Str"",getReadName()));
  }
  if (getReadUnmappedFlag()) {
    if (getNotPrimaryAlignmentFlag()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_NOT_PRIM_ALIGNMENT,""String_Node_Str"",getReadName()));
    }
    if (getMappingQuality() != 0) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_MAPPING_QUALITY,""String_Node_Str"",getReadName()));
    }
  }
 else {
    if (getMappingQuality() >= 256) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_MAPPING_QUALITY,""String_Node_Str"",getReadName()));
    }
    if (getCigarLength() == 0) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_CIGAR,""String_Node_Str"",getReadName()));
    }
    if (getHeader().getSequenceDictionary().size() == 0) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.MISSING_SEQUENCE_DICTIONARY,""String_Node_Str"",getReadName()));
    }
    if (!hasReferenceName()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_READ_UNMAPPED,""String_Node_Str"",getReadName()));
    }
  }
  final String rgId=(String)getAttribute(SAMTagUtil.getSingleton().RG);
  if (rgId != null && getHeader().getReadGroup(rgId) == null) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.READ_GROUP_NOT_FOUND,""String_Node_Str"" + rgId,getReadName()));
  }
  final List<SAMValidationError> errors=isValidReferenceIndexAndPosition(mReferenceIndex,mReferenceName,getAlignmentStart(),false);
  if (errors != null) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.addAll(errors);
  }
  if (this.getReadLength() == 0 && !this.getNotPrimaryAlignmentFlag()) {
    Object fz=getAttribute(SAMTagUtil.getSingleton().FZ);
    if (fz == null) {
      String cq=(String)getAttribute(SAMTagUtil.getSingleton().CQ);
      String cs=(String)getAttribute(SAMTagUtil.getSingleton().CS);
      if (cq == null || cq.length() == 0 || cs == null || cs.length() == 0) {
        if (ret == null)         ret=new ArrayList<SAMValidationError>();
        ret.add(new SAMValidationError(SAMValidationError.Type.EMPTY_READ,""String_Node_Str"",getReadName()));
      }
 else       if (!getReadUnmappedFlag()) {
        boolean hasIndel=false;
        for (        CigarElement cigarElement : getCigar().getCigarElements()) {
          if (cigarElement.getOperator() == CigarOperator.DELETION || cigarElement.getOperator() == CigarOperator.INSERTION) {
            hasIndel=true;
            break;
          }
        }
        if (!hasIndel) {
          if (ret == null)           ret=new ArrayList<SAMValidationError>();
          ret.add(new SAMValidationError(SAMValidationError.Type.EMPTY_READ,""String_Node_Str"",getReadName()));
        }
      }
    }
  }
  if (this.getReadLength() != getBaseQualities().length && !Arrays.equals(getBaseQualities(),NULL_QUALS)) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.MISMATCH_READ_LENGTH_AND_QUALS_LENGTH,""String_Node_Str"",getReadName()));
  }
  if (this.getAlignmentStart() != NO_ALIGNMENT_START && this.getIndexingBin() != null && this.computeIndexingBin() != this.getIndexingBin()) {
    ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_INDEXING_BIN,""String_Node_Str"",getReadName()));
  }
  if (ret == null || ret.size() == 0) {
    return null;
  }
  return ret;
}","/** 
 * Perform various validations of SAMRecord. Note that this method deliberately returns null rather than Collections.emptyList() if there are no validation errors, because callers tend to assume that if a non-null list is returned, it is modifiable.
 * @return null if valid.  If invalid, returns a list of error messages.
 */
public List<SAMValidationError> isValid(){
  ArrayList<SAMValidationError> ret=null;
  if (!getReadPairedFlag()) {
    if (getProperPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_PROPER_PAIR,""String_Node_Str"",getReadName()));
    }
    if (getMateUnmappedFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_MATE_UNMAPPED,""String_Node_Str"",getReadName()));
    }
    if (getMateNegativeStrandFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_MATE_NEG_STRAND,""String_Node_Str"",getReadName()));
    }
    if (getFirstOfPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_FIRST_OF_PAIR,""String_Node_Str"",getReadName()));
    }
    if (getSecondOfPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_SECOND_OF_PAIR,""String_Node_Str"",getReadName()));
    }
    if (getMateReferenceIndex() != NO_ALIGNMENT_REFERENCE_INDEX) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_MATE_REF_INDEX,""String_Node_Str"",getReadName()));
    }
  }
 else {
    final List<SAMValidationError> errors=isValidReferenceIndexAndPosition(mMateReferenceIndex,mMateReferenceName,getMateAlignmentStart(),true);
    if (errors != null) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.addAll(errors);
    }
    if (!hasMateReferenceName() && !getMateUnmappedFlag()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_MATE_UNMAPPED,""String_Node_Str"",getReadName()));
    }
    if (!getFirstOfPairFlagUnchecked() && !getSecondOfPairFlagUnchecked()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.PAIRED_READ_NOT_MARKED_AS_FIRST_OR_SECOND,""String_Node_Str"",getReadName()));
    }
  }
  if (getInferredInsertSize() > MAX_INSERT_SIZE || getInferredInsertSize() < -MAX_INSERT_SIZE) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_INSERT_SIZE,""String_Node_Str"",getReadName()));
  }
  if (getReadUnmappedFlag()) {
    if (getNotPrimaryAlignmentFlag()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_NOT_PRIM_ALIGNMENT,""String_Node_Str"",getReadName()));
    }
    if (getMappingQuality() != 0) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_MAPPING_QUALITY,""String_Node_Str"",getReadName()));
    }
  }
 else {
    if (getMappingQuality() >= 256) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_MAPPING_QUALITY,""String_Node_Str"",getReadName()));
    }
    if (getCigarLength() == 0) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_CIGAR,""String_Node_Str"",getReadName()));
    }
    if (getHeader().getSequenceDictionary().size() == 0) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.MISSING_SEQUENCE_DICTIONARY,""String_Node_Str"",getReadName()));
    }
    if (!hasReferenceName()) {
      if (ret == null)       ret=new ArrayList<SAMValidationError>();
      ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_FLAG_READ_UNMAPPED,""String_Node_Str"",getReadName()));
    }
  }
  final String rgId=(String)getAttribute(SAMTagUtil.getSingleton().RG);
  if (rgId != null && getHeader().getReadGroup(rgId) == null) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.READ_GROUP_NOT_FOUND,""String_Node_Str"" + rgId,getReadName()));
  }
  final List<SAMValidationError> errors=isValidReferenceIndexAndPosition(mReferenceIndex,mReferenceName,getAlignmentStart(),false);
  if (errors != null) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.addAll(errors);
  }
  if (this.getReadLength() == 0 && !this.getNotPrimaryAlignmentFlag()) {
    Object fz=getAttribute(SAMTagUtil.getSingleton().FZ);
    if (fz == null) {
      String cq=(String)getAttribute(SAMTagUtil.getSingleton().CQ);
      String cs=(String)getAttribute(SAMTagUtil.getSingleton().CS);
      if (cq == null || cq.length() == 0 || cs == null || cs.length() == 0) {
        if (ret == null)         ret=new ArrayList<SAMValidationError>();
        ret.add(new SAMValidationError(SAMValidationError.Type.EMPTY_READ,""String_Node_Str"",getReadName()));
      }
 else       if (!getReadUnmappedFlag()) {
        boolean hasIndel=false;
        for (        CigarElement cigarElement : getCigar().getCigarElements()) {
          if (cigarElement.getOperator() == CigarOperator.DELETION || cigarElement.getOperator() == CigarOperator.INSERTION) {
            hasIndel=true;
            break;
          }
        }
        if (!hasIndel) {
          if (ret == null)           ret=new ArrayList<SAMValidationError>();
          ret.add(new SAMValidationError(SAMValidationError.Type.EMPTY_READ,""String_Node_Str"",getReadName()));
        }
      }
    }
  }
  if (this.getReadLength() != getBaseQualities().length && !Arrays.equals(getBaseQualities(),NULL_QUALS)) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.MISMATCH_READ_LENGTH_AND_QUALS_LENGTH,""String_Node_Str"",getReadName()));
  }
  if (this.getAlignmentStart() != NO_ALIGNMENT_START && this.getIndexingBin() != null && this.computeIndexingBin() != this.getIndexingBin()) {
    if (ret == null)     ret=new ArrayList<SAMValidationError>();
    ret.add(new SAMValidationError(SAMValidationError.Type.INVALID_INDEXING_BIN,""String_Node_Str"",getReadName()));
  }
  if (ret == null || ret.size() == 0) {
    return null;
  }
  return ret;
}",0.9952270754989876
30600,"@Test public void testNegative(){
  List<SAMValidationError> errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.ADJACENT_INDEL_IN_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
}","@Test public void testNegative(){
  List<SAMValidationError> errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.ADJACENT_INDEL_IN_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.ADJACENT_INDEL_IN_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
  errors=codec.decode(""String_Node_Str"").isValid(null,-1);
  Assert.assertEquals(errors.size(),1);
  Assert.assertEquals(errors.get(0).getType(),SAMValidationError.Type.INVALID_CIGAR);
}",0.9865030674846624
30601,"/** 
 * It is required that sequenceIndex is >= any previous sequenceIndex passed to this class.
 * @return the next pos on the given sequence >= position that is set, or -1 if there are no more set positions
 */
public int nextPosition(final int sequenceIndex,final int position){
  ensureSequenceLoaded(sequenceIndex);
  return currentBitSet.nextSetBit(position);
}","/** 
 * It is required that sequenceIndex is >= any previous sequenceIndex passed to this class.
 * @return the next pos on the given sequence >= position that is set, or -1 if there are no more set positions
 */
public int nextPosition(final int sequenceIndex,final int position){
  ensureSequenceLoaded(sequenceIndex);
  return currentBitSet.nextSetBit(position + 1);
}",0.994579945799458
30602,"/** 
 * Create the next relevant zero-coverage LocusInfo
 * @param stopBeforeLocus don't go up to this sequence and position
 * @return a zero-coverage LocusInfo, or null if there is none before the stopBefore locus
 */
private LocusInfo createNextUncoveredLocusInfo(final Locus stopBeforeLocus){
  while (lastReferenceSequence <= stopBeforeLocus.getSequenceIndex() && lastReferenceSequence <= referenceSequenceMask.getMaxSequenceIndex()) {
    if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex() && lastPosition + 1 >= stopBeforeLocus.getPosition()) {
      return null;
    }
    final int nextbit=referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition + 1);
    if (nextbit == -1) {
      if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex()) {
        lastPosition=stopBeforeLocus.getPosition();
        return null;
      }
      lastReferenceSequence++;
      lastPosition=0;
    }
 else     if (lastReferenceSequence < stopBeforeLocus.getSequenceIndex() || nextbit < stopBeforeLocus.getPosition()) {
      lastPosition=nextbit;
      return new LocusInfo(getReferenceSequence(lastReferenceSequence),lastPosition);
    }
 else     if (nextbit >= stopBeforeLocus.getPosition()) {
      return null;
    }
  }
  return null;
}","/** 
 * Create the next relevant zero-coverage LocusInfo
 * @param stopBeforeLocus don't go up to this sequence and position
 * @return a zero-coverage LocusInfo, or null if there is none before the stopBefore locus
 */
private LocusInfo createNextUncoveredLocusInfo(final Locus stopBeforeLocus){
  while (lastReferenceSequence <= stopBeforeLocus.getSequenceIndex() && lastReferenceSequence <= referenceSequenceMask.getMaxSequenceIndex()) {
    if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex() && lastPosition + 1 >= stopBeforeLocus.getPosition()) {
      return null;
    }
    final int nextbit=referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition);
    if (nextbit == -1) {
      if (lastReferenceSequence == stopBeforeLocus.getSequenceIndex()) {
        lastPosition=stopBeforeLocus.getPosition();
        return null;
      }
      lastReferenceSequence++;
      lastPosition=0;
    }
 else     if (lastReferenceSequence < stopBeforeLocus.getSequenceIndex() || nextbit < stopBeforeLocus.getPosition()) {
      lastPosition=nextbit;
      return new LocusInfo(getReferenceSequence(lastReferenceSequence),lastPosition);
    }
 else     if (nextbit >= stopBeforeLocus.getPosition()) {
      return null;
    }
  }
  return null;
}",0.9984202211690364
30603,"/** 
 * @return true if there are loci in the target mask that have yet to be covered by LocusInfos
 */
private boolean hasRemainingMaskBases(){
  if (!emitUncoveredLoci) {
    return false;
  }
  return (lastReferenceSequence < referenceSequenceMask.getMaxSequenceIndex() || (lastReferenceSequence == referenceSequenceMask.getMaxSequenceIndex() && lastPosition <= referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition + 1)));
}","/** 
 * @return true if there are loci in the target mask that have yet to be covered by LocusInfos
 */
private boolean hasRemainingMaskBases(){
  if (!emitUncoveredLoci) {
    return false;
  }
  return (lastReferenceSequence < referenceSequenceMask.getMaxSequenceIndex() || (lastReferenceSequence == referenceSequenceMask.getMaxSequenceIndex() && lastPosition < referenceSequenceMask.nextPosition(lastReferenceSequence,lastPosition)));
}",0.9943374858437146
30604,"@Test(groups={""String_Node_Str""}) public void testEmitUncoveredLoci(){
  final String sqHeader=""String_Node_Str"";
  final String seq1=""String_Node_Str"";
  final String qual1=""String_Node_Str"";
  final String s1=""String_Node_Str"" + seq1 + ""String_Node_Str""+ qual1+ ""String_Node_Str"";
  final String exampleSam=sqHeader + s1 + s1;
  final SAMFileReader samReader=createSamFileReader(exampleSam);
  final SamLocusIterator sli=new SamLocusIterator(samReader);
  int pos=1;
  final int coveredStart=165;
  final int coveredEnd=CoordMath.getEnd(coveredStart,seq1.length());
  for (  final SamLocusIterator.LocusInfo li : sli) {
    Assert.assertEquals(li.getPosition(),pos++);
    final int expectedReads;
    if (li.getPosition() >= coveredStart && li.getPosition() <= coveredEnd) {
      expectedReads=2;
    }
 else {
      expectedReads=0;
    }
    Assert.assertEquals(li.getRecordAndPositions().size(),expectedReads);
  }
  Assert.assertEquals(pos,100001);
}","@Test public void testEmitUncoveredLoci(){
  final String sqHeader=""String_Node_Str"";
  final String seq1=""String_Node_Str"";
  final String qual1=""String_Node_Str"";
  final String s1=""String_Node_Str"" + seq1 + ""String_Node_Str""+ qual1+ ""String_Node_Str"";
  final String exampleSam=sqHeader + s1 + s1;
  final SAMFileReader samReader=createSamFileReader(exampleSam);
  final SamLocusIterator sli=new SamLocusIterator(samReader);
  int pos=1;
  final int coveredStart=165;
  final int coveredEnd=CoordMath.getEnd(coveredStart,seq1.length());
  for (  final SamLocusIterator.LocusInfo li : sli) {
    Assert.assertEquals(li.getPosition(),pos++);
    final int expectedReads;
    if (li.getPosition() >= coveredStart && li.getPosition() <= coveredEnd) {
      expectedReads=2;
    }
 else {
      expectedReads=0;
    }
    Assert.assertEquals(li.getRecordAndPositions().size(),expectedReads);
  }
  Assert.assertEquals(pos,100001);
}",0.9851694915254238
30605,"/** 
 * Read a null terminated byte array and return result as a string
 * @return
 * @throws IOException
 */
public String readString() throws IOException {
  ByteArrayOutputStream bis=new ByteArrayOutputStream(100);
  byte b;
  while ((b=(byte)in.read()) != 0) {
    bis.write(b);
  }
  return new String(bis.toByteArray());
}","/** 
 * Read a null terminated byte array and return result as a string
 * @return
 * @throws IOException
 */
public String readString() throws IOException {
  ByteArrayOutputStream bis=new ByteArrayOutputStream(100);
  byte b;
  while ((b=(byte)in.read()) != 0) {
    if (b < 0) {
      throw new EOFException();
    }
    bis.write(b);
  }
  return new String(bis.toByteArray());
}",0.9226441631504922
30606,"@Test() public void testReadingBeyondIntSizedBlock() throws IOException {
  final Block block=new Block(0,((long)Integer.MAX_VALUE) * 2);
  final SeekableFileStream stream=new SeekableFileStream(new File(""String_Node_Str""));
  final TribbleIndexedFeatureReader.BlockStreamWrapper blockStreamWrapper=new TribbleIndexedFeatureReader.BlockStreamWrapper(stream,block);
  final int chunkSize=100000;
  final int chunksToRead=(int)Math.ceil(block.getSize() / (chunkSize * 1.0));
  final byte[] bytes=new byte[chunkSize];
  long totalRead=0;
  for (int chunk=0; chunk < chunksToRead; chunk++) {
    final int nRead=blockStreamWrapper.read(bytes);
    Assert.assertTrue(nRead != -1,""String_Node_Str"" + totalRead + ""String_Node_Str"");
    totalRead+=nRead;
  }
  Assert.assertEquals(totalRead,block.getSize(),""String_Node_Str"" + block.getSize());
}","@Test(groups=""String_Node_Str"") public void testReadingBeyondIntSizedBlock() throws IOException {
  final Block block=new Block(0,((long)Integer.MAX_VALUE) * 2);
  final SeekableFileStream stream=new SeekableFileStream(new File(""String_Node_Str""));
  final TribbleIndexedFeatureReader.BlockStreamWrapper blockStreamWrapper=new TribbleIndexedFeatureReader.BlockStreamWrapper(stream,block);
  final int chunkSize=100000;
  final int chunksToRead=(int)Math.ceil(block.getSize() / (chunkSize * 1.0));
  final byte[] bytes=new byte[chunkSize];
  long totalRead=0;
  for (int chunk=0; chunk < chunksToRead; chunk++) {
    final int nRead=blockStreamWrapper.read(bytes);
    Assert.assertTrue(nRead != -1,""String_Node_Str"" + totalRead + ""String_Node_Str"");
    totalRead+=nRead;
  }
  Assert.assertEquals(totalRead,block.getSize(),""String_Node_Str"" + block.getSize());
}",0.9858989424206815
30607,"/** 
 * Method to scatter an interval list by locus.
 * @param list  The list of intervals to scatter
 * @return the number of intervals across the scattered lists (which may differ from the inputas some may have been split)
 */
private int scatterIntervals(final IntervalList list){
  final long idealSplitLength=Math.max((long)Math.floor(list.getUniqueBaseCount() / (1.0 * SCATTER_COUNT)),1);
  int splitLength=0;
  IntervalList split=new IntervalList(list.getHeader());
  int index=1;
  final Iterator<Interval> it=list.iterator();
  int totalIntervals=0;
  while (it.hasNext() && index < SCATTER_COUNT) {
    final Interval interval=it.next();
    final int projectedSize=splitLength + interval.length();
    if (projectedSize < idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      splitLength+=interval.length();
    }
 else     if (projectedSize == idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      split.write(createDirectoryAndGetScatterFile(index++));
      split=new IntervalList(list.getHeader());
      splitLength=0;
    }
 else {
      final int diff=(int)(idealSplitLength - splitLength);
      final Interval firstHalf=new Interval(interval.getSequence(),interval.getStart(),interval.getStart() + diff - 1,interval.isNegativeStrand(),interval.getName());
      split.add(firstHalf);
      totalIntervals++;
      split.write(createDirectoryAndGetScatterFile(index++));
      split=new IntervalList(list.getHeader());
      final Interval secondHalf=new Interval(interval.getSequence(),interval.getStart() + diff,interval.getEnd(),interval.isNegativeStrand(),interval.getName());
      split.add(secondHalf);
      totalIntervals++;
      splitLength=secondHalf.length();
    }
  }
  while (it.hasNext()) {
    split.add(it.next());
    totalIntervals++;
  }
  split.write(createDirectoryAndGetScatterFile(index));
  return totalIntervals;
}","/** 
 * Method to scatter an interval list by locus.
 * @param list  The list of intervals to scatter
 * @return the number of intervals across the scattered lists (which may differ from the inputas some may have been split)
 */
private int scatterIntervals(final IntervalList list){
  final long idealSplitLength=Math.max((long)Math.floor(list.getUniqueBaseCount() / (1.0 * SCATTER_COUNT)),1);
  int splitLength=0;
  IntervalList split=new IntervalList(list.getHeader());
  int index=1;
  final Iterator<Interval> it=list.iterator();
  int totalIntervals=0;
  while (it.hasNext() && index < SCATTER_COUNT) {
    final Interval interval=it.next();
    int projectedSize=splitLength + interval.length();
    if (projectedSize < idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      splitLength+=interval.length();
    }
 else     if (projectedSize == idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      split.write(createDirectoryAndGetScatterFile(index++));
      split=new IntervalList(list.getHeader());
      splitLength=0;
    }
 else {
      int consumed=0;
      while (projectedSize > idealSplitLength) {
        final int amountToConsume=(int)(idealSplitLength - splitLength);
        final Interval partial=new Interval(interval.getSequence(),interval.getStart() + consumed,interval.getStart() + consumed + amountToConsume - 1,interval.isNegativeStrand(),interval.getName());
        split.add(partial);
        totalIntervals++;
        split.write(createDirectoryAndGetScatterFile(index++));
        split=new IntervalList(list.getHeader());
        consumed+=amountToConsume;
        splitLength=0;
        projectedSize=interval.length() - consumed;
      }
      if (projectedSize > 0) {
        final Interval remainder=new Interval(interval.getSequence(),interval.getStart() + consumed,interval.getEnd(),interval.isNegativeStrand(),interval.getName());
        split.add(remainder);
        totalIntervals++;
        splitLength=remainder.length();
      }
    }
  }
  while (it.hasNext()) {
    split.add(it.next());
    totalIntervals++;
  }
  split.write(createDirectoryAndGetScatterFile(index));
  return totalIntervals;
}",0.8586770807908225
30608,"@Test public void testScatter() throws IOException {
  final File scatterDir=IoUtil.createTempDir(""String_Node_Str"",""String_Node_Str"");
  try {
    final File listToScatter=new File(TEST_DATA_DIR,""String_Node_Str"");
    final IntervalList gold=IntervalList.fromFile(listToScatter);
    Assert.assertEquals(gold.getUniqueBaseCount(),200,""String_Node_Str"");
    final File singleFileOutput=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    singleFileOutput.deleteOnExit();
    int result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + singleFileOutput.getAbsolutePath(),""String_Node_Str"" + 1});
    Assert.assertEquals(result,0);
    final IntervalList single=IntervalList.fromFile(singleFileOutput);
    Assert.assertEquals(gold.size(),single.size());
    Assert.assertEquals(gold.getUniqueBaseCount(),single.getUniqueBaseCount());
    result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + scatterDir.getAbsolutePath(),""String_Node_Str"" + 2});
    Assert.assertEquals(result,0);
    Assert.assertEquals(scatterDir.listFiles(new FilenameFilter(){
      public boolean accept(      File file,      String s){
        return s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str"");
      }
    }
).length,2,""String_Node_Str"");
    IntervalList lists[]=getIntervalLists(scatterDir,2);
    Assert.assertEquals(lists[0].size(),2);
    Assert.assertEquals(lists[0].getIntervals().get(1).length(),1,""String_Node_Str"");
    Assert.assertEquals(lists[0].getUniqueBaseCount(),100,""String_Node_Str"");
    final IntervalList second=IntervalList.fromFile(IntervalListTools.getScatteredFileName(scatterDir,2,1));
    Assert.assertEquals(lists[1].getUniqueBaseCount(),100,""String_Node_Str"");
    result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + scatterDir.getAbsolutePath(),""String_Node_Str"" + 4});
    Assert.assertEquals(result,0);
    Assert.assertEquals(scatterDir.listFiles(new FilenameFilter(){
      public boolean accept(      File file,      String s){
        return s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str"");
      }
    }
).length,4,""String_Node_Str"");
    lists=getIntervalLists(scatterDir,4);
    Assert.assertEquals(lists[0].size(),1);
    Assert.assertEquals(lists[1].size(),2);
    Assert.assertEquals(lists[2].size(),2);
    Assert.assertEquals(lists[3].size(),1);
    Assert.assertEquals(lists[3].getIntervals().get(0).getStart(),30200);
    Assert.assertEquals(lists[0].getUniqueBaseCount() + lists[1].getUniqueBaseCount() + lists[2].getUniqueBaseCount()+ lists[3].getUniqueBaseCount(),200);
  }
  finally {
    TestUtil.recursiveDelete(scatterDir);
  }
}","@Test public void testScatter() throws IOException {
  final File scatterDir=IoUtil.createTempDir(""String_Node_Str"",""String_Node_Str"");
  try {
    final File listToScatter=new File(TEST_DATA_DIR,""String_Node_Str"");
    final IntervalList gold=IntervalList.fromFile(listToScatter);
    Assert.assertEquals(gold.getUniqueBaseCount(),200,""String_Node_Str"");
    final File singleFileOutput=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    singleFileOutput.deleteOnExit();
    int result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + singleFileOutput.getAbsolutePath(),""String_Node_Str"" + 1});
    Assert.assertEquals(result,0);
    final IntervalList single=IntervalList.fromFile(singleFileOutput);
    Assert.assertEquals(gold.size(),single.size());
    Assert.assertEquals(gold.getUniqueBaseCount(),single.getUniqueBaseCount());
    result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + scatterDir.getAbsolutePath(),""String_Node_Str"" + 2});
    Assert.assertEquals(result,0);
    Assert.assertEquals(scatterDir.listFiles(new FilenameFilter(){
      public boolean accept(      File file,      String s){
        return s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str"");
      }
    }
).length,2,""String_Node_Str"");
    IntervalList lists[]=getIntervalLists(scatterDir,2);
    Assert.assertEquals(lists[0].size(),2);
    Assert.assertEquals(lists[0].getIntervals().get(1).length(),1,""String_Node_Str"");
    Assert.assertEquals(lists[0].getUniqueBaseCount(),100,""String_Node_Str"");
    final IntervalList second=IntervalList.fromFile(IntervalListTools.getScatteredFileName(scatterDir,2,1));
    Assert.assertEquals(lists[1].getUniqueBaseCount(),100,""String_Node_Str"");
    result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + scatterDir.getAbsolutePath(),""String_Node_Str"" + 4});
    Assert.assertEquals(result,0);
    Assert.assertEquals(scatterDir.listFiles(new FilenameFilter(){
      public boolean accept(      File file,      String s){
        return s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str"");
      }
    }
).length,4,""String_Node_Str"");
    lists=getIntervalLists(scatterDir,4);
    Assert.assertEquals(lists[0].size(),1);
    Assert.assertEquals(lists[1].size(),2);
    Assert.assertEquals(lists[2].size(),2);
    Assert.assertEquals(lists[3].size(),1);
    Assert.assertEquals(lists[3].getIntervals().get(0).getStart(),30200);
    Assert.assertEquals(lists[0].getUniqueBaseCount() + lists[1].getUniqueBaseCount() + lists[2].getUniqueBaseCount()+ lists[3].getUniqueBaseCount(),200);
    result=new IntervalListTools().instanceMain(new String[]{""String_Node_Str"" + listToScatter.getAbsolutePath(),""String_Node_Str"" + scatterDir.getAbsolutePath(),""String_Node_Str"" + 5});
    Assert.assertEquals(result,0);
    lists=getIntervalLists(scatterDir,5);
    Assert.assertEquals(lists[0].size(),1);
    Assert.assertEquals(lists[1].size(),1);
    Assert.assertEquals(lists[2].size(),2);
    Assert.assertEquals(lists[3].size(),2);
    Assert.assertEquals(lists[4].size(),1);
    Assert.assertEquals(lists[0].getUniqueBaseCount() + lists[1].getUniqueBaseCount() + lists[2].getUniqueBaseCount()+ lists[3].getUniqueBaseCount()+ lists[4].getUniqueBaseCount(),200);
  }
  finally {
    TestUtil.recursiveDelete(scatterDir);
  }
}",0.8942216608778023
30609,"/** 
 * Method to scatter an interval list by locus.
 * @param list  The list of intervals to scatter
 * @return the number of intervals across the scattered lists (which may differ from the inputas some may have been split)
 */
private int scatterIntervals(final IntervalList list){
  final long idealSplitLength=Math.max((long)Math.floor(list.getUniqueBaseCount() / (1.0 * SCATTER_COUNT)),1);
  int splitLength=0;
  IntervalList split=new IntervalList(list.getHeader());
  int index=1;
  final Iterator<Interval> it=list.iterator();
  int totalIntervals=0;
  final DecimalFormat format=new DecimalFormat(""String_Node_Str"");
  while (it.hasNext() && index < SCATTER_COUNT) {
    final Interval interval=it.next();
    int projectedSize=splitLength + interval.length();
    if (projectedSize < idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      splitLength+=interval.length();
    }
 else     if (projectedSize == idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      split.write(createDirectoryAndGetScatterFile(format.format(index++)));
      split=new IntervalList(list.getHeader());
      splitLength=0;
    }
 else {
      int consumed=0;
      while (projectedSize > idealSplitLength) {
        final int amountToConsume=(int)(idealSplitLength - splitLength);
        final Interval partial=new Interval(interval.getSequence(),interval.getStart() + consumed,interval.getStart() + consumed + amountToConsume - 1,interval.isNegativeStrand(),interval.getName());
        split.add(partial);
        totalIntervals++;
        split.write(createDirectoryAndGetScatterFile(format.format(index++)));
        split=new IntervalList(list.getHeader());
        consumed+=amountToConsume;
        splitLength=0;
        projectedSize=interval.length() - consumed;
      }
      if (projectedSize > 0) {
        final Interval remainder=new Interval(interval.getSequence(),interval.getStart() + consumed,interval.getEnd(),interval.isNegativeStrand(),interval.getName());
        split.add(remainder);
        totalIntervals++;
        splitLength=remainder.length();
      }
    }
  }
  while (it.hasNext()) {
    split.add(it.next());
    totalIntervals++;
  }
  split.write(createDirectoryAndGetScatterFile(format.format(index)));
  return totalIntervals;
}","/** 
 * Method to scatter an interval list by locus.
 * @param list  The list of intervals to scatter
 * @return the number of intervals across the scattered lists (which may differ from the inputas some may have been split)
 */
private int scatterIntervals(final IntervalList list){
  final long idealSplitLength=Math.max((long)Math.floor(list.getUniqueBaseCount() / (1.0 * SCATTER_COUNT)),1);
  int splitLength=0;
  IntervalList split=new IntervalList(list.getHeader());
  int index=1;
  final Iterator<Interval> it=list.iterator();
  int totalIntervals=0;
  final DecimalFormat format=new DecimalFormat(""String_Node_Str"");
  while (it.hasNext() && index < SCATTER_COUNT) {
    final Interval interval=it.next();
    int projectedSize=splitLength + interval.length();
    if (projectedSize < idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      splitLength+=interval.length();
    }
 else     if (projectedSize == idealSplitLength) {
      split.add(interval);
      totalIntervals++;
      split.write(createDirectoryAndGetScatterFile(format.format(index++)));
      split=new IntervalList(list.getHeader());
      splitLength=0;
    }
 else {
      int consumed=0;
      while (projectedSize > idealSplitLength && index < SCATTER_COUNT) {
        final int amountToConsume=(int)(idealSplitLength - splitLength);
        final Interval partial=new Interval(interval.getSequence(),interval.getStart() + consumed,interval.getStart() + consumed + amountToConsume - 1,interval.isNegativeStrand(),interval.getName());
        split.add(partial);
        totalIntervals++;
        split.write(createDirectoryAndGetScatterFile(format.format(index++)));
        split=new IntervalList(list.getHeader());
        consumed+=amountToConsume;
        splitLength=0;
        projectedSize=interval.length() - consumed;
      }
      if (projectedSize > 0) {
        final Interval remainder=new Interval(interval.getSequence(),interval.getStart() + consumed,interval.getEnd(),interval.isNegativeStrand(),interval.getName());
        split.add(remainder);
        totalIntervals++;
        splitLength=remainder.length();
      }
    }
  }
  while (it.hasNext()) {
    split.add(it.next());
    totalIntervals++;
  }
  split.write(createDirectoryAndGetScatterFile(format.format(index)));
  return totalIntervals;
}",0.994599265500108
30610,"private void initializeBAMWriter(final BAMFileWriter writer,final SAMFileHeader header,final boolean presorted,final boolean createIndex){
  writer.setSortOrder(header.getSortOrder(),presorted);
  writer.setHeader(header);
  if (createIndex && writer.getSortOrder().equals(SAMFileHeader.SortOrder.coordinate)) {
    writer.enableBamIndexConstruction();
  }
  if (maxRecordsInRam != null) {
    writer.setMaxRecordsInRam(maxRecordsInRam);
  }
}","private void initializeBAMWriter(final BAMFileWriter writer,final SAMFileHeader header,final boolean presorted,final boolean createIndex){
  writer.setSortOrder(header.getSortOrder(),presorted);
  if (maxRecordsInRam != null) {
    writer.setMaxRecordsInRam(maxRecordsInRam);
  }
  writer.setHeader(header);
  if (createIndex && writer.getSortOrder().equals(SAMFileHeader.SortOrder.coordinate)) {
    writer.enableBamIndexConstruction();
  }
}",0.8081264108352144
30611,"/** 
 * Returns the mapping of barcodes to records associated with them.
 */
public Map<String,SortingCollection<SAMRecord>> getBarcodeRecords(){
  return barcodeToRecordCollection;
}","/** 
 * Returns the mapping of barcodes to records associated with them.
 */
public synchronized Map<String,SortingCollection<SAMRecord>> getBarcodeRecords(){
  return barcodeToRecordCollection;
}",0.9656992084432716
30612,"/** 
 * Returns the distinct set of barcodes for which data has been collected in this record.
 * @return
 */
public Set<String> getBarcodes(){
  return this.getBarcodeRecords().keySet();
}","/** 
 * Returns the distinct set of barcodes for which data has been collected in this record.
 * @return
 */
public synchronized Set<String> getBarcodes(){
  return this.getBarcodeRecords().keySet();
}",0.9667519181585678
30613,"@Override protected int doWork(){
  initialize();
  doTileProcessing();
  finalise();
  return 0;
}","@Override protected int doWork(){
  initialize();
  try {
    doTileProcessing();
  }
  finally {
    finalise();
  }
  return 0;
}",0.8608695652173913
30614,"/** 
 * Returns the number of records read.
 */
public long getRecordCount(){
  return recordCount;
}","/** 
 * Returns the number of records read.
 */
public synchronized long getRecordCount(){
  return recordCount;
}",0.9395348837209302
30615,"/** 
 * Gets the state of the provided barcode's data's processing progress.  Only invoke this query if this tile is in a DONE_READING state.
 * @throws IllegalStateException When a barcode is queried before the tile is in the DONE_READING state
 */
public TileBarcodeProcessingState getBarcodeState(final String barcode){
  if (this.getState() == TileProcessingState.NOT_DONE_READING) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (this.barcodeToProcessingState.containsKey(barcode)) {
    return this.barcodeToProcessingState.get(barcode);
  }
 else {
    return TileBarcodeProcessingState.NA;
  }
}","/** 
 * Gets the state of the provided barcode's data's processing progress.  Only invoke this query if this tile is in a DONE_READING state.
 * @throws IllegalStateException When a barcode is queried before the tile is in the DONE_READING state
 */
public synchronized TileBarcodeProcessingState getBarcodeState(final String barcode){
  if (this.getState() == TileProcessingState.NOT_DONE_READING) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (this.barcodeToProcessingState.containsKey(barcode)) {
    return this.barcodeToProcessingState.get(barcode);
  }
 else {
    return TileBarcodeProcessingState.NA;
  }
}",0.9896579156722356
30616,"/** 
 * Reads the data from the appropriate IlluminaDataProvider and feeds it into the TileProcessingRecord for this tile.
 */
public void process(){
  final IlluminaDataProvider dataProvider=factory.makeDataProvider(Arrays.asList(this.tile.getNumber()));
  final SAMRecord[] recordContainer=new SAMRecord[converter.getNumRecordsPerCluster()];
  log.debug(String.format(""String_Node_Str"",tile.getNumber()));
  while (dataProvider.hasNext()) {
    final ClusterData cluster=dataProvider.next();
    final String barcode=cluster.getMatchedBarcode();
    converter.createSamRecords(cluster,null,recordContainer);
    for (    final SAMRecord record : recordContainer) {
      readProgressLogger.record(record);
      this.processingRecord.addRecord(barcode,record);
    }
  }
  this.handler.completeTile(this.tile);
}","/** 
 * Reads the data from the appropriate IlluminaDataProvider and feeds it into the TileProcessingRecord for this tile.
 */
public void process(){
  final IlluminaDataProvider dataProvider=factory.makeDataProvider(Arrays.asList(this.tile.getNumber()));
  final SAMRecord[] recordContainer=new SAMRecord[converter.getNumRecordsPerCluster()];
  log.debug(String.format(""String_Node_Str"",tile.getNumber()));
  while (dataProvider.hasNext()) {
    final ClusterData cluster=dataProvider.next();
    final String barcode=cluster.getMatchedBarcode();
    converter.createSamRecords(cluster,null,recordContainer);
    readProgressLogger.record(recordContainer);
    this.processingRecord.addRecord(barcode,recordContainer);
  }
  this.handler.completeTile(this.tile);
}",0.8081063964534515
30617,"/** 
 * Adds the provided recoded to this tile.
 */
public void addRecord(final String barcode,final SAMRecord... records){
  this.recordCount+=records.length;
  SortingCollection<SAMRecord> recordCollection=this.barcodeToRecordCollection.get(barcode);
  if (recordCollection == null) {
    recordCollection=this.newSortingCollection();
    this.barcodeToRecordCollection.put(barcode,recordCollection);
    this.barcodeToProcessingState.put(barcode,null);
  }
  for (  final SAMRecord record : records) {
    recordCollection.add(record);
  }
}","/** 
 * Adds the provided recoded to this tile.
 */
public synchronized void addRecord(final String barcode,final SAMRecord... records){
  this.recordCount+=records.length;
  SortingCollection<SAMRecord> recordCollection=this.barcodeToRecordCollection.get(barcode);
  if (recordCollection == null) {
    if (!IlluminaBasecallsToSam.this.barcodeSamWriterMap.containsKey(barcode))     throw new PicardException(String.format(""String_Node_Str"",barcode));
    recordCollection=this.newSortingCollection();
    this.barcodeToRecordCollection.put(barcode,recordCollection);
    this.barcodeToProcessingState.put(barcode,null);
  }
  for (  final SAMRecord record : records) {
    recordCollection.add(record);
  }
}",0.8683160415003991
30618,"/** 
 * Sets the processing state of the provided barcode in this record.
 * @throws NoSuchElementException When the provided barcode is not one associated with this record.
 */
public void setBarcodeState(final String barcode,final TileBarcodeProcessingState state){
  if (this.barcodeToProcessingState.containsKey(barcode)) {
    this.barcodeToProcessingState.put(barcode,state);
  }
 else {
    throw new NoSuchElementException(String.format(""String_Node_Str"",barcode));
  }
}","/** 
 * Sets the processing state of the provided barcode in this record.
 * @throws NoSuchElementException When the provided barcode is not one associated with this record.
 */
public synchronized void setBarcodeState(final String barcode,final TileBarcodeProcessingState state){
  if (this.barcodeToProcessingState.containsKey(barcode)) {
    this.barcodeToProcessingState.put(barcode,state);
  }
 else {
    throw new NoSuchElementException(String.format(""String_Node_Str"",barcode));
  }
}",0.9866117404737385
30619,"/** 
 * Returns the state of this tile's processing.
 */
public TileProcessingState getState(){
  return this.state;
}","/** 
 * Returns the state of this tile's processing.
 */
public synchronized TileProcessingState getState(){
  return this.state;
}",0.9477911646586346
30620,"/** 
 * Returns the number of unique barcodes read.
 */
public long getBarcodeCount(){
  return this.barcodeToRecordCollection.size();
}","/** 
 * Returns the number of unique barcodes read.
 */
public synchronized long getBarcodeCount(){
  return this.barcodeToRecordCollection.size();
}",0.9543859649122808
30621,"private SortingCollection<SAMRecord> newSortingCollection(){
  final int maxRecordsInRam=IlluminaBasecallsToSam.this.MAX_READS_IN_RAM_PER_TILE / IlluminaBasecallsToSam.this.barcodeSamWriterMap.size();
  return SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(null),new SAMRecordQueryNameComparator(),maxRecordsInRam,IlluminaBasecallsToSam.this.TMP_DIR);
}","private synchronized SortingCollection<SAMRecord> newSortingCollection(){
  final int maxRecordsInRam=IlluminaBasecallsToSam.this.MAX_READS_IN_RAM_PER_TILE / IlluminaBasecallsToSam.this.barcodeSamWriterMap.size();
  return SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(null),new SAMRecordQueryNameComparator(),maxRecordsInRam,IlluminaBasecallsToSam.this.TMP_DIR);
}",0.9827814569536424
30622,"/** 
 * Sets the state of this tile's processing.
 */
public void setState(final TileProcessingState state){
  this.state=state;
}","/** 
 * Sets the state of this tile's processing.
 */
public synchronized void setState(final TileProcessingState state){
  this.state=state;
}",0.9523809523809524
30623,"/** 
 * Returns true if this aggregator has not completed its work.  Specifically, returns false iff any tile's barcode data yas not yet been written.
 * @return True if more work remains to be done, false otherwise
 */
public boolean isWorkCompleted(){
  for (  final Map.Entry<Tile,TileProcessingRecord> entry : this.tileRecords.entrySet()) {
    final TileProcessingRecord tileProcessingRecord=entry.getValue();
    if (tileProcessingRecord.getState() != TileProcessingState.DONE_READING) {
      return false;
    }
 else {
      for (      final TileBarcodeProcessingState barcodeProcessingState : tileProcessingRecord.barcodeToProcessingState.values()) {
        if (barcodeProcessingState != TileBarcodeProcessingState.WRITTEN) {
          return false;
        }
      }
    }
  }
  return true;
}","/** 
 * Returns true if this aggregator has not completed its work.  Specifically, returns false iff any tile's barcode data yas not yet been written.
 * @return True if more work remains to be done, false otherwise
 */
public boolean isWorkCompleted(){
  for (  final Map.Entry<Tile,TileProcessingRecord> entry : this.tileRecords.entrySet()) {
    final TileProcessingRecord tileProcessingRecord=entry.getValue();
    if (tileProcessingRecord.getState() != TileProcessingState.DONE_READING) {
      log.debug(String.format(""String_Node_Str"",entry.getKey().getNumber()));
      return false;
    }
 else {
      for (      final Map.Entry<String,TileBarcodeProcessingState> barcodeStateEntry : tileProcessingRecord.getBarcodeProcessingStates().entrySet()) {
        TileBarcodeProcessingState barcodeProcessingState=barcodeStateEntry.getValue();
        if (barcodeProcessingState != TileBarcodeProcessingState.WRITTEN) {
          log.debug(String.format(""String_Node_Str"",entry.getKey().getNumber(),barcodeStateEntry.getKey(),barcodeProcessingState));
          return false;
        }
      }
    }
  }
  log.info(""String_Node_Str"");
  return true;
}",0.7272727272727273
30624,"/** 
 * woot This test utility takes a libraryParamsFile and generates output sam files through IlluminaBasecallsToSam to compare against preloaded test data
 * @param jobName
 * @param libraryParamsFile
 * @param concatNColumnFields
 * @param readStructure
 * @throws Exception
 */
private void runStandardTest(final int lane,final String jobName,final String libraryParamsFile,final int concatNColumnFields,final String readStructure) throws Exception {
  final File outputDir=File.createTempFile(jobName,""String_Node_Str"");
  outputDir.delete();
  outputDir.mkdir();
  outputDir.deleteOnExit();
  final File libraryParams=new File(outputDir,libraryParamsFile);
  libraryParams.deleteOnExit();
  final List<File> samFiles=new ArrayList<File>();
  final LineReader reader=new BufferedLineReader(new FileInputStream(new File(TEST_DATA_DIR,libraryParamsFile)));
  final PrintWriter writer=new PrintWriter(libraryParams);
  final String header=reader.readLine();
  writer.println(header + ""String_Node_Str"");
  while (true) {
    final String line=reader.readLine();
    if (line == null) {
      break;
    }
    final String[] fields=line.split(""String_Node_Str"");
    final File outputSam=new File(outputDir,StringUtil.join(""String_Node_Str"",Arrays.copyOfRange(fields,0,concatNColumnFields)) + ""String_Node_Str"");
    outputSam.deleteOnExit();
    samFiles.add(outputSam);
    writer.println(line + ""String_Node_Str"" + outputSam);
  }
  writer.close();
  new IlluminaBasecallsToSam().instanceMain(new String[]{""String_Node_Str"" + BASECALLS_DIR,""String_Node_Str"" + lane,""String_Node_Str"",""String_Node_Str"" + readStructure,""String_Node_Str"" + libraryParams});
  for (  final File outputSam : samFiles) {
    IoUtil.assertFilesEqual(outputSam,new File(TEST_DATA_DIR,outputSam.getName()));
  }
}","/** 
 * This test utility takes a libraryParamsFile and generates output sam files through IlluminaBasecallsToSam to compare against preloaded test data
 * @param jobName
 * @param libraryParamsFile
 * @param concatNColumnFields
 * @param readStructure
 * @throws Exception
 */
private void runStandardTest(final int lane,final String jobName,final String libraryParamsFile,final int concatNColumnFields,final String readStructure) throws Exception {
  final File outputDir=File.createTempFile(jobName,""String_Node_Str"");
  outputDir.delete();
  outputDir.mkdir();
  outputDir.deleteOnExit();
  final File libraryParams=new File(outputDir,libraryParamsFile);
  libraryParams.deleteOnExit();
  final List<File> samFiles=new ArrayList<File>();
  final LineReader reader=new BufferedLineReader(new FileInputStream(new File(TEST_DATA_DIR,libraryParamsFile)));
  final PrintWriter writer=new PrintWriter(libraryParams);
  final String header=reader.readLine();
  writer.println(header + ""String_Node_Str"");
  while (true) {
    final String line=reader.readLine();
    if (line == null) {
      break;
    }
    final String[] fields=line.split(""String_Node_Str"");
    final File outputSam=new File(outputDir,StringUtil.join(""String_Node_Str"",Arrays.copyOfRange(fields,0,concatNColumnFields)) + ""String_Node_Str"");
    outputSam.deleteOnExit();
    samFiles.add(outputSam);
    writer.println(line + ""String_Node_Str"" + outputSam);
  }
  writer.close();
  new IlluminaBasecallsToSam().instanceMain(new String[]{""String_Node_Str"" + BASECALLS_DIR,""String_Node_Str"" + lane,""String_Node_Str"",""String_Node_Str"" + readStructure,""String_Node_Str"" + libraryParams});
  for (  final File outputSam : samFiles) {
    IoUtil.assertFilesEqual(outputSam,new File(TEST_DATA_DIR,outputSam.getName()));
  }
}",0.9986029617211511
30625,"/** 
 * Parses a String into a double. 
 */
public double parseDouble(String value){
  if (""String_Node_Str"".equals(value))   return Double.NaN;
 else   return Double.parseDouble(value);
}","/** 
 * Parses a String into a double. 
 */
public double parseDouble(String value){
  if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value))   return Double.NaN;
 else   return Double.parseDouble(value);
}",0.9148418491484184
30626,"/** 
 * Parses a String into a float. 
 */
public float parseFloat(String value){
  if (""String_Node_Str"".equals(value))   return Float.NaN;
 else   return Float.parseFloat(value);
}","/** 
 * Parses a String into a float. 
 */
public float parseFloat(String value){
  if (""String_Node_Str"".equals(value) || ""String_Node_Str"".equals(value))   return Float.NaN;
 else   return Float.parseFloat(value);
}",0.912280701754386
30627,"private void doTileProcessing(){
  FileChannelJDKBugWorkAround.doBugWorkAround();
  final List<Tile> tiles=new ArrayList<Tile>();
  for (  final Integer tileNumber : this.tiles) {
    tiles.add(new Tile(tileNumber));
  }
  final TileReadAggregator tileReadAggregator=new TileReadAggregator(tiles);
  tileReadAggregator.submit();
  try {
    tileReadAggregator.awaitWorkComplete();
  }
 catch (  InterruptedException e) {
    log.error(e,""String_Node_Str"");
    tileReadAggregator.shutdown();
  }
}","private void doTileProcessing(){
  FileChannelJDKBugWorkAround.doBugWorkAround();
  final List<Tile> tiles=new ArrayList<Tile>();
  for (  final Integer tileNumber : this.tiles) {
    tiles.add(new Tile(tileNumber));
  }
  final TileReadAggregator tileReadAggregator=new TileReadAggregator(tiles);
  tileReadAggregator.submit();
  try {
    tileReadAggregator.awaitWorkComplete();
  }
 catch (  InterruptedException e) {
    log.error(e,""String_Node_Str"");
    tileReadAggregator.shutdown();
    throw new PicardException(""String_Node_Str"");
  }
}",0.9521072796934866
30628,"/** 
 * Execute the tile aggregator's work.  Creates a thread pool to read data from tiles and write them to file. Invoke this method only once.
 * @throws IllegalStateException If submit was called more than once.
 */
public void submit(){
  if (!this.submitted.compareAndSet(false,true)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.parentThread=Thread.currentThread();
  int priority=0;
  for (  final Tile tile : this.tileRecords.keySet()) {
    final TileReader reader=new TileReader(tile,this,this.tileRecords.get(tile));
    this.prioritizingThreadPool.execute(new PriorityRunnable(--priority){
      @Override public void run(){
        reader.process();
      }
    }
);
  }
}","/** 
 * Execute the tile aggregator's work.  Creates a thread pool to read data from tiles and write them to file. Invoke this method only once.
 * @throws IllegalStateException If submit was called more than once.
 */
public void submit(){
  if (!this.submitted.compareAndSet(false,true)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.parentThread=Thread.currentThread();
  int priority=0;
  for (  final Tile tile : this.tileRecords.keySet()) {
    final TileReader reader=new TileReader(tile,this,this.tileRecords.get(tile));
    this.prioritizingThreadPool.execute(new PriorityRunnable(--priority){
      @Override public void run(){
        try {
          reader.process();
        }
 catch (        RuntimeException e) {
          parentThread.interrupt();
          throw e;
        }
catch (        Error e) {
          parentThread.interrupt();
          throw e;
        }
      }
    }
);
  }
}",0.8656898656898657
30629,"private void doTileProcessing(){
  FileChannelJDKBugWorkAround.doBugWorkAround();
  final List<Tile> tiles=new ArrayList<Tile>();
  for (  final Integer tileNumber : this.tiles) {
    tiles.add(new Tile(tileNumber));
  }
  final TileReadAggregator tileReadAggregator=new TileReadAggregator(tiles);
  tileReadAggregator.submit();
  try {
    tileReadAggregator.awaitWorkComplete();
  }
 catch (  InterruptedException e) {
    log.error(e,""String_Node_Str"");
    tileReadAggregator.shutdown();
    throw new PicardException(String.format(""String_Node_Str"",e.getMessage()));
  }
}","private void doTileProcessing(){
  FileChannelJDKBugWorkAround.doBugWorkAround();
  final List<Tile> tiles=new ArrayList<Tile>();
  for (  final Integer tileNumber : this.tiles) {
    tiles.add(new Tile(tileNumber));
  }
  final TileReadAggregator tileReadAggregator=new TileReadAggregator(tiles);
  tileReadAggregator.submit();
  try {
    tileReadAggregator.awaitWorkComplete();
  }
 catch (  InterruptedException e) {
    log.error(e,""String_Node_Str"");
    tileReadAggregator.shutdown();
  }
}",0.925512104283054
30630,"/** 
 * Returns a PriorityRunnable that encapsulates the work involved with writing the provided tileRecord's data for the given barcode to disk.
 * @param tile       The tile from which the record was read
 * @param tileRecord The processing record associated with the tile
 * @param barcode    The barcode whose data within the tileRecord is to be written
 * @return The runnable that upon invocation writes the barcode's data from the tileRecord to disk
 */
private PriorityRunnable newBarcodeWorkInstance(final Tile tile,final TileProcessingRecord tileRecord,final String barcode){
  return new PriorityRunnable(){
    @Override public void run(){
      try {
        final SortingCollection<SAMRecord> records=tileRecord.getBarcodeRecords().get(barcode);
        final SAMFileWriter writer=barcodeSamWriterMap.get(barcode);
        log.debug(String.format(""String_Node_Str"",tile.getNumber(),barcode));
        final PeekIterator<SAMRecord> it=new PeekIterator<SAMRecord>(records.iterator());
        while (it.hasNext()) {
          final SAMRecord rec=it.next();
          if (it.hasNext()) {
            final SAMRecord lookAhead=it.peek();
            if (!rec.getReadUnmappedFlag() || !lookAhead.getReadUnmappedFlag()) {
              throw new IllegalStateException(""String_Node_Str"");
            }
            if (samRecordQueryNameComparator.compare(rec,lookAhead) == 0) {
              it.next();
              log.info(""String_Node_Str"" + rec.getReadName());
              continue;
            }
          }
          writer.addAlignment(rec);
          writeProgressLogger.record(rec);
        }
        tileRecord.setBarcodeState(barcode,TileBarcodeProcessingState.WRITTEN);
        findAndEnqueueWorkOrSignalCompletion();
      }
 catch (      RuntimeException e) {
        parentThread.interrupt();
        throw e;
      }
    }
  }
;
}","/** 
 * Returns a PriorityRunnable that encapsulates the work involved with writing the provided tileRecord's data for the given barcode to disk.
 * @param tile       The tile from which the record was read
 * @param tileRecord The processing record associated with the tile
 * @param barcode    The barcode whose data within the tileRecord is to be written
 * @return The runnable that upon invocation writes the barcode's data from the tileRecord to disk
 */
private PriorityRunnable newBarcodeWorkInstance(final Tile tile,final TileProcessingRecord tileRecord,final String barcode){
  return new PriorityRunnable(){
    @Override public void run(){
      try {
        final SortingCollection<SAMRecord> records=tileRecord.getBarcodeRecords().get(barcode);
        final SAMFileWriter writer=barcodeSamWriterMap.get(barcode);
        log.debug(String.format(""String_Node_Str"",tile.getNumber(),barcode));
        final PeekIterator<SAMRecord> it=new PeekIterator<SAMRecord>(records.iterator());
        while (it.hasNext()) {
          final SAMRecord rec=it.next();
          if (it.hasNext()) {
            final SAMRecord lookAhead=it.peek();
            if (!rec.getReadUnmappedFlag() || !lookAhead.getReadUnmappedFlag()) {
              throw new IllegalStateException(""String_Node_Str"");
            }
            if (samRecordQueryNameComparator.compare(rec,lookAhead) == 0) {
              it.next();
              log.info(""String_Node_Str"" + rec.getReadName());
              continue;
            }
          }
          writer.addAlignment(rec);
          writeProgressLogger.record(rec);
        }
        tileRecord.setBarcodeState(barcode,TileBarcodeProcessingState.WRITTEN);
        findAndEnqueueWorkOrSignalCompletion();
      }
 catch (      RuntimeException e) {
        parentThread.interrupt();
        throw e;
      }
catch (      Error e) {
        parentThread.interrupt();
        throw e;
      }
    }
  }
;
}",0.9781406373452726
30631,"private void populateWritersByBarcode(){
  final TabbedTextFileWithHeaderParser barcodeParamsParser=new TabbedTextFileWithHeaderParser(BARCODE_PARAMS);
  final String[] columnLabels=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  final String columnLabel : columnLabels) {
    if (!barcodeParamsParser.hasColumn(columnLabel)) {
      throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str""+ columnLabel+ ""String_Node_Str"");
    }
  }
  final List<String> barcodeColumnLabels=new ArrayList<String>();
  if (readStructure.barcodes.length() == 1) {
    if (barcodeParamsParser.hasColumn(""String_Node_Str"")) {
      barcodeColumnLabels.add(""String_Node_Str"");
    }
 else     if (barcodeParamsParser.hasColumn(""String_Node_Str"")) {
      barcodeColumnLabels.add(""String_Node_Str"");
    }
 else {
      throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str"");
    }
  }
 else {
    for (int i=1; i <= readStructure.barcodes.length(); i++) {
      final String barcodeLabel=""String_Node_Str"" + i;
      if (!barcodeParamsParser.hasColumn(barcodeLabel)) {
        throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str""+ barcodeLabel+ ""String_Node_Str"");
      }
      barcodeColumnLabels.add(barcodeLabel);
    }
  }
  for (  final TabbedTextFileWithHeaderParser.Row row : barcodeParamsParser) {
    final List<String> barcodeValues=new ArrayList<String>();
    for (    final String barcodeLabel : barcodeColumnLabels) {
      barcodeValues.add(row.getField(barcodeLabel));
    }
    final String[] barcodeValuesArray=barcodeValues.toArray(new String[]{});
    final String key=(barcodeValues.contains(""String_Node_Str"") ? null : IlluminaUtil.barcodeSeqsToString(barcodeValuesArray));
    if (writersByBarcode.containsKey(key)) {
      throw new PicardException(""String_Node_Str"" + key + ""String_Node_Str""+ BARCODE_PARAMS);
    }
    final SAMFileWriter writer=buildSamFileWriter(new File(row.getField(""String_Node_Str"")),row.getField(""String_Node_Str""),row.getField(""String_Node_Str""),barcodeValuesArray);
    writersByBarcode.put(key,writer);
  }
  if (writersByBarcode.isEmpty()) {
    throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str"");
  }
}","private void populateWritersByBarcode(){
  final TabbedTextFileWithHeaderParser barcodeParamsParser=new TabbedTextFileWithHeaderParser(BARCODE_PARAMS);
  final String[] columnLabels=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  final String columnLabel : columnLabels) {
    if (!barcodeParamsParser.hasColumn(columnLabel)) {
      throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str""+ columnLabel+ ""String_Node_Str"");
    }
  }
  final List<String> barcodeColumnLabels=new ArrayList<String>();
  if (readStructure.barcodes.length() == 1) {
    if (barcodeParamsParser.hasColumn(""String_Node_Str"")) {
      barcodeColumnLabels.add(""String_Node_Str"");
    }
 else     if (barcodeParamsParser.hasColumn(""String_Node_Str"")) {
      barcodeColumnLabels.add(""String_Node_Str"");
    }
 else {
      throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str"");
    }
  }
 else {
    for (int i=1; i <= readStructure.barcodes.length(); i++) {
      final String barcodeLabel=""String_Node_Str"" + i;
      if (!barcodeParamsParser.hasColumn(barcodeLabel)) {
        throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str""+ barcodeLabel+ ""String_Node_Str"");
      }
      barcodeColumnLabels.add(barcodeLabel);
    }
  }
  for (  final TabbedTextFileWithHeaderParser.Row row : barcodeParamsParser) {
    final List<String> barcodeValues=new ArrayList<String>();
    for (    final String barcodeLabel : barcodeColumnLabels) {
      barcodeValues.add(row.getField(barcodeLabel));
    }
    final String[] barcodeValuesArray=barcodeValues.toArray(new String[]{});
    final String key=(barcodeValues.contains(""String_Node_Str"") ? null : StringUtil.join(""String_Node_Str"",barcodeValuesArray));
    if (writersByBarcode.containsKey(key)) {
      throw new PicardException(""String_Node_Str"" + key + ""String_Node_Str""+ BARCODE_PARAMS);
    }
    final SAMFileWriter writer=buildSamFileWriter(new File(row.getField(""String_Node_Str"")),row.getField(""String_Node_Str""),row.getField(""String_Node_Str""),barcodeValuesArray);
    writersByBarcode.put(key,writer);
  }
  if (writersByBarcode.isEmpty()) {
    throw new PicardException(""String_Node_Str"" + BARCODE_PARAMS + ""String_Node_Str"");
  }
}",0.9874917709019092
30632,"/** 
 * run method which extracts barcodes and accumulates metrics for an entire tile
 */
synchronized public void run(){
  log.info(""String_Node_Str"" + tile);
  final IlluminaDataProvider provider=factory.makeDataProvider(Arrays.asList(tile));
  final int[] barcodeIndices=outputReadStructure.barcodes.getIndices();
  final BufferedWriter writer=IoUtil.openFileForBufferedWriting(barcodeFile);
  try {
    final byte barcodeSubsequences[][]=new byte[barcodeIndices.length][];
    final byte qualityScores[][]=usingQualityScores ? new byte[barcodeIndices.length][] : null;
    while (provider.hasNext()) {
      final ClusterData cluster=provider.next();
      for (int i=0; i < barcodeIndices.length; i++) {
        barcodeSubsequences[i]=cluster.getRead(barcodeIndices[i]).getBases();
        if (usingQualityScores)         qualityScores[i]=cluster.getRead(barcodeIndices[i]).getQualities();
      }
      final boolean passingFilter=cluster.isPf();
      final BarcodeMatch match=findBestBarcodeAndUpdateMetrics(barcodeSubsequences,qualityScores,passingFilter,metrics,noMatchMetric);
      final String yOrN=(match.matched ? ""String_Node_Str"" : ""String_Node_Str"");
      for (      final byte[] bc : barcodeSubsequences) {
        writer.write(StringUtil.bytesToString(bc) + ""String_Node_Str"");
      }
      writer.write(yOrN + ""String_Node_Str"" + match.barcode+ ""String_Node_Str""+ String.valueOf(match.mismatches)+ ""String_Node_Str""+ String.valueOf(match.mismatchesToSecondBest));
      writer.newLine();
    }
    writer.close();
  }
 catch (  Exception e) {
    log.error(e,""String_Node_Str"",this.tile);
    this.exception=e;
  }
}","/** 
 * run method which extracts barcodes and accumulates metrics for an entire tile
 */
synchronized public void run(){
  log.info(""String_Node_Str"" + tile);
  final IlluminaDataProvider provider=factory.makeDataProvider(Arrays.asList(tile));
  final int[] barcodeIndices=outputReadStructure.barcodes.getIndices();
  final BufferedWriter writer=IoUtil.openFileForBufferedWriting(barcodeFile);
  try {
    final byte barcodeSubsequences[][]=new byte[barcodeIndices.length][];
    final byte qualityScores[][]=usingQualityScores ? new byte[barcodeIndices.length][] : null;
    while (provider.hasNext()) {
      final ClusterData cluster=provider.next();
      for (int i=0; i < barcodeIndices.length; i++) {
        barcodeSubsequences[i]=cluster.getRead(barcodeIndices[i]).getBases();
        if (usingQualityScores)         qualityScores[i]=cluster.getRead(barcodeIndices[i]).getQualities();
      }
      final boolean passingFilter=cluster.isPf();
      final BarcodeMatch match=findBestBarcodeAndUpdateMetrics(barcodeSubsequences,qualityScores,passingFilter,metrics,noMatchMetric);
      final String yOrN=(match.matched ? ""String_Node_Str"" : ""String_Node_Str"");
      for (      final byte[] bc : barcodeSubsequences) {
        writer.write(StringUtil.bytesToString(bc));
      }
      writer.write(""String_Node_Str"" + yOrN + ""String_Node_Str""+ match.barcode+ ""String_Node_Str""+ String.valueOf(match.mismatches)+ ""String_Node_Str""+ String.valueOf(match.mismatchesToSecondBest));
      writer.newLine();
    }
    writer.close();
  }
 catch (  Exception e) {
    log.error(e,""String_Node_Str"",this.tile);
    this.exception=e;
  }
}",0.9795544705523344
30633,"@Override protected void setup(final SAMFileHeader header,final File samFile){
  if (CHART_OUTPUT != null)   IoUtil.assertFileIsWritable(CHART_OUTPUT);
  final OverlapDetector<Gene> geneOverlapDetector=GeneAnnotationReader.loadRefFlat(REF_FLAT,header.getSequenceDictionary());
  LOG.info(""String_Node_Str"" + geneOverlapDetector.getAll().size() + ""String_Node_Str"");
  final Long ribosomalBasesInitialValue=RIBOSOMAL_INTERVALS != null ? 0L : null;
  final OverlapDetector<Interval> ribosomalSequenceOverlapDetector=MultiLevelRnaSeqMetricsCollector.makeOverlapDetector(samFile,header,RIBOSOMAL_INTERVALS);
  final HashSet<Integer> ignoredSequenceIndices=MultiLevelRnaSeqMetricsCollector.makeIgnoredSequenceIndicesSet(header,IGNORE_SEQUENCE);
  collector=new MultiLevelRnaSeqMetricsCollector(METRIC_ACCUMULATION_LEVEL,header.getReadGroups(),ribosomalBasesInitialValue,geneOverlapDetector,ribosomalSequenceOverlapDetector,ignoredSequenceIndices,MINIMUM_LENGTH,STRAND_SPECIFICITY,RRNA_FRAGMENT_PERCENTAGE);
}","@Override protected void setup(final SAMFileHeader header,final File samFile){
  if (CHART_OUTPUT != null)   IoUtil.assertFileIsWritable(CHART_OUTPUT);
  final OverlapDetector<Gene> geneOverlapDetector=GeneAnnotationReader.loadRefFlat(REF_FLAT,header.getSequenceDictionary());
  LOG.info(""String_Node_Str"" + geneOverlapDetector.getAll().size() + ""String_Node_Str"");
  final Long ribosomalBasesInitialValue=RIBOSOMAL_INTERVALS != null ? 0L : null;
  final OverlapDetector<Interval> ribosomalSequenceOverlapDetector=RnaSeqMetricsCollector.makeOverlapDetector(samFile,header,RIBOSOMAL_INTERVALS);
  final HashSet<Integer> ignoredSequenceIndices=RnaSeqMetricsCollector.makeIgnoredSequenceIndicesSet(header,IGNORE_SEQUENCE);
  collector=new RnaSeqMetricsCollector(METRIC_ACCUMULATION_LEVEL,header.getReadGroups(),ribosomalBasesInitialValue,geneOverlapDetector,ribosomalSequenceOverlapDetector,ignoredSequenceIndices,MINIMUM_LENGTH,STRAND_SPECIFICITY,RRNA_FRAGMENT_PERCENTAGE);
}",0.9848178137651822
30634,"private int[] removeNonexistantCycles(final int[] cycles){
  if (lazyDetectedCyclesSet == null) {
    lazyDetectedCyclesSet=new TreeSet<Integer>();
    for (    final Integer cycle : detectedCycles) {
      lazyDetectedCyclesSet.add(cycle);
    }
  }
  final TreeSet<Integer> inputCyclesSet=new TreeSet<Integer>();
  for (  final Integer inputCycle : cycles) {
    inputCyclesSet.add(inputCycle);
  }
  final int[] outputCycles;
  inputCyclesSet.retainAll(lazyDetectedCyclesSet);
  outputCycles=new int[inputCyclesSet.size()];
  int i=0;
  for (  final Integer element : inputCyclesSet) {
    outputCycles[i++]=element;
  }
  return outputCycles;
}","private int[] removeNonexistantCycles(final int[] cycles){
  final TreeSet<Integer> detectedCyclesSet=new TreeSet<Integer>();
  for (  final Integer cycle : detectedCycles) {
    detectedCyclesSet.add(cycle);
  }
  final TreeSet<Integer> inputCyclesSet=new TreeSet<Integer>();
  for (  final Integer inputCycle : cycles) {
    inputCyclesSet.add(inputCycle);
  }
  final int[] outputCycles;
  inputCyclesSet.retainAll(detectedCyclesSet);
  outputCycles=new int[inputCyclesSet.size()];
  int i=0;
  for (  final Integer element : inputCyclesSet) {
    outputCycles[i++]=element;
  }
  return outputCycles;
}",0.7081339712918661
30635,"/** 
 * Compute SAMRecord insert size
 * @param firstEnd
 * @param secondEnd
 * @return note that when storing insert size on the secondEnd, the return value must be negated.
 */
public static int computeInsertSize(final SAMRecord firstEnd,final SAMRecord secondEnd){
  if (firstEnd.getReadUnmappedFlag() || secondEnd.getReadUnmappedFlag()) {
    return 0;
  }
  if (!firstEnd.getReferenceName().equals(secondEnd.getReferenceName())) {
    return 0;
  }
  int firstEnd5PrimePosition=firstEnd.getReadNegativeStrandFlag() ? firstEnd.getAlignmentEnd() : firstEnd.getAlignmentStart();
  int secondEnd5PrimePosition=secondEnd.getReadNegativeStrandFlag() ? secondEnd.getAlignmentEnd() : secondEnd.getAlignmentStart();
  return CoordMath.getLength(firstEnd5PrimePosition,secondEnd5PrimePosition);
}","/** 
 * Compute SAMRecord insert size
 * @param firstEnd
 * @param secondEnd
 * @return note that when storing insert size on the secondEnd, the return value must be negated.
 */
public static int computeInsertSize(final SAMRecord firstEnd,final SAMRecord secondEnd){
  if (firstEnd.getReadUnmappedFlag() || secondEnd.getReadUnmappedFlag()) {
    return 0;
  }
  if (!firstEnd.getReferenceName().equals(secondEnd.getReferenceName())) {
    return 0;
  }
  final int firstEnd5PrimePosition=firstEnd.getReadNegativeStrandFlag() ? firstEnd.getAlignmentEnd() : firstEnd.getAlignmentStart();
  final int secondEnd5PrimePosition=secondEnd.getReadNegativeStrandFlag() ? secondEnd.getAlignmentEnd() : secondEnd.getAlignmentStart();
  final int adjustment=(secondEnd5PrimePosition >= firstEnd5PrimePosition) ? +1 : -1;
  return secondEnd5PrimePosition - firstEnd5PrimePosition + adjustment;
}",0.8984468339307049
30636,"private void collectQualityData(final SAMRecord record,final ReferenceSequence reference){
  if (record.getReadUnmappedFlag() || !doRefMetrics) {
    final byte[] readBases=record.getReadBases();
    for (int i=0; i < readBases.length; i++) {
      if (SequenceUtil.isNoCall(readBases[i])) {
        badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(),readBases.length,i));
      }
    }
  }
 else {
    final boolean highQualityMapping=isHighQualityMapping(record);
    if (highQualityMapping)     metrics.PF_HQ_ALIGNED_READS++;
    final byte[] readBases=record.getReadBases();
    final byte[] refBases=reference.getBases();
    final byte[] qualities=record.getBaseQualities();
    final int refLength=refBases.length;
    long mismatchCount=0;
    long hqMismatchCount=0;
    for (    final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {
      final int readIndex=alignmentBlock.getReadStart() - 1;
      final int refIndex=alignmentBlock.getReferenceStart() - 1;
      final int length=alignmentBlock.getLength();
      for (int i=0; i < length && refIndex + i < refLength; ++i) {
        final int readBaseIndex=readIndex + i;
        boolean mismatch=!SequenceUtil.basesEqual(readBases[readBaseIndex],refBases[refIndex + i]);
        boolean bisulfiteBase=false;
        if (mismatch && IS_BISULFITE_SEQUENCED) {
          if ((record.getReadNegativeStrandFlag() && (refBases[refIndex + i] == 'G' || refBases[refIndex + i] == 'g') && (readBases[readBaseIndex] == 'A' || readBases[readBaseIndex] == 'a')) || ((!record.getReadNegativeStrandFlag()) && (refBases[refIndex + i] == 'C' || refBases[refIndex + i] == 'c') && (readBases[readBaseIndex] == 'T') || readBases[readBaseIndex] == 't')) {
            bisulfiteBase=true;
            mismatch=false;
          }
        }
        if (mismatch)         mismatchCount++;
        metrics.PF_ALIGNED_BASES++;
        if (!bisulfiteBase) {
          nonBisulfiteAlignedBases++;
        }
        if (highQualityMapping) {
          metrics.PF_HQ_ALIGNED_BASES++;
          if (!bisulfiteBase) {
            hqNonBisulfiteAlignedBases++;
          }
          if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {
            metrics.PF_HQ_ALIGNED_Q20_BASES++;
          }
          if (mismatch) {
            hqMismatchCount++;
          }
        }
        if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {
          badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(),readBases.length,i));
        }
      }
    }
    mismatchHistogram.increment(mismatchCount);
    hqMismatchHistogram.increment(hqMismatchCount);
    for (    final CigarElement elem : record.getCigar().getCigarElements()) {
      final CigarOperator op=elem.getOperator();
      if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION)       ++this.indels;
    }
  }
}","private void collectQualityData(final SAMRecord record,final ReferenceSequence reference){
  if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {
    final byte[] readBases=record.getReadBases();
    for (int i=0; i < readBases.length; i++) {
      if (SequenceUtil.isNoCall(readBases[i])) {
        badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(),readBases.length,i));
      }
    }
  }
 else   if (!record.getReadFailsVendorQualityCheckFlag()) {
    final boolean highQualityMapping=isHighQualityMapping(record);
    if (highQualityMapping)     metrics.PF_HQ_ALIGNED_READS++;
    final byte[] readBases=record.getReadBases();
    final byte[] refBases=reference.getBases();
    final byte[] qualities=record.getBaseQualities();
    final int refLength=refBases.length;
    long mismatchCount=0;
    long hqMismatchCount=0;
    for (    final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {
      final int readIndex=alignmentBlock.getReadStart() - 1;
      final int refIndex=alignmentBlock.getReferenceStart() - 1;
      final int length=alignmentBlock.getLength();
      for (int i=0; i < length && refIndex + i < refLength; ++i) {
        final int readBaseIndex=readIndex + i;
        boolean mismatch=!SequenceUtil.basesEqual(readBases[readBaseIndex],refBases[refIndex + i]);
        boolean bisulfiteBase=false;
        if (mismatch && IS_BISULFITE_SEQUENCED) {
          if ((record.getReadNegativeStrandFlag() && (refBases[refIndex + i] == 'G' || refBases[refIndex + i] == 'g') && (readBases[readBaseIndex] == 'A' || readBases[readBaseIndex] == 'a')) || ((!record.getReadNegativeStrandFlag()) && (refBases[refIndex + i] == 'C' || refBases[refIndex + i] == 'c') && (readBases[readBaseIndex] == 'T') || readBases[readBaseIndex] == 't')) {
            bisulfiteBase=true;
            mismatch=false;
          }
        }
        if (mismatch)         mismatchCount++;
        metrics.PF_ALIGNED_BASES++;
        if (!bisulfiteBase)         nonBisulfiteAlignedBases++;
        if (highQualityMapping) {
          metrics.PF_HQ_ALIGNED_BASES++;
          if (!bisulfiteBase)           hqNonBisulfiteAlignedBases++;
          if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD)           metrics.PF_HQ_ALIGNED_Q20_BASES++;
          if (mismatch)           hqMismatchCount++;
        }
        if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {
          badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(),readBases.length,i));
        }
      }
    }
    mismatchHistogram.increment(mismatchCount);
    hqMismatchHistogram.increment(hqMismatchCount);
    for (    final CigarElement elem : record.getCigar().getCigarElements()) {
      final CigarOperator op=elem.getOperator();
      if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION)       ++this.indels;
    }
  }
}",0.9679629946890526
30637,"private void collectReadData(final SAMRecord record,final ReferenceSequence ref){
  metrics.TOTAL_READS++;
  readLengthHistogram.increment(record.getReadBases().length);
  if (!record.getReadFailsVendorQualityCheckFlag()) {
    metrics.PF_READS++;
    if (isNoiseRead(record)) {
      metrics.PF_NOISE_READS++;
    }
 else     if (record.getReadUnmappedFlag()) {
      final byte[] readBases=record.getReadBases();
      if (!(record instanceof BAMRecord))       StringUtil.toUpperCase(readBases);
      if (isAdapterSequence(readBases)) {
        this.adapterReads++;
      }
    }
 else {
      if (doRefMetrics) {
        metrics.PF_READS_ALIGNED++;
        if (!record.getReadNegativeStrandFlag()) {
          numPositiveStrand++;
        }
        if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {
          metrics.READS_ALIGNED_IN_PAIRS++;
          final Integer mateMq=record.getIntegerAttribute(""String_Node_Str"");
          if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {
            ++this.chimerasDenominator;
            if (Math.abs(record.getInferredInsertSize()) > MAX_INSERT_SIZE || !record.getReferenceIndex().equals(record.getMateReferenceIndex())) {
              ++this.chimeras;
            }
          }
        }
      }
    }
  }
}","private void collectReadData(final SAMRecord record,final ReferenceSequence ref){
  metrics.TOTAL_READS++;
  readLengthHistogram.increment(record.getReadBases().length);
  if (!record.getReadFailsVendorQualityCheckFlag()) {
    metrics.PF_READS++;
    if (isNoiseRead(record))     metrics.PF_NOISE_READS++;
    if (record.getReadUnmappedFlag()) {
      final byte[] readBases=record.getReadBases();
      if (!(record instanceof BAMRecord))       StringUtil.toUpperCase(readBases);
      if (isAdapterSequence(readBases)) {
        this.adapterReads++;
      }
    }
 else     if (doRefMetrics) {
      metrics.PF_READS_ALIGNED++;
      if (!record.getReadNegativeStrandFlag())       numPositiveStrand++;
      if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {
        metrics.READS_ALIGNED_IN_PAIRS++;
        final Integer mateMq=record.getIntegerAttribute(""String_Node_Str"");
        if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {
          ++this.chimerasDenominator;
          if (Math.abs(record.getInferredInsertSize()) > MAX_INSERT_SIZE || !record.getReferenceIndex().equals(record.getMateReferenceIndex())) {
            ++this.chimeras;
          }
        }
      }
    }
  }
}",0.9573170731707316
30638,"/** 
 * Gets the pair of writers for a given read group or, if we are not sorting by read group, just returns the single pair of writers.
 */
private Map<SAMReadGroupRecord,List<FastqWriter>> getWriters(final List<SAMReadGroupRecord> samReadGroupRecords,final FastqWriterFactory factory){
  final Map<SAMReadGroupRecord,List<FastqWriter>> writerMap=new HashMap<SAMReadGroupRecord,List<FastqWriter>>(0);
  for (  final SAMReadGroupRecord rg : samReadGroupRecords) {
    final List<FastqWriter> fqw=new ArrayList<FastqWriter>();
    if (!OUTPUT_PER_RG) {
      if (writerMap.isEmpty()) {
        IoUtil.assertFileIsWritable(FASTQ);
        IoUtil.openFileForWriting(FASTQ);
        fqw.add(factory.newWriter(FASTQ));
        if (SECOND_END_FASTQ != null) {
          IoUtil.assertFileIsWritable(SECOND_END_FASTQ);
          IoUtil.openFileForWriting(SECOND_END_FASTQ);
          fqw.add(factory.newWriter(SECOND_END_FASTQ));
        }
        writerMap.put(rg,fqw);
      }
 else {
        writerMap.put(rg,writerMap.values().iterator().next());
      }
    }
 else {
      fqw.add(factory.newWriter(makeReadGroupFile(rg,""String_Node_Str"")));
      writerMap.put(rg,fqw);
    }
  }
  return writerMap;
}","/** 
 * Gets the pair of writers for a given read group or, if we are not sorting by read group, just returns the single pair of writers.
 */
private Map<SAMReadGroupRecord,List<FastqWriter>> getWriters(final List<SAMReadGroupRecord> samReadGroupRecords,final FastqWriterFactory factory){
  final Map<SAMReadGroupRecord,List<FastqWriter>> writerMap=new HashMap<SAMReadGroupRecord,List<FastqWriter>>();
  for (  final SAMReadGroupRecord rg : samReadGroupRecords) {
    final List<FastqWriter> fqw=new ArrayList<FastqWriter>();
    if (!OUTPUT_PER_RG) {
      if (writerMap.isEmpty()) {
        IoUtil.assertFileIsWritable(FASTQ);
        IoUtil.openFileForWriting(FASTQ);
        fqw.add(factory.newWriter(FASTQ));
        if (SECOND_END_FASTQ != null) {
          IoUtil.assertFileIsWritable(SECOND_END_FASTQ);
          IoUtil.openFileForWriting(SECOND_END_FASTQ);
          fqw.add(factory.newWriter(SECOND_END_FASTQ));
        }
        writerMap.put(rg,fqw);
      }
 else {
        writerMap.put(rg,writerMap.values().iterator().next());
      }
    }
 else {
      fqw.add(factory.newWriter(makeReadGroupFile(rg,""String_Node_Str"")));
      writerMap.put(rg,fqw);
    }
  }
  return writerMap;
}",0.9995835068721366
30639,"protected int doWork(){
  IoUtil.assertFileIsReadable(INPUT);
  final SAMFileReader reader=new SAMFileReader(IoUtil.openFileForReading(INPUT));
  final Map<String,SAMRecord> firstSeenMates=new HashMap<String,SAMRecord>();
  final FastqWriterFactory factory=new FastqWriterFactory();
  final Map<SAMReadGroupRecord,List<FastqWriter>> writers=getWriters(reader.getFileHeader().getReadGroups(),factory);
  long count=0;
  for (  final SAMRecord currentRecord : reader) {
    if (currentRecord.getNotPrimaryAlignmentFlag() && !INCLUDE_NON_PRIMARY_ALIGNMENTS)     continue;
    if (currentRecord.getReadFailsVendorQualityCheckFlag() && !INCLUDE_NON_PF_READS)     continue;
    final List<FastqWriter> fq=writers.get(currentRecord.getReadGroup());
    if (currentRecord.getReadPairedFlag()) {
      final String currentReadName=currentRecord.getReadName();
      final SAMRecord firstRecord=firstSeenMates.remove(currentReadName);
      if (firstRecord == null) {
        firstSeenMates.put(currentReadName,currentRecord);
      }
 else {
        assertPairedMates(firstRecord,currentRecord);
        if (OUTPUT_PER_RG && fq.size() == 1) {
          fq.add(factory.newWriter(makeReadGroupFile(currentRecord.getReadGroup(),""String_Node_Str"")));
        }
        final SAMRecord read1=currentRecord.getFirstOfPairFlag() ? currentRecord : firstRecord;
        final SAMRecord read2=currentRecord.getFirstOfPairFlag() ? firstRecord : currentRecord;
        writeRecord(read1,1,fq.get(0),READ1_TRIM,READ1_MAX_BASES_TO_WRITE);
        writeRecord(read2,2,fq.get(1),READ2_TRIM,READ2_MAX_BASES_TO_WRITE);
      }
    }
 else {
      writeRecord(currentRecord,null,fq.get(0),READ1_TRIM,READ1_MAX_BASES_TO_WRITE);
    }
    if (++count % 10000000 == 0) {
      log.info(""String_Node_Str"" + count + ""String_Node_Str"");
    }
  }
  reader.close();
  if (firstSeenMates.size() > 0) {
    throw new PicardException(""String_Node_Str"" + firstSeenMates.size() + ""String_Node_Str"");
  }
  for (  final List<FastqWriter> listOfWriters : writers.values()) {
    for (    final FastqWriter w : listOfWriters) {
      w.close();
    }
  }
  return 0;
}","protected int doWork(){
  IoUtil.assertFileIsReadable(INPUT);
  final SAMFileReader reader=new SAMFileReader(IoUtil.openFileForReading(INPUT));
  final Map<String,SAMRecord> firstSeenMates=new HashMap<String,SAMRecord>();
  final FastqWriterFactory factory=new FastqWriterFactory();
  final Map<SAMReadGroupRecord,List<FastqWriter>> writers=getWriters(reader.getFileHeader().getReadGroups(),factory);
  long count=0;
  for (  final SAMRecord currentRecord : reader) {
    if (currentRecord.getNotPrimaryAlignmentFlag() && !INCLUDE_NON_PRIMARY_ALIGNMENTS)     continue;
    if (currentRecord.getReadFailsVendorQualityCheckFlag() && !INCLUDE_NON_PF_READS)     continue;
    final List<FastqWriter> fq=writers.get(currentRecord.getReadGroup());
    if (currentRecord.getReadPairedFlag()) {
      final String currentReadName=currentRecord.getReadName();
      final SAMRecord firstRecord=firstSeenMates.remove(currentReadName);
      if (firstRecord == null) {
        firstSeenMates.put(currentReadName,currentRecord);
      }
 else {
        assertPairedMates(firstRecord,currentRecord);
        if (OUTPUT_PER_RG && fq.size() == 1) {
          fq.add(factory.newWriter(makeReadGroupFile(currentRecord.getReadGroup(),""String_Node_Str"")));
        }
        final SAMRecord read1=currentRecord.getFirstOfPairFlag() ? currentRecord : firstRecord;
        final SAMRecord read2=currentRecord.getFirstOfPairFlag() ? firstRecord : currentRecord;
        writeRecord(read1,1,fq.get(0),READ1_TRIM,READ1_MAX_BASES_TO_WRITE);
        writeRecord(read2,2,fq.get(1),READ2_TRIM,READ2_MAX_BASES_TO_WRITE);
      }
    }
 else {
      writeRecord(currentRecord,null,fq.get(0),READ1_TRIM,READ1_MAX_BASES_TO_WRITE);
    }
    if (++count % 10000000 == 0) {
      log.info(""String_Node_Str"" + count + ""String_Node_Str"");
    }
  }
  reader.close();
  if (firstSeenMates.size() > 0) {
    throw new PicardException(""String_Node_Str"" + firstSeenMates.size() + ""String_Node_Str"");
  }
  final IdentityHashMap<FastqWriter,FastqWriter> seen=new IdentityHashMap<FastqWriter,FastqWriter>();
  for (  final List<FastqWriter> listOfWriters : writers.values()) {
    for (    final FastqWriter w : listOfWriters) {
      if (!seen.containsKey(w)) {
        w.close();
        seen.put(w,w);
      }
    }
  }
  return 0;
}",0.9237384023534736
30640,"/** 
 * Compute SAMRecord insert size
 * @param firstEnd
 * @param secondEnd
 * @return note that when storing insert size on the secondEnd, the return value must be negated.
 */
public static int computeInsertSize(final SAMRecord firstEnd,final SAMRecord secondEnd){
  if (firstEnd.getReadUnmappedFlag() || secondEnd.getReadUnmappedFlag()) {
    return 0;
  }
  if (!firstEnd.getReferenceName().equals(secondEnd.getReferenceName())) {
    return 0;
  }
  int firstEnd5PrimePosition=firstEnd.getReadNegativeStrandFlag() ? firstEnd.getAlignmentEnd() : firstEnd.getAlignmentStart();
  int secondEnd5PrimePosition=secondEnd.getReadNegativeStrandFlag() ? secondEnd.getAlignmentEnd() : secondEnd.getAlignmentStart();
  return secondEnd5PrimePosition - firstEnd5PrimePosition;
}","/** 
 * Compute SAMRecord insert size
 * @param firstEnd
 * @param secondEnd
 * @return note that when storing insert size on the secondEnd, the return value must be negated.
 */
public static int computeInsertSize(final SAMRecord firstEnd,final SAMRecord secondEnd){
  if (firstEnd.getReadUnmappedFlag() || secondEnd.getReadUnmappedFlag()) {
    return 0;
  }
  if (!firstEnd.getReferenceName().equals(secondEnd.getReferenceName())) {
    return 0;
  }
  int firstEnd5PrimePosition=firstEnd.getReadNegativeStrandFlag() ? firstEnd.getAlignmentEnd() : firstEnd.getAlignmentStart();
  int secondEnd5PrimePosition=secondEnd.getReadNegativeStrandFlag() ? secondEnd.getAlignmentEnd() : secondEnd.getAlignmentStart();
  return CoordMath.getLength(firstEnd5PrimePosition,secondEnd5PrimePosition);
}",0.9699296225207934
30641,"private void parseBarcodeFile(final ArrayList<String> messages){
  final TabbedTextFileWithHeaderParser barcodesParser=new TabbedTextFileWithHeaderParser(BARCODE_FILE);
  final String sequenceColumn=barcodesParser.hasColumn(BARCODE_SEQUENCE_COLUMN) ? BARCODE_SEQUENCE_COLUMN : barcodesParser.hasColumn(BARCODE_SEQUENCE_1_COLUMN) ? BARCODE_SEQUENCE_1_COLUMN : null;
  if (sequenceColumn == null) {
    messages.add(BARCODE_FILE + ""String_Node_Str"" + BARCODE_SEQUENCE_COLUMN+ ""String_Node_Str""+ BARCODE_SEQUENCE_1_COLUMN+ ""String_Node_Str"");
    return;
  }
  final boolean hasBarcodeName=barcodesParser.hasColumn(BARCODE_NAME_COLUMN);
  final boolean hasLibraryName=barcodesParser.hasColumn(LIBRARY_NAME_COLUMN);
  final int numBarcodes=readStructure.barcodeIndices.length;
  final Set<String> barcodes=new HashSet<String>();
  for (  final TabbedTextFileWithHeaderParser.Row row : barcodesParser) {
    final String bcStrings[]=new String[numBarcodes];
    int barcodeNum=1;
    for (    final ReadDescriptor rd : readStructure.descriptors) {
      if (rd.type != ReadType.Barcode)       continue;
      final String header=barcodeNum == 1 ? sequenceColumn : ""String_Node_Str"" + String.valueOf(barcodeNum);
      bcStrings[barcodeNum - 1]=row.getField(header);
      barcodeNum++;
    }
    final String bcStr=barcodeSeqsToString(bcStrings,barcodeDelimiter);
    if (barcodes.contains(bcStr)) {
      messages.add(""String_Node_Str"" + bcStr + ""String_Node_Str""+ BARCODE_FILE);
    }
    barcodes.add(bcStr);
    final String barcodeName=(hasBarcodeName ? row.getField(BARCODE_NAME_COLUMN) : ""String_Node_Str"");
    final String libraryName=(hasLibraryName ? row.getField(LIBRARY_NAME_COLUMN) : ""String_Node_Str"");
    final BarcodeMetric metric=new BarcodeMetric(barcodeName,libraryName,bcStr,bcStrings);
    barcodeMetrics.add(metric);
  }
}","private void parseBarcodeFile(final ArrayList<String> messages){
  final TabbedTextFileWithHeaderParser barcodesParser=new TabbedTextFileWithHeaderParser(BARCODE_FILE);
  final String sequenceColumn=barcodesParser.hasColumn(BARCODE_SEQUENCE_COLUMN) ? BARCODE_SEQUENCE_COLUMN : barcodesParser.hasColumn(BARCODE_SEQUENCE_1_COLUMN) ? BARCODE_SEQUENCE_1_COLUMN : null;
  if (sequenceColumn == null) {
    messages.add(BARCODE_FILE + ""String_Node_Str"" + BARCODE_SEQUENCE_COLUMN+ ""String_Node_Str""+ BARCODE_SEQUENCE_1_COLUMN+ ""String_Node_Str"");
    return;
  }
  final boolean hasBarcodeName=barcodesParser.hasColumn(BARCODE_NAME_COLUMN);
  final boolean hasLibraryName=barcodesParser.hasColumn(LIBRARY_NAME_COLUMN);
  final int numBarcodes=readStructure.barcodeIndices.length;
  final Set<String> barcodes=new HashSet<String>();
  for (  final TabbedTextFileWithHeaderParser.Row row : barcodesParser) {
    final String bcStrings[]=new String[numBarcodes];
    int barcodeNum=1;
    for (    final ReadDescriptor rd : readStructure.descriptors) {
      if (rd.type != ReadType.Barcode)       continue;
      final String header=barcodeNum == 1 ? sequenceColumn : ""String_Node_Str"" + String.valueOf(barcodeNum);
      bcStrings[barcodeNum - 1]=row.getField(header);
      barcodeNum++;
    }
    final String bcStr=barcodeSeqsToString(bcStrings,barcodeDelimiter);
    if (barcodes.contains(bcStr)) {
      messages.add(""String_Node_Str"" + bcStr + ""String_Node_Str""+ BARCODE_FILE);
    }
    barcodes.add(bcStr);
    final String barcodeName=(hasBarcodeName ? row.getField(BARCODE_NAME_COLUMN) : ""String_Node_Str"");
    final String libraryName=(hasLibraryName ? row.getField(LIBRARY_NAME_COLUMN) : ""String_Node_Str"");
    final BarcodeMetric metric=new BarcodeMetric(barcodeName,libraryName,bcStr,bcStrings);
    barcodeMetrics.add(metric);
  }
  barcodesParser.close();
}",0.9929881337648327
30642,"/** 
 * Validate that POSITION >= 1, and that all BARCODEs are the same length and unique
 * @return null if command line is valid.  If command line is invalid, returns an array of error messageto be written to the appropriate place.
 */
@Override protected String[] customCommandLineValidation(){
  if (READ_STRUCTURE == null) {
    factory=new IlluminaDataProviderFactory(BASECALLS_DIR,LANE,BARCODE_CYCLE,BARCODE.get(0).length(),IlluminaDataType.BaseCalls,IlluminaDataType.PF);
    readStructure=factory.readStructure();
  }
 else {
    readStructure=new ReadStructure(READ_STRUCTURE);
    factory=new IlluminaDataProviderFactory(BASECALLS_DIR,LANE,readStructure,IlluminaDataType.BaseCalls,IlluminaDataType.PF);
  }
  final ArrayList<String> messages=new ArrayList<String>();
  if (READ_STRUCTURE == null && BARCODE_CYCLE < 1) {
    messages.add(""String_Node_Str"" + BARCODE_CYCLE + ""String_Node_Str"");
  }
  if (BARCODE_FILE != null) {
    parseBarcodeFile(messages);
  }
 else {
    final Set<String> barcodes=new HashSet<String>();
    for (    final String barcode : BARCODE) {
      if (barcodes.contains(barcode)) {
        messages.add(""String_Node_Str"" + barcode + ""String_Node_Str"");
      }
      barcodes.add(barcode);
      final BarcodeMetric metric=new BarcodeMetric(null,null,barcode,new String[]{barcode});
      barcodeMetrics.add(metric);
    }
  }
  if (barcodeMetrics.size() == 0) {
    messages.add(""String_Node_Str"");
  }
  if (messages.size() == 0) {
    return null;
  }
  return messages.toArray(new String[messages.size()]);
}","/** 
 * Validate that POSITION >= 1, and that all BARCODEs are the same length and unique
 * @return null if command line is valid.  If command line is invalid, returns an array of error messageto be written to the appropriate place.
 */
@Override protected String[] customCommandLineValidation(){
  final ArrayList<String> messages=new ArrayList<String>();
  if (READ_STRUCTURE == null) {
    int barcodeLength=0;
    if (BARCODE == null || BARCODE.size() == 0) {
      if (BARCODE_FILE != null)       barcodeLength=getBarcodeLengthFromFile();
    }
 else {
      barcodeLength=BARCODE.get(0).length();
    }
    if (barcodeLength == 0)     messages.add(""String_Node_Str"");
    log.debug(""String_Node_Str"" + barcodeLength);
    factory=new IlluminaDataProviderFactory(BASECALLS_DIR,LANE,BARCODE_CYCLE,barcodeLength,IlluminaDataType.BaseCalls,IlluminaDataType.PF);
    readStructure=factory.readStructure();
  }
 else {
    readStructure=new ReadStructure(READ_STRUCTURE);
    factory=new IlluminaDataProviderFactory(BASECALLS_DIR,LANE,readStructure,IlluminaDataType.BaseCalls,IlluminaDataType.PF);
  }
  if (READ_STRUCTURE == null && BARCODE_CYCLE < 1) {
    messages.add(""String_Node_Str"" + BARCODE_CYCLE + ""String_Node_Str"");
  }
  if (BARCODE_FILE != null) {
    parseBarcodeFile(messages);
  }
 else {
    final Set<String> barcodes=new HashSet<String>();
    for (    final String barcode : BARCODE) {
      if (barcodes.contains(barcode)) {
        messages.add(""String_Node_Str"" + barcode + ""String_Node_Str"");
      }
      barcodes.add(barcode);
      final BarcodeMetric metric=new BarcodeMetric(null,null,barcode,new String[]{barcode});
      barcodeMetrics.add(metric);
    }
  }
  if (barcodeMetrics.size() == 0) {
    messages.add(""String_Node_Str"");
  }
  if (messages.size() == 0) {
    return null;
  }
  return messages.toArray(new String[messages.size()]);
}",0.8598076362576508
30643,"/** 
 * Combines multiple SAM/BAM files into one. 
 */
@Override protected int doWork(){
  boolean matchedSortOrders=true;
  final List<SAMFileReader> readers=new ArrayList<SAMFileReader>();
  final List<SAMFileHeader> headers=new ArrayList<SAMFileHeader>();
{
    SAMSequenceDictionary dict=null;
    for (    final File inFile : INPUT) {
      IoUtil.assertFileIsReadable(inFile);
      final SAMFileReader in=new SAMFileReader(inFile);
      readers.add(in);
      headers.add(in.getFileHeader());
      if (dict == null) {
        dict=in.getFileHeader().getSequenceDictionary();
      }
 else       if (dict.equals(in.getFileHeader().getSequenceDictionary())) {
        in.getFileHeader().setSequenceDictionary(dict);
      }
      matchedSortOrders=matchedSortOrders && in.getFileHeader().getSortOrder() == SORT_ORDER;
    }
  }
  IoUtil.assertFileIsWritable(OUTPUT);
  final boolean presorted;
  final SAMFileHeader.SortOrder headerMergerSortOrder;
  final boolean mergingSamRecordIteratorAssumeSorted;
  if (matchedSortOrders || SORT_ORDER == SAMFileHeader.SortOrder.unsorted || ASSUME_SORTED) {
    log.info(""String_Node_Str"");
    headerMergerSortOrder=SORT_ORDER;
    mergingSamRecordIteratorAssumeSorted=ASSUME_SORTED;
    presorted=true;
  }
 else {
    log.info(""String_Node_Str"" + TMP_DIR);
    headerMergerSortOrder=SAMFileHeader.SortOrder.unsorted;
    mergingSamRecordIteratorAssumeSorted=false;
    presorted=false;
  }
  final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(headerMergerSortOrder,headers,MERGE_SEQUENCE_DICTIONARIES);
  final MergingSamRecordIterator iterator=new MergingSamRecordIterator(headerMerger,readers,mergingSamRecordIteratorAssumeSorted);
  final SAMFileHeader header=headerMerger.getMergedHeader();
  for (  String comment : COMMENT) {
    header.addComment(comment);
  }
  header.setSortOrder(SORT_ORDER);
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,presorted,OUTPUT);
  if (USE_THREADING) {
    final BlockingQueue<SAMRecord> queue=new ArrayBlockingQueue<SAMRecord>(10000);
    final AtomicBoolean producerSuccceeded=new AtomicBoolean(false);
    final AtomicBoolean consumerSuccceeded=new AtomicBoolean(false);
    Runnable producer=new Runnable(){
      public void run(){
        try {
          while (iterator.hasNext()) {
            queue.put(iterator.next());
          }
          producerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Runnable consumer=new Runnable(){
      public void run(){
        try {
          long i=0;
          SAMRecord rec=null;
          while ((rec=queue.poll(15,TimeUnit.SECONDS)) != null) {
            out.addAlignment(rec);
            if (++i % PROGRESS_INTERVAL == 0)             log.info(i + ""String_Node_Str"");
          }
          consumerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Thread producerThread=new Thread(producer);
    Thread consumerThread=new Thread(consumer);
    producerThread.start();
    consumerThread.start();
    try {
      consumerThread.join();
      producerThread.join();
    }
 catch (    InterruptedException ie) {
      throw new PicardException(""String_Node_Str"",ie);
    }
    if (!producerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
    if (!consumerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
  }
 else {
    for (long numRecords=1; iterator.hasNext(); ++numRecords) {
      final SAMRecord record=iterator.next();
      out.addAlignment(record);
      if (numRecords % PROGRESS_INTERVAL == 0) {
        log.info(numRecords + ""String_Node_Str"");
      }
    }
  }
  log.info(""String_Node_Str"");
  out.close();
  return 0;
}","/** 
 * Combines multiple SAM/BAM files into one. 
 */
@Override protected int doWork(){
  boolean matchedSortOrders=true;
  final List<SAMFileReader> readers=new ArrayList<SAMFileReader>();
  final List<SAMFileHeader> headers=new ArrayList<SAMFileHeader>();
{
    SAMSequenceDictionary dict=null;
    for (    final File inFile : INPUT) {
      IoUtil.assertFileIsReadable(inFile);
      final SAMFileReader in=new SAMFileReader(inFile);
      readers.add(in);
      headers.add(in.getFileHeader());
      if (dict == null) {
        dict=in.getFileHeader().getSequenceDictionary();
      }
 else       if (dict.equals(in.getFileHeader().getSequenceDictionary())) {
        in.getFileHeader().setSequenceDictionary(dict);
      }
      matchedSortOrders=matchedSortOrders && in.getFileHeader().getSortOrder() == SORT_ORDER;
    }
  }
  IoUtil.assertFileIsWritable(OUTPUT);
  final boolean presorted;
  final SAMFileHeader.SortOrder headerMergerSortOrder;
  final boolean mergingSamRecordIteratorAssumeSorted;
  if (matchedSortOrders || SORT_ORDER == SAMFileHeader.SortOrder.unsorted || ASSUME_SORTED) {
    log.info(""String_Node_Str"");
    headerMergerSortOrder=SORT_ORDER;
    mergingSamRecordIteratorAssumeSorted=ASSUME_SORTED;
    presorted=true;
  }
 else {
    log.info(""String_Node_Str"" + TMP_DIR);
    headerMergerSortOrder=SAMFileHeader.SortOrder.unsorted;
    mergingSamRecordIteratorAssumeSorted=false;
    presorted=false;
  }
  final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(headerMergerSortOrder,headers,MERGE_SEQUENCE_DICTIONARIES);
  final MergingSamRecordIterator iterator=new MergingSamRecordIterator(headerMerger,readers,mergingSamRecordIteratorAssumeSorted);
  final SAMFileHeader header=headerMerger.getMergedHeader();
  for (  String comment : COMMENT) {
    header.addComment(comment);
  }
  header.setSortOrder(SORT_ORDER);
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,presorted,OUTPUT);
  if (USE_THREADING) {
    final BlockingQueue<SAMRecord> queue=new ArrayBlockingQueue<SAMRecord>(10000);
    final AtomicBoolean producerSuccceeded=new AtomicBoolean(false);
    final AtomicBoolean consumerSuccceeded=new AtomicBoolean(false);
    Runnable producer=new Runnable(){
      public void run(){
        try {
          while (iterator.hasNext()) {
            queue.put(iterator.next());
          }
          producerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Runnable consumer=new Runnable(){
      public void run(){
        try {
          long i=0;
          while (!producerSuccceeded.get()) {
            SAMRecord rec=queue.poll(15,TimeUnit.SECONDS);
            if (rec != null) {
              out.addAlignment(rec);
              if (++i % PROGRESS_INTERVAL == 0)               log.info(i + ""String_Node_Str"");
            }
          }
          consumerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Thread producerThread=new Thread(producer);
    Thread consumerThread=new Thread(consumer);
    producerThread.start();
    consumerThread.start();
    try {
      consumerThread.join();
      producerThread.join();
    }
 catch (    InterruptedException ie) {
      throw new PicardException(""String_Node_Str"",ie);
    }
    if (!producerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
    if (!consumerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
  }
 else {
    for (long numRecords=1; iterator.hasNext(); ++numRecords) {
      final SAMRecord record=iterator.next();
      out.addAlignment(record);
      if (numRecords % PROGRESS_INTERVAL == 0) {
        log.info(numRecords + ""String_Node_Str"");
      }
    }
  }
  log.info(""String_Node_Str"");
  out.close();
  return 0;
}",0.98501397002794
30644,"public void run(){
  try {
    long i=0;
    SAMRecord rec=null;
    while ((rec=queue.poll(15,TimeUnit.SECONDS)) != null) {
      out.addAlignment(rec);
      if (++i % PROGRESS_INTERVAL == 0)       log.info(i + ""String_Node_Str"");
    }
    consumerSuccceeded.set(true);
  }
 catch (  InterruptedException ie) {
    throw new PicardException(""String_Node_Str"",ie);
  }
}","public void run(){
  try {
    long i=0;
    while (!producerSuccceeded.get()) {
      SAMRecord rec=queue.poll(15,TimeUnit.SECONDS);
      if (rec != null) {
        out.addAlignment(rec);
        if (++i % PROGRESS_INTERVAL == 0)         log.info(i + ""String_Node_Str"");
      }
    }
    consumerSuccceeded.set(true);
  }
 catch (  InterruptedException ie) {
    throw new PicardException(""String_Node_Str"",ie);
  }
}",0.8813131313131313
30645,"/** 
 * Combines multiple SAM/BAM files into one. 
 */
@Override protected int doWork(){
  boolean matchedSortOrders=true;
  final List<SAMFileReader> readers=new ArrayList<SAMFileReader>();
  final List<SAMFileHeader> headers=new ArrayList<SAMFileHeader>();
{
    SAMSequenceDictionary dict=null;
    for (    final File inFile : INPUT) {
      IoUtil.assertFileIsReadable(inFile);
      final SAMFileReader in=new SAMFileReader(inFile);
      readers.add(in);
      headers.add(in.getFileHeader());
      if (dict == null) {
        dict=in.getFileHeader().getSequenceDictionary();
      }
 else       if (dict.equals(in.getFileHeader().getSequenceDictionary())) {
        in.getFileHeader().setSequenceDictionary(dict);
      }
      matchedSortOrders=matchedSortOrders && in.getFileHeader().getSortOrder() == SORT_ORDER;
    }
  }
  IoUtil.assertFileIsWritable(OUTPUT);
  final boolean presorted;
  final SAMFileHeader.SortOrder headerMergerSortOrder;
  final boolean mergingSamRecordIteratorAssumeSorted;
  if (matchedSortOrders || SORT_ORDER == SAMFileHeader.SortOrder.unsorted || ASSUME_SORTED) {
    log.info(""String_Node_Str"");
    headerMergerSortOrder=SORT_ORDER;
    mergingSamRecordIteratorAssumeSorted=ASSUME_SORTED;
    presorted=true;
  }
 else {
    log.info(""String_Node_Str"" + TMP_DIR);
    headerMergerSortOrder=SAMFileHeader.SortOrder.unsorted;
    mergingSamRecordIteratorAssumeSorted=false;
    presorted=false;
  }
  final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(headerMergerSortOrder,headers,MERGE_SEQUENCE_DICTIONARIES);
  final MergingSamRecordIterator iterator=new MergingSamRecordIterator(headerMerger,readers,mergingSamRecordIteratorAssumeSorted);
  final SAMFileHeader header=headerMerger.getMergedHeader();
  for (  String comment : COMMENT) {
    header.addComment(comment);
  }
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,presorted,OUTPUT);
  if (USE_THREADING) {
    final BlockingQueue<SAMRecord> queue=new ArrayBlockingQueue<SAMRecord>(10000);
    final AtomicBoolean producerSuccceeded=new AtomicBoolean(false);
    final AtomicBoolean consumerSuccceeded=new AtomicBoolean(false);
    Runnable producer=new Runnable(){
      public void run(){
        try {
          while (iterator.hasNext()) {
            queue.put(iterator.next());
          }
          producerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Runnable consumer=new Runnable(){
      public void run(){
        try {
          long i=0;
          SAMRecord rec=null;
          while ((rec=queue.poll(15,TimeUnit.SECONDS)) != null) {
            out.addAlignment(rec);
            if (++i % PROGRESS_INTERVAL == 0)             log.info(i + ""String_Node_Str"");
          }
          consumerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Thread producerThread=new Thread(producer);
    Thread consumerThread=new Thread(consumer);
    producerThread.start();
    consumerThread.start();
    try {
      consumerThread.join();
      producerThread.join();
    }
 catch (    InterruptedException ie) {
      throw new PicardException(""String_Node_Str"",ie);
    }
    if (!producerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
    if (!consumerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
  }
 else {
    for (long numRecords=1; iterator.hasNext(); ++numRecords) {
      final SAMRecord record=iterator.next();
      out.addAlignment(record);
      if (numRecords % PROGRESS_INTERVAL == 0) {
        log.info(numRecords + ""String_Node_Str"");
      }
    }
  }
  log.info(""String_Node_Str"");
  out.close();
  return 0;
}","/** 
 * Combines multiple SAM/BAM files into one. 
 */
@Override protected int doWork(){
  boolean matchedSortOrders=true;
  final List<SAMFileReader> readers=new ArrayList<SAMFileReader>();
  final List<SAMFileHeader> headers=new ArrayList<SAMFileHeader>();
{
    SAMSequenceDictionary dict=null;
    for (    final File inFile : INPUT) {
      IoUtil.assertFileIsReadable(inFile);
      final SAMFileReader in=new SAMFileReader(inFile);
      readers.add(in);
      headers.add(in.getFileHeader());
      if (dict == null) {
        dict=in.getFileHeader().getSequenceDictionary();
      }
 else       if (dict.equals(in.getFileHeader().getSequenceDictionary())) {
        in.getFileHeader().setSequenceDictionary(dict);
      }
      matchedSortOrders=matchedSortOrders && in.getFileHeader().getSortOrder() == SORT_ORDER;
    }
  }
  IoUtil.assertFileIsWritable(OUTPUT);
  final boolean presorted;
  final SAMFileHeader.SortOrder headerMergerSortOrder;
  final boolean mergingSamRecordIteratorAssumeSorted;
  if (matchedSortOrders || SORT_ORDER == SAMFileHeader.SortOrder.unsorted || ASSUME_SORTED) {
    log.info(""String_Node_Str"");
    headerMergerSortOrder=SORT_ORDER;
    mergingSamRecordIteratorAssumeSorted=ASSUME_SORTED;
    presorted=true;
  }
 else {
    log.info(""String_Node_Str"" + TMP_DIR);
    headerMergerSortOrder=SAMFileHeader.SortOrder.unsorted;
    mergingSamRecordIteratorAssumeSorted=false;
    presorted=false;
  }
  final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(headerMergerSortOrder,headers,MERGE_SEQUENCE_DICTIONARIES);
  final MergingSamRecordIterator iterator=new MergingSamRecordIterator(headerMerger,readers,mergingSamRecordIteratorAssumeSorted);
  final SAMFileHeader header=headerMerger.getMergedHeader();
  for (  String comment : COMMENT) {
    header.addComment(comment);
  }
  header.setSortOrder(SORT_ORDER);
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,presorted,OUTPUT);
  if (USE_THREADING) {
    final BlockingQueue<SAMRecord> queue=new ArrayBlockingQueue<SAMRecord>(10000);
    final AtomicBoolean producerSuccceeded=new AtomicBoolean(false);
    final AtomicBoolean consumerSuccceeded=new AtomicBoolean(false);
    Runnable producer=new Runnable(){
      public void run(){
        try {
          while (iterator.hasNext()) {
            queue.put(iterator.next());
          }
          producerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Runnable consumer=new Runnable(){
      public void run(){
        try {
          long i=0;
          SAMRecord rec=null;
          while ((rec=queue.poll(15,TimeUnit.SECONDS)) != null) {
            out.addAlignment(rec);
            if (++i % PROGRESS_INTERVAL == 0)             log.info(i + ""String_Node_Str"");
          }
          consumerSuccceeded.set(true);
        }
 catch (        InterruptedException ie) {
          throw new PicardException(""String_Node_Str"",ie);
        }
      }
    }
;
    Thread producerThread=new Thread(producer);
    Thread consumerThread=new Thread(consumer);
    producerThread.start();
    consumerThread.start();
    try {
      consumerThread.join();
      producerThread.join();
    }
 catch (    InterruptedException ie) {
      throw new PicardException(""String_Node_Str"",ie);
    }
    if (!producerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
    if (!consumerSuccceeded.get()) {
      throw new PicardException(""String_Node_Str"");
    }
  }
 else {
    for (long numRecords=1; iterator.hasNext(); ++numRecords) {
      final SAMRecord record=iterator.next();
      out.addAlignment(record);
      if (numRecords % PROGRESS_INTERVAL == 0) {
        log.info(numRecords + ""String_Node_Str"");
      }
    }
  }
  log.info(""String_Node_Str"");
  out.close();
  return 0;
}",0.9955007070317522
30646,"/** 
 * Reads a whole line. A line is considered to be terminated by a line feed ('\n')
 * @return  A String containing the contents of the line, excluding the line terminatingcharacter, or null if the end of the stream has been reached
 * @exception IOException  If an I/O error occurs
 */
public String readLine() throws IOException {
  int available=available();
  if (available == 0) {
    return null;
  }
  buf.setLength(0);
  boolean done=false;
  while (!done) {
    int linetmpPos=mCurrentOffset;
    int bCnt=0;
    while ((available-- > 0)) {
      final byte c=mCurrentBlock[linetmpPos++];
      if (c == eol) {
        done=true;
        break;
      }
      ++bCnt;
    }
    if (mCurrentOffset < linetmpPos) {
      buf.append(new String(mCurrentBlock,mCurrentOffset,bCnt));
      mCurrentOffset=linetmpPos;
    }
    available=available();
    if (available == 0) {
      done=true;
    }
  }
  return buf.toString();
}","/** 
 * Reads a whole line. A line is considered to be terminated by either a line feed ('\n'),  carriage return ('\r') or carriage return followed by a line feed (""\r\n"").
 * @return  A String containing the contents of the line, excluding the line terminatingcharacter, or null if the end of the stream has been reached
 * @exception IOException  If an I/O error occurs
 * @
 */
public String readLine() throws IOException {
  int available=available();
  if (available == 0) {
    return null;
  }
  buf.reset();
  boolean done=false;
  boolean foundCr=false;
  while (!done) {
    int linetmpPos=mCurrentOffset;
    int bCnt=0;
    while ((available-- > 0)) {
      final byte c=mCurrentBlock[linetmpPos++];
      if (c == eol) {
        done=true;
        break;
      }
 else       if (foundCr) {
        --linetmpPos;
        done=true;
        break;
      }
 else       if (c == eolCr) {
        foundCr=true;
        continue;
      }
      ++bCnt;
    }
    if (mCurrentOffset < linetmpPos) {
      buf.write(mCurrentBlock,mCurrentOffset,bCnt);
      mCurrentOffset=linetmpPos;
    }
    available=available();
    if (available == 0) {
      done=true;
    }
  }
  return buf.toString();
}",0.8333333333333334
30647,"public int instanceMain(final String[] argv){
  if (!parseArgs(argv)) {
    return 1;
  }
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  final Date startDate=new Date();
  this.defaultHeaders.add(new StringHeader(commandLine));
  this.defaultHeaders.add(new StringHeader(""String_Node_Str"" + startDate));
  Log.setGlobalLogLevel(VERBOSITY);
  SAMFileReader.ValidationStringency originalStringency=SAMFileReader.getDefaultValidationStringency();
  SAMFileReader.setDefaultValidationStringency(VALIDATION_STRINGENCY);
  BlockCompressedOutputStream.setDefaultCompressionLevel(COMPRESSION_LEVEL);
  if (MAX_RECORDS_IN_RAM != null) {
    SAMFileWriterImpl.setDefaultMaxRecordsInRam(MAX_RECORDS_IN_RAM);
  }
  if (CREATE_INDEX) {
    SAMFileWriterFactory.setDefaultCreateIndexWhileWriting(true);
  }
  SAMFileWriterFactory.setDefaultCreateMd5File(CREATE_MD5_FILE);
  if (!TMP_DIR.exists()) {
    TMP_DIR.mkdirs();
  }
  System.setProperty(""String_Node_Str"",TMP_DIR.getAbsolutePath());
  if (!QUIET) {
    System.err.println(""String_Node_Str"" + new Date() + ""String_Node_Str""+ commandLine);
  }
  final int ret;
  try {
    ret=doWork();
  }
  finally {
    SAMFileReader.setDefaultValidationStringency(originalStringency);
    try {
      if (!QUIET) {
        final Date endDate=new Date();
        final double elapsedMinutes=(endDate.getTime() - startDate.getTime()) / (1000d * 60d);
        final String elapsedString=new DecimalFormat(""String_Node_Str"").format(elapsedMinutes);
        System.err.println(""String_Node_Str"" + endDate + ""String_Node_Str""+ getClass().getName()+ ""String_Node_Str""+ elapsedString+ ""String_Node_Str"");
        System.err.println(""String_Node_Str"" + Runtime.getRuntime().totalMemory());
      }
    }
 catch (    Throwable e) {
    }
  }
  return ret;
}","public int instanceMain(final String[] argv){
  if (!parseArgs(argv)) {
    return 1;
  }
  final Date startDate=new Date();
  this.defaultHeaders.add(new StringHeader(commandLine));
  this.defaultHeaders.add(new StringHeader(""String_Node_Str"" + startDate));
  Log.setGlobalLogLevel(VERBOSITY);
  SAMFileReader.ValidationStringency originalStringency=SAMFileReader.getDefaultValidationStringency();
  SAMFileReader.setDefaultValidationStringency(VALIDATION_STRINGENCY);
  BlockCompressedOutputStream.setDefaultCompressionLevel(COMPRESSION_LEVEL);
  if (MAX_RECORDS_IN_RAM != null) {
    SAMFileWriterImpl.setDefaultMaxRecordsInRam(MAX_RECORDS_IN_RAM);
  }
  if (CREATE_INDEX) {
    SAMFileWriterFactory.setDefaultCreateIndexWhileWriting(true);
  }
  SAMFileWriterFactory.setDefaultCreateMd5File(CREATE_MD5_FILE);
  if (!TMP_DIR.exists()) {
    TMP_DIR.mkdirs();
  }
  System.setProperty(""String_Node_Str"",TMP_DIR.getAbsolutePath());
  if (!QUIET) {
    System.err.println(""String_Node_Str"" + new Date() + ""String_Node_Str""+ commandLine);
  }
  final int ret;
  try {
    ret=doWork();
  }
  finally {
    SAMFileReader.setDefaultValidationStringency(originalStringency);
    try {
      if (!QUIET) {
        final Date endDate=new Date();
        final double elapsedMinutes=(endDate.getTime() - startDate.getTime()) / (1000d * 60d);
        final String elapsedString=new DecimalFormat(""String_Node_Str"").format(elapsedMinutes);
        System.err.println(""String_Node_Str"" + endDate + ""String_Node_Str""+ getClass().getName()+ ""String_Node_Str""+ elapsedString+ ""String_Node_Str"");
        System.err.println(""String_Node_Str"" + Runtime.getRuntime().totalMemory());
      }
    }
 catch (    Throwable e) {
    }
  }
  return ret;
}",0.9832624113475176
30648,"public SnappyLoader(final boolean verbose){
  Constructor<InputStream> inputStreamCtor=null;
  Constructor<OutputStream> outputStreamCtor=null;
  if (java.lang.Boolean.valueOf(System.getProperty(""String_Node_Str"",""String_Node_Str""))) {
    System.err.println(""String_Node_Str"");
  }
 else {
    try {
      final Class<InputStream> snappyInputStreamClass=(Class<InputStream>)Class.forName(""String_Node_Str"");
      final Class<OutputStream> snappyOutputStreamClass=(Class<OutputStream>)Class.forName(""String_Node_Str"");
      inputStreamCtor=snappyInputStreamClass.getConstructor(InputStream.class);
      outputStreamCtor=snappyOutputStreamClass.getConstructor(OutputStream.class);
    }
 catch (    NoSuchMethodException e) {
    }
catch (    ClassNotFoundException e) {
    }
  }
  SnappyInputStreamCtor=inputStreamCtor;
  SnappyOutputStreamCtor=outputStreamCtor;
  if (SnappyInputStreamCtor != null && SnappyOutputStreamCtor != null) {
    if (!LoadSnappy.load()) {
      if (verbose)       System.err.println(""String_Node_Str"");
      SnappyAvailable=false;
    }
 else {
      SnappyAvailable=true;
      if (verbose)       System.err.println(""String_Node_Str"");
    }
  }
 else {
    SnappyAvailable=false;
    if (verbose)     System.err.println(""String_Node_Str"");
  }
}","public SnappyLoader(final boolean verbose){
  Constructor<InputStream> inputStreamCtor=null;
  Constructor<OutputStream> outputStreamCtor=null;
  if (true || java.lang.Boolean.valueOf(System.getProperty(""String_Node_Str"",""String_Node_Str""))) {
    System.err.println(""String_Node_Str"");
  }
 else {
    try {
      final Class<InputStream> snappyInputStreamClass=(Class<InputStream>)Class.forName(""String_Node_Str"");
      final Class<OutputStream> snappyOutputStreamClass=(Class<OutputStream>)Class.forName(""String_Node_Str"");
      inputStreamCtor=snappyInputStreamClass.getConstructor(InputStream.class);
      outputStreamCtor=snappyOutputStreamClass.getConstructor(OutputStream.class);
    }
 catch (    NoSuchMethodException e) {
    }
catch (    ClassNotFoundException e) {
    }
  }
  SnappyInputStreamCtor=inputStreamCtor;
  SnappyOutputStreamCtor=outputStreamCtor;
  if (SnappyInputStreamCtor != null && SnappyOutputStreamCtor != null) {
    if (!LoadSnappy.load()) {
      if (verbose)       System.err.println(""String_Node_Str"");
      SnappyAvailable=false;
    }
 else {
      SnappyAvailable=true;
      if (verbose)       System.err.println(""String_Node_Str"");
    }
  }
 else {
    SnappyAvailable=false;
    if (verbose)     System.err.println(""String_Node_Str"");
  }
}",0.9968823070927514
30649,"OverlapDetector<Gene> load(){
  final OverlapDetector<Gene> overlapDetector=new OverlapDetector<Gene>(0,0);
  final int expectedColumns=RefFlatColumns.values().length;
  final TabbedTextFileWithHeaderParser parser=new TabbedTextFileWithHeaderParser(refFlatFile,RefFlatColumnLabels);
  final Map<String,List<TabbedTextFileWithHeaderParser.Row>> refFlatLinesByGene=new HashMap<String,List<TabbedTextFileWithHeaderParser.Row>>();
  for (  final TabbedTextFileWithHeaderParser.Row row : parser) {
    final int lineNumber=parser.getCurrentLineNumber() - 1;
    if (row.getFields().length != expectedColumns) {
      throw new AnnotationException(""String_Node_Str"" + refFlatFile + ""String_Node_Str""+ lineNumber);
    }
    final String geneName=row.getField(RefFlatColumns.GENE_NAME.name());
    final String transcriptName=row.getField(RefFlatColumns.TRANSCRIPT_NAME.name());
    final String transcriptDescription=geneName + ""String_Node_Str"" + transcriptName;
    final String chromosome=row.getField(RefFlatColumns.CHROMOSOME.name());
    if (!isSequenceRecognized(chromosome)) {
      LOG.debug(""String_Node_Str"" + transcriptDescription + ""String_Node_Str""+ chromosome);
    }
 else {
      List<TabbedTextFileWithHeaderParser.Row> transcriptLines=refFlatLinesByGene.get(geneName);
      if (transcriptLines == null) {
        transcriptLines=new ArrayList<TabbedTextFileWithHeaderParser.Row>();
        refFlatLinesByGene.put(geneName,transcriptLines);
      }
      transcriptLines.add(row);
    }
  }
  int longestInterval=0;
  int numIntervalsOver1MB=0;
  for (  final List<TabbedTextFileWithHeaderParser.Row> transcriptLines : refFlatLinesByGene.values()) {
    try {
      final Gene gene=makeGeneFromRefFlatLines(transcriptLines);
      overlapDetector.addLhs(gene,gene);
      if (gene.length() > longestInterval)       longestInterval=gene.length();
      if (gene.length() > 1000000)       ++numIntervalsOver1MB;
    }
 catch (    AnnotationException e) {
      LOG.debug(e.getMessage() + ""String_Node_Str"");
    }
  }
  LOG.debug(""String_Node_Str"" + longestInterval + ""String_Node_Str""+ numIntervalsOver1MB);
  return overlapDetector;
}","OverlapDetector<Gene> load(){
  final OverlapDetector<Gene> overlapDetector=new OverlapDetector<Gene>(0,0);
  final int expectedColumns=RefFlatColumns.values().length;
  final TabbedTextFileWithHeaderParser parser=new TabbedTextFileWithHeaderParser(refFlatFile,RefFlatColumnLabels);
  final Map<String,List<TabbedTextFileWithHeaderParser.Row>> refFlatLinesByGene=new HashMap<String,List<TabbedTextFileWithHeaderParser.Row>>();
  for (  final TabbedTextFileWithHeaderParser.Row row : parser) {
    final int lineNumber=parser.getCurrentLineNumber();
    if (row.getFields().length != expectedColumns) {
      throw new AnnotationException(""String_Node_Str"" + refFlatFile + ""String_Node_Str""+ lineNumber);
    }
    final String geneName=row.getField(RefFlatColumns.GENE_NAME.name());
    final String transcriptName=row.getField(RefFlatColumns.TRANSCRIPT_NAME.name());
    final String transcriptDescription=geneName + ""String_Node_Str"" + transcriptName;
    final String chromosome=row.getField(RefFlatColumns.CHROMOSOME.name());
    if (!isSequenceRecognized(chromosome)) {
      LOG.debug(""String_Node_Str"" + transcriptDescription + ""String_Node_Str""+ chromosome);
    }
 else {
      List<TabbedTextFileWithHeaderParser.Row> transcriptLines=refFlatLinesByGene.get(geneName);
      if (transcriptLines == null) {
        transcriptLines=new ArrayList<TabbedTextFileWithHeaderParser.Row>();
        refFlatLinesByGene.put(geneName,transcriptLines);
      }
      transcriptLines.add(row);
    }
  }
  int longestInterval=0;
  int numIntervalsOver1MB=0;
  for (  final List<TabbedTextFileWithHeaderParser.Row> transcriptLines : refFlatLinesByGene.values()) {
    try {
      final Gene gene=makeGeneFromRefFlatLines(transcriptLines);
      overlapDetector.addLhs(gene,gene);
      if (gene.length() > longestInterval)       longestInterval=gene.length();
      if (gene.length() > 1000000)       ++numIntervalsOver1MB;
    }
 catch (    AnnotationException e) {
      LOG.debug(e.getMessage() + ""String_Node_Str"");
    }
  }
  LOG.debug(""String_Node_Str"" + longestInterval + ""String_Node_Str""+ numIntervalsOver1MB);
  return overlapDetector;
}",0.9990675990675992
30650,"/** 
 * Read the next record from the list of input files, and load into data argument.
 * @param data Has already been set up appropriately for paired or single end read, barcoded or not.
 */
@Override public void next(final IlluminaReadData data){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  final int lineNumber=parser.getCurrentLineNumber();
  final String line=parser.getCurrentLine();
  try {
    final String[] fields=parser.next();
    processLine(data,fields);
  }
 catch (  RuntimeException re) {
    log.error(re,""String_Node_Str"" + parser.getFileName() + ""String_Node_Str""+ lineNumber+ ""String_Node_Str""+ line);
    throw re;
  }
}","/** 
 * Read the next record from the list of input files, and load into data argument.
 * @param data Has already been set up appropriately for paired or single end read, barcoded or not.
 */
@Override public void next(final IlluminaReadData data){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  try {
    final String[] fields=parser.next();
    processLine(data,fields);
  }
 catch (  RuntimeException re) {
    log.error(re,""String_Node_Str"" + parser.getFileName() + ""String_Node_Str""+ parser.getCurrentLineNumber()+ ""String_Node_Str""+ parser.getCurrentLine());
    throw re;
  }
}",0.8841607565011821
30651,"/** 
 * Workhorse method that reads the next line from the underlying reader
 * @return  String or null if there is no next line
 */
protected byte[] readNextLine(){
  try {
    final String line=reader.readLine();
    if (line != null) {
      currentLineNumber++;
      currentLine=line;
      return line.getBytes();
    }
    if (inputs.size() > 0) {
      currentFileName=fileNames.size() > 0 ? fileNames.remove(0) : null;
      currentLineNumber=0;
      reader=new AsciiLineReader(inputs.remove(0));
      return readNextLine();
    }
    return null;
  }
 catch (  RuntimeIOException ioe) {
    throw new PicardException(""String_Node_Str"" + currentFileName,ioe);
  }
}","/** 
 * Workhorse method that reads the next line from the underlying reader
 * @return  String or null if there is no next line
 */
protected byte[] readNextLine(){
  try {
    final String line=reader.readLine();
    if (nextLine != null && !isComment(nextLine.getBytes())) {
      currentLineNumber=nextLineNumber;
      currentLine=nextLine;
    }
    if (line != null) {
      nextLineNumber++;
      nextLine=line;
      return line.getBytes();
    }
    if (inputs.size() > 0) {
      currentFileName=fileNames.size() > 0 ? fileNames.remove(0) : null;
      nextLineNumber=0;
      nextLine=null;
      reader=new AsciiLineReader(inputs.remove(0));
      return readNextLine();
    }
    return null;
  }
 catch (  RuntimeIOException ioe) {
    throw new PicardException(""String_Node_Str"" + currentFileName,ioe);
  }
}",0.8834110592938041
30652,"@Override public Row next(){
  final String source=parser.getCurrentLine();
  final String[] fields=parser.next();
  return new Row(fields,source);
}","@Override public Row next(){
  final String[] fields=parser.next();
  final String source=parser.getCurrentLine();
  return new Row(fields,source);
}",0.738255033557047
30653,"@Test(dataProvider=""String_Node_Str"") public void testTextFileParser(Object fileOrStream){
  FormatUtil format=new FormatUtil();
  BasicInputParser parser=fileOrStream instanceof File ? new BasicInputParser(true,(File)fileOrStream) : new BasicInputParser(true,(InputStream)fileOrStream);
  int index=0;
  while (parser.hasNext()) {
    String parts[]=parser.next();
    Assert.assertEquals(parts.length,4);
    if (index < 4) {
      for (int i=0; i < parts.length; i++) {
        Assert.assertEquals(parts,testFile1Data[index]);
      }
    }
 else {
      Assert.assertEquals(testFile1Data[index][0],format.parseDouble(parts[0]));
      Assert.assertEquals(testFile1Data[index][1],format.parseInt(parts[1]));
      Assert.assertEquals(testFile1Data[index][2],format.parseInt(parts[2]));
      Assert.assertEquals(testFile1Data[index][3],format.parseDouble(parts[3]));
    }
    index++;
  }
}","@Test(dataProvider=""String_Node_Str"") public void testTextFileParser(Object fileOrStream) throws IOException {
  FormatUtil format=new FormatUtil();
  List<String> expected=new ArrayList<String>();
  if (fileOrStream instanceof File) {
    BufferedReader reader=new BufferedReader(new FileReader((File)fileOrStream));
    String line=null;
    while ((line=reader.readLine()) != null) {
      if (!line.startsWith(""String_Node_Str""))       expected.add(line);
    }
    reader.close();
  }
  BasicInputParser parser=fileOrStream instanceof File ? new BasicInputParser(true,(File)fileOrStream) : new BasicInputParser(true,(InputStream)fileOrStream);
  int index=0;
  while (parser.hasNext()) {
    String parts[]=parser.next();
    if (fileOrStream instanceof File) {
      Assert.assertEquals(parser.getCurrentLine(),expected.get(index));
    }
    Assert.assertEquals(parser.getCurrentLineNumber(),index <= 2 ? index + 1 : index + 2);
    Assert.assertEquals(parts.length,4);
    if (index < 4) {
      for (int i=0; i < parts.length; i++) {
        Assert.assertEquals(parts,testFile1Data[index]);
      }
    }
 else {
      Assert.assertEquals(testFile1Data[index][0],format.parseDouble(parts[0]));
      Assert.assertEquals(testFile1Data[index][1],format.parseInt(parts[1]));
      Assert.assertEquals(testFile1Data[index][2],format.parseInt(parts[2]));
      Assert.assertEquals(testFile1Data[index][3],format.parseDouble(parts[3]));
    }
    index++;
  }
}",0.7582697201017812
30654,"/** 
 * Checks that the average quality over the entire read is >= min, and that the first N bases do not contain any no-calls.
 */
boolean passesQualityCheck(final byte[] bases,final byte[] quals,final int seedLength,final int minQuality){
  for (int i=0; i < seedLength; ++i) {
    if (SequenceUtil.isNoCall(bases[i]))     return false;
  }
  int total=0;
  for (  final byte b : quals)   total+=b;
  return total / quals.length >= minQuality;
}","/** 
 * Checks that the average quality over the entire read is >= min, and that the first N bases do not contain any no-calls.
 */
boolean passesQualityCheck(final byte[] bases,final byte[] quals,final int seedLength,final int minQuality){
  if (bases.length < seedLength)   return false;
  for (int i=0; i < seedLength; ++i) {
    if (SequenceUtil.isNoCall(bases[i]))     return false;
  }
  int total=0;
  for (  final byte b : quals)   total+=b;
  return total / quals.length >= minQuality;
}",0.9480381760339344
30655,"@Test public void testBisulfite() throws IOException {
  File input=new File(TEST_DATA_DIR,""String_Node_Str"");
  File reference=new File(TEST_DATA_DIR,""String_Node_Str"");
  File outfile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  outfile.deleteOnExit();
  int result=new CollectAlignmentSummaryMetrics().instanceMain(new String[]{""String_Node_Str"" + input.getAbsolutePath(),""String_Node_Str"" + outfile.getAbsolutePath(),""String_Node_Str"" + reference.getAbsolutePath(),""String_Node_Str""});
  Assert.assertEquals(result,0);
  NumberFormat format=NumberFormat.getInstance();
  format.setMaximumFractionDigits(4);
  MetricsFile<AlignmentSummaryMetrics,Comparable<?>> output=new MetricsFile<AlignmentSummaryMetrics,Comparable<?>>();
  output.read(new FileReader(outfile));
  for (  AlignmentSummaryMetrics metrics : output.getMetrics()) {
    Assert.assertEquals(metrics.MEAN_READ_LENGTH,101.0);
switch (metrics.CATEGORY) {
case FIRST_OF_PAIR:
      Assert.assertEquals(metrics.TOTAL_READS,1);
    Assert.assertEquals(metrics.PF_READS,1);
  Assert.assertEquals(metrics.PF_HQ_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_HQ_MEDIAN_MISMATCHES,20.0);
Assert.assertEquals(metrics.PF_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_MISMATCH_RATE,20D / 100D);
Assert.assertEquals(metrics.BAD_CYCLES,20);
Assert.assertEquals(format.format(metrics.PF_HQ_ERROR_RATE),format.format(20 / (double)100));
break;
case SECOND_OF_PAIR:
Assert.assertEquals(metrics.TOTAL_READS,1);
Assert.assertEquals(metrics.PF_READS,1);
Assert.assertEquals(metrics.PF_HQ_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_HQ_MEDIAN_MISMATCHES,3.0);
Assert.assertEquals(metrics.PF_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_MISMATCH_RATE,0.030303);
Assert.assertEquals(metrics.BAD_CYCLES,3);
Assert.assertEquals(format.format(metrics.PF_HQ_ERROR_RATE),format.format(3 / (double)99));
break;
case PAIR:
Assert.assertEquals(metrics.TOTAL_READS,2);
Assert.assertEquals(metrics.PF_READS,2);
Assert.assertEquals(metrics.PF_HQ_ALIGNED_BASES,202);
Assert.assertEquals(metrics.PF_HQ_MEDIAN_MISMATCHES,3.0);
Assert.assertEquals(metrics.PF_ALIGNED_BASES,202);
Assert.assertEquals(metrics.PF_MISMATCH_RATE,0.115578);
Assert.assertEquals(metrics.BAD_CYCLES,23);
Assert.assertEquals(format.format(metrics.PF_HQ_ERROR_RATE),format.format(23 / (double)199));
break;
case UNPAIRED:
default :
Assert.fail(""String_Node_Str"" + metrics.CATEGORY);
}
}
}","@Test public void testBisulfite() throws IOException {
  File input=new File(TEST_DATA_DIR,""String_Node_Str"");
  File reference=new File(TEST_DATA_DIR,""String_Node_Str"");
  File outfile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  outfile.deleteOnExit();
  int result=new CollectAlignmentSummaryMetrics().instanceMain(new String[]{""String_Node_Str"" + input.getAbsolutePath(),""String_Node_Str"" + outfile.getAbsolutePath(),""String_Node_Str"" + reference.getAbsolutePath(),""String_Node_Str""});
  Assert.assertEquals(result,0);
  NumberFormat format=NumberFormat.getInstance();
  format.setMaximumFractionDigits(4);
  MetricsFile<AlignmentSummaryMetrics,Comparable<?>> output=new MetricsFile<AlignmentSummaryMetrics,Comparable<?>>();
  output.read(new FileReader(outfile));
  for (  AlignmentSummaryMetrics metrics : output.getMetrics()) {
    Assert.assertEquals(metrics.MEAN_READ_LENGTH,101.0);
switch (metrics.CATEGORY) {
case FIRST_OF_PAIR:
      Assert.assertEquals(metrics.TOTAL_READS,1);
    Assert.assertEquals(metrics.PF_READS,1);
  Assert.assertEquals(metrics.PF_HQ_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_HQ_MEDIAN_MISMATCHES,20.0);
Assert.assertEquals(metrics.PF_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_MISMATCH_RATE,20D / 100D);
Assert.assertEquals(metrics.BAD_CYCLES,20);
Assert.assertEquals(format.format(metrics.PF_HQ_ERROR_RATE),format.format(20 / (double)100));
break;
case SECOND_OF_PAIR:
Assert.assertEquals(metrics.TOTAL_READS,1);
Assert.assertEquals(metrics.PF_READS,1);
Assert.assertEquals(metrics.PF_HQ_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_HQ_MEDIAN_MISMATCHES,3.0);
Assert.assertEquals(metrics.PF_ALIGNED_BASES,101);
Assert.assertEquals(metrics.PF_MISMATCH_RATE,0.030303);
Assert.assertEquals(metrics.BAD_CYCLES,3);
Assert.assertEquals(format.format(metrics.PF_HQ_ERROR_RATE),format.format(3 / (double)99));
break;
case PAIR:
Assert.assertEquals(metrics.TOTAL_READS,2);
Assert.assertEquals(metrics.PF_READS,2);
Assert.assertEquals(metrics.PF_HQ_ALIGNED_BASES,202);
Assert.assertEquals(metrics.PF_HQ_MEDIAN_MISMATCHES,11.5);
Assert.assertEquals(metrics.PF_ALIGNED_BASES,202);
Assert.assertEquals(metrics.PF_MISMATCH_RATE,0.115578);
Assert.assertEquals(metrics.BAD_CYCLES,23);
Assert.assertEquals(format.format(metrics.PF_HQ_ERROR_RATE),format.format(23 / (double)199));
break;
case UNPAIRED:
default :
Assert.fail(""String_Node_Str"" + metrics.CATEGORY);
}
}
}",0.9985581874356334
30656,"/** 
 * Attempts to calculate the HS penalty incurred by the library in order to get 80% of target bases (in non-zero-covered targets) to a specific target coverage (e.g. 20X).
 * @param coverageGoal the desired coverage target (e.g. 20X)
 * @return the hs penalty - a multiplier that tells if you want, e.g. 20X coverage, then you willneed to produce this many PF aligned bases per target bases in your design!
 */
private double calculateHsPenalty(final int coverageGoal){
  if (this.metrics.HS_LIBRARY_SIZE == null)   return 0;
  final double meanCoverage=this.ON_TARGET_FROM_PAIR_BASES / (double)this.metrics.TARGET_TERRITORY;
  final double fold80=this.metrics.FOLD_80_BASE_PENALTY;
  final long hsLibrarySize=this.metrics.HS_LIBRARY_SIZE;
  final long pairs=this.PF_SELECTED_PAIRS;
  final long uniquePairs=this.PF_SELECTED_UNIQUE_PAIRS;
  final double onTargetPct=(double)this.metrics.ON_TARGET_BASES / (double)this.metrics.PF_UQ_BASES_ALIGNED;
  final double uniquePairGoalMultiplier=(coverageGoal / meanCoverage) * fold80;
  double pairMultiplier=uniquePairGoalMultiplier;
  double increment=1;
  boolean goingUp=uniquePairGoalMultiplier >= 1;
  double finalPairMultiplier=-1;
  for (int i=0; i < 10000; ++i) {
    double uniquePairMultiplier=DuplicationMetrics.estimateRoi(hsLibrarySize,pairMultiplier,pairs,uniquePairs);
    if (Math.abs(uniquePairMultiplier - uniquePairGoalMultiplier) <= 0.01) {
      finalPairMultiplier=pairMultiplier;
      break;
    }
 else     if ((uniquePairMultiplier > uniquePairGoalMultiplier && goingUp) || (uniquePairMultiplier < uniquePairGoalMultiplier && !goingUp)) {
      increment/=2;
      goingUp=!goingUp;
    }
    pairMultiplier+=(goingUp ? increment : -increment);
  }
  if (finalPairMultiplier == -1) {
    return -1;
  }
 else {
    double uniqueFraction=(uniquePairs * uniquePairGoalMultiplier) / (pairs * finalPairMultiplier);
    return (1 / uniqueFraction) * fold80 * (1 / onTargetPct);
  }
}","/** 
 * Attempts to calculate the HS penalty incurred by the library in order to get 80% of target bases (in non-zero-covered targets) to a specific target coverage (e.g. 20X).
 * @param coverageGoal the desired coverage target (e.g. 20X)
 * @return the hs penalty - a multiplier that tells if you want, e.g. 20X coverage, then you willneed to produce this many PF aligned bases per target bases in your design!
 */
private double calculateHsPenalty(final int coverageGoal){
  if (this.metrics.HS_LIBRARY_SIZE == null)   return 0;
  final double meanCoverage=this.ON_TARGET_FROM_PAIR_BASES / (double)this.metrics.TARGET_TERRITORY;
  final double fold80=this.metrics.FOLD_80_BASE_PENALTY;
  final long hsLibrarySize=this.metrics.HS_LIBRARY_SIZE;
  final long pairs=this.PF_SELECTED_PAIRS;
  final long uniquePairs=this.PF_SELECTED_UNIQUE_PAIRS;
  final double onTargetPct=(double)this.metrics.ON_TARGET_BASES / (double)this.metrics.PF_UQ_BASES_ALIGNED;
  final double uniquePairGoalMultiplier=(coverageGoal / meanCoverage) * fold80;
  double pairMultiplier=uniquePairGoalMultiplier;
  double increment=1;
  boolean goingUp=uniquePairGoalMultiplier >= 1;
  double finalPairMultiplier=-1;
  for (int i=0; i < 10000; ++i) {
    double uniquePairMultiplier=DuplicationMetrics.estimateRoi(hsLibrarySize,pairMultiplier,pairs,uniquePairs);
    if (Math.abs(uniquePairMultiplier - uniquePairGoalMultiplier) / uniquePairGoalMultiplier <= 0.001) {
      finalPairMultiplier=pairMultiplier;
      break;
    }
 else     if ((uniquePairMultiplier > uniquePairGoalMultiplier && goingUp) || (uniquePairMultiplier < uniquePairGoalMultiplier && !goingUp)) {
      increment/=2;
      goingUp=!goingUp;
    }
    pairMultiplier+=(goingUp ? increment : -increment);
  }
  if (finalPairMultiplier == -1) {
    return -1;
  }
 else {
    double uniqueFraction=(uniquePairs * uniquePairGoalMultiplier) / (pairs * finalPairMultiplier);
    return (1 / uniqueFraction) * fold80 * (1 / onTargetPct);
  }
}",0.992878942014242
30657,"@Override public Row next(){
  final Row row=new Row(parser.next());
  row.setCurrentLine(parser.getCurrentLine());
  return row;
}","@Override public Row next(){
  final String source=parser.getCurrentLine();
  final String[] fields=parser.next();
  return new Row(fields,source);
}",0.5785714285714286
30658,"Row(final String[] fields){
  this.fields=fields;
}","Row(final String[] fields,final String source){
  this.fields=fields;
  this.currentLine=source;
}",0.6845637583892618
30659,"/** 
 * Merges the alignment data with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  final SAMRecordQueryNameComparator comparator=new SAMRecordQueryNameComparator();
  final SAMFileReader unmappedSam=new SAMFileReader(this.unmappedBamFile);
  final CloseableIterator<SAMRecord> unmappedIterator=unmappedSam.iterator();
  this.header.setReadGroups(unmappedSam.getFileHeader().getReadGroups());
  int aligned=0;
  int unmapped=0;
  final CloseableIterator<SAMRecord> alignedIterator=getQuerynameSortedAlignedRecords();
  SAMRecord nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
  final SortingCollection<SAMRecord> coordinateSorted=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordCoordinateComparator(),MAX_RECORDS_IN_RAM);
  SAMRecord firstOfPair=null;
  while (unmappedIterator.hasNext()) {
    final SAMRecord rec=unmappedIterator.next();
    if (nextAligned != null && comparator.compare(rec,nextAligned) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + nextAligned.getReadName() + ""String_Node_Str""+ rec.getReadName()+ ""String_Node_Str"");
    }
    rec.setHeader(this.header);
    if (isMatch(rec,nextAligned)) {
      if (!(nextAligned.getReadUnmappedFlag() || ignoreAlignment(nextAligned))) {
        setValuesFromAlignment(rec,nextAligned);
        updateCigarForTrimmedOrClippedBases(rec,nextAligned);
        if (this.programRecord != null) {
          rec.setAttribute(ReservedTagConstants.PROGRAM_GROUP_ID,this.programRecord.getProgramGroupId());
        }
        aligned++;
      }
 else {
        unmapped++;
      }
      nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
    }
 else {
      unmapped++;
    }
    if (!rec.getReadPairedFlag()) {
      if (!rec.getReadUnmappedFlag() || !alignedReadsOnly) {
        coordinateSorted.add(rec);
      }
    }
 else {
      if (firstOfPair == null) {
        firstOfPair=rec;
      }
 else {
        if (!rec.getReadName().equals(firstOfPair.getReadName())) {
          throw new PicardException(""String_Node_Str"" + rec.getReadName());
        }
 else {
          if ((!rec.getReadUnmappedFlag() || !firstOfPair.getReadUnmappedFlag()) || !alignedReadsOnly) {
            clipForOverlappingReads(rec,firstOfPair);
            SamPairUtil.setProperPairAndMateInfo(rec,firstOfPair,header,expectedOrientations);
            coordinateSorted.add(firstOfPair);
            coordinateSorted.add(rec);
            firstOfPair=null;
          }
        }
      }
    }
  }
  unmappedIterator.close();
  if (alignedIterator.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"" + alignedIterator.next().getReadName() + ""String_Node_Str"");
  }
  alignedIterator.close();
  final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,true,this.targetBamFile);
  int count=0;
  CloseableIterator<SAMRecord> it=coordinateSorted.iterator();
  while (it.hasNext()) {
    SAMRecord rec=it.next();
    if (!rec.getReadUnmappedFlag()) {
      if (refSeq != null) {
        byte referenceBases[]=refSeq.get(sequenceDictionary.getSequenceIndex(rec.getReferenceName())).getBases();
        rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTag(rec,referenceBases,0,bisulfiteSequence));
        if (rec.getBaseQualities() != SAMRecord.NULL_QUALS) {
          rec.setAttribute(SAMTag.UQ.name(),SequenceUtil.sumQualitiesOfMismatches(rec,referenceBases,0,bisulfiteSequence));
        }
      }
    }
    writer.addAlignment(rec);
    if (++count % 1000000 == 0) {
      log.info(count + ""String_Node_Str"" + targetBamFile.getName());
    }
  }
  writer.close();
  log.info(""String_Node_Str"" + aligned + ""String_Node_Str""+ (alignedReadsOnly ? 0 : unmapped)+ ""String_Node_Str"");
}","/** 
 * Merges the alignment data with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
}",0.0632814493493238
30660,"/** 
 * Merges the alignment data with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
}","/** 
 * Merges the alignment data with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  final SAMRecordQueryNameComparator comparator=new SAMRecordQueryNameComparator();
  final SAMFileReader unmappedSam=new SAMFileReader(this.unmappedBamFile);
  final CloseableIterator<SAMRecord> unmappedIterator=unmappedSam.iterator();
  this.header.setReadGroups(unmappedSam.getFileHeader().getReadGroups());
  int aligned=0;
  int unmapped=0;
  final CloseableIterator<SAMRecord> alignedIterator=getQuerynameSortedAlignedRecords();
  SAMRecord nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
  final SortingCollection<SAMRecord> coordinateSorted=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordCoordinateComparator(),MAX_RECORDS_IN_RAM);
  SAMRecord firstOfPair=null;
  while (unmappedIterator.hasNext()) {
    final SAMRecord rec=unmappedIterator.next();
    if (nextAligned != null && comparator.compare(rec,nextAligned) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + nextAligned.getReadName() + ""String_Node_Str""+ rec.getReadName()+ ""String_Node_Str"");
    }
    rec.setHeader(this.header);
    if (isMatch(rec,nextAligned)) {
      if (!(nextAligned.getReadUnmappedFlag() || ignoreAlignment(nextAligned))) {
        setValuesFromAlignment(rec,nextAligned);
        updateCigarForTrimmedOrClippedBases(rec,nextAligned);
        if (this.programRecord != null) {
          rec.setAttribute(ReservedTagConstants.PROGRAM_GROUP_ID,this.programRecord.getProgramGroupId());
        }
        aligned++;
      }
 else {
        unmapped++;
      }
      nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
    }
 else {
      unmapped++;
    }
    if (!rec.getReadPairedFlag()) {
      if (!rec.getReadUnmappedFlag() || !alignedReadsOnly) {
        coordinateSorted.add(rec);
      }
    }
 else {
      if (firstOfPair == null) {
        firstOfPair=rec;
      }
 else {
        if (!rec.getReadName().equals(firstOfPair.getReadName())) {
          throw new PicardException(""String_Node_Str"" + firstOfPair.getReadName() + ""String_Node_Str""+ rec.getReadName());
        }
 else {
          if ((!rec.getReadUnmappedFlag() || !firstOfPair.getReadUnmappedFlag()) || !alignedReadsOnly) {
            clipForOverlappingReads(rec,firstOfPair);
            SamPairUtil.setProperPairAndMateInfo(rec,firstOfPair,header,expectedOrientations);
            coordinateSorted.add(firstOfPair);
            coordinateSorted.add(rec);
          }
          firstOfPair=null;
        }
      }
    }
  }
  unmappedIterator.close();
  if (alignedIterator.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"" + alignedIterator.next().getReadName() + ""String_Node_Str"");
  }
  alignedIterator.close();
  final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,true,this.targetBamFile);
  int count=0;
  CloseableIterator<SAMRecord> it=coordinateSorted.iterator();
  while (it.hasNext()) {
    SAMRecord rec=it.next();
    if (!rec.getReadUnmappedFlag()) {
      if (refSeq != null) {
        byte referenceBases[]=refSeq.get(sequenceDictionary.getSequenceIndex(rec.getReferenceName())).getBases();
        rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTag(rec,referenceBases,0,bisulfiteSequence));
        if (rec.getBaseQualities() != SAMRecord.NULL_QUALS) {
          rec.setAttribute(SAMTag.UQ.name(),SequenceUtil.sumQualitiesOfMismatches(rec,referenceBases,0,bisulfiteSequence));
        }
      }
    }
    writer.addAlignment(rec);
    if (++count % 1000000 == 0) {
      log.info(count + ""String_Node_Str"" + targetBamFile.getName());
    }
  }
  writer.close();
  log.info(""String_Node_Str"" + aligned + ""String_Node_Str""+ (alignedReadsOnly ? 0 : unmapped)+ ""String_Node_Str"");
}",0.0625630676084762
30661,"/** 
 * Merges the alignment data with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  final SAMRecordQueryNameComparator comparator=new SAMRecordQueryNameComparator();
  final SAMFileReader unmappedSam=new SAMFileReader(this.unmappedBamFile);
  final CloseableIterator<SAMRecord> unmappedIterator=unmappedSam.iterator();
  this.header.setReadGroups(unmappedSam.getFileHeader().getReadGroups());
  int aligned=0;
  int unmapped=0;
  final CloseableIterator<SAMRecord> alignedIterator=getQuerynameSortedAlignedRecords();
  SAMRecord nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
  final SortingCollection<SAMRecord> coordinateSorted=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordCoordinateComparator(),MAX_RECORDS_IN_RAM);
  SAMRecord firstOfPair=null;
  while (unmappedIterator.hasNext()) {
    final SAMRecord rec=unmappedIterator.next();
    if (nextAligned != null && comparator.compare(rec,nextAligned) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + nextAligned.getReadName() + ""String_Node_Str""+ rec.getReadName()+ ""String_Node_Str"");
    }
    rec.setHeader(this.header);
    if (isMatch(rec,nextAligned)) {
      if (!(nextAligned.getReadUnmappedFlag() || ignoreAlignment(nextAligned))) {
        setValuesFromAlignment(rec,nextAligned);
        updateCigarForTrimmedOrClippedBases(rec,nextAligned);
        if (this.programRecord != null) {
          rec.setAttribute(ReservedTagConstants.PROGRAM_GROUP_ID,this.programRecord.getProgramGroupId());
        }
        aligned++;
      }
 else {
        unmapped++;
      }
      nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
    }
 else {
      unmapped++;
    }
    if (!rec.getReadPairedFlag()) {
      if (!rec.getReadUnmappedFlag() || !alignedReadsOnly) {
        coordinateSorted.add(rec);
      }
    }
 else {
      if (firstOfPair == null) {
        firstOfPair=rec;
      }
 else {
        if (!rec.getReadName().equals(firstOfPair.getReadName())) {
          coordinateSorted.add(firstOfPair);
          firstOfPair=rec;
        }
 else {
          if ((!rec.getReadUnmappedFlag() || !firstOfPair.getReadUnmappedFlag()) || !alignedReadsOnly) {
            clipForOverlappingReads(rec,firstOfPair);
            SamPairUtil.setProperPairAndMateInfo(rec,firstOfPair,header,expectedOrientations);
            coordinateSorted.add(firstOfPair);
            coordinateSorted.add(rec);
            firstOfPair=null;
          }
        }
      }
    }
  }
  unmappedIterator.close();
  if (alignedIterator.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"" + alignedIterator.next().getReadName() + ""String_Node_Str"");
  }
  alignedIterator.close();
  final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,true,this.targetBamFile);
  int count=0;
  CloseableIterator<SAMRecord> it=coordinateSorted.iterator();
  while (it.hasNext()) {
    SAMRecord rec=it.next();
    if (!rec.getReadUnmappedFlag()) {
      if (refSeq != null) {
        byte referenceBases[]=refSeq.get(sequenceDictionary.getSequenceIndex(rec.getReferenceName())).getBases();
        rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTag(rec,referenceBases,0,bisulfiteSequence));
        if (rec.getBaseQualities() != SAMRecord.NULL_QUALS) {
          rec.setAttribute(SAMTag.UQ.name(),SequenceUtil.sumQualitiesOfMismatches(rec,referenceBases,0,bisulfiteSequence));
        }
      }
    }
    writer.addAlignment(rec);
    if (++count % 1000000 == 0) {
      log.info(count + ""String_Node_Str"" + targetBamFile.getName());
    }
  }
  writer.close();
  log.info(""String_Node_Str"" + aligned + ""String_Node_Str""+ (alignedReadsOnly ? 0 : unmapped)+ ""String_Node_Str"");
}","/** 
 * Merges the alignment data with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  final SAMRecordQueryNameComparator comparator=new SAMRecordQueryNameComparator();
  final SAMFileReader unmappedSam=new SAMFileReader(this.unmappedBamFile);
  final CloseableIterator<SAMRecord> unmappedIterator=unmappedSam.iterator();
  this.header.setReadGroups(unmappedSam.getFileHeader().getReadGroups());
  int aligned=0;
  int unmapped=0;
  final CloseableIterator<SAMRecord> alignedIterator=getQuerynameSortedAlignedRecords();
  SAMRecord nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
  final SortingCollection<SAMRecord> coordinateSorted=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordCoordinateComparator(),MAX_RECORDS_IN_RAM);
  SAMRecord firstOfPair=null;
  while (unmappedIterator.hasNext()) {
    final SAMRecord rec=unmappedIterator.next();
    if (nextAligned != null && comparator.compare(rec,nextAligned) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + nextAligned.getReadName() + ""String_Node_Str""+ rec.getReadName()+ ""String_Node_Str"");
    }
    rec.setHeader(this.header);
    if (isMatch(rec,nextAligned)) {
      if (!(nextAligned.getReadUnmappedFlag() || ignoreAlignment(nextAligned))) {
        setValuesFromAlignment(rec,nextAligned);
        updateCigarForTrimmedOrClippedBases(rec,nextAligned);
        if (this.programRecord != null) {
          rec.setAttribute(ReservedTagConstants.PROGRAM_GROUP_ID,this.programRecord.getProgramGroupId());
        }
        aligned++;
      }
 else {
        unmapped++;
      }
      nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
    }
 else {
      unmapped++;
    }
    if (!rec.getReadPairedFlag()) {
      if (!rec.getReadUnmappedFlag() || !alignedReadsOnly) {
        coordinateSorted.add(rec);
      }
    }
 else {
      if (firstOfPair == null) {
        firstOfPair=rec;
      }
 else {
        if (!rec.getReadName().equals(firstOfPair.getReadName())) {
          throw new PicardException(""String_Node_Str"" + rec.getReadName());
        }
 else {
          if ((!rec.getReadUnmappedFlag() || !firstOfPair.getReadUnmappedFlag()) || !alignedReadsOnly) {
            clipForOverlappingReads(rec,firstOfPair);
            SamPairUtil.setProperPairAndMateInfo(rec,firstOfPair,header,expectedOrientations);
            coordinateSorted.add(firstOfPair);
            coordinateSorted.add(rec);
            firstOfPair=null;
          }
        }
      }
    }
  }
  unmappedIterator.close();
  if (alignedIterator.hasNext()) {
    throw new IllegalStateException(""String_Node_Str"" + alignedIterator.next().getReadName() + ""String_Node_Str"");
  }
  alignedIterator.close();
  final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,true,this.targetBamFile);
  int count=0;
  CloseableIterator<SAMRecord> it=coordinateSorted.iterator();
  while (it.hasNext()) {
    SAMRecord rec=it.next();
    if (!rec.getReadUnmappedFlag()) {
      if (refSeq != null) {
        byte referenceBases[]=refSeq.get(sequenceDictionary.getSequenceIndex(rec.getReferenceName())).getBases();
        rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTag(rec,referenceBases,0,bisulfiteSequence));
        if (rec.getBaseQualities() != SAMRecord.NULL_QUALS) {
          rec.setAttribute(SAMTag.UQ.name(),SequenceUtil.sumQualitiesOfMismatches(rec,referenceBases,0,bisulfiteSequence));
        }
      }
    }
    writer.addAlignment(rec);
    if (++count % 1000000 == 0) {
      log.info(count + ""String_Node_Str"" + targetBamFile.getName());
    }
  }
  writer.close();
  log.info(""String_Node_Str"" + aligned + ""String_Node_Str""+ (alignedReadsOnly ? 0 : unmapped)+ ""String_Node_Str"");
}",0.9839177432111784
30662,"protected int doWork(){
  IoUtil.assertFileIsReadable(REFERENCE_SEQUENCE);
  IoUtil.assertFileIsReadable(INPUT);
  IoUtil.assertFileIsWritable(OUTPUT);
  IoUtil.assertFileIsWritable(CHART_OUTPUT);
  if (SUMMARY_OUTPUT != null)   IoUtil.assertFileIsWritable(SUMMARY_OUTPUT);
  int[] windowsByGc=new int[101];
  int[] readsByGc=new int[101];
  long[] basesByGc=new long[101];
  long[] errorsByGc=new long[101];
  SAMFileReader sam=new SAMFileReader(INPUT);
  PeekableIterator<SAMRecord> iterator=new PeekableIterator<SAMRecord>(sam.iterator());
  ReferenceSequenceFile referenceFile=ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE);
{
    SAMSequenceDictionary referenceDictionary=referenceFile.getSequenceDictionary();
    SAMSequenceDictionary samFileDictionary=sam.getFileHeader().getSequenceDictionary();
    if (referenceDictionary != null && samFileDictionary != null) {
      SequenceUtil.assertSequenceDictionariesEqual(referenceDictionary,samFileDictionary);
    }
  }
  ReferenceSequence ref=null;
  while ((ref=referenceFile.nextSequence()) != null) {
    final byte[] refBases=ref.getBases();
    StringUtil.toUpperCase(refBases);
    final int refLength=refBases.length;
    final int lastWindowStart=refLength - WINDOW_SIZE;
    byte[] gc=null;
    for (int countSeq=0; iterator.hasNext() && iterator.peek().getReferenceIndex() == ref.getContigIndex(); countSeq++) {
      SAMRecord rec=iterator.next();
      if (countSeq == 0) {
        gc=calculateAllGcs(refBases,windowsByGc,lastWindowStart);
      }
      if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag())       ++this.totalClusters;
      if (!rec.getReadUnmappedFlag()) {
        int pos=rec.getReadNegativeStrandFlag() ? rec.getAlignmentEnd() - WINDOW_SIZE : rec.getAlignmentStart();
        ++this.totalAlignedReads;
        if (pos > 0) {
          int windowGc=gc[pos];
          if (windowGc >= 0) {
            ++readsByGc[windowGc];
            basesByGc[windowGc]+=rec.getReadLength();
            errorsByGc[windowGc]+=SequenceUtil.countMismatches(rec,refBases);
          }
        }
      }
    }
    LOG.info(""String_Node_Str"" + ref.getName());
  }
  while (iterator.hasNext()) {
    SAMRecord rec=iterator.next();
    if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag())     ++this.totalClusters;
  }
  MetricsFile<GcBiasDetailMetrics,?> metricsFile=getMetricsFile();
  double totalWindows=sum(windowsByGc);
  double totalReads=sum(readsByGc);
  double meanReadsPerWindow=totalReads / totalWindows;
  double minimumWindowsToCountInSummary=totalWindows * this.MINIMUM_GENOME_FRACTION;
  for (int i=0; i < windowsByGc.length; ++i) {
    if (windowsByGc[i] == 0)     continue;
    GcBiasDetailMetrics m=new GcBiasDetailMetrics();
    m.GC=i;
    m.WINDOWS=windowsByGc[i];
    m.READ_STARTS=readsByGc[i];
    if (errorsByGc[i] > 0)     m.MEAN_BASE_QUALITY=QualityUtil.getPhredScoreFromObsAndErrors(basesByGc[i],errorsByGc[i]);
    m.NORMALIZED_COVERAGE=(m.READ_STARTS / (double)m.WINDOWS) / meanReadsPerWindow;
    m.ERROR_BAR_WIDTH=(Math.sqrt(m.READ_STARTS) / (double)m.WINDOWS) / meanReadsPerWindow;
    metricsFile.addMetric(m);
  }
  metricsFile.write(OUTPUT);
  if (SUMMARY_OUTPUT != null) {
    MetricsFile<GcBiasSummaryMetrics,?> summaryMetricsFile=getMetricsFile();
    GcBiasSummaryMetrics summary=new GcBiasSummaryMetrics();
    summary.WINDOW_SIZE=this.WINDOW_SIZE;
    summary.TOTAL_CLUSTERS=this.totalClusters;
    summary.ALIGNED_READS=this.totalAlignedReads;
    summary.LOW_GC_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,0,33);
    summary.MID_GC_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,34,66);
    summary.HIGH_GC_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,67,100);
    summary.TOTAL_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,0,100);
    summary.JAFFE_BIAS_METRIC=calculateJaffeMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,0,100);
    summaryMetricsFile.addMetric(summary);
    if (SUMMARY_OUTPUT != null)     summaryMetricsFile.write(SUMMARY_OUTPUT);
  }
  NumberFormat fmt=NumberFormat.getIntegerInstance();
  fmt.setGroupingUsed(true);
  String subtitle=""String_Node_Str"" + fmt.format(this.totalClusters) + ""String_Node_Str""+ fmt.format(this.totalAlignedReads);
  RExecutor.executeFromClasspath(R_SCRIPT,OUTPUT.getAbsolutePath(),CHART_OUTPUT.getAbsolutePath(),INPUT.getName().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),subtitle,String.valueOf(WINDOW_SIZE));
  return 0;
}","protected int doWork(){
  IoUtil.assertFileIsReadable(REFERENCE_SEQUENCE);
  IoUtil.assertFileIsReadable(INPUT);
  IoUtil.assertFileIsWritable(OUTPUT);
  IoUtil.assertFileIsWritable(CHART_OUTPUT);
  if (SUMMARY_OUTPUT != null)   IoUtil.assertFileIsWritable(SUMMARY_OUTPUT);
  int[] windowsByGc=new int[101];
  int[] readsByGc=new int[101];
  long[] basesByGc=new long[101];
  long[] errorsByGc=new long[101];
  SAMFileReader sam=new SAMFileReader(INPUT);
  PeekableIterator<SAMRecord> iterator=new PeekableIterator<SAMRecord>(sam.iterator());
  ReferenceSequenceFile referenceFile=ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE);
{
    SAMSequenceDictionary referenceDictionary=referenceFile.getSequenceDictionary();
    SAMSequenceDictionary samFileDictionary=sam.getFileHeader().getSequenceDictionary();
    if (referenceDictionary != null && samFileDictionary != null) {
      SequenceUtil.assertSequenceDictionariesEqual(referenceDictionary,samFileDictionary);
    }
  }
  ReferenceSequence ref=null;
  while ((ref=referenceFile.nextSequence()) != null) {
    final byte[] refBases=ref.getBases();
    StringUtil.toUpperCase(refBases);
    final int refLength=refBases.length;
    final int lastWindowStart=refLength - WINDOW_SIZE;
    byte[] gc=calculateAllGcs(refBases,windowsByGc,lastWindowStart);
    while (iterator.hasNext() && iterator.peek().getReferenceIndex() == ref.getContigIndex()) {
      SAMRecord rec=iterator.next();
      if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag())       ++this.totalClusters;
      if (!rec.getReadUnmappedFlag()) {
        int pos=rec.getReadNegativeStrandFlag() ? rec.getAlignmentEnd() - WINDOW_SIZE : rec.getAlignmentStart();
        ++this.totalAlignedReads;
        if (pos > 0) {
          int windowGc=gc[pos];
          if (windowGc >= 0) {
            ++readsByGc[windowGc];
            basesByGc[windowGc]+=rec.getReadLength();
            errorsByGc[windowGc]+=SequenceUtil.countMismatches(rec,refBases);
          }
        }
      }
    }
    LOG.info(""String_Node_Str"" + ref.getName());
  }
  while (iterator.hasNext()) {
    SAMRecord rec=iterator.next();
    if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag())     ++this.totalClusters;
  }
  MetricsFile<GcBiasDetailMetrics,?> metricsFile=getMetricsFile();
  double totalWindows=sum(windowsByGc);
  double totalReads=sum(readsByGc);
  double meanReadsPerWindow=totalReads / totalWindows;
  double minimumWindowsToCountInSummary=totalWindows * this.MINIMUM_GENOME_FRACTION;
  for (int i=0; i < windowsByGc.length; ++i) {
    if (windowsByGc[i] == 0)     continue;
    GcBiasDetailMetrics m=new GcBiasDetailMetrics();
    m.GC=i;
    m.WINDOWS=windowsByGc[i];
    m.READ_STARTS=readsByGc[i];
    if (errorsByGc[i] > 0)     m.MEAN_BASE_QUALITY=QualityUtil.getPhredScoreFromObsAndErrors(basesByGc[i],errorsByGc[i]);
    m.NORMALIZED_COVERAGE=(m.READ_STARTS / (double)m.WINDOWS) / meanReadsPerWindow;
    m.ERROR_BAR_WIDTH=(Math.sqrt(m.READ_STARTS) / (double)m.WINDOWS) / meanReadsPerWindow;
    metricsFile.addMetric(m);
  }
  metricsFile.write(OUTPUT);
  if (SUMMARY_OUTPUT != null) {
    MetricsFile<GcBiasSummaryMetrics,?> summaryMetricsFile=getMetricsFile();
    GcBiasSummaryMetrics summary=new GcBiasSummaryMetrics();
    summary.WINDOW_SIZE=this.WINDOW_SIZE;
    summary.TOTAL_CLUSTERS=this.totalClusters;
    summary.ALIGNED_READS=this.totalAlignedReads;
    summary.LOW_GC_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,0,33);
    summary.MID_GC_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,34,66);
    summary.HIGH_GC_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,67,100);
    summary.TOTAL_BIAS=calculateSummaryMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,0,100);
    summary.JAFFE_BIAS_METRIC=calculateJaffeMetric(metricsFile.getMetrics(),minimumWindowsToCountInSummary,0,100);
    summaryMetricsFile.addMetric(summary);
    if (SUMMARY_OUTPUT != null)     summaryMetricsFile.write(SUMMARY_OUTPUT);
  }
  NumberFormat fmt=NumberFormat.getIntegerInstance();
  fmt.setGroupingUsed(true);
  String subtitle=""String_Node_Str"" + fmt.format(this.totalClusters) + ""String_Node_Str""+ fmt.format(this.totalAlignedReads);
  RExecutor.executeFromClasspath(R_SCRIPT,OUTPUT.getAbsolutePath(),CHART_OUTPUT.getAbsolutePath(),INPUT.getName().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""),subtitle,String.valueOf(WINDOW_SIZE));
  return 0;
}",0.9771739130434782
30663,"/** 
 * Merges the alignment from the map file with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  try {
    super.mergeAlignment();
  }
 catch (  Exception e) {
    forceSort=true;
    super.mergeAlignment();
  }
}","/** 
 * Merges the alignment from the map file with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  try {
    super.mergeAlignment();
  }
 catch (  Exception e) {
    forceSort=true;
    setRefSeqFileWalker();
    super.mergeAlignment();
  }
}",0.9495327102803738
30664,"public int compare(final SAMRecord samRecord1,final SAMRecord samRecord2){
  final int cmp=fileOrderCompare(samRecord1,samRecord2);
  if (cmp != 0) {
    return cmp;
  }
  if (samRecord1.getReadPairedFlag()) {
    if (samRecord1.getFirstOfPairFlag() && samRecord2.getSecondOfPairFlag()) {
      return -1;
    }
 else     if (samRecord2.getFirstOfPairFlag() && samRecord1.getSecondOfPairFlag()) {
      return 1;
    }
  }
  if (samRecord1.getReadNegativeStrandFlag() == samRecord2.getReadNegativeStrandFlag()) {
    return 0;
  }
  return (samRecord1.getReadNegativeStrandFlag() ? 1 : -1);
}","public int compare(final SAMRecord samRecord1,final SAMRecord samRecord2){
  final int cmp=fileOrderCompare(samRecord1,samRecord2);
  if (cmp != 0) {
    return cmp;
  }
  final boolean r1Paired=samRecord1.getReadPairedFlag();
  final boolean r2Paired=samRecord2.getReadPairedFlag();
  if (r1Paired || r2Paired) {
    if (!r1Paired)     return 1;
 else     if (!r2Paired)     return -1;
 else     if (samRecord1.getFirstOfPairFlag() && samRecord2.getSecondOfPairFlag())     return -1;
 else     if (samRecord1.getSecondOfPairFlag() && samRecord2.getFirstOfPairFlag())     return 1;
  }
  if (samRecord1.getReadNegativeStrandFlag() == samRecord2.getReadNegativeStrandFlag())   return 0;
 else   return (samRecord1.getReadNegativeStrandFlag() ? 1 : -1);
}",0.6364312267657992
30665,"protected List<Chunk> optimizeChunkList(final List<Chunk> chunks,final long minimumOffset){
  Chunk lastChunk=null;
  Collections.sort(chunks);
  final List<Chunk> result=new ArrayList<Chunk>();
  for (  final Chunk chunk : chunks) {
    if (chunk.getChunkEnd() <= minimumOffset) {
      continue;
    }
    if (result.isEmpty()) {
      result.add(chunk);
      lastChunk=chunk;
      continue;
    }
    if (!BlockCompressedFilePointerUtil.areInSameOrAdjacentBlocks(lastChunk.getChunkEnd(),chunk.getChunkStart())) {
      result.add(chunk);
      lastChunk=chunk;
    }
 else {
      if (chunk.getChunkEnd() > lastChunk.getChunkEnd()) {
        lastChunk.setChunkEnd(chunk.getChunkEnd());
      }
    }
  }
  return result;
}","protected List<Chunk> optimizeChunkList(final List<Chunk> chunks,final long minimumOffset){
  Chunk lastChunk=null;
  Collections.sort(chunks);
  final List<Chunk> result=new ArrayList<Chunk>();
  for (  final Chunk chunk : chunks) {
    if (chunk.getChunkEnd() <= minimumOffset) {
      continue;
    }
    if (result.isEmpty()) {
      result.add(chunk);
      lastChunk=chunk;
      continue;
    }
    if (!lastChunk.overlaps(chunk) && !lastChunk.isAdjacentTo(chunk)) {
      result.add(chunk);
      lastChunk=chunk;
    }
 else {
      if (chunk.getChunkEnd() > lastChunk.getChunkEnd()) {
        lastChunk.setChunkEnd(chunk.getChunkEnd());
      }
    }
  }
  return result;
}",0.6822695035460993
30666,"/** 
 * Record any index information for a given BAM record
 * @param rec The BAM record
 */
public void processAlignment(final SAMRecord rec){
  indexStats.recordMetaData(rec);
  final int alignmentStart=rec.getAlignmentStart();
  if (alignmentStart == SAMRecord.NO_ALIGNMENT_START) {
    return;
  }
  final int reference=rec.getReferenceIndex();
  if (reference != currentReference) {
    throw new SAMException(""String_Node_Str"" + reference + ""String_Node_Str""+ currentReference+ ""String_Node_Str""+ rec);
  }
  final Integer binNumber=rec.getIndexingBin();
  final int binNum=binNumber == null ? rec.computeIndexingBin() : binNumber;
  if (bins == null) {
    final SAMSequenceRecord seq=bamHeader.getSequence(reference);
    if (seq == null) {
      bins=new Bin[MAX_BINS + 1];
    }
 else {
      bins=new Bin[AbstractBAMFileIndex.getMaxBinNumberForSequenceLength(seq.getSequenceLength()) + 1];
    }
  }
  final Bin bin;
  if (bins[binNum] != null) {
    bin=bins[binNum];
  }
 else {
    bin=new Bin(reference,binNum);
    bins[binNum]=bin;
    binsSeen++;
  }
  final SAMFileSource source=rec.getFileSource();
  if (source == null) {
    throw new SAMException(""String_Node_Str"" + rec);
  }
  final Chunk newChunk=((BAMFileSpan)source.getFilePointer()).getSingleChunk();
  final long chunkStart=newChunk.getChunkStart();
  final long chunkEnd=newChunk.getChunkEnd();
  final List<Chunk> oldChunks=bin.getChunkList();
  if (oldChunks == null) {
    bin.addInitialChunk(newChunk);
  }
 else {
    final Chunk lastChunk=bin.getLastChunk();
    if (BlockCompressedFilePointerUtil.areInSameOrAdjacentBlocks(lastChunk.getChunkEnd(),chunkStart)) {
      lastChunk.setChunkEnd(chunkEnd);
    }
 else {
      oldChunks.add(newChunk);
      bin.setLastChunk(newChunk);
    }
  }
  final int alignmentEnd=rec.getAlignmentEnd();
  int startWindow=LinearIndex.convertToLinearIndexOffset(alignmentStart);
  final int endWindow;
  if (alignmentEnd == SAMRecord.NO_ALIGNMENT_START) {
    startWindow=LinearIndex.convertToLinearIndexOffset(alignmentStart - 1);
    endWindow=startWindow;
  }
 else {
    endWindow=LinearIndex.convertToLinearIndexOffset(alignmentEnd);
  }
  if (endWindow > largestIndexSeen) {
    largestIndexSeen=endWindow;
  }
  for (int win=startWindow; win <= endWindow; win++) {
    if (index[win] == 0 || chunkStart < index[win]) {
      index[win]=chunkStart;
    }
  }
}","/** 
 * Record any index information for a given BAM record
 * @param rec The BAM record
 */
public void processAlignment(final SAMRecord rec){
  indexStats.recordMetaData(rec);
  final int alignmentStart=rec.getAlignmentStart();
  if (alignmentStart == SAMRecord.NO_ALIGNMENT_START) {
    return;
  }
  final int reference=rec.getReferenceIndex();
  if (reference != currentReference) {
    throw new SAMException(""String_Node_Str"" + reference + ""String_Node_Str""+ currentReference+ ""String_Node_Str""+ rec);
  }
  final Integer binNumber=rec.getIndexingBin();
  final int binNum=binNumber == null ? rec.computeIndexingBin() : binNumber;
  if (bins == null) {
    final SAMSequenceRecord seq=bamHeader.getSequence(reference);
    if (seq == null) {
      bins=new Bin[MAX_BINS + 1];
    }
 else {
      bins=new Bin[AbstractBAMFileIndex.getMaxBinNumberForSequenceLength(seq.getSequenceLength()) + 1];
    }
  }
  final Bin bin;
  if (bins[binNum] != null) {
    bin=bins[binNum];
  }
 else {
    bin=new Bin(reference,binNum);
    bins[binNum]=bin;
    binsSeen++;
  }
  final SAMFileSource source=rec.getFileSource();
  if (source == null) {
    throw new SAMException(""String_Node_Str"" + rec);
  }
  final Chunk newChunk=((BAMFileSpan)source.getFilePointer()).getSingleChunk();
  final long chunkStart=newChunk.getChunkStart();
  final long chunkEnd=newChunk.getChunkEnd();
  final List<Chunk> oldChunks=bin.getChunkList();
  if (!bin.containsChunks()) {
    bin.addInitialChunk(newChunk);
  }
 else {
    final Chunk lastChunk=bin.getLastChunk();
    if (BlockCompressedFilePointerUtil.areInSameOrAdjacentBlocks(lastChunk.getChunkEnd(),chunkStart)) {
      lastChunk.setChunkEnd(chunkEnd);
    }
 else {
      oldChunks.add(newChunk);
      bin.setLastChunk(newChunk);
    }
  }
  final int alignmentEnd=rec.getAlignmentEnd();
  int startWindow=LinearIndex.convertToLinearIndexOffset(alignmentStart);
  final int endWindow;
  if (alignmentEnd == SAMRecord.NO_ALIGNMENT_START) {
    startWindow=LinearIndex.convertToLinearIndexOffset(alignmentStart - 1);
    endWindow=startWindow;
  }
 else {
    endWindow=LinearIndex.convertToLinearIndexOffset(alignmentEnd);
  }
  if (endWindow > largestIndexSeen) {
    largestIndexSeen=endWindow;
  }
  for (int win=startWindow; win <= endWindow; win++) {
    if (index[win] == 0 || chunkStart < index[win]) {
      index[win]=chunkStart;
    }
  }
}",0.9920468815403934
30667,"/** 
 * @return  the chunks associated with this bin
 */
public List<Chunk> getChunkList(){
  return chunkList;
}","/** 
 * Gets the list of chunks associated with this bin.
 * @return the chunks in this bin.  If no chunks are associated, an empty list will be returned.
 */
public List<Chunk> getChunkList(){
  if (chunkList == null)   return Collections.<Chunk>emptyList();
  return chunkList;
}",0.3807106598984771
30668,"/** 
 * Perform an overlapping query of all bins bounding the given location.
 * @param bin The bin over which to perform an overlapping query.
 * @return The file pointers
 */
public BAMFileSpan getSpanOverlapping(final Bin bin){
  if (bin == null)   return null;
  final int referenceSequence=bin.getReferenceSequence();
  BAMIndexContent indexQuery=getQueryResults(referenceSequence);
  if (indexQuery == null)   return null;
  final int binLevel=getLevelForBin(bin);
  final int firstLocusInBin=getFirstLocusInBin(bin);
  List<Bin> binTree=new ArrayList<Bin>();
  if (indexQuery.containsBin(bin))   binTree.add(bin);
  int currentBinLevel=binLevel;
  while (--currentBinLevel >= 0) {
    final int binStart=getFirstBinInLevel(currentBinLevel);
    final int binWidth=getMaxAddressibleGenomicLocation() / getLevelSize(currentBinLevel);
    final int binNumber=firstLocusInBin / binWidth + binStart;
    Bin parentBin=new Bin(bin.getReferenceSequence(),binNumber);
    if (indexQuery.containsBin(parentBin))     binTree.add(parentBin);
  }
  List<Chunk> chunkList=new ArrayList<Chunk>();
  for (  Bin coveringBin : binTree) {
    for (    Chunk chunk : coveringBin.getChunkList())     chunkList.add(chunk.clone());
  }
  final int start=getFirstLocusInBin(bin);
  chunkList=optimizeChunkList(chunkList,indexQuery.getLinearIndex().getMinimumOffset(start));
  return new BAMFileSpan(chunkList);
}","/** 
 * Perform an overlapping query of all bins bounding the given location.
 * @param bin The bin over which to perform an overlapping query.
 * @return The file pointers
 */
public BAMFileSpan getSpanOverlapping(final Bin bin){
  if (bin == null)   return null;
  final int referenceSequence=bin.getReferenceSequence();
  BAMIndexContent indexQuery=getQueryResults(referenceSequence);
  if (indexQuery == null)   return null;
  final int binLevel=getLevelForBin(bin);
  final int firstLocusInBin=getFirstLocusInBin(bin);
  List<Bin> binTree=new ArrayList<Bin>();
  if (indexQuery.containsBin(bin))   binTree.add(indexQuery.getBins().getBin(bin.getBinNumber()));
  int currentBinLevel=binLevel;
  while (--currentBinLevel >= 0) {
    final int binStart=getFirstBinInLevel(currentBinLevel);
    final int binWidth=getMaxAddressibleGenomicLocation() / getLevelSize(currentBinLevel);
    final int binNumber=firstLocusInBin / binWidth + binStart;
    Bin parentBin=indexQuery.getBins().getBin(binNumber);
    if (parentBin != null && indexQuery.containsBin(parentBin))     binTree.add(parentBin);
  }
  List<Chunk> chunkList=new ArrayList<Chunk>();
  for (  Bin coveringBin : binTree) {
    for (    Chunk chunk : coveringBin.getChunkList())     chunkList.add(chunk.clone());
  }
  final int start=getFirstLocusInBin(bin);
  chunkList=optimizeChunkList(chunkList,indexQuery.getLinearIndex().getMinimumOffset(start));
  return new BAMFileSpan(chunkList);
}",0.9529824561403508
30669,"protected int doWork(){
  boolean allQueryNameSorted=true;
  final List<SAMFileReader> readers=new ArrayList<SAMFileReader>();
  for (  final File f : INPUT) {
    IoUtil.assertFileIsReadable(f);
    SAMFileReader reader=new SAMFileReader(f);
    readers.add(new SAMFileReader(f));
    if (reader.getFileHeader().getSortOrder() != SortOrder.queryname)     allQueryNameSorted=false;
  }
  if (OUTPUT != null)   OUTPUT=OUTPUT.getAbsoluteFile();
  final boolean differentOutputSpecified=OUTPUT != null;
  if (differentOutputSpecified) {
    IoUtil.assertFileIsWritable(OUTPUT);
  }
 else   if (INPUT.size() != 1) {
    throw new PicardException(""String_Node_Str"");
  }
 else {
    final File soleInput=INPUT.get(0).getAbsoluteFile();
    final File dir=soleInput.getParentFile().getAbsoluteFile();
    try {
      IoUtil.assertFileIsWritable(soleInput);
      IoUtil.assertDirectoryIsWritable(dir);
      OUTPUT=File.createTempFile(soleInput.getName() + ""String_Node_Str"",""String_Node_Str"",dir);
    }
 catch (    IOException ioe) {
      throw new RuntimeIOException(""String_Node_Str"" + dir.getAbsolutePath());
    }
  }
  final PeekableIterator<SAMRecord> iterator;
  final SAMFileHeader header;
{
    Iterator<SAMRecord> tmp;
    if (INPUT.size() > 1) {
      final SamFileHeaderMerger merger=new SamFileHeaderMerger(readers,SortOrder.unsorted,false);
      tmp=new MergingSamRecordIterator(merger,false);
      header=merger.getMergedHeader();
    }
 else {
      tmp=readers.get(0).iterator();
      header=readers.get(0).getFileHeader();
    }
    if (allQueryNameSorted) {
      iterator=new PeekableIterator<SAMRecord>(tmp);
    }
 else {
      log.info(""String_Node_Str"");
      final SortingCollection<SAMRecord> sorter=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordQueryNameComparator(),MAX_RECORDS_IN_RAM,TMP_DIR);
      while (tmp.hasNext()) {
        sorter.add(tmp.next());
      }
      iterator=new PeekableIterator<SAMRecord>(sorter.iterator());
      log.info(""String_Node_Str"");
    }
    final SortOrder outputSortOrder=SORT_ORDER == null ? readers.get(0).getFileHeader().getSortOrder() : SORT_ORDER;
    log.info(""String_Node_Str"" + outputSortOrder);
    header.setSortOrder(outputSortOrder);
  }
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,header.getSortOrder() == SortOrder.queryname,OUTPUT);
  log.info(""String_Node_Str"");
  int count=0;
  while (iterator.hasNext()) {
    final SAMRecord rec1=iterator.next();
    final SAMRecord rec2=iterator.hasNext() ? iterator.peek() : null;
    if (rec2 != null && rec1.getReadName().equals(rec2.getReadName())) {
      iterator.next();
      SamPairUtil.setMateInfo(rec1,rec2,header);
      out.addAlignment(rec1);
      out.addAlignment(rec2);
      count+=2;
    }
 else {
      out.addAlignment(rec1);
      ++count;
    }
    if (count % 1000000 == 0) {
      log.info(""String_Node_Str"" + count + ""String_Node_Str"");
    }
  }
  if (header.getSortOrder() == SortOrder.queryname) {
    log.info(""String_Node_Str"");
  }
 else {
    log.info(""String_Node_Str"");
  }
  out.close();
  if (!differentOutputSpecified) {
    log.info(""String_Node_Str"");
    final File soleInput=INPUT.get(0).getAbsoluteFile();
    final File old=new File(soleInput.getParentFile(),soleInput.getName() + ""String_Node_Str"");
    if (!old.exists() && soleInput.renameTo(old)) {
      if (OUTPUT.renameTo(soleInput)) {
        if (!old.delete()) {
          log.warn(""String_Node_Str"" + old.getAbsolutePath());
          return 1;
        }
      }
 else {
        log.error(""String_Node_Str"" + soleInput.getAbsolutePath());
        log.error(""String_Node_Str"" + old.getAbsolutePath());
        log.error(""String_Node_Str"" + OUTPUT.getAbsolutePath());
        return 1;
      }
    }
 else {
      log.error(""String_Node_Str"" + soleInput.getAbsolutePath());
      if (!OUTPUT.delete()) {
        log.error(""String_Node_Str"" + OUTPUT.getAbsolutePath());
      }
      return 1;
    }
  }
  return 0;
}","protected int doWork(){
  boolean allQueryNameSorted=true;
  final List<SAMFileReader> readers=new ArrayList<SAMFileReader>();
  for (  final File f : INPUT) {
    IoUtil.assertFileIsReadable(f);
    SAMFileReader reader=new SAMFileReader(f);
    readers.add(new SAMFileReader(f));
    if (reader.getFileHeader().getSortOrder() != SortOrder.queryname)     allQueryNameSorted=false;
  }
  if (OUTPUT != null)   OUTPUT=OUTPUT.getAbsoluteFile();
  final boolean differentOutputSpecified=OUTPUT != null;
  if (differentOutputSpecified) {
    IoUtil.assertFileIsWritable(OUTPUT);
  }
 else   if (INPUT.size() != 1) {
    throw new PicardException(""String_Node_Str"");
  }
 else {
    final File soleInput=INPUT.get(0).getAbsoluteFile();
    final File dir=soleInput.getParentFile().getAbsoluteFile();
    try {
      IoUtil.assertFileIsWritable(soleInput);
      IoUtil.assertDirectoryIsWritable(dir);
      OUTPUT=File.createTempFile(soleInput.getName() + ""String_Node_Str"",""String_Node_Str"",dir);
    }
 catch (    IOException ioe) {
      throw new RuntimeIOException(""String_Node_Str"" + dir.getAbsolutePath());
    }
  }
  final PeekableIterator<SAMRecord> iterator;
  final SAMFileHeader header;
{
    Iterator<SAMRecord> tmp;
    if (INPUT.size() > 1) {
      final SamFileHeaderMerger merger=new SamFileHeaderMerger(readers,SortOrder.unsorted,false);
      tmp=new MergingSamRecordIterator(merger,false);
      header=merger.getMergedHeader();
    }
 else {
      tmp=readers.get(0).iterator();
      header=readers.get(0).getFileHeader();
    }
    if (allQueryNameSorted) {
      iterator=new PeekableIterator<SAMRecord>(tmp);
    }
 else {
      log.info(""String_Node_Str"");
      final SortingCollection<SAMRecord> sorter=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordQueryNameComparator(),MAX_RECORDS_IN_RAM,TMP_DIR);
      while (tmp.hasNext()) {
        sorter.add(tmp.next());
      }
      iterator=new PeekableIterator<SAMRecord>(sorter.iterator());
      log.info(""String_Node_Str"");
    }
    final SortOrder outputSortOrder=SORT_ORDER == null ? readers.get(0).getFileHeader().getSortOrder() : SORT_ORDER;
    log.info(""String_Node_Str"" + outputSortOrder);
    header.setSortOrder(outputSortOrder);
  }
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header,header.getSortOrder() == SortOrder.queryname,OUTPUT);
  log.info(""String_Node_Str"");
  long count=0;
  while (iterator.hasNext()) {
    final SAMRecord rec1=iterator.next();
    final SAMRecord rec2=iterator.hasNext() ? iterator.peek() : null;
    if (rec2 != null && rec1.getReadName().equals(rec2.getReadName())) {
      iterator.next();
      SamPairUtil.setMateInfo(rec1,rec2,header);
      out.addAlignment(rec1);
      out.addAlignment(rec2);
      count+=2;
    }
 else {
      out.addAlignment(rec1);
      ++count;
    }
    if (count % 1000000 == 0) {
      log.info(""String_Node_Str"" + count + ""String_Node_Str"");
    }
  }
  if (header.getSortOrder() == SortOrder.queryname) {
    log.info(""String_Node_Str"");
  }
 else {
    log.info(""String_Node_Str"");
  }
  out.close();
  if (!differentOutputSpecified) {
    log.info(""String_Node_Str"");
    final File soleInput=INPUT.get(0).getAbsoluteFile();
    final File old=new File(soleInput.getParentFile(),soleInput.getName() + ""String_Node_Str"");
    if (!old.exists() && soleInput.renameTo(old)) {
      if (OUTPUT.renameTo(soleInput)) {
        if (!old.delete()) {
          log.warn(""String_Node_Str"" + old.getAbsolutePath());
          return 1;
        }
      }
 else {
        log.error(""String_Node_Str"" + soleInput.getAbsolutePath());
        log.error(""String_Node_Str"" + old.getAbsolutePath());
        log.error(""String_Node_Str"" + OUTPUT.getAbsolutePath());
        return 1;
      }
    }
 else {
      log.error(""String_Node_Str"" + soleInput.getAbsolutePath());
      if (!OUTPUT.delete()) {
        log.error(""String_Node_Str"" + OUTPUT.getAbsolutePath());
      }
      return 1;
    }
  }
  return 0;
}",0.999128160418483
30670,"protected BAMIndexContent query(final int referenceSequence,final int startPos,final int endPos){
  if (mFileBuffer == null)   throw new SAMException(""String_Node_Str"");
  seek(4);
  List<Bin> bins=null;
  LinearIndex linearIndex=null;
  final int sequenceCount=readInteger();
  if (referenceSequence >= sequenceCount) {
    return null;
  }
  final BitSet regionBins=regionToBins(startPos,endPos);
  if (regionBins == null) {
    return null;
  }
  skipToSequence(referenceSequence);
  final int binCount=readInteger();
  bins=new ArrayList<Bin>(binCount);
  for (int binNumber=0; binNumber < binCount; binNumber++) {
    List<Chunk> chunks=new ArrayList<Chunk>();
    final int indexBin=readInteger();
    final int nChunks=readInteger();
    if (regionBins.get(indexBin) || indexBin == MAX_BINS) {
      for (int ci=0; ci < nChunks; ci++) {
        final long chunkBegin=readLong();
        final long chunkEnd=readLong();
        chunks.add(new Chunk(chunkBegin,chunkEnd));
      }
    }
 else {
      skipBytes(16 * nChunks);
    }
    Bin bin=new Bin(referenceSequence,indexBin);
    bin.setChunkList(chunks);
    bins.add(bin);
  }
  Collections.sort(bins);
  final int nLinearBins=readInteger();
  final int regionLinearBinStart=LinearIndex.convertToLinearIndexOffset(startPos);
  final int regionLinearBinStop=LinearIndex.convertToLinearIndexOffset(endPos) > 0 ? LinearIndex.convertToLinearIndexOffset(endPos) : nLinearBins - 1;
  long[] linearIndexEntries=new long[0];
  if (regionLinearBinStart < nLinearBins) {
    linearIndexEntries=new long[regionLinearBinStop - regionLinearBinStart + 1];
    skipBytes(8 * regionLinearBinStart);
    for (int linearBin=regionLinearBinStart; linearBin <= regionLinearBinStop && linearBin <= nLinearBins - 1; linearBin++)     linearIndexEntries[linearBin - regionLinearBinStart]=readLong();
  }
  linearIndex=new LinearIndex(referenceSequence,regionLinearBinStart,linearIndexEntries);
  return new BAMIndexContent(referenceSequence,bins,linearIndex);
}","protected BAMIndexContent query(final int referenceSequence,final int startPos,final int endPos){
  if (mFileBuffer == null)   throw new SAMException(""String_Node_Str"");
  seek(4);
  List<Bin> bins=null;
  LinearIndex linearIndex=null;
  final int sequenceCount=readInteger();
  if (referenceSequence >= sequenceCount) {
    return null;
  }
  final BitSet regionBins=regionToBins(startPos,endPos);
  if (regionBins == null) {
    return null;
  }
  skipToSequence(referenceSequence);
  final int binCount=readInteger();
  bins=new ArrayList<Bin>(binCount);
  for (int binNumber=0; binNumber < binCount; binNumber++) {
    List<Chunk> chunks=new ArrayList<Chunk>();
    final int indexBin=readInteger();
    final int nChunks=readInteger();
    if (regionBins.get(indexBin) || indexBin == MAX_BINS) {
      for (int ci=0; ci < nChunks; ci++) {
        final long chunkBegin=readLong();
        final long chunkEnd=readLong();
        chunks.add(new Chunk(chunkBegin,chunkEnd));
      }
    }
 else {
      skipBytes(16 * nChunks);
    }
    Bin bin=new Bin(referenceSequence,indexBin);
    bin.setChunkList(chunks);
    bins.add(bin);
  }
  Collections.sort(bins);
  final int nLinearBins=readInteger();
  final int regionLinearBinStart=LinearIndex.convertToLinearIndexOffset(startPos);
  final int regionLinearBinStop=LinearIndex.convertToLinearIndexOffset(endPos) > 0 ? LinearIndex.convertToLinearIndexOffset(endPos) : nLinearBins - 1;
  final int actualStop=Math.min(regionLinearBinStop,nLinearBins - 1);
  long[] linearIndexEntries=new long[0];
  if (regionLinearBinStart < nLinearBins) {
    linearIndexEntries=new long[actualStop - regionLinearBinStart + 1];
    skipBytes(8 * regionLinearBinStart);
    for (int linearBin=regionLinearBinStart; linearBin <= actualStop; linearBin++)     linearIndexEntries[linearBin - regionLinearBinStart]=readLong();
  }
  linearIndex=new LinearIndex(referenceSequence,regionLinearBinStart,linearIndexEntries);
  return new BAMIndexContent(referenceSequence,bins,linearIndex);
}",0.964161274265804
30671,"/** 
 * Merges the alignment from the map file with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  SAMFileReader unmappedSam=null;
  if (this.unmappedBamFile != null) {
    unmappedSam=new SAMFileReader(IoUtil.openFileForReading(this.unmappedBamFile));
  }
  if (unmappedSam != null)   header.setReadGroups(unmappedSam.getFileHeader().getReadGroups());
  int aligned=0;
  int unmapped=0;
  final PeekableIterator<SAMRecord> alignedIterator=new PeekableIterator(getQuerynameSortedAlignedRecords());
  final SortingCollection<SAMRecord> alignmentSorted=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordCoordinateComparator(),MAX_RECORDS_IN_RAM);
  final ClippedPairFixer pairFixer=new ClippedPairFixer(alignmentSorted,header);
  final CloseableIterator<SAMRecord> unmappedIterator=unmappedSam.iterator();
  SAMRecord nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
  SAMRecord lastAligned=null;
  final UnmappedReadSorter unmappedSorter=new UnmappedReadSorter(unmappedIterator);
  while (unmappedSorter.hasNext()) {
    final SAMRecord rec=unmappedSorter.next();
    rec.setReadName(cleanReadName(rec.getReadName()));
    if (nextAligned != null && rec.getReadName().compareTo(nextAligned.getReadName()) > 0) {
      throw new PicardException(""String_Node_Str"" + nextAligned.getReadName() + ""String_Node_Str""+ rec.getReadName()+ ""String_Node_Str"");
    }
    rec.setHeader(header);
    if (isMatch(rec,nextAligned)) {
      if (!ignoreAlignment(nextAligned)) {
        setValuesFromAlignment(rec,nextAligned);
        if (programRecord != null) {
          rec.setAttribute(ReservedTagConstants.PROGRAM_GROUP_ID,programRecord.getProgramGroupId());
        }
        aligned++;
      }
      nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
    }
 else {
      unmapped++;
    }
    final boolean eitherReadMapped=!rec.getReadUnmappedFlag() || (rec.getReadPairedFlag() && !rec.getMateUnmappedFlag());
    if (eitherReadMapped || !alignedReadsOnly) {
      pairFixer.add(rec);
    }
  }
  unmappedIterator.close();
  alignedIterator.close();
  final SAMFileWriter writer=new SAMFileWriterFactory().makeBAMWriter(header,true,this.targetBamFile);
  int count=0;
  CloseableIterator<SAMRecord> it=alignmentSorted.iterator();
  while (it.hasNext()) {
    SAMRecord rec=it.next();
    if (!rec.getReadUnmappedFlag()) {
      if (refSeq != null) {
        byte referenceBases[]=refSeq.get(rec.getReferenceIndex()).getBases();
        rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTag(rec,referenceBases,0,bisulfiteSequence));
        rec.setAttribute(SAMTag.UQ.name(),SequenceUtil.sumQualitiesOfMismatches(rec,referenceBases,0,bisulfiteSequence));
      }
    }
    writer.addAlignment(rec);
    if (++count % 1000000 == 0) {
      log.info(count + ""String_Node_Str"" + targetBamFile.getName());
    }
  }
  writer.close();
  log.info(""String_Node_Str"" + aligned + ""String_Node_Str""+ unmapped+ ""String_Node_Str"");
}","/** 
 * Merges the alignment from the map file with the non-aligned records from the source BAM file.
 */
public void mergeAlignment(){
  SAMFileReader unmappedSam=null;
  if (this.unmappedBamFile != null) {
    unmappedSam=new SAMFileReader(IoUtil.openFileForReading(this.unmappedBamFile));
  }
  if (unmappedSam != null)   header.setReadGroups(unmappedSam.getFileHeader().getReadGroups());
  int aligned=0;
  int unmapped=0;
  final PeekableIterator<SAMRecord> alignedIterator=new PeekableIterator(getQuerynameSortedAlignedRecords());
  final SortingCollection<SAMRecord> alignmentSorted=SortingCollection.newInstance(SAMRecord.class,new BAMRecordCodec(header),new SAMRecordCoordinateComparator(),MAX_RECORDS_IN_RAM);
  final ClippedPairFixer pairFixer=new ClippedPairFixer(alignmentSorted,header,alignedReadsOnly);
  final CloseableIterator<SAMRecord> unmappedIterator=unmappedSam.iterator();
  SAMRecord nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
  SAMRecord lastAligned=null;
  final UnmappedReadSorter unmappedSorter=new UnmappedReadSorter(unmappedIterator);
  while (unmappedSorter.hasNext()) {
    final SAMRecord rec=unmappedSorter.next();
    rec.setReadName(cleanReadName(rec.getReadName()));
    if (nextAligned != null && rec.getReadName().compareTo(nextAligned.getReadName()) > 0) {
      throw new PicardException(""String_Node_Str"" + nextAligned.getReadName() + ""String_Node_Str""+ rec.getReadName()+ ""String_Node_Str"");
    }
    rec.setHeader(header);
    if (isMatch(rec,nextAligned)) {
      if (!ignoreAlignment(nextAligned)) {
        setValuesFromAlignment(rec,nextAligned);
        if (programRecord != null) {
          rec.setAttribute(ReservedTagConstants.PROGRAM_GROUP_ID,programRecord.getProgramGroupId());
        }
        aligned++;
      }
      nextAligned=alignedIterator.hasNext() ? alignedIterator.next() : null;
    }
 else {
      unmapped++;
    }
    final boolean eitherReadMapped=!rec.getReadUnmappedFlag() || (rec.getReadPairedFlag() && !rec.getMateUnmappedFlag());
    if (eitherReadMapped || !alignedReadsOnly) {
      pairFixer.add(rec);
    }
  }
  unmappedIterator.close();
  alignedIterator.close();
  final SAMFileWriter writer=new SAMFileWriterFactory().makeBAMWriter(header,true,this.targetBamFile);
  int count=0;
  CloseableIterator<SAMRecord> it=alignmentSorted.iterator();
  while (it.hasNext()) {
    SAMRecord rec=it.next();
    if (!rec.getReadUnmappedFlag()) {
      if (refSeq != null) {
        byte referenceBases[]=refSeq.get(rec.getReferenceIndex()).getBases();
        rec.setAttribute(SAMTag.NM.name(),SequenceUtil.calculateSamNmTag(rec,referenceBases,0,bisulfiteSequence));
        rec.setAttribute(SAMTag.UQ.name(),SequenceUtil.sumQualitiesOfMismatches(rec,referenceBases,0,bisulfiteSequence));
      }
    }
    writer.addAlignment(rec);
    if (++count % 1000000 == 0) {
      log.info(count + ""String_Node_Str"" + targetBamFile.getName());
    }
  }
  writer.close();
  log.info(""String_Node_Str"" + aligned + ""String_Node_Str""+ (alignedReadsOnly ? 0 : unmapped)+ ""String_Node_Str"");
}",0.9905259719046065
30672,"public void add(final SAMRecord record){
  if (!record.getReadPairedFlag()) {
    collection.add(record);
  }
 else   if (pending == null) {
    pending=record;
  }
 else {
    if (!record.getReadName().equals(pending.getReadName())) {
      throw new PicardException(""String_Node_Str"" + record.getReadName() + ""String_Node_Str""+ pending.getReadName());
    }
    if (!(record.getReadUnmappedFlag() || pending.getReadUnmappedFlag())) {
      if (record.getReadNegativeStrandFlag() != pending.getReadNegativeStrandFlag()) {
        final SAMRecord pos=(record.getReadNegativeStrandFlag()) ? pending : record;
        final SAMRecord neg=(record.getReadNegativeStrandFlag()) ? record : pending;
        if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {
          final int posDiff=pos.getAlignmentEnd() - neg.getAlignmentEnd();
          final int negDiff=pos.getAlignmentStart() - neg.getAlignmentStart();
          if (posDiff > 0) {
            CigarUtil.softClip3PrimeEndOfRead(pos,Math.min(pos.getReadLength(),pos.getReadLength() - posDiff + 1));
          }
          if (negDiff > 0) {
            CigarUtil.softClip3PrimeEndOfRead(neg,Math.min(neg.getReadLength(),neg.getReadLength() - negDiff + 1));
          }
        }
      }
 else {
      }
    }
    SamPairUtil.setMateInfo(record,pending,header);
    collection.add(pending);
    collection.add(record);
    pending=null;
  }
}","public void add(final SAMRecord record){
  if (!record.getReadPairedFlag()) {
    collection.add(record);
  }
 else   if (pending == null) {
    pending=record;
  }
 else   if (alignedOnly && !pending.getReadName().equals(record.getReadName())) {
    collection.add(pending);
    pending=record;
  }
 else {
    if (!record.getReadName().equals(pending.getReadName())) {
      throw new PicardException(""String_Node_Str"" + record.getReadName() + ""String_Node_Str""+ pending.getReadName());
    }
    if (!(record.getReadUnmappedFlag() || pending.getReadUnmappedFlag())) {
      if (record.getReadNegativeStrandFlag() != pending.getReadNegativeStrandFlag()) {
        final SAMRecord pos=(record.getReadNegativeStrandFlag()) ? pending : record;
        final SAMRecord neg=(record.getReadNegativeStrandFlag()) ? record : pending;
        if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {
          final int posDiff=pos.getAlignmentEnd() - neg.getAlignmentEnd();
          final int negDiff=pos.getAlignmentStart() - neg.getAlignmentStart();
          if (posDiff > 0) {
            CigarUtil.softClip3PrimeEndOfRead(pos,Math.min(pos.getReadLength(),pos.getReadLength() - posDiff + 1));
          }
          if (negDiff > 0) {
            CigarUtil.softClip3PrimeEndOfRead(neg,Math.min(neg.getReadLength(),neg.getReadLength() - negDiff + 1));
          }
        }
      }
 else {
      }
    }
    SamPairUtil.setMateInfo(record,pending,header);
    collection.add(pending);
    collection.add(record);
    pending=null;
  }
}",0.953877690468056
30673,"public ClippedPairFixer(final SortingCollection<SAMRecord> collection,final SAMFileHeader header){
  this.collection=collection;
  this.header=header;
}","public ClippedPairFixer(final SortingCollection<SAMRecord> collection,final SAMFileHeader header,boolean alignedReadsOnly){
  this.collection=collection;
  this.header=header;
  this.alignedOnly=alignedReadsOnly;
}",0.8306010928961749
30674,"/** 
 * Prints the histogram if one is present. 
 */
private void printHistogram(BufferedWriter out,FormatUtil formatter) throws IOException {
  if (this.histograms.isEmpty()) {
    return;
  }
  java.util.Set<HKEY> keys=new TreeSet<HKEY>();
  for (  Histogram<HKEY> histo : histograms) {
    if (histo != null)     keys.addAll(histo.keySet());
  }
  out.append(HISTO_HEADER + this.histograms.get(0).keySet().iterator().next().getClass().getName());
  out.newLine();
  out.append(StringUtil.assertCharactersNotInString(this.histograms.get(0).getBinLabel(),'\t','\n'));
  for (  Histogram<HKEY> histo : this.histograms) {
    out.append(SEPARATOR);
    out.append(StringUtil.assertCharactersNotInString(histo.getValueLabel(),'\t','\n'));
  }
  out.newLine();
  for (  HKEY key : keys) {
    out.append(key.toString());
    for (    Histogram<HKEY> histo : this.histograms) {
      Histogram<HKEY>.Bin bin=histo.get(key);
      final double value=(bin == null ? 0 : bin.getValue());
      out.append(SEPARATOR);
      out.append(formatter.format(value));
    }
    out.newLine();
  }
}","/** 
 * Prints the histogram if one is present. 
 */
private void printHistogram(BufferedWriter out,FormatUtil formatter) throws IOException {
  if (this.histograms.isEmpty()) {
    return;
  }
  java.util.Set<HKEY> keys=new TreeSet<HKEY>(histograms.get(0).comparator());
  for (  Histogram<HKEY> histo : histograms) {
    if (histo != null)     keys.addAll(histo.keySet());
  }
  out.append(HISTO_HEADER + this.histograms.get(0).keySet().iterator().next().getClass().getName());
  out.newLine();
  out.append(StringUtil.assertCharactersNotInString(this.histograms.get(0).getBinLabel(),'\t','\n'));
  for (  Histogram<HKEY> histo : this.histograms) {
    out.append(SEPARATOR);
    out.append(StringUtil.assertCharactersNotInString(histo.getValueLabel(),'\t','\n'));
  }
  out.newLine();
  for (  HKEY key : keys) {
    out.append(key.toString());
    for (    Histogram<HKEY> histo : this.histograms) {
      Histogram<HKEY>.Bin bin=histo.get(key);
      final double value=(bin == null ? 0 : bin.getValue());
      out.append(SEPARATOR);
      out.append(formatter.format(value));
    }
    out.newLine();
  }
}",0.9863387978142076
30675,"/** 
 * Reads the Metrics in from the given reader. 
 */
public void read(Reader r){
  BufferedReader in=new BufferedReader(r);
  FormatUtil formatter=new FormatUtil();
  String line=null;
  try {
    Header header=null;
    boolean inHeader=true;
    while ((line=in.readLine()) != null && inHeader) {
      line=line.trim();
      if (""String_Node_Str"".equals(line)) {
        inHeader=false;
      }
 else       if (line.startsWith(MAJOR_HEADER_PREFIX)) {
        if (header != null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        String className=line.substring(MAJOR_HEADER_PREFIX.length()).trim();
        try {
          header=(Header)loadClass(className).newInstance();
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + className,e);
        }
      }
 else       if (line.startsWith(MINOR_HEADER_PREFIX)) {
        if (header == null) {
          throw new IllegalStateException(""String_Node_Str"" + line);
        }
        header.parse(line.substring(MINOR_HEADER_PREFIX.length()));
        this.headers.add(header);
        header=null;
      }
 else {
        throw new PicardException(""String_Node_Str"" + line);
      }
    }
    if (line == null) {
      throw new PicardException(""String_Node_Str"");
    }
    while (!line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine().trim();
    }
    if (line.startsWith(METRIC_HEADER)) {
      String className=line.split(SEPARATOR)[1];
      Class<?> type=null;
      try {
        type=loadClass(className);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + className,cnfe);
      }
      String[] fieldNames=in.readLine().split(SEPARATOR);
      Field[] fields=new Field[fieldNames.length];
      for (int i=0; i < fieldNames.length; ++i) {
        try {
          fields[i]=type.getField(fieldNames[i]);
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + fieldNames[i] + ""String_Node_Str""+ type.getName());
        }
      }
      while ((line=in.readLine()) != null) {
        line=line.trim();
        if (""String_Node_Str"".equals(line)) {
          break;
        }
 else {
          String[] values=line.split(SEPARATOR,-1);
          BEAN bean=null;
          try {
            bean=(BEAN)type.newInstance();
          }
 catch (          Exception e) {
            throw new PicardException(""String_Node_Str"" + type.getName(),e);
          }
          for (int i=0; i < fields.length; ++i) {
            Object value=null;
            if (values[i] != null && values[i].length() > 0) {
              value=formatter.parseObject(values[i],fields[i].getType());
            }
            try {
              fields[i].set(bean,value);
            }
 catch (            Exception e) {
              throw new PicardException(""String_Node_Str"" + fields[i].getName() + ""String_Node_Str""+ type.getName(),e);
            }
          }
          this.metrics.add(bean);
        }
      }
    }
    while (line != null && !line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine();
    }
    if (line != null && line.startsWith(HISTO_HEADER)) {
      String keyClassName=line.split(SEPARATOR)[1].trim();
      Class<?> keyClass=null;
      try {
        keyClass=loadClass(keyClassName);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + keyClassName);
      }
      String[] labels=in.readLine().split(SEPARATOR);
      for (int i=1; i < labels.length; ++i) {
        this.histograms.add(new Histogram<HKEY>(labels[0],labels[i]));
      }
      while ((line=in.readLine()) != null && !""String_Node_Str"".equals(line)) {
        String[] fields=line.trim().split(SEPARATOR);
        HKEY key=(HKEY)formatter.parseObject(fields[0],keyClass);
        for (int i=1; i < fields.length; ++i) {
          double value=formatter.parseDouble(fields[i]);
          this.histograms.get(i - 1).increment(key,value);
        }
      }
    }
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}","/** 
 * Reads the Metrics in from the given reader. 
 */
public void read(Reader r){
  BufferedReader in=new BufferedReader(r);
  FormatUtil formatter=new FormatUtil();
  String line=null;
  try {
    Header header=null;
    boolean inHeader=true;
    while ((line=in.readLine()) != null && inHeader) {
      line=line.trim();
      if (""String_Node_Str"".equals(line)) {
        inHeader=false;
      }
 else       if (line.startsWith(MAJOR_HEADER_PREFIX)) {
        if (header != null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        String className=line.substring(MAJOR_HEADER_PREFIX.length()).trim();
        try {
          header=(Header)loadClass(className).newInstance();
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + className,e);
        }
      }
 else       if (line.startsWith(MINOR_HEADER_PREFIX)) {
        if (header == null) {
          throw new IllegalStateException(""String_Node_Str"" + line);
        }
        header.parse(line.substring(MINOR_HEADER_PREFIX.length()));
        this.headers.add(header);
        header=null;
      }
 else {
        throw new PicardException(""String_Node_Str"" + line);
      }
    }
    if (line == null) {
      throw new PicardException(""String_Node_Str"");
    }
    while (!line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine().trim();
    }
    if (line.startsWith(METRIC_HEADER)) {
      String className=line.split(SEPARATOR)[1];
      Class<?> type=null;
      try {
        type=loadClass(className);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + className,cnfe);
      }
      String[] fieldNames=in.readLine().split(SEPARATOR);
      Field[] fields=new Field[fieldNames.length];
      for (int i=0; i < fieldNames.length; ++i) {
        try {
          fields[i]=type.getField(fieldNames[i]);
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + fieldNames[i] + ""String_Node_Str""+ type.getName());
        }
      }
      while ((line=in.readLine()) != null) {
        if (""String_Node_Str"".equals(line.trim())) {
          break;
        }
 else {
          String[] values=line.split(SEPARATOR,-1);
          BEAN bean=null;
          try {
            bean=(BEAN)type.newInstance();
          }
 catch (          Exception e) {
            throw new PicardException(""String_Node_Str"" + type.getName(),e);
          }
          for (int i=0; i < fields.length; ++i) {
            Object value=null;
            if (values[i] != null && values[i].length() > 0) {
              value=formatter.parseObject(values[i],fields[i].getType());
            }
            try {
              fields[i].set(bean,value);
            }
 catch (            Exception e) {
              throw new PicardException(""String_Node_Str"" + fields[i].getName() + ""String_Node_Str""+ type.getName(),e);
            }
          }
          this.metrics.add(bean);
        }
      }
    }
    while (line != null && !line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine();
    }
    if (line != null && line.startsWith(HISTO_HEADER)) {
      String keyClassName=line.split(SEPARATOR)[1].trim();
      Class<?> keyClass=null;
      try {
        keyClass=loadClass(keyClassName);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + keyClassName);
      }
      String[] labels=in.readLine().split(SEPARATOR);
      for (int i=1; i < labels.length; ++i) {
        this.histograms.add(new Histogram<HKEY>(labels[0],labels[i]));
      }
      while ((line=in.readLine()) != null && !""String_Node_Str"".equals(line)) {
        String[] fields=line.trim().split(SEPARATOR);
        HKEY key=(HKEY)formatter.parseObject(fields[0],keyClass);
        for (int i=1; i < fields.length; ++i) {
          double value=formatter.parseDouble(fields[i]);
          this.histograms.get(i - 1).increment(key,value);
        }
      }
    }
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}",0.9960024227740764
30676,"/** 
 * Checks to see if there are clashes where different readers are using the same read group IDs. If they are then a new set of unique read group IDs are generated (across all read groups) otherwise the original read group headers are returned.
 * @param readers readers to combine
 * @return new list of readgroups constructed from all the readers
 */
private List<SAMReadGroupRecord> mergeReadGroups(final Collection<SAMFileReader> readers){
  final Map<String,SAMReadGroupRecord> seenGroupIds=new TreeMap<String,SAMReadGroupRecord>();
  int idx=0;
  for (  final SAMFileReader reader : readers) {
    final Map<String,String> groupIdTranslation=new HashMap<String,String>();
    samReadGroupIdTranslation.put(reader,groupIdTranslation);
    for (    final SAMReadGroupRecord group : reader.getFileHeader().getReadGroups()) {
      final String groupId=group.getReadGroupId();
      final SAMReadGroupRecord seenGroup=seenGroupIds.get(groupId);
      if (seenGroup == null) {
        seenGroupIds.put(groupId,group);
        groupIdTranslation.put(groupId,groupId);
      }
 else       if (!group.equivalent(seenGroup)) {
        hasReadGroupCollisions=true;
        String newGroupId;
        while (seenGroupIds.containsKey(newGroupId=Integer.toString(idx++)))         ;
        seenGroupIds.put(newGroupId,new SAMReadGroupRecord(newGroupId,group));
        groupIdTranslation.put(groupId,newGroupId);
      }
    }
  }
  return new ArrayList<SAMReadGroupRecord>(seenGroupIds.values());
}","/** 
 * Checks to see if there are clashes where different readers are using the same read group IDs. If yes, then those IDs that collided are remapped.
 * @param readers readers to combine
 * @return new list of read groups constructed from all the readers
 */
private List<SAMReadGroupRecord> mergeReadGroups(final Collection<SAMFileReader> readers){
  final HashSet<String> idsThatAreAlreadyTaken=new HashSet<String>();
  final List<HeaderRecordAndFileReader<SAMReadGroupRecord>> readGroupsToProcess=new LinkedList<HeaderRecordAndFileReader<SAMReadGroupRecord>>();
  for (  final SAMFileReader reader : readers) {
    for (    final SAMReadGroupRecord readGroup : reader.getFileHeader().getReadGroups()) {
      if (!idsThatAreAlreadyTaken.add(readGroup.getId()))       throw new PicardException(""String_Node_Str"" + reader + ""String_Node_Str""+ readGroup.getId()+ ""String_Node_Str"");
      readGroupsToProcess.add(new HeaderRecordAndFileReader<SAMReadGroupRecord>(readGroup,reader));
    }
    idsThatAreAlreadyTaken.clear();
  }
  final List<SAMReadGroupRecord> result=new LinkedList<SAMReadGroupRecord>();
  hasReadGroupCollisions=mergeHeaderRecords(readGroupsToProcess,READ_GROUP_RECORD_FACTORY,idsThatAreAlreadyTaken,samReadGroupIdTranslation,result);
  Collections.sort(result,RECORD_ID_COMPARATOR);
  return result;
}",0.3509393831974477
30677,"/** 
 * Checks to see if there are clashes where different readers are using the same program group IDs. If they are then a new set of unique program group IDs are generated (across all program groups) otherwise the original program group headers are returned.
 * @param readers readers to combine
 * @return new list of program groups constructed from all the readers
 */
private List<SAMProgramRecord> mergeProgramGroups(final Collection<SAMFileReader> readers){
  final Map<String,SAMProgramRecord> seenGroupIds=new TreeMap<String,SAMProgramRecord>();
  int idx=0;
  for (  final SAMFileReader reader : readers) {
    final Map<String,String> groupIdTranslation=new HashMap<String,String>();
    samProgramGroupIdTranslation.put(reader,groupIdTranslation);
    for (    final SAMProgramRecord group : reader.getFileHeader().getProgramRecords()) {
      final String groupId=group.getProgramGroupId();
      final SAMProgramRecord seenGroup=seenGroupIds.get(groupId);
      if (seenGroup == null) {
        seenGroupIds.put(groupId,group);
        groupIdTranslation.put(groupId,groupId);
      }
 else       if (!group.equivalent(seenGroup)) {
        hasProgramGroupCollisions=true;
        String newGroupId;
        while (seenGroupIds.containsKey(newGroupId=Integer.toString(idx++)))         ;
        seenGroupIds.put(newGroupId,new SAMProgramRecord(newGroupId,group));
        groupIdTranslation.put(groupId,newGroupId);
      }
    }
  }
  return new ArrayList<SAMProgramRecord>(seenGroupIds.values());
}","/** 
 * Checks to see if there are clashes where different readers are using the same program group IDs. If yes, then those IDs that collided are remapped.
 * @param readers readers to combine
 * @return new list of program groups constructed from all the readers
 */
private List<SAMProgramRecord> mergeProgramGroups(final Collection<SAMFileReader> readers){
  final List<SAMProgramRecord> overallResult=new LinkedList<SAMProgramRecord>();
  final HashSet<String> idsThatAreAlreadyTaken=new HashSet<String>();
  List<HeaderRecordAndFileReader<SAMProgramRecord>> programGroupsLeftToProcess=new LinkedList<HeaderRecordAndFileReader<SAMProgramRecord>>();
  for (  final SAMFileReader reader : readers) {
    for (    final SAMProgramRecord programGroup : reader.getFileHeader().getProgramRecords()) {
      if (!idsThatAreAlreadyTaken.add(programGroup.getId()))       throw new PicardException(""String_Node_Str"" + reader + ""String_Node_Str""+ programGroup.getId()+ ""String_Node_Str"");
      programGroupsLeftToProcess.add(new HeaderRecordAndFileReader<SAMProgramRecord>(programGroup,reader));
    }
    idsThatAreAlreadyTaken.clear();
  }
  List<HeaderRecordAndFileReader<SAMProgramRecord>> currentProgramGroups=new LinkedList<HeaderRecordAndFileReader<SAMProgramRecord>>();
  for (final Iterator<HeaderRecordAndFileReader<SAMProgramRecord>> programGroupsLeftToProcessIterator=programGroupsLeftToProcess.iterator(); programGroupsLeftToProcessIterator.hasNext(); ) {
    final HeaderRecordAndFileReader<SAMProgramRecord> pair=programGroupsLeftToProcessIterator.next();
    if (pair.getHeaderRecord().getAttribute(SAMProgramRecord.PREVIOUS_PROGRAM_GROUP_ID_TAG) == null) {
      programGroupsLeftToProcessIterator.remove();
      currentProgramGroups.add(pair);
    }
  }
  while (!currentProgramGroups.isEmpty()) {
    final List<SAMProgramRecord> currentResult=new LinkedList<SAMProgramRecord>();
    hasProgramGroupCollisions|=mergeHeaderRecords(currentProgramGroups,PROGRAM_RECORD_FACTORY,idsThatAreAlreadyTaken,samProgramGroupIdTranslation,currentResult);
    overallResult.addAll(currentResult);
    currentProgramGroups=translateIds(currentProgramGroups,samProgramGroupIdTranslation,false);
    programGroupsLeftToProcess=translateIds(programGroupsLeftToProcess,samProgramGroupIdTranslation,true);
    LinkedList<HeaderRecordAndFileReader<SAMProgramRecord>> programGroupsToProcessNext=new LinkedList<HeaderRecordAndFileReader<SAMProgramRecord>>();
    for (final Iterator<HeaderRecordAndFileReader<SAMProgramRecord>> programGroupsLeftToProcessIterator=programGroupsLeftToProcess.iterator(); programGroupsLeftToProcessIterator.hasNext(); ) {
      final HeaderRecordAndFileReader<SAMProgramRecord> pairLeftToProcess=programGroupsLeftToProcessIterator.next();
      final Object ppIdOfRecordLeftToProcess=pairLeftToProcess.getHeaderRecord().getAttribute(SAMProgramRecord.PREVIOUS_PROGRAM_GROUP_ID_TAG);
      for (      final HeaderRecordAndFileReader<SAMProgramRecord> justProcessedPair : currentProgramGroups) {
        String idJustProcessed=justProcessedPair.getHeaderRecord().getId();
        if (pairLeftToProcess.getFileReader() == justProcessedPair.getFileReader() && ppIdOfRecordLeftToProcess.equals(idJustProcessed)) {
          programGroupsLeftToProcessIterator.remove();
          programGroupsToProcessNext.add(pairLeftToProcess);
          break;
        }
      }
    }
    currentProgramGroups=programGroupsToProcessNext;
  }
  if (!programGroupsLeftToProcess.isEmpty()) {
    StringBuffer errorMsg=new StringBuffer(programGroupsLeftToProcess.size() + ""String_Node_Str"");
    for (    final HeaderRecordAndFileReader<SAMProgramRecord> pair : programGroupsLeftToProcess) {
      SAMProgramRecord record=pair.getHeaderRecord();
      errorMsg.append(""String_Node_Str"" + record.getProgramGroupId() + ""String_Node_Str""+ record.getProgramName()+ ""String_Node_Str""+ record.getPreviousProgramGroupId()+ ""String_Node_Str"");
    }
    throw new PicardException(errorMsg.toString());
  }
  Collections.sort(overallResult,RECORD_ID_COMPARATOR);
  return overallResult;
}",0.1967799642218247
30678,"public Set<Map.Entry<String,Object>> getAttributes(){
  return mAttributes.entrySet();
}","/** 
 * Returns the Set of attributes.
 */
public Set<Map.Entry<String,Object>> getAttributes(){
  return mAttributes.entrySet();
}",0.8036529680365296
30679,"public String getLibrary(){
  return (String)getAttribute(""String_Node_Str"");
}","public String getLibrary(){
  return (String)getAttribute(LIBRARY_TAG);
}",0.8289473684210527
30680,"public String getSample(){
  return (String)getAttribute(""String_Node_Str"");
}","public String getSample(){
  return (String)getAttribute(READ_GROUP_SAMPLE_TAG);
}",0.8
30681,"public void setSample(final String value){
  setAttribute(""String_Node_Str"",value);
}","public void setSample(final String value){
  setAttribute(READ_GROUP_SAMPLE_TAG,value);
}",0.8160919540229885
30682,"public void setLibrary(final String value){
  setAttribute(""String_Node_Str"",value);
}","public void setLibrary(final String value){
  setAttribute(LIBRARY_TAG,value);
}",0.8433734939759037
30683,"@Test(dataProvider=""String_Node_Str"") public void differentIds(GroupAdapter adapter) throws Exception {
  final String[] groupIds={""String_Node_Str"",""String_Node_Str""};
  final List<? extends AbstractSAMHeaderRecord> groups=adapter.createGroups(groupIds);
  Assert.assertEquals(groups.size(),2);
  int i=0;
  for (  final AbstractSAMHeaderRecord g : groups) {
    System.out.println(""String_Node_Str"" + adapter.getGroupId(g));
    Assert.assertEquals(groupIds[i],adapter.getGroupId(g));
    i++;
  }
}","@Test(dataProvider=""String_Node_Str"") public void differentIds(GroupAdapter adapter) throws Exception {
  final String[] groupIds={""String_Node_Str"",""String_Node_Str""};
  final List<? extends AbstractSAMHeaderRecord> groups=adapter.createGroups(groupIds);
  Assert.assertEquals(groups.size(),2);
  int i=0;
  for (  final AbstractSAMHeaderRecord g : groups) {
    Assert.assertEquals(groupIds[i],adapter.getGroupId(g));
    i++;
  }
}",0.9283422459893048
30684,"/** 
 * Reads the Metrics in from the given reader. 
 */
public void read(Reader r){
  BufferedReader in=new BufferedReader(r);
  FormatUtil formatter=new FormatUtil();
  String line=null;
  try {
    Header header=null;
    boolean inHeader=true;
    while ((line=in.readLine()) != null && inHeader) {
      line=line.trim();
      if (""String_Node_Str"".equals(line)) {
        inHeader=false;
      }
 else       if (line.startsWith(MAJOR_HEADER_PREFIX)) {
        if (header != null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        String className=line.substring(MAJOR_HEADER_PREFIX.length()).trim();
        try {
          header=(Header)loadClass(className).newInstance();
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + className,e);
        }
      }
 else       if (line.startsWith(MINOR_HEADER_PREFIX)) {
        if (header == null) {
          throw new IllegalStateException(""String_Node_Str"" + line);
        }
        header.parse(line.substring(MINOR_HEADER_PREFIX.length()));
        this.headers.add(header);
        header=null;
      }
 else {
        throw new PicardException(""String_Node_Str"" + line);
      }
    }
    if (line == null) {
      throw new PicardException(""String_Node_Str"");
    }
    while (!line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine().trim();
    }
    if (line.startsWith(METRIC_HEADER)) {
      String className=line.split(SEPARATOR)[1];
      Class<?> type=null;
      try {
        type=loadClass(className);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + className,cnfe);
      }
      String[] fieldNames=in.readLine().split(SEPARATOR);
      Field[] fields=new Field[fieldNames.length];
      for (int i=0; i < fieldNames.length; ++i) {
        try {
          fields[i]=type.getField(fieldNames[i]);
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + fieldNames[i] + ""String_Node_Str""+ type.getName());
        }
      }
      while ((line=in.readLine()) != null) {
        line=line.trim();
        if (""String_Node_Str"".equals(line)) {
          break;
        }
 else {
          String[] values=line.split(SEPARATOR);
          BEAN bean=null;
          try {
            bean=(BEAN)type.newInstance();
          }
 catch (          Exception e) {
            throw new PicardException(""String_Node_Str"" + type.getName(),e);
          }
          for (int i=0; i < fields.length; ++i) {
            Object value=null;
            if (values[i] != null && values[i].length() > 0) {
              value=formatter.parseObject(values[i],fields[i].getType());
            }
            try {
              fields[i].set(bean,value);
            }
 catch (            Exception e) {
              throw new PicardException(""String_Node_Str"" + fields[i].getName() + ""String_Node_Str""+ type.getName(),e);
            }
          }
          this.metrics.add(bean);
        }
      }
    }
    while (line != null && !line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine();
    }
    if (line != null && line.startsWith(HISTO_HEADER)) {
      String keyClassName=line.split(SEPARATOR)[1].trim();
      Class<?> keyClass=null;
      try {
        keyClass=loadClass(keyClassName);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + keyClassName);
      }
      String[] labels=in.readLine().split(SEPARATOR);
      for (int i=1; i < labels.length; ++i) {
        this.histograms.add(new Histogram<HKEY>(labels[0],labels[i]));
      }
      while ((line=in.readLine()) != null && !""String_Node_Str"".equals(line)) {
        String[] fields=line.trim().split(SEPARATOR);
        HKEY key=(HKEY)formatter.parseObject(fields[0],keyClass);
        for (int i=1; i < fields.length; ++i) {
          double value=formatter.parseDouble(fields[i]);
          this.histograms.get(i - 1).increment(key,value);
        }
      }
    }
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}","/** 
 * Reads the Metrics in from the given reader. 
 */
public void read(Reader r){
  BufferedReader in=new BufferedReader(r);
  FormatUtil formatter=new FormatUtil();
  String line=null;
  try {
    Header header=null;
    boolean inHeader=true;
    while ((line=in.readLine()) != null && inHeader) {
      line=line.trim();
      if (""String_Node_Str"".equals(line)) {
        inHeader=false;
      }
 else       if (line.startsWith(MAJOR_HEADER_PREFIX)) {
        if (header != null) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        String className=line.substring(MAJOR_HEADER_PREFIX.length()).trim();
        try {
          header=(Header)loadClass(className).newInstance();
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + className,e);
        }
      }
 else       if (line.startsWith(MINOR_HEADER_PREFIX)) {
        if (header == null) {
          throw new IllegalStateException(""String_Node_Str"" + line);
        }
        header.parse(line.substring(MINOR_HEADER_PREFIX.length()));
        this.headers.add(header);
        header=null;
      }
 else {
        throw new PicardException(""String_Node_Str"" + line);
      }
    }
    if (line == null) {
      throw new PicardException(""String_Node_Str"");
    }
    while (!line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine().trim();
    }
    if (line.startsWith(METRIC_HEADER)) {
      String className=line.split(SEPARATOR)[1];
      Class<?> type=null;
      try {
        type=loadClass(className);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + className,cnfe);
      }
      String[] fieldNames=in.readLine().split(SEPARATOR);
      Field[] fields=new Field[fieldNames.length];
      for (int i=0; i < fieldNames.length; ++i) {
        try {
          fields[i]=type.getField(fieldNames[i]);
        }
 catch (        Exception e) {
          throw new PicardException(""String_Node_Str"" + fieldNames[i] + ""String_Node_Str""+ type.getName());
        }
      }
      while ((line=in.readLine()) != null) {
        line=line.trim();
        if (""String_Node_Str"".equals(line)) {
          break;
        }
 else {
          String[] values=line.split(SEPARATOR,-1);
          BEAN bean=null;
          try {
            bean=(BEAN)type.newInstance();
          }
 catch (          Exception e) {
            throw new PicardException(""String_Node_Str"" + type.getName(),e);
          }
          for (int i=0; i < fields.length; ++i) {
            Object value=null;
            if (values[i] != null && values[i].length() > 0) {
              value=formatter.parseObject(values[i],fields[i].getType());
            }
            try {
              fields[i].set(bean,value);
            }
 catch (            Exception e) {
              throw new PicardException(""String_Node_Str"" + fields[i].getName() + ""String_Node_Str""+ type.getName(),e);
            }
          }
          this.metrics.add(bean);
        }
      }
    }
    while (line != null && !line.startsWith(MAJOR_HEADER_PREFIX)) {
      line=in.readLine();
    }
    if (line != null && line.startsWith(HISTO_HEADER)) {
      String keyClassName=line.split(SEPARATOR)[1].trim();
      Class<?> keyClass=null;
      try {
        keyClass=loadClass(keyClassName);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new PicardException(""String_Node_Str"" + keyClassName);
      }
      String[] labels=in.readLine().split(SEPARATOR);
      for (int i=1; i < labels.length; ++i) {
        this.histograms.add(new Histogram<HKEY>(labels[0],labels[i]));
      }
      while ((line=in.readLine()) != null && !""String_Node_Str"".equals(line)) {
        String[] fields=line.trim().split(SEPARATOR);
        HKEY key=(HKEY)formatter.parseObject(fields[0],keyClass);
        for (int i=1; i < fields.length; ++i) {
          double value=formatter.parseDouble(fields[i]);
          this.histograms.get(i - 1).increment(key,value);
        }
      }
    }
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}",0.9996372869060574
30685,"/** 
 * Create SAMFileHeader with additional information.
 * @param readers sam file readers to combine
 * @param sortOrder sort order new header should have
 * @param mergeDictionaries If true, merge sequence dictionaries in new header.  If false, require thatall input sequence dictionaries be identical.
 */
public SamFileHeaderMerger(final Collection<SAMFileReader> readers,final SAMFileHeader.SortOrder sortOrder,final boolean mergeDictionaries){
  this.readers=readers;
  this.mergedHeader=new SAMFileHeader();
  SAMSequenceDictionary sequenceDictionary=null;
  try {
    sequenceDictionary=getSequenceDictionary(readers);
    this.hasMergedSequenceDictionary=false;
  }
 catch (  SequenceUtil.SequenceListsDifferException pe) {
    if (mergeDictionaries) {
      sequenceDictionary=mergeSequenceDictionaries(readers);
      this.hasMergedSequenceDictionary=true;
    }
 else {
      throw pe;
    }
  }
  this.mergedHeader.setSequenceDictionary(sequenceDictionary);
  for (  final SAMProgramRecord program : mergeProgramGroups(readers)) {
    this.mergedHeader.addProgramRecord(program);
  }
  final List<SAMReadGroupRecord> readGroups=mergeReadGroups(readers);
  this.mergedHeader.setReadGroups(readGroups);
  this.mergedHeader.setGroupOrder(SAMFileHeader.GroupOrder.none);
  this.mergedHeader.setSortOrder(sortOrder);
  for (  final SAMFileReader reader : readers) {
    for (    final String comment : reader.getFileHeader().getComments()) {
      this.mergedHeader.addComment(comment);
    }
  }
}","/** 
 * Create SAMFileHeader with additional information.
 * @param readers sam file readers to combine
 * @param sortOrder sort order new header should have
 * @param mergeDictionaries If true, merge sequence dictionaries in new header.  If false, require thatall input sequence dictionaries be identical.
 */
public SamFileHeaderMerger(final Collection<SAMFileReader> readers,final SAMFileHeader.SortOrder sortOrder,final boolean mergeDictionaries){
  this.readers=readers;
  this.mergedHeader=new SAMFileHeader();
  SAMSequenceDictionary sequenceDictionary;
  try {
    sequenceDictionary=getSequenceDictionary(readers);
    this.hasMergedSequenceDictionary=false;
  }
 catch (  SequenceUtil.SequenceListsDifferException pe) {
    if (mergeDictionaries) {
      sequenceDictionary=mergeSequenceDictionaries(readers);
      this.hasMergedSequenceDictionary=true;
    }
 else {
      throw pe;
    }
  }
  this.mergedHeader.setSequenceDictionary(sequenceDictionary);
  for (  final SAMProgramRecord program : mergeProgramGroups(readers)) {
    this.mergedHeader.addProgramRecord(program);
  }
  final List<SAMReadGroupRecord> readGroups=mergeReadGroups(readers);
  this.mergedHeader.setReadGroups(readGroups);
  this.mergedHeader.setGroupOrder(SAMFileHeader.GroupOrder.none);
  this.mergedHeader.setSortOrder(sortOrder);
  for (  final SAMFileReader reader : readers) {
    for (    final String comment : reader.getFileHeader().getComments()) {
      this.mergedHeader.addComment(comment);
    }
  }
}",0.9983394221188974
30686,"/** 
 * They've asked to merge the sequence headers.  What we support right now is finding the sequence name superset.
 * @param currentDict the current dictionary, though merged entries are the superset of both dictionaries
 * @param mergingDict the sequence dictionary to merge
 * @return the superset dictionary, by sequence names
 */
private SAMSequenceDictionary mergeSequences(SAMSequenceDictionary currentDict,SAMSequenceDictionary mergingDict){
  LinkedList<SAMSequenceRecord> resultingDict=new LinkedList<SAMSequenceRecord>();
  LinkedList<String> resultingDictStr=new LinkedList<String>();
  LinkedList<SAMSequenceRecord> holder=new LinkedList<SAMSequenceRecord>();
  resultingDict.addAll(currentDict.getSequences());
  for (  SAMSequenceRecord r : resultingDict) {
    resultingDictStr.add(r.getSequenceName());
  }
  for (  SAMSequenceRecord record : mergingDict.getSequences()) {
    if (resultingDictStr.contains(record.getSequenceName())) {
      int loc=resultingDictStr.indexOf(record.getSequenceName());
      resultingDict.addAll(loc,holder);
      holder.clear();
    }
 else {
      holder.add(record.clone());
    }
  }
  if (holder.size() != 0) {
    resultingDict.addAll(holder);
  }
  return new SAMSequenceDictionary(resultingDict);
}","/** 
 * They've asked to merge the sequence headers.  What we support right now is finding the sequence name superset.
 * @param mergeIntoDict the result of merging so far.  All SAMSequenceRecords in here have been cloned from the originals.
 * @param mergeFromDict A new sequence dictionary to merge into mergeIntoDict.
 * @return A new sequence dictionary that resulting from merging the two inputs.
 */
private SAMSequenceDictionary mergeSequences(SAMSequenceDictionary mergeIntoDict,SAMSequenceDictionary mergeFromDict){
  LinkedList<SAMSequenceRecord> holder=new LinkedList<SAMSequenceRecord>();
  LinkedList<SAMSequenceRecord> resultingDict=new LinkedList<SAMSequenceRecord>();
  for (  final SAMSequenceRecord sequenceRecord : mergeIntoDict.getSequences()) {
    resultingDict.add(sequenceRecord);
  }
  int prevloc=-1;
  SAMSequenceRecord previouslyMerged=null;
  for (  SAMSequenceRecord sequenceRecord : mergeFromDict.getSequences()) {
    int loc=getIndexOfSequenceName(resultingDict,sequenceRecord.getSequenceName());
    if (loc == -1) {
      holder.add(sequenceRecord.clone());
    }
 else     if (prevloc > loc) {
      throw new PicardException(""String_Node_Str"" + sequenceRecord.getSequenceName() + ""String_Node_Str""+ previouslyMerged.getSequenceName()+ ""String_Node_Str"");
    }
 else {
      resultingDict.addAll(loc,holder);
      prevloc=loc + holder.size();
      previouslyMerged=sequenceRecord;
      holder.clear();
    }
  }
  if (holder.size() != 0) {
    resultingDict.addAll(holder);
  }
  return new SAMSequenceDictionary(resultingDict);
}",0.5060070671378092
30687,"public BlockCompressedInputStream(final URL url){
  mFile=new SeekableHTTPStream(url);
  mStream=null;
}","public BlockCompressedInputStream(final URL url){
  mFile=new SeekableBufferedStream(new SeekableHTTPStream(url));
  mStream=null;
}",0.8813559322033898
30688,"public int read(byte[] buffer,int offset,int length) throws IOException {
  int nBytesRead=bufferedStream.read(buffer,offset,length);
  position+=nBytesRead;
  return nBytesRead;
}","public int read(byte[] buffer,int offset,int length) throws IOException {
  int nBytesRead=bufferedStream.read(buffer,offset,length);
  if (nBytesRead > 0) {
    position+=nBytesRead;
  }
  return nBytesRead;
}",0.9230769230769232
30689,"public SeekableHTTPStream(final URL url){
  this.url=url;
  final String contentLengthString=HttpUtils.getHeaderField(url,""String_Node_Str"");
  if (contentLengthString != null) {
    try {
      contentLength=Long.parseLong(contentLengthString);
    }
 catch (    NumberFormatException ignored) {
    }
  }
}","public SeekableHTTPStream(final URL url){
  this.url=url;
  final String contentLengthString=HttpUtils.getHeaderField(url,""String_Node_Str"");
  if (contentLengthString != null) {
    try {
      contentLength=Long.parseLong(contentLengthString);
    }
 catch (    NumberFormatException ignored) {
      System.out.println(""String_Node_Str"" + contentLengthString + ""String_Node_Str""+ url);
      contentLength=-1;
    }
  }
}",0.8415300546448088
30690,"public static FileTermination checkTermination(final File file) throws IOException {
  final long fileSize=file.length();
  if (fileSize < BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length) {
    return FileTermination.DEFECTIVE;
  }
  final RandomAccessFile raFile=new RandomAccessFile(file,""String_Node_Str"");
  raFile.seek(fileSize - BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length);
  byte[] buf=new byte[BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length];
  raFile.readFully(buf);
  if (Arrays.equals(buf,BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK)) {
    return FileTermination.HAS_TERMINATOR_BLOCK;
  }
  final int bufsize=(int)Math.min(fileSize,BlockCompressedStreamConstants.MAX_COMPRESSED_BLOCK_SIZE);
  buf=new byte[bufsize];
  raFile.seek(fileSize - bufsize);
  raFile.read(buf);
  for (int i=buf.length - BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length; i >= 0; --i) {
    if (!preambleEqual(BlockCompressedStreamConstants.GZIP_BLOCK_PREAMBLE,buf,i,BlockCompressedStreamConstants.GZIP_BLOCK_PREAMBLE.length)) {
      continue;
    }
    final ByteBuffer byteBuffer=ByteBuffer.wrap(buf,i + BlockCompressedStreamConstants.GZIP_BLOCK_PREAMBLE.length,4);
    byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
    final int totalBlockSizeMinusOne=byteBuffer.getShort() & 0xFFFF;
    if (buf.length - i == totalBlockSizeMinusOne + 1) {
      return FileTermination.HAS_HEALTHY_LAST_BLOCK;
    }
 else {
      return FileTermination.DEFECTIVE;
    }
  }
  return FileTermination.DEFECTIVE;
}","public static FileTermination checkTermination(final File file) throws IOException {
  final long fileSize=file.length();
  if (fileSize < BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length) {
    return FileTermination.DEFECTIVE;
  }
  final RandomAccessFile raFile=new RandomAccessFile(file,""String_Node_Str"");
  try {
    raFile.seek(fileSize - BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length);
    byte[] buf=new byte[BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length];
    raFile.readFully(buf);
    if (Arrays.equals(buf,BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK)) {
      return FileTermination.HAS_TERMINATOR_BLOCK;
    }
    final int bufsize=(int)Math.min(fileSize,BlockCompressedStreamConstants.MAX_COMPRESSED_BLOCK_SIZE);
    buf=new byte[bufsize];
    raFile.seek(fileSize - bufsize);
    raFile.read(buf);
    for (int i=buf.length - BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length; i >= 0; --i) {
      if (!preambleEqual(BlockCompressedStreamConstants.GZIP_BLOCK_PREAMBLE,buf,i,BlockCompressedStreamConstants.GZIP_BLOCK_PREAMBLE.length)) {
        continue;
      }
      final ByteBuffer byteBuffer=ByteBuffer.wrap(buf,i + BlockCompressedStreamConstants.GZIP_BLOCK_PREAMBLE.length,4);
      byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
      final int totalBlockSizeMinusOne=byteBuffer.getShort() & 0xFFFF;
      if (buf.length - i == totalBlockSizeMinusOne + 1) {
        return FileTermination.HAS_HEALTHY_LAST_BLOCK;
      }
 else {
        return FileTermination.DEFECTIVE;
      }
    }
    return FileTermination.DEFECTIVE;
  }
  finally {
    raFile.close();
  }
}",0.9629865985960434
30691,"/** 
 * Read from input until input is exhausted, EOLN is seen, or output buffer is filled
 * @param outputBuffer where to put bytes read
 * @param startOutputIndex where to start putting bytes read
 * @return number of bytes read
 */
public int readToEndOfOutputBufferOrEoln(final byte[] outputBuffer,final int startOutputIndex){
  boolean sawNewline;
  int totalGrabbed=0;
  do {
    if (!ensureBufferNotEmpty()) {
      break;
    }
    final int startInputIndex=nextByte;
    sawNewline=advanceToEobOrEoln();
    int lengthOfChunk=nextByte - startInputIndex;
    if (lengthOfChunk > outputBuffer.length - startOutputIndex) {
      lengthOfChunk=outputBuffer.length - startOutputIndex;
      nextByte=startInputIndex + lengthOfChunk;
    }
    System.arraycopy(fileBuffer,startInputIndex,outputBuffer,startOutputIndex + totalGrabbed,lengthOfChunk);
    totalGrabbed+=lengthOfChunk;
  }
 while (!sawNewline && totalGrabbed < outputBuffer.length - startOutputIndex);
  ensureBufferNotEmpty();
  return totalGrabbed;
}","/** 
 * Read from input until input is exhausted, EOLN is seen, or output buffer is filled
 * @param outputBuffer where to put bytes read
 * @param startOutputIndex where to start putting bytes read
 * @return number of bytes read
 */
public int readToEndOfOutputBufferOrEoln(final byte[] outputBuffer,final int startOutputIndex){
  boolean sawNewline;
  int totalGrabbed=0;
  do {
    if (!ensureBufferNotEmpty()) {
      break;
    }
    final int startInputIndex=nextByte;
    sawNewline=advanceToEobOrEoln();
    int lengthOfChunk=nextByte - startInputIndex;
    if (lengthOfChunk > outputBuffer.length - (startOutputIndex + totalGrabbed)) {
      lengthOfChunk=outputBuffer.length - (startOutputIndex + totalGrabbed);
      nextByte=startInputIndex + lengthOfChunk;
    }
    System.arraycopy(fileBuffer,startInputIndex,outputBuffer,startOutputIndex + totalGrabbed,lengthOfChunk);
    totalGrabbed+=lengthOfChunk;
  }
 while (!sawNewline && totalGrabbed < outputBuffer.length - startOutputIndex);
  ensureBufferNotEmpty();
  return totalGrabbed;
}",0.952657004830918
30692,"/** 
 * Main work method.  Reads the BAM file once and collects sorted information about the 5' ends of both ends of each read (or just one end in the case of pairs). Then makes a pass through those determining duplicates before re-reading the input file and writing it out with duplication flags set correctly.
 */
protected int doWork(){
  reportMemoryStats(""String_Node_Str"");
  log.info(""String_Node_Str"");
  buildSortedReadEndLists();
  reportMemoryStats(""String_Node_Str"");
  generateDuplicateIndexes();
  reportMemoryStats(""String_Node_Str"");
  log.info(""String_Node_Str"" + this.numDuplicateIndices + ""String_Node_Str"");
  Map<String,DuplicationMetrics> metricsByLibrary=new HashMap<String,DuplicationMetrics>();
  final SAMFileReader in=new SAMFileReader(INPUT);
  final SAMFileHeader header=in.getFileHeader();
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(),true,OUTPUT);
  long pairedReadsExamined=0;
  long pairedReadDuplicates=0;
  long recordInFileIndex=0;
  long nextDuplicateIndex=(this.duplicateIndexes.hasNext() ? this.duplicateIndexes.next() : -1);
  for (  final SAMRecord rec : in) {
    String library=getLibraryName(header,rec);
    DuplicationMetrics metrics=metricsByLibrary.get(library);
    if (metrics == null) {
      metrics=new DuplicationMetrics();
      metrics.LIBRARY=library;
      metricsByLibrary.put(library,metrics);
    }
    if (rec.getReadUnmappedFlag()) {
      ++metrics.UNMAPPED_READS;
    }
 else     if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) {
      ++metrics.UNPAIRED_READS_EXAMINED;
    }
 else {
      ++pairedReadsExamined;
    }
    if (recordInFileIndex++ == nextDuplicateIndex) {
      rec.setDuplicateReadFlag(true);
      if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) {
        ++metrics.UNPAIRED_READ_DUPLICATES;
      }
 else {
        ++pairedReadDuplicates;
      }
      if (this.duplicateIndexes.hasNext()) {
        nextDuplicateIndex=this.duplicateIndexes.next();
      }
 else {
        nextDuplicateIndex=-1;
      }
    }
 else {
      rec.setDuplicateReadFlag(false);
    }
    if (this.REMOVE_DUPLICATES && rec.getDuplicateReadFlag()) {
    }
 else {
      out.addAlignment(rec);
    }
  }
  reportMemoryStats(""String_Node_Str"");
  out.close();
  reportMemoryStats(""String_Node_Str"");
  final MetricsFile<DuplicationMetrics,Double> file=getMetricsFile();
  for (  DuplicationMetrics metrics : metricsByLibrary.values()) {
    metrics.READ_PAIRS_EXAMINED=pairedReadsExamined / 2;
    metrics.READ_PAIR_DUPLICATES=pairedReadDuplicates / 2;
    metrics.calculateDerivedMetrics();
    file.addMetric(metrics);
  }
  if (metricsByLibrary.size() == 1) {
    file.setHistogram(metricsByLibrary.values().iterator().next().calculateRoiHistogram());
  }
  file.write(METRICS_FILE);
  return 0;
}","/** 
 * Main work method.  Reads the BAM file once and collects sorted information about the 5' ends of both ends of each read (or just one end in the case of pairs). Then makes a pass through those determining duplicates before re-reading the input file and writing it out with duplication flags set correctly.
 */
protected int doWork(){
  reportMemoryStats(""String_Node_Str"");
  log.info(""String_Node_Str"");
  buildSortedReadEndLists();
  reportMemoryStats(""String_Node_Str"");
  generateDuplicateIndexes();
  reportMemoryStats(""String_Node_Str"");
  log.info(""String_Node_Str"" + this.numDuplicateIndices + ""String_Node_Str"");
  Map<String,DuplicationMetrics> metricsByLibrary=new HashMap<String,DuplicationMetrics>();
  final SAMFileReader in=new SAMFileReader(INPUT);
  final SAMFileHeader header=in.getFileHeader();
  final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(),true,OUTPUT);
  long recordInFileIndex=0;
  long nextDuplicateIndex=(this.duplicateIndexes.hasNext() ? this.duplicateIndexes.next() : -1);
  for (  final SAMRecord rec : in) {
    String library=getLibraryName(header,rec);
    DuplicationMetrics metrics=metricsByLibrary.get(library);
    if (metrics == null) {
      metrics=new DuplicationMetrics();
      metrics.LIBRARY=library;
      metricsByLibrary.put(library,metrics);
    }
    if (rec.getReadUnmappedFlag()) {
      ++metrics.UNMAPPED_READS;
    }
 else     if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) {
      ++metrics.UNPAIRED_READS_EXAMINED;
    }
 else {
      ++metrics.READ_PAIRS_EXAMINED;
    }
    if (recordInFileIndex++ == nextDuplicateIndex) {
      rec.setDuplicateReadFlag(true);
      if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) {
        ++metrics.UNPAIRED_READ_DUPLICATES;
      }
 else {
        ++metrics.READ_PAIR_DUPLICATES;
      }
      if (this.duplicateIndexes.hasNext()) {
        nextDuplicateIndex=this.duplicateIndexes.next();
      }
 else {
        nextDuplicateIndex=-1;
      }
    }
 else {
      rec.setDuplicateReadFlag(false);
    }
    if (this.REMOVE_DUPLICATES && rec.getDuplicateReadFlag()) {
    }
 else {
      out.addAlignment(rec);
    }
  }
  reportMemoryStats(""String_Node_Str"");
  out.close();
  reportMemoryStats(""String_Node_Str"");
  final MetricsFile<DuplicationMetrics,Double> file=getMetricsFile();
  for (  DuplicationMetrics metrics : metricsByLibrary.values()) {
    metrics.READ_PAIRS_EXAMINED=metrics.READ_PAIRS_EXAMINED / 2;
    metrics.READ_PAIR_DUPLICATES=metrics.READ_PAIR_DUPLICATES / 2;
    metrics.calculateDerivedMetrics();
    file.addMetric(metrics);
  }
  if (metricsByLibrary.size() == 1) {
    file.setHistogram(metricsByLibrary.values().iterator().next().calculateRoiHistogram());
  }
  file.write(METRICS_FILE);
  return 0;
}",0.9557490669984006
30693,"public void encode(final ReadEnds read){
  try {
    this.out.writeShort(read.score);
    this.out.writeByte(read.orientation);
    this.out.writeInt(read.read1Sequence);
    this.out.writeInt(read.read1Coordinate);
    this.out.writeLong(read.read1IndexInFile);
    this.out.writeInt(read.read2Sequence);
    if (read.orientation > ReadEnds.R) {
      this.out.writeInt(read.read2Coordinate);
      this.out.writeLong(read.read2IndexInFile);
    }
    this.out.flush();
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}","public void encode(final ReadEnds read){
  try {
    this.out.writeShort(read.score);
    this.out.writeShort(read.libraryId);
    this.out.writeByte(read.orientation);
    this.out.writeInt(read.read1Sequence);
    this.out.writeInt(read.read1Coordinate);
    this.out.writeLong(read.read1IndexInFile);
    this.out.writeInt(read.read2Sequence);
    if (read.orientation > ReadEnds.R) {
      this.out.writeInt(read.read2Coordinate);
      this.out.writeLong(read.read2IndexInFile);
    }
    this.out.flush();
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}",0.9648671808054842
30694,"public ReadEnds decode(){
  final ReadEnds read=new ReadEnds();
  try {
    try {
      read.score=this.in.readShort();
    }
 catch (    EOFException eof) {
      return null;
    }
    read.orientation=this.in.readByte();
    read.read1Sequence=this.in.readInt();
    read.read1Coordinate=this.in.readInt();
    read.read1IndexInFile=this.in.readLong();
    read.read2Sequence=this.in.readInt();
    if (read.orientation > ReadEnds.R) {
      read.read2Coordinate=this.in.readInt();
      read.read2IndexInFile=this.in.readLong();
    }
    return read;
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}","public ReadEnds decode(){
  final ReadEnds read=new ReadEnds();
  try {
    try {
      read.score=this.in.readShort();
    }
 catch (    EOFException eof) {
      return null;
    }
    read.libraryId=this.in.readShort();
    read.orientation=this.in.readByte();
    read.read1Sequence=this.in.readInt();
    read.read1Coordinate=this.in.readInt();
    read.read1IndexInFile=this.in.readLong();
    read.read2Sequence=this.in.readInt();
    if (read.orientation > ReadEnds.R) {
      read.read2Coordinate=this.in.readInt();
      read.read2IndexInFile=this.in.readLong();
    }
    return read;
  }
 catch (  IOException ioe) {
    throw new PicardException(""String_Node_Str"",ioe);
  }
}",0.9700598802395208
30695,"/** 
 * Read value of specified type.
 * @param tagType What type to read.
 * @param byteBuffer Little-ending byte buffer to read value from.
 * @return Value in in-memory Object form.
 */
private static Object readValue(final byte tagType,final ByteBuffer byteBuffer){
switch (tagType) {
case 'Z':
    return readNullTerminatedString(byteBuffer);
case 'A':
  return (char)byteBuffer.get();
case 'I':
return byteBuffer.getInt() & 0xffffffffL;
case 'i':
return byteBuffer.getInt();
case 's':
return byteBuffer.getShort();
case 'S':
return byteBuffer.getShort() & 0xffff;
case 'c':
return byteBuffer.get();
case 'C':
return (short)((int)byteBuffer.get() & 0xff);
case 'f':
return byteBuffer.getFloat();
case 'H':
final String hexRep=readNullTerminatedString(byteBuffer);
return SAMUtils.hexStringToBytes(hexRep);
default :
throw new SAMFormatException(""String_Node_Str"" + (char)tagType);
}
}","/** 
 * Read value of specified type.
 * @param tagType What type to read.
 * @param byteBuffer Little-ending byte buffer to read value from.
 * @return Value in in-memory Object form.
 */
private static Object readValue(final byte tagType,final ByteBuffer byteBuffer){
switch (tagType) {
case 'Z':
    return readNullTerminatedString(byteBuffer);
case 'A':
  return (char)byteBuffer.get();
case 'I':
return byteBuffer.getInt() & 0xffffffffL;
case 'i':
return byteBuffer.getInt();
case 's':
return byteBuffer.getShort();
case 'S':
return byteBuffer.getShort() & 0xffff;
case 'c':
return byteBuffer.get();
case 'C':
return (short)((int)byteBuffer.get() & 0xff);
case 'f':
return byteBuffer.getFloat();
case 'H':
final String hexRep=readNullTerminatedString(byteBuffer);
return StringUtil.hexStringToBytes(hexRep);
default :
throw new SAMFormatException(""String_Node_Str"" + (char)tagType);
}
}",0.995505617977528
30696,"/** 
 * Write the given tag name and value to disk.
 */
void writeTag(final short tag,final Object value){
  binaryCodec.writeShort(tag);
  final char tagValueType=getTagValueType(value);
  binaryCodec.writeByte(tagValueType);
switch (tagValueType) {
case 'Z':
    binaryCodec.writeString((String)value,false,true);
  break;
case 'A':
binaryCodec.writeByte(((Character)value));
break;
case 'I':
binaryCodec.writeUInt((Long)value);
break;
case 'i':
binaryCodec.writeInt((Integer)value);
break;
case 's':
binaryCodec.writeShort(((Number)value).shortValue());
break;
case 'c':
binaryCodec.writeByte(((Number)value).byteValue());
break;
case 'f':
binaryCodec.writeFloat((Float)value);
break;
case 'H':
final byte[] byteArray=(byte[])value;
binaryCodec.writeString(SAMUtils.bytesToHexString(byteArray),false,true);
break;
case 'S':
binaryCodec.writeUShort((Integer)value);
break;
case 'C':
binaryCodec.writeUByte(((Integer)value).shortValue());
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + value.getClass().getName());
}
}","/** 
 * Write the given tag name and value to disk.
 */
void writeTag(final short tag,final Object value){
  binaryCodec.writeShort(tag);
  final char tagValueType=getTagValueType(value);
  binaryCodec.writeByte(tagValueType);
switch (tagValueType) {
case 'Z':
    binaryCodec.writeString((String)value,false,true);
  break;
case 'A':
binaryCodec.writeByte(((Character)value));
break;
case 'I':
binaryCodec.writeUInt((Long)value);
break;
case 'i':
binaryCodec.writeInt((Integer)value);
break;
case 's':
binaryCodec.writeShort(((Number)value).shortValue());
break;
case 'c':
binaryCodec.writeByte(((Number)value).byteValue());
break;
case 'f':
binaryCodec.writeFloat((Float)value);
break;
case 'H':
final byte[] byteArray=(byte[])value;
binaryCodec.writeString(StringUtil.bytesToHexString(byteArray),false,true);
break;
case 'S':
binaryCodec.writeUShort((Integer)value);
break;
case 'C':
binaryCodec.writeUByte(((Integer)value).shortValue());
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + value.getClass().getName());
}
}",0.9961722488038276
30697,"private String formatTagValue(final short tag,final Object value){
  final String tagString=SAMTagUtil.getSingleton().makeStringTag(tag);
  if (value == null || value instanceof String) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof Integer) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof Character) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof Float) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof byte[]) {
    return tagString + ""String_Node_Str"" + SAMUtils.bytesToHexString((byte[])value);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + tagString + ""String_Node_Str""+ value);
  }
}","private String formatTagValue(final short tag,final Object value){
  final String tagString=SAMTagUtil.getSingleton().makeStringTag(tag);
  if (value == null || value instanceof String) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof Integer) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof Character) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof Float) {
    return tagString + ""String_Node_Str"" + value;
  }
 else   if (value instanceof byte[]) {
    return tagString + ""String_Node_Str"" + StringUtil.bytesToHexString((byte[])value);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + tagString + ""String_Node_Str""+ value);
  }
}",0.9947089947089948
30698,"/** 
 * Retrieve the 2nd-best base call from SQ value.
 * @param sqValue
 * @return Ordinal of 2nd-best base call.
 */
public static int sqValueToBaseOrdinal(final byte sqValue){
  return sqValue >>> BASE_INDEX_SHIFT;
}","/** 
 * Retrieve the 2nd-best base call from SQ value.
 * @param sqValue
 * @return Ordinal of 2nd-best base call.
 */
public static int sqValueToBaseOrdinal(final byte sqValue){
  return (sqValue & 0xff) >>> BASE_INDEX_SHIFT;
}",0.9485458612975392
30699,"/** 
 * Convert in-memory representation of tag to SAM text representation.
 * @param tagName Two-character tag name.
 * @param value Tag value as approriate Object subclass.
 * @return SAM text String representation, i.e. name:type:value
 */
String encode(final String tagName,Object value){
  final StringBuilder sb=new StringBuilder(tagName);
  sb.append(':');
  char tagType=BinaryTagCodec.getTagValueType(value);
switch (tagType) {
case 'c':
case 'C':
case 's':
case 'S':
case 'I':
    tagType='i';
}
if (tagType == 'H') {
  value=SAMUtils.bytesToHexString((byte[])value);
}
 else if (tagType == 'i') {
  final long longVal=((Number)value).longValue();
  if (longVal > Integer.MAX_VALUE || longVal < Integer.MIN_VALUE) {
    throw new SAMFormatException(""String_Node_Str"" + tagName + ""String_Node_Str""+ longVal);
  }
}
sb.append(tagType);
sb.append(':');
sb.append(value.toString());
return sb.toString();
}","/** 
 * Convert in-memory representation of tag to SAM text representation.
 * @param tagName Two-character tag name.
 * @param value Tag value as approriate Object subclass.
 * @return SAM text String representation, i.e. name:type:value
 */
String encode(final String tagName,Object value){
  final StringBuilder sb=new StringBuilder(tagName);
  sb.append(':');
  char tagType=BinaryTagCodec.getTagValueType(value);
switch (tagType) {
case 'c':
case 'C':
case 's':
case 'S':
case 'I':
    tagType='i';
}
if (tagType == 'H') {
  value=StringUtil.bytesToHexString((byte[])value);
}
 else if (tagType == 'i') {
  final long longVal=((Number)value).longValue();
  if (longVal > Integer.MAX_VALUE || longVal < Integer.MIN_VALUE) {
    throw new SAMFormatException(""String_Node_Str"" + tagName + ""String_Node_Str""+ longVal);
  }
}
sb.append(tagType);
sb.append(':');
sb.append(value.toString());
return sb.toString();
}",0.9956188389923328
30700,"private Object convertStringToObject(final String type,final String stringVal){
  final Object val;
  if (type.equals(""String_Node_Str"")) {
    val=stringVal;
  }
 else   if (type.equals(""String_Node_Str"")) {
    if (stringVal.length() != 1) {
      throw new SAMFormatException(""String_Node_Str"");
    }
    val=stringVal.charAt(0);
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      val=new Integer(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      val=new Float(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      val=SAMUtils.hexStringToBytes(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else {
    throw new SAMFormatException(""String_Node_Str"" + type);
  }
  return val;
}","private Object convertStringToObject(final String type,final String stringVal){
  final Object val;
  if (type.equals(""String_Node_Str"")) {
    val=stringVal;
  }
 else   if (type.equals(""String_Node_Str"")) {
    if (stringVal.length() != 1) {
      throw new SAMFormatException(""String_Node_Str"");
    }
    val=stringVal.charAt(0);
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      val=new Integer(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      val=new Float(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else   if (type.equals(""String_Node_Str"")) {
    try {
      val=StringUtil.hexStringToBytes(stringVal);
    }
 catch (    NumberFormatException e) {
      throw new SAMFormatException(""String_Node_Str"");
    }
  }
 else {
    throw new SAMFormatException(""String_Node_Str"" + type);
  }
  return val;
}",0.9961464354527938
30701,"/** 
 * Constructs a FastaSequenceFile that reads from the specified file. 
 */
FastaSequenceFile(final File file,final boolean truncateNamesAtWhitespace){
  this.file=file;
  this.truncateNamesAtWhitespace=truncateNamesAtWhitespace;
  this.in=new FastLineReader(IoUtil.openFileForReading(file));
  String dictionaryName=file.getAbsolutePath();
  boolean fileTypeSupported=false;
  for (  String extension : ReferenceSequenceFileFactory.FASTA_EXTENSIONS) {
    if (dictionaryName.endsWith(extension)) {
      dictionaryName=dictionaryName.substring(0,dictionaryName.lastIndexOf(extension));
      dictionaryName+=""String_Node_Str"";
      fileTypeSupported=true;
      break;
    }
  }
  if (!fileTypeSupported)   throw new IllegalArgumentException(""String_Node_Str"" + file.getAbsolutePath());
  dictionaryName+=""String_Node_Str"";
  final File dictionary=new File(dictionaryName);
  if (dictionary.exists()) {
    IoUtil.assertFileIsReadable(dictionary);
    try {
      final SAMTextHeaderCodec codec=new SAMTextHeaderCodec();
      final SAMFileHeader header=codec.decode(new AsciiLineReader(new FileInputStream(dictionary)),dictionary);
      if (header.getSequenceDictionary() != null && header.getSequenceDictionary().size() > 0) {
        this.sequenceDictionary=header.getSequenceDictionary();
      }
    }
 catch (    Exception e) {
      throw new PicardException(""String_Node_Str"" + dictionaryName,e);
    }
  }
}","/** 
 * Constructs a FastaSequenceFile that reads from the specified file. 
 */
FastaSequenceFile(final File file,final boolean truncateNamesAtWhitespace){
  this.file=file;
  this.truncateNamesAtWhitespace=truncateNamesAtWhitespace;
  this.in=new FastLineReader(IoUtil.openFileForReading(file));
  String dictionaryName=file.getAbsolutePath();
  boolean fileTypeSupported=false;
  for (  String extension : ReferenceSequenceFileFactory.FASTA_EXTENSIONS) {
    if (dictionaryName.endsWith(extension)) {
      dictionaryName=dictionaryName.substring(0,dictionaryName.lastIndexOf(extension));
      dictionaryName+=""String_Node_Str"";
      fileTypeSupported=true;
      break;
    }
  }
  if (!fileTypeSupported)   throw new IllegalArgumentException(""String_Node_Str"" + file.getAbsolutePath());
  final File dictionary=new File(dictionaryName);
  if (dictionary.exists()) {
    IoUtil.assertFileIsReadable(dictionary);
    try {
      final SAMTextHeaderCodec codec=new SAMTextHeaderCodec();
      final SAMFileHeader header=codec.decode(new AsciiLineReader(new FileInputStream(dictionary)),dictionary);
      if (header.getSequenceDictionary() != null && header.getSequenceDictionary().size() > 0) {
        this.sequenceDictionary=header.getSequenceDictionary();
      }
    }
 catch (    Exception e) {
      throw new PicardException(""String_Node_Str"" + dictionaryName,e);
    }
  }
}",0.9868280526877892
30702,"/** 
 * For setting the Cigar string when BAMRecord has decoded it.  Use this rather than setCigar() so that indexing bin doesn't get clobbered.
 */
protected void initializeCigar(final Cigar cigar){
  this.mCigar=cigar;
  mCigarString=null;
  mAlignmentBlocks=null;
}","/** 
 * For setting the Cigar string when BAMRecord has decoded it.  Use this rather than setCigar() so that indexing bin doesn't get clobbered.
 */
protected void initializeCigar(final Cigar cigar){
  this.mCigar=cigar;
  mCigarString=null;
  mAlignmentBlocks=null;
  mAlignmentEnd=NO_ALIGNMENT_START;
}",0.9370629370629372
30703,"/** 
 * @return 1-based inclusive rightmost position of the clippped sequence, or -1 read if unmapped.
 */
public int getAlignmentEnd(){
  if (getReadUnmappedFlag()) {
    return NO_ALIGNMENT_START;
  }
 else   if (this.mAlignmentEnd == NO_ALIGNMENT_START) {
    this.mAlignmentEnd=getCigar().getReferenceLength() - 1;
  }
  return this.mAlignmentEnd;
}","/** 
 * @return 1-based inclusive rightmost position of the clippped sequence, or -1 read if unmapped.
 */
public int getAlignmentEnd(){
  if (getReadUnmappedFlag()) {
    return NO_ALIGNMENT_START;
  }
 else   if (this.mAlignmentEnd == NO_ALIGNMENT_START) {
    this.mAlignmentEnd=mAlignmentStart + getCigar().getReferenceLength() - 1;
  }
  return this.mAlignmentEnd;
}",0.9751381215469612
30704,"/** 
 * @param value 1-based inclusive leftmost position of the clippped sequence, or 0 if there is no position.
 */
public void setAlignmentStart(final int value){
  mAlignmentStart=value;
  setIndexingBin(null);
}","/** 
 * @param value 1-based inclusive leftmost position of the clippped sequence, or 0 if there is no position.
 */
public void setAlignmentStart(final int value){
  mAlignmentStart=value;
  mAlignmentEnd=NO_ALIGNMENT_START;
  setIndexingBin(null);
}",0.9227467811158798
30705,"public void setCigarString(final String value){
  mCigarString=value;
  mCigar=null;
  mAlignmentBlocks=null;
  setIndexingBin(null);
}","public void setCigarString(final String value){
  mCigarString=value;
  mCigar=null;
  mAlignmentBlocks=null;
  mAlignmentEnd=NO_ALIGNMENT_START;
  setIndexingBin(null);
}",0.8823529411764706
30706,"public ArrayList<Token> process(String doc) throws Exception {
  if (service == null || count % 10 == 0) {
    initialize();
  }
  count++;
  ArrayList<Token> allWords=new ArrayList<Token>();
  Annotation document=new Annotation(doc);
  System.err.println(""String_Node_Str"");
  pipeline.annotate(document);
  int s=0;
  int t=0;
  int p=0;
  boolean quotation=false;
  List<CoreMap> sentences=document.get(SentencesAnnotation.class);
  int totalSentences=sentences.size() - 1;
  for (  CoreMap sentence : sentences) {
    if (s % 100 == 0 || s == totalSentences) {
      double ratio=((double)s) / totalSentences;
      System.err.print(String.format(""String_Node_Str"",ratio,s,totalSentences));
    }
    int id=1;
    String[] parseTokens=new String[sentence.get(TokensAnnotation.class).size()];
    ArrayList<Token> annos=new ArrayList<Token>();
    for (    CoreLabel token : sentence.get(TokensAnnotation.class)) {
      String word=token.get(TextAnnotation.class);
      String pos=token.get(PartOfSpeechAnnotation.class);
      String lemma=token.get(LemmaAnnotation.class);
      String ne=token.get(NamedEntityTagAnnotation.class);
      int beginOffset=token.beginPosition();
      int endOffset=token.endPosition();
      String whitespaceAfter=token.after();
      String original=token.originalText();
      if (word.equals(""String_Node_Str"")) {
        quotation=true;
      }
      Token anno=new Token();
      anno.original=original;
      anno.word=word;
      anno.pos=pos;
      anno.lemma=lemma;
      anno.ner=ne;
      anno.sentenceID=s;
      anno.tokenId=t;
      anno.beginOffset=beginOffset;
      anno.endOffset=endOffset;
      anno.quotation=quotation;
      anno.setWhitespaceAfter(whitespaceAfter);
      anno.p=p;
      annos.add(anno);
      String parseToken=String.format(""String_Node_Str"",id,word,lemma,pos,pos,""String_Node_Str"");
      parseTokens[id - 1]=parseToken;
      id++;
      allWords.add(anno);
      t++;
      whitespaceAfter=anno.whitespaceAfter;
      if (word.equals(""String_Node_Str"")) {
        quotation=false;
      }
      if (token.after().matches(""String_Node_Str"")) {
        p++;
      }
    }
    s++;
    DependencyStructure graph=service.parse(parseTokens);
    SymbolTable symboltable=graph.getSymbolTables().getSymbolTable(""String_Node_Str"");
    SortedSet<Integer> depInts=graph.getDependencyIndices();
    for (    int dint : depInts) {
      if (dint > 0) {
        Token anno=annos.get(dint - 1);
        DependencyNode node=graph.getDependencyNode(dint);
        DependencyNode head=node.getHead();
        int headIndex=0;
        String label=""String_Node_Str"";
        if (head != null) {
          Edge edge=node.getHeadEdge();
          headIndex=head.getIndex();
          label=edge.getLabelSymbol(symboltable);
        }
        int globalHead=-1;
        if (headIndex > 0) {
          int offset=headIndex - dint;
          globalHead=offset + anno.tokenId;
        }
        anno.head=globalHead;
        anno.deprel=label;
        annos.set(dint - 1,anno);
      }
    }
  }
  p++;
  System.err.println();
  service.terminateParserModel();
  return allWords;
}","public ArrayList<Token> process(String doc) throws Exception {
  if (service == null || count % 10 == 0) {
    initialize();
  }
  count++;
  ArrayList<Token> allWords=new ArrayList<Token>();
  Annotation document=new Annotation(doc);
  System.err.println(""String_Node_Str"");
  pipeline.annotate(document);
  int s=0;
  int t=0;
  int p=0;
  boolean quotation=false;
  List<CoreMap> sentences=document.get(SentencesAnnotation.class);
  int totalSentences=sentences.size() - 1;
  ArrayList<ArrayList<Token>> sentenceannos=new ArrayList<ArrayList<Token>>();
  for (int cm_indx=0; cm_indx < sentences.size(); cm_indx++) {
    CoreMap sentence=sentences.get(cm_indx);
    if (s % 100 == 0 || s == totalSentences) {
      double ratio=((double)s) / totalSentences;
      System.err.print(String.format(""String_Node_Str"",ratio,s,totalSentences));
    }
    ArrayList<Token> annos=new ArrayList<Token>();
    for (    CoreLabel token : sentence.get(TokensAnnotation.class)) {
      String word=token.get(TextAnnotation.class);
      String pos=token.get(PartOfSpeechAnnotation.class);
      String lemma=token.get(LemmaAnnotation.class);
      String ne=token.get(NamedEntityTagAnnotation.class);
      int beginOffset=token.beginPosition();
      int endOffset=token.endPosition();
      String whitespaceAfter=token.after();
      String original=token.originalText();
      if (word.equals(""String_Node_Str"")) {
        quotation=true;
      }
      Token anno=new Token();
      anno.original=original;
      anno.word=word;
      anno.pos=pos;
      anno.lemma=lemma;
      anno.ner=ne;
      anno.sentenceID=s;
      anno.tokenId=t;
      anno.beginOffset=beginOffset;
      anno.endOffset=endOffset;
      anno.quotation=quotation;
      anno.setWhitespaceAfter(whitespaceAfter);
      anno.p=p;
      annos.add(anno);
      allWords.add(anno);
      t++;
      whitespaceAfter=anno.whitespaceAfter;
      if (word.equals(""String_Node_Str"")) {
        quotation=false;
      }
      if (token.after().matches(""String_Node_Str"")) {
        p++;
      }
    }
    sentenceannos.add(annos);
  }
  ArrayList<ArrayList<Token>> new_sentences=new ArrayList<ArrayList<Token>>();
  boolean lastFlag=false;
  for (int s_idx=0; s_idx < sentenceannos.size(); s_idx++) {
    boolean lowercaseFlag=false;
    ArrayList<Token> annos=sentenceannos.get(s_idx);
    if (annos.size() > 0 && annos.get(0).word.toLowerCase().equals(annos.get(0).word) && annos.get(0).word.matches(""String_Node_Str"")) {
      lowercaseFlag=true;
    }
    if (lastFlag == true && lowercaseFlag == true) {
      ArrayList<Token> this_annos=new_sentences.get(new_sentences.size() - 1);
      for (int t_idx=0; t_idx < annos.size(); t_idx++) {
        Token anno=annos.get(t_idx);
        this_annos.add(anno);
      }
      new_sentences.set(new_sentences.size() - 1,this_annos);
    }
 else {
      ArrayList<Token> newannos=new ArrayList<Token>();
      for (int t_idx=0; t_idx < annos.size(); t_idx++) {
        Token anno=annos.get(t_idx);
        newannos.add(anno);
      }
      new_sentences.add(newannos);
    }
    lastFlag=false;
    if (annos.size() > 1) {
      Token ultimate=annos.get(annos.size() - 1);
      Token penultimate=annos.get(annos.size() - 2);
      if (ultimate.word.equals(""String_Node_Str"") && (penultimate.word.equals(""String_Node_Str"") || penultimate.word.equals(""String_Node_Str""))) {
        lastFlag=true;
      }
    }
  }
  for (int s_idx=0; s_idx < new_sentences.size(); s_idx++) {
    ArrayList<Token> annos=new_sentences.get(s_idx);
    int id=1;
    String[] parseTokens=new String[annos.size()];
    for (    Token anno : annos) {
      String parseToken=String.format(""String_Node_Str"",id,anno.word,anno.lemma,anno.pos,anno.pos,""String_Node_Str"");
      parseTokens[id - 1]=parseToken;
      id++;
      anno.sentenceID=s;
    }
    s++;
    DependencyStructure graph=service.parse(parseTokens);
    SymbolTable symboltable=graph.getSymbolTables().getSymbolTable(""String_Node_Str"");
    SortedSet<Integer> depInts=graph.getDependencyIndices();
    for (    int dint : depInts) {
      if (dint > 0) {
        Token anno=annos.get(dint - 1);
        DependencyNode node=graph.getDependencyNode(dint);
        DependencyNode head=node.getHead();
        int headIndex=0;
        String label=""String_Node_Str"";
        if (head != null) {
          Edge edge=node.getHeadEdge();
          headIndex=head.getIndex();
          label=edge.getLabelSymbol(symboltable);
        }
        int globalHead=-1;
        if (headIndex > 0) {
          int offset=headIndex - dint;
          globalHead=offset + anno.tokenId;
        }
        anno.head=globalHead;
        anno.deprel=label;
        annos.set(dint - 1,anno);
      }
    }
  }
  p++;
  System.err.println();
  service.terminateParserModel();
  return allWords;
}",0.7232546459065796
30707,"public void findQuotations(Book book){
  setQuotes(book);
  for (  Token token : book.tokens) {
    if (token.pos.startsWith(""String_Node_Str"") && (token.lemma.equals(""String_Node_Str""))) {
      PronounAntecedent pronoun=new PronounAntecedent(token.tokenId,0);
      book.animateEntities.put(token.tokenId,pronoun);
    }
  }
  TreeMap<Integer,Quotation> quotations;
  int start=0;
  int end=0;
  quotations=Maps.newTreeMap();
  for (  Token token : book.tokens) {
    if (token.lemma.equals(""String_Node_Str"")) {
      start=token.tokenId;
    }
 else     if (token.lemma.equals(""String_Node_Str"")) {
      end=token.tokenId;
      if (start > -1) {
        Quotation quote=new Quotation(start,end,token.sentenceID);
        quotations.put(start,quote);
      }
      start=-1;
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    int quoteSentence=book.tokens.get(quote.start).sentenceID;
    int i=quote.start;
    int currentSentence=quoteSentence;
    while (quoteSentence == currentSentence && i >= 0) {
      Token token=book.tokens.get(i);
      currentSentence=token.sentenceID;
      if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
        quote.attributionId=i;
        break;
      }
      i--;
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    int quoteSentence=book.tokens.get(quote.end).sentenceID;
    int i=quote.end;
    int currentSentence=quoteSentence;
    while (quoteSentence == currentSentence && i < book.tokens.size()) {
      Token token=book.tokens.get(i);
      currentSentence=token.sentenceID;
      if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
        quote.attributionId=i;
        break;
      }
      i++;
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    Map.Entry<Integer,Quotation> map=quotations.floorEntry(quote.start - 1);
    if (map != null) {
      Quotation previous=map.getValue();
      for (int i=quote.start; i > previous.end && i >= 0; i--) {
        Token token=book.tokens.get(i);
        if (token.word.matches(""String_Node_Str"")) {
          break;
        }
        if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
          quote.attributionId=i;
          break;
        }
      }
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    Map.Entry<Integer,Quotation> map=quotations.ceilingEntry(quote.start + 1);
    if (map != null) {
      Quotation next=map.getValue();
      for (int i=quote.end; i < next.start && i < book.tokens.size(); i++) {
        Token token=book.tokens.get(i);
        if (token.word.matches(""String_Node_Str"")) {
          break;
        }
        if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
          quote.attributionId=i;
          break;
        }
      }
    }
  }
  book.quotations=Lists.newArrayList();
  for (  Quotation quote : quotations.values()) {
    book.quotations.add(quote);
  }
}","public void findQuotations(Book book){
  for (  Token token : book.tokens) {
    if (token.pos.startsWith(""String_Node_Str"") && (token.lemma.equals(""String_Node_Str""))) {
      PronounAntecedent pronoun=new PronounAntecedent(token.tokenId,0);
      book.animateEntities.put(token.tokenId,pronoun);
    }
  }
  TreeMap<Integer,Quotation> quotations;
  int start=0;
  int end=0;
  quotations=Maps.newTreeMap();
  int doubleQuotes=0;
  int singleQuotes=0;
  for (  Token token : book.tokens) {
    if (token.lemma.equals(""String_Node_Str"")) {
      doubleQuotes++;
    }
 else     if (token.lemma.equals(""String_Node_Str"")) {
      singleQuotes++;
    }
  }
  boolean usesSingleQuotes=false;
  if (singleQuotes > doubleQuotes) {
    usesSingleQuotes=true;
  }
  boolean open=false;
  if (usesSingleQuotes) {
    Token previousToken=null;
    for (int i=0; i < book.tokens.size(); i++) {
      Token token=book.tokens.get(i);
      if (token.original.equals(""String_Node_Str"")) {
        if (!previousToken.whitespaceAfter.equals(""String_Node_Str"")) {
          token.lemma=""String_Node_Str"";
          token.word=""String_Node_Str"";
          token.pos=""String_Node_Str"";
        }
      }
      previousToken=token;
    }
    previousToken=null;
    for (int i=0; i < book.tokens.size(); i++) {
      Token token=book.tokens.get(i);
      if (token.lemma.equals(""String_Node_Str"")) {
        if (!previousToken.whitespaceAfter.equals(""String_Node_Str"")) {
          open=true;
          start=token.tokenId;
        }
      }
 else       if (token.lemma.equals(""String_Node_Str"")) {
        end=token.tokenId;
        if (start > -1 && open) {
          Quotation quote=new Quotation(start,end,token.sentenceID);
          quotations.put(start,quote);
        }
        start=-1;
        open=false;
      }
      previousToken=token;
    }
  }
 else {
    for (    Token token : book.tokens) {
      if (token.lemma.equals(""String_Node_Str"")) {
        open=true;
        start=token.tokenId;
      }
 else       if (token.lemma.equals(""String_Node_Str"")) {
        end=token.tokenId;
        if (start > -1 && open) {
          Quotation quote=new Quotation(start,end,token.sentenceID);
          quotations.put(start,quote);
        }
        start=-1;
        open=false;
      }
    }
  }
  for (  Token token : book.tokens) {
    token.quotation=false;
  }
  for (  int qstart : quotations.keySet()) {
    Quotation quotation=quotations.get(qstart);
    for (int s=quotation.start; s <= quotation.end; s++) {
      book.tokens.get(s).quotation=true;
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    int quoteSentence=book.tokens.get(quote.start).sentenceID;
    int i=quote.start;
    int currentSentence=quoteSentence;
    while (quoteSentence == currentSentence && i >= 0) {
      Token token=book.tokens.get(i);
      currentSentence=token.sentenceID;
      if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
        quote.attributionId=i;
        break;
      }
      i--;
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    int quoteSentence=book.tokens.get(quote.end).sentenceID;
    int i=quote.end;
    int currentSentence=quoteSentence;
    while (quoteSentence == currentSentence && i < book.tokens.size()) {
      Token token=book.tokens.get(i);
      currentSentence=token.sentenceID;
      if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
        quote.attributionId=i;
        break;
      }
      i++;
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    Map.Entry<Integer,Quotation> map=quotations.floorEntry(quote.start - 1);
    if (map != null) {
      Quotation previous=map.getValue();
      for (int i=quote.start; i > previous.end && i >= 0; i--) {
        Token token=book.tokens.get(i);
        if (token.word.matches(""String_Node_Str"")) {
          break;
        }
        if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
          quote.attributionId=i;
          break;
        }
      }
    }
  }
  for (  Quotation quote : quotations.values()) {
    if (quote.attributionId != 0) {
      continue;
    }
    Map.Entry<Integer,Quotation> map=quotations.ceilingEntry(quote.start + 1);
    if (map != null) {
      Quotation next=map.getValue();
      for (int i=quote.end; i < next.start && i < book.tokens.size(); i++) {
        Token token=book.tokens.get(i);
        if (token.word.matches(""String_Node_Str"")) {
          break;
        }
        if (book.animateEntities.containsKey(i) && token.quotation == false && !token.pos.equals(""String_Node_Str"")) {
          quote.attributionId=i;
          break;
        }
      }
    }
  }
  book.quotations=Lists.newArrayList();
  for (  Quotation quote : quotations.values()) {
    book.quotations.add(quote);
  }
}",0.5145573380867499
30708,"/** 
 * Remove non visible views laid out of the screen
 */
private void removeNonVisibleViews(){
  if (getChildCount() == 0)   return;
  final int leftScreenEdge=getScrollX();
  final int rightScreenEdge=leftScreenEdge + getWidth();
  int dspRightScreenEdge=pxToDsp(rightScreenEdge);
  if (dspRightScreenEdge >= 0)   dspRightScreenEdge++;
  int dspLeftScreenEdge=pxToDsp(leftScreenEdge);
  if (dspLeftScreenEdge < 0)   dspLeftScreenEdge--;
  mTempViewArray.clear();
  View v;
  for (int i=0; i < getChildCount(); i++) {
    v=getChildAt(i);
    if (!isOnScreen((LayoutParams)v.getLayoutParams(),dspLeftScreenEdge,dspRightScreenEdge))     mTempViewArray.add(v);
  }
  for (int i=0; i < mTempViewArray.size(); i++) {
    v=mTempViewArray.get(i);
    removeViewInLayout(v);
    mAdapter.offerViewForRecycling(v);
  }
  mTempViewArray.clear();
  int dspMostRight=dspLeftScreenEdge;
  int dspMostLeft=dspRightScreenEdge;
  LayoutParams lp;
  for (int i=0; i < getChildCount(); i++) {
    lp=(LayoutParams)getChildAt(i).getLayoutParams();
    if (lp.getDspRight() > dspMostRight)     dspMostRight=lp.getDspRight();
    if (lp.dspLeft < dspMostLeft)     dspMostLeft=lp.dspLeft;
  }
  mCurrentlyLayoutedViewsLeftEdgeDsp=dspMostLeft;
  mCurrentlyLayoutedViewsRightEdgeDsp=dspMostRight;
}","/** 
 * Remove non visible views laid out of the screen
 */
private void removeNonVisibleViews(){
  if (getChildCount() == 0)   return;
  final int leftScreenEdge=getScrollX();
  final int rightScreenEdge=leftScreenEdge + getWidth();
  int dspRightScreenEdge=pxToDsp(rightScreenEdge);
  if (dspRightScreenEdge >= 0)   dspRightScreenEdge++;
  int dspLeftScreenEdge=pxToDsp(leftScreenEdge);
  if (dspLeftScreenEdge <= 0)   dspLeftScreenEdge--;
  mTempViewArray.clear();
  View v;
  for (int i=0; i < getChildCount(); i++) {
    v=getChildAt(i);
    if (!isOnScreen((LayoutParams)v.getLayoutParams(),dspLeftScreenEdge,dspRightScreenEdge))     mTempViewArray.add(v);
  }
  for (int i=0; i < mTempViewArray.size(); i++) {
    v=mTempViewArray.get(i);
    removeViewInLayout(v);
    mAdapter.offerViewForRecycling(v);
  }
  mTempViewArray.clear();
  int dspMostRight=dspLeftScreenEdge;
  int dspMostLeft=dspRightScreenEdge;
  LayoutParams lp;
  for (int i=0; i < getChildCount(); i++) {
    lp=(LayoutParams)getChildAt(i).getLayoutParams();
    if (lp.getDspRight() > dspMostRight)     dspMostRight=lp.getDspRight();
    if (lp.dspLeft < dspMostLeft)     dspMostLeft=lp.dspLeft;
  }
  mCurrentlyLayoutedViewsLeftEdgeDsp=dspMostLeft;
  mCurrentlyLayoutedViewsRightEdgeDsp=dspMostRight;
}",0.9996092223524814
30709,"/** 
 * Checks and refills empty area on the left edge of screen
 */
@Override protected void refillLeftSide(){
  final int leftScreenEdge=getScrollX();
  final int dspNextViewsRight=mCurrentlyLayoutedViewsLeftEdgeDsp;
  int dspLeftScreenEdge=pxToDsp(leftScreenEdge);
  if (dspLeftScreenEdge < 0)   dspLeftScreenEdge--;
  int end=mAdapter.getEnd();
  if (dspLeftScreenEdge >= dspNextViewsRight || end == 0)   return;
  int dspModuloLeftScreenEdge=dspLeftScreenEdge % end;
  int dspModuloNextViewsRight=dspNextViewsRight % end;
  int dspOffsetLeftScreenEdge=dspLeftScreenEdge / end;
  int dspOffsetNextViewsRight=dspNextViewsRight / end;
  if (dspModuloLeftScreenEdge < 0) {
    dspModuloLeftScreenEdge+=end;
    dspOffsetLeftScreenEdge-=1;
  }
  if (dspModuloNextViewsRight < 0) {
    dspModuloNextViewsRight+=end;
    dspOffsetNextViewsRight-=1;
  }
  View[] list;
  if (dspModuloLeftScreenEdge > dspModuloNextViewsRight) {
    View[] list1, list2;
    list1=mAdapter.getViewsByRightSideRange(dspModuloLeftScreenEdge,end);
    list2=mAdapter.getViewsByRightSideRange(0,dspModuloNextViewsRight);
    translateLayoutParams(list1,dspOffsetLeftScreenEdge);
    translateLayoutParams(list2,dspOffsetNextViewsRight);
    list=ToolBox.concatenateArray(list1,list2);
  }
 else {
    list=mAdapter.getViewsByRightSideRange(dspModuloLeftScreenEdge,dspModuloNextViewsRight);
    translateLayoutParams(list,dspOffsetLeftScreenEdge);
  }
  int dspMostLeft=dspNextViewsRight;
  LayoutParams lp;
  for (int i=0; i < list.length; i++) {
    lp=(LayoutParams)list[i].getLayoutParams();
    if (lp.dspLeft < dspMostLeft)     dspMostLeft=lp.dspLeft;
    addViewInLayout(list[i],-1,list[i].getLayoutParams(),true);
  }
  if (list.length > 0) {
    layoutNewChildren(list);
  }
  mCurrentlyLayoutedViewsLeftEdgeDsp=dspMostLeft;
}","/** 
 * Checks and refills empty area on the left edge of screen
 */
@Override protected void refillLeftSide(){
  final int leftScreenEdge=getScrollX();
  final int dspNextViewsRight=mCurrentlyLayoutedViewsLeftEdgeDsp;
  int dspLeftScreenEdge=pxToDsp(leftScreenEdge);
  if (dspLeftScreenEdge <= 0)   dspLeftScreenEdge--;
  int end=mAdapter.getEnd();
  if (dspLeftScreenEdge >= dspNextViewsRight || end == 0)   return;
  int dspModuloLeftScreenEdge=dspLeftScreenEdge % end;
  int dspModuloNextViewsRight=dspNextViewsRight % end;
  int dspOffsetLeftScreenEdge=dspLeftScreenEdge / end;
  int dspOffsetNextViewsRight=dspNextViewsRight / end;
  if (dspModuloLeftScreenEdge < 0) {
    dspModuloLeftScreenEdge+=end;
    dspOffsetLeftScreenEdge-=1;
  }
  if (dspModuloNextViewsRight < 0) {
    dspModuloNextViewsRight+=end;
    dspOffsetNextViewsRight-=1;
  }
  View[] list;
  if (dspModuloLeftScreenEdge > dspModuloNextViewsRight) {
    View[] list1, list2;
    list1=mAdapter.getViewsByRightSideRange(dspModuloLeftScreenEdge,end);
    list2=mAdapter.getViewsByRightSideRange(0,dspModuloNextViewsRight);
    translateLayoutParams(list1,dspOffsetLeftScreenEdge);
    translateLayoutParams(list2,dspOffsetNextViewsRight);
    list=ToolBox.concatenateArray(list1,list2);
  }
 else {
    list=mAdapter.getViewsByRightSideRange(dspModuloLeftScreenEdge,dspModuloNextViewsRight);
    translateLayoutParams(list,dspOffsetLeftScreenEdge);
  }
  int dspMostLeft=dspNextViewsRight;
  LayoutParams lp;
  for (int i=0; i < list.length; i++) {
    lp=(LayoutParams)list[i].getLayoutParams();
    if (lp.dspLeft < dspMostLeft)     dspMostLeft=lp.dspLeft;
    addViewInLayout(list[i],-1,list[i].getLayoutParams(),true);
  }
  if (list.length > 0) {
    layoutNewChildren(list);
  }
  mCurrentlyLayoutedViewsLeftEdgeDsp=dspMostLeft;
}",0.9997236805747444
30710,"/** 
 * Takes a URI for an image contained within an application jar file and  converts it into a data URI for use in a MarkerOptions object. <p> Usage: <p> markerOptions.icon(MarkerImageFactory.createMarkerImage(""/path/to/my/image.jpg"", ""jpg"")); <p> Currently tested to work with ""jpg"" and ""png"" files.
 * @param uri
 * @param type
 * @return 
 * @throws java.io.IOException 
 */
public static String createMarkerImage(String uri,String type){
  String dataURI=null;
  URL myURL=MarkerImageFactory.class.getResource(uri);
  if (myURL != null) {
    String myURI=myURL.toExternalForm();
    Image img=new Image(myURI);
    String imageMimeType=""String_Node_Str"" + type;
    try {
      dataURI=""String_Node_Str"" + imageMimeType + ""String_Node_Str""+ javax.xml.bind.DatatypeConverter.printBase64Binary(getImageBytes(SwingFXUtils.fromFXImage(img,null),type))+ ""String_Node_Str"";
    }
 catch (    IOException ioe) {
      Logger.getLogger(MarkerImageFactory.class.getName()).log(Level.WARNING,""String_Node_Str"",ioe);
      dataURI=null;
    }
  }
  return dataURI;
}","/** 
 * Takes a URI for an image contained within an application jar file and  converts it into a data URI for use in a MarkerOptions object. <p> Usage: <p> markerOptions.icon(MarkerImageFactory.createMarkerImage(""/path/to/my/image.jpg"", ""jpg"")); <p> Currently tested to work with ""jpg"" and ""png"" files.
 * @param uri
 * @param type
 * @return 
 */
public static String createMarkerImage(String uri,String type){
  String dataURI=null;
  URL myURL=MarkerImageFactory.class.getResource(uri);
  if (myURL != null) {
    String myURI=myURL.toExternalForm();
    Image img=new Image(myURI);
    String imageMimeType=""String_Node_Str"" + type;
    try {
      dataURI=""String_Node_Str"" + imageMimeType + ""String_Node_Str""+ javax.xml.bind.DatatypeConverter.printBase64Binary(getImageBytes(SwingFXUtils.fromFXImage(img,null),type))+ ""String_Node_Str"";
    }
 catch (    IOException ioe) {
      Logger.getLogger(MarkerImageFactory.class.getName()).log(Level.WARNING,""String_Node_Str"",ioe);
      dataURI=null;
    }
  }
  return dataURI;
}",0.4937917860553963
30711,"@Override public void start(final Stage stage) throws Exception {
  mapComponent=new GoogleMapView();
  mapComponent.addMapInializedListener(this);
  BorderPane bp=new BorderPane();
  ToolBar tb=new ToolBar();
  btnZoomIn=new Button(""String_Node_Str"");
  btnZoomIn.setOnAction(e -> {
    map.zoomProperty().set(map.getZoom() + 1);
  }
);
  btnZoomIn.setDisable(true);
  btnZoomOut=new Button(""String_Node_Str"");
  btnZoomOut.setOnAction(e -> {
    map.zoomProperty().set(map.getZoom() - 1);
  }
);
  btnZoomOut.setDisable(true);
  lblZoom=new Label();
  lblCenter=new Label();
  lblClick=new Label();
  tb.getItems().addAll(btnZoomIn,btnZoomOut,new Label(""String_Node_Str""),lblZoom,new Label(""String_Node_Str""),lblCenter,new Label(""String_Node_Str""),lblClick);
  bp.setTop(tb);
  bp.setCenter(mapComponent);
  Scene scene=new Scene(bp);
  stage.setScene(scene);
  stage.show();
}","@Override public void start(final Stage stage) throws Exception {
  mapComponent=new GoogleMapView();
  mapComponent.addMapInializedListener(this);
  BorderPane bp=new BorderPane();
  ToolBar tb=new ToolBar();
  btnZoomIn=new Button(""String_Node_Str"");
  btnZoomIn.setOnAction(e -> {
    map.zoomProperty().set(map.getZoom() + 1);
  }
);
  btnZoomIn.setDisable(true);
  btnZoomOut=new Button(""String_Node_Str"");
  btnZoomOut.setOnAction(e -> {
    map.zoomProperty().set(map.getZoom() - 1);
  }
);
  btnZoomOut.setDisable(true);
  lblZoom=new Label();
  lblCenter=new Label();
  lblClick=new Label();
  mapTypeCombo=new ComboBox<>();
  mapTypeCombo.setOnAction(e -> {
    map.setMapType(mapTypeCombo.getSelectionModel().getSelectedItem());
  }
);
  mapTypeCombo.setDisable(true);
  Button btnType=new Button(""String_Node_Str"");
  btnType.setOnAction(e -> {
    map.setMapType(MapTypeIdEnum.HYBRID);
  }
);
  tb.getItems().addAll(btnZoomIn,btnZoomOut,mapTypeCombo,new Label(""String_Node_Str""),lblZoom,new Label(""String_Node_Str""),lblCenter,new Label(""String_Node_Str""),lblClick);
  bp.setTop(tb);
  bp.setCenter(mapComponent);
  Scene scene=new Scene(bp);
  stage.setScene(scene);
  stage.show();
}",0.7928709055876686
30712,"@Override public void mapInitialized(){
  LatLong center=new LatLong(47.606189,-122.335842);
  MapOptions options=new MapOptions();
  options.center(center).mapMarker(true).zoom(9).overviewMapControl(false).panControl(false).rotateControl(false).scaleControl(false).streetViewControl(false).zoomControl(false).mapType(MapTypeIdEnum.TERRAIN);
  map=mapComponent.createMap(options);
  MarkerOptions markerOptions=new MarkerOptions();
  LatLong markerLatLong=new LatLong(47.606189,-122.335842);
  markerOptions.position(markerLatLong).title(""String_Node_Str"").animation(Animation.DROP).visible(true);
  final Marker myMarker=new Marker(markerOptions);
  MarkerOptions markerOptions2=new MarkerOptions();
  LatLong markerLatLong2=new LatLong(47.906189,-122.335842);
  markerOptions2.position(markerLatLong2).title(""String_Node_Str"").visible(true);
  Marker myMarker2=new Marker(markerOptions2);
  map.addMarker(myMarker);
  map.addMarker(myMarker2);
  InfoWindowOptions infoOptions=new InfoWindowOptions();
  infoOptions.content(""String_Node_Str"").position(center);
  InfoWindow window=new InfoWindow(infoOptions);
  window.open(map,myMarker);
  lblCenter.setText(map.getCenter().toString());
  map.centerProperty().addListener((  ObservableValue<? extends LatLong> obs,  LatLong o,  LatLong n) -> {
    lblCenter.setText(n.toString());
  }
);
  lblZoom.setText(Integer.toString(map.getZoom()));
  map.zoomProperty().addListener((  ObservableValue<? extends Number> obs,  Number o,  Number n) -> {
    lblZoom.setText(n.toString());
  }
);
  map.addUIEventHandler(UIEventType.click,(  JSObject obj) -> {
    LatLong ll=new LatLong((JSObject)obj.getMember(""String_Node_Str""));
    lblClick.setText(ll.toString());
  }
);
  btnZoomIn.setDisable(false);
  btnZoomOut.setDisable(false);
  LatLong[] ary=new LatLong[]{markerLatLong,markerLatLong2};
  MVCArray mvc=new MVCArray(ary);
  PolylineOptions polyOpts=new PolylineOptions().path(mvc).strokeColor(""String_Node_Str"").strokeWeight(2);
  Polyline poly=new Polyline(polyOpts);
  map.addMapShape(poly);
  map.addUIEventHandler(poly,UIEventType.click,(  JSObject obj) -> {
    LatLong ll=new LatLong((JSObject)obj.getMember(""String_Node_Str""));
    System.out.println(""String_Node_Str"" + ll.getLatitude() + ""String_Node_Str""+ ll.getLongitude());
  }
);
  LatLong poly1=new LatLong(47.429945,-122.84363);
  LatLong poly2=new LatLong(47.361153,-123.03040);
  LatLong poly3=new LatLong(47.387193,-123.11554);
  LatLong poly4=new LatLong(47.585789,-122.96722);
  LatLong[] pAry=new LatLong[]{poly1,poly2,poly3,poly4};
  MVCArray pmvc=new MVCArray(pAry);
  PolygonOptions polygOpts=new PolygonOptions().paths(pmvc).strokeColor(""String_Node_Str"").strokeWeight(2).editable(false).fillColor(""String_Node_Str"").fillOpacity(0.5);
  Polygon pg=new Polygon(polygOpts);
  map.addMapShape(pg);
  map.addUIEventHandler(pg,UIEventType.click,(  JSObject obj) -> {
    pg.setEditable(!pg.getEditable());
  }
);
  LatLong centreC=new LatLong(47.545481,-121.87384);
  CircleOptions cOpts=new CircleOptions().center(centreC).radius(5000).strokeColor(""String_Node_Str"").strokeWeight(2).fillColor(""String_Node_Str"").fillOpacity(0.3);
  Circle c=new Circle(cOpts);
  map.addMapShape(c);
  map.addUIEventHandler(c,UIEventType.click,(  JSObject obj) -> {
    c.setEditable(!c.getEditable());
  }
);
  LatLongBounds llb=new LatLongBounds(new LatLong(47.533893,-122.89856),new LatLong(47.580694,-122.80312));
  RectangleOptions rOpts=new RectangleOptions().bounds(llb).strokeColor(""String_Node_Str"").strokeWeight(2).fillColor(""String_Node_Str"");
  Rectangle rt=new Rectangle(rOpts);
  map.addMapShape(rt);
  LatLong arcC=new LatLong(47.227029,-121.81641);
  double startBearing=0;
  double endBearing=30;
  double radius=30000;
  MVCArray path=ArcBuilder.buildArcPoints(arcC,startBearing,endBearing,radius);
  path.push(arcC);
  Polygon arc=new Polygon(new PolygonOptions().paths(path).strokeColor(""String_Node_Str"").fillColor(""String_Node_Str"").fillOpacity(0.3).strokeWeight(2).editable(false));
  map.addMapShape(arc);
  map.addUIEventHandler(arc,UIEventType.click,(  JSObject obj) -> {
    arc.setEditable(!arc.getEditable());
  }
);
  LatLong ll=new LatLong(-41.2,145.9);
  LocationElevationRequest ler=new LocationElevationRequest(new LatLong[]{ll});
  ElevationService es=new ElevationService();
  es.getElevationForLocations(ler,new ElevationServiceCallback(){
    @Override public void elevationsReceived(    ElevationResult[] results,    ElevationStatus status){
      System.out.println(""String_Node_Str"");
      for (      ElevationResult er : results) {
        System.out.println(""String_Node_Str"" + er.getElevation());
      }
    }
  }
);
  LatLong lle=new LatLong(-42.2,145.9);
  PathElevationRequest per=new PathElevationRequest(new LatLong[]{ll,lle},3);
  ElevationService esb=new ElevationService();
  esb.getElevationAlongPath(per,new ElevationServiceCallback(){
    @Override public void elevationsReceived(    ElevationResult[] results,    ElevationStatus status){
      System.out.println(""String_Node_Str"");
      for (      ElevationResult er : results) {
        System.out.println(""String_Node_Str"" + er.getElevation());
      }
    }
  }
);
  MaxZoomService mzs=new MaxZoomService();
  mzs.getMaxZoomAtLatLng(lle,new MaxZoomServiceCallback(){
    @Override public void maxZoomReceived(    MaxZoomResult result){
      System.out.println(""String_Node_Str"" + result.getStatus());
      System.out.println(""String_Node_Str"" + result.getMaxZoom());
    }
  }
);
}","@Override public void mapInitialized(){
  LatLong center=new LatLong(47.606189,-122.335842);
  MapOptions options=new MapOptions();
  options.center(center).mapMarker(true).zoom(9).overviewMapControl(false).panControl(false).rotateControl(false).scaleControl(false).streetViewControl(false).zoomControl(false).mapType(MapTypeIdEnum.TERRAIN);
  map=mapComponent.createMap(options);
  MarkerOptions markerOptions=new MarkerOptions();
  LatLong markerLatLong=new LatLong(47.606189,-122.335842);
  markerOptions.position(markerLatLong).title(""String_Node_Str"").animation(Animation.DROP).visible(true);
  final Marker myMarker=new Marker(markerOptions);
  MarkerOptions markerOptions2=new MarkerOptions();
  LatLong markerLatLong2=new LatLong(47.906189,-122.335842);
  markerOptions2.position(markerLatLong2).title(""String_Node_Str"").visible(true);
  Marker myMarker2=new Marker(markerOptions2);
  map.addMarker(myMarker);
  map.addMarker(myMarker2);
  InfoWindowOptions infoOptions=new InfoWindowOptions();
  infoOptions.content(""String_Node_Str"").position(center);
  InfoWindow window=new InfoWindow(infoOptions);
  window.open(map,myMarker);
  lblCenter.setText(map.getCenter().toString());
  map.centerProperty().addListener((  ObservableValue<? extends LatLong> obs,  LatLong o,  LatLong n) -> {
    lblCenter.setText(n.toString());
  }
);
  lblZoom.setText(Integer.toString(map.getZoom()));
  map.zoomProperty().addListener((  ObservableValue<? extends Number> obs,  Number o,  Number n) -> {
    lblZoom.setText(n.toString());
  }
);
  map.addUIEventHandler(UIEventType.click,(  JSObject obj) -> {
    LatLong ll=new LatLong((JSObject)obj.getMember(""String_Node_Str""));
    lblClick.setText(ll.toString());
  }
);
  btnZoomIn.setDisable(false);
  btnZoomOut.setDisable(false);
  mapTypeCombo.setDisable(false);
  mapTypeCombo.getItems().addAll(MapTypeIdEnum.ALL);
  LatLong[] ary=new LatLong[]{markerLatLong,markerLatLong2};
  MVCArray mvc=new MVCArray(ary);
  PolylineOptions polyOpts=new PolylineOptions().path(mvc).strokeColor(""String_Node_Str"").strokeWeight(2);
  Polyline poly=new Polyline(polyOpts);
  map.addMapShape(poly);
  map.addUIEventHandler(poly,UIEventType.click,(  JSObject obj) -> {
    LatLong ll=new LatLong((JSObject)obj.getMember(""String_Node_Str""));
    System.out.println(""String_Node_Str"" + ll.getLatitude() + ""String_Node_Str""+ ll.getLongitude());
  }
);
  LatLong poly1=new LatLong(47.429945,-122.84363);
  LatLong poly2=new LatLong(47.361153,-123.03040);
  LatLong poly3=new LatLong(47.387193,-123.11554);
  LatLong poly4=new LatLong(47.585789,-122.96722);
  LatLong[] pAry=new LatLong[]{poly1,poly2,poly3,poly4};
  MVCArray pmvc=new MVCArray(pAry);
  PolygonOptions polygOpts=new PolygonOptions().paths(pmvc).strokeColor(""String_Node_Str"").strokeWeight(2).editable(false).fillColor(""String_Node_Str"").fillOpacity(0.5);
  Polygon pg=new Polygon(polygOpts);
  map.addMapShape(pg);
  map.addUIEventHandler(pg,UIEventType.click,(  JSObject obj) -> {
    pg.setEditable(!pg.getEditable());
  }
);
  LatLong centreC=new LatLong(47.545481,-121.87384);
  CircleOptions cOpts=new CircleOptions().center(centreC).radius(5000).strokeColor(""String_Node_Str"").strokeWeight(2).fillColor(""String_Node_Str"").fillOpacity(0.3);
  Circle c=new Circle(cOpts);
  map.addMapShape(c);
  map.addUIEventHandler(c,UIEventType.click,(  JSObject obj) -> {
    c.setEditable(!c.getEditable());
  }
);
  LatLongBounds llb=new LatLongBounds(new LatLong(47.533893,-122.89856),new LatLong(47.580694,-122.80312));
  RectangleOptions rOpts=new RectangleOptions().bounds(llb).strokeColor(""String_Node_Str"").strokeWeight(2).fillColor(""String_Node_Str"");
  Rectangle rt=new Rectangle(rOpts);
  map.addMapShape(rt);
  LatLong arcC=new LatLong(47.227029,-121.81641);
  double startBearing=0;
  double endBearing=30;
  double radius=30000;
  MVCArray path=ArcBuilder.buildArcPoints(arcC,startBearing,endBearing,radius);
  path.push(arcC);
  Polygon arc=new Polygon(new PolygonOptions().paths(path).strokeColor(""String_Node_Str"").fillColor(""String_Node_Str"").fillOpacity(0.3).strokeWeight(2).editable(false));
  map.addMapShape(arc);
  map.addUIEventHandler(arc,UIEventType.click,(  JSObject obj) -> {
    arc.setEditable(!arc.getEditable());
  }
);
  LatLong ll=new LatLong(-41.2,145.9);
  LocationElevationRequest ler=new LocationElevationRequest(new LatLong[]{ll});
  ElevationService es=new ElevationService();
  es.getElevationForLocations(ler,new ElevationServiceCallback(){
    @Override public void elevationsReceived(    ElevationResult[] results,    ElevationStatus status){
      System.out.println(""String_Node_Str"");
      for (      ElevationResult er : results) {
        System.out.println(""String_Node_Str"" + er.getElevation());
      }
    }
  }
);
  LatLong lle=new LatLong(-42.2,145.9);
  PathElevationRequest per=new PathElevationRequest(new LatLong[]{ll,lle},3);
  ElevationService esb=new ElevationService();
  esb.getElevationAlongPath(per,new ElevationServiceCallback(){
    @Override public void elevationsReceived(    ElevationResult[] results,    ElevationStatus status){
      System.out.println(""String_Node_Str"");
      for (      ElevationResult er : results) {
        System.out.println(""String_Node_Str"" + er.getElevation());
      }
    }
  }
);
  MaxZoomService mzs=new MaxZoomService();
  mzs.getMaxZoomAtLatLng(lle,new MaxZoomServiceCallback(){
    @Override public void maxZoomReceived(    MaxZoomResult result){
      System.out.println(""String_Node_Str"" + result.getStatus());
      System.out.println(""String_Node_Str"" + result.getMaxZoom());
    }
  }
);
}",0.9921543872305888
30713,"/** 
 * Invoke the specified JavaScript function in the JavaScript runtime.
 * @param function The function to invoke
 * @param args Any arguments to pass to the function
 * @return The result of the function.
 */
protected Object invokeJavascript(String function,Object... args){
  Object[] jsArgs=new Object[args.length];
  for (int i=0; i < jsArgs.length; i++) {
    if (args[i] instanceof JavascriptObject) {
      jsArgs[i]=((JavascriptObject)args[i]).getJSObject();
    }
 else {
      jsArgs[i]=args[i];
    }
  }
  return jsObject.call(function,(Object[])jsArgs);
}","/** 
 * Invoke the specified JavaScript function in the JavaScript runtime.
 * @param function The function to invoke
 * @param args Any arguments to pass to the function
 * @return The result of the function.
 */
protected Object invokeJavascript(String function,Object... args){
  Object[] jsArgs=new Object[args.length];
  for (int i=0; i < jsArgs.length; i++) {
    if (args[i] instanceof JavascriptObject) {
      jsArgs[i]=((JavascriptObject)args[i]).getJSObject();
    }
 else     if (args[i] instanceof JavascriptEnum) {
      jsArgs[i]=((JavascriptEnum)args[i]).getEnumValue();
    }
 else {
      jsArgs[i]=args[i];
    }
  }
  return jsObject.call(function,(Object[])jsArgs);
}",0.8977002379064235
30714,"@Override public final void close(){
  offsets.close();
  if (address != 0) {
    Unsafe.free(address,capacity);
    address=0;
  }
}","@Override public final void close(){
  offsets=Misc.free(offsets);
  if (address != 0) {
    Unsafe.free(address,capacity);
    address=0;
  }
}",0.9386281588447654
30715,"@Override public MapKey withKeyAsLong(long value){
  key.startAddress=kPos;
  key.appendAddress=key.startAddress + keyDataOffset;
  if (key.appendAddress + 8 > kLimit) {
    resize(8);
  }
  Unsafe.getUnsafe().putLong(key.appendAddress,value);
  key.appendAddress+=8;
  return key;
}","@Override public MapKey withKeyAsLong(long value){
  key.startAddress=kPos;
  key.appendAddress=kPos + keyDataOffset;
  if (key.appendAddress + 8 > kLimit) {
    key.nextColOffset=kPos + keyBlockOffset;
    resize(8);
  }
  Unsafe.getUnsafe().putLong(key.appendAddress,value);
  key.appendAddress+=8;
  return key;
}",0.8981636060100167
30716,"public void of(TableReader reader){
  this.reader=reader;
  this.timestampIndex=reader.getMetadata().getTimestampIndex();
  if (this.timestampIndex == -1) {
    throw CairoException.instance(0).put(""String_Node_Str"");
  }
  calculateRanges();
}","public void of(TableReader reader){
  this.timestampIndex=reader.getMetadata().getTimestampIndex();
  if (this.timestampIndex == -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(reader.getTableName()).put(""String_Node_Str"");
  }
  this.reader=reader;
  calculateRanges();
}",0.8252788104089219
30717,"private void calculateRanges(){
  if (intervals.size() > 0) {
    if (reader.getPartitionedBy() == PartitionBy.NONE) {
      initialIntervalsLo=0;
      initialIntervalsHi=intervals.size();
      initialPartitionLo=0;
      initialPartitionHi=reader.getPartitionCount();
    }
 else {
      cullIntervals();
      if (initialIntervalsLo < initialIntervalsHi) {
        cullPartitions();
      }
    }
    toTop();
  }
}","private void calculateRanges(){
  if (intervals.size() > 0) {
    if (reader.getPartitionedBy() == PartitionBy.NONE) {
      initialIntervalsLo=0;
      initialIntervalsHi=intervals.size() / 2;
      initialPartitionLo=0;
      initialPartitionHi=reader.getPartitionCount();
    }
 else {
      cullIntervals();
      if (initialIntervalsLo < initialIntervalsHi) {
        cullPartitions();
      }
    }
    toTop();
  }
}",0.995249406175772
30718,"/** 
 * Adds key-value pair to index. If key already exists, value is appended to end of list of existing values. Otherwise new value list is associated with the key. <p> Index is updated atomically as far as concurrent reading is concerned. Please refer to notes on classes that are responsible for reading bitmap indexes, such as   {@link BitmapIndexBackwardReader}.
 * @param key   int key
 * @param value long value
 */
public void add(int key,long value){
}","/** 
 * Adds key-value pair to index. If key already exists, value is appended to end of list of existing values. Otherwise new value list is associated with the key. <p> Index is updated atomically as far as concurrent reading is concerned. Please refer to notes on classes that are responsible for reading bitmap indexes, such as   {@link BitmapIndexBwdReader}.
 * @param key   int key
 * @param value long value
 */
public void add(int key,long value){
}",0.9945593035908596
30719,"@Override public boolean hasNext(){
  while (intervalsLo < intervalsHi && partitionLo < partitionHi) {
    final int currentInterval=intervalsHi - 1;
    final int currentPartition=partitionHi - 1;
    long rowCount=reader.openPartition(currentPartition);
    if (rowCount > 0) {
      final ReadOnlyColumn column=reader.getColumn(TableReader.getPrimaryColumnIndex(reader.getColumnBase(currentPartition),timestampIndex));
      final long intervalLo=intervals.getQuick(currentInterval * 2);
      final long intervalHi=intervals.getQuick(currentInterval * 2 + 1);
      if (column.getLong(0) > intervalHi) {
        intervalsHi=currentInterval;
        continue;
      }
      if (column.getLong((rowCount - 1) * 8) < intervalLo) {
        partitionLimit=-1;
        intervalsHi=currentInterval;
        continue;
      }
      long lo=search(column,intervalLo,0,partitionLimit == -1 ? rowCount : partitionLimit);
      if (lo < 0) {
        lo=-lo - 1;
      }
      long hi=search(column,intervalHi,lo,rowCount);
      if (hi < 0) {
        hi=-hi - 1;
      }
 else {
        hi++;
      }
      if (lo < hi) {
        dataFrame.partitionIndex=currentPartition;
        dataFrame.rowLo=lo;
        dataFrame.rowHi=hi;
        if (lo == 0) {
          partitionLimit=-1;
          partitionHi=currentPartition;
        }
 else {
          partitionLimit=lo;
          intervalsHi=currentInterval;
        }
        return true;
      }
      partitionLimit=lo;
      intervalsHi=currentInterval;
    }
 else {
      partitionLo++;
    }
  }
  return false;
}","@Override public boolean hasNext(){
  while (intervalsLo < intervalsHi && partitionLo < partitionHi) {
    final int currentInterval=intervalsHi - 1;
    final int currentPartition=partitionHi - 1;
    long rowCount=reader.openPartition(currentPartition);
    if (rowCount > 0) {
      final ReadOnlyColumn column=reader.getColumn(TableReader.getPrimaryColumnIndex(reader.getColumnBase(currentPartition),timestampIndex));
      final long intervalLo=intervals.getQuick(currentInterval * 2);
      final long intervalHi=intervals.getQuick(currentInterval * 2 + 1);
      if (column.getLong(0) > intervalHi) {
        partitionHi=currentPartition;
        partitionLimit=-1;
        continue;
      }
      if (column.getLong((rowCount - 1) * 8) < intervalLo) {
        partitionLimit=-1;
        intervalsHi=currentInterval;
        continue;
      }
      long lo=search(column,intervalLo,0,partitionLimit == -1 ? rowCount : partitionLimit);
      if (lo < 0) {
        lo=-lo - 1;
      }
      long hi=search(column,intervalHi,lo,rowCount);
      if (hi < 0) {
        hi=-hi - 1;
      }
 else {
        hi++;
      }
      if (lo < hi) {
        dataFrame.partitionIndex=currentPartition;
        dataFrame.rowLo=lo;
        dataFrame.rowHi=hi;
        if (lo == 0) {
          partitionLimit=-1;
          partitionHi=currentPartition;
        }
 else {
          partitionLimit=lo;
          intervalsHi=currentInterval;
        }
        return true;
      }
      partitionLimit=lo;
      intervalsHi=currentInterval;
    }
 else {
      partitionHi=currentPartition;
    }
  }
  return false;
}",0.9731267783749604
30720,"private void reloadColumnAt(Path path,ObjList<ReadOnlyColumn> columns,LongList columnTops,ObjList<BitmapIndexReader> indexReaders,int columnBase,int columnIndex,long partitionRowCount){
  int plen=path.length();
  try {
    final CharSequence name=metadata.getColumnName(columnIndex);
    final int primaryIndex=getPrimaryColumnIndex(columnBase,columnIndex);
    final int secondaryIndex=primaryIndex + 1;
    ReadOnlyColumn mem1=columns.getQuick(primaryIndex);
    ReadOnlyColumn mem2=columns.getQuick(secondaryIndex);
    if (ff.exists(TableUtils.dFile(path.trimTo(plen),name))) {
      if (mem1 instanceof ReadOnlyMemory) {
        ((ReadOnlyMemory)mem1).of(ff,path,ff.getMapPageSize(),0);
      }
 else {
        mem1=new ReadOnlyMemory(ff,path,ff.getMapPageSize(),0);
        columns.setQuick(primaryIndex,mem1);
      }
      final long columnTop=TableUtils.readColumnTop(ff,path.trimTo(plen),name,plen,tempMem8b);
      final int type=metadata.getColumnType(columnIndex);
switch (type) {
case ColumnType.BINARY:
case ColumnType.STRING:
        TableUtils.iFile(path.trimTo(plen),name);
      if (mem2 instanceof ReadOnlyMemory) {
        ((ReadOnlyMemory)mem2).of(ff,path,ff.getMapPageSize(),0);
      }
 else {
        mem2=new ReadOnlyMemory(ff,path,ff.getMapPageSize(),0);
        columns.setQuick(secondaryIndex,mem2);
      }
    growColumn(mem1,mem2,type,partitionRowCount - columnTop);
  break;
default :
Misc.free(columns.getAndSetQuick(secondaryIndex,null));
growColumn(mem1,null,type,partitionRowCount - columnTop);
break;
}
columnTops.setQuick(columnBase / 2 + columnIndex,columnTop);
if (metadata.isColumnIndexed(columnIndex)) {
BitmapIndexReader indexReader=indexReaders.getQuick(primaryIndex);
if (indexReader instanceof BitmapIndexBackwardReader) {
((BitmapIndexBackwardReader)indexReader).of(configuration,path.trimTo(plen),name,columnTop);
}
indexReader=indexReaders.getQuick(secondaryIndex);
if (indexReader instanceof BitmapIndexForwardReader) {
((BitmapIndexForwardReader)indexReader).of(configuration,path.trimTo(plen),name,columnTop);
}
}
 else {
Misc.free(indexReaders.getAndSetQuick(primaryIndex,null));
Misc.free(indexReaders.getAndSetQuick(secondaryIndex,null));
}
}
 else {
Misc.free(columns.getAndSetQuick(primaryIndex,NullColumn.INSTANCE));
Misc.free(columns.getAndSetQuick(secondaryIndex,NullColumn.INSTANCE));
Misc.free(indexReaders.getAndSetQuick(primaryIndex,null));
Misc.free(indexReaders.getAndSetQuick(secondaryIndex,null));
}
}
  finally {
path.trimTo(plen);
}
}","private void reloadColumnAt(Path path,ObjList<ReadOnlyColumn> columns,LongList columnTops,ObjList<BitmapIndexReader> indexReaders,int columnBase,int columnIndex,long partitionRowCount){
  int plen=path.length();
  try {
    final CharSequence name=metadata.getColumnName(columnIndex);
    final int primaryIndex=getPrimaryColumnIndex(columnBase,columnIndex);
    final int secondaryIndex=primaryIndex + 1;
    ReadOnlyColumn mem1=columns.getQuick(primaryIndex);
    ReadOnlyColumn mem2=columns.getQuick(secondaryIndex);
    if (ff.exists(TableUtils.dFile(path.trimTo(plen),name))) {
      if (mem1 instanceof ReadOnlyMemory) {
        ((ReadOnlyMemory)mem1).of(ff,path,ff.getMapPageSize(),0);
      }
 else {
        mem1=new ReadOnlyMemory(ff,path,ff.getMapPageSize(),0);
        columns.setQuick(primaryIndex,mem1);
      }
      final long columnTop=TableUtils.readColumnTop(ff,path.trimTo(plen),name,plen,tempMem8b);
      final int type=metadata.getColumnType(columnIndex);
switch (type) {
case ColumnType.BINARY:
case ColumnType.STRING:
        TableUtils.iFile(path.trimTo(plen),name);
      if (mem2 instanceof ReadOnlyMemory) {
        ((ReadOnlyMemory)mem2).of(ff,path,ff.getMapPageSize(),0);
      }
 else {
        mem2=new ReadOnlyMemory(ff,path,ff.getMapPageSize(),0);
        columns.setQuick(secondaryIndex,mem2);
      }
    growColumn(mem1,mem2,type,partitionRowCount - columnTop);
  break;
default :
Misc.free(columns.getAndSetQuick(secondaryIndex,null));
growColumn(mem1,null,type,partitionRowCount - columnTop);
break;
}
columnTops.setQuick(columnBase / 2 + columnIndex,columnTop);
if (metadata.isColumnIndexed(columnIndex)) {
BitmapIndexReader indexReader=indexReaders.getQuick(primaryIndex);
if (indexReader instanceof BitmapIndexBwdReader) {
((BitmapIndexBwdReader)indexReader).of(configuration,path.trimTo(plen),name,columnTop);
}
indexReader=indexReaders.getQuick(secondaryIndex);
if (indexReader instanceof BitmapIndexFwdReader) {
((BitmapIndexFwdReader)indexReader).of(configuration,path.trimTo(plen),name,columnTop);
}
}
 else {
Misc.free(indexReaders.getAndSetQuick(primaryIndex,null));
Misc.free(indexReaders.getAndSetQuick(secondaryIndex,null));
}
}
 else {
Misc.free(columns.getAndSetQuick(primaryIndex,NullColumn.INSTANCE));
Misc.free(columns.getAndSetQuick(secondaryIndex,NullColumn.INSTANCE));
Misc.free(indexReaders.getAndSetQuick(primaryIndex,null));
Misc.free(indexReaders.getAndSetQuick(secondaryIndex,null));
}
}
  finally {
path.trimTo(plen);
}
}",0.919903884661594
30721,"@NotNull private BitmapIndexReader createBitmapIndexReaderAt(int globalIndex,int columnBase,int columnIndex,int direction){
  BitmapIndexReader reader;
  if (!metadata.isColumnIndexed(columnIndex)) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(metadata.getColumnName(columnIndex));
  }
  ReadOnlyColumn col=columns.getQuick(globalIndex);
  if (col instanceof NullColumn) {
    if (direction == BitmapIndexReader.DIR_BACKWARD) {
      reader=new BitmapIndexBackwardNullReader();
      bitmapIndexes.setQuick(globalIndex,reader);
    }
 else {
      reader=new BitmapIndexForwardNullReader();
      bitmapIndexes.setQuick(globalIndex + 1,reader);
    }
  }
 else {
    Path path=partitionPathGenerator.generate(this,getPartitionIndex(columnBase));
    try {
      if (direction == BitmapIndexReader.DIR_BACKWARD) {
        reader=new BitmapIndexBackwardReader(configuration,path.chopZ(),metadata.getColumnName(columnIndex),getColumnTop(columnBase,columnIndex));
        bitmapIndexes.setQuick(globalIndex,reader);
      }
 else {
        reader=new BitmapIndexForwardReader(configuration,path.chopZ(),metadata.getColumnName(columnIndex),getColumnTop(columnBase,columnIndex));
        bitmapIndexes.setQuick(globalIndex + 1,reader);
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
  return reader;
}","@NotNull private BitmapIndexReader createBitmapIndexReaderAt(int globalIndex,int columnBase,int columnIndex,int direction){
  BitmapIndexReader reader;
  if (!metadata.isColumnIndexed(columnIndex)) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(metadata.getColumnName(columnIndex));
  }
  ReadOnlyColumn col=columns.getQuick(globalIndex);
  if (col instanceof NullColumn) {
    if (direction == BitmapIndexReader.DIR_BACKWARD) {
      reader=new BitmapIndexBwdNullReader();
      bitmapIndexes.setQuick(globalIndex,reader);
    }
 else {
      reader=new BitmapIndexFwdNullReader();
      bitmapIndexes.setQuick(globalIndex + 1,reader);
    }
  }
 else {
    Path path=partitionPathGenerator.generate(this,getPartitionIndex(columnBase));
    try {
      if (direction == BitmapIndexReader.DIR_BACKWARD) {
        reader=new BitmapIndexBwdReader(configuration,path.chopZ(),metadata.getColumnName(columnIndex),getColumnTop(columnBase,columnIndex));
        bitmapIndexes.setQuick(globalIndex,reader);
      }
 else {
        reader=new BitmapIndexFwdReader(configuration,path.chopZ(),metadata.getColumnName(columnIndex),getColumnTop(columnBase,columnIndex));
        bitmapIndexes.setQuick(globalIndex + 1,reader);
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
  return reader;
}",0.7173091458805745
30722,"private void parseFromClause(QueryModel model,QueryModel masterModel) throws ParserException {
  CharSequence tok=expectTableNameOrSubQuery();
  if (Chars.equals(tok,'(')) {
    model.setNestedModel(parseSubQuery());
    expectTok(')');
    tok=optTok();
    if (tok != null && !tableAliasStop.contains(tok)) {
      model.setAlias(literal(tok));
      tok=optTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=optTok();
    }
  }
 else {
    parseSelectFrom(model,tok,masterModel);
    tok=optTok();
    if (tok != null && !tableAliasStop.contains(tok)) {
      model.setAlias(literal(tok));
      tok=optTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=optTok();
    }
    if (Chars.equalsNc(""String_Node_Str"",tok)) {
      parseLatestBy(model);
      tok=optTok();
    }
  }
  int joinType;
  while (tok != null && (joinType=joinStartSet.get(tok)) != -1) {
    model.addJoinModel(parseJoin(tok,joinType,masterModel));
    tok=optTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    model.setWhereClause(expr());
    tok=optTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
    model.setSampleBy(expectLiteral());
    tok=optTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
    do {
      tok=tok(""String_Node_Str"");
      if (Chars.equals(tok,')')) {
        throw err(""String_Node_Str"");
      }
      lexer.unparse();
      ExprNode n=expectLiteral();
      tok=optTok();
      if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_DESCENDING);
        tok=optTok();
      }
 else {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_ASCENDING);
        if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
          tok=optTok();
        }
      }
      if (model.getOrderBy().size() >= MAX_ORDER_BY_COLUMNS) {
        throw err(""String_Node_Str"");
      }
    }
 while (tok != null && Chars.equals(tok,','));
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    ExprNode lo=expr();
    ExprNode hi=null;
    tok=optTok();
    if (tok != null && Chars.equals(tok,',')) {
      hi=expr();
    }
 else {
      lexer.unparse();
    }
    model.setLimit(lo,hi);
  }
 else {
    lexer.unparse();
  }
}","private void parseFromClause(QueryModel model,QueryModel masterModel) throws ParserException {
  CharSequence tok=expectTableNameOrSubQuery();
  if (Chars.equals(tok,'(')) {
    model.setNestedModel(parseSubQuery());
    expectTok(')');
    tok=optTok();
    if (tok != null && !tableAliasStop.contains(tok)) {
      model.setAlias(literal(tok));
      tok=optTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=optTok();
    }
  }
 else {
    parseSelectFrom(model,tok,masterModel);
    tok=optTok();
    if (tok != null && !tableAliasStop.contains(tok)) {
      model.setAlias(literal(tok));
      tok=optTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=optTok();
    }
    if (Chars.equalsNc(""String_Node_Str"",tok)) {
      parseLatestBy(model);
      tok=optTok();
    }
  }
  int joinType;
  while (tok != null && (joinType=joinStartSet.get(tok)) != -1) {
    model.addJoinModel(parseJoin(tok,joinType,masterModel));
    tok=optTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    model.setWhereClause(expr());
    tok=optTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
    model.setSampleBy(expectLiteral());
    tok=optTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
    do {
      ExprNode n=expectLiteral();
      tok=optTok();
      if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_DESCENDING);
        tok=optTok();
      }
 else {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_ASCENDING);
        if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
          tok=optTok();
        }
      }
      if (model.getOrderBy().size() >= MAX_ORDER_BY_COLUMNS) {
        throw err(""String_Node_Str"");
      }
    }
 while (tok != null && Chars.equals(tok,','));
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    ExprNode lo=expr();
    ExprNode hi=null;
    tok=optTok();
    if (tok != null && Chars.equals(tok,',')) {
      hi=expr();
    }
 else {
      lexer.unparse();
    }
    model.setLimit(lo,hi);
  }
 else {
    lexer.unparse();
  }
}",0.9716399506781752
30723,"private void toSink0(CharSink sink,boolean joinSlave){
  if (columns.size() > 0) {
    sink.put(getSelectModelTypeText()).put(' ');
    for (int i=0, n=columns.size(); i < n; i++) {
      if (i > 0) {
        sink.put(""String_Node_Str"");
      }
      QueryColumn column=columns.getQuick(i);
      String name=column.getName();
      String alias=column.getAlias();
      ExprNode ast=column.getAst();
      if (column instanceof AnalyticColumn || name == null) {
        ast.toSink(sink);
        if (alias != null) {
          aliasToSink(alias,sink);
        }
        if (name != null) {
          AnalyticColumn ac=(AnalyticColumn)column;
          sink.put(""String_Node_Str"");
          final ObjList<ExprNode> partitionBy=ac.getPartitionBy();
          if (partitionBy.size() > 0) {
            sink.put(""String_Node_Str"");
            for (int k=0, z=partitionBy.size(); k < z; k++) {
              if (k > 0) {
                sink.put(""String_Node_Str"");
              }
              partitionBy.getQuick(k).toSink(sink);
            }
          }
          final ObjList<ExprNode> orderBy=ac.getOrderBy();
          if (orderBy.size() > 0) {
            if (partitionBy.size() > 0) {
              sink.put(' ');
            }
            sink.put(""String_Node_Str"");
            for (int k=0, z=orderBy.size(); k < z; k++) {
              if (k > 0) {
                sink.put(""String_Node_Str"");
              }
              orderBy.getQuick(k).toSink(sink);
              if (ac.getOrderByDirection().getQuick(k) == 1) {
                sink.put(""String_Node_Str"");
              }
            }
          }
          sink.put(')');
        }
      }
 else {
        ast.toSink(sink);
        if (alias != null && (ast.type != ExprNode.LITERAL || !ast.token.equals(alias))) {
          aliasToSink(alias,sink);
        }
      }
    }
    sink.put(""String_Node_Str"");
  }
  if (tableName != null) {
    sink.put(tableName.token);
    if (alias != null) {
      aliasToSink(alias.token,sink);
    }
  }
 else {
    sink.put('(');
    nestedModel.toSink(sink);
    sink.put(')');
    if (alias != null) {
      aliasToSink(alias.token,sink);
    }
  }
  if (timestamp != null) {
    sink.put(""String_Node_Str"");
    timestamp.toSink(sink);
    sink.put(')');
  }
  if (latestBy != null) {
    sink.put(""String_Node_Str"");
    latestBy.toSink(sink);
  }
  if (orderedJoinModels.size() > 1) {
    for (int i=0, n=orderedJoinModels.size(); i < n; i++) {
      QueryModel model=joinModels.getQuick(orderedJoinModels.getQuick(i));
      if (model != this) {
switch (model.getJoinType()) {
case JOIN_OUTER:
          sink.put(""String_Node_Str"");
        break;
case JOIN_ASOF:
      sink.put(""String_Node_Str"");
    break;
case JOIN_CROSS:
  sink.put(""String_Node_Str"");
break;
default :
sink.put(""String_Node_Str"");
}
if (model.getWhereClause() != null) {
sink.put('(');
model.toSink0(sink,true);
sink.put(')');
if (model.getAlias() != null) {
aliasToSink(model.getAlias().token,sink);
}
}
 else {
model.toSink0(sink,true);
}
JoinContext jc=model.getContext();
if (jc != null && jc.aIndexes.size() > 0) {
sink.put(""String_Node_Str"");
for (int k=0, z=jc.aIndexes.size(); k < z; k++) {
if (k > 0) {
sink.put(""String_Node_Str"");
}
jc.aNodes.getQuick(k).toSink(sink);
sink.put(""String_Node_Str"");
jc.bNodes.getQuick(k).toSink(sink);
}
}
if (model.getPostJoinWhereClause() != null) {
sink.put(""String_Node_Str"");
model.getPostJoinWhereClause().toSink(sink);
}
}
}
}
if (whereClause != null) {
sink.put(""String_Node_Str"");
whereClause.toSink(sink);
}
if (constWhereClause != null) {
sink.put(""String_Node_Str"");
constWhereClause.toSink(sink);
}
if (!joinSlave && postJoinWhereClause != null) {
sink.put(""String_Node_Str"");
postJoinWhereClause.toSink(sink);
}
if (sampleBy != null) {
sink.put(""String_Node_Str"");
sampleBy.toSink(sink);
}
if (orderBy.size() > 0) {
sink.put(""String_Node_Str"");
for (int i=0, n=orderBy.size(); i < n; i++) {
if (i > 0) {
sink.put(""String_Node_Str"");
}
orderBy.getQuick(i).toSink(sink);
if (orderByDirection.getQuick(i) == 1) {
sink.put(""String_Node_Str"");
}
}
}
if (limitLo != null || limitHi != null) {
sink.put(""String_Node_Str"");
if (limitLo != null) {
limitLo.toSink(sink);
}
if (limitHi != null) {
sink.put(',');
limitHi.toSink(sink);
}
}
}","private void toSink0(CharSink sink,boolean joinSlave){
  if (columns.size() > 0) {
    sink.put(getSelectModelTypeText()).put(' ');
    for (int i=0, n=columns.size(); i < n; i++) {
      if (i > 0) {
        sink.put(""String_Node_Str"");
      }
      QueryColumn column=columns.getQuick(i);
      String name=column.getName();
      String alias=column.getAlias();
      ExprNode ast=column.getAst();
      if (column instanceof AnalyticColumn || name == null) {
        ast.toSink(sink);
        if (alias != null) {
          aliasToSink(alias,sink);
        }
        if (name != null) {
          AnalyticColumn ac=(AnalyticColumn)column;
          sink.put(""String_Node_Str"");
          final ObjList<ExprNode> partitionBy=ac.getPartitionBy();
          if (partitionBy.size() > 0) {
            sink.put(""String_Node_Str"");
            for (int k=0, z=partitionBy.size(); k < z; k++) {
              if (k > 0) {
                sink.put(""String_Node_Str"");
              }
              partitionBy.getQuick(k).toSink(sink);
            }
          }
          final ObjList<ExprNode> orderBy=ac.getOrderBy();
          if (orderBy.size() > 0) {
            if (partitionBy.size() > 0) {
              sink.put(' ');
            }
            sink.put(""String_Node_Str"");
            for (int k=0, z=orderBy.size(); k < z; k++) {
              if (k > 0) {
                sink.put(""String_Node_Str"");
              }
              orderBy.getQuick(k).toSink(sink);
              if (ac.getOrderByDirection().getQuick(k) == 1) {
                sink.put(""String_Node_Str"");
              }
            }
          }
          sink.put(')');
        }
      }
 else {
        ast.toSink(sink);
        if (alias != null && (ast.type != ExprNode.LITERAL || !ast.token.equals(alias))) {
          aliasToSink(alias,sink);
        }
      }
    }
    sink.put(""String_Node_Str"");
  }
  if (tableName != null) {
    sink.put(tableName.token);
    if (alias != null) {
      aliasToSink(alias.token,sink);
    }
  }
 else {
    sink.put('(');
    nestedModel.toSink(sink);
    sink.put(')');
    if (alias != null) {
      aliasToSink(alias.token,sink);
    }
  }
  if (timestamp != null) {
    sink.put(""String_Node_Str"");
    timestamp.toSink(sink);
    sink.put(')');
  }
  if (getLatestBy() != null) {
    sink.put(""String_Node_Str"");
    getLatestBy().toSink(sink);
  }
  if (orderedJoinModels.size() > 1) {
    for (int i=0, n=orderedJoinModels.size(); i < n; i++) {
      QueryModel model=joinModels.getQuick(orderedJoinModels.getQuick(i));
      if (model != this) {
switch (model.getJoinType()) {
case JOIN_OUTER:
          sink.put(""String_Node_Str"");
        break;
case JOIN_ASOF:
      sink.put(""String_Node_Str"");
    break;
case JOIN_CROSS:
  sink.put(""String_Node_Str"");
break;
default :
sink.put(""String_Node_Str"");
}
if (model.getWhereClause() != null) {
sink.put('(');
model.toSink0(sink,true);
sink.put(')');
if (model.getAlias() != null) {
aliasToSink(model.getAlias().token,sink);
}
 else if (model.getTableName() != null) {
aliasToSink(model.getTableName().token,sink);
}
}
 else {
model.toSink0(sink,true);
}
JoinContext jc=model.getContext();
if (jc != null && jc.aIndexes.size() > 0) {
sink.put(""String_Node_Str"");
for (int k=0, z=jc.aIndexes.size(); k < z; k++) {
if (k > 0) {
sink.put(""String_Node_Str"");
}
jc.aNodes.getQuick(k).toSink(sink);
sink.put(""String_Node_Str"");
jc.bNodes.getQuick(k).toSink(sink);
}
}
if (model.getPostJoinWhereClause() != null) {
sink.put(""String_Node_Str"");
model.getPostJoinWhereClause().toSink(sink);
}
}
}
}
if (whereClause != null) {
sink.put(""String_Node_Str"");
whereClause.toSink(sink);
}
if (constWhereClause != null) {
sink.put(""String_Node_Str"");
constWhereClause.toSink(sink);
}
if (!joinSlave && postJoinWhereClause != null) {
sink.put(""String_Node_Str"");
postJoinWhereClause.toSink(sink);
}
if (sampleBy != null) {
sink.put(""String_Node_Str"");
sampleBy.toSink(sink);
}
if (orderBy.size() > 0) {
sink.put(""String_Node_Str"");
for (int i=0, n=orderBy.size(); i < n; i++) {
if (i > 0) {
sink.put(""String_Node_Str"");
}
orderBy.getQuick(i).toSink(sink);
if (orderByDirection.getQuick(i) == 1) {
sink.put(""String_Node_Str"");
}
}
}
if (getLimitLo() != null || getLimitHi() != null) {
sink.put(""String_Node_Str"");
if (getLimitLo() != null) {
getLimitLo().toSink(sink);
}
if (getLimitHi() != null) {
sink.put(',');
getLimitHi().toSink(sink);
}
}
}",0.97582316371172
30724,"public void unlock(CharSequence tableName){
  readerPool.unlock(tableName);
  writerPool.unlock(tableName);
}","@Override public void unlock(CharSequence tableName){
  readerPool.unlock(tableName);
  writerPool.unlock(tableName);
}",0.956140350877193
30725,"@Override public int getStatus(CharSequence tableName){
  return TableUtils.exists(configuration.getFilesFacade(),path,configuration.getRoot(),tableName);
}","@Override public int getStatus(CharSequence tableName,int lo,int hi){
  return TableUtils.exists(configuration.getFilesFacade(),path,configuration.getRoot(),tableName,lo,hi);
}",0.9397590361445785
30726,"public boolean lock(CharSequence tableName){
  if (writerPool.lock(tableName)) {
    boolean locked=readerPool.lock(tableName);
    if (locked) {
      return true;
    }
    writerPool.unlock(tableName);
  }
  return false;
}","@Override public boolean lock(CharSequence tableName){
  if (writerPool.lock(tableName)) {
    boolean locked=readerPool.lock(tableName);
    if (locked) {
      return true;
    }
    writerPool.unlock(tableName);
  }
  return false;
}",0.9783549783549784
30727,"public static int exists(FilesFacade ff,Path path,CharSequence root,CharSequence name){
  path.of(root).concat(name).$();
  if (ff.exists(path)) {
    if (ff.exists(path.chopZ().concat(TXN_FILE_NAME).$())) {
      return TABLE_EXISTS;
    }
 else {
      return TABLE_RESERVED;
    }
  }
 else {
    return TABLE_DOES_NOT_EXIST;
  }
}","public static int exists(FilesFacade ff,Path path,CharSequence root,CharSequence name,int lo,int hi){
  path.of(root).concat(name,lo,hi).$();
  if (ff.exists(path)) {
    if (ff.exists(path.chopZ().concat(TXN_FILE_NAME).$())) {
      return TABLE_EXISTS;
    }
 else {
      return TABLE_RESERVED;
    }
  }
 else {
    return TABLE_DOES_NOT_EXIST;
  }
}",0.9709302325581396
30728,"public boolean lock(CharSequence name){
  checkClosed();
  Entry e=entries.get(name);
  if (e == null) {
    LOG.info().$('\'').$(name).$(""String_Node_Str"").$();
    return true;
  }
  long thread=Thread.currentThread().getId();
  if (Unsafe.cas(e,LOCK_OWNER,UNLOCKED,thread) || Unsafe.cas(e,LOCK_OWNER,thread,thread)) {
    do {
      for (int i=0; i < ENTRY_SIZE; i++) {
        if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
          closeReader(thread,e,i,PoolListener.EV_LOCK_CLOSE,PoolConstants.CR_NAME_LOCK);
        }
 else         if (Unsafe.cas(e.allocations,i,thread,thread)) {
          if (Unsafe.arrayGet(e.readers,i) != null) {
            e.lockOwner=-1L;
            return false;
          }
        }
 else {
          LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(':').$(i).$(""String_Node_Str"").$(Unsafe.arrayGet(e.allocations,i)).$(""String_Node_Str"").$(thread).$(']').$();
          e.lockOwner=-1L;
          return false;
        }
      }
      if (e.next == null) {
        if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,NEXT_OPEN,NEXT_LOCKED)) {
          break;
        }
 else {
          if (e.next == null) {
            LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index + 1).$(':').$(0).$(""String_Node_Str"").$(""String_Node_Str"").$(thread).$(']').$();
            e.lockOwner=-1L;
            return false;
          }
        }
      }
      e=e.next;
    }
 while (e != null);
  }
 else {
    LOG.error().$('\'').$(name).$(""String_Node_Str"").$(e.lockOwner).$(']').$();
    notifyListener(thread,name,PoolListener.EV_LOCK_BUSY,-1,-1);
    return false;
  }
  notifyListener(thread,name,PoolListener.EV_LOCK_SUCCESS,-1,-1);
  LOG.info().$('\'').$(name).$(""String_Node_Str"").$(thread).$(']').$();
  return true;
}","public boolean lock(CharSequence name){
  checkClosed();
  Entry e=entries.get(name);
  if (e == null) {
    e=new Entry(0,clock.getTicks());
    Entry other=entries.putIfAbsent(name,e);
    if (other != null) {
      e=other;
    }
  }
  long thread=Thread.currentThread().getId();
  if (Unsafe.cas(e,LOCK_OWNER,UNLOCKED,thread) || Unsafe.cas(e,LOCK_OWNER,thread,thread)) {
    do {
      for (int i=0; i < ENTRY_SIZE; i++) {
        if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
          closeReader(thread,e,i,PoolListener.EV_LOCK_CLOSE,PoolConstants.CR_NAME_LOCK);
        }
 else         if (Unsafe.cas(e.allocations,i,thread,thread)) {
          if (Unsafe.arrayGet(e.readers,i) != null) {
            e.lockOwner=-1L;
            return false;
          }
        }
 else {
          LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(':').$(i).$(""String_Node_Str"").$(Unsafe.arrayGet(e.allocations,i)).$(""String_Node_Str"").$(thread).$(']').$();
          e.lockOwner=-1L;
          return false;
        }
      }
      if (e.next == null) {
        if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,NEXT_OPEN,NEXT_LOCKED)) {
          break;
        }
 else {
          if (e.next == null) {
            LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index + 1).$(':').$(0).$(""String_Node_Str"").$(""String_Node_Str"").$(thread).$(']').$();
            e.lockOwner=-1L;
            return false;
          }
        }
      }
      e=e.next;
    }
 while (e != null);
  }
 else {
    LOG.error().$('\'').$(name).$(""String_Node_Str"").$(e.lockOwner).$(']').$();
    notifyListener(thread,name,PoolListener.EV_LOCK_BUSY,-1,-1);
    return false;
  }
  notifyListener(thread,name,PoolListener.EV_LOCK_SUCCESS,-1,-1);
  LOG.info().$('\'').$(name).$(""String_Node_Str"").$(thread).$(']').$();
  return true;
}",0.1570338058887677
30729,int getStatus(CharSequence tableName);,"default int getStatus(CharSequence tableName){
  return getStatus(tableName,0,tableName.length());
}",0.5507246376811594
30730,"public ParserException put(char c){
  message.put(c);
  return this;
}","public ParserException put(Sinkable sinkable){
  message.put(sinkable);
  return this;
}",0.8227848101265823
30731,"/** 
 * Rewrites order by clause to achieve simple column resolution for model parser. Order by must never reference column that doesn't exist in its own select list. <p> Because order by clause logically executes after ""select"" it must be able to reference results of arithmetic expression, aggregation function results, arithmetic with aggregation results and analytic functions. Somewhat contradictory to this order by must also be able to reference columns of table or sub-query that are not even in select clause.
 * @param model inbound model
 * @return outbound model
 * @throws ParserException when column names are ambiguos or not found at all.
 */
private QueryModel rewriteOrderBy(QueryModel model) throws ParserException {
  QueryModel result=model;
  QueryModel base=model;
  QueryModel baseParent=model;
  QueryModel wrapper=null;
  final int modelColumnCount=model.getColumns().size();
  boolean groupBy=false;
  while (base.getColumns().size() > 0) {
    baseParent=base;
    base=base.getNestedModel();
    groupBy=groupBy || baseParent.getSelectModelType() == QueryModel.SELECT_MODEL_GROUP_BY;
  }
  ObjList<ExprNode> orderByNodes=base.getOrderBy();
  int sz=orderByNodes.size();
  if (sz > 0) {
    boolean ascendColumns=true;
    for (int i=0; i < sz; i++) {
      final ExprNode orderBy=orderByNodes.getQuick(i);
      final String column=orderBy.token;
      final int dot=column.indexOf('.');
      if (dot > -1 || !model.getColumnNameTypeMap().contains(column)) {
        getIndexOfTableForColumn(base,column,dot,orderBy.position);
        if (ascendColumns && base != model) {
          final CharSequenceObjHashMap<String> map=baseParent.getColumnToAliasMap();
          int index=map.keyIndex(column);
          if (index > -1) {
            if (dot > -1) {
              index=map.keyIndex(column,dot + 1,column.length());
            }
 else {
              index=map.keyIndex(column);
            }
          }
          if (index < 0) {
            orderBy.token=map.valueAt(index);
          }
 else {
            if (groupBy) {
              ascendColumns=false;
            }
 else {
              if (baseParent.getSelectModelType() != QueryModel.SELECT_MODEL_CHOOSE) {
                QueryModel synthetic=queryModelPool.next();
                synthetic.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);
                for (int j=0, z=baseParent.getColumns().size(); j < z; j++) {
                  synthetic.addColumn(baseParent.getColumns().getQuick(j));
                }
                synthetic.setNestedModel(base);
                baseParent.setNestedModel(synthetic);
                baseParent=synthetic;
              }
              String alias=createColumnAlias(column,dot,baseParent.getColumnNameTypeMap());
              baseParent.addColumn(queryColumnPool.next().of(alias,0,exprNodePool.next().of(ExprNode.LITERAL,column,0,0)));
              if (model != baseParent) {
                QueryColumn col=queryColumnPool.next().of(alias,0,exprNodePool.next().of(ExprNode.LITERAL,alias,0,0));
                QueryModel m=model;
                do {
                  m.addColumn(col);
                  m=m.getNestedModel();
                }
 while (m != baseParent);
              }
              orderBy.token=alias;
              if (wrapper == null) {
                wrapper=queryModelPool.next();
                wrapper.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);
                for (int j=0; j < modelColumnCount; j++) {
                  String refAlias=model.getColumns().getQuick(j).getAlias();
                  wrapper.addColumn(queryColumnPool.next().of(refAlias,0,exprNodePool.next().of(ExprNode.LITERAL,refAlias,0,0)));
                }
                result=wrapper;
                wrapper.setNestedModel(model);
              }
            }
          }
        }
      }
      if (ascendColumns && base != model) {
        model.addOrderBy(orderBy,base.getOrderByDirection().getQuick(i));
      }
    }
    if (base != model) {
      base.clearOrderBy();
    }
  }
  QueryModel nested=base.getNestedModel();
  if (nested != null) {
    QueryModel rewritten=rewriteOrderBy(nested);
    if (rewritten != nested) {
      base.setNestedModel(rewritten);
    }
  }
  ObjList<QueryModel> joinModels=base.getJoinModels();
  for (int i=1, n=joinModels.size(); i < n; i++) {
    rewriteOrderBy(joinModels.getQuick(i));
  }
  return result;
}","/** 
 * Rewrites order by clause to achieve simple column resolution for model parser. Order by must never reference column that doesn't exist in its own select list. <p> Because order by clause logically executes after ""select"" it must be able to reference results of arithmetic expression, aggregation function results, arithmetic with aggregation results and analytic functions. Somewhat contradictory to this order by must also be able to reference columns of table or sub-query that are not even in select clause.
 * @param model inbound model
 * @return outbound model
 * @throws ParserException when column names are ambiguos or not found at all.
 */
private QueryModel rewriteOrderBy(QueryModel model) throws ParserException {
  QueryModel result=model;
  QueryModel base=model;
  QueryModel baseParent=model;
  QueryModel wrapper=null;
  final int modelColumnCount=model.getColumns().size();
  boolean groupBy=false;
  while (base.getColumns().size() > 0) {
    baseParent=base;
    base=base.getNestedModel();
    groupBy=groupBy || baseParent.getSelectModelType() == QueryModel.SELECT_MODEL_GROUP_BY;
  }
  ObjList<ExprNode> orderByNodes=base.getOrderBy();
  int sz=orderByNodes.size();
  if (sz > 0) {
    boolean ascendColumns=true;
    for (int i=0; i < sz; i++) {
      final ExprNode orderBy=orderByNodes.getQuick(i);
      final String column=orderBy.token;
      final int dot=column.indexOf('.');
      if (dot > -1 || !model.getColumnNameTypeMap().contains(column)) {
        getIndexOfTableForColumn(base,column,dot,orderBy.position);
        if (ascendColumns && base != model) {
          final CharSequenceObjHashMap<String> map=baseParent.getColumnToAliasMap();
          int index=map.keyIndex(column);
          if (index > -1) {
            if (dot > -1) {
              index=map.keyIndex(column,dot + 1,column.length());
            }
 else {
              index=map.keyIndex(column);
            }
          }
          if (index < 0) {
            orderBy.token=map.valueAt(index);
          }
 else {
            if (groupBy) {
              ascendColumns=false;
            }
 else {
              if (baseParent.getSelectModelType() != QueryModel.SELECT_MODEL_CHOOSE) {
                QueryModel synthetic=queryModelPool.next();
                synthetic.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);
                for (int j=0, z=baseParent.getColumns().size(); j < z; j++) {
                  synthetic.addColumn(baseParent.getColumns().getQuick(j));
                }
                synthetic.setNestedModel(base);
                baseParent.setNestedModel(synthetic);
                baseParent=synthetic;
              }
              String alias=createColumnAlias(column,dot,baseParent.getColumnNameTypeMap());
              baseParent.addColumn(queryColumnPool.next().of(alias,exprNodePool.next().of(ExprNode.LITERAL,column,0,0)));
              if (model != baseParent) {
                QueryColumn col=queryColumnPool.next().of(alias,exprNodePool.next().of(ExprNode.LITERAL,alias,0,0));
                QueryModel m=model;
                do {
                  m.addColumn(col);
                  m=m.getNestedModel();
                }
 while (m != baseParent);
              }
              orderBy.token=alias;
              if (wrapper == null) {
                wrapper=queryModelPool.next();
                wrapper.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);
                for (int j=0; j < modelColumnCount; j++) {
                  String refAlias=model.getColumns().getQuick(j).getAlias();
                  wrapper.addColumn(queryColumnPool.next().of(refAlias,exprNodePool.next().of(ExprNode.LITERAL,refAlias,0,0)));
                }
                result=wrapper;
                wrapper.setNestedModel(model);
              }
            }
          }
        }
      }
      if (ascendColumns && base != model) {
        model.addOrderBy(orderBy,base.getOrderByDirection().getQuick(i));
      }
    }
    if (base != model) {
      base.clearOrderBy();
    }
  }
  QueryModel nested=base.getNestedModel();
  if (nested != null) {
    QueryModel rewritten=rewriteOrderBy(nested);
    if (rewritten != nested) {
      base.setNestedModel(rewritten);
    }
  }
  ObjList<QueryModel> joinModels=base.getJoinModels();
  for (int i=1, n=joinModels.size(); i < n; i++) {
    rewriteOrderBy(joinModels.getQuick(i));
  }
  return result;
}",0.9993206521739132
30732,"private void parseSelectClause(QueryModel model) throws ParserException {
  CharSequence tok;
  while (true) {
    tok=tok(""String_Node_Str"");
    final ExprNode expr;
    final char last=tok.charAt(tok.length() - 1);
    if (last == '*') {
      expr=exprNodePool.next().of(ExprNode.LITERAL,Chars.toString(tok),0,lexer.position());
    }
 else     if (last == '.') {
      final int pos=lexer.position() + tok.length();
      columnNameAssembly.clear();
      columnNameAssembly.put(tok);
      tok=tok(""String_Node_Str"");
      if (Chars.equals(tok,'*')) {
        if (lexer.position() > pos) {
          throw ParserException.$(pos,""String_Node_Str"");
        }
        columnNameAssembly.put('*');
        expr=exprNodePool.next().of(ExprNode.LITERAL,columnNameAssembly.toString(),0,lexer.position());
      }
 else {
        throw ParserException.$(pos,""String_Node_Str"");
      }
    }
 else {
      lexer.unparse();
      expr=expr();
      if (expr == null) {
        throw ParserException.$(lexer.position(),""String_Node_Str"");
      }
    }
    String alias;
    int aliasPosition=lexer.position();
    tok=tok(""String_Node_Str"");
    if (!columnAliasStop.contains(tok)) {
      if (Chars.indexOf(tok,'.') != -1) {
        throw ParserException.$(aliasPosition,""String_Node_Str"");
      }
      alias=Chars.toString(tok);
      tok=tok(""String_Node_Str"");
    }
 else {
      alias=createColumnAlias(expr,model);
      aliasPosition=-1;
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      expectTok('(');
      AnalyticColumn col=analyticColumnPool.next().of(alias,aliasPosition,expr);
      tok=tok(""String_Node_Str"");
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(""String_Node_Str"");
        ObjList<ExprNode> partitionBy=col.getPartitionBy();
        do {
          partitionBy.add(expectLiteral());
          tok=tok(""String_Node_Str"");
        }
 while (Chars.equals(tok,','));
      }
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(""String_Node_Str"");
        do {
          ExprNode e=expectLiteral();
          tok=tok(""String_Node_Str"");
          if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_DESCENDING);
            tok=tok(""String_Node_Str"");
          }
 else {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_ASCENDING);
            if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
              tok=tok(""String_Node_Str"");
            }
          }
        }
 while (Chars.equals(tok,','));
      }
      expectTok(tok,lexer.position(),')');
      model.addColumn(col);
      tok=tok(""String_Node_Str"");
    }
 else {
      model.addColumn(queryColumnPool.next().of(alias,aliasPosition,expr));
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      break;
    }
    if (!Chars.equals(tok,',')) {
      throw err(""String_Node_Str"");
    }
  }
}","private void parseSelectClause(QueryModel model) throws ParserException {
  CharSequence tok;
  while (true) {
    tok=tok(""String_Node_Str"");
    final ExprNode expr;
    final char last=tok.charAt(tok.length() - 1);
    if (last == '*') {
      expr=exprNodePool.next().of(ExprNode.LITERAL,Chars.toString(tok),0,lexer.position());
    }
 else     if (last == '.') {
      final int pos=lexer.position() + tok.length();
      columnNameAssembly.clear();
      columnNameAssembly.put(tok);
      tok=tok(""String_Node_Str"");
      if (Chars.equals(tok,'*')) {
        if (lexer.position() > pos) {
          throw ParserException.$(pos,""String_Node_Str"");
        }
        columnNameAssembly.put('*');
        expr=exprNodePool.next().of(ExprNode.LITERAL,columnNameAssembly.toString(),0,lexer.position());
      }
 else {
        throw ParserException.$(pos,""String_Node_Str"");
      }
    }
 else {
      lexer.unparse();
      expr=expr();
      if (expr == null) {
        throw ParserException.$(lexer.position(),""String_Node_Str"");
      }
    }
    String alias;
    tok=tok(""String_Node_Str"");
    if (!columnAliasStop.contains(tok)) {
      if (Chars.indexOf(tok,'.') != -1) {
        throw ParserException.$(lexer.position(),""String_Node_Str"");
      }
      alias=Chars.toString(tok);
      tok=tok(""String_Node_Str"");
    }
 else {
      alias=createColumnAlias(expr,model);
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      expectTok('(');
      AnalyticColumn col=analyticColumnPool.next().of(alias,expr);
      tok=tok(""String_Node_Str"");
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(""String_Node_Str"");
        ObjList<ExprNode> partitionBy=col.getPartitionBy();
        do {
          partitionBy.add(expectLiteral());
          tok=tok(""String_Node_Str"");
        }
 while (Chars.equals(tok,','));
      }
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(""String_Node_Str"");
        do {
          ExprNode e=expectLiteral();
          tok=tok(""String_Node_Str"");
          if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_DESCENDING);
            tok=tok(""String_Node_Str"");
          }
 else {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_ASCENDING);
            if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
              tok=tok(""String_Node_Str"");
            }
          }
        }
 while (Chars.equals(tok,','));
      }
      expectTok(tok,lexer.position(),')');
      model.addColumn(col);
      tok=tok(""String_Node_Str"");
    }
 else {
      model.addColumn(queryColumnPool.next().of(alias,expr));
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      break;
    }
    if (!Chars.equals(tok,',')) {
      throw err(""String_Node_Str"");
    }
  }
}",0.9787830966158162
30733,"private QueryModel parseDml() throws ParserException {
  CharSequence tok;
  QueryModel model=queryModelPool.next();
  tok=tok(""String_Node_Str"");
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseWithClauses(model);
    tok=tok(""String_Node_Str"");
  }
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseSelectClause(model);
  }
 else {
    lexer.unparse();
    if (subQueryMode) {
      parseFromClause(model,model);
      return model;
    }
    model.addColumn(queryColumnPool.next().of(""String_Node_Str"",0,exprNodePool.next().of(ExprNode.LITERAL,""String_Node_Str"",0,0)));
  }
  QueryModel nestedModel=queryModelPool.next();
  parseFromClause(nestedModel,model);
  model.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);
  model.setNestedModel(nestedModel);
  return model;
}","private QueryModel parseDml() throws ParserException {
  CharSequence tok;
  QueryModel model=queryModelPool.next();
  tok=tok(""String_Node_Str"");
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseWithClauses(model);
    tok=tok(""String_Node_Str"");
  }
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseSelectClause(model);
  }
 else {
    lexer.unparse();
    if (subQueryMode) {
      parseFromClause(model,model);
      return model;
    }
    model.addColumn(queryColumnPool.next().of(""String_Node_Str"",exprNodePool.next().of(ExprNode.LITERAL,""String_Node_Str"",0,0)));
  }
  QueryModel nestedModel=queryModelPool.next();
  parseFromClause(nestedModel,model);
  model.setSelectModelType(QueryModel.SELECT_MODEL_CHOOSE);
  model.setNestedModel(nestedModel);
  return model;
}",0.9987277353689568
30734,"private ExprNode replaceLiteral(@Transient ExprNode node,QueryModel translatingModel,QueryModel innerModel,QueryModel validatingModel) throws ParserException {
  if (node != null && node.type == ExprNode.LITERAL) {
    final CharSequenceObjHashMap<String> map=translatingModel.getColumnToAliasMap();
    int index=map.keyIndex(node.token);
    if (index > -1) {
      String alias=createColumnAlias(node,translatingModel);
      QueryColumn column=queryColumnPool.next().of(alias,node.position,node);
      addColumnToTranslatingModel(column,translatingModel,validatingModel);
      if (innerModel != null) {
        innerModel.addColumn(column);
      }
      return exprNodePool.next().of(ExprNode.LITERAL,alias,0,node.position);
    }
    return exprNodePool.next().of(ExprNode.LITERAL,map.valueAt(index),0,node.position);
  }
  return node;
}","private ExprNode replaceLiteral(@Transient ExprNode node,QueryModel translatingModel,QueryModel innerModel,QueryModel validatingModel) throws ParserException {
  if (node != null && node.type == ExprNode.LITERAL) {
    final CharSequenceObjHashMap<String> map=translatingModel.getColumnToAliasMap();
    int index=map.keyIndex(node.token);
    if (index > -1) {
      String alias=createColumnAlias(node,translatingModel);
      QueryColumn column=queryColumnPool.next().of(alias,node);
      addColumnToTranslatingModel(column,translatingModel,validatingModel);
      if (innerModel != null) {
        innerModel.addColumn(column);
      }
      return exprNodePool.next().of(ExprNode.LITERAL,alias,0,node.position);
    }
    return exprNodePool.next().of(ExprNode.LITERAL,map.valueAt(index),0,node.position);
  }
  return node;
}",0.9916567342073898
30735,"private void createSelectColumn(String columnName,ExprNode columnAst,QueryModel validatingModel,QueryModel translatingModel,QueryModel innerModel,QueryModel groupByModel,QueryModel analyticModel,QueryModel outerModel) throws ParserException {
  final String alias=createColumnAlias(columnName,translatingModel);
  addColumnToTranslatingModel(queryColumnPool.next().of(alias,0,columnAst),translatingModel,validatingModel);
  final QueryColumn translatedColumn=queryColumnPool.next().of(alias,0,exprNodePool.next().of(ExprNode.LITERAL,alias,0,0));
  innerModel.addColumn(translatedColumn);
  groupByModel.addColumn(translatedColumn);
  analyticModel.addColumn(translatedColumn);
  outerModel.addColumn(translatedColumn);
}","private void createSelectColumn(String columnName,ExprNode columnAst,QueryModel validatingModel,QueryModel translatingModel,QueryModel innerModel,QueryModel groupByModel,QueryModel analyticModel,QueryModel outerModel) throws ParserException {
  final String alias=createColumnAlias(columnName,translatingModel);
  addColumnToTranslatingModel(queryColumnPool.next().of(alias,columnAst),translatingModel,validatingModel);
  final QueryColumn translatedColumn=queryColumnPool.next().of(alias,exprNodePool.next().of(ExprNode.LITERAL,alias,0,0));
  innerModel.addColumn(translatedColumn);
  groupByModel.addColumn(translatedColumn);
  analyticModel.addColumn(translatedColumn);
  outerModel.addColumn(translatedColumn);
}",0.9972144846796658
30736,"private ExprNode replaceIfAggregate(@Transient ExprNode node,QueryModel model){
  if (node != null && FunctionFactories.isAggregate(node.token)) {
    QueryColumn c=queryColumnPool.next().of(createColumnAlias(node,model),node.position,node);
    model.addColumn(c);
    return exprNodePool.next().of(ExprNode.LITERAL,c.getAlias(),0,0);
  }
  return node;
}","private ExprNode replaceIfAggregate(@Transient ExprNode node,QueryModel model){
  if (node != null && FunctionFactories.isAggregate(node.token)) {
    QueryColumn c=queryColumnPool.next().of(createColumnAlias(node,model),node);
    model.addColumn(c);
    return exprNodePool.next().of(ExprNode.LITERAL,c.getAlias(),0,0);
  }
  return node;
}",0.9799426934097422
30737,"public void enumerateTableColumns(QueryModel model) throws ParserException {
  final ObjList<QueryModel> jm=model.getJoinModels();
  if (model.getTableName() != null) {
    RecordMetadata m=model.getTableMetadata(engine);
    for (int i=0, k=m.getColumnCount(); i < k; i++) {
      model.addField(createColumnAlias(m.getColumnName(i),model));
    }
    ExprNode timestamp=model.getTimestamp();
    if (timestamp == null) {
      if (m.getTimestampIndex() != -1) {
        model.setTimestamp(exprNodePool.next().of(ExprNode.LITERAL,m.getColumnQuick(m.getTimestampIndex()).getName(),0,0));
      }
    }
 else {
      int index=m.getColumnIndexQuiet(timestamp.token);
      if (index == -1) {
        throw ParserException.invalidColumn(timestamp.position,timestamp.token);
      }
 else       if (m.getColumnQuick(index).getType() != ColumnType.TIMESTAMP) {
        throw ParserException.$(timestamp.position,""String_Node_Str"");
      }
    }
  }
 else {
    if (model.getNestedModel() != null) {
      enumerateTableColumns(model.getNestedModel());
      model.copyColumnsFrom(model.getNestedModel());
    }
  }
  for (int i=1, n=jm.size(); i < n; i++) {
    enumerateTableColumns(jm.getQuick(i));
  }
}","public void enumerateTableColumns(QueryModel model) throws ParserException {
  final ObjList<QueryModel> jm=model.getJoinModels();
  if (model.getTableName() != null) {
    RecordMetadata m=model.getTableMetadata(engine,csPool.next());
    for (int i=0, k=m.getColumnCount(); i < k; i++) {
      model.addField(createColumnAlias(m.getColumnName(i),model));
    }
    ExprNode timestamp=model.getTimestamp();
    if (timestamp == null) {
      if (m.getTimestampIndex() != -1) {
        model.setTimestamp(exprNodePool.next().of(ExprNode.LITERAL,m.getColumnQuick(m.getTimestampIndex()).getName(),0,0));
      }
    }
 else {
      int index=m.getColumnIndexQuiet(timestamp.token);
      if (index == -1) {
        throw ParserException.invalidColumn(timestamp.position,timestamp.token);
      }
 else       if (m.getColumnQuick(index).getType() != ColumnType.TIMESTAMP) {
        throw ParserException.$(timestamp.position,""String_Node_Str"");
      }
    }
  }
 else {
    if (model.getNestedModel() != null) {
      enumerateTableColumns(model.getNestedModel());
      model.copyColumnsFrom(model.getNestedModel());
    }
  }
  for (int i=1, n=jm.size(); i < n; i++) {
    enumerateTableColumns(jm.getQuick(i));
  }
}",0.9942148760330578
30738,"@Override public AnalyticColumn of(String alias,int aliasPosition,ExprNode ast){
  return (AnalyticColumn)super.of(alias,aliasPosition,ast);
}","@Override public AnalyticColumn of(String alias,ExprNode ast){
  return (AnalyticColumn)super.of(alias,ast);
}",0.873015873015873
30739,"public QueryColumn of(String alias,int aliasPosition,ExprNode ast){
  this.alias=alias;
  this.aliasPosition=aliasPosition;
  this.ast=ast;
  return this;
}","public QueryColumn of(String alias,ExprNode ast){
  this.alias=alias;
  this.ast=ast;
  return this;
}",0.7906976744186046
30740,"private void parseSelectColumns(QueryModel model) throws ParserException {
  CharSequence tok;
  while (true) {
    ExprNode expr=expr();
    if (expr == null) {
      throw ParserException.$(lexer.position(),""String_Node_Str"");
    }
    String alias;
    int aliasPosition=lexer.position();
    tok=tok();
    if (!columnAliasStop.contains(tok)) {
      alias=tok.toString();
      tok=tok();
    }
 else {
      alias=null;
      aliasPosition=-1;
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      expectTok('(');
      AnalyticColumn col=analyticColumnPool.next().of(alias,aliasPosition,expr);
      tok=tok();
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(tok(),""String_Node_Str"");
        ObjList<ExprNode> partitionBy=col.getPartitionBy();
        do {
          partitionBy.add(expectLiteral());
          tok=tok();
        }
 while (Chars.equals(tok,','));
      }
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(tok(),""String_Node_Str"");
        do {
          ExprNode e=expectLiteral();
          tok=tok();
          if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_DESCENDING);
            tok=tok();
          }
 else {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_ASCENDING);
            if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
              tok=tok();
            }
          }
        }
 while (Chars.equals(tok,','));
      }
      if (!Chars.equals(tok,')')) {
        throw err(""String_Node_Str"");
      }
      model.addColumn(col);
      tok=tok();
    }
 else {
      model.addColumn(queryColumnPool.next().of(alias,aliasPosition,expr));
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      break;
    }
    if (!Chars.equals(tok,',')) {
      throw err(""String_Node_Str"");
    }
  }
}","private void parseSelectColumns(QueryModel model) throws ParserException {
  CharSequence tok;
  while (true) {
    ExprNode expr=expr();
    if (expr == null) {
      throw ParserException.$(lexer.position(),""String_Node_Str"");
    }
    String alias;
    int aliasPosition=lexer.position();
    tok=tok();
    if (!columnAliasStop.contains(tok)) {
      alias=tok.toString();
      tok=tok();
    }
 else {
      alias=null;
      aliasPosition=-1;
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      expectTok('(');
      AnalyticColumn col=analyticColumnPool.next().of(alias,aliasPosition,expr);
      tok=tok();
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(""String_Node_Str"");
        ObjList<ExprNode> partitionBy=col.getPartitionBy();
        do {
          partitionBy.add(expectLiteral());
          tok=tok();
        }
 while (Chars.equals(tok,','));
      }
      if (Chars.equals(tok,""String_Node_Str"")) {
        expectTok(""String_Node_Str"");
        do {
          ExprNode e=expectLiteral();
          tok=tok();
          if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_DESCENDING);
            tok=tok();
          }
 else {
            col.addOrderBy(e,QueryModel.ORDER_DIRECTION_ASCENDING);
            if (Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
              tok=tok();
            }
          }
        }
 while (Chars.equals(tok,','));
      }
      if (!Chars.equals(tok,')')) {
        throw err(""String_Node_Str"");
      }
      model.addColumn(col);
      tok=tok();
    }
 else {
      model.addColumn(queryColumnPool.next().of(alias,aliasPosition,expr));
    }
    if (Chars.equals(tok,""String_Node_Str"")) {
      break;
    }
    if (!Chars.equals(tok,',')) {
      throw err(""String_Node_Str"");
    }
  }
}",0.9967444384156268
30741,"private ParsedModel parseCreateStatement() throws ParserException {
  CharSequence tok=tok();
  if (Chars.equals(tok,""String_Node_Str"")) {
    return parseCreateJournal();
  }
  throw err(""String_Node_Str"");
}","private ParsedModel parseCreateStatement() throws ParserException {
  CharSequence tok=tok();
  if (Chars.equals(tok,""String_Node_Str"")) {
    return parseCreateTable();
  }
  throw err(""String_Node_Str"");
}",0.9759615384615384
30742,"private QueryModel parseJoin(CharSequence tok,int joinType,QueryModel parent) throws ParserException {
  QueryModel joinModel=queryModelPool.next();
  joinModel.setJoinType(joinType);
  if (!Chars.equals(tok,""String_Node_Str"")) {
    expectTok(tok(),""String_Node_Str"");
  }
  tok=tok();
  if (Chars.equals(tok,'(')) {
    joinModel.setNestedModel(parseQuery(true));
    expectTok(')');
  }
 else {
    lexer.unparse();
    parseWithClauseOrJournalName(joinModel,parent);
  }
  tok=lexer.optionTok();
  if (tok != null && !journalAliasStop.contains(tok)) {
    lexer.unparse();
    joinModel.setAlias(expr());
  }
 else {
    lexer.unparse();
  }
  tok=lexer.optionTok();
  if (joinType == QueryModel.JOIN_CROSS && tok != null && Chars.equals(tok,""String_Node_Str"")) {
    throw ParserException.$(lexer.position(),""String_Node_Str"");
  }
switch (joinType) {
case QueryModel.JOIN_ASOF:
    if (tok == null || !Chars.equals(""String_Node_Str"",tok)) {
      lexer.unparse();
      break;
    }
case QueryModel.JOIN_INNER:
case QueryModel.JOIN_OUTER:
  expectTok(tok,""String_Node_Str"");
astBuilder.reset();
exprParser.parseExpr(lexer,astBuilder);
ExprNode expr;
switch (astBuilder.size()) {
case 0:
throw ParserException.$(lexer.position(),""String_Node_Str"");
case 1:
expr=astBuilder.poll();
if (expr.type == ExprNode.LITERAL) {
do {
joinModel.addJoinColumn(expr);
}
 while ((expr=astBuilder.poll()) != null);
}
 else {
joinModel.setJoinCriteria(expr);
}
break;
default :
while ((expr=astBuilder.poll()) != null) {
if (expr.type != ExprNode.LITERAL) {
throw ParserException.$(lexer.position(),""String_Node_Str"");
}
joinModel.addJoinColumn(expr);
}
break;
}
break;
default :
lexer.unparse();
}
return joinModel;
}","private QueryModel parseJoin(CharSequence tok,int joinType,QueryModel parent) throws ParserException {
  QueryModel joinModel=queryModelPool.next();
  joinModel.setJoinType(joinType);
  if (!Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
  }
  tok=tok();
  if (Chars.equals(tok,'(')) {
    joinModel.setNestedModel(parseQuery(true));
    expectTok(')');
  }
 else {
    lexer.unparse();
    parseWithClauseOrJournalName(joinModel,parent);
  }
  tok=lexer.optionTok();
  if (tok != null && !journalAliasStop.contains(tok)) {
    lexer.unparse();
    joinModel.setAlias(expr());
  }
 else {
    lexer.unparse();
  }
  tok=lexer.optionTok();
  if (joinType == QueryModel.JOIN_CROSS && tok != null && Chars.equals(tok,""String_Node_Str"")) {
    throw ParserException.$(lexer.position(),""String_Node_Str"");
  }
switch (joinType) {
case QueryModel.JOIN_ASOF:
    if (tok == null || !Chars.equals(""String_Node_Str"",tok)) {
      lexer.unparse();
      break;
    }
case QueryModel.JOIN_INNER:
case QueryModel.JOIN_OUTER:
  expectTok(tok,lexer.position(),""String_Node_Str"");
astBuilder.reset();
exprParser.parseExpr(lexer,astBuilder);
ExprNode expr;
switch (astBuilder.size()) {
case 0:
throw ParserException.$(lexer.position(),""String_Node_Str"");
case 1:
expr=astBuilder.poll();
if (expr.type == ExprNode.LITERAL) {
do {
joinModel.addJoinColumn(expr);
}
 while ((expr=astBuilder.poll()) != null);
}
 else {
joinModel.setJoinCriteria(expr);
}
break;
default :
while ((expr=astBuilder.poll()) != null) {
if (expr.type != ExprNode.LITERAL) {
throw ParserException.$(lexer.position(),""String_Node_Str"");
}
joinModel.addJoinColumn(expr);
}
break;
}
break;
default :
lexer.unparse();
}
return joinModel;
}",0.9932807478819748
30743,"private ParsedModel parseRenameStatement() throws ParserException {
  expectTok(tok(),""String_Node_Str"");
  RenameJournalModel model=renameJournalModelPool.next();
  ExprNode e=expectExpr();
  if (e.type != ExprNode.LITERAL && e.type != ExprNode.CONSTANT) {
    throw ParserException.$(e.position,""String_Node_Str"");
  }
  model.setFrom(e);
  expectTok(tok(),""String_Node_Str"");
  e=expectExpr();
  if (e.type != ExprNode.LITERAL && e.type != ExprNode.CONSTANT) {
    throw ParserException.$(e.position,""String_Node_Str"");
  }
  model.setTo(e);
  return model;
}","private ParsedModel parseRenameStatement() throws ParserException {
  expectTok(""String_Node_Str"");
  RenameJournalModel model=renameJournalModelPool.next();
  ExprNode e=expectExpr();
  if (e.type != ExprNode.LITERAL && e.type != ExprNode.CONSTANT) {
    throw ParserException.$(e.position,""String_Node_Str"");
  }
  model.setFrom(e);
  expectTok(""String_Node_Str"");
  e=expectExpr();
  if (e.type != ExprNode.LITERAL && e.type != ExprNode.CONSTANT) {
    throw ParserException.$(e.position,""String_Node_Str"");
  }
  model.setTo(e);
  return model;
}",0.9892086330935252
30744,"private ExprNode parseRecordHint(CharSequence tok) throws ParserException {
  if (Chars.equalsNc(""String_Node_Str"",tok)) {
    expectTok(tok(),""String_Node_Str"");
    ExprNode hint=expectExpr();
    if (hint.type != ExprNode.CONSTANT) {
      throw ParserException.$(hint.position,""String_Node_Str"");
    }
    return hint;
  }
  return null;
}","private ExprNode parseRecordHint(CharSequence tok) throws ParserException {
  if (Chars.equalsNc(""String_Node_Str"",tok)) {
    expectTok(""String_Node_Str"");
    ExprNode hint=expectExpr();
    if (hint.type != ExprNode.CONSTANT) {
      throw ParserException.$(hint.position,""String_Node_Str"");
    }
    return hint;
  }
  return null;
}",0.9912023460410556
30745,"private QueryModel parseQuery(boolean subQuery) throws ParserException {
  CharSequence tok;
  QueryModel model=queryModelPool.next();
  tok=tok();
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseWithClauses(model);
    tok=tok();
  }
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseSelectColumns(model);
    tok=tok();
  }
  if (Chars.equals(tok,'(')) {
    model.setNestedModel(parseQuery(true));
    expectTok(')');
    tok=lexer.optionTok();
    if (tok != null && !journalAliasStop.contains(tok)) {
      lexer.unparse();
      model.setAlias(literal());
      tok=lexer.optionTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=lexer.optionTok();
    }
  }
 else {
    lexer.unparse();
    parseWithClauseOrJournalName(model,model);
    tok=lexer.optionTok();
    if (tok != null && !journalAliasStop.contains(tok)) {
      lexer.unparse();
      model.setAlias(literal());
      tok=lexer.optionTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=lexer.optionTok();
    }
    if (Chars.equalsNc(""String_Node_Str"",tok)) {
      parseLatestBy(model);
      tok=lexer.optionTok();
    }
  }
  int joinType;
  while (tok != null && (joinType=joinStartSet.get(tok)) != -1) {
    model.addJoinModel(parseJoin(tok,joinType,model));
    tok=lexer.optionTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    model.setWhereClause(expr());
    tok=lexer.optionTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(tok(),""String_Node_Str"");
    model.setSampleBy(expectLiteral());
    tok=lexer.optionTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(tok(),""String_Node_Str"");
    do {
      tok=tok();
      if (Chars.equals(tok,')')) {
        throw err(""String_Node_Str"");
      }
      lexer.unparse();
      ExprNode n=expectLiteral();
      tok=lexer.optionTok();
      if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_DESCENDING);
        tok=lexer.optionTok();
      }
 else {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_ASCENDING);
        if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
          tok=lexer.optionTok();
        }
      }
      if (model.getOrderBy().size() >= MAX_ORDER_BY_COLUMNS) {
        throw err(""String_Node_Str"");
      }
    }
 while (tok != null && Chars.equals(tok,','));
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    ExprNode lo=expr();
    ExprNode hi=null;
    tok=lexer.optionTok();
    if (tok != null && Chars.equals(tok,',')) {
      hi=expr();
      tok=lexer.optionTok();
    }
    model.setLimit(lo,hi);
  }
  if (subQuery) {
    lexer.unparse();
  }
 else   if (tok != null) {
    throw ParserException.position(lexer.position()).put(""String_Node_Str"").put(tok);
  }
  resolveJoinColumns(model);
  return model;
}","private QueryModel parseQuery(boolean subQuery) throws ParserException {
  CharSequence tok;
  QueryModel model=queryModelPool.next();
  tok=tok();
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseWithClauses(model);
    tok=tok();
  }
  if (Chars.equals(tok,""String_Node_Str"")) {
    parseSelectColumns(model);
    tok=tok();
  }
  if (Chars.equals(tok,'(')) {
    model.setNestedModel(parseQuery(true));
    expectTok(')');
    tok=lexer.optionTok();
    if (tok != null && !journalAliasStop.contains(tok)) {
      lexer.unparse();
      model.setAlias(literal());
      tok=lexer.optionTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=lexer.optionTok();
    }
  }
 else {
    lexer.unparse();
    parseWithClauseOrJournalName(model,model);
    tok=lexer.optionTok();
    if (tok != null && !journalAliasStop.contains(tok)) {
      lexer.unparse();
      model.setAlias(literal());
      tok=lexer.optionTok();
    }
    ExprNode timestamp=parseTimestamp(tok);
    if (timestamp != null) {
      model.setTimestamp(timestamp);
      tok=lexer.optionTok();
    }
    if (Chars.equalsNc(""String_Node_Str"",tok)) {
      parseLatestBy(model);
      tok=lexer.optionTok();
    }
  }
  int joinType;
  while (tok != null && (joinType=joinStartSet.get(tok)) != -1) {
    model.addJoinModel(parseJoin(tok,joinType,model));
    tok=lexer.optionTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    model.setWhereClause(expr());
    tok=lexer.optionTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
    model.setSampleBy(expectLiteral());
    tok=lexer.optionTok();
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    expectTok(""String_Node_Str"");
    do {
      tok=tok();
      if (Chars.equals(tok,')')) {
        throw err(""String_Node_Str"");
      }
      lexer.unparse();
      ExprNode n=expectLiteral();
      tok=lexer.optionTok();
      if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_DESCENDING);
        tok=lexer.optionTok();
      }
 else {
        model.addOrderBy(n,QueryModel.ORDER_DIRECTION_ASCENDING);
        if (tok != null && Chars.equalsIgnoreCase(tok,""String_Node_Str"")) {
          tok=lexer.optionTok();
        }
      }
      if (model.getOrderBy().size() >= MAX_ORDER_BY_COLUMNS) {
        throw err(""String_Node_Str"");
      }
    }
 while (tok != null && Chars.equals(tok,','));
  }
  if (tok != null && Chars.equals(tok,""String_Node_Str"")) {
    ExprNode lo=expr();
    ExprNode hi=null;
    tok=lexer.optionTok();
    if (tok != null && Chars.equals(tok,',')) {
      hi=expr();
      tok=lexer.optionTok();
    }
    model.setLimit(lo,hi);
  }
  if (subQuery) {
    lexer.unparse();
  }
 else   if (tok != null) {
    throw ParserException.position(lexer.position()).put(""String_Node_Str"").put(tok);
  }
  resolveJoinColumns(model);
  return model;
}",0.953243332235759
30746,"private void parseWithClauses(QueryModel model) throws ParserException {
  do {
    ExprNode name=expectLiteral();
    if (model.getWithClause(name.token) != null) {
      throw ParserException.$(name.position,""String_Node_Str"");
    }
    expectTok(tok(),""String_Node_Str"");
    expectTok('(');
    int lo, hi;
    lo=lexer.position();
    QueryModel m=parseQuery(true);
    hi=lexer.position();
    WithClauseModel wcm=withClauseModelPool.next();
    wcm.of(lo + 1,hi,m);
    expectTok(')');
    model.addWithClause(name.token,wcm);
    CharSequence tok=lexer.optionTok();
    if (tok == null || !Chars.equals(tok,',')) {
      lexer.unparse();
      break;
    }
  }
 while (true);
}","private void parseWithClauses(QueryModel model) throws ParserException {
  do {
    ExprNode name=expectLiteral();
    if (model.getWithClause(name.token) != null) {
      throw ParserException.$(name.position,""String_Node_Str"");
    }
    expectTok(""String_Node_Str"");
    expectTok('(');
    int lo, hi;
    lo=lexer.position();
    QueryModel m=parseQuery(true);
    hi=lexer.position();
    WithClauseModel wcm=withClauseModelPool.next();
    wcm.of(lo + 1,hi,m);
    expectTok(')');
    model.addWithClause(name.token,wcm);
    CharSequence tok=lexer.optionTok();
    if (tok == null || !Chars.equals(tok,',')) {
      lexer.unparse();
      break;
    }
  }
 while (true);
}",0.9956076134699854
30747,"private void parseLatestBy(QueryModel model) throws ParserException {
  expectTok(tok(),""String_Node_Str"");
  model.setLatestBy(expr());
}","private void parseLatestBy(QueryModel model) throws ParserException {
  expectTok(""String_Node_Str"");
  model.setLatestBy(expr());
}",0.9777777777777776
30748,"private void clear(){
  queryModelPool.clear();
  queryColumnPool.clear();
  exprNodePool.clear();
  analyticColumnPool.clear();
  createJournalModelPool.clear();
  columnIndexModelPool.clear();
  columnCastModelPool.clear();
  renameJournalModelPool.clear();
  withClauseModelPool.clear();
}","private void clear(){
  queryModelPool.clear();
  queryColumnPool.clear();
  exprNodePool.clear();
  analyticColumnPool.clear();
  createJournalModelPool.clear();
  columnCastModelPool.clear();
  renameJournalModelPool.clear();
  withClauseModelPool.clear();
}",0.9420289855072465
30749,"private CharSequence parseIndexDefinition(GenericIndexedBuilder builder) throws ParserException {
  CharSequence tok=tok();
  if (isFieldTerm(tok)) {
    return tok;
  }
  expectTok(tok,""String_Node_Str"");
  builder.index();
  if (isFieldTerm(tok=tok())) {
    return tok;
  }
  expectTok(tok,""String_Node_Str"");
  try {
    builder.buckets(Numbers.parseInt(tok()));
  }
 catch (  NumericException e) {
    throw err(""String_Node_Str"");
  }
  return null;
}","private CharSequence parseIndexDefinition(CreateTableModel model) throws ParserException {
  CharSequence tok=tok();
  if (isFieldTerm(tok)) {
    return tok;
  }
  expectTok(tok,lexer.position(),""String_Node_Str"");
  if (isFieldTerm(tok=tok())) {
    model.setIndexFlags(true,1024);
    return tok;
  }
  expectTok(tok,lexer.position(),""String_Node_Str"");
  expectTok(""String_Node_Str"");
  try {
    model.setIndexFlags(true,Numbers.parseInt(tok()));
  }
 catch (  NumericException e) {
    throw err(""String_Node_Str"");
  }
  return null;
}",0.3983983983983984
30750,"private ExprNode parsePartitionBy(CharSequence tok) throws ParserException {
  if (Chars.equalsNc(""String_Node_Str"",tok)) {
    expectTok(tok(),""String_Node_Str"");
    return expectLiteral();
  }
  return null;
}","private ExprNode parsePartitionBy(CharSequence tok) throws ParserException {
  if (Chars.equalsNc(""String_Node_Str"",tok)) {
    expectTok(""String_Node_Str"");
    return expectLiteral();
  }
  return null;
}",0.985645933014354
30751,"private void reloadColumnAt(Path path,ObjList<ReadOnlyColumn> columns,LongList columnTops,int columnIndex,int columnBase,long partitionRowCount){
  int plen=path.length();
  try {
    String name=metadata.getColumnName(columnIndex);
    ReadOnlyMemory mem1=(ReadOnlyMemory)columns.getQuick(getPrimaryColumnIndex(columnBase,columnIndex));
    ReadOnlyMemory mem2=(ReadOnlyMemory)columns.getQuick(getSecondaryColumnIndex(columnBase,columnIndex));
    if (ff.exists(TableUtils.dFile(path.trimTo(plen),name))) {
      int type=metadata.getColumnQuick(columnIndex).getType();
      mem1.of(ff,path,ff.getMapPageSize(),0);
      long columnTop=TableUtils.readColumnTop(ff,path.trimTo(plen),name,plen,tempMem8b);
switch (type) {
case ColumnType.BINARY:
case ColumnType.STRING:
        mem2.of(ff,TableUtils.iFile(path.trimTo(plen),name),ff.getMapPageSize(),0);
      columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
    columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),mem2);
  growColumn(mem1,mem2,type,partitionRowCount - columnTop);
break;
default :
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
growColumn(mem1,null,type,partitionRowCount - columnTop);
break;
}
columnTops.setQuick(columnBase / 2 + columnIndex,columnTop);
}
 else {
Misc.free(mem1);
Misc.free(mem2);
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
}
}
  finally {
path.trimTo(plen);
}
}","private void reloadColumnAt(Path path,ObjList<ReadOnlyColumn> columns,LongList columnTops,int columnIndex,int columnBase,long partitionRowCount){
  int plen=path.length();
  try {
    String name=metadata.getColumnName(columnIndex);
    ReadOnlyMemory mem1=(ReadOnlyMemory)columns.getQuick(getPrimaryColumnIndex(columnBase,columnIndex));
    ReadOnlyMemory mem2=(ReadOnlyMemory)columns.getQuick(getSecondaryColumnIndex(columnBase,columnIndex));
    if (ff.exists(TableUtils.dFile(path.trimTo(plen),name))) {
      int type=metadata.getColumnQuick(columnIndex).getType();
      mem1.of(ff,path,ff.getMapPageSize(),0);
      long columnTop=TableUtils.readColumnTop(ff,path.trimTo(plen),name,plen,tempMem8b);
switch (type) {
case ColumnType.BINARY:
case ColumnType.STRING:
        mem2.of(ff,TableUtils.iFile(path.trimTo(plen),name),ff.getMapPageSize(),0);
      growColumn(mem1,mem2,type,partitionRowCount - columnTop);
    break;
default :
  growColumn(mem1,null,type,partitionRowCount - columnTop);
break;
}
columnTops.setQuick(columnBase / 2 + columnIndex,columnTop);
}
 else {
Misc.free(mem1);
Misc.free(mem2);
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
}
}
  finally {
path.trimTo(plen);
}
}",0.8782365290412876
30752,"/** 
 * Closed column files. Similarly to   {@link #closeColumnForRemove(CharSequence)} closed reader column files beforecolumn can be removed. This method takes column index usually resolved from column name by #TableReaderMetadata. Bounds checking is performed via assertion.
 * @param columnIndex column index
 */
public void closeColumnForRemove(int columnIndex){
}","/** 
 * Closes column files. This method should be used before call to TableWriter.removeColumn() on Windows OS.
 * @param columnName name of column to be closed.
 * @throws NoSuchColumnException when column is not found.
 */
public void closeColumnForRemove(CharSequence columnName){
  closeColumnForRemove(metadata.getColumnIndex(columnName));
}",0.2513966480446927
30753,"private void doReloadStruct(){
  long pTransitionIndex=metadata.createTransitionIndex();
  try {
    metadata.applyTransitionIndex(pTransitionIndex);
    final int columnCount=Unsafe.getUnsafe().getInt(pTransitionIndex + 4);
    int columnCountBits=getColumnBits(columnCount);
    if (columnCountBits > this.columnCountBits) {
      createNewColumnList(columnCount,pTransitionIndex,columnCountBits);
    }
 else {
      reshuffleExistingColumnList(columnCount,pTransitionIndex);
    }
    applyTransitionIndexToSymbolMapReaders(pTransitionIndex);
    this.columnCount=columnCount;
  }
  finally {
    TableReaderMetadata.freeTransitionIndex(pTransitionIndex);
  }
}","private void doReloadStruct(){
  long pTransitionIndex=metadata.createTransitionIndex();
  try {
    metadata.applyTransitionIndex(pTransitionIndex);
    final int columnCount=Unsafe.getUnsafe().getInt(pTransitionIndex + 4);
    int columnCountBits=getColumnBits(columnCount);
    if (columnCountBits > this.columnCountBits) {
      createNewColumnList(columnCount,pTransitionIndex,columnCountBits);
    }
 else {
      reshuffleColumns(columnCount,pTransitionIndex);
    }
    reshuffleSymbolMapReaders(pTransitionIndex);
    this.columnCount=columnCount;
  }
  finally {
    TableReaderMetadata.freeTransitionIndex(pTransitionIndex);
  }
}",0.9571209800918836
30754,"private SymbolMapReader copyOrRenewSymbolMapReader(SymbolMapReader reader,int columnIndex){
  if (reader != null && reader.isDeleted()) {
    reader=newSymbolMapReaderInstance(columnIndex,reader);
  }
  reader=symbolMapReaders.getAndSetQuick(columnIndex,reader);
  return reader;
}","private SymbolMapReader copyOrRenewSymbolMapReader(SymbolMapReader reader,int columnIndex){
  if (reader != null && reader.isDeleted()) {
    reader=reloadSymbolMapReader(columnIndex,reader);
  }
  return symbolMapReaders.getAndSetQuick(columnIndex,reader);
}",0.8629629629629629
30755,"@Override public BitmapIndexCursor getCursor(int key,long maxValue){
  if (key >= keyCount) {
    updateKeyCount();
  }
  if (key == 0 && unindexedNullCount > 0) {
    nullCursor.nullCount=unindexedNullCount + 1;
    nullCursor.of(key,maxValue);
    return nullCursor;
  }
  if (key < keyCount) {
    cursor.of(key,maxValue);
    return cursor;
  }
  return BitmapIndexEmptyCursor.INSTANCE;
}","@Override public BitmapIndexCursor getCursor(int key,long maxValue){
  if (key >= keyCount) {
    updateKeyCount();
  }
  if (key == 0 && unindexedNullCount > 0) {
    nullCursor.nullCount=unindexedNullCount;
    nullCursor.of(key,maxValue);
    return nullCursor;
  }
  if (key < keyCount) {
    cursor.of(key,maxValue);
    return cursor;
  }
  return BitmapIndexEmptyCursor.INSTANCE;
}",0.9948717948717948
30756,"private void testReplaceUnindexedColWithIndexed(int partitionBy,long increment,int expectedPartitionMin,boolean testRestricted) throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    final int M=1000;
    final int N=100;
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",partitionBy).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4).col(""String_Node_Str"",ColumnType.INT).timestamp().col(""String_Node_Str"",ColumnType.SYMBOL)){
      CairoTestUtils.create(model);
    }
     final Rnd rnd=new Rnd();
    final String symbols[]=new String[N];
    for (int i=0; i < N; i++) {
      symbols[i]=rnd.nextChars(8).toString();
    }
    long timestamp=0;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < M; i++) {
        TableWriter.Row row=writer.newRow(timestamp+=increment);
        row.putStr(0,rnd.nextChars(20));
        row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
        row.putInt(2,rnd.nextInt());
        row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        final TableReaderDataFrameCursor cursor=new TableReaderDataFrameCursor();
        final TableReaderRecord record=new TableReaderRecord(reader);
        Assert.assertTrue(reader.getPartitionCount() > expectedPartitionMin);
        cursor.of(reader);
        assertSymbolFoundInIndex(cursor,record,1,M);
        cursor.toTop();
        assertNoIndex(cursor);
        if (testRestricted || configuration.getFilesFacade().isRestrictedFileSystem()) {
          reader.closeColumnForRemove(""String_Node_Str"");
        }
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL,N,true,true,8);
        for (int i=0; i < M; i++) {
          TableWriter.Row row=writer.newRow(timestamp+=increment);
          row.putStr(0,rnd.nextChars(20));
          row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
          row.putInt(2,rnd.nextInt());
          row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
          row.append();
        }
        writer.commit();
        Assert.assertTrue(reader.reload());
        cursor.reload();
        assertSymbolFoundInIndex(cursor,record,1,M * 2);
        cursor.toTop();
        assertSymbolFoundInIndex(cursor,record,4,M * 2);
      }
     }
   }
);
}","private void testReplaceUnindexedColWithIndexed(int partitionBy,long increment,int expectedPartitionMin,boolean testRestricted) throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    final int M=1000;
    final int N=100;
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",partitionBy).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4).col(""String_Node_Str"",ColumnType.INT).timestamp().col(""String_Node_Str"",ColumnType.SYMBOL)){
      CairoTestUtils.create(model);
    }
     final Rnd rnd=new Rnd();
    final String symbols[]=new String[N];
    for (int i=0; i < N; i++) {
      symbols[i]=rnd.nextChars(8).toString();
    }
    long timestamp=0;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < M; i++) {
        TableWriter.Row row=writer.newRow(timestamp+=increment);
        row.putStr(0,rnd.nextChars(20));
        row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
        row.putInt(2,rnd.nextInt());
        row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        final TableReaderDataFrameCursor cursor=new TableReaderDataFrameCursor();
        final TableReaderRecord record=new TableReaderRecord(reader);
        Assert.assertTrue(reader.getPartitionCount() > expectedPartitionMin);
        cursor.of(reader);
        assertSymbolFoundInIndex(cursor,record,1,M);
        cursor.toTop();
        assertNoIndex(cursor);
        if (testRestricted || configuration.getFilesFacade().isRestrictedFileSystem()) {
          reader.closeColumnForRemove(""String_Node_Str"");
        }
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL,N,true,true,8);
        for (int i=0; i < M; i++) {
          TableWriter.Row row=writer.newRow(timestamp+=increment);
          row.putStr(0,rnd.nextChars(20));
          row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
          row.putInt(2,rnd.nextInt());
          row.putSym(4,rnd.nextPositiveInt() % 16 == 0 ? null : symbols[rnd.nextPositiveInt() % N]);
          row.append();
        }
        writer.commit();
        Assert.assertTrue(reader.reload());
        cursor.reload();
        assertSymbolFoundInIndex(cursor,record,1,M * 2);
        cursor.toTop();
        assertSymbolFoundInIndex(cursor,record,4,M * 2);
        cursor.toTop();
        assertIndexRowsMatchSymbol(cursor,record,4);
      }
     }
   }
);
}",0.9767258382642998
30757,"private boolean readTxn(){
  while (true) {
    long txn=txMem.getLong(TableUtils.TX_OFFSET_TXN);
    if (txn == this.txn) {
      return false;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableUtils.TX_OFFSET_FIXED_ROW_COUNT);
    long maxTimestamp=txMem.getLong(TableUtils.TX_OFFSET_MAX_TIMESTAMP);
    long structVersion=txMem.getLong(TableUtils.TX_OFFSET_STRUCT_VERSION);
    this.symbolCountSnapshot.clear();
    int symbolMapCount=txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT);
    if (symbolMapCount > 0) {
      txMem.grow(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + symbolMapCount * 4);
      for (int i=0; i < symbolMapCount; i++) {
        symbolCountSnapshot.add(txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + i * 4));
      }
    }
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN_CHECK)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.rowCount=fixedRowCount + transientRowCount;
      this.maxTimestamp=maxTimestamp;
      this.structVersion=structVersion;
      break;
    }
    LockSupport.parkNanos(1);
  }
  return true;
}","private boolean readTxn(){
  int count=0;
  while (true) {
    long txn=txMem.getLong(TableUtils.TX_OFFSET_TXN);
    if (txn == this.txn) {
      return false;
    }
    Unsafe.getUnsafe().loadFence();
    long checkTxn;
    while ((checkTxn=txMem.getLong(TableUtils.TX_OFFSET_TXN_CHECK)) < txn) {
      LockSupport.parkNanos(1);
    }
    if (txn == checkTxn) {
      Unsafe.getUnsafe().loadFence();
      final long transientRowCount=txMem.getLong(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
      final long fixedRowCount=txMem.getLong(TableUtils.TX_OFFSET_FIXED_ROW_COUNT);
      final long maxTimestamp=txMem.getLong(TableUtils.TX_OFFSET_MAX_TIMESTAMP);
      final long structVersion=txMem.getLong(TableUtils.TX_OFFSET_STRUCT_VERSION);
      this.symbolCountSnapshot.clear();
      int symbolMapCount=txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT);
      if (symbolMapCount > 0) {
        txMem.grow(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + symbolMapCount * 4);
        for (int i=0; i < symbolMapCount; i++) {
          symbolCountSnapshot.add(txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + i * 4));
        }
      }
      Unsafe.getUnsafe().loadFence();
      if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN)) {
        this.txn=txn;
        this.transientRowCount=transientRowCount;
        this.rowCount=fixedRowCount + transientRowCount;
        this.maxTimestamp=maxTimestamp;
        this.structVersion=structVersion;
        LOG.info().$(""String_Node_Str"").$(txn).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(fixedRowCount).$(""String_Node_Str"").$(maxTimestamp).$(""String_Node_Str"").$(count).$(']').$();
        break;
      }
      count++;
      LockSupport.parkNanos(1);
    }
  }
  return true;
}",0.8198468198468198
30758,"private long openPartition0(int partitionIndex){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    if (ff.exists(path)) {
      path.chopZ();
      final long partitionSize=partitionIndex == partitionCount - 1 ? transientRowCount : readPartitionSize(ff,path,tempMem8b);
      LOG.info().$(""String_Node_Str"").utf8(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(partitionIndex).$(""String_Node_Str"").$(partitionCount).$();
      if (partitionSize > 0) {
        openPartitionColumns(path,getColumnBase(partitionIndex),partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
        if (maxTimestamp != Numbers.LONG_NaN) {
          if (reloadMethod == FIRST_TIME_PARTITIONED_RELOAD_METHOD) {
            reloadMethod=PARTITIONED_RELOAD_METHOD;
          }
 else           if (reloadMethod == FIRST_TIME_NON_PARTITIONED_RELOAD_METHOD) {
            reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
          }
        }
      }
      return partitionSize;
    }
    return -1;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition0(int partitionIndex){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    if (ff.exists(path)) {
      path.chopZ();
      final long partitionSize=partitionIndex == partitionCount - 1 ? transientRowCount : readPartitionSize(ff,path,tempMem8b);
      LOG.info().$(""String_Node_Str"").utf8(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(partitionIndex).$(""String_Node_Str"").$(partitionCount).$(']').$();
      if (partitionSize > 0) {
        openPartitionColumns(path,getColumnBase(partitionIndex),partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
        if (maxTimestamp != Numbers.LONG_NaN) {
          if (reloadMethod == FIRST_TIME_PARTITIONED_RELOAD_METHOD) {
            reloadMethod=PARTITIONED_RELOAD_METHOD;
          }
 else           if (reloadMethod == FIRST_TIME_NON_PARTITIONED_RELOAD_METHOD) {
            reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
          }
        }
      }
      return partitionSize;
    }
    return -1;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.996933858957512
30759,"public static void resetTxn(VirtualMemory txMem,int symbolMapCount){
  txMem.jumpTo(TX_OFFSET_TXN);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  txMem.skip(8);
  txMem.putInt(symbolMapCount);
  for (int i=0; i < symbolMapCount; i++) {
    txMem.putLong(0);
  }
  long offset=txMem.getAppendOffset();
  txMem.jumpTo(TX_OFFSET_TXN_CHECK);
  Unsafe.getUnsafe().storeFence();
  txMem.putLong(0);
  txMem.jumpTo(offset);
}","public static void resetTxn(VirtualMemory txMem,int symbolMapCount){
  txMem.jumpTo(TX_OFFSET_TXN);
  txMem.putLong(INITIAL_TXN);
  Unsafe.getUnsafe().storeFence();
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  txMem.skip(8);
  txMem.putInt(symbolMapCount);
  for (int i=0; i < symbolMapCount; i++) {
    txMem.putLong(0);
  }
  long offset=txMem.getAppendOffset();
  txMem.jumpTo(TX_OFFSET_TXN_CHECK);
  Unsafe.getUnsafe().storeFence();
  txMem.putLong(INITIAL_TXN);
  txMem.jumpTo(offset);
}",0.9774436090225564
30760,"private void cacheWriter(CacheEntry entry,CachedCharSequence tableName){
  try {
    entry.writer=pool.get(tableName);
    this.tableName=tableName.getCacheAddress();
    createState(entry);
  }
 catch (  CairoException ex) {
    LOG.error().$((Sinkable)ex).$();
    switchModeToSkipLine();
  }
}","private void cacheWriter(CacheEntry entry,CachedCharSequence tableName){
  try {
    entry.writer=pool.get(tableName);
    this.tableName=tableName.getCacheAddress();
    createState(entry);
    LOG.info().$(""String_Node_Str"").$(tableName).$(']').$();
  }
 catch (  CairoException ex) {
    LOG.error().$((Sinkable)ex).$();
    switchModeToSkipLine();
  }
}",0.7993874425727412
30761,"@Override public void close(){
  if (keyMem != null) {
    if (keyMem.isOpen() && keyCount > -1) {
      keyMem.jumpTo(keyMemSize());
    }
    Misc.free(keyMem);
  }
  if (valueMem != null) {
    if (valueMem.isOpen()) {
      valueMem.jumpTo(valueMemSize);
    }
    Misc.free(valueMem);
  }
}","@Override public void close(){
  if (keyMem != null) {
    if (keyMem.isOpen() && keyCount > -1) {
      keyMem.jumpTo(keyMemSize());
    }
    Misc.free(keyMem);
  }
  if (valueMem != null) {
    if (valueMem.isOpen() && valueMemSize > -1) {
      valueMem.jumpTo(valueMemSize);
    }
    Misc.free(valueMem);
  }
}",0.9656301145662848
30762,"public CairoError(Throwable cause){
  super(cause);
}","public CairoError(String message){
  super(message);
}",0.7102803738317757
30763,"@Override public void of(CairoConfiguration configuration,Path path,CharSequence name,AppendMemory mem1,AppendMemory mem2,long columnTop){
  this.columnTop=columnTop;
  this.writer.of(configuration,path,name);
  this.mem.of(mem1);
}","@Override public void of(CairoConfiguration configuration,Path path,CharSequence name,AppendMemory mem1,AppendMemory mem2,long columnTop){
  this.columnTop=columnTop;
  try {
    this.writer.of(configuration,path,name);
    this.mem.of(mem1);
  }
 catch (  CairoException e) {
    this.close();
    throw e;
  }
}",0.8513761467889909
30764,"public SymbolMapWriter(CairoConfiguration configuration,Path path,CharSequence name,int symbolCount){
  final int plen=path.length();
  try {
    final FilesFacade ff=configuration.getFilesFacade();
    final long mapPageSize=ff.getMapPageSize();
    offsetFileName(path.trimTo(plen),name);
    if (!ff.exists(path)) {
      LOG.error().$(path).$(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    long len=ff.length(path);
    if (len < HEADER_SIZE) {
      LOG.error().$(path).$(""String_Node_Str"").$(len).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.offsetMem=new ReadWriteMemory(ff,path,mapPageSize);
    final int symbolCapacity=offsetMem.getInt(0);
    final boolean useCache=offsetMem.getBool(4);
    long jumpTarget=keyToOffset(symbolCount);
    this.offsetMem.jumpTo(jumpTarget);
    this.indexWriter=new BitmapIndexWriter(configuration,path.trimTo(plen),name);
    this.charMem=new ReadWriteMemory(ff,charFileName(path.trimTo(plen),name),mapPageSize);
    jumpCharMemToSymbolCount(symbolCount);
    this.maxHash=Numbers.ceilPow2(symbolCapacity / 2) - 1;
    if (useCache) {
      this.cache=new CharSequenceIntHashMap(symbolCapacity);
    }
 else {
      this.cache=null;
    }
    LOG.info().$(""String_Node_Str"").$(path.trimTo(plen).concat(name).$()).$(""String_Node_Str"").$(this.offsetMem.getFd()).$(""String_Node_Str"").$(cache != null).$(""String_Node_Str"").$(symbolCapacity).$(']').$();
    if (jumpTarget < len) {
      rollback(symbolCount);
    }
  }
 catch (  CairoException e) {
    close();
    throw e;
  }
 finally {
    path.trimTo(plen);
  }
}","public SymbolMapWriter(CairoConfiguration configuration,Path path,CharSequence name,int symbolCount){
  final int plen=path.length();
  try {
    final FilesFacade ff=configuration.getFilesFacade();
    final long mapPageSize=ff.getMapPageSize();
    offsetFileName(path.trimTo(plen),name);
    if (!ff.exists(path)) {
      LOG.error().$(path).$(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    long len=ff.length(path);
    if (len < HEADER_SIZE) {
      LOG.error().$(path).$(""String_Node_Str"").$(len).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.offsetMem=new ReadWriteMemory(ff,path,mapPageSize);
    final int symbolCapacity=offsetMem.getInt(0);
    final boolean useCache=offsetMem.getBool(4);
    this.offsetMem.jumpTo(keyToOffset(symbolCount));
    this.indexWriter=new BitmapIndexWriter(configuration,path.trimTo(plen),name);
    this.charMem=new ReadWriteMemory(ff,charFileName(path.trimTo(plen),name),mapPageSize);
    jumpCharMemToSymbolCount(symbolCount);
    this.maxHash=Numbers.ceilPow2(symbolCapacity / 2) - 1;
    if (useCache) {
      this.cache=new CharSequenceIntHashMap(symbolCapacity);
    }
 else {
      this.cache=null;
    }
    LOG.info().$(""String_Node_Str"").$(path.trimTo(plen).concat(name).$()).$(""String_Node_Str"").$(this.offsetMem.getFd()).$(""String_Node_Str"").$(cache != null).$(""String_Node_Str"").$(symbolCapacity).$(']').$();
  }
 catch (  CairoException e) {
    close();
    throw e;
  }
 finally {
    path.trimTo(plen);
  }
}",0.9603442975714724
30765,"public static long lock(FilesFacade ff,Path path){
  long fd=ff.openRW(path.put(""String_Node_Str"").$());
  if (fd == -1) {
    LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(ff.errno()).$(']').$();
    return -1L;
  }
  if (ff.lock(fd) != 0) {
    LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(ff.errno()).$(""String_Node_Str"").$(fd).$(']').$();
    ff.close(fd);
    return -1L;
  }
  return fd;
}","public static long lock(FilesFacade ff,Path path){
  long fd=ff.openRW(path);
  if (fd == -1) {
    LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(ff.errno()).$(']').$();
    return -1L;
  }
  if (ff.lock(fd) != 0) {
    LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(ff.errno()).$(""String_Node_Str"").$(fd).$(']').$();
    ff.close(fd);
    return -1L;
  }
  return fd;
}",0.967741935483871
30766,"private long openPartition0(int partitionIndex){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    if (ff.exists(path)) {
      if (reloadMethod == FIRST_TIME_PARTITIONED_RELOAD_METHOD) {
        reloadMethod=PARTITIONED_RELOAD_METHOD;
      }
 else       if (reloadMethod == FIRST_TIME_NON_PARTITIONED_RELOAD_METHOD) {
        reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
      }
      path.chopZ();
      final long partitionSize=partitionIndex == partitionCount - 1 ? transientRowCount : readPartitionSize(ff,path,tempMem8b);
      LOG.info().$(""String_Node_Str"").utf8(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(partitionIndex).$(""String_Node_Str"").$(partitionCount).$();
      if (partitionSize > 0) {
        openPartitionColumns(path,getColumnBase(partitionIndex),partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
      }
      return partitionSize;
    }
    return -1;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition0(int partitionIndex){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    if (ff.exists(path)) {
      path.chopZ();
      final long partitionSize=partitionIndex == partitionCount - 1 ? transientRowCount : readPartitionSize(ff,path,tempMem8b);
      LOG.info().$(""String_Node_Str"").utf8(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(partitionIndex).$(""String_Node_Str"").$(partitionCount).$();
      if (partitionSize > 0) {
        openPartitionColumns(path,getColumnBase(partitionIndex),partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
        if (reloadMethod == FIRST_TIME_PARTITIONED_RELOAD_METHOD) {
          reloadMethod=PARTITIONED_RELOAD_METHOD;
        }
 else         if (reloadMethod == FIRST_TIME_NON_PARTITIONED_RELOAD_METHOD && maxTimestamp != Numbers.LONG_NaN) {
          reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
        }
      }
      return partitionSize;
    }
    return -1;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.4629629629629629
30767,"private void removeColumnFiles(CharSequence name,RemoveFileLambda removeLambda){
  try {
    ff.iterateDir(path.$(),(file,type) -> {
      nativeLPSZ.of(file);
      if (type == Files.DT_DIR && !IGNORED_FILES.contains(nativeLPSZ)) {
        path.trimTo(rootLen);
        path.concat(nativeLPSZ);
        int plen=path.length();
        removeLambda.remove(ff,TableUtils.dFile(path,name));
        removeLambda.remove(ff,TableUtils.iFile(path.trimTo(plen),name));
        removeLambda.remove(ff,TableUtils.topFile(path.trimTo(plen),name));
      }
    }
);
  }
  finally {
    path.trimTo(rootLen);
  }
}","private void removeColumnFiles(CharSequence columnName,int columnType,RemoveFileLambda removeLambda){
  try {
    ff.iterateDir(path.$(),(file,type) -> {
      nativeLPSZ.of(file);
      if (type == Files.DT_DIR && !IGNORED_FILES.contains(nativeLPSZ)) {
        path.trimTo(rootLen);
        path.concat(nativeLPSZ);
        int plen=path.length();
        removeLambda.remove(ff,TableUtils.dFile(path,columnName));
        removeLambda.remove(ff,TableUtils.iFile(path.trimTo(plen),columnName));
        removeLambda.remove(ff,TableUtils.topFile(path.trimTo(plen),columnName));
      }
    }
);
    if (columnType == ColumnType.SYMBOL) {
      removeLambda.remove(ff,SymbolMapWriter.offsetFileName(path.trimTo(rootLen),columnName));
      removeLambda.remove(ff,SymbolMapWriter.charFileName(path.trimTo(rootLen),columnName));
      removeLambda.remove(ff,BitmapIndexUtils.keyFileName(path.trimTo(rootLen),columnName));
      removeLambda.remove(ff,BitmapIndexUtils.valueFileName(path.trimTo(rootLen),columnName));
    }
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.7149700598802395
30768,"/** 
 * Adds new column to table, which can be either empty or can have data already. When existing columns already have data this function will create "".top"" file in addition to column files. "".top"" file contains size of partition at the moment of column creation. It must be used to accurately position inside new column when either appending or reading. <p> <b>Failures</b> Adding new column can fail in many different situations. None of the failures affect integrity of data that is already in the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError. Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be either with disk or memory or both. <p> Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to add columns again. <p> <b>Transactions</b> <p> Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may still have committed transaction.
 * @param name            of column either ASCII or UTF8 encoded.
 * @param symbolCapacity  when column type is SYMBOL this parameter specifies approximate capacity for symbol map.It should be equal to number of unique symbol values stored in the table and getting this value badly wrong will cause performance degradation.
 * @param symbolCacheFlag when set to true, symbol values will be cached on Java heap.
 * @param type            {@link ColumnType}
 */
public void addColumn(CharSequence name,int type,int symbolCapacity,boolean symbolCacheFlag){
  if (getColumnIndexQuiet(metaMem,name,columnCount) != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
  commit();
  if (type == ColumnType.SYMBOL) {
    removeSymbolMapFilesLoud(name);
  }
  removeColumnFiles(name,REMOVE_OR_EXCEPTION);
  this.metaSwapIndex=addColumnToMeta(name,type);
  metaMem.close();
  renameMetaToMetaPrev(name);
  writeRestoreMetaTodo(name);
  renameSwapMetaToMeta(name);
  if (type == ColumnType.SYMBOL) {
    try {
      createSymbolMapWriter(name,symbolCapacity,symbolCacheFlag);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE,name,e);
    }
  }
  configureColumn(type);
  columnCount++;
  columnTops.extendAndSet(columnCount - 1,transientRowCount);
  if (transientRowCount > 0 || partitionBy == PartitionBy.NONE) {
    try {
      openNewColumnFiles(name);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE,name,e);
    }
  }
  try {
    openMetaFile();
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
  bumpStructureVersion();
  metadata.addColumn(name,type);
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
}","/** 
 * Adds new column to table, which can be either empty or can have data already. When existing columns already have data this function will create "".top"" file in addition to column files. "".top"" file contains size of partition at the moment of column creation. It must be used to accurately position inside new column when either appending or reading. <p> <b>Failures</b> Adding new column can fail in many different situations. None of the failures affect integrity of data that is already in the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError. Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be either with disk or memory or both. <p> Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to add columns again. <p> <b>Transactions</b> <p> Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may still have committed transaction.
 * @param name            of column either ASCII or UTF8 encoded.
 * @param symbolCapacity  when column type is SYMBOL this parameter specifies approximate capacity for symbol map.It should be equal to number of unique symbol values stored in the table and getting this value badly wrong will cause performance degradation.
 * @param symbolCacheFlag when set to true, symbol values will be cached on Java heap.
 * @param type            {@link ColumnType}
 */
public void addColumn(CharSequence name,int type,int symbolCapacity,boolean symbolCacheFlag){
  if (getColumnIndexQuiet(metaMem,name,columnCount) != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
  commit();
  removeColumnFiles(name,type,REMOVE_OR_EXCEPTION);
  this.metaSwapIndex=addColumnToMeta(name,type);
  metaMem.close();
  renameMetaToMetaPrev(name);
  writeRestoreMetaTodo(name);
  renameSwapMetaToMeta(name);
  if (type == ColumnType.SYMBOL) {
    try {
      createSymbolMapWriter(name,symbolCapacity,symbolCacheFlag);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE,name,e);
    }
  }
  configureColumn(type);
  columnCount++;
  columnTops.extendAndSet(columnCount - 1,transientRowCount);
  if (transientRowCount > 0 || partitionBy == PartitionBy.NONE) {
    try {
      openNewColumnFiles(name);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE,name,e);
    }
  }
  try {
    openMetaFile();
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
  bumpStructureVersion();
  metadata.addColumn(name,type);
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
}",0.9832719973235196
30769,"public BitmapIndexBackwardReader(CairoConfiguration configuration,Path path,CharSequence name){
  final int plen=path.length();
  final long pageSize=configuration.getFilesFacade().getMapPageSize();
  this.spinLockTimeoutUs=configuration.getSpinLockTimeoutUs();
  try {
    this.keyMem=new ReadOnlyMemory(configuration.getFilesFacade(),BitmapIndexUtils.keyFileName(path,name),pageSize,0);
    this.keyMem.grow(configuration.getFilesFacade().length(this.keyMem.getFd()));
    this.clock=configuration.getClock();
    long keyMemSize=this.keyMem.size();
    if (keyMemSize < BitmapIndexUtils.KEY_FILE_RESERVED) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getByte(BitmapIndexUtils.KEY_RESERVED_OFFSET_SIGNATURE) != BitmapIndexUtils.SIGNATURE) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    int blockValueCountMod;
    int keyCount;
    long timestamp=clock.getTicks();
    while (true) {
      long seq=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE);
      Unsafe.getUnsafe().loadFence();
      blockValueCountMod=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_BLOCK_VALUE_COUNT) - 1;
      keyCount=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
      Unsafe.getUnsafe().loadFence();
      if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) == seq) {
        break;
      }
      if (clock.getTicks() - timestamp > spinLockTimeoutUs) {
        LOG.error().$(""String_Node_Str"").$(spinLockTimeoutUs).utf8(""String_Node_Str"").$();
        throw CairoException.instance(0).put(""String_Node_Str"");
      }
    }
    this.blockValueCountMod=blockValueCountMod;
    this.blockCapacity=(blockValueCountMod + 1) * 8 + BitmapIndexUtils.VALUE_BLOCK_FILE_RESERVED;
    this.keyCount=keyCount;
    this.valueMem=new ReadOnlyMemory(configuration.getFilesFacade(),BitmapIndexUtils.valueFileName(path.trimTo(plen),name),pageSize,0);
    this.valueMem.grow(configuration.getFilesFacade().length(this.valueMem.getFd()));
  }
 catch (  CairoException e) {
    close();
    throw e;
  }
 finally {
    path.trimTo(plen);
  }
}","public BitmapIndexBackwardReader(CairoConfiguration configuration,Path path,CharSequence name){
  of(configuration,path,name);
}",0.1055694098088113
30770,"public SymbolMapReaderImpl(CairoConfiguration configuration,Path path,CharSequence name,int symbolCount){
  this.ff=configuration.getFilesFacade();
  this.symbolCount=symbolCount;
  this.maxOffset=SymbolMapWriter.keyToOffset(symbolCount - 1);
  final int plen=path.length();
  try {
    final long mapPageSize=configuration.getFilesFacade().getMapPageSize();
    offsetFileName(path.trimTo(plen),name);
    if (!ff.exists(path)) {
      LOG.error().$(path).$(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    long len=ff.length(path);
    if (len < SymbolMapWriter.HEADER_SIZE) {
      LOG.error().$(path).$(""String_Node_Str"").$(len).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.offsetMem=new ReadOnlyMemory(ff,path,mapPageSize,keyToOffset(symbolCount));
    final int symbolCapacity=offsetMem.getInt(0);
    final boolean useCache=offsetMem.getBool(4);
    this.offsetMem.grow(maxOffset);
    this.indexReader=new BitmapIndexBackwardReader(configuration,path.trimTo(plen),name);
    this.charMem=new ReadOnlyMemory(ff,charFileName(path.trimTo(plen),name),mapPageSize,0);
    growCharMemToSymbolCount(symbolCount);
    this.maxHash=Numbers.ceilPow2(symbolCapacity / 2) - 1;
    if (useCache) {
      this.cache=new ObjList<>(symbolCapacity);
      this.cache.setPos(symbolCapacity);
    }
 else {
      this.cache=null;
    }
    LOG.info().$(""String_Node_Str"").$(path.trimTo(plen).concat(name).$()).$(""String_Node_Str"").$(this.offsetMem.getFd()).$(""String_Node_Str"").$(symbolCapacity).$(']').$();
  }
 catch (  CairoException e) {
    close();
    throw e;
  }
 finally {
    path.trimTo(plen);
  }
}","public SymbolMapReaderImpl(CairoConfiguration configuration,Path path,CharSequence name,int symbolCount){
  of(configuration,path,name,symbolCount);
}",0.1610305958132045
30771,"@Override public void close(){
  Misc.free(indexReader);
  Misc.free(charMem);
  if (this.offsetMem != null) {
    long fd=this.offsetMem.getFd();
    Misc.free(offsetMem);
    LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
  }
}","@Override public void close(){
  Misc.free(indexReader);
  Misc.free(charMem);
  this.cache.clear();
  if (this.offsetMem != null) {
    long fd=this.offsetMem.getFd();
    Misc.free(offsetMem);
    LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
  }
}",0.9547325102880658
30772,"@Override public CharSequence value(int key){
  if (key > -1 && key < symbolCount) {
    if (cache != null) {
      return cachedValue(key);
    }
    return uncachedValue(key);
  }
  return null;
}","@Override public CharSequence value(int key){
  if (key > -1 && key < symbolCount) {
    if (cached) {
      return cachedValue(key);
    }
    return uncachedValue(key);
  }
  return null;
}",0.9768637532133676
30773,"boolean isCached(){
  return cache != null;
}","boolean isCached(){
  return cached;
}",0.891566265060241
30774,"public void applyTransitionIndexToSymbolMapReaders(long pTransitionIndex){
  final int columnCount=Unsafe.getUnsafe().getInt(pTransitionIndex + 4);
  final long index=pTransitionIndex + 8;
  final long stateAddress=index + columnCount * 8;
  if (columnCount > this.columnCount) {
    symbolMapReaders.setPos(columnCount);
  }
  Unsafe.getUnsafe().setMemory(stateAddress,columnCount,(byte)0);
  for (int i=0; i < columnCount; i++) {
    if (Unsafe.getUnsafe().getByte(stateAddress + i) == -1) {
      continue;
    }
    Unsafe.getUnsafe().putByte(stateAddress + i,(byte)-1);
    int copyFrom=Unsafe.getUnsafe().getInt(index + i * 8);
    if (copyFrom == i + 1) {
      continue;
    }
    SymbolMapReader tmp;
    if (copyFrom > 0) {
      tmp=copyOrRenewSymbolMapReader(symbolMapReaders.getAndSetQuick(copyFrom - 1,null),i);
      int copyTo=Unsafe.getUnsafe().getInt(index + i * 8 + 4);
      while (copyTo > 0) {
        if (Unsafe.getUnsafe().getByte(stateAddress + copyTo - 1) == -1) {
          break;
        }
        Unsafe.getUnsafe().putByte(stateAddress + copyTo - 1,(byte)-1);
        tmp=copyOrRenewSymbolMapReader(tmp,copyTo - 1);
        copyTo=Unsafe.getUnsafe().getInt(index + (copyTo - 1) * 8 + 4);
      }
      Misc.free(tmp);
    }
 else {
      Misc.free(symbolMapReaders.getAndSetQuick(i,newSymbolMapReaderInstance(i)));
    }
  }
  if (columnCount < this.columnCount) {
    for (int i=columnCount; i < this.columnCount; i++) {
      Misc.free(symbolMapReaders.getQuick(i));
    }
    symbolMapReaders.setPos(columnCount);
  }
}","public void applyTransitionIndexToSymbolMapReaders(long pTransitionIndex){
  final int columnCount=Unsafe.getUnsafe().getInt(pTransitionIndex + 4);
  final long index=pTransitionIndex + 8;
  final long stateAddress=index + columnCount * 8;
  if (columnCount > this.columnCount) {
    symbolMapReaders.setPos(columnCount);
  }
  Unsafe.getUnsafe().setMemory(stateAddress,columnCount,(byte)0);
  for (int i=0; i < columnCount; i++) {
    if (Unsafe.getUnsafe().getByte(stateAddress + i) == -1) {
      continue;
    }
    Unsafe.getUnsafe().putByte(stateAddress + i,(byte)-1);
    int copyFrom=Unsafe.getUnsafe().getInt(index + i * 8);
    if (copyFrom == i + 1) {
      SymbolMapReader reader=symbolMapReaders.getQuick(copyFrom);
      if (reader != null && reader.isDeleted()) {
        newSymbolMapReaderInstance(copyFrom,reader);
      }
      continue;
    }
    SymbolMapReader tmp;
    if (copyFrom > 0) {
      tmp=copyOrRenewSymbolMapReader(symbolMapReaders.getAndSetQuick(copyFrom - 1,null),i);
      int copyTo=Unsafe.getUnsafe().getInt(index + i * 8 + 4);
      while (copyTo > 0) {
        if (Unsafe.getUnsafe().getByte(stateAddress + copyTo - 1) == -1) {
          break;
        }
        Unsafe.getUnsafe().putByte(stateAddress + copyTo - 1,(byte)-1);
        tmp=copyOrRenewSymbolMapReader(tmp,copyTo - 1);
        copyTo=Unsafe.getUnsafe().getInt(index + (copyTo - 1) * 8 + 4);
      }
      Misc.free(tmp);
    }
 else {
      Misc.free(symbolMapReaders.getAndSetQuick(i,newSymbolMapReaderInstance(i,null)));
    }
  }
  if (columnCount < this.columnCount) {
    for (int i=columnCount; i < this.columnCount; i++) {
      Misc.free(symbolMapReaders.getQuick(i));
    }
    symbolMapReaders.setPos(columnCount);
  }
}",0.9153986609860012
30775,"private void reshuffleExistingColumnList(int columnCount,long pTransitionIndex){
  final long pIndexBase=pTransitionIndex + 8;
  final long pState=pIndexBase + columnCount * 8;
  for (int partitionIndex=0; partitionIndex < partitionCount; partitionIndex++) {
    int base=getColumnBase(partitionIndex);
    try {
      Path path=partitionPathGenerator.generate(this,partitionIndex);
      final long partitionRowCount=partitionRowCounts.getQuick(partitionIndex);
      Unsafe.getUnsafe().setMemory(pState,columnCount,(byte)0);
      for (int i=0; i < columnCount; i++) {
        if (isEntryToBeProcessed(pState,i)) {
          final int copyFrom=Unsafe.getUnsafe().getInt(pIndexBase + i * 8) - 1;
          if (copyFrom == i) {
            ReadOnlyColumn col=columns.getQuick(getPrimaryColumnIndex(base,i));
            if (col == null || col instanceof NullColumn || ff.exists(col.getFd())) {
              continue;
            }
            reloadColumnAt(path,columns,columnTops,i,base,partitionRowCount);
            continue;
          }
          if (copyFrom > -1) {
            fetchColumnsFrom(this.columns,this.columnTops,base,copyFrom);
            copyColumnsTo(this.columns,this.columnTops,base,i,partitionRowCount);
            int copyTo=Unsafe.getUnsafe().getInt(pIndexBase + i * 8 + 4) - 1;
            while (copyTo > -1 && isEntryToBeProcessed(pState,copyTo)) {
              copyColumnsTo(this.columns,this.columnTops,base,copyTo,partitionRowCount);
              copyTo=Unsafe.getUnsafe().getInt(pIndexBase + (copyTo - 1) * 8 + 4);
            }
            Misc.free(tempCopyStruct.mem1);
            Misc.free(tempCopyStruct.mem2);
          }
 else {
            createColumnInstanceAt(path,this.columns,this.columnTops,i,base,partitionRowCount);
          }
        }
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
}","private void reshuffleExistingColumnList(int columnCount,long pTransitionIndex){
  final long pIndexBase=pTransitionIndex + 8;
  final long pState=pIndexBase + columnCount * 8;
  for (int partitionIndex=0; partitionIndex < partitionCount; partitionIndex++) {
    int base=getColumnBase(partitionIndex);
    try {
      Path path=partitionPathGenerator.generate(this,partitionIndex);
      final long partitionRowCount=partitionRowCounts.getQuick(partitionIndex);
      Unsafe.getUnsafe().setMemory(pState,columnCount,(byte)0);
      for (int i=0; i < columnCount; i++) {
        if (isEntryToBeProcessed(pState,i)) {
          final int copyFrom=Unsafe.getUnsafe().getInt(pIndexBase + i * 8) - 1;
          if (copyFrom == i) {
            ReadOnlyColumn col=columns.getQuick(getPrimaryColumnIndex(base,i));
            if (col instanceof ReadOnlyMemory && !ff.exists(col.getFd())) {
              reloadColumnAt(path,columns,columnTops,i,base,partitionRowCount);
            }
            continue;
          }
          if (copyFrom > -1) {
            fetchColumnsFrom(this.columns,this.columnTops,base,copyFrom);
            copyColumnsTo(this.columns,this.columnTops,base,i,partitionRowCount);
            int copyTo=Unsafe.getUnsafe().getInt(pIndexBase + i * 8 + 4) - 1;
            while (copyTo > -1 && isEntryToBeProcessed(pState,copyTo)) {
              copyColumnsTo(this.columns,this.columnTops,base,copyTo,partitionRowCount);
              copyTo=Unsafe.getUnsafe().getInt(pIndexBase + (copyTo - 1) * 8 + 4);
            }
            Misc.free(tempCopyStruct.mem1);
            Misc.free(tempCopyStruct.mem2);
          }
 else {
            createColumnInstanceAt(path,this.columns,this.columnTops,i,base,partitionRowCount);
          }
        }
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
}",0.9403147042864894
30776,"private SymbolMapReader copyOrRenewSymbolMapReader(SymbolMapReader reader,int columnIndex){
  if (reader != null && reader.isDeleted()) {
    Misc.free(reader);
    reader=newSymbolMapReaderInstance(columnIndex);
  }
  reader=symbolMapReaders.getAndSetQuick(columnIndex,reader);
  return reader;
}","private SymbolMapReader copyOrRenewSymbolMapReader(SymbolMapReader reader,int columnIndex){
  if (reader != null && reader.isDeleted()) {
    reader=newSymbolMapReaderInstance(columnIndex,reader);
  }
  reader=symbolMapReaders.getAndSetQuick(columnIndex,reader);
  return reader;
}",0.9480968858131488
30777,"private SymbolMapReader newSymbolMapReaderInstance(int columnIndex){
  RecordColumnMetadata m=metadata.getColumnQuick(columnIndex);
  if (m.getType() == ColumnType.SYMBOL) {
    return new SymbolMapReaderImpl(configuration,path,m.getName(),0);
  }
 else {
    return null;
  }
}","private SymbolMapReader newSymbolMapReaderInstance(int columnIndex,SymbolMapReader reader){
  RecordColumnMetadata m=metadata.getColumnQuick(columnIndex);
  if (m.getType() == ColumnType.SYMBOL) {
    if (reader instanceof SymbolMapReaderImpl) {
      ((SymbolMapReaderImpl)reader).of(configuration,path,m.getName(),0);
      return reader;
    }
    return new SymbolMapReaderImpl(configuration,path,m.getName(),0);
  }
 else {
    return null;
  }
}",0.7626886145404664
30778,"private void copyColumnsTo(ObjList<ReadOnlyColumn> columns,LongList columnTops,ObjList<BitmapIndexReader> indexReaders,int columnBase,int columnIndex,long partitionRowCount){
  boolean reload=tempCopyStruct.mem1 instanceof ReadOnlyMemory && tempCopyStruct.mem1.isDeleted();
  tempCopyStruct.mem1=columns.getAndSetQuick(getPrimaryColumnIndex(columnBase,columnIndex),tempCopyStruct.mem1);
  tempCopyStruct.mem2=columns.getAndSetQuick(getSecondaryColumnIndex(columnBase,columnIndex),tempCopyStruct.mem2);
  tempCopyStruct.top=columnTops.getAndSetQuick(columnBase / 2 + columnIndex,tempCopyStruct.top);
  tempCopyStruct.bitmapIndexReader=indexReaders.getAndSetQuick(columnBase / 2 + columnIndex,tempCopyStruct.bitmapIndexReader);
  if (reload) {
    reloadColumnAt(path,columns,columnTops,indexReaders,columnBase,columnIndex,partitionRowCount);
  }
}","private void copyColumnsTo(ObjList<ReadOnlyColumn> columns,LongList columnTops,ObjList<BitmapIndexReader> indexReaders,int columnBase,int columnIndex,long partitionRowCount){
  ReadOnlyColumn mem1=tempCopyStruct.mem1;
  boolean reload=(mem1 instanceof ReadOnlyMemory || mem1 instanceof ForceNullColumn) && mem1.isDeleted();
  tempCopyStruct.mem1=columns.getAndSetQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
  tempCopyStruct.mem2=columns.getAndSetQuick(getSecondaryColumnIndex(columnBase,columnIndex),tempCopyStruct.mem2);
  tempCopyStruct.top=columnTops.getAndSetQuick(columnBase / 2 + columnIndex,tempCopyStruct.top);
  tempCopyStruct.bitmapIndexReader=indexReaders.getAndSetQuick(columnBase / 2 + columnIndex,tempCopyStruct.bitmapIndexReader);
  if (reload) {
    reloadColumnAt(path,columns,columnTops,indexReaders,columnBase,columnIndex,partitionRowCount);
  }
}",0.9276201505500868
30779,"@Test public void testReplaceIndexedWithUnindexedByMonth() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.MONTH,1000000 * 60 * 5* 24L,2);
}","@Test public void testReplaceIndexedWithUnindexedByMonth() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.MONTH,1000000 * 60 * 5* 24L,2,false);
}",0.98159509202454
30780,"private void testReplaceUnindexedColWithIndexed(int partitionBy,long increment,int expectedPartitionMin) throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    final int M=1000;
    final int N=100;
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",partitionBy).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4).col(""String_Node_Str"",ColumnType.INT).timestamp().col(""String_Node_Str"",ColumnType.SYMBOL)){
      CairoTestUtils.create(model);
    }
     final Rnd rnd=new Rnd();
    final String symbols[]=new String[N];
    for (int i=0; i < N; i++) {
      symbols[i]=rnd.nextChars(8).toString();
    }
    long timestamp=0;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < M; i++) {
        TableWriter.Row row=writer.newRow(timestamp+=increment);
        row.putStr(0,rnd.nextChars(20));
        row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
        row.putInt(2,rnd.nextInt());
        row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        final TableReaderDataFrameCursor cursor=new TableReaderDataFrameCursor();
        final TableReaderRecord record=new TableReaderRecord(reader);
        Assert.assertTrue(reader.getPartitionCount() > expectedPartitionMin);
        cursor.of(reader);
        assertSymbolFoundInIndex(cursor,record,1,M);
        cursor.toTop();
        assertNoIndex(cursor,4);
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL,N,true,true,8);
        for (int i=0; i < M; i++) {
          TableWriter.Row row=writer.newRow(timestamp+=increment);
          row.putStr(0,rnd.nextChars(20));
          row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
          row.putInt(2,rnd.nextInt());
          row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
          row.append();
        }
        writer.commit();
        Assert.assertTrue(reader.reload());
        cursor.reload();
        assertSymbolFoundInIndex(cursor,record,1,M * 2);
        cursor.toTop();
        assertSymbolFoundInIndex(cursor,record,4,M * 2);
      }
     }
   }
);
}","private void testReplaceUnindexedColWithIndexed(int partitionBy,long increment,int expectedPartitionMin,boolean testRestricted) throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    final int M=1000;
    final int N=100;
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",partitionBy).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4).col(""String_Node_Str"",ColumnType.INT).timestamp().col(""String_Node_Str"",ColumnType.SYMBOL)){
      CairoTestUtils.create(model);
    }
     final Rnd rnd=new Rnd();
    final String symbols[]=new String[N];
    for (int i=0; i < N; i++) {
      symbols[i]=rnd.nextChars(8).toString();
    }
    long timestamp=0;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < M; i++) {
        TableWriter.Row row=writer.newRow(timestamp+=increment);
        row.putStr(0,rnd.nextChars(20));
        row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
        row.putInt(2,rnd.nextInt());
        row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        final TableReaderDataFrameCursor cursor=new TableReaderDataFrameCursor();
        final TableReaderRecord record=new TableReaderRecord(reader);
        Assert.assertTrue(reader.getPartitionCount() > expectedPartitionMin);
        cursor.of(reader);
        assertSymbolFoundInIndex(cursor,record,1,M);
        cursor.toTop();
        assertNoIndex(cursor);
        if (testRestricted || configuration.getFilesFacade().isRestrictedFileSystem()) {
          reader.closeColumnForRemove(""String_Node_Str"");
        }
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL,N,true,true,8);
        for (int i=0; i < M; i++) {
          TableWriter.Row row=writer.newRow(timestamp+=increment);
          row.putStr(0,rnd.nextChars(20));
          row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
          row.putInt(2,rnd.nextInt());
          row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
          row.append();
        }
        writer.commit();
        Assert.assertTrue(reader.reload());
        cursor.reload();
        assertSymbolFoundInIndex(cursor,record,1,M * 2);
        cursor.toTop();
        assertSymbolFoundInIndex(cursor,record,4,M * 2);
      }
     }
   }
);
}",0.961038961038961
30781,"@Test public void testReplaceIndexedWithUnindexedByByNone() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.NONE,1000000 * 60 * 5,0);
}","@Test public void testReplaceIndexedWithUnindexedByByNone() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.NONE,1000000 * 60 * 5,0,false);
}",0.981012658227848
30782,"private void assertNoIndex(TableReaderDataFrameCursor cursor,int columnIndex){
  while (cursor.hasNext()) {
    DataFrame frame=cursor.next();
    try {
      frame.getBitmapIndexReader(columnIndex);
      Assert.fail();
    }
 catch (    CairoException e) {
      Assert.assertTrue(Chars.contains(e.getMessage(),""String_Node_Str""));
    }
  }
}","private void assertNoIndex(TableReaderDataFrameCursor cursor){
  while (cursor.hasNext()) {
    DataFrame frame=cursor.next();
    try {
      frame.getBitmapIndexReader(4);
      Assert.fail();
    }
 catch (    CairoException e) {
      Assert.assertTrue(Chars.contains(e.getMessage(),""String_Node_Str""));
    }
  }
}",0.9578313253012049
30783,"@Test public void testReplaceIndexedWithUnindexedByByDay() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.DAY,1000000 * 60 * 5,3);
}","@Test public void testReplaceIndexedWithUnindexedByByDay() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.DAY,1000000 * 60 * 5,3,false);
}",0.9807692307692308
30784,"@Test public void testReplaceIndexedWithUnindexedByByYear() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.YEAR,1000000 * 60 * 5* 24L* 10L,2);
}","@Test public void testReplaceIndexedWithUnindexedByByYear() throws Exception {
  testReplaceIndexedColWithUnindexed(PartitionBy.YEAR,1000000 * 60 * 5* 24L* 10L,2,false);
}",0.9821428571428572
30785,"private void testReplaceIndexedColWithUnindexed(int partitionBy,long increment,int expectedPartitionMin) throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    final int M=1000;
    final int N=100;
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",partitionBy).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4).col(""String_Node_Str"",ColumnType.INT).timestamp().col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4)){
      CairoTestUtils.create(model);
    }
     final Rnd rnd=new Rnd();
    final String symbols[]=new String[N];
    for (int i=0; i < N; i++) {
      symbols[i]=rnd.nextChars(8).toString();
    }
    long timestamp=0;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < M; i++) {
        TableWriter.Row row=writer.newRow(timestamp+=increment);
        row.putStr(0,rnd.nextChars(20));
        row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
        row.putInt(2,rnd.nextInt());
        row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        final TableReaderDataFrameCursor cursor=new TableReaderDataFrameCursor();
        final TableReaderRecord record=new TableReaderRecord(reader);
        Assert.assertTrue(reader.getPartitionCount() > expectedPartitionMin);
        cursor.of(reader);
        assertSymbolFoundInIndex(cursor,record,1,M);
        cursor.toTop();
        assertSymbolFoundInIndex(cursor,record,4,M);
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL);
        for (int i=0; i < M; i++) {
          TableWriter.Row row=writer.newRow(timestamp+=increment);
          row.putStr(0,rnd.nextChars(20));
          row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
          row.putInt(2,rnd.nextInt());
          row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
          row.append();
        }
        writer.commit();
        Assert.assertTrue(reader.reload());
        cursor.reload();
        assertSymbolFoundInIndex(cursor,record,1,M * 2);
        cursor.toTop();
        assertNoIndex(cursor,4);
      }
     }
   }
);
}","private void testReplaceIndexedColWithUnindexed(int partitionBy,long increment,int expectedPartitionMin,boolean testRestricted) throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    final int M=1000;
    final int N=100;
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",partitionBy).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4).col(""String_Node_Str"",ColumnType.INT).timestamp().col(""String_Node_Str"",ColumnType.SYMBOL).indexed(true,N / 4)){
      CairoTestUtils.create(model);
    }
     final Rnd rnd=new Rnd();
    final String symbols[]=new String[N];
    for (int i=0; i < N; i++) {
      symbols[i]=rnd.nextChars(8).toString();
    }
    long timestamp=0;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < M; i++) {
        TableWriter.Row row=writer.newRow(timestamp+=increment);
        row.putStr(0,rnd.nextChars(20));
        row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
        row.putInt(2,rnd.nextInt());
        row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        final TableReaderDataFrameCursor cursor=new TableReaderDataFrameCursor();
        final TableReaderRecord record=new TableReaderRecord(reader);
        Assert.assertTrue(reader.getPartitionCount() > expectedPartitionMin);
        cursor.of(reader);
        assertSymbolFoundInIndex(cursor,record,1,M);
        cursor.toTop();
        assertSymbolFoundInIndex(cursor,record,4,M);
        if (testRestricted || configuration.getFilesFacade().isRestrictedFileSystem()) {
          reader.closeColumnForRemove(""String_Node_Str"");
        }
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL);
        for (int i=0; i < M; i++) {
          TableWriter.Row row=writer.newRow(timestamp+=increment);
          row.putStr(0,rnd.nextChars(20));
          row.putSym(1,symbols[rnd.nextPositiveInt() % N]);
          row.putInt(2,rnd.nextInt());
          row.putSym(4,symbols[rnd.nextPositiveInt() % N]);
          row.append();
        }
        writer.commit();
        Assert.assertTrue(reader.reload());
        cursor.reload();
        assertSymbolFoundInIndex(cursor,record,1,M * 2);
        cursor.toTop();
        assertNoIndex(cursor);
      }
     }
   }
);
}",0.9619087484303056
30786,"public void of(FilesFacade ff,LPSZ name,long pageSize,long size){
  close();
  this.ff=ff;
  boolean exists=ff.exists(name);
  if (!exists) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  fd=ff.openRO(name);
  if (fd == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(name);
  }
  this.pageSize=pageSize;
  grow(size);
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(']').$();
}","public void of(FilesFacade ff,LPSZ name,long pageSize,long size){
  close();
  this.ff=ff;
  boolean exists=ff.exists(name);
  if (!exists) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  fd=ff.openRO(name);
  if (fd == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(name);
  }
  this.pageSize=pageSize;
  grow(size);
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(this.size).$(']').$();
}",0.9645833333333332
30787,"@Override public void close(){
  super.close();
  if (fd != -1) {
    ff.close(fd);
    LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
    fd=-1;
  }
}","@Override public void close(){
  super.close();
  if (fd != -1) {
    ff.close(fd);
    LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
    fd=-1;
    this.size=0;
  }
}",0.9476923076923076
30788,"private void createColumnInstanceAt(Path path,ObjList<ReadOnlyColumn> columns,LongList columnTops,int columnIndex,int columnBase,long partitionRowCount){
  int plen=path.length();
  try {
    String name=metadata.getColumnName(columnIndex);
    if (ff.exists(TableUtils.dFile(path.trimTo(plen),name))) {
      int type=metadata.getColumnQuick(columnIndex).getType();
      ReadOnlyColumn mem1=new ReadOnlyMemory(ff,path,ff.getMapPageSize(),0);
switch (type) {
case ColumnType.BINARY:
case ColumnType.STRING:
        ReadOnlyColumn mem2=new ReadOnlyMemory(ff,TableUtils.iFile(path.trimTo(plen),name),ff.getMapPageSize(),0);
      columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
    columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),mem2);
  growColumn(mem1,mem2,type,partitionRowCount);
break;
default :
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
growColumn(mem1,null,type,partitionRowCount);
break;
}
columnTops.setQuick(columnBase / 2 + columnIndex,TableUtils.readColumnTop(ff,path.trimTo(plen),name,plen,tempMem8b));
}
 else {
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
}
}
  finally {
path.trimTo(plen);
}
}","private void createColumnInstanceAt(Path path,ObjList<ReadOnlyColumn> columns,LongList columnTops,int columnIndex,int columnBase,long partitionRowCount){
  int plen=path.length();
  try {
    String name=metadata.getColumnName(columnIndex);
    if (ff.exists(TableUtils.dFile(path.trimTo(plen),name))) {
      int type=metadata.getColumnQuick(columnIndex).getType();
      ReadOnlyColumn mem1=new ReadOnlyMemory(ff,path,ff.getMapPageSize(),0);
      long columnTop=TableUtils.readColumnTop(ff,path.trimTo(plen),name,plen,tempMem8b);
switch (type) {
case ColumnType.BINARY:
case ColumnType.STRING:
        ReadOnlyColumn mem2=new ReadOnlyMemory(ff,TableUtils.iFile(path.trimTo(plen),name),ff.getMapPageSize(),0);
      columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
    columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),mem2);
  growColumn(mem1,mem2,type,partitionRowCount - columnTop);
break;
default :
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),mem1);
growColumn(mem1,null,type,partitionRowCount - columnTop);
break;
}
columnTops.setQuick(columnBase / 2 + columnIndex,columnTop);
}
 else {
columns.setQuick(getPrimaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
columns.setQuick(getSecondaryColumnIndex(columnBase,columnIndex),NullColumn.INSTANCE);
}
}
  finally {
path.trimTo(plen);
}
}",0.9293764087152516
30789,"private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > -1) {
        openPartitionColumns(path,columnBase,partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
      }
    }
 else {
      partitionSize=-1;
    }
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(last).$(""String_Node_Str"").$(transientRowCount).$(']').$();
      if (partitionSize > 0) {
        openPartitionColumns(path,columnBase,partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
      }
    }
 else {
      partitionSize=-1;
    }
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.9532828282828284
30790,"/** 
 * Updates boundaries of all columns in partition.
 * @param partitionIndex index of partition
 * @param rowCount       number of rows in partition
 */
private void reloadPartition(int partitionIndex,long rowCount){
  int symbolMapIndex=0;
  int columnBase=getColumnBase(partitionIndex);
  for (int i=0; i < columnCount; i++) {
    growColumn(columns.getQuick(getPrimaryColumnIndex(columnBase,i)),columns.getQuick(getSecondaryColumnIndex(columnBase,i)),metadata.getColumnQuick(i).getType(),rowCount);
    SymbolMapReader reader=symbolMapReaders.getQuick(i);
    if (reader != null) {
      reader.updateSymbolCount(symbolCountSnapshot.getQuick(symbolMapIndex++));
    }
  }
  partitionRowCounts.setQuick(partitionIndex,rowCount);
}","/** 
 * Updates boundaries of all columns in partition.
 * @param partitionIndex index of partition
 * @param rowCount       number of rows in partition
 */
private void reloadPartition(int partitionIndex,long rowCount){
  int symbolMapIndex=0;
  int columnBase=getColumnBase(partitionIndex);
  for (int i=0; i < columnCount; i++) {
    growColumn(columns.getQuick(getPrimaryColumnIndex(columnBase,i)),columns.getQuick(getSecondaryColumnIndex(columnBase,i)),metadata.getColumnQuick(i).getType(),rowCount - this.columnTops.getQuick(columnBase / 2 + i));
    SymbolMapReader reader=symbolMapReaders.getQuick(i);
    if (reader != null) {
      reader.updateSymbolCount(symbolCountSnapshot.getQuick(symbolMapIndex++));
    }
  }
  partitionRowCounts.setQuick(partitionIndex,rowCount);
}",0.9690585911784068
30791,"private void reshuffleExistingColumnList(int columnCount,long pTransitionIndex){
  final long pIndexBase=pTransitionIndex + 8;
  final long pState=pIndexBase + columnCount * 8;
  for (int partitionIndex=0; partitionIndex < partitionCount; partitionIndex++) {
    int base=getColumnBase(partitionIndex);
    try {
      Path path=partitionPathGenerator.generate(this,partitionIndex);
      final long partitionRowCount=partitionRowCounts.getQuick(partitionIndex);
      Unsafe.getUnsafe().setMemory(pState,columnCount,(byte)0);
      for (int i=0; i < columnCount; i++) {
        if (isEntryToBeProcessed(pState,i)) {
          final int copyFrom=Unsafe.getUnsafe().getInt(pIndexBase + i * 8) - 1;
          if (copyFrom == i) {
            continue;
          }
          if (copyFrom > -1) {
            fetchColumnsFrom(this.columns,this.columnTops,base,copyFrom);
            copyColumnsTo(this.columns,this.columnTops,base,i,partitionRowCount);
            int copyTo=Unsafe.getUnsafe().getInt(pIndexBase + i * 8 + 4) - 1;
            while (copyTo > -1 && isEntryToBeProcessed(pState,copyTo)) {
              copyColumnsTo(this.columns,this.columnTops,base,copyTo,partitionRowCount);
              copyTo=Unsafe.getUnsafe().getInt(pIndexBase + (copyTo - 1) * 8 + 4);
            }
            Misc.free(tempCopyStruct.mem1);
            Misc.free(tempCopyStruct.mem2);
          }
 else {
            createColumnInstanceAt(path,this.columns,this.columnTops,i,base,partitionRowCount);
          }
        }
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
}","private void reshuffleExistingColumnList(int columnCount,long pTransitionIndex){
  final long pIndexBase=pTransitionIndex + 8;
  final long pState=pIndexBase + columnCount * 8;
  for (int partitionIndex=0; partitionIndex < partitionCount; partitionIndex++) {
    int base=getColumnBase(partitionIndex);
    try {
      Path path=partitionPathGenerator.generate(this,partitionIndex);
      final long partitionRowCount=partitionRowCounts.getQuick(partitionIndex);
      Unsafe.getUnsafe().setMemory(pState,columnCount,(byte)0);
      for (int i=0; i < columnCount; i++) {
        if (isEntryToBeProcessed(pState,i)) {
          final int copyFrom=Unsafe.getUnsafe().getInt(pIndexBase + i * 8) - 1;
          if (copyFrom == i) {
            ReadOnlyColumn col=columns.getQuick(getPrimaryColumnIndex(base,i));
            if (col == null || col instanceof NullColumn || ff.exists(col.getFd())) {
              continue;
            }
            reloadColumnAt(path,columns,columnTops,i,base,partitionRowCount);
            continue;
          }
          if (copyFrom > -1) {
            fetchColumnsFrom(this.columns,this.columnTops,base,copyFrom);
            copyColumnsTo(this.columns,this.columnTops,base,i,partitionRowCount);
            int copyTo=Unsafe.getUnsafe().getInt(pIndexBase + i * 8 + 4) - 1;
            while (copyTo > -1 && isEntryToBeProcessed(pState,copyTo)) {
              copyColumnsTo(this.columns,this.columnTops,base,copyTo,partitionRowCount);
              copyTo=Unsafe.getUnsafe().getInt(pIndexBase + (copyTo - 1) * 8 + 4);
            }
            Misc.free(tempCopyStruct.mem1);
            Misc.free(tempCopyStruct.mem2);
          }
 else {
            createColumnInstanceAt(path,this.columns,this.columnTops,i,base,partitionRowCount);
          }
        }
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
}",0.9179278230500582
30792,"private long openPartition0(int partitionIndex){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    if (ff.exists(path)) {
      path.chopZ();
      final long partitionSize=partitionIndex == partitionCount - 1 ? transientRowCount : readPartitionSize(ff,path,tempMem8b);
      LOG.info().$(""String_Node_Str"").utf8(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(partitionIndex).$(""String_Node_Str"").$(partitionCount).$();
      if (partitionSize > 0) {
        openPartitionColumns(path,getColumnBase(partitionIndex),partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
      }
      return partitionSize;
    }
    return -1;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition0(int partitionIndex){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    if (ff.exists(path)) {
      if (reloadMethod == FIRST_TIME_PARTITIONED_RELOAD_METHOD) {
        reloadMethod=PARTITIONED_RELOAD_METHOD;
      }
 else       if (reloadMethod == FIRST_TIME_NON_PARTITIONED_RELOAD_METHOD) {
        reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
      }
      path.chopZ();
      final long partitionSize=partitionIndex == partitionCount - 1 ? transientRowCount : readPartitionSize(ff,path,tempMem8b);
      LOG.info().$(""String_Node_Str"").utf8(path.$()).$(""String_Node_Str"").$(partitionSize).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(partitionIndex).$(""String_Node_Str"").$(partitionCount).$();
      if (partitionSize > 0) {
        openPartitionColumns(path,getColumnBase(partitionIndex),partitionSize);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
      }
      return partitionSize;
    }
    return -1;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.86084142394822
30793,"private void updateCapacities(){
  int capacity=getColumnBase(partitionCount);
  columns.setPos(capacity);
  this.partitionRowCounts.seed(partitionCount,-1);
  this.columnTops=new LongList(capacity / 2);
  this.columnTops.setPos(capacity / 2);
}","private void updateCapacities(){
  int capacity=getColumnBase(partitionCount);
  columns.setPos(capacity);
  this.partitionRowCounts.seed(partitionCount,-1);
  this.columnTops.setPos(capacity / 2);
}",0.8963963963963963
30794,"private void removeColumnFiles(CharSequence name){
  try {
    ff.iterateDir(path.$(),(file,type) -> {
      nativeLPSZ.of(file);
      if (type == Files.DT_DIR && !IGNORED_FILES.contains(nativeLPSZ)) {
        path.trimTo(rootLen);
        path.concat(nativeLPSZ);
        int plen=path.length();
        removeFileAndOrLog(ff,TableUtils.dFile(path,name));
        removeFileAndOrLog(ff,TableUtils.iFile(path.trimTo(plen),name));
        removeFileAndOrLog(ff,TableUtils.topFile(path.trimTo(plen),name));
      }
    }
);
  }
  finally {
    path.trimTo(rootLen);
  }
}","private void removeColumnFiles(CharSequence name,RemoveFileLambda removeLambda){
  try {
    ff.iterateDir(path.$(),(file,type) -> {
      nativeLPSZ.of(file);
      if (type == Files.DT_DIR && !IGNORED_FILES.contains(nativeLPSZ)) {
        path.trimTo(rootLen);
        path.concat(nativeLPSZ);
        int plen=path.length();
        removeLambda.remove(ff,TableUtils.dFile(path,name));
        removeLambda.remove(ff,TableUtils.iFile(path.trimTo(plen),name));
        removeLambda.remove(ff,TableUtils.topFile(path.trimTo(plen),name));
      }
    }
);
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.8115942028985508
30795,"/** 
 * Adds new column to table, which can be either empty or can have data already. When existing columns already have data this function will create "".top"" file in addition to column files. "".top"" file contains size of partition at the moment of column creation. It must be used to accurately position inside new column when either appending or reading. <p> <b>Failures</b> Adding new column can fail in many different situations. None of the failures affect integrity of data that is already in the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError. Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be either with disk or memory or both. <p> Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to add columns again. <p> <b>Transactions</b> <p> Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may still have committed transaction.
 * @param name            of column either ASCII or UTF8 encoded.
 * @param symbolCapacity  when column type is SYMBOL this parameter specifies approximate capacity for symbol map.It should be equal to number of unique symbol values stored in the table and getting this value badly wrong will cause performance degradation.
 * @param symbolCacheFlag when set to true, symbol values will be cached on Java heap.
 * @param type            {@link ColumnType}
 */
public void addColumn(CharSequence name,int type,int symbolCapacity,boolean symbolCacheFlag){
  if (getColumnIndexQuiet(metaMem,name,columnCount) != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
  commit();
  if (type == ColumnType.SYMBOL) {
    removeSymbolMapFilesLoud(name);
  }
  this.metaSwapIndex=addColumnToMeta(name,type);
  metaMem.close();
  renameMetaToMetaPrev(name);
  writeRestoreMetaTodo(name);
  renameSwapMetaToMeta(name);
  if (type == ColumnType.SYMBOL) {
    try {
      createSymbolMapWriter(name,symbolCapacity,symbolCacheFlag);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE,name,e);
    }
  }
  configureColumn(type);
  columnCount++;
  columnTops.extendAndSet(columnCount - 1,transientRowCount);
  if (transientRowCount > 0 || partitionBy == PartitionBy.NONE) {
    try {
      openNewColumnFiles(name);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE,name,e);
    }
  }
  try {
    openMetaFile();
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
  bumpStructureVersion();
  metadata.addColumn(name,type);
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
}","/** 
 * Adds new column to table, which can be either empty or can have data already. When existing columns already have data this function will create "".top"" file in addition to column files. "".top"" file contains size of partition at the moment of column creation. It must be used to accurately position inside new column when either appending or reading. <p> <b>Failures</b> Adding new column can fail in many different situations. None of the failures affect integrity of data that is already in the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError. Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be either with disk or memory or both. <p> Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to add columns again. <p> <b>Transactions</b> <p> Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may still have committed transaction.
 * @param name            of column either ASCII or UTF8 encoded.
 * @param symbolCapacity  when column type is SYMBOL this parameter specifies approximate capacity for symbol map.It should be equal to number of unique symbol values stored in the table and getting this value badly wrong will cause performance degradation.
 * @param symbolCacheFlag when set to true, symbol values will be cached on Java heap.
 * @param type            {@link ColumnType}
 */
public void addColumn(CharSequence name,int type,int symbolCapacity,boolean symbolCacheFlag){
  if (getColumnIndexQuiet(metaMem,name,columnCount) != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
  commit();
  if (type == ColumnType.SYMBOL) {
    removeSymbolMapFilesLoud(name);
  }
  removeColumnFiles(name,REMOVE_OR_EXCEPTION);
  this.metaSwapIndex=addColumnToMeta(name,type);
  metaMem.close();
  renameMetaToMetaPrev(name);
  writeRestoreMetaTodo(name);
  renameSwapMetaToMeta(name);
  if (type == ColumnType.SYMBOL) {
    try {
      createSymbolMapWriter(name,symbolCapacity,symbolCacheFlag);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE,name,e);
    }
  }
  configureColumn(type);
  columnCount++;
  columnTops.extendAndSet(columnCount - 1,transientRowCount);
  if (transientRowCount > 0 || partitionBy == PartitionBy.NONE) {
    try {
      openNewColumnFiles(name);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE,name,e);
    }
  }
  try {
    openMetaFile();
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
  bumpStructureVersion();
  metadata.addColumn(name,type);
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
}",0.992167972004666
30796,"private static void removeOrException(FilesFacade ff,Path path){
  if (ff.exists(path) && !ff.remove(path)) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
  }
}","private static void removeOrException(FilesFacade ff,LPSZ path){
  if (ff.exists(path) && !ff.remove(path)) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
  }
}",0.9846153846153848
30797,"@Test public void testUnsuccessfulFileRemoveAndReload() throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",PartitionBy.NONE).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.STRING)){
      CairoTestUtils.create(model);
    }
     Rnd rnd=new Rnd();
    final int N=1000;
    TestFilesFacade ff=new TestFilesFacade(){
      int counter=2;
      @Override public boolean remove(      LPSZ name){
        if (counter > 0 && Chars.endsWith(name,""String_Node_Str"") || Chars.endsWith(name,""String_Node_Str"")) {
          counter--;
          return false;
        }
        return super.remove(name);
      }
      @Override public boolean wasCalled(){
        return counter < 1;
      }
    }
;
    CairoConfiguration configuration=new DefaultCairoConfiguration(root){
      @Override public FilesFacade getFilesFacade(){
        return ff;
      }
    }
;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < N; i++) {
        TableWriter.Row row=writer.newRow(0);
        row.putStr(0,rnd.nextChars(10));
        row.putStr(1,rnd.nextChars(15));
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        long counter=0;
        rnd.reset();
        RecordCursor cursor=reader.getCursor();
        while (cursor.hasNext()) {
          Record record=cursor.next();
          Assert.assertEquals(rnd.nextChars(10),record.getFlyweightStr(0));
          Assert.assertEquals(rnd.nextChars(15),record.getFlyweightStr(1));
          counter++;
        }
        Assert.assertEquals(N,counter);
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.STRING);
        Assert.assertTrue(reader.reload());
        Assert.assertEquals(N,reader.size());
        rnd.reset();
        while (cursor.hasNext()) {
          Record record=cursor.next();
          Assert.assertEquals(rnd.nextChars(10),record.getFlyweightStr(0));
          rnd.nextChars(15);
          Assert.assertNull(record.getFlyweightStr(1));
          counter++;
        }
        Assert.assertEquals(N,counter);
      }
     }
     Assert.assertTrue(ff.wasCalled());
  }
);
}","@Test public void testUnsuccessfulFileRemoveAndReload() throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    try (TableModel model=new TableModel(configuration,""String_Node_Str"",PartitionBy.NONE).col(""String_Node_Str"",ColumnType.STRING).col(""String_Node_Str"",ColumnType.STRING)){
      CairoTestUtils.create(model);
    }
     Rnd rnd=new Rnd();
    final int N=1000;
    TestFilesFacade ff=new TestFilesFacade(){
      int counter=2;
      @Override public boolean remove(      LPSZ name){
        if (counter > 0 && (Chars.endsWith(name,""String_Node_Str"") || Chars.endsWith(name,""String_Node_Str""))) {
          counter--;
          return false;
        }
        return super.remove(name);
      }
      @Override public boolean wasCalled(){
        return counter < 1;
      }
    }
;
    CairoConfiguration configuration=new DefaultCairoConfiguration(root){
      @Override public FilesFacade getFilesFacade(){
        return ff;
      }
    }
;
    try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
      for (int i=0; i < N; i++) {
        TableWriter.Row row=writer.newRow(0);
        row.putStr(0,rnd.nextChars(10));
        row.putStr(1,rnd.nextChars(15));
        row.append();
      }
      writer.commit();
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        long counter=0;
        rnd.reset();
        RecordCursor cursor=reader.getCursor();
        while (cursor.hasNext()) {
          Record record=cursor.next();
          Assert.assertEquals(rnd.nextChars(10),record.getFlyweightStr(0));
          Assert.assertEquals(rnd.nextChars(15),record.getFlyweightStr(1));
          counter++;
        }
        Assert.assertEquals(N,counter);
        writer.removeColumn(""String_Node_Str"");
        writer.addColumn(""String_Node_Str"",ColumnType.STRING);
        Assert.assertTrue(reader.reload());
        Assert.assertEquals(N,reader.size());
        rnd.reset();
        cursor.toTop();
        while (cursor.hasNext()) {
          Record record=cursor.next();
          Assert.assertEquals(rnd.nextChars(10),record.getFlyweightStr(0));
          rnd.nextChars(15);
          Assert.assertNull(record.getFlyweightStr(1));
          counter++;
        }
        Assert.assertEquals(N * 2,counter);
      }
     }
     Assert.assertTrue(ff.wasCalled());
  }
);
}",0.993556701030928
30798,"@Override public boolean remove(LPSZ name){
  if (counter > 0 && Chars.endsWith(name,""String_Node_Str"") || Chars.endsWith(name,""String_Node_Str"")) {
    counter--;
    return false;
  }
  return super.remove(name);
}","@Override public boolean remove(LPSZ name){
  if (counter > 0 && (Chars.endsWith(name,""String_Node_Str"") || Chars.endsWith(name,""String_Node_Str""))) {
    counter--;
    return false;
  }
  return super.remove(name);
}",0.9953917050691244
30799,"private void updateKeyCount(){
  int keyCount;
  long timestamp=clock.getTicks();
  while (true) {
    long seq=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE);
    Unsafe.getUnsafe().loadFence();
    keyCount=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
    Unsafe.getUnsafe().loadFence();
    if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) == seq) {
      break;
    }
    if (clock.getTicks() - timestamp > spinLockTimeoutUs) {
      this.keyCount=0;
      LOG.error().$(""String_Node_Str"").$(spinLockTimeoutUs).utf8(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"");
    }
  }
  if (keyCount > this.keyCount) {
    this.keyCount=keyCount;
  }
}","private void updateKeyCount(){
  int keyCount;
  final long deadline=clock.getTicks() + spinLockTimeoutUs;
  while (true) {
    long seq=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE);
    Unsafe.getUnsafe().loadFence();
    if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) == seq) {
      keyCount=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
      Unsafe.getUnsafe().loadFence();
      if (seq == this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE)) {
        break;
      }
    }
    if (clock.getTicks() > deadline) {
      this.keyCount=0;
      LOG.error().$(""String_Node_Str"").$(spinLockTimeoutUs).utf8(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"");
    }
  }
  if (keyCount > this.keyCount) {
    this.keyCount=keyCount;
  }
}",0.8
30800,"private boolean readTxn(){
  int count=0;
  while (true) {
    long txn=txMem.getLong(TableUtils.TX_OFFSET_TXN);
    if (txn == this.txn) {
      return false;
    }
    Unsafe.getUnsafe().loadFence();
    long checkTxn;
    while ((checkTxn=txMem.getLong(TableUtils.TX_OFFSET_TXN_CHECK)) < txn) {
      LockSupport.parkNanos(1);
    }
    if (txn == checkTxn) {
      Unsafe.getUnsafe().loadFence();
      final long transientRowCount=txMem.getLong(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
      final long fixedRowCount=txMem.getLong(TableUtils.TX_OFFSET_FIXED_ROW_COUNT);
      final long maxTimestamp=txMem.getLong(TableUtils.TX_OFFSET_MAX_TIMESTAMP);
      final long structVersion=txMem.getLong(TableUtils.TX_OFFSET_STRUCT_VERSION);
      this.symbolCountSnapshot.clear();
      int symbolMapCount=txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT);
      if (symbolMapCount > 0) {
        txMem.grow(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + symbolMapCount * 4);
        for (int i=0; i < symbolMapCount; i++) {
          symbolCountSnapshot.add(txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + i * 4));
        }
      }
      Unsafe.getUnsafe().loadFence();
      if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN)) {
        this.txn=txn;
        this.transientRowCount=transientRowCount;
        this.rowCount=fixedRowCount + transientRowCount;
        this.maxTimestamp=maxTimestamp;
        this.structVersion=structVersion;
        LOG.info().$(""String_Node_Str"").$(txn).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(fixedRowCount).$(""String_Node_Str"").$(maxTimestamp).$(""String_Node_Str"").$(count).$(']').$();
        break;
      }
      count++;
      LockSupport.parkNanos(1);
    }
  }
  return true;
}","private boolean readTxn(){
  int count=0;
  final long deadline=configuration.getClock().getTicks() + configuration.getSpinLockTimeoutUs();
  while (true) {
    long txn=txMem.getLong(TableUtils.TX_OFFSET_TXN);
    if (txn == this.txn) {
      return false;
    }
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN_CHECK)) {
      Unsafe.getUnsafe().loadFence();
      final long transientRowCount=txMem.getLong(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
      final long fixedRowCount=txMem.getLong(TableUtils.TX_OFFSET_FIXED_ROW_COUNT);
      final long maxTimestamp=txMem.getLong(TableUtils.TX_OFFSET_MAX_TIMESTAMP);
      final long structVersion=txMem.getLong(TableUtils.TX_OFFSET_STRUCT_VERSION);
      this.symbolCountSnapshot.clear();
      int symbolMapCount=txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT);
      if (symbolMapCount > 0) {
        txMem.grow(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + symbolMapCount * 4);
        for (int i=0; i < symbolMapCount; i++) {
          symbolCountSnapshot.add(txMem.getInt(TableUtils.TX_OFFSET_MAP_WRITER_COUNT + 4 + i * 4));
        }
      }
      Unsafe.getUnsafe().loadFence();
      if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN)) {
        this.txn=txn;
        this.transientRowCount=transientRowCount;
        this.rowCount=fixedRowCount + transientRowCount;
        this.maxTimestamp=maxTimestamp;
        this.structVersion=structVersion;
        LOG.info().$(""String_Node_Str"").$(txn).$(""String_Node_Str"").$(transientRowCount).$(""String_Node_Str"").$(fixedRowCount).$(""String_Node_Str"").$(maxTimestamp).$(""String_Node_Str"").$(count).$(']').$();
        return true;
      }
    }
    count++;
    if (configuration.getClock().getTicks() > deadline) {
      LOG.error().$(""String_Node_Str"").$(configuration.getSpinLockTimeoutUs()).utf8(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"");
    }
    LockSupport.parkNanos(1);
  }
}",0.8688656476267096
30801,"public static void validate(FilesFacade ff,ReadOnlyMemory metaMem,CharSequenceIntHashMap nameIndex){
  try {
    final int columnCount=metaMem.getInt(META_OFFSET_COUNT);
    long offset=getColumnNameOffset(columnCount);
    if (offset < columnCount || (columnCount > 0 && (offset < 0 || offset >= ff.length(metaMem.getFd())))) {
      throw validationException(metaMem).put(""String_Node_Str"").put(columnCount);
    }
    final int timestampIndex=metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);
    if (timestampIndex < -1 || timestampIndex >= columnCount) {
      throw validationException(metaMem).put(""String_Node_Str"");
    }
    if (timestampIndex != -1) {
      int timestampType=getColumnType(metaMem,timestampIndex);
      if (timestampType != ColumnType.TIMESTAMP) {
        throw validationException(metaMem).put(""String_Node_Str"").put(ColumnType.nameOf(timestampType));
      }
    }
    for (int i=0; i < columnCount; i++) {
      int type=getColumnType(metaMem,i);
      if (ColumnType.sizeOf(type) == -1) {
        throw validationException(metaMem).put(""String_Node_Str"").put(type).put(""String_Node_Str"").put(i).put(']');
      }
    }
    for (int i=0; i < columnCount; i++) {
      CharSequence name=metaMem.getStr(offset);
      if (name == null || name.length() < 1) {
        throw validationException(metaMem).put(""String_Node_Str"").put(i).put(']');
      }
      String s=name.toString();
      if (!nameIndex.put(s,i)) {
        throw validationException(metaMem).put(""String_Node_Str"").put(s).put(""String_Node_Str"").put(i).put(']');
      }
      offset+=ReadOnlyMemory.getStorageLength(name);
    }
  }
 catch (  CairoException e) {
    nameIndex.clear();
    throw e;
  }
}","public static void validate(FilesFacade ff,ReadOnlyMemory metaMem,CharSequenceIntHashMap nameIndex){
  try {
    final int columnCount=metaMem.getInt(META_OFFSET_COUNT);
    long offset=getColumnNameOffset(columnCount);
    if (offset < columnCount || (columnCount > 0 && (offset < 0 || offset >= ff.length(metaMem.getFd())))) {
      throw validationException(metaMem).put(""String_Node_Str"").put(columnCount);
    }
    final int timestampIndex=metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);
    if (timestampIndex < -1 || timestampIndex >= columnCount) {
      throw validationException(metaMem).put(""String_Node_Str"");
    }
    if (timestampIndex != -1) {
      int timestampType=getColumnType(metaMem,timestampIndex);
      if (timestampType != ColumnType.TIMESTAMP) {
        throw validationException(metaMem).put(""String_Node_Str"").put(ColumnType.nameOf(timestampType));
      }
    }
    for (int i=0; i < columnCount; i++) {
      int type=getColumnType(metaMem,i);
      if (ColumnType.sizeOf(type) == -1) {
        throw validationException(metaMem).put(""String_Node_Str"").put(type).put(""String_Node_Str"").put(i).put(']');
      }
      if (isColumnIndexed(metaMem,i)) {
        if (type != ColumnType.SYMBOL) {
          throw validationException(metaMem).put(""String_Node_Str"").put(""String_Node_Str"").put(i).put(']');
        }
        if (getIndexBlockCapacity(metaMem,i) < 2) {
          throw validationException(metaMem).put(""String_Node_Str"").put(getIndexBlockCapacity(metaMem,i)).put(""String_Node_Str"").put(i).put(']');
        }
      }
    }
    for (int i=0; i < columnCount; i++) {
      CharSequence name=metaMem.getStr(offset);
      if (name == null || name.length() < 1) {
        throw validationException(metaMem).put(""String_Node_Str"").put(i).put(']');
      }
      String s=name.toString();
      if (!nameIndex.put(s,i)) {
        throw validationException(metaMem).put(""String_Node_Str"").put(s).put(""String_Node_Str"").put(i).put(']');
      }
      offset+=ReadOnlyMemory.getStorageLength(name);
    }
  }
 catch (  CairoException e) {
    nameIndex.clear();
    throw e;
  }
}",0.8909329829172142
30802,"private int addColumnToMeta(CharSequence name,int type,boolean indexFlag,int indexValueBlockCapacity){
  int index;
  try {
    index=TableUtils.openMetaSwapFile(ff,ddlMem,path,rootLen,30);
    int columnCount=metaMem.getInt(TableUtils.META_OFFSET_COUNT);
    ddlMem.putInt(columnCount + 1);
    ddlMem.putInt(metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY));
    ddlMem.putInt(metaMem.getInt(TableUtils.META_OFFSET_TIMESTAMP_INDEX));
    ddlMem.jumpTo(TableUtils.META_OFFSET_COLUMN_TYPES);
    for (int i=0; i < columnCount; i++) {
      ddlMem.putByte((byte)TableUtils.getColumnType(metaMem,i));
      ddlMem.putBool(TableUtils.isColumnIndexed(metaMem,i));
      ddlMem.putInt(TableUtils.getIndexBlockCapacity(metaMem,i));
      ddlMem.skip(10);
    }
    ddlMem.putByte((byte)type);
    ddlMem.putBool(indexFlag);
    ddlMem.putInt(indexValueBlockCapacity);
    ddlMem.skip(10);
    long nameOffset=TableUtils.getColumnNameOffset(columnCount);
    for (int i=0; i < columnCount; i++) {
      CharSequence columnName=metaMem.getStr(nameOffset);
      ddlMem.putStr(columnName);
      nameOffset+=VirtualMemory.getStorageLength(columnName);
    }
    ddlMem.putStr(name);
  }
  finally {
    ddlMem.close();
  }
  return index;
}","private int addColumnToMeta(CharSequence name,int type,boolean indexFlag,int indexValueBlockCapacity){
  int index;
  try {
    index=TableUtils.openMetaSwapFile(ff,ddlMem,path,rootLen,configuration.getMaxNumberOfSwapFiles());
    int columnCount=metaMem.getInt(TableUtils.META_OFFSET_COUNT);
    ddlMem.putInt(columnCount + 1);
    ddlMem.putInt(metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY));
    ddlMem.putInt(metaMem.getInt(TableUtils.META_OFFSET_TIMESTAMP_INDEX));
    ddlMem.jumpTo(TableUtils.META_OFFSET_COLUMN_TYPES);
    for (int i=0; i < columnCount; i++) {
      ddlMem.putByte((byte)TableUtils.getColumnType(metaMem,i));
      ddlMem.putBool(TableUtils.isColumnIndexed(metaMem,i));
      ddlMem.putInt(TableUtils.getIndexBlockCapacity(metaMem,i));
      ddlMem.skip(10);
    }
    ddlMem.putByte((byte)type);
    ddlMem.putBool(indexFlag);
    ddlMem.putInt(indexValueBlockCapacity);
    ddlMem.skip(10);
    long nameOffset=TableUtils.getColumnNameOffset(columnCount);
    for (int i=0; i < columnCount; i++) {
      CharSequence columnName=metaMem.getStr(nameOffset);
      ddlMem.putStr(columnName);
      nameOffset+=VirtualMemory.getStorageLength(columnName);
    }
    ddlMem.putStr(name);
  }
  finally {
    ddlMem.close();
  }
  return index;
}",0.983632734530938
30803,"/** 
 * Adds new column to table, which can be either empty or can have data already. When existing columns already have data this function will create "".top"" file in addition to column files. "".top"" file contains size of partition at the moment of column creation. It must be used to accurately position inside new column when either appending or reading. <p> <b>Failures</b> Adding new column can fail in many different situations. None of the failures affect integrity of data that is already in the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError. Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be either with disk or memory or both. <p> Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to add columns again. <p> <b>Transactions</b> <p> Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may still have committed transaction.
 * @param name            of column either ASCII or UTF8 encoded.
 * @param symbolCapacity  when column type is SYMBOL this parameter specifies approximate capacity for symbol map.It should be equal to number of unique symbol values stored in the table and getting this value badly wrong will cause performance degradation.
 * @param symbolCacheFlag when set to true, symbol values will be cached on Java heap.
 * @param type            {@link ColumnType}
 */
public void addColumn(CharSequence name,int type,int symbolCapacity,boolean symbolCacheFlag,boolean indexFlag,int indexValueBlockCapacity){
  if (getColumnIndexQuiet(metaMem,name,columnCount) != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
  commit();
  removeColumnFiles(name,type,REMOVE_OR_EXCEPTION);
  this.metaSwapIndex=addColumnToMeta(name,type,indexFlag,indexValueBlockCapacity);
  metaMem.close();
  renameMetaToMetaPrev(name);
  writeRestoreMetaTodo(name);
  renameSwapMetaToMeta(name);
  if (type == ColumnType.SYMBOL) {
    try {
      createSymbolMapWriter(name,symbolCapacity,symbolCacheFlag);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE,name,e);
    }
  }
  configureColumn(type,indexFlag);
  columnCount++;
  columnTops.extendAndSet(columnCount - 1,transientRowCount);
  if (transientRowCount > 0 || partitionBy == PartitionBy.NONE) {
    try {
      openNewColumnFiles(name,indexFlag,indexValueBlockCapacity);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE,name,e);
    }
  }
  try {
    openMetaFile();
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
  bumpStructureVersion();
  metadata.addColumn(name,type,indexFlag,indexValueBlockCapacity);
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
}","/** 
 * Adds new column to table, which can be either empty or can have data already. When existing columns already have data this function will create "".top"" file in addition to column files. "".top"" file contains size of partition at the moment of column creation. It must be used to accurately position inside new column when either appending or reading. <p> <b>Failures</b> Adding new column can fail in many different situations. None of the failures affect integrity of data that is already in the table but can leave instance of TableWriter in inconsistent state. When this happens function will throw CairoError. Calling code must close TableWriter instance and open another when problems are rectified. Those problems would be either with disk or memory or both. <p> Whenever function throws CairoException application code can continue using TableWriter instance and may attempt to add columns again. <p> <b>Transactions</b> <p> Pending transaction will be committed before function attempts to add column. Even when function is unsuccessful it may still have committed transaction.
 * @param name            of column either ASCII or UTF8 encoded.
 * @param symbolCapacity  when column type is SYMBOL this parameter specifies approximate capacity for symbol map.It should be equal to number of unique symbol values stored in the table and getting this value badly wrong will cause performance degradation.
 * @param symbolCacheFlag when set to true, symbol values will be cached on Java heap.
 * @param type            {@link ColumnType}
 */
public void addColumn(CharSequence name,int type,int symbolCapacity,boolean symbolCacheFlag,boolean indexFlag,int indexValueBlockCapacity){
  if (getColumnIndexQuiet(metaMem,name,columnCount) != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
  commit();
  removeColumnFiles(name,type,REMOVE_OR_EXCEPTION);
  this.metaSwapIndex=addColumnToMeta(name,type,indexFlag,indexValueBlockCapacity);
  metaMem.close();
  validateSwapMeta(name);
  renameMetaToMetaPrev(name);
  writeRestoreMetaTodo(name);
  renameSwapMetaToMeta(name);
  if (type == ColumnType.SYMBOL) {
    try {
      createSymbolMapWriter(name,symbolCapacity,symbolCacheFlag);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_SYMBOL_MAP_WRITER_FAILURE,name,e);
    }
  }
  configureColumn(type,indexFlag);
  columnCount++;
  columnTops.extendAndSet(columnCount - 1,transientRowCount);
  if (transientRowCount > 0 || partitionBy == PartitionBy.NONE) {
    try {
      openNewColumnFiles(name,indexFlag,indexValueBlockCapacity);
    }
 catch (    CairoException e) {
      runFragile(RECOVER_FROM_COLUMN_OPEN_FAILURE,name,e);
    }
  }
  try {
    openMetaFile();
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
  bumpStructureVersion();
  metadata.addColumn(name,type,indexFlag,indexValueBlockCapacity);
  LOG.info().$(""String_Node_Str"").utf8(name).$('[').$(ColumnType.nameOf(type)).$(""String_Node_Str"").$(path).$();
}",0.99584
30804,"public final void close(boolean truncate){
  long sz=getAppendOffset();
  releaseCurrentPage();
  super.close();
  if (fd != -1) {
    try {
      if (truncate) {
        if (ff.truncate(fd,sz)) {
          LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
        }
 else {
          if (!ff.supportsTruncateMappedFiles()) {
            long n=sz / getMapPageSize();
            if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
              LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
              return;
            }
          }
          LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(ff.errno()).$(']').$();
        }
      }
 else {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
    }
  finally {
      closeFd();
    }
  }
}","public final void close(boolean truncate){
  long sz=getAppendOffset();
  releaseCurrentPage();
  super.close();
  if (fd != -1) {
    try {
      if (truncate) {
        if (ff.truncate(fd,sz)) {
          LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
        }
 else {
          if (ff.isRestrictedFileSystem()) {
            long n=sz / getMapPageSize();
            if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
              LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
              return;
            }
          }
          LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(ff.errno()).$(']').$();
        }
      }
 else {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
    }
  finally {
      closeFd();
    }
  }
}",0.9715025906735753
30805,"@Override public void close(){
  long size=getAppendOffset();
  super.close();
  if (fd != -1) {
    try {
      if (ff.truncate(fd,size)) {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
 else {
        if (!ff.supportsTruncateMappedFiles()) {
          long n=size / getMapPageSize();
          if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
            LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
            return;
          }
        }
        LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(ff.errno()).$(']').$();
      }
    }
  finally {
      ff.close(fd);
      fd=-1;
    }
  }
}","@Override public void close(){
  long size=getAppendOffset();
  super.close();
  if (fd != -1) {
    try {
      if (ff.truncate(fd,size)) {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
 else {
        if (ff.isRestrictedFileSystem()) {
          long n=size / getMapPageSize();
          if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
            LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
            return;
          }
        }
        LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(ff.errno()).$(']').$();
      }
    }
  finally {
      ff.close(fd);
      fd=-1;
    }
  }
}",0.9666666666666668
30806,"public void updateSymbolCount(int symbolCount){
  if (symbolCount > this.symbolCount) {
    this.symbolCount=symbolCount;
    this.maxOffset=SymbolMapWriter.keyToOffset(symbolCount - 1);
    this.offsetMem.grow(maxOffset);
    growCharMemToSymbolCount(symbolCount);
  }
}","@Override public void updateSymbolCount(int symbolCount){
  if (symbolCount > this.symbolCount) {
    this.symbolCount=symbolCount;
    this.maxOffset=SymbolMapWriter.keyToOffset(symbolCount - 1);
    this.offsetMem.grow(maxOffset);
    growCharMemToSymbolCount(symbolCount);
  }
}",0.9818840579710144
30807,"private void growCharMemToSymbolCount(int symbolCount){
  if (symbolCount > 0) {
    long lastSymbolOffset=this.offsetMem.getLong(SymbolMapWriter.keyToOffset(symbolCount - 1));
    int l=VirtualMemory.getStorageLength(this.charMem.getStr(lastSymbolOffset));
    this.charMem.grow(lastSymbolOffset + l);
  }
 else {
    this.charMem.grow(0);
  }
}","private void growCharMemToSymbolCount(int symbolCount){
  if (symbolCount > 0) {
    long lastSymbolOffset=this.offsetMem.getLong(SymbolMapWriter.keyToOffset(symbolCount - 1));
    this.charMem.grow(lastSymbolOffset + 4);
    this.charMem.grow(lastSymbolOffset + this.charMem.getStrLen(lastSymbolOffset) * 2 + 4);
  }
 else {
    this.charMem.grow(0);
  }
}",0.5860597439544808
30808,"public void applyTransitionIndexToSymbolMapReaders(long pTransitionIndex){
  final int columnCount=Unsafe.getUnsafe().getInt(pTransitionIndex + 4);
  final long index=pTransitionIndex + 8;
  final long stateAddress=index + columnCount * 8;
  if (columnCount > this.columnCount) {
    symbolMapReaders.setPos(columnCount);
  }
  Unsafe.getUnsafe().setMemory(stateAddress,columnCount,(byte)0);
  for (int i=0; i < columnCount; i++) {
    if (Unsafe.getUnsafe().getByte(stateAddress + i) == -1) {
      continue;
    }
    Unsafe.getUnsafe().putByte(stateAddress + i,(byte)-1);
    int copyFrom=Unsafe.getUnsafe().getInt(index + i * 8);
    if (copyFrom == i + 1) {
      continue;
    }
    SymbolMapReaderImpl tmp;
    if (copyFrom > 0) {
      tmp=symbolMapReaders.getAndSetQuick(copyFrom - 1,null);
      tmp=symbolMapReaders.getAndSetQuick(i,tmp);
      int copyTo=Unsafe.getUnsafe().getInt(index + i * 8 + 4);
      while (copyTo > 0) {
        if (Unsafe.getUnsafe().getByte(stateAddress + copyTo - 1) == -1) {
          break;
        }
        Unsafe.getUnsafe().putByte(stateAddress + copyTo - 1,(byte)-1);
        tmp=symbolMapReaders.getAndSetQuick(copyTo - 1,tmp);
        copyTo=Unsafe.getUnsafe().getInt(index + (copyTo - 1) * 8 + 4);
      }
      Misc.free(tmp);
    }
 else {
      RecordColumnMetadata m=metadata.getColumnQuick(i);
      if (m.getType() == ColumnType.SYMBOL) {
        SymbolMapReaderImpl reader=new SymbolMapReaderImpl(configuration,path,m.getName(),0);
        tmp=symbolMapReaders.getAndSetQuick(i,reader);
        Misc.free(tmp);
      }
 else {
        Misc.free(symbolMapReaders.getAndSetQuick(i,null));
      }
    }
  }
  if (columnCount < this.columnCount) {
    for (int i=columnCount; i < this.columnCount; i++) {
      Misc.free(symbolMapReaders.getQuick(i));
    }
    symbolMapReaders.setPos(columnCount);
  }
}","public void applyTransitionIndexToSymbolMapReaders(long pTransitionIndex){
  final int columnCount=Unsafe.getUnsafe().getInt(pTransitionIndex + 4);
  final long index=pTransitionIndex + 8;
  final long stateAddress=index + columnCount * 8;
  if (columnCount > this.columnCount) {
    symbolMapReaders.setPos(columnCount);
  }
  Unsafe.getUnsafe().setMemory(stateAddress,columnCount,(byte)0);
  for (int i=0; i < columnCount; i++) {
    if (Unsafe.getUnsafe().getByte(stateAddress + i) == -1) {
      continue;
    }
    Unsafe.getUnsafe().putByte(stateAddress + i,(byte)-1);
    int copyFrom=Unsafe.getUnsafe().getInt(index + i * 8);
    if (copyFrom == i + 1) {
      continue;
    }
    SymbolMapReader tmp;
    if (copyFrom > 0) {
      tmp=symbolMapReaders.getAndSetQuick(copyFrom - 1,null);
      tmp=symbolMapReaders.getAndSetQuick(i,tmp);
      int copyTo=Unsafe.getUnsafe().getInt(index + i * 8 + 4);
      while (copyTo > 0) {
        if (Unsafe.getUnsafe().getByte(stateAddress + copyTo - 1) == -1) {
          break;
        }
        Unsafe.getUnsafe().putByte(stateAddress + copyTo - 1,(byte)-1);
        tmp=symbolMapReaders.getAndSetQuick(copyTo - 1,tmp);
        copyTo=Unsafe.getUnsafe().getInt(index + (copyTo - 1) * 8 + 4);
      }
      Misc.free(tmp);
    }
 else {
      RecordColumnMetadata m=metadata.getColumnQuick(i);
      if (m.getType() == ColumnType.SYMBOL) {
        SymbolMapReaderImpl reader=new SymbolMapReaderImpl(configuration,path,m.getName(),0);
        tmp=symbolMapReaders.getAndSetQuick(i,reader);
        Misc.free(tmp);
      }
 else {
        Misc.free(symbolMapReaders.getAndSetQuick(i,null));
      }
    }
  }
  if (columnCount < this.columnCount) {
    for (int i=columnCount; i < this.columnCount; i++) {
      Misc.free(symbolMapReaders.getQuick(i));
    }
    symbolMapReaders.setPos(columnCount);
  }
}",0.9989224137931034
30809,"private void removeColumn(int index){
  Misc.free(getPrimaryColumn(index));
  Misc.free(getSecondaryColumn(index));
  columns.remove(getSecondaryColumnIndex(index));
  columns.remove(getPrimaryColumnIndex(index));
  columnTops.removeIndex(index);
}","private void removeColumn(int index){
  Misc.free(getPrimaryColumn(index));
  Misc.free(getSecondaryColumn(index));
  columns.remove(getSecondaryColumnIndex(index));
  columns.remove(getPrimaryColumnIndex(index));
  columnTops.removeIndex(index);
  nullers.remove(index);
}",0.9520153550863724
30810,"public void truncate(){
  if (fd == -1) {
    return;
  }
  releaseCurrentPage();
  if (!ff.truncate(fd,getMapPageSize())) {
    throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(getMapPageSize()).put(""String_Node_Str"");
  }
  updateLimits(0,pageAddress=mapPage(0));
}","public void truncate(){
  if (fd == -1) {
    return;
  }
  releaseCurrentPage();
  if (!ff.truncate(fd,getMapPageSize())) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(getMapPageSize()).put(""String_Node_Str"");
  }
  updateLimits(0,pageAddress=mapPage(0));
}",0.9937106918238994
30811,"public final void close(boolean truncate){
  long sz=getAppendOffset();
  releaseCurrentPage();
  super.close();
  if (fd != -1) {
    try {
      if (truncate) {
        if (ff.truncate(fd,sz)) {
          LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
        }
 else {
          if (!ff.supportsTruncateMappedFiles()) {
            long n=sz / getMapPageSize();
            if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
              LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
              return;
            }
          }
          LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(Os.errno()).$(']').$();
        }
      }
 else {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
    }
  finally {
      closeFd();
    }
  }
}","public final void close(boolean truncate){
  long sz=getAppendOffset();
  releaseCurrentPage();
  super.close();
  if (fd != -1) {
    try {
      if (truncate) {
        if (ff.truncate(fd,sz)) {
          LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
        }
 else {
          if (!ff.supportsTruncateMappedFiles()) {
            long n=sz / getMapPageSize();
            if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
              LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
              return;
            }
          }
          LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(ff.errno()).$(']').$();
        }
      }
 else {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
    }
  finally {
      closeFd();
    }
  }
}",0.9974193548387096
30812,"public BitmapIndexWriter(CairoConfiguration configuration,Path path,CharSequence name){
  long pageSize=configuration.getFilesFacade().getMapPageSize();
  int plen=path.length();
  try {
    BitmapIndexUtils.keyFileName(path,name);
    boolean exists=configuration.getFilesFacade().exists(path);
    this.keyMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (!exists) {
      LOG.error().$(path).$(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    long keyMemSize=this.keyMem.getAppendOffset();
    if (keyMemSize < BitmapIndexUtils.KEY_FILE_RESERVED) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getByte(BitmapIndexUtils.KEY_RESERVED_OFFSET_SIGNATURE) != BitmapIndexUtils.SIGNATURE) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.keyCount=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
    if (keyMemSize != keyMemSize()) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.keyCount).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) != this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE)) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.valueMemSize=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_VALUE_MEM_SIZE);
    BitmapIndexUtils.valueFileName(path.trimTo(plen),name);
    this.valueMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (this.valueMem.getAppendOffset() != this.valueMemSize) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.valueMemSize).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.blockValueCountMod=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_BLOCK_VALUE_COUNT) - 1;
    this.blockCapacity=(this.blockValueCountMod + 1) * 8 + BitmapIndexUtils.VALUE_BLOCK_FILE_RESERVED;
  }
 catch (  CairoException e) {
    this.close();
    throw e;
  }
 finally {
    path.trimTo(plen);
  }
}","public BitmapIndexWriter(CairoConfiguration configuration,Path path,CharSequence name){
  long pageSize=configuration.getFilesFacade().getMapPageSize();
  int plen=path.length();
  try {
    BitmapIndexUtils.keyFileName(path,name);
    boolean exists=configuration.getFilesFacade().exists(path);
    this.keyMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (!exists) {
      LOG.error().$(path).$(""String_Node_Str"").$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    long keyMemSize=this.keyMem.getAppendOffset();
    if (keyMemSize < BitmapIndexUtils.KEY_FILE_RESERVED) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getByte(BitmapIndexUtils.KEY_RESERVED_OFFSET_SIGNATURE) != BitmapIndexUtils.SIGNATURE) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.keyCount=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
    if (keyMemSize < keyMemSize()) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.keyCount).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) != this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE)) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.valueMemSize=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_VALUE_MEM_SIZE);
    BitmapIndexUtils.valueFileName(path.trimTo(plen),name);
    this.valueMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (this.valueMem.getAppendOffset() != this.valueMemSize) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.valueMemSize).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.blockValueCountMod=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_BLOCK_VALUE_COUNT) - 1;
    this.blockCapacity=(this.blockValueCountMod + 1) * 8 + BitmapIndexUtils.VALUE_BLOCK_FILE_RESERVED;
  }
 catch (  CairoException e) {
    this.close();
    throw e;
  }
 finally {
    path.trimTo(plen);
  }
}",0.9993748697645344
30813,"@Override public void close(){
  long size=getAppendOffset();
  super.close();
  if (fd != -1) {
    ff.truncate(fd,size);
    ff.close(fd);
    LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
    fd=-1;
  }
}","@Override public void close(){
  long size=getAppendOffset();
  super.close();
  if (fd != -1) {
    try {
      if (ff.truncate(fd,size)) {
        LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
      }
 else {
        if (!ff.supportsTruncateMappedFiles()) {
          long n=size / getMapPageSize();
          if (ff.truncate(fd,(n + 1) * getMapPageSize())) {
            LOG.info().$(""String_Node_Str"").$(fd).$(']').$();
            return;
          }
        }
        LOG.info().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(ff.errno()).$(']').$();
      }
    }
  finally {
      ff.close(fd);
      fd=-1;
    }
  }
}",0.4454976303317535
30814,"public void applyTransitionIndex(long address){
  this.metaMem.of(ff,path,ff.getPageSize());
  this.columnNameIndexMap.clear();
  final int columnCount=Unsafe.getUnsafe().getInt(address + 4);
  final long index=address + 8;
  final long stateAddress=index + columnCount * 8;
  boolean timestampRequired=true;
  if (columnCount > this.columnCount) {
    columnMetadata.setPos(columnCount);
    this.columnCount=columnCount;
  }
  Unsafe.getUnsafe().setMemory(stateAddress,columnCount,(byte)0);
  for (int i=0; i < columnCount; i++) {
    if (Unsafe.getUnsafe().getByte(stateAddress + i) == -1) {
      continue;
    }
    Unsafe.getUnsafe().putByte(stateAddress + i,(byte)-1);
    int copyFrom=Unsafe.getUnsafe().getInt(index + i * 8);
    if (copyFrom == i + 1) {
      columnNameIndexMap.put(columnMetadata.getQuick(i).getName(),i);
      continue;
    }
    if (copyFrom > 0) {
      TableColumnMetadata tmp=moveMetadata(copyFrom - 1,null);
      columnNameIndexMap.put(tmp.getName(),i);
      tmp=moveMetadata(i,tmp);
      if (copyFrom - 1 == timestampIndex && timestampRequired) {
        timestampIndex=i;
        timestampRequired=false;
      }
      int copyTo=Unsafe.getUnsafe().getInt(index + i * 8 + 4);
      while (copyTo > 0) {
        if (Unsafe.getUnsafe().getByte(stateAddress + copyTo - 1) == -1) {
          break;
        }
        Unsafe.getUnsafe().putByte(stateAddress + copyTo - 1,(byte)-1);
        columnNameIndexMap.put(tmp.getName(),copyTo - 1);
        tmp=moveMetadata(copyTo - 1,tmp);
        copyFrom=copyTo;
        copyTo=Unsafe.getUnsafe().getInt(index + (copyTo - 1) * 8 + 4);
        if ((copyFrom - 1) == timestampIndex && timestampRequired) {
          timestampIndex=copyTo - 1;
          timestampRequired=false;
        }
      }
      if (tmp != null && i == timestampIndex && timestampRequired) {
        timestampIndex=-1;
        timestampRequired=false;
      }
    }
 else {
      TableColumnMetadata m=newInstance(i,columnCount);
      moveMetadata(i,m);
      columnNameIndexMap.put(m.getName(),i);
    }
  }
  if (columnCount < this.columnCount) {
    if (timestampIndex >= columnCount && timestampRequired) {
      timestampIndex=-1;
    }
    columnMetadata.setPos(columnCount);
    this.columnCount=columnCount;
  }
}","public void applyTransitionIndex(long address){
}",0.0422231796639379
30815,"public BitmapIndexWriter(CairoConfiguration configuration,CharSequence name,int blockCapacity){
  long pageSize=configuration.getFilesFacade().getMapPageSize();
  try (Path path=new Path()){
    BitmapIndexUtils.keyFileName(path,configuration.getRoot(),name);
    boolean exists=configuration.getFilesFacade().exists(path);
    this.keyMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (!exists) {
      initKeyMemory(blockCapacity);
    }
    long keyMemSize=this.keyMem.getAppendOffset();
    if (keyMemSize < BitmapIndexUtils.KEY_FILE_RESERVED) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getByte(BitmapIndexUtils.KEY_RESERVED_OFFSET_SIGNATURE) != BitmapIndexUtils.SIGNATURE) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.keyCount=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
    if (keyMemSize != keyMemSize()) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.keyCount).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) != this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE)) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.valueMemSize=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_VALUE_MEM_SIZE);
    BitmapIndexUtils.valueFileName(path,configuration.getRoot(),name);
    this.valueMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (this.valueMem.getAppendOffset() != this.valueMemSize) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.valueMemSize).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.blockValueCountMod=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_BLOCK_VALUE_COUNT) - 1;
    this.blockCapacity=(this.blockValueCountMod + 1) * 8 + BitmapIndexUtils.VALUE_BLOCK_FILE_RESERVED;
  }
 catch (  CairoException e) {
    this.close();
    throw e;
  }
}","public BitmapIndexWriter(CairoConfiguration configuration,CharSequence name,int valueBlockCapacity){
  long pageSize=configuration.getFilesFacade().getMapPageSize();
  try (Path path=new Path()){
    BitmapIndexUtils.keyFileName(path,configuration.getRoot(),name);
    boolean exists=configuration.getFilesFacade().exists(path);
    this.keyMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (!exists) {
      initKeyMemory(valueBlockCapacity);
    }
    long keyMemSize=this.keyMem.getAppendOffset();
    if (keyMemSize < BitmapIndexUtils.KEY_FILE_RESERVED) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getByte(BitmapIndexUtils.KEY_RESERVED_OFFSET_SIGNATURE) != BitmapIndexUtils.SIGNATURE) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.keyCount=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_KEY_COUNT);
    if (keyMemSize != keyMemSize()) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.keyCount).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    if (this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE_CHECK) != this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_SEQUENCE)) {
      LOG.error().$(""String_Node_Str"").$(path).$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.valueMemSize=this.keyMem.getLong(BitmapIndexUtils.KEY_RESERVED_OFFSET_VALUE_MEM_SIZE);
    BitmapIndexUtils.valueFileName(path,configuration.getRoot(),name);
    this.valueMem=new ReadWriteMemory(configuration.getFilesFacade(),path,pageSize);
    if (this.valueMem.getAppendOffset() != this.valueMemSize) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(this.valueMemSize).$(']').$();
      throw CairoException.instance(0).put(""String_Node_Str"").put(path);
    }
    this.blockValueCountMod=this.keyMem.getInt(BitmapIndexUtils.KEY_RESERVED_OFFSET_BLOCK_VALUE_COUNT) - 1;
    this.blockCapacity=(this.blockValueCountMod + 1) * 8 + BitmapIndexUtils.VALUE_BLOCK_FILE_RESERVED;
  }
 catch (  CairoException e) {
    this.close();
    throw e;
  }
}",0.9969788519637462
30816,"public SymbolMapWriter(CairoConfiguration configuration,CharSequence name,int capacity,int maxHash){
  this.writer=new BitmapIndexWriter(configuration,name,capacity);
  this.reader=new BitmapIndexBackwardReader(configuration,name);
  long mapPageSize=configuration.getFilesFacade().getMapPageSize();
  try (Path path=new Path()){
    this.charMem=new ReadWriteMemory(configuration.getFilesFacade(),path.of(configuration.getRoot()).concat(name).put(""String_Node_Str"").$(),mapPageSize);
    this.offsetMem=new ReadWriteMemory(configuration.getFilesFacade(),path.of(configuration.getRoot()).concat(name).put(""String_Node_Str"").$(),mapPageSize);
  }
   this.maxHash=maxHash;
}","public SymbolMapWriter(CairoConfiguration configuration,CharSequence name,int capacity,int maxHash){
  this.writer=new BitmapIndexWriter(configuration,name,capacity);
  long mapPageSize=configuration.getFilesFacade().getMapPageSize();
  try (Path path=new Path()){
    this.charMem=new ReadWriteMemory(configuration.getFilesFacade(),path.of(configuration.getRoot()).concat(name).put(""String_Node_Str"").$(),mapPageSize);
    this.offsetMem=new ReadWriteMemory(configuration.getFilesFacade(),path.of(configuration.getRoot()).concat(name).put(""String_Node_Str"").$(),mapPageSize);
  }
   this.maxHash=maxHash;
}",0.9491790461297888
30817,"@Override public void close(){
  Misc.free(writer);
  Misc.free(reader);
  Misc.free(charMem);
  Misc.free(offsetMem);
}","@Override public void close(){
  Misc.free(writer);
  Misc.free(charMem);
  Misc.free(offsetMem);
}",0.9041095890410958
30818,"public long put(CharSequence symbol){
  int key=Hash.boundedHash(symbol,maxHash - 1);
  BitmapIndexCursor cursor=reader.getCursor(key,Long.MAX_VALUE);
  while (cursor.hasNext()) {
    long offsetOffset=cursor.next();
    long offset=offsetMem.getLong(offsetOffset);
    if (Chars.equals(symbol,charMem.getStr(offset))) {
      return offsetOffset / 8;
    }
  }
  long offset=charMem.putStr(symbol);
  long offsetOffset=offsetMem.getAppendOffset();
  offsetMem.putLong(offset);
  writer.add(key,offsetOffset);
  return offsetOffset / 8;
}","public long put(CharSequence symbol){
  int key=Hash.boundedHash(symbol,maxHash - 1);
  BitmapIndexCursor cursor=writer.getCursor(key);
  while (cursor.hasNext()) {
    long offsetOffset=cursor.next();
    long offset=offsetMem.getLong(offsetOffset);
    if (Chars.equals(symbol,charMem.getStr(offset))) {
      return offsetOffset / 8;
    }
  }
  long offset=charMem.putStr(symbol);
  long offsetOffset=offsetMem.getAppendOffset();
  offsetMem.putLong(offset);
  writer.add(key,offsetOffset);
  return offsetOffset / 8;
}",0.9783223374175306
30819,"char getCharBytes(int page,long pageOffset,long pageSize){
  char value=0;
  long pageAddress=getPageAddress(page);
  for (int i=0; i < 2; i++) {
    if (pageOffset == pageSize) {
      pageAddress=getPageAddress(++page);
      pageOffset=0;
    }
    char b=(char)(Unsafe.getUnsafe().getByte(pageAddress + pageOffset++));
    value=(char)((value << (8 * i)) | b);
  }
  return value;
}","char getCharBytes(int page,long pageOffset,long pageSize){
  char value=0;
  long pageAddress=getPageAddress(page);
  for (int i=0; i < 2; i++) {
    if (pageOffset == pageSize) {
      pageAddress=getPageAddress(++page);
      pageOffset=0;
    }
    char b=(char)(Unsafe.getUnsafe().getByte(pageAddress + pageOffset++));
    value=(char)((b << (8 * i)) | value);
  }
  return value;
}",0.9844559585492229
30820,"private void putSplitChar(char c){
  Unsafe.getUnsafe().putByte(pageHi - 1,(byte)(c >> 8));
  pageAt(baseOffset + pageHi);
  Unsafe.getUnsafe().putByte(appendPointer++,(byte)c);
}","private void putSplitChar(char c){
  Unsafe.getUnsafe().putByte(pageHi - 1,(byte)c);
  pageAt(baseOffset + pageHi);
  Unsafe.getUnsafe().putByte(appendPointer++,(byte)(c >> 8));
}",0.9608938547486032
30821,"private long offsetInPage(long offset){
  return offset & mod;
}","long offsetInPage(long offset){
  return offset & mod;
}",0.9333333333333332
30822,"@Test public void testSimpleAdd() throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    int N=10000000;
    try (SymbolMapWriter writer=new SymbolMapWriter(configuration,""String_Node_Str"",48,Numbers.ceilPow2(N))){
      Rnd rnd=new Rnd();
      long prev=-1L;
      for (int i=0; i < N; i++) {
        CharSequence cs=rnd.nextChars(10);
        long key=writer.put(cs);
        Assert.assertEquals(prev + 1,key);
        Assert.assertEquals(key,writer.put(cs));
        prev=key;
      }
    }
   }
);
}","@Test public void testSimpleAdd() throws Exception {
  TestUtils.assertMemoryLeak(() -> {
    int N=100000;
    try (SymbolMapWriter writer=new SymbolMapWriter(configuration,""String_Node_Str"",4,Numbers.ceilPow2(N / 2))){
      Rnd rnd=new Rnd();
      long prev=-1L;
      for (int i=0; i < N; i++) {
        CharSequence cs=rnd.nextChars(10);
        long key=writer.put(cs);
        Assert.assertEquals(prev + 1,key);
        Assert.assertEquals(key,writer.put(cs));
        prev=key;
      }
    }
   }
);
}",0.9931305201177624
30823,"private void assertStrings(VirtualMemory mem,boolean b){
  if (b) {
    mem.putByte((byte)1);
  }
  long o1=mem.putStr(""String_Node_Str"");
  long o2=mem.putStr(""String_Node_Str"");
  long o3=mem.putStr(null);
  long o4=mem.putStr(""String_Node_Str"");
  long o5=mem.putNullStr();
  long o6=mem.putStr(""String_Node_Str"",3,3);
  long o7=mem.putStr(null,0,2);
  if (b) {
    assertEquals(1,mem.getByte(0));
  }
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o1));
  Assert.assertEquals(3,mem.getStrLen(o1));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr2(o1));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o2));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr2(o2));
  assertNull(mem.getStr(o3));
  assertNull(mem.getStr2(o3));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o4));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr2(o4));
  assertNull(mem.getStr(o5));
  assertNull(mem.getStr2(o5));
  Assert.assertEquals(-1,mem.getStrLen(o5));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o6));
  Assert.assertNull(mem.getStr(o7));
  CharSequence s1=mem.getStr(o1);
  CharSequence s2=mem.getStr2(o2);
  Assert.assertFalse(Chars.equals(s1,s2));
}","private void assertStrings(VirtualMemory mem,boolean b){
  if (b) {
    mem.putByte((byte)1);
  }
  long o1=mem.putStr(""String_Node_Str"");
  long o2=mem.putStr(""String_Node_Str"");
  long o3=mem.putStr(null);
  long o4=mem.putStr(""String_Node_Str"");
  long o5=mem.putNullStr();
  long o6=mem.putStr(""String_Node_Str"",3,3);
  long o7=mem.putStr(null,0,2);
  if (b) {
    assertEquals(1,mem.getByte(0));
  }
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o1));
  Assert.assertEquals(3,mem.getStrLen(o1));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr2(o1));
  String expected=""String_Node_Str"";
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o2));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr2(o2));
  for (int i=0; i < expected.length(); i++) {
    long offset=o2 + 4 + i * 2;
    int page=mem.pageIndex(offset);
    long pageOffset=mem.offsetInPage(offset);
    final long pageSize=mem.getPageSize(page);
    Assert.assertEquals(expected.charAt(i),mem.getCharBytes(page,pageOffset,pageSize));
  }
  assertNull(mem.getStr(o3));
  assertNull(mem.getStr2(o3));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o4));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr2(o4));
  assertNull(mem.getStr(o5));
  assertNull(mem.getStr2(o5));
  Assert.assertEquals(-1,mem.getStrLen(o5));
  TestUtils.assertEquals(""String_Node_Str"",mem.getStr(o6));
  Assert.assertNull(mem.getStr(o7));
  CharSequence s1=mem.getStr(o1);
  CharSequence s2=mem.getStr2(o2);
  Assert.assertFalse(Chars.equals(s1,s2));
}",0.7523949889462048
30824,"public TableReader(CairoConfiguration configuration,CharSequence name){
  LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  this.ff=configuration.getFilesFacade();
  this.name=ImmutableCharSequence.of(name);
  this.path=new Path().of(configuration.getRoot()).concat(name);
  this.rootLen=path.length();
  try {
    failOnPendingTodo();
    this.txMem=openTxnFile();
    this.metadata=openMetaFile();
    this.columnCount=this.metadata.getColumnCount();
    this.columnCountBits=getColumnBits(columnCount);
    readTxn();
    this.prevStructVersion=structVersion;
switch (this.metadata.getPartitionBy()) {
case PartitionBy.DAY:
      partitionPathGenerator=DAY_GEN;
    reloadMethod=PARTITIONED_RELOAD_METHOD;
  timestampFloorMethod=Dates::floorDD;
intervalLengthMethod=Dates::getDaysBetween;
dateFormat=TableUtils.fmtDay;
break;
case PartitionBy.MONTH:
partitionPathGenerator=MONTH_GEN;
reloadMethod=PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorMM;
intervalLengthMethod=Dates::getMonthsBetween;
dateFormat=TableUtils.fmtMonth;
break;
case PartitionBy.YEAR:
partitionPathGenerator=YEAR_GEN;
reloadMethod=PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorYYYY;
intervalLengthMethod=Dates::getYearsBetween;
dateFormat=TableUtils.fmtYear;
break;
default :
partitionPathGenerator=DEFAULT_GEN;
reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=null;
intervalLengthMethod=null;
dateFormat=null;
partitionCount=1;
break;
}
if (partitionCount == 0) {
partitionMin=findPartitionMinimum(dateFormat);
partitionCount=calculatePartitionCount();
}
int capacity=getColumnBase(partitionCount);
this.columns=new ObjList<>(capacity);
columns.setPos(capacity);
this.partitionRowCounts=new LongList(partitionCount);
this.partitionRowCounts.seed(partitionCount,-1);
this.columnTops=new LongList(capacity / 2);
this.columnTops.setPos(capacity / 2);
if (partitionCount == 0) {
reloadMethod=FIRST_TIME_PARTITIONED_RELOAD_METHOD;
}
}
 catch (CairoException e) {
close();
throw e;
}
}","public TableReader(CairoConfiguration configuration,CharSequence name){
  LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  this.ff=configuration.getFilesFacade();
  this.name=ImmutableCharSequence.of(name);
  this.path=new Path().of(configuration.getRoot()).concat(name);
  this.rootLen=path.length();
  try {
    failOnPendingTodo();
    this.txMem=openTxnFile();
    this.metadata=openMetaFile();
    this.columnCount=this.metadata.getColumnCount();
    this.columnCountBits=getColumnBits(columnCount);
    readTxn();
    this.prevStructVersion=structVersion;
switch (this.metadata.getPartitionBy()) {
case PartitionBy.DAY:
      partitionPathGenerator=DAY_GEN;
    reloadMethod=FIRST_TIME_PARTITIONED_RELOAD_METHOD;
  timestampFloorMethod=Dates::floorDD;
intervalLengthMethod=Dates::getDaysBetween;
dateFormat=TableUtils.fmtDay;
partitionMin=findPartitionMinimum(dateFormat);
partitionCount=calculatePartitionCount();
break;
case PartitionBy.MONTH:
partitionPathGenerator=MONTH_GEN;
reloadMethod=FIRST_TIME_PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorMM;
intervalLengthMethod=Dates::getMonthsBetween;
dateFormat=TableUtils.fmtMonth;
partitionMin=findPartitionMinimum(dateFormat);
partitionCount=calculatePartitionCount();
break;
case PartitionBy.YEAR:
partitionPathGenerator=YEAR_GEN;
reloadMethod=FIRST_TIME_PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorYYYY;
intervalLengthMethod=Dates::getYearsBetween;
dateFormat=TableUtils.fmtYear;
partitionMin=findPartitionMinimum(dateFormat);
partitionCount=calculatePartitionCount();
break;
default :
partitionPathGenerator=DEFAULT_GEN;
reloadMethod=FIRST_TIME_NON_PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=null;
intervalLengthMethod=null;
dateFormat=null;
partitionCount=findDefaultPartitionCount();
break;
}
int capacity=getColumnBase(partitionCount);
this.columns=new ObjList<>(capacity);
columns.setPos(capacity);
this.partitionRowCounts=new LongList(partitionCount);
this.partitionRowCounts.seed(partitionCount,-1);
this.columnTops=new LongList(capacity / 2);
this.columnTops.setPos(capacity / 2);
}
 catch (CairoException e) {
close();
throw e;
}
}",0.8503253796095445
30825,"private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > 0) {
        openPartitionColumns(path,columnBase);
      }
    }
 else {
      partitionSize=-1;
    }
    partitionRowCounts.setQuick(partitionIndex,partitionSize);
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > -1) {
        openPartitionColumns(path,columnBase);
      }
    }
 else {
      partitionSize=-1;
    }
    partitionRowCounts.setQuick(partitionIndex,partitionSize);
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.997968855788761
30826,"private int calculatePartitionCount(){
  if (partitionMin == Long.MAX_VALUE) {
    return 0;
  }
 else {
    return (int)(intervalLengthMethod.calculate(partitionMin,timestampFloorMethod.floor(maxTimestamp)) + 1);
  }
}","private int calculatePartitionCount(){
  if (partitionMin == Long.MAX_VALUE) {
    return 0;
  }
 else {
    return maxTimestamp == Numbers.LONG_NaN ? 1 : (int)(intervalLengthMethod.calculate(partitionMin,timestampFloorMethod.floor(maxTimestamp)) + 1);
  }
}",0.5953878406708596
30827,"private boolean switchPartition(){
  while (partitionIndex < partitionCount) {
    final int columnBase=getColumnBase(partitionIndex);
    long partitionSize=partitionRowCounts.getQuick(partitionIndex);
    if (partitionSize == -1) {
      partitionSize=openPartition(partitionIndex++,columnBase,partitionIndex == partitionCount);
    }
 else {
      partitionIndex++;
    }
    if (partitionSize != 0) {
      record.maxRecordIndex=partitionSize - 1;
      record.recordIndex=-1;
      record.columnBase=columnBase;
      return true;
    }
  }
  return false;
}","private boolean switchPartition(){
  while (partitionIndex < partitionCount) {
    final int columnBase=getColumnBase(partitionIndex);
    long partitionSize=partitionRowCounts.getQuick(partitionIndex);
    if (partitionSize == -1) {
      partitionSize=openPartition(partitionIndex++,columnBase,partitionIndex == partitionCount);
    }
 else {
      partitionIndex++;
    }
    if (partitionSize > 0) {
      record.maxRecordIndex=partitionSize - 1;
      record.recordIndex=-1;
      record.columnBase=columnBase;
      return true;
    }
  }
  return false;
}",0.9973333333333332
30828,"public void grow(long size){
  if (size > this.size) {
    grow0(size);
  }
}","void grow(long size){
  if (size > this.size) {
    grow0(size);
  }
}",0.9523809523809524
30829,"@Override public void trackFileSize(){
  long size=ff.length(fd);
  if (size < this.size) {
    setInitialSize(size);
  }
 else {
    grow(size);
  }
}","@Override public void trackFileSize(){
  long size=ff.length(fd);
  grow(size);
}",0.6982758620689655
30830,"public void of(FilesFacade ff,LPSZ name,long maxPageSize){
  close();
  this.ff=ff;
  boolean exists=ff.exists(name);
  if (!exists) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  fd=ff.openRO(name);
  if (fd == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(name);
  }
  this.maxPageSize=maxPageSize;
  setInitialSize(ff.length(fd));
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(']').$();
}","public void of(FilesFacade ff,LPSZ name,long maxPageSize){
  close();
  this.ff=ff;
  boolean exists=ff.exists(name);
  if (!exists) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  fd=ff.openRO(name);
  if (fd == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(name);
  }
  this.maxPageSize=maxPageSize;
  grow0(ff.length(fd));
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(']').$();
}",0.9800629590766002
30831,"private void grow0(long size){
  pages.ensureCapacity((int)(size / getMapPageSize() + 1));
  if (lastPageSize < getMapPageSize()) {
    int lastIndex=pages.size() - 1;
    if (lastIndex > -1) {
      long address=pages.getQuick(lastIndex);
      if (address != 0) {
        release(lastIndex,address);
        pages.setQuick(lastIndex,0);
      }
      clearHotPage();
    }
    this.lastPageIndex=0;
    this.lastPageSize=getMapPageSize();
  }
  this.size=size;
}","private void grow0(long size){
  long targetPageSize=computePageSize(size);
  if (targetPageSize != getMapPageSize()) {
    setPageSize(targetPageSize);
    ensurePagesListCapacity(size);
    this.lastPageSize=targetPageSize < size ? targetPageSize : size;
  }
 else {
    ensurePagesListCapacity(size);
    if (lastPageSize < getMapPageSize()) {
      int lastIndex=pages.size() - 1;
      if (lastIndex > -1) {
        long address=pages.getQuick(lastIndex);
        if (address != 0) {
          release(lastIndex,address);
          pages.setQuick(lastIndex,0);
        }
        clearHotPage();
      }
      this.lastPageIndex=0;
      this.lastPageSize=getMapPageSize();
    }
  }
  this.size=size;
}",0.623398804440649
30832,"private void configurePageSize(long size,long maxPageSize){
  setPageSize(maxPageSize);
  pages.ensureCapacity((int)(size / getMapPageSize() + 1));
  this.size=size;
}","private void configurePageSize(long size,long maxPageSize){
  setPageSize(maxPageSize);
  ensurePagesListCapacity(size);
  this.size=size;
}",0.8534201954397395
30833,"@Test @Ignore public void testConcurrentWriterAndReadHeight() throws Exception {
  testConcurrentRW(10000000,5000000);
}","@Test public void testConcurrentWriterAndReadHeight() throws Exception {
  testConcurrentRW(1000000,1000000);
}",0.9523809523809524
30834,"private boolean readTxn(){
  while (true) {
    long txn=txMem.getLong(TableUtils.TX_OFFSET_TXN);
    if (txn == this.txn) {
      return false;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableUtils.TX_OFFSET_FIXED_ROW_COUNT);
    long maxTimestamp=txMem.getLong(TableUtils.TX_OFFSET_MAX_TIMESTAMP);
    long structVersion=txMem.getLong(TableUtils.TX_OFFSET_STRUCT_VERSION);
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.rowCount=fixedRowCount + transientRowCount;
      this.maxTimestamp=maxTimestamp;
      this.structVersion=structVersion;
      break;
    }
    LockSupport.parkNanos(1);
  }
  return true;
}","private boolean readTxn(){
  while (true) {
    long txn=txMem.getLong(TableUtils.TX_OFFSET_TXN);
    if (txn == this.txn) {
      return false;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableUtils.TX_OFFSET_FIXED_ROW_COUNT);
    long maxTimestamp=txMem.getLong(TableUtils.TX_OFFSET_MAX_TIMESTAMP);
    long structVersion=txMem.getLong(TableUtils.TX_OFFSET_STRUCT_VERSION);
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableUtils.TX_OFFSET_TXN_CHECK)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.rowCount=fixedRowCount + transientRowCount;
      this.maxTimestamp=maxTimestamp;
      this.structVersion=structVersion;
      break;
    }
    LockSupport.parkNanos(1);
  }
  return true;
}",0.9965197215777262
30835,"public TableReader(CairoConfiguration configuration,CharSequence name){
  LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  this.ff=configuration.getFilesFacade();
  this.name=ImmutableCharSequence.of(name);
  this.path=new Path().of(configuration.getRoot()).concat(name);
  this.rootLen=path.length();
  try {
    failOnPendingTodo();
    this.txMem=openTxnFile();
    this.metadata=openMetaFile();
    this.columnCount=this.metadata.getColumnCount();
    this.columnCountBits=getColumnBits(columnCount);
    readTxn();
    this.prevStructVersion=structVersion;
switch (this.metadata.getPartitionBy()) {
case PartitionBy.DAY:
      partitionPathGenerator=DAY_GEN;
    reloadMethod=PARTITIONED_RELOAD_METHOD;
  timestampFloorMethod=Dates::floorDD;
intervalLengthMethod=Dates::getDaysBetween;
partitionMin=findPartitionMinimum(TableUtils.fmtDay);
partitionCount=calculatePartitionCount();
break;
case PartitionBy.MONTH:
partitionPathGenerator=MONTH_GEN;
reloadMethod=PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorMM;
intervalLengthMethod=Dates::getMonthsBetween;
partitionMin=findPartitionMinimum(TableUtils.fmtMonth);
partitionCount=calculatePartitionCount();
break;
case PartitionBy.YEAR:
partitionPathGenerator=YEAR_GEN;
reloadMethod=PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorYYYY;
intervalLengthMethod=Dates::getYearsBetween;
partitionMin=findPartitionMinimum(TableUtils.fmtYear);
partitionCount=calculatePartitionCount();
break;
default :
partitionPathGenerator=DEFAULT_GEN;
reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=null;
intervalLengthMethod=null;
partitionCount=1;
break;
}
int capacity=getColumnBase(partitionCount);
this.columns=new ObjList<>(capacity);
columns.setPos(capacity);
this.partitionRowCounts=new LongList(partitionCount);
this.partitionRowCounts.seed(partitionCount,-1);
this.columnTops=new LongList(capacity / 2);
this.columnTops.setPos(capacity / 2);
}
 catch (CairoException e) {
close();
throw e;
}
}","public TableReader(CairoConfiguration configuration,CharSequence name){
  LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  this.ff=configuration.getFilesFacade();
  this.name=ImmutableCharSequence.of(name);
  this.path=new Path().of(configuration.getRoot()).concat(name);
  this.rootLen=path.length();
  try {
    failOnPendingTodo();
    this.txMem=openTxnFile();
    this.metadata=openMetaFile();
    this.columnCount=this.metadata.getColumnCount();
    this.columnCountBits=getColumnBits(columnCount);
    readTxn();
    this.prevStructVersion=structVersion;
switch (this.metadata.getPartitionBy()) {
case PartitionBy.DAY:
      partitionPathGenerator=DAY_GEN;
    reloadMethod=PARTITIONED_RELOAD_METHOD;
  timestampFloorMethod=Dates::floorDD;
intervalLengthMethod=Dates::getDaysBetween;
dateFormat=TableUtils.fmtDay;
break;
case PartitionBy.MONTH:
partitionPathGenerator=MONTH_GEN;
reloadMethod=PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorMM;
intervalLengthMethod=Dates::getMonthsBetween;
dateFormat=TableUtils.fmtMonth;
break;
case PartitionBy.YEAR:
partitionPathGenerator=YEAR_GEN;
reloadMethod=PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=Dates::floorYYYY;
intervalLengthMethod=Dates::getYearsBetween;
dateFormat=TableUtils.fmtYear;
break;
default :
partitionPathGenerator=DEFAULT_GEN;
reloadMethod=NON_PARTITIONED_RELOAD_METHOD;
timestampFloorMethod=null;
intervalLengthMethod=null;
dateFormat=null;
partitionCount=1;
break;
}
if (partitionCount == 0) {
partitionMin=findPartitionMinimum(dateFormat);
partitionCount=calculatePartitionCount();
}
int capacity=getColumnBase(partitionCount);
this.columns=new ObjList<>(capacity);
columns.setPos(capacity);
this.partitionRowCounts=new LongList(partitionCount);
this.partitionRowCounts.seed(partitionCount,-1);
this.columnTops=new LongList(capacity / 2);
this.columnTops.setPos(capacity / 2);
if (partitionCount == 0) {
reloadMethod=FIRST_TIME_PARTITIONED_RELOAD_METHOD;
}
}
 catch (CairoException e) {
close();
throw e;
}
}",0.8600050087653394
30836,"/** 
 * Updates boundaries of all columns in partition.
 * @param partitionIndex index of partition
 * @param rowCount       number of rows in partition
 */
private void reloadPartition(int partitionIndex,long rowCount){
  if (partitionRowCounts.getQuick(partitionIndex) > -1) {
    int columnBase=getColumnBase(partitionIndex);
    for (int i=0; i < columnCount; i++) {
      columns.getQuick(getPrimaryColumnIndex(columnBase,i)).trackFileSize();
      ReadOnlyColumn mem2=columns.getQuick(getSecondaryColumnIndex(columnBase,i));
      if (mem2 != null) {
        mem2.trackFileSize();
      }
    }
    partitionRowCounts.setQuick(partitionIndex,rowCount);
  }
}","/** 
 * Updates boundaries of all columns in partition.
 * @param partitionIndex index of partition
 * @param rowCount       number of rows in partition
 */
private void reloadPartition(int partitionIndex,long rowCount){
}",0.5011286681715575
30837,"public static void resetTxn(VirtualMemory txMem){
  txMem.putLong(-1);
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(0);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(TX_EOF);
}","public static void resetTxn(VirtualMemory txMem){
  txMem.jumpTo(TX_OFFSET_TXN);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.putLong(0);
}",0.6895368782161235
30838,"/** 
 * Commits newly added rows of data. This method updates transaction file with pointers to end of appended data. <p> <b>Pending rows</b> <p>This method will cancel pending rows by calling   {@link #cancelRow()}. Data in partially appended row will be lost.</p>
 */
public void commit(){
  if ((masterRef & 1) != 0) {
    cancelRow();
  }
  if (inTransaction()) {
    txMem.jumpTo(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
    txMem.putLong(transientRowCount);
    if (txPartitionCount > 1) {
      commitPendingPartitions();
      txMem.putLong(fixedRowCount);
      columnSizeMem.jumpTo(0);
      txPartitionCount=1;
    }
 else {
      txMem.skip(8);
    }
    txMem.putLong(maxTimestamp);
    fencedTxnBump();
    prevTransientRowCount=transientRowCount;
  }
}","/** 
 * Commits newly added rows of data. This method updates transaction file with pointers to end of appended data. <p> <b>Pending rows</b> <p>This method will cancel pending rows by calling   {@link #cancelRow()}. Data in partially appended row will be lost.</p>
 */
public void commit(){
  if ((masterRef & 1) != 0) {
    cancelRow();
  }
  if (inTransaction()) {
    txMem.jumpTo(TableUtils.TX_OFFSET_TXN);
    txMem.putLong(++txn);
    Unsafe.getUnsafe().storeFence();
    txMem.jumpTo(TableUtils.TX_OFFSET_TRANSIENT_ROW_COUNT);
    txMem.putLong(transientRowCount);
    if (txPartitionCount > 1) {
      commitPendingPartitions();
      txMem.putLong(fixedRowCount);
      columnSizeMem.jumpTo(0);
      txPartitionCount=1;
    }
 else {
      txMem.skip(8);
    }
    txMem.putLong(maxTimestamp);
    Unsafe.getUnsafe().storeFence();
    txMem.jumpTo(TableUtils.TX_OFFSET_TXN_CHECK);
    txMem.putLong(txn);
    prevTransientRowCount=transientRowCount;
  }
}",0.8703170028818443
30839,"public TableWriter(CairoConfiguration configuration,CharSequence name){
  LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  this.ff=configuration.getFilesFacade();
  this.mkDirMode=configuration.getMkDirMode();
  this.fileOperationRetryCount=configuration.getFileOperationRetryCount();
  this.path=new Path().of(configuration.getRoot()).concat(name);
  this.other=new Path().of(configuration.getRoot()).concat(name);
  this.name=ImmutableCharSequence.of(name);
  this.rootLen=path.length();
  try {
    try {
      this.lockFd=TableUtils.lock(ff,path);
    }
  finally {
      path.trimTo(rootLen);
    }
    if (this.lockFd == -1L) {
      throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path.$());
    }
    this.txMem=openTxnFile();
    this.txMem.jumpTo(TableUtils.TX_EOF);
    long todo=readTodoTaskCode();
    if (todo != -1L) {
switch ((int)(todo & 0xff)) {
case TableUtils.TODO_TRUNCATE:
        repairTruncate();
      break;
case TableUtils.TODO_RESTORE_META:
    repairMetaRename((int)(todo >> 8));
  break;
default :
LOG.error().$(""String_Node_Str"").$(todo).$();
break;
}
}
this.ddlMem=new AppendMemory();
this.metaMem=new ReadOnlyMemory();
openMetaFile();
this.metadata=new TableWriterMetadata(ff,metaMem);
this.columnCount=metadata.getColumnCount();
this.partitionBy=metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY);
this.columnSizeMem=new VirtualMemory(ff.getPageSize());
this.refs.extendAndSet(columnCount,0);
this.columns=new ObjList<>(columnCount);
this.nullers=new ObjList<>(columnCount);
this.columnTops=new LongList(columnCount);
this.partitionDirFmt=selectPartitionDirFmt(partitionBy);
configureColumnMemory();
timestampSetter=configureTimestampSetter();
configureAppendPosition();
purgeUnusedPartitions();
}
 catch (CairoException e) {
LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$((Sinkable)e).$('}').$();
close();
throw e;
}
}","public TableWriter(CairoConfiguration configuration,CharSequence name){
  LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  this.ff=configuration.getFilesFacade();
  this.mkDirMode=configuration.getMkDirMode();
  this.fileOperationRetryCount=configuration.getFileOperationRetryCount();
  this.path=new Path().of(configuration.getRoot()).concat(name);
  this.other=new Path().of(configuration.getRoot()).concat(name);
  this.name=ImmutableCharSequence.of(name);
  this.rootLen=path.length();
  try {
    try {
      this.lockFd=TableUtils.lock(ff,path);
    }
  finally {
      path.trimTo(rootLen);
    }
    if (this.lockFd == -1L) {
      throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path.$());
    }
    this.txMem=openTxnFile();
    long todo=readTodoTaskCode();
    if (todo != -1L) {
switch ((int)(todo & 0xff)) {
case TableUtils.TODO_TRUNCATE:
        repairTruncate();
      break;
case TableUtils.TODO_RESTORE_META:
    repairMetaRename((int)(todo >> 8));
  break;
default :
LOG.error().$(""String_Node_Str"").$(todo).$();
break;
}
}
this.ddlMem=new AppendMemory();
this.metaMem=new ReadOnlyMemory();
openMetaFile();
this.metadata=new TableWriterMetadata(ff,metaMem);
this.columnCount=metadata.getColumnCount();
this.partitionBy=metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY);
this.columnSizeMem=new VirtualMemory(ff.getPageSize());
this.refs.extendAndSet(columnCount,0);
this.columns=new ObjList<>(columnCount);
this.nullers=new ObjList<>(columnCount);
this.columnTops=new LongList(columnCount);
this.partitionDirFmt=selectPartitionDirFmt(partitionBy);
configureColumnMemory();
timestampSetter=configureTimestampSetter();
configureAppendPosition();
purgeUnusedPartitions();
}
 catch (CairoException e) {
LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$((Sinkable)e).$('}').$();
close();
throw e;
}
}",0.9888297872340426
30840,"/** 
 * Truncates table. When operation is unsuccessful it throws CairoException. With that truncate can be retried or alternatively table can be closed. Outcome of any other operation with the table is undefined and likely to cause segmentation fault. When table re-opens any partial truncate will be retried.
 */
public final void truncate(){
  if (size() == 0) {
    return;
  }
  writeTodo(TableUtils.TODO_TRUNCATE);
  for (int i=0; i < columnCount; i++) {
    getPrimaryColumn(i).truncate();
    AppendMemory mem=getSecondaryColumn(i);
    if (mem != null) {
      mem.truncate();
    }
  }
  if (partitionBy != PartitionBy.NONE) {
    closeColumns(false);
    removePartitionDirectories();
    rowFunction=openPartitionFunction;
  }
  prevTimestamp=Long.MIN_VALUE;
  maxTimestamp=Long.MIN_VALUE;
  partitionLo=Long.MIN_VALUE;
  prevTransientRowCount=0;
  transientRowCount=0;
  fixedRowCount=0;
  txn=0;
  txPartitionCount=1;
  txMem.jumpTo(TableUtils.TX_OFFSET_TXN);
  TableUtils.resetTxn(txMem);
  try {
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
}","/** 
 * Truncates table. When operation is unsuccessful it throws CairoException. With that truncate can be retried or alternatively table can be closed. Outcome of any other operation with the table is undefined and likely to cause segmentation fault. When table re-opens any partial truncate will be retried.
 */
public final void truncate(){
  if (size() == 0) {
    return;
  }
  writeTodo(TableUtils.TODO_TRUNCATE);
  for (int i=0; i < columnCount; i++) {
    getPrimaryColumn(i).truncate();
    AppendMemory mem=getSecondaryColumn(i);
    if (mem != null) {
      mem.truncate();
    }
  }
  if (partitionBy != PartitionBy.NONE) {
    closeColumns(false);
    removePartitionDirectories();
    rowFunction=openPartitionFunction;
  }
  prevTimestamp=Long.MIN_VALUE;
  maxTimestamp=Long.MIN_VALUE;
  partitionLo=Long.MIN_VALUE;
  prevTransientRowCount=0;
  transientRowCount=0;
  fixedRowCount=0;
  txn=0;
  txPartitionCount=1;
  TableUtils.resetTxn(txMem);
  try {
    removeTodoFile();
  }
 catch (  CairoException err) {
    throw new CairoError(err);
  }
}",0.9622119815668204
30841,"private void repairTruncate(){
  LOG.info().$(""String_Node_Str"").$(path).$();
  if (partitionBy != PartitionBy.NONE) {
    removePartitionDirectories();
  }
  txMem.jumpTo(TableUtils.TX_OFFSET_TXN);
  TableUtils.resetTxn(txMem);
  removeTodoFile();
}","private void repairTruncate(){
  LOG.info().$(""String_Node_Str"").$(path).$();
  if (partitionBy != PartitionBy.NONE) {
    removePartitionDirectories();
  }
  TableUtils.resetTxn(txMem);
  removeTodoFile();
}",0.7510917030567685
30842,"private void bumpStructureVersion(){
  txMem.jumpTo(TableUtils.TX_OFFSET_STRUCT_VERSION);
  txMem.putLong(++structVersion);
  fencedTxnBump();
}","private void bumpStructureVersion(){
  txMem.jumpTo(TableUtils.TX_OFFSET_TXN);
  txMem.putLong(++txn);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(TableUtils.TX_OFFSET_STRUCT_VERSION);
  txMem.putLong(++structVersion);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(TableUtils.TX_OFFSET_TXN_CHECK);
  txMem.putLong(txn);
}",0.5684210526315789
30843,"@Override public void close(){
  if (isOpen()) {
    closeColumns(true);
    Misc.free(txMem);
    Misc.free(metaMem);
    Misc.free(columnSizeMem);
    Misc.free(ddlMem);
    Misc.free(path);
    Misc.free(other);
    if (lockFd != -1L) {
      ff.close(lockFd);
    }
    if (tempMem8b != 0) {
      Unsafe.free(tempMem8b,8);
      tempMem8b=0;
    }
    LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  }
}","@Override public void close(){
  if (isOpen()) {
    closeColumns(true);
    if (txMem != null) {
      txMem.jumpTo(TableUtils.TX_EOF);
      txMem.close();
    }
    Misc.free(metaMem);
    Misc.free(columnSizeMem);
    Misc.free(ddlMem);
    Misc.free(path);
    Misc.free(other);
    if (lockFd != -1L) {
      ff.close(lockFd);
    }
    if (tempMem8b != 0) {
      Unsafe.free(tempMem8b,8);
      tempMem8b=0;
    }
    LOG.info().$(""String_Node_Str"").utf8(name).$('\'').$();
  }
}",0.8994475138121547
30844,"private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > -1) {
        openPartitionColumns(path,columnBase);
      }
    }
 else {
      partitionSize=-1;
    }
    partitionRowCounts.setQuick(partitionIndex,partitionSize);
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > -1) {
        openPartitionColumns(path,columnBase);
        partitionRowCounts.setQuick(partitionIndex,partitionSize);
      }
    }
 else {
      partitionSize=-1;
    }
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.912280701754386
30845,"private boolean switchPartition(){
  while (partitionIndex < partitionCount) {
    final int columnBase=getColumnBase(partitionIndex);
    long partitionSize=partitionRowCounts.getQuick(partitionIndex);
    if (partitionSize == -1) {
      partitionSize=openPartition(partitionIndex++,columnBase,partitionIndex == partitionCount);
    }
 else {
      partitionIndex++;
    }
    if (partitionSize > 0) {
      record.maxRecordIndex=partitionSize - 1;
      record.recordIndex=-1;
      record.columnBase=columnBase;
      return true;
    }
  }
  return false;
}","private boolean switchPartition(){
}",0.1204013377926421
30846,"private boolean reloadInitialPartitioned(){
  if (readTxn()) {
    partitionMin=findPartitionMinimum(dateFormat);
    partitionCount=calculatePartitionCount();
    if (partitionCount > 0 && maxTimestamp != Numbers.LONG_NaN) {
      updateCapacities();
      reloadMethod=PARTITIONED_RELOAD_METHOD;
    }
    return true;
  }
  return false;
}","private boolean reloadInitialPartitioned(){
  if (readTxn()) {
    partitionMin=findPartitionMinimum(dateFormat);
    partitionCount=calculatePartitionCount();
    if (partitionCount > 0) {
      updateCapacities();
      if (maxTimestamp != Numbers.LONG_NaN) {
        reloadMethod=PARTITIONED_RELOAD_METHOD;
      }
    }
    return true;
  }
  return false;
}",0.8494318181818182
30847,"private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > 0) {
        openPartitionColumns(path,columnBase);
      }
    }
 else {
      partitionSize=0;
    }
    partitionRowCounts.setQuick(partitionIndex,partitionSize);
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition(int partitionIndex,int columnBase,boolean last){
  try {
    Path path=partitionPathGenerator.generate(this,partitionIndex);
    final long partitionSize;
    if (ff.exists(path)) {
      path.chopZ();
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize(ff,path,tempMem8b);
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > 0) {
        openPartitionColumns(path,columnBase);
      }
    }
 else {
      partitionSize=-1;
    }
    partitionRowCounts.setQuick(partitionIndex,partitionSize);
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.9979661016949152
30848,"private void testReload(int partitionBy,int count,long inct,final int testPartitionSwitch) throws Exception {
  final long increment=inct * 1000;
  CairoTestUtils.createAllTable(configuration,partitionBy);
  TestUtils.assertMemoryLeak(() -> {
    Rnd rnd=new Rnd();
    long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
    long blob=allocBlob();
    try {
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        Assert.assertFalse(reader.reload());
        assertCursor(reader,ts,increment,blob,0,null);
      }
       try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        long nextTs=testAppend(rnd,configuration,ts,count,increment,blob,0,BATCH1_GENERATOR);
        Assert.assertTrue(reader.reload());
        assertCursor(reader,ts,increment,blob,count,BATCH1_ASSERTER);
        try (TableReader reader2=new TableReader(configuration,""String_Node_Str"")){
          assertCursor(reader2,ts,increment,blob,count,BATCH1_ASSERTER);
        }
         Assert.assertFalse(reader.reload());
        nextTs=testAppend(rnd,configuration,nextTs,count,increment,blob,testPartitionSwitch,BATCH1_GENERATOR);
        assertCursor(reader,ts,increment,blob,count,BATCH1_ASSERTER);
        Assert.assertTrue(reader.reload());
        assertCursor(reader,ts,increment,blob,2 * count,BATCH1_ASSERTER);
        try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
          assertCursor(reader,ts,increment,blob,2 * count,BATCH1_ASSERTER);
          Assert.assertFalse(reader.reload());
          assertCursor(reader,ts,increment,blob,2 * count,BATCH1_ASSERTER);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH1_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertCursor(reader,ts,increment,blob,3 * count,BATCH1_ASSERTER);
          writer.addColumn(""String_Node_Str"",ColumnType.STRING);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH2_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch2(count,increment,ts,blob,reader);
          writer.addColumn(""String_Node_Str"",ColumnType.INT);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH3_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch3(count,increment,ts,blob,reader);
          writer.addColumn(""String_Node_Str"",ColumnType.SHORT);
          writer.addColumn(""String_Node_Str"",ColumnType.BOOLEAN);
          writer.addColumn(""String_Node_Str"",ColumnType.BYTE);
          writer.addColumn(""String_Node_Str"",ColumnType.FLOAT);
          writer.addColumn(""String_Node_Str"",ColumnType.DOUBLE);
          writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL);
          writer.addColumn(""String_Node_Str"",ColumnType.LONG);
          writer.addColumn(""String_Node_Str"",ColumnType.DATE);
          writer.addColumn(""String_Node_Str"",ColumnType.BINARY);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH4_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch4(count,increment,ts,blob,reader);
          if (Os.type == Os.WINDOWS) {
            reader.closeColumn(""String_Node_Str"");
          }
          writer.removeColumn(""String_Node_Str"");
          Assert.assertTrue(reader.reload());
          assertBatch5(count,increment,ts,blob,reader,new Rnd());
          testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH6_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch6(count,increment,ts,blob,reader);
          if (Os.type == Os.WINDOWS) {
            reader.closeColumn(""String_Node_Str"");
          }
          writer.removeColumn(""String_Node_Str"");
          writer.addColumn(""String_Node_Str"",ColumnType.INT);
          Assert.assertTrue(reader.reload());
          assertBatch7(count,increment,ts,blob,reader);
          Assert.assertFalse(reader.reload());
        }
       }
     }
  finally {
      freeBlob(blob);
    }
  }
);
}","private void testReload(int partitionBy,int count,long inct,final int testPartitionSwitch) throws Exception {
  final long increment=inct * 1000;
  CairoTestUtils.createAllTable(configuration,partitionBy);
  TestUtils.assertMemoryLeak(() -> {
    Rnd rnd=new Rnd();
    long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
    long blob=allocBlob();
    try {
      try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        Assert.assertFalse(reader.reload());
        assertCursor(reader,ts,increment,blob,0,null);
      }
       try (TableReader reader=new TableReader(configuration,""String_Node_Str"")){
        Assert.assertFalse(reader.reload());
        assertCursor(reader,ts,increment,blob,0,null);
        Assert.assertFalse(reader.reload());
        long nextTs=testAppend(rnd,configuration,ts,count,increment,blob,0,BATCH1_GENERATOR);
        Assert.assertTrue(reader.reload());
        assertCursor(reader,ts,increment,blob,count,BATCH1_ASSERTER);
        try (TableReader reader2=new TableReader(configuration,""String_Node_Str"")){
          assertCursor(reader2,ts,increment,blob,count,BATCH1_ASSERTER);
        }
         Assert.assertFalse(reader.reload());
        nextTs=testAppend(rnd,configuration,nextTs,count,increment,blob,testPartitionSwitch,BATCH1_GENERATOR);
        assertCursor(reader,ts,increment,blob,count,BATCH1_ASSERTER);
        Assert.assertTrue(reader.reload());
        assertCursor(reader,ts,increment,blob,2 * count,BATCH1_ASSERTER);
        try (TableWriter writer=new TableWriter(configuration,""String_Node_Str"")){
          assertCursor(reader,ts,increment,blob,2 * count,BATCH1_ASSERTER);
          Assert.assertFalse(reader.reload());
          assertCursor(reader,ts,increment,blob,2 * count,BATCH1_ASSERTER);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH1_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertCursor(reader,ts,increment,blob,3 * count,BATCH1_ASSERTER);
          writer.addColumn(""String_Node_Str"",ColumnType.STRING);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH2_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch2(count,increment,ts,blob,reader);
          writer.addColumn(""String_Node_Str"",ColumnType.INT);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH3_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch3(count,increment,ts,blob,reader);
          writer.addColumn(""String_Node_Str"",ColumnType.SHORT);
          writer.addColumn(""String_Node_Str"",ColumnType.BOOLEAN);
          writer.addColumn(""String_Node_Str"",ColumnType.BYTE);
          writer.addColumn(""String_Node_Str"",ColumnType.FLOAT);
          writer.addColumn(""String_Node_Str"",ColumnType.DOUBLE);
          writer.addColumn(""String_Node_Str"",ColumnType.SYMBOL);
          writer.addColumn(""String_Node_Str"",ColumnType.LONG);
          writer.addColumn(""String_Node_Str"",ColumnType.DATE);
          writer.addColumn(""String_Node_Str"",ColumnType.BINARY);
          nextTs=testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH4_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch4(count,increment,ts,blob,reader);
          if (Os.type == Os.WINDOWS) {
            reader.closeColumn(""String_Node_Str"");
          }
          writer.removeColumn(""String_Node_Str"");
          Assert.assertTrue(reader.reload());
          assertBatch5(count,increment,ts,blob,reader,new Rnd());
          testAppend(writer,rnd,nextTs,count,increment,blob,0,BATCH6_GENERATOR);
          Assert.assertTrue(reader.reload());
          assertBatch6(count,increment,ts,blob,reader);
          if (Os.type == Os.WINDOWS) {
            reader.closeColumn(""String_Node_Str"");
          }
          writer.removeColumn(""String_Node_Str"");
          writer.addColumn(""String_Node_Str"",ColumnType.INT);
          Assert.assertTrue(reader.reload());
          assertBatch7(count,increment,ts,blob,reader);
          Assert.assertFalse(reader.reload());
        }
       }
     }
  finally {
      freeBlob(blob);
    }
  }
);
}",0.9822282142419414
30849,"@Override protected boolean releaseAll(long deadline){
  long thread=Thread.currentThread().getId();
  boolean removed=false;
  final int reason;
  if (deadline == Long.MAX_VALUE) {
    reason=PoolConstants.CR_POOL_CLOSE;
  }
 else {
    reason=PoolConstants.CR_IDLE;
  }
  Iterator<Entry> iterator=entries.values().iterator();
  while (iterator.hasNext()) {
    Entry e=iterator.next();
    if ((deadline > e.lastReleaseTime && e.owner == UNALLOCATED)) {
      if (Unsafe.cas(e,ENTRY_OWNER,UNALLOCATED,thread)) {
        closeWriter(thread,e,PoolListener.EV_EXPIRE,reason);
        iterator.remove();
        removed=true;
        Unsafe.getUnsafe().putOrderedLong(e,ENTRY_OWNER,UNALLOCATED);
      }
    }
 else     if (e.lockFd != -1L) {
      if (ff.close(e.lockFd)) {
        e.lockFd=-1L;
        iterator.remove();
        removed=true;
      }
    }
 else     if (e.ex != null) {
      LOG.info().$(""String_Node_Str"").$();
      iterator.remove();
      removed=true;
    }
  }
  return removed;
}","@Override protected boolean releaseAll(long deadline){
  long thread=Thread.currentThread().getId();
  boolean removed=false;
  final int reason;
  if (deadline == Long.MAX_VALUE) {
    reason=PoolConstants.CR_POOL_CLOSE;
  }
 else {
    reason=PoolConstants.CR_IDLE;
  }
  Iterator<Entry> iterator=entries.values().iterator();
  while (iterator.hasNext()) {
    Entry e=iterator.next();
    if ((deadline > e.lastReleaseTime && e.owner == UNALLOCATED)) {
      if (Unsafe.cas(e,ENTRY_OWNER,UNALLOCATED,thread)) {
        closeWriter(thread,e,PoolListener.EV_EXPIRE,reason);
        iterator.remove();
        removed=true;
      }
    }
 else     if (e.lockFd != -1L) {
      if (ff.close(e.lockFd)) {
        e.lockFd=-1L;
        iterator.remove();
        removed=true;
      }
    }
 else     if (e.ex != null) {
      LOG.info().$(""String_Node_Str"").$();
      iterator.remove();
      removed=true;
    }
  }
  return removed;
}",0.963917525773196
30850,"@Test public void testAllocateAndClear() throws Exception {
  assertWithPool(pool -> {
    int n=2;
    final CyclicBarrier barrier=new CyclicBarrier(n);
    final CountDownLatch halt=new CountDownLatch(n);
    final AtomicInteger errors1=new AtomicInteger();
    final AtomicInteger errors2=new AtomicInteger();
    final AtomicInteger writerCount=new AtomicInteger();
    new Thread(() -> {
      try {
        for (int i=0; i < 1000; i++) {
          try (TableWriter ignored=pool.get(""String_Node_Str"")){
            writerCount.incrementAndGet();
          }
 catch (          EntryUnavailableException ignored) {
          }
          if (i == 1) {
            barrier.await();
          }
 else {
            LockSupport.parkNanos(1L);
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors1.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
).start();
    new Thread(() -> {
      try {
        barrier.await();
        for (int i=0; i < 1000; i++) {
          pool.releaseInactive();
          LockSupport.parkNanos(1L);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors2.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
).start();
    halt.await();
    Assert.assertTrue(writerCount.get() > 0);
    Assert.assertEquals(0,errors1.get());
    Assert.assertEquals(0,errors2.get());
  }
);
}","@Test public void testAllocateAndClear() throws Exception {
  assertWithPool(pool -> {
    int n=2;
    final CyclicBarrier barrier=new CyclicBarrier(n);
    final CountDownLatch halt=new CountDownLatch(n);
    final AtomicInteger errors1=new AtomicInteger();
    final AtomicInteger errors2=new AtomicInteger();
    final AtomicInteger writerCount=new AtomicInteger();
    new Thread(() -> {
      try {
        for (int i=0; i < 1000000; i++) {
          try (TableWriter ignored=pool.get(""String_Node_Str"")){
            writerCount.incrementAndGet();
          }
 catch (          EntryUnavailableException ignored) {
          }
          if (i == 1) {
            barrier.await();
          }
 else {
            LockSupport.parkNanos(1L);
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors1.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
).start();
    new Thread(() -> {
      try {
        barrier.await();
        for (int i=0; i < 1000000; i++) {
          pool.releaseInactive();
          LockSupport.parkNanos(1L);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors2.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
).start();
    halt.await();
    Assert.assertTrue(writerCount.get() > 0);
    Assert.assertEquals(0,errors1.get());
    Assert.assertEquals(0,errors2.get());
  }
);
}",0.9979253112033196
30851,"@Override protected boolean runSerially(){
  long t=System.currentTimeMillis();
  if (last + checkInterval < t) {
    last=t;
    return doRun();
  }
  return false;
}","@Override protected boolean runSerially(){
  long t=clock.getTicks();
  if (last + checkInterval < t) {
    last=t;
    return doRun();
  }
  return false;
}",0.9135802469135802
30852,"private void rename0(CharSequence tableName,CharSequence to){
  final FilesFacade ff=configuration.getFilesFacade();
  final CharSequence root=configuration.getRoot();
  try (Path oldName=new Path()){
    try (Path newName=new Path()){
      if (TableUtils.exists(ff,oldName,root,tableName) != TableUtils.TABLE_EXISTS) {
        LOG.error().$('\'').utf8(tableName).$(""String_Node_Str"").$();
        throw CairoException.instance(0).put(""String_Node_Str"").put(tableName).put(""String_Node_Str"");
      }
      if (Os.type == Os.WINDOWS) {
        oldName.of(""String_Node_Str"").concat(root).concat(tableName).$();
        newName.of(""String_Node_Str"").concat(root).concat(to).$();
      }
 else {
        oldName.of(root).concat(tableName).$();
        newName.of(root).concat(to).$();
      }
      if (ff.exists(newName)) {
        LOG.error().$(""String_Node_Str"").$(tableName).$(""String_Node_Str"").$(newName).$(""String_Node_Str"").$();
        throw CairoException.instance(0).put(""String_Node_Str"");
      }
      if (!getConfiguration().getFilesFacade().rename(oldName,newName)) {
        int error=ff.errno();
        LOG.error().$(""String_Node_Str"").$(oldName).$(""String_Node_Str"").$(newName).$(""String_Node_Str"").$(error).$(']').$();
        throw CairoException.instance(error).put(""String_Node_Str"");
      }
    }
   }
 }","private void rename0(CharSequence tableName,CharSequence to){
  final FilesFacade ff=configuration.getFilesFacade();
  final CharSequence root=configuration.getRoot();
  if (TableUtils.exists(ff,path,root,tableName) != TableUtils.TABLE_EXISTS) {
    LOG.error().$('\'').utf8(tableName).$(""String_Node_Str"").$();
    throw CairoException.instance(0).put(""String_Node_Str"").put(tableName).put(""String_Node_Str"");
  }
  if (Os.type == Os.WINDOWS) {
    path.of(""String_Node_Str"").concat(root).concat(tableName).$();
    other.of(""String_Node_Str"").concat(root).concat(to).$();
  }
 else {
    path.of(root).concat(tableName).$();
    other.of(root).concat(to).$();
  }
  if (ff.exists(other)) {
    LOG.error().$(""String_Node_Str"").$(tableName).$(""String_Node_Str"").$(other).$(""String_Node_Str"").$();
    throw CairoException.instance(0).put(""String_Node_Str"");
  }
  if (!ff.rename(path,other)) {
    int error=ff.errno();
    LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(other).$(""String_Node_Str"").$(error).$(']').$();
    throw CairoException.instance(error).put(""String_Node_Str"");
  }
}",0.6814449917898193
30853,"public void remove(CharSequence tableName){
  if (lock(tableName)) {
    try {
      path.of(configuration.getRoot()).concat(tableName).$();
      if (!configuration.getFilesFacade().rmdir(path)) {
        int error=configuration.getFilesFacade().errno();
        LOG.error().$(""String_Node_Str"").utf8(tableName).$(""String_Node_Str"").$(error).$(']').$();
        throw CairoException.instance(error).put(""String_Node_Str"");
      }
    }
  finally {
      unlock(tableName);
    }
  }
  throw CairoException.instance(configuration.getFilesFacade().errno()).put(""String_Node_Str"").put(tableName);
}","public void remove(CharSequence tableName){
  if (lock(tableName)) {
    try {
      path.of(configuration.getRoot()).concat(tableName).$();
      if (!configuration.getFilesFacade().rmdir(path)) {
        int error=configuration.getFilesFacade().errno();
        LOG.error().$(""String_Node_Str"").utf8(tableName).$(""String_Node_Str"").$(error).$(']').$();
        throw CairoException.instance(error).put(""String_Node_Str"");
      }
      return;
    }
  finally {
      unlock(tableName);
    }
  }
  throw CairoException.instance(configuration.getFilesFacade().errno()).put(""String_Node_Str"").put(tableName);
}",0.98841059602649
30854,"@Override protected boolean doRun(){
  return writerPool.releaseInactive() || readerPool.releaseInactive();
}","protected boolean doRun(){
  boolean w=writerPool.releaseInactive();
  boolean r=readerPool.releaseInactive();
  return w || r;
}",0.7815126050420168
30855,"public void rename(CharSequence tableName,String newName){
  lock(tableName);
  try {
    rename0(tableName,newName);
  }
  finally {
    unlock(tableName);
  }
}","public void rename(CharSequence tableName,String newName){
  if (lock(tableName)) {
    try {
      rename0(tableName,newName);
    }
  finally {
      unlock(tableName);
    }
  }
 else {
    LOG.error().$(""String_Node_Str"").$(tableName).$(""String_Node_Str"").$(newName).$(""String_Node_Str"").$();
    throw CairoException.instance(0).put(""String_Node_Str"").put(tableName).put(']');
  }
}",0.3497267759562841
30856,"public WriterMaintenanceJob(long checkInterval){
  super(checkInterval);
}","public WriterMaintenanceJob(CairoConfiguration configuration){
  this.clock=configuration.getClock();
  this.checkInterval=configuration.getIdleCheckInterval() * 1000;
}",0.5267489711934157
30857,"public Engine(CairoConfiguration configuration){
  this.configuration=configuration;
  this.writerPool=new WriterPool(configuration);
  this.readerPool=new ReaderPool(configuration);
  this.writerMaintenanceJob=new WriterMaintenanceJob(configuration.getIdleCheckInterval());
}","public Engine(CairoConfiguration configuration){
  this.configuration=configuration;
  this.writerPool=new WriterPool(configuration);
  this.readerPool=new ReaderPool(configuration);
  this.writerMaintenanceJob=new WriterMaintenanceJob(configuration);
}",0.9565217391304348
30858,"public boolean lock(CharSequence name){
  checkClosed();
  Entry e=entries.get(name);
  if (e == null) {
    LOG.info().$('\'').$(name).$(""String_Node_Str"").$();
    return true;
  }
  long thread=Thread.currentThread().getId();
  if (Unsafe.cas(e,LOCK_OWNER,UNLOCKED,thread) || Unsafe.cas(e,LOCK_OWNER,thread,thread)) {
    do {
      for (int i=0; i < ENTRY_SIZE; i++) {
        if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
          closeReader(thread,e,i,PoolListener.EV_LOCK_CLOSE,PoolConstants.CR_NAME_LOCK);
        }
 else         if (Unsafe.cas(e.allocations,i,thread,thread)) {
          if (Unsafe.arrayGet(e.readers,i) != null) {
            return false;
          }
        }
 else {
          LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(':').$(i).$(""String_Node_Str"").$(Unsafe.arrayGet(e.allocations,i)).$(""String_Node_Str"").$(thread).$(']').$();
          return false;
        }
      }
      if (e.next == null) {
        if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,NEXT_OPEN,NEXT_LOCKED)) {
          break;
        }
 else {
          if (e.next == null) {
            LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index + 1).$(':').$(0).$(""String_Node_Str"").$(""String_Node_Str"").$(thread).$(']').$();
            return false;
          }
        }
      }
      e=e.next;
    }
 while (e != null);
  }
 else {
    LOG.error().$('\'').$(name).$(""String_Node_Str"").$(e.lockOwner).$(']').$();
    notifyListener(thread,name,PoolListener.EV_LOCK_BUSY,-1,-1);
    return false;
  }
  notifyListener(thread,name,PoolListener.EV_LOCK_SUCCESS,-1,-1);
  LOG.info().$('\'').$(name).$(""String_Node_Str"").$(thread).$(']').$();
  return true;
}","public boolean lock(CharSequence name){
  checkClosed();
  Entry e=entries.get(name);
  if (e == null) {
    LOG.info().$('\'').$(name).$(""String_Node_Str"").$();
    return true;
  }
  long thread=Thread.currentThread().getId();
  if (Unsafe.cas(e,LOCK_OWNER,UNLOCKED,thread) || Unsafe.cas(e,LOCK_OWNER,thread,thread)) {
    do {
      for (int i=0; i < ENTRY_SIZE; i++) {
        if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
          closeReader(thread,e,i,PoolListener.EV_LOCK_CLOSE,PoolConstants.CR_NAME_LOCK);
        }
 else         if (Unsafe.cas(e.allocations,i,thread,thread)) {
          if (Unsafe.arrayGet(e.readers,i) != null) {
            e.lockOwner=-1L;
            return false;
          }
        }
 else {
          LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(':').$(i).$(""String_Node_Str"").$(Unsafe.arrayGet(e.allocations,i)).$(""String_Node_Str"").$(thread).$(']').$();
          e.lockOwner=-1L;
          return false;
        }
      }
      if (e.next == null) {
        if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,NEXT_OPEN,NEXT_LOCKED)) {
          break;
        }
 else {
          if (e.next == null) {
            LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index + 1).$(':').$(0).$(""String_Node_Str"").$(""String_Node_Str"").$(thread).$(']').$();
            e.lockOwner=-1L;
            return false;
          }
        }
      }
      e=e.next;
    }
 while (e != null);
  }
 else {
    LOG.error().$('\'').$(name).$(""String_Node_Str"").$(e.lockOwner).$(']').$();
    notifyListener(thread,name,PoolListener.EV_LOCK_BUSY,-1,-1);
    return false;
  }
  notifyListener(thread,name,PoolListener.EV_LOCK_SUCCESS,-1,-1);
  LOG.info().$('\'').$(name).$(""String_Node_Str"").$(thread).$(']').$();
  return true;
}",0.9759138566166052
30859,"public void unlock(CharSequence name){
  long thread=Thread.currentThread().getId();
  Entry e=entries.get(name);
  if (e == null) {
    notifyListener(thread,name,PoolListener.EV_NOT_LOCKED);
    return;
  }
  if (e.owner == thread) {
    if (e.writer != null) {
      notifyListener(thread,name,PoolListener.EV_NOT_LOCKED);
      throw new IllegalStateException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    entries.remove(name);
  }
  if (e.lockFd != -1) {
    ff.close(e.lockFd);
  }
  notifyListener(thread,name,PoolListener.EV_UNLOCKED);
}","public void unlock(CharSequence name){
  long thread=Thread.currentThread().getId();
  Entry e=entries.get(name);
  if (e == null) {
    notifyListener(thread,name,PoolListener.EV_NOT_LOCKED);
    return;
  }
  if (e.owner == thread) {
    if (e.writer != null) {
      notifyListener(thread,name,PoolListener.EV_NOT_LOCKED);
      throw CairoException.instance(0).put(""String_Node_Str"").put(name).put(""String_Node_Str"");
    }
    entries.remove(name);
  }
  if (e.lockFd != -1) {
    ff.close(e.lockFd);
  }
  notifyListener(thread,name,PoolListener.EV_UNLOCKED);
}",0.943900267141585
30860,"/** 
 * Locks writer. Locking operation is always non-blocking. Lock is usually successful when writer is in pool or owned by calling thread, in which case writer instance is closed. Lock will also succeed when writer does not exist. This will prevent from writer being created before it is unlocked. <p> Lock fails immediately with   {@link EntryUnavailableException} when writer is used by another thread and with{@link PoolClosedException} when pool is closed.</p> <p> Lock is beneficial before table directory is renamed or deleted. </p>
 * @param tableName table name
 */
public boolean lock(CharSequence tableName){
  checkClosed();
  long thread=Thread.currentThread().getId();
  Entry e=entries.get(tableName);
  if (e == null) {
    e=new Entry(clock.getTicks());
    Entry other=entries.putIfAbsent(tableName,e);
    if (other == null) {
      return lockAndNotify(thread,e,tableName);
    }
 else {
      e=other;
    }
  }
  if ((Unsafe.cas(e,ENTRY_OWNER,UNALLOCATED,thread) || Unsafe.cas(e,ENTRY_OWNER,thread,thread))) {
    closeWriter(thread,e,PoolListener.EV_LOCK_CLOSE,PoolConstants.CR_NAME_LOCK);
    return lockAndNotify(thread,e,tableName);
  }
  LOG.error().$(""String_Node_Str"").$(tableName).$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(thread).$();
  notifyListener(thread,tableName,PoolListener.EV_LOCK_BUSY);
  return false;
}","/** 
 * Locks writer. Locking operation is always non-blocking. Lock is usually successful when writer is in pool or owned by calling thread, in which case writer instance is closed. Lock will also succeed when writer does not exist. This will prevent from writer being created before it is unlocked. <p> Lock fails immediately with   {@link EntryUnavailableException} when writer is used by another thread and with{@link PoolClosedException} when pool is closed.</p> <p> Lock is beneficial before table directory is renamed or deleted. </p>
 * @param tableName table name
 */
public boolean lock(CharSequence tableName){
  checkClosed();
  long thread=Thread.currentThread().getId();
  Entry e=entries.get(tableName);
  if (e == null) {
    e=new Entry(clock.getTicks());
    Entry other=entries.putIfAbsent(tableName,e);
    if (other == null) {
      return lockAndNotify(thread,e,tableName);
    }
 else {
      e=other;
    }
  }
  if ((Unsafe.cas(e,ENTRY_OWNER,UNALLOCATED,thread))) {
    closeWriter(thread,e,PoolListener.EV_LOCK_CLOSE,PoolConstants.CR_NAME_LOCK);
    return lockAndNotify(thread,e,tableName);
  }
  LOG.error().$(""String_Node_Str"").$(tableName).$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(thread).$();
  notifyListener(thread,tableName,PoolListener.EV_LOCK_BUSY);
  return false;
}",0.9839372431826672
30861,"public TableReader getReader(CharSequence tableName){
  return readerPool.getReader(tableName);
}","public TableReader getReader(CharSequence tableName){
  return readerPool.get(tableName);
}",0.9680851063829788
30862,"public TableWriter getWriter(CharSequence tableName){
  return writerPool.getWriter(tableName);
}","public TableWriter getWriter(CharSequence tableName){
  return writerPool.get(tableName);
}",0.9680851063829788
30863,"@Override public int getInt(long offset){
  return 0;
}","@Override public int getInt(long offset){
  return Numbers.INT_NaN;
}",0.8709677419354839
30864,"@Override public int getInt(int col){
  long index=getIndex(col);
  if (index < 0) {
    return 0;
  }
  return colA(col).getInt(index * 4);
}","@Override public int getInt(int col){
  long index=getIndex(col);
  if (index < 0) {
    return Numbers.INT_NaN;
  }
  return colA(col).getInt(index * 4);
}",0.9463087248322148
30865,"static void resetTxn(VirtualMemory txMem){
  txMem.putLong(-1);
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(0);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(TX_EOF);
}","public static void resetTxn(VirtualMemory txMem){
  txMem.putLong(-1);
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(0);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(TX_EOF);
}",0.9881154499151104
30866,"public TableWriter(FilesFacade ff,CharSequence root,CharSequence name,int mkDirMode,int fileOperationRetryCount){
  LOG.info().$(""String_Node_Str"").$(name).$('\'').$();
  this.ff=ff;
  this.mkDirMode=mkDirMode;
  this.fileOperationRetryCount=fileOperationRetryCount;
  this.path=new CompositePath().of(root).concat(name);
  this.other=new CompositePath().of(root).concat(name);
  this.name=ImmutableCharSequence.of(name);
  this.rootLen=path.length();
  try {
    this.txMem=openTxnFile();
    try {
      this.lockFd=TableUtils.lock(ff,path);
    }
  finally {
      path.trimTo(rootLen);
    }
    if (this.lockFd == -1L) {
      throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path.$());
    }
    this.txMem.jumpTo(TableUtils.TX_EOF);
    long todo=readTodoTaskCode();
    if (todo != -1L) {
switch ((int)(todo & 0xff)) {
case TableUtils.TODO_TRUNCATE:
        repairTruncate();
      break;
case TableUtils.TODO_RESTORE_META:
    repairMetaRename((int)(todo >> 8));
  break;
default :
LOG.error().$(""String_Node_Str"").$(todo).$();
break;
}
}
this.ddlMem=new AppendMemory();
this.metaMem=new ReadOnlyMemory();
openMetaFile();
this.metadata=new TableWriterMetadata(ff,metaMem);
this.columnCount=metadata.getColumnCount();
this.partitionBy=metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY);
this.columnSizeMem=new VirtualMemory(ff.getPageSize());
this.refs.extendAndSet(columnCount,0);
this.columns=new ObjList<>(columnCount);
this.nullers=new ObjList<>(columnCount);
this.columnTops=new LongList(columnCount);
this.partitionDirFmt=selectPartitionDirFmt(partitionBy);
configureColumnMemory();
timestampSetter=configureTimestampSetter();
configureAppendPosition();
purgeUnusedPartitions();
}
 catch (CairoException e) {
LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$((Sinkable)e).$('}').$();
close();
throw e;
}
}","public TableWriter(FilesFacade ff,CharSequence root,CharSequence name,int mkDirMode,int fileOperationRetryCount){
  LOG.info().$(""String_Node_Str"").$(name).$('\'').$();
  this.ff=ff;
  this.mkDirMode=mkDirMode;
  this.fileOperationRetryCount=fileOperationRetryCount;
  this.path=new CompositePath().of(root).concat(name);
  this.other=new CompositePath().of(root).concat(name);
  this.name=ImmutableCharSequence.of(name);
  this.rootLen=path.length();
  try {
    try {
      this.lockFd=TableUtils.lock(ff,path);
    }
  finally {
      path.trimTo(rootLen);
    }
    if (this.lockFd == -1L) {
      throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path.$());
    }
    this.txMem=openTxnFile();
    this.txMem.jumpTo(TableUtils.TX_EOF);
    long todo=readTodoTaskCode();
    if (todo != -1L) {
switch ((int)(todo & 0xff)) {
case TableUtils.TODO_TRUNCATE:
        repairTruncate();
      break;
case TableUtils.TODO_RESTORE_META:
    repairMetaRename((int)(todo >> 8));
  break;
default :
LOG.error().$(""String_Node_Str"").$(todo).$();
break;
}
}
this.ddlMem=new AppendMemory();
this.metaMem=new ReadOnlyMemory();
openMetaFile();
this.metadata=new TableWriterMetadata(ff,metaMem);
this.columnCount=metadata.getColumnCount();
this.partitionBy=metaMem.getInt(TableUtils.META_OFFSET_PARTITION_BY);
this.columnSizeMem=new VirtualMemory(ff.getPageSize());
this.refs.extendAndSet(columnCount,0);
this.columns=new ObjList<>(columnCount);
this.nullers=new ObjList<>(columnCount);
this.columnTops=new LongList(columnCount);
this.partitionDirFmt=selectPartitionDirFmt(partitionBy);
configureColumnMemory();
timestampSetter=configureTimestampSetter();
configureAppendPosition();
purgeUnusedPartitions();
}
 catch (CairoException e) {
LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$((Sinkable)e).$('}').$();
close();
throw e;
}
}",0.9838187702265372
30867,"private void cancelRow(){
  if ((masterRef & 1) == 0) {
    return;
  }
  if (transientRowCount == 0) {
    if (partitionBy != PartitionBy.NONE) {
      closeColumns(false);
      if (removeDirOnCancelRow) {
        try {
          setStateForTimestamp(maxTimestamp,false);
          if (!ff.rmdir(path.$())) {
            throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
          }
          removeDirOnCancelRow=false;
        }
  finally {
          path.trimTo(rootLen);
        }
      }
      if (prevTimestamp > Long.MIN_VALUE) {
        try {
          columnSizeMem.jumpTo((txPartitionCount - 2) * 16);
          openPartition(prevTimestamp);
          setAppendPosition(prevTransientRowCount);
          txPartitionCount--;
        }
 catch (        CairoException e) {
          closeColumns(false);
          throw e;
        }
      }
 else {
        rowFunction=openPartitionFunction;
      }
      transientRowCount=prevTransientRowCount;
      fixedRowCount-=prevTransientRowCount;
      maxTimestamp=prevTimestamp;
      removeDirOnCancelRow=true;
    }
 else {
      for (int i=0; i < columnCount; i++) {
        getPrimaryColumn(i).jumpTo(0);
        AppendMemory mem=getSecondaryColumn(i);
        if (mem != null) {
          mem.jumpTo(0);
        }
      }
    }
  }
 else {
    maxTimestamp=prevTimestamp;
    boolean rowChanged=false;
    for (int i=0; i < columnCount; i++) {
      if (refs.getQuick(i) == masterRef) {
        rowChanged=true;
        break;
      }
    }
    if (rowChanged) {
      setAppendPosition(transientRowCount);
    }
  }
  masterRef--;
}","private void cancelRow(){
  if ((masterRef & 1) == 0) {
    return;
  }
  if (transientRowCount == 0) {
    if (partitionBy != PartitionBy.NONE) {
      closeColumns(false);
      if (removeDirOnCancelRow) {
        try {
          setStateForTimestamp(maxTimestamp,false);
          if (!ff.rmdir(path.$())) {
            throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
          }
          removeDirOnCancelRow=false;
        }
  finally {
          path.trimTo(rootLen);
        }
      }
      if (prevTimestamp > Long.MIN_VALUE) {
        try {
          columnSizeMem.jumpTo((txPartitionCount - 2) * 16);
          openPartition(prevTimestamp);
          setAppendPosition(prevTransientRowCount);
          txPartitionCount--;
        }
 catch (        CairoException e) {
          closeColumns(false);
          throw e;
        }
      }
 else {
        rowFunction=openPartitionFunction;
      }
      transientRowCount=prevTransientRowCount;
      fixedRowCount-=prevTransientRowCount;
      maxTimestamp=prevTimestamp;
      removeDirOnCancelRow=true;
    }
 else {
      maxTimestamp=prevTimestamp;
      for (int i=0; i < columnCount; i++) {
        getPrimaryColumn(i).setSize(0);
        AppendMemory mem=getSecondaryColumn(i);
        if (mem != null) {
          mem.setSize(0);
        }
      }
    }
  }
 else {
    maxTimestamp=prevTimestamp;
    boolean rowChanged=false;
    for (int i=0; i < columnCount; i++) {
      if (refs.getQuick(i) == masterRef) {
        rowChanged=true;
        break;
      }
    }
    if (rowChanged) {
      setAppendPosition(transientRowCount);
    }
  }
  refs.fill(0,columnCount,--masterRef);
}",0.9669596847529556
30868,"public void putStr(int index,CharSequence value){
  getSecondaryColumn(index).putLong(getPrimaryColumn(index).putStr(value));
  notNull(index);
}","public void putStr(int index,CharSequence value,int pos,int len){
  getSecondaryColumn(index).putLong(getPrimaryColumn(index).putStr(value,pos,len));
  notNull(index);
}",0.9235668789808916
30869,"private LongConsumer configureTimestampSetter(){
  int index=metadata.getTimestampIndex();
  if (index == -1) {
    return value -> {
    }
;
  }
 else {
    return getPrimaryColumn(index)::putLong;
  }
}","private LongConsumer configureTimestampSetter(){
  int index=metadata.getTimestampIndex();
  if (index == -1) {
    return value -> {
    }
;
  }
 else {
    nullers.setQuick(index,NOOP);
    return getPrimaryColumn(index)::putLong;
  }
}",0.9230769230769232
30870,"private void clearPages(){
  int n=pages.size();
  if (n > 0) {
    for (int i=0; i < n; i++) {
      release(i,pages.getQuick(i));
    }
  }
  pages.clear();
}","private void clearPages(){
  int n=pages.size();
  if (n > 0) {
    for (int i=0; i < n; i++) {
      release(i,pages.getQuick(i));
    }
  }
  pages.erase();
}",0.98125
30871,"private void putStrSplit(CharSequence value,int len){
  int start=0;
  do {
    int half=(int)((pageHi - appendPointer) / 2);
    if (len <= half) {
      copyStrChars(value,start,len,appendPointer);
      appendPointer+=len * 2;
      break;
    }
    copyStrChars(value,start,half,appendPointer);
    if (half * 2 < pageHi - appendPointer) {
      putSplitChar(value.charAt(start + half++));
    }
 else {
      pageAt(getAppendOffset() + half * 2);
    }
    len-=half;
    start+=half;
  }
 while (true);
}","private void putStrSplit(CharSequence value,int pos,int len){
  int start=pos;
  do {
    int half=(int)((pageHi - appendPointer) / 2);
    if (len <= half) {
      copyStrChars(value,start,len,appendPointer);
      appendPointer+=len * 2;
      break;
    }
    copyStrChars(value,start,half,appendPointer);
    if (half * 2 < pageHi - appendPointer) {
      putSplitChar(value.charAt(start + half++));
    }
 else {
      pageAt(getAppendOffset() + half * 2);
    }
    len-=half;
    start+=half;
  }
 while (true);
}",0.9883495145631068
30872,"public final long putStr(CharSequence value){
  final long offset=getAppendOffset();
  if (value == null) {
    putInt(-1);
    return offset;
  }
  int l=value.length();
  putInt(l);
  if (pageHi - appendPointer < l * 2) {
    putStrSplit(value,l);
  }
 else {
    copyStrChars(value,0,l,appendPointer);
    appendPointer+=l * 2;
  }
  return offset;
}","public final long putStr(CharSequence value,int pos,int len){
  if (value == null) {
    return putNullStr();
  }
  final long offset=getAppendOffset();
  putInt(len);
  if (pageHi - appendPointer < len * 2) {
    putStrSplit(value,pos,len);
  }
 else {
    copyStrChars(value,pos,len,appendPointer);
    appendPointer+=len * 2;
  }
  return offset;
}",0.7443181818181818
30873,"@Override protected void release(long address){
  ff.munmap(address,pageSize);
}","@Override protected void release(int page,long address){
  ff.munmap(address,getPageSize(page));
}",0.8876404494382022
30874,"private void releaseCurrentPage(){
  if (pageAddress != 0) {
    release(pageAddress);
    pageAddress=0;
  }
}","private void releaseCurrentPage(){
  if (pageAddress != 0) {
    release(0,pageAddress);
    pageAddress=0;
  }
}",0.9910714285714286
30875,"public void truncate(){
  if (fd == -1) {
    return;
  }
  this.size=0;
  releaseCurrentPage();
  if (!ff.truncate(fd,pageSize)) {
    throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(pageSize).put(""String_Node_Str"");
  }
  updateLimits(0,pageAddress=mapPage(0));
}","public void truncate(){
  if (fd == -1) {
    return;
  }
  this.size=0;
  releaseCurrentPage();
  if (!ff.truncate(fd,getMapPageSize())) {
    throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(getMapPageSize()).put(""String_Node_Str"");
  }
  updateLimits(0,pageAddress=mapPage(0));
}",0.9692307692307692
30876,"private long mapPage(int page){
  long target=pageOffset(page + 1);
  if (ff.length(fd) < target && !ff.truncate(fd,target)) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(target);
  }
  long offset=pageOffset(page);
  long address=ff.mmap(fd,pageSize,offset,Files.MAP_RW);
  if (address == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(offset).put(""String_Node_Str"").put(pageSize);
  }
  return address;
}","private long mapPage(int page){
  long target=pageOffset(page + 1);
  if (ff.length(fd) < target && !ff.truncate(fd,target)) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(target);
  }
  long offset=pageOffset(page);
  long address=ff.mmap(fd,getMapPageSize(),offset,Files.MAP_RW);
  if (address == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(offset).put(""String_Node_Str"").put(getMapPageSize());
  }
  return address;
}",0.9813780260707636
30877,"@Override protected void release(long address){
  ff.munmap(address,pageSize);
}","@Override protected void release(int page,long address){
  if (address != 0) {
    ff.munmap(address,getPageSize(page));
    if (page == lastPageIndex) {
      lastPageSize=getMapPageSize();
    }
  }
}",0.5602836879432624
30878,"private long mapPage(int page){
  long address;
  long offset=pageOffset(page);
  long sz=size - offset;
  if (sz > 0) {
    if (sz > pageSize) {
      sz=pageSize;
    }
 else {
      this.lastPageSize=sz;
    }
    address=ff.mmap(fd,sz,offset,Files.MAP_RO);
  }
 else {
    address=-1L;
  }
  if (address == -1L) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(offset).put(""String_Node_Str"").put(sz);
  }
  cachePageAddress(page,address);
  return address;
}","private long mapPage(int page){
  long address;
  long offset=pageOffset(page);
  long sz=size - offset;
  if (sz > 0) {
    if (sz >= getMapPageSize()) {
      sz=getMapPageSize();
    }
 else {
      this.lastPageSize=sz;
      this.lastPageIndex=page;
    }
    address=ff.mmap(fd,sz,offset,Files.MAP_RO);
    if (address == -1L) {
      throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(offset).put(""String_Node_Str"").put(sz);
    }
    return cachePageAddress(page,address);
  }
  throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(offset).put(""String_Node_Str"").put(sz);
}",0.7324414715719063
30879,"private void setInitialSize(long size){
  long targetPageSize;
  if (size > maxPageSize) {
    targetPageSize=maxPageSize;
  }
 else {
    targetPageSize=Math.max(ff.getPageSize(),(size / ff.getPageSize()) * ff.getPageSize());
  }
  if (targetPageSize != pageSize) {
    setPageSize(targetPageSize);
    pages.ensureCapacity((int)(size / this.pageSize + 1));
    this.lastPageSize=targetPageSize;
  }
  this.size=size;
}","private void setInitialSize(long size){
  long targetPageSize;
  if (size > maxPageSize) {
    targetPageSize=maxPageSize;
  }
 else {
    targetPageSize=Math.max(ff.getPageSize(),(size / ff.getPageSize()) * ff.getPageSize());
  }
  if (targetPageSize != getMapPageSize()) {
    setPageSize(targetPageSize);
    pages.ensureCapacity((int)(size / getMapPageSize() + 1));
    this.lastPageSize=targetPageSize < size ? targetPageSize : size;
  }
 else {
    this.lastPageSize=targetPageSize;
  }
  this.size=size;
}",0.8540772532188842
30880,"@Override public void trackFileSize(){
  long size=ff.length(fd);
  if (size < this.size) {
    setInitialSize(size);
  }
 else   if (size > this.size && lastPageSize < pageSize) {
    pages.ensureCapacity((int)(size / this.pageSize + 1));
    int lastIndex=pages.size() - 1;
    if (lastIndex > -1) {
      long address=pages.getQuick(lastIndex);
      if (address != 0) {
        releaseLast(address);
        pages.setQuick(lastIndex,0);
      }
      clearHotPage();
    }
    this.size=size;
  }
}","@Override public void trackFileSize(){
  long size=ff.length(fd);
  if (size < this.size) {
    setInitialSize(size);
  }
 else   if (size > this.size) {
    pages.ensureCapacity((int)(size / getMapPageSize() + 1));
    if (lastPageSize < getMapPageSize()) {
      int lastIndex=pages.size() - 1;
      if (lastIndex > -1) {
        long address=pages.getQuick(lastIndex);
        if (address != 0) {
          release(lastIndex,address);
          pages.setQuick(lastIndex,0);
        }
        clearHotPage();
      }
      this.lastPageIndex=0;
      this.lastPageSize=getMapPageSize();
    }
    this.size=size;
  }
}",0.7195013357079252
30881,"@Override protected void release(long address){
  ff.munmap(address,pageSize);
}","@Override protected void release(int page,long address){
  ff.munmap(address,getPageSize(page));
}",0.8876404494382022
30882,"@Override protected long allocateNextPage(int page){
  return mapPage(page);
}","@Override protected long allocateNextPage(int page){
  long address;
  long offset=pageOffset(page);
  final long pageSize=getMapPageSize();
  if (ff.length(fd) < offset + pageSize) {
    ff.truncate(fd,offset + pageSize);
  }
  address=ff.mmap(fd,pageSize,offset,Files.MAP_RW);
  if (address == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(offset).put(""String_Node_Str"").put(pageSize);
  }
  return address;
}",0.2097649186256781
30883,"@Override protected long getPageAddress(int page){
  long address;
  if (page < pages.size()) {
    address=pages.getQuick(page);
    if (address != 0) {
      return address;
    }
  }
  address=mapPage(page);
  cachePageAddress(page,address);
  return address;
}","@Override protected long getPageAddress(int page){
  return mapWritePage(page);
}",0.4405797101449275
30884,"protected final void configurePageSize(long size,long defaultPageSize,long maxPageSize){
  if (size > maxPageSize) {
    setPageSize(maxPageSize);
  }
 else {
    setPageSize(Math.max(defaultPageSize,(size / ff.getPageSize()) * ff.getPageSize()));
  }
  pages.ensureCapacity((int)(size / this.pageSize + 1));
  this.size=size;
}","protected final void configurePageSize(long size,long defaultPageSize,long maxPageSize){
  if (size > maxPageSize) {
    setPageSize(maxPageSize);
  }
 else {
    setPageSize(Math.max(defaultPageSize,(size / ff.getPageSize()) * ff.getPageSize()));
  }
  pages.ensureCapacity((int)(size / getMapPageSize() + 1));
  this.size=size;
}",0.8983308042488619
30885,"static void resetTxn(VirtualMemory txMem){
  txMem.putLong(-1);
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(0);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(32);
}","static void resetTxn(VirtualMemory txMem){
  txMem.putLong(-1);
  txMem.putLong(0);
  txMem.putLong(0);
  txMem.putLong(Long.MIN_VALUE);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(0);
  txMem.putLong(0);
  Unsafe.getUnsafe().storeFence();
  txMem.jumpTo(TX_EOF);
}",0.986159169550173
30886,"public void of(LPSZ name){
  close();
  boolean exists=ff.exists(name);
  if (!exists) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  fd=ff.openRO(name);
  if (fd == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(']').$();
  this.lastPageSize=ff.getPageSize();
}","public void of(LPSZ name){
  close();
  boolean exists=ff.exists(name);
  if (!exists) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(name);
  }
  fd=ff.openRO(name);
  if (fd == -1) {
    throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(']').$();
}",0.9511568123393316
30887,"private void openPartitionColumns(int columnIndex,long partitionSize,long[] columnTops){
  int plen=path.length();
  try {
    for (int i=0; i < columnCount; i++) {
      if (columns.getQuick(columnIndex + i * 2) == null) {
        String name=metadata.getColumnName(i);
        if (ff.exists(TableWriter.dFile(path.trimTo(plen),name))) {
          ReadOnlyMemory mem1=new ReadOnlyMemory(ff);
          mem1.of(path);
          columns.setQuick(columnIndex + i * 2,mem1);
switch (metadata.getColumnQuick(i).getType()) {
case ColumnType.STRING:
case ColumnType.SYMBOL:
            columns.setQuick(columnIndex + i * 2 + 1,openIndexColumn(TableWriter.iFile(path.trimTo(plen),name),mem1,partitionSize,4));
          break;
case ColumnType.BINARY:
        columns.setQuick(columnIndex + i * 2 + 1,openIndexColumn(TableWriter.iFile(path.trimTo(plen),name),mem1,partitionSize,8));
      break;
case ColumnType.LONG:
case ColumnType.DOUBLE:
case ColumnType.DATE:
    mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize * 8);
  break;
case ColumnType.INT:
case ColumnType.FLOAT:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize * 4);
break;
case ColumnType.SHORT:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize * 2);
break;
case ColumnType.BOOLEAN:
case ColumnType.BYTE:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize);
break;
default :
throw CairoException.instance(0).put(""String_Node_Str"").put(ColumnType.nameOf(metadata.getColumnQuick(i).getType()));
}
columnTops[i]=readColumnTop(ff,path,name,plen);
}
}
}
}
  finally {
path.trimTo(plen);
}
}","private void openPartitionColumns(int columnBase,long partitionSize,long[] columnTops){
  int plen=path.length();
  try {
    for (int i=0; i < columnCount; i++) {
      if (columns.getQuick(getPrimaryColumnIndex(columnBase,i)) == null) {
        String name=metadata.getColumnName(i);
        if (ff.exists(TableWriter.dFile(path.trimTo(plen),name))) {
          ReadOnlyMemory mem1=new ReadOnlyMemory(ff);
          ReadOnlyMemory mem2;
          long offset;
          long len;
          mem1.of(path);
          columns.setQuick(getPrimaryColumnIndex(columnBase,i),mem1);
switch (metadata.getColumnQuick(i).getType()) {
case ColumnType.STRING:
case ColumnType.SYMBOL:
            mem2=new ReadOnlyMemory(ff,TableWriter.iFile(path.trimTo(plen),name),TableWriter.getMapPageSize(ff),partitionSize * 8);
          offset=mem2.getLong((partitionSize - 1) * 8);
        if (ff.read(mem1.getFd(),tempMem8b,4,offset) != 4) {
          throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(mem2.getFd()).put(""String_Node_Str"").put(offset);
        }
      len=Unsafe.getUnsafe().getInt(tempMem8b);
    if (len == -1) {
      mem1.setSize(TableWriter.getMapPageSize(ff),offset + 4);
    }
 else {
      mem1.setSize(TableWriter.getMapPageSize(ff),offset + len + 4);
    }
  columns.setQuick(getSecondaryColumnIndex(columnBase,i),mem2);
break;
case ColumnType.BINARY:
mem2=new ReadOnlyMemory(ff,TableWriter.iFile(path.trimTo(plen),name),TableWriter.getMapPageSize(ff),partitionSize * 8);
offset=mem2.getLong((partitionSize - 1) * 8);
if (ff.read(mem1.getFd(),tempMem8b,8,offset) != 8) {
throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(mem2.getFd()).put(""String_Node_Str"").put(offset);
}
len=Unsafe.getUnsafe().getLong(tempMem8b);
if (len == -1) {
mem1.setSize(TableWriter.getMapPageSize(ff),offset + 8);
}
 else {
mem1.setSize(TableWriter.getMapPageSize(ff),offset + len + 8);
}
columns.setQuick(getSecondaryColumnIndex(columnBase,i),mem2);
break;
case ColumnType.LONG:
case ColumnType.DOUBLE:
case ColumnType.DATE:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize * 8);
break;
case ColumnType.INT:
case ColumnType.FLOAT:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize * 4);
break;
case ColumnType.SHORT:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize * 2);
break;
case ColumnType.BOOLEAN:
case ColumnType.BYTE:
mem1.setSize(TableWriter.getMapPageSize(ff),partitionSize);
break;
default :
throw CairoException.instance(0).put(""String_Node_Str"").put(ColumnType.nameOf(metadata.getColumnQuick(i).getType()));
}
columnTops[i]=readColumnTop(ff,path,name,plen);
}
}
}
}
  finally {
path.trimTo(plen);
}
}",0.6293673276676109
30888,"public TableReader(FilesFacade ff,CharSequence root,CharSequence name){
  this.ff=ff;
  this.path=new CompositePath().of(root).concat(name);
  this.rootLen=path.length();
  failOnPendingTodo();
  this.txMem=openTxnFile();
  this.metaMem=new ReadOnlyMemory(ff);
  openMetaFile();
  this.columnCount=metaMem.getInt(META_OFFSET_COUNT);
  this.columnBlockSize=Numbers.ceilPow2(this.columnCount);
  this.partitionBy=metaMem.getInt(META_OFFSET_PARTITION_BY);
  this.timestampIndex=metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);
  this.metadata=new Meta(columnCount);
  this.partitionDirFmt=TableWriter.selectPartitionDirFmt(partitionBy);
  countPartitions();
  int columnListCapacity=(this.partitionCount == 1 ? columnCount : columnBlockSize * partitionCount) * 2;
  this.columns=new ObjList<>(columnListCapacity);
  columns.extendAndSet(columnListCapacity - 1,null);
  this.partitionSizes=new LongList(partitionCount);
  this.partitionSizes.seed(partitionCount,-1);
  readTx();
  this.columnTops=new long[columnCount];
}","public TableReader(FilesFacade ff,CharSequence root,CharSequence name){
  this.ff=ff;
  this.path=new CompositePath().of(root).concat(name);
  this.rootLen=path.length();
  failOnPendingTodo();
  this.txMem=openTxnFile();
  this.metaMem=new ReadOnlyMemory(ff);
  openMetaFile();
  this.columnCount=metaMem.getInt(META_OFFSET_COUNT);
  this.columnCountBits=Numbers.msb(Numbers.ceilPow2(this.columnCount) * 2);
  this.partitionBy=metaMem.getInt(META_OFFSET_PARTITION_BY);
  this.timestampIndex=metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);
  this.metadata=new Meta(columnCount);
  this.partitionDirFmt=TableWriter.selectPartitionDirFmt(partitionBy);
  countPartitions();
  int columnListCapacity=(this.partitionCount == 1 ? columnCount * 2 : partitionCount << columnCountBits);
  this.columns=new ObjList<>(columnListCapacity);
  columns.extendAndSet(columnListCapacity - 1,null);
  this.partitionSizes=new LongList(partitionCount);
  this.partitionSizes.seed(partitionCount,-1);
  readTx();
  this.columnTops=new long[columnCount];
}",0.9471624266144814
30889,"@Override public void recordAt(Record record,long atRowId){
}","@Override public void recordAt(Record record,long rowId){
  TableRecord rec=(TableRecord)record;
  rec.columnBase=Rows.toPartitionIndex(rowId) << columnCountBits;
  rec.recordIndex=Rows.toLocalRowID(rowId);
}",0.4312267657992565
30890,"private long openPartition(int columnIndex,long partitionTimestamp,boolean last,long[] columnTops){
  try {
    partitionDirFmt.format(partitionTimestamp,DateLocaleFactory.INSTANCE.getDefaultDateLocale(),null,path.put(Path.SEPARATOR));
    final long partitionSize;
    if (ff.exists(path.$())) {
      path.trimTo(path.length());
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize();
      }
      if (partitionSize > 0) {
        openPartitionColumns(columnIndex,partitionSize,columnTops);
      }
    }
 else {
      partitionSize=0;
    }
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}","private long openPartition(int columnBase,long partitionTimestamp,boolean last,long[] columnTops){
  try {
    partitionDirFmt.format(partitionTimestamp,DateLocaleFactory.INSTANCE.getDefaultDateLocale(),null,path.put(Path.SEPARATOR));
    final long partitionSize;
    if (ff.exists(path.$())) {
      path.trimTo(path.length());
      if (last) {
        partitionSize=transientRowCount;
      }
 else {
        partitionSize=readPartitionSize();
      }
      LOG.info().$(""String_Node_Str"").$(path.$()).$(""String_Node_Str"").$(partitionSize).$(']').$();
      if (partitionSize > 0) {
        openPartitionColumns(columnBase,partitionSize,columnTops);
      }
    }
 else {
      partitionSize=0;
    }
    return partitionSize;
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.9190672153635115
30891,"@Override public Record next(TableReader reader){
  if (++reader.recordIndex < reader.maxRecordIndex) {
    return reader.record;
  }
 else {
    reader.currentRecordFunction=nextPartitionFunction;
    reader.partitionIndex++;
    return reader.record;
  }
}","@Override public Record next(TableReader reader){
  TableReader.TableRecord rec=reader.record;
  if (++rec.recordIndex < rec.maxRecordIndex) {
    return rec;
  }
 else {
    reader.currentRecordFunction=nextPartitionFunction;
    reader.partitionIndex++;
    return rec;
  }
}",0.8523364485981308
30892,"@Override public long getRowId(){
  return 0;
}","@Override public long getRowId(){
  return Rows.toRowID(columnBase >>> columnCountBits,recordIndex);
}",0.6174496644295302
30893,"@Override public void close(){
  Misc.free(path);
  Misc.free(metaMem);
  Misc.free(txMem);
  for (int i=0, n=columns.size(); i < n; i++) {
    VirtualMemory mem=columns.getQuick(i);
    if (mem != null) {
      mem.close();
    }
  }
}","@Override public void close(){
  Misc.free(path);
  Misc.free(metaMem);
  Misc.free(txMem);
  for (int i=0, n=columns.size(); i < n; i++) {
    VirtualMemory mem=columns.getQuick(i);
    if (mem != null) {
      mem.close();
    }
  }
  if (tempMem8b != 0) {
    Unsafe.free(tempMem8b,8);
    tempMem8b=0;
  }
}",0.8628884826325411
30894,"private ReadOnlyMemory colB(int col){
  return columns.getQuick(baseColumnIndex + col * 2 + 1);
}","private ReadOnlyMemory colB(int col){
  return columns.getQuick(columnBase + col * 2 + 1);
}",0.9312169312169312
30895,"private ReadOnlyMemory colA(int col){
  return columns.getQuick(baseColumnIndex + col * 2);
}","private ReadOnlyMemory colA(int col){
  return columns.getQuick(columnBase + col * 2);
}",0.9281767955801103
30896,"@Override public Record newRecord(){
  return null;
}","@Override public Record newRecord(){
  return new TableRecord();
}",0.8571428571428571
30897,"private void readTx(){
  while (true) {
    long txn=txMem.getLong(TableWriter.TX_OFFSET_TXN);
    if (txn == this.txn) {
      break;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableWriter.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableWriter.TX_OFFSET_FIXED_ROW_COUNT);
    long maxTimestamp=txMem.getLong(TableWriter.TX_OFFSET_MAX_TIMESTAMP);
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableWriter.TX_OFFSET_TXN)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.size=fixedRowCount + transientRowCount;
      break;
    }
    LockSupport.parkNanos(1);
  }
}","private void readTx(){
  while (true) {
    long txn=txMem.getLong(TableWriter.TX_OFFSET_TXN);
    if (txn == this.txn) {
      break;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableWriter.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableWriter.TX_OFFSET_FIXED_ROW_COUNT);
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableWriter.TX_OFFSET_TXN)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.size=fixedRowCount + transientRowCount;
      break;
    }
    LockSupport.parkNanos(1);
  }
}",0.9425465838509316
30898,"@Test public void testStringHash() throws Exception {
  Rnd rnd=new Rnd();
  IntHashSet hashes=new IntHashSet(100000);
  final int LEN=30;
  long address=Unsafe.malloc(LEN);
  for (int i=0; i < 100000; i++) {
    rnd.nextChars(address,LEN);
    hashes.add(Hash.hashMem(address,LEN));
  }
  Assert.assertTrue(""String_Node_Str"",hashes.size() > 99990);
}","@Test public void testStringHash() throws Exception {
  Rnd rnd=new Rnd();
  IntHashSet hashes=new IntHashSet(100000);
  final int LEN=64;
  long address=Unsafe.malloc(LEN);
  for (int i=0; i < 100000; i++) {
    rnd.nextChars(address,LEN / 2);
    hashes.add(Hash.hashMem(address,LEN));
  }
  Assert.assertTrue(""String_Node_Str"",hashes.size() > 99990);
}",0.9886685552407932
30899,"@Test public void testAddColumnTopFileWriteFail() throws Exception {
  testAddColumnRecoverableFault(new FilesFacadeImpl(){
    long fd=-1;
    @Override public long append(    long fd,    long buf,    int len){
      if (this.fd == fd) {
        return -1;
      }
      return super.append(fd,buf,len);
    }
    @Override public long openAppend(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openAppend(name);
      }
      return super.openAppend(name);
    }
  }
);
}","@Test public void testAddColumnTopFileWriteFail() throws Exception {
  testAddColumnRecoverableFault(new FilesFacadeImpl(){
    long fd=-1;
    @Override public long append(    long fd,    long buf,    int len){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.append(fd,buf,len);
    }
    @Override public long openAppend(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openAppend(name);
      }
      return super.openAppend(name);
    }
  }
);
}",0.9715370018975332
30900,"@Test public void testRemoveColumnCannotMMapSwap() throws Exception {
class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.META_SWAP_FILE_NAME)) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long mmap(    long fd,    long len,    long offset,    int mode){
      if (fd == this.fd) {
        return -1;
      }
      return super.mmap(fd,len,offset,mode);
    }
  }
  testRemoveColumn(new X());
}","@Test public void testRemoveColumnCannotMMapSwap() throws Exception {
class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.META_SWAP_FILE_NAME)) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long mmap(    long fd,    long len,    long offset,    int mode){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.mmap(fd,len,offset,mode);
    }
  }
  testRemoveColumn(new X());
}",0.9694244604316546
30901,"@Test public void testCannotSetAppendPositionOnIndexFile() throws Exception {
  create(FF,PartitionBy.NONE);
  populateTable0(FF);
  testConstructor(new FilesFacadeImpl(){
    long fd;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
,false);
}","@Test public void testCannotSetAppendPositionOnIndexFile() throws Exception {
  create(FF,PartitionBy.NONE);
  populateTable0(FF);
  testConstructor(new FilesFacadeImpl(){
    long fd;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
,false);
}",0.9709401709401708
30902,"@Test public void testRemoveColumnUnrecoverableRemoveTodoFailure() throws Exception {
class X extends FilesFacadeImpl {
    int count=1;
    @Override public boolean remove(    LPSZ name){
      return !Chars.endsWith(name,TableWriter.TODO_FILE_NAME) || --count != 0 && super.remove(name);
    }
  }
  testUnrecoverableRemoveColumn(new X());
}","@Test public void testRemoveColumnUnrecoverableRemoveTodoFailure() throws Exception {
class X extends FilesFacadeImpl {
    int count=1;
    @Override public boolean remove(    LPSZ name){
      return (!Chars.endsWith(name,TableWriter.TODO_FILE_NAME) || --count != 0) && super.remove(name);
    }
  }
  testUnrecoverableRemoveColumn(new X());
}",0.997093023255814
30903,"@Test public void testCancelFailureFollowedByTableClose() throws Exception {
  long used=Unsafe.getMemUsed();
  create(FF,PartitionBy.DAY);
  Rnd rnd=new Rnd();
  final int N=47;
class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (this.fd == fd) {
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
  X ff=new X();
  try (TableWriter writer=new TableWriter(ff,root,PRODUCT)){
    long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ts=populateRow(writer,ts,rnd,60 * 60000);
    }
    writer.commit();
    Assert.assertEquals(N,writer.size());
    TableWriter.Row r=writer.newRow(ts + 60 * 60000);
    r.putInt(0,rnd.nextInt());
    try {
      r.cancel();
      Assert.fail();
    }
 catch (    CairoException ignore) {
    }
  }
   try (TableWriter writer=new TableWriter(FF,root,PRODUCT)){
    Assert.assertEquals(N,writer.size());
  }
   Assert.assertEquals(used,Unsafe.getMemUsed());
  Assert.assertEquals(0L,FF.getOpenFileCount());
}","@Test public void testCancelFailureFollowedByTableClose() throws Exception {
  long used=Unsafe.getMemUsed();
  create(FF,PartitionBy.DAY);
  Rnd rnd=new Rnd();
  final int N=47;
class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
  X ff=new X();
  try (TableWriter writer=new TableWriter(ff,root,PRODUCT)){
    long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      ts=populateRow(writer,ts,rnd,60 * 60000);
    }
    writer.commit();
    Assert.assertEquals(N,writer.size());
    TableWriter.Row r=writer.newRow(ts + 60 * 60000);
    r.putInt(0,rnd.nextInt());
    try {
      r.cancel();
      Assert.fail();
    }
 catch (    CairoException ignore) {
    }
  }
   try (TableWriter writer=new TableWriter(FF,root,PRODUCT)){
    Assert.assertEquals(N,writer.size());
  }
   Assert.assertEquals(used,Unsafe.getMemUsed());
  Assert.assertEquals(0L,FF.getOpenFileCount());
}",0.9877112135176652
30904,"@Test public void testCannotMapTxFile() throws Exception {
  testConstructor(new FilesFacadeImpl(){
    int count=2;
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.TXN_FILE_NAME) && --count == 0) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long mmap(    long fd,    long len,    long offset,    int mode){
      if (fd == this.fd) {
        return -1;
      }
      return super.mmap(fd,len,offset,mode);
    }
  }
);
}","@Test public void testCannotMapTxFile() throws Exception {
  testConstructor(new FilesFacadeImpl(){
    int count=2;
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.TXN_FILE_NAME) && --count == 0) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long mmap(    long fd,    long len,    long offset,    int mode){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.mmap(fd,len,offset,mode);
    }
  }
);
}",0.969258589511754
30905,"@Test public void testAddColumnAndFailToReadTopFile() throws Exception {
  create(FF,PartitionBy.DAY);
  long mem=Unsafe.getMemUsed();
  try (TableWriter writer=new TableWriter(FF,root,PRODUCT)){
    long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
    int N=10000;
    Rnd rnd=new Rnd();
    for (int i=0; i < N; i++) {
      ts=populateRow(writer,ts,rnd,60 * 60000);
    }
    writer.addColumn(""String_Node_Str"",ColumnType.STRING);
    Assert.assertEquals(N,writer.size());
  }
 class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRO(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return this.fd=super.openRO(name);
      }
      return super.openRO(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (this.fd == fd) {
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
  try {
    new TableWriter(new X(),root,PRODUCT);
    Assert.fail();
  }
 catch (  CairoException ignore) {
  }
  Assert.assertEquals(mem,Unsafe.getMemUsed());
  Assert.assertEquals(0,Files.getOpenFileCount());
}","@Test public void testAddColumnAndFailToReadTopFile() throws Exception {
  create(FF,PartitionBy.DAY);
  long mem=Unsafe.getMemUsed();
  try (TableWriter writer=new TableWriter(FF,root,PRODUCT)){
    long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
    int N=10000;
    Rnd rnd=new Rnd();
    for (int i=0; i < N; i++) {
      ts=populateRow(writer,ts,rnd,60 * 60000);
    }
    writer.addColumn(""String_Node_Str"",ColumnType.STRING);
    Assert.assertEquals(N,writer.size());
  }
 class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRO(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return this.fd=super.openRO(name);
      }
      return super.openRO(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
  try {
    new TableWriter(new X(),root,PRODUCT);
    Assert.fail();
  }
 catch (  CairoException ignore) {
  }
  Assert.assertEquals(mem,Unsafe.getMemUsed());
  Assert.assertEquals(0,Files.getOpenFileCount());
}",0.9869337979094076
30906,"@Override public long read(long fd,long buf,int len,long offset){
  if (fd == this.fd) {
    return -1;
  }
  return super.read(fd,buf,len,offset);
}","@Override public long read(long fd,long buf,int len,long offset){
  if (fd == this.fd) {
    this.fd=-1;
    return -1;
  }
  return super.read(fd,buf,len,offset);
}",0.9490445859872612
30907,"@Test public void testAddColumnSwpFileMapFail() throws Exception {
  testAddColumnRecoverableFault(new FilesFacadeImpl(){
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.META_SWAP_FILE_NAME)) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long mmap(    long fd,    long len,    long offset,    int mode){
      if (fd == this.fd) {
        return -1;
      }
      return super.mmap(fd,len,offset,mode);
    }
  }
);
}","@Test public void testAddColumnSwpFileMapFail() throws Exception {
  testAddColumnRecoverableFault(new FilesFacadeImpl(){
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.META_SWAP_FILE_NAME)) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long mmap(    long fd,    long len,    long offset,    int mode){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.mmap(fd,len,offset,mode);
    }
  }
);
}",0.968978102189781
30908,"@Test public void testCannotSetAppendPosition() throws Exception {
  create(FF,PartitionBy.NONE);
  populateTable0(FF);
  testConstructor(new FilesFacadeImpl(){
    long fd;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
,false);
}","@Test public void testCannotSetAppendPosition() throws Exception {
  create(FF,PartitionBy.NONE);
  populateTable0(FF);
  testConstructor(new FilesFacadeImpl(){
    long fd;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,""String_Node_Str"")) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
,false);
}",0.970383275261324
30909,"private void testSetAppendPositionFailure(String failFile) throws NumericException {
  createAllTable();
class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,failFile)) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
  final X ff=new X();
  long mem=Unsafe.getMemUsed();
  testAppendNulls(new Rnd(),FF,DateFormatUtils.parseDateTime(""String_Node_Str""));
  try {
    new TableWriter(ff,root,""String_Node_Str"");
    Assert.fail();
  }
 catch (  CairoException ignore) {
  }
  Assert.assertEquals(mem,Unsafe.getMemUsed());
  Assert.assertEquals(0,ff.getOpenFileCount());
}","private void testSetAppendPositionFailure(String failFile) throws NumericException {
  createAllTable();
class X extends FilesFacadeImpl {
    long fd=-1;
    @Override public long openRW(    LPSZ name){
      if (Chars.endsWith(name,failFile)) {
        return fd=super.openRW(name);
      }
      return super.openRW(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
  final X ff=new X();
  long mem=Unsafe.getMemUsed();
  testAppendNulls(new Rnd(),FF,DateFormatUtils.parseDateTime(""String_Node_Str""));
  try {
    new TableWriter(ff,root,""String_Node_Str"");
    Assert.fail();
  }
 catch (  CairoException ignore) {
  }
  Assert.assertEquals(mem,Unsafe.getMemUsed());
  Assert.assertEquals(0,ff.getOpenFileCount());
}",0.9808342728297632
30910,"@Test public void testConstructorTruncatedTodo() throws Exception {
  FilesFacade ff=new FilesFacadeImpl(){
    long fd=7686876823L;
    @Override public boolean exists(    LPSZ path){
      return Chars.endsWith(path,TableWriter.TODO_FILE_NAME) || super.exists(path);
    }
    @Override public long openRO(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.TODO_FILE_NAME)) {
        return this.fd;
      }
      return super.openRO(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
;
  populateTable(ff);
}","@Test public void testConstructorTruncatedTodo() throws Exception {
  FilesFacade ff=new FilesFacadeImpl(){
    long fd=7686876823L;
    @Override public boolean exists(    LPSZ path){
      return Chars.endsWith(path,TableWriter.TODO_FILE_NAME) || super.exists(path);
    }
    @Override public long openRO(    LPSZ name){
      if (Chars.endsWith(name,TableWriter.TODO_FILE_NAME)) {
        return this.fd;
      }
      return super.openRO(name);
    }
    @Override public long read(    long fd,    long buf,    int len,    long offset){
      if (fd == this.fd) {
        this.fd=-1;
        return -1;
      }
      return super.read(fd,buf,len,offset);
    }
  }
;
  populateTable(ff);
}",0.9751461988304092
30911,"@Override public long append(long fd,long buf,int len){
  if (this.fd == fd) {
    return -1;
  }
  return super.append(fd,buf,len);
}","@Override public long append(long fd,long buf,int len){
  if (fd == this.fd) {
    this.fd=-1;
    return -1;
  }
  return super.append(fd,buf,len);
}",0.9014084507042254
30912,"private void removePartitionDirsNewerThan(long timestamp){
  LOG.info().$(""String_Node_Str"").$ts(timestamp).$(""String_Node_Str"").$(path.$()).$();
  try {
    long p=ff.findFirst(path.$());
    if (p > 0) {
      try {
        do {
          long pName=ff.findName(p);
          path.trimTo(rootLen);
          path.concat(pName).$();
          nativeLPSZ.of(pName);
          if (!truncateIgnores.contains(nativeLPSZ)) {
            try {
              long dirTimestamp=partitionDirFmt.parse(nativeLPSZ,partitionDirLocale);
              if (dirTimestamp < timestamp) {
                continue;
              }
            }
 catch (            NumericException ignore) {
            }
            if (ff.rmdir(path)) {
              LOG.info().$(""String_Node_Str"").$(path).$();
            }
 else {
              throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
            }
          }
        }
 while (ff.findNext(p));
      }
  finally {
        ff.findClose(p);
      }
    }
  }
  finally {
    path.trimTo(rootLen);
  }
}","private void removePartitionDirsNewerThan(long timestamp){
  LOG.info().$(""String_Node_Str"").$ts(timestamp).$(""String_Node_Str"").$(path.$()).$();
  try {
    long p=ff.findFirst(path.$());
    if (p > 0) {
      try {
        do {
          long pName=ff.findName(p);
          path.trimTo(rootLen);
          path.concat(pName).$();
          nativeLPSZ.of(pName);
          if (!truncateIgnores.contains(nativeLPSZ)) {
            try {
              long dirTimestamp=partitionDirFmt.parse(nativeLPSZ,partitionDirLocale);
              if (dirTimestamp <= timestamp) {
                continue;
              }
            }
 catch (            NumericException ignore) {
            }
            if (ff.rmdir(path)) {
              LOG.info().$(""String_Node_Str"").$(path).$();
            }
 else {
              throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
            }
          }
        }
 while (ff.findNext(p));
      }
  finally {
        ff.findClose(p);
      }
    }
  }
  finally {
    path.trimTo(rootLen);
  }
}",0.9995285242809996
30913,"private void indexZones(String[][] zones,TimeZoneRuleFactory timeZoneRuleFactory,CharSequenceHashSet cache){
  for (int i=0, n=zones.length; i < n; i++) {
    String[] zNames=zones[i];
    String key=zNames[0];
    int index=timeZoneRuleFactory.getTimeZoneRulesIndex(key);
    if (index == -1) {
      continue;
    }
    for (int k=1, m=zNames.length; k < m; k++) {
      String name=zNames[k];
      if (cache.add(name)) {
        defineToken(name,index,this.zones);
      }
    }
  }
}","private void indexZones(String[][] zones,TimeZoneRuleFactory timeZoneRuleFactory,CharSequenceHashSet cache){
  if (cache.add(""String_Node_Str"")) {
    int index=timeZoneRuleFactory.getTimeZoneRulesIndex(""String_Node_Str"");
    if (index != -1) {
      defineToken(""String_Node_Str"",index,this.zones);
    }
  }
  for (int i=0, n=zones.length; i < n; i++) {
    String[] zNames=zones[i];
    String key=zNames[0];
    int index=timeZoneRuleFactory.getTimeZoneRulesIndex(key);
    if (index == -1) {
      continue;
    }
    for (int k=1, m=zNames.length; k < m; k++) {
      String name=zNames[k];
      if (cache.add(name)) {
        defineToken(name,index,this.zones);
      }
    }
  }
}",0.8285229202037352
30914,"@Override public CharSequence getFlyweightStrB(int col){
  return colA(col).getStr2(colB(col).getLong(baseOffset * 8));
}","@Override public CharSequence getFlyweightStrB(int col){
  return colA(col).getStr2(colB(col).getLong(recordIndex * 8));
}",0.9300411522633744
30915,"@Override public long getBinLen(int col){
  return colA(col).getLong(colB(col).getLong(baseOffset * 8));
}","@Override public long getBinLen(int col){
  return colA(col).getLong(colB(col).getLong(recordIndex * 8));
}",0.92018779342723
30916,"@Override public double getDouble(int col){
  return colA(col).getDouble(baseOffset * 8);
}","@Override public double getDouble(int col){
  return colA(col).getDouble(recordIndex * 8);
}",0.907103825136612
30917,"@Override public float getFloat(int col){
  return colA(col).getFloat(baseOffset * 4);
}","@Override public float getFloat(int col){
  return colA(col).getFloat(recordIndex * 4);
}",0.903954802259887
30918,"@Override public CharSequence getFlyweightStr(int col){
  return colA(col).getStr(colB(col).getLong(baseOffset * 8));
}","@Override public CharSequence getFlyweightStr(int col){
  return colA(col).getStr(colB(col).getLong(recordIndex * 8));
}",0.9288702928870292
30919,"@Override public byte get(int col){
  return colA(col).getByte(baseOffset);
}","@Override public byte get(int col){
  return colA(col).getByte(recordIndex);
}",0.8903225806451613
30920,"@Override public long getDate(int col){
  return colA(col).getLong(baseOffset * 8);
}","@Override public long getDate(int col){
  return colA(col).getLong(recordIndex * 8);
}",0.9005847953216374
30921,"@Override public void close() throws IOException {
  Misc.free(path);
  Misc.free(metaMem);
  Misc.free(txMem);
  for (int i=0, n=columns.size(); i < n; i++) {
    VirtualMemory mem=columns.getQuick(i);
    if (mem != null) {
      mem.close();
    }
  }
}","@Override public void close(){
  Misc.free(path);
  Misc.free(metaMem);
  Misc.free(txMem);
  for (int i=0, n=columns.size(); i < n; i++) {
    VirtualMemory mem=columns.getQuick(i);
    if (mem != null) {
      mem.close();
    }
  }
}",0.959349593495935
30922,"@Override public boolean getBool(int col){
  return colA(col).getBool(baseOffset);
}","@Override public boolean getBool(int col){
  return colA(col).getBool(recordIndex);
}",0.8994082840236687
30923,"public TableReader(FilesFacade ff,CharSequence root,CharSequence name){
  this.ff=ff;
  this.path=new CompositePath().of(root).concat(name);
  this.rootLen=path.length();
  this.txMem=openTxnFile();
  if (readTodoTaskCode() != -1) {
    throw CairoException.instance(0).put(""String_Node_Str"").put(path.$()).put(""String_Node_Str"");
  }
  this.metaMem=new ReadOnlyMemory(ff);
  openMetaFile();
  this.columnCount=metaMem.getInt(META_OFFSET_COUNT);
  this.columnBlockSize=Numbers.ceilPow2(this.columnCount);
  this.partitionBy=metaMem.getInt(META_OFFSET_PARTITION_BY);
  this.timestampIndex=metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);
  this.metadata=new Meta(columnCount);
  this.partitionDirFmt=TableWriter.selectPartitionDirFmt(partitionBy);
  countPartitions();
  int columnListCapacity=(this.partitionCount == 1 ? columnCount : columnBlockSize * partitionCount) * 2;
  this.columns=new ObjList<>(columnListCapacity);
  columns.extendAndSet(columnListCapacity - 1,null);
  this.partitionSizes=new LongList(partitionCount);
  this.partitionSizes.seed(partitionCount,-1);
  readTx();
  this.columnTops=new long[columnCount];
}","public TableReader(FilesFacade ff,CharSequence root,CharSequence name){
  this.ff=ff;
  this.path=new CompositePath().of(root).concat(name);
  this.rootLen=path.length();
  failOnPendingTodo();
  this.txMem=openTxnFile();
  this.metaMem=new ReadOnlyMemory(ff);
  openMetaFile();
  this.columnCount=metaMem.getInt(META_OFFSET_COUNT);
  this.columnBlockSize=Numbers.ceilPow2(this.columnCount);
  this.partitionBy=metaMem.getInt(META_OFFSET_PARTITION_BY);
  this.timestampIndex=metaMem.getInt(META_OFFSET_TIMESTAMP_INDEX);
  this.metadata=new Meta(columnCount);
  this.partitionDirFmt=TableWriter.selectPartitionDirFmt(partitionBy);
  countPartitions();
  int columnListCapacity=(this.partitionCount == 1 ? columnCount : columnBlockSize * partitionCount) * 2;
  this.columns=new ObjList<>(columnListCapacity);
  columns.extendAndSet(columnListCapacity - 1,null);
  this.partitionSizes=new LongList(partitionCount);
  this.partitionSizes.seed(partitionCount,-1);
  readTx();
  this.columnTops=new long[columnCount];
}",0.9256661991584852
30924,"@Override public short getShort(int col){
  return colA(col).getShort(baseOffset * 2);
}","@Override public short getShort(int col){
  return colA(col).getShort(recordIndex * 2);
}",0.903954802259887
30925,"private void countPartitions(){
  if (partitionDirFmt == null) {
    partitionCount=1;
    return;
  }
  partitionMin=Long.MAX_VALUE;
  long partitionMax=Long.MIN_VALUE;
  try {
    long p=ff.findFirst(path.$());
    if (p > 0) {
      try {
        do {
          int type=ff.findType(p);
          if (type == Files.DT_DIR || type == Files.DT_LNK) {
            try {
              long time=partitionDirFmt.parse(nativeLPSZ.of(ff.findName(p)),DateLocaleFactory.INSTANCE.getDefaultDateLocale());
              if (time < partitionMin) {
                partitionMin=time;
              }
              if (time > partitionMax) {
                partitionMax=time;
              }
            }
 catch (            NumericException e) {
              e.printStackTrace();
            }
          }
        }
 while (ff.findNext(p));
      }
  finally {
        ff.findClose(p);
      }
    }
  }
  finally {
    path.trimTo(rootLen);
  }
  if (partitionMin == Long.MAX_VALUE) {
    partitionCount=1;
    return;
  }
switch (partitionBy) {
case PartitionBy.YEAR:
    partitionCount=(int)Dates.getYearsBetween(partitionMin,partitionMax) + 1;
  break;
case PartitionBy.MONTH:
partitionCount=(int)Dates.getMonthsBetween(partitionMin,partitionMax) + 1;
break;
case PartitionBy.DAY:
partitionCount=(int)Dates.getDaysBetween(partitionMin,partitionMax) + 1;
break;
default :
break;
}
}","private void countPartitions(){
  if (partitionDirFmt == null) {
    partitionCount=1;
    return;
  }
  partitionMin=Long.MAX_VALUE;
  long partitionMax=Long.MIN_VALUE;
  try {
    long p=ff.findFirst(path.$());
    if (p > 0) {
      try {
        do {
          int type=ff.findType(p);
          if (type == Files.DT_DIR || type == Files.DT_LNK) {
            try {
              long time=partitionDirFmt.parse(nativeLPSZ.of(ff.findName(p)),DateLocaleFactory.INSTANCE.getDefaultDateLocale());
              if (time < partitionMin) {
                partitionMin=time;
              }
              if (time > partitionMax) {
                partitionMax=time;
              }
            }
 catch (            NumericException ignore) {
            }
          }
        }
 while (ff.findNext(p));
      }
  finally {
        ff.findClose(p);
      }
    }
  }
  finally {
    path.trimTo(rootLen);
  }
  if (partitionMin == Long.MAX_VALUE) {
    partitionCount=1;
    return;
  }
switch (partitionBy) {
case PartitionBy.YEAR:
    partitionCount=(int)Dates.getYearsBetween(partitionMin,partitionMax) + 1;
  break;
case PartitionBy.MONTH:
partitionCount=(int)Dates.getMonthsBetween(partitionMin,partitionMax) + 1;
break;
case PartitionBy.DAY:
partitionCount=(int)Dates.getDaysBetween(partitionMin,partitionMax) + 1;
break;
default :
break;
}
}",0.9823917828319882
30926,"@Override public long getLong(int col){
  return colA(col).getLong(baseOffset * 8);
}","@Override public long getLong(int col){
  return colA(col).getLong(recordIndex * 8);
}",0.9005847953216374
30927,"@Override public int getInt(int col){
  return colA(col).getInt(baseOffset * 4);
}","@Override public int getInt(int col){
  return colA(col).getInt(recordIndex * 4);
}",0.896969696969697
30928,"@Override public int getStrLen(int col){
  return colA(col).getInt(colB(col).getLong(baseOffset * 8));
}","@Override public int getStrLen(int col){
  return colA(col).getInt(colB(col).getLong(recordIndex * 8));
}",0.9186602870813396
30929,"private void readTx(){
  while (true) {
    long txn=txMem.getLong(TableWriter.TX_OFFSET_TXN);
    if (txn == this.txn) {
      break;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableWriter.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableWriter.TX_OFFSET_FIXED_ROW_COUNT);
    long maxTimestamp=txMem.getLong(TableWriter.TX_OFFSET_MAX_TIMESTAMP);
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableWriter.TX_OFFSET_TXN)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.size=fixedRowCount + transientRowCount;
      this.maxTimestamp=maxTimestamp;
      break;
    }
    LockSupport.parkNanos(1);
  }
}","private void readTx(){
  while (true) {
    long txn=txMem.getLong(TableWriter.TX_OFFSET_TXN);
    if (txn == this.txn) {
      break;
    }
    Unsafe.getUnsafe().loadFence();
    long transientRowCount=txMem.getLong(TableWriter.TX_OFFSET_TRANSIENT_ROW_COUNT);
    long fixedRowCount=txMem.getLong(TableWriter.TX_OFFSET_FIXED_ROW_COUNT);
    long maxTimestamp=txMem.getLong(TableWriter.TX_OFFSET_MAX_TIMESTAMP);
    Unsafe.getUnsafe().loadFence();
    if (txn == txMem.getLong(TableWriter.TX_OFFSET_TXN)) {
      this.txn=txn;
      this.transientRowCount=transientRowCount;
      this.size=fixedRowCount + transientRowCount;
      break;
    }
    LockSupport.parkNanos(1);
  }
}",0.9728571428571428
30930,"/** 
 * Sets path member variable to partition directory for the given timestamp and partitionLo and partitionHi to partition interval in millis. These values are determined based on input timestamp and value of partitionBy. For any given timestamp this method will determine either day, month or year interval timestamp falls to. Partition directory name is ISO string of interval start. <p> Because this method modifies ""path"" member variable, be sure path is trimmed to original state withing try..finally block.
 * @param timestamp               to determine interval for
 * @param updatePartitionInterval flag indicating that partition interval partitionLo andpartitionHi have to be updated as well.
 */
private void setStateForTimestamp(long timestamp,boolean updatePartitionInterval){
  int y, m, d;
  boolean leap;
  path.put(Path.SEPARATOR);
switch (partitionBy) {
case PartitionBy.DAY:
    y=Dates.getYear(timestamp);
  leap=Dates.isLeapYear(y);
m=Dates.getMonthOfYear(timestamp,y,leap);
d=Dates.getDayOfMonth(timestamp,y,m,leap);
DateFormatUtils.append000(path,y);
path.put('-');
DateFormatUtils.append0(path,m);
path.put('-');
DateFormatUtils.append0(path,d);
if (updatePartitionInterval) {
partitionLo=Dates.yearMillis(y,leap);
partitionLo+=Dates.monthOfYearMillis(m,leap);
partitionLo+=(d - 1) * Dates.DAY_MILLIS;
partitionHi=partitionLo + 24 * Dates.HOUR_MILLIS;
}
break;
case PartitionBy.MONTH:
y=Dates.getYear(timestamp);
leap=Dates.isLeapYear(y);
m=Dates.getMonthOfYear(timestamp,y,leap);
DateFormatUtils.append000(path,y);
path.put('-');
DateFormatUtils.append0(path,m);
if (updatePartitionInterval) {
partitionLo=Dates.yearMillis(y,leap);
partitionLo+=Dates.monthOfYearMillis(m,leap);
partitionHi=partitionLo + Dates.getDaysPerMonth(m,leap) * 24L * Dates.HOUR_MILLIS;
}
break;
case PartitionBy.YEAR:
y=Dates.getYear(timestamp);
leap=Dates.isLeapYear(y);
DateFormatUtils.append000(path,y);
if (updatePartitionInterval) {
partitionLo=Dates.yearMillis(y,leap);
partitionHi=Dates.addYear(partitionLo,1);
}
break;
default :
path.put(DEFAULT_PARTITION_NAME);
partitionLo=Long.MIN_VALUE;
partitionHi=Long.MAX_VALUE;
}
}","/** 
 * Sets path member variable to partition directory for the given timestamp and partitionLo and partitionHi to partition interval in millis. These values are determined based on input timestamp and value of partitionBy. For any given timestamp this method will determine either day, month or year interval timestamp falls to. Partition directory name is ISO string of interval start. <p> Because this method modifies ""path"" member variable, be sure path is trimmed to original state withing try..finally block.
 * @param timestamp               to determine interval for
 * @param updatePartitionInterval flag indicating that partition interval partitionLo andpartitionHi have to be updated as well.
 */
private void setStateForTimestamp(long timestamp,boolean updatePartitionInterval){
  int y, m, d;
  boolean leap;
  path.put(Path.SEPARATOR);
switch (partitionBy) {
case PartitionBy.DAY:
    y=Dates.getYear(timestamp);
  leap=Dates.isLeapYear(y);
m=Dates.getMonthOfYear(timestamp,y,leap);
d=Dates.getDayOfMonth(timestamp,y,m,leap);
DateFormatUtils.append000(path,y);
path.put('-');
DateFormatUtils.append0(path,m);
path.put('-');
DateFormatUtils.append0(path,d);
if (updatePartitionInterval) {
partitionLo=Dates.yearMillis(y,leap);
partitionLo+=Dates.monthOfYearMillis(m,leap);
partitionLo+=(d - 1) * Dates.DAY_MILLIS;
partitionHi=partitionLo + 24 * Dates.HOUR_MILLIS;
}
break;
case PartitionBy.MONTH:
y=Dates.getYear(timestamp);
leap=Dates.isLeapYear(y);
m=Dates.getMonthOfYear(timestamp,y,leap);
DateFormatUtils.append000(path,y);
path.put('-');
DateFormatUtils.append0(path,m);
if (updatePartitionInterval) {
partitionLo=Dates.yearMillis(y,leap);
partitionLo+=Dates.monthOfYearMillis(m,leap);
partitionHi=partitionLo + Dates.getDaysPerMonth(m,leap) * 24L * Dates.HOUR_MILLIS;
}
break;
case PartitionBy.YEAR:
y=Dates.getYear(timestamp);
leap=Dates.isLeapYear(y);
DateFormatUtils.append000(path,y);
if (updatePartitionInterval) {
partitionLo=Dates.yearMillis(y,leap);
partitionHi=Dates.addYear(partitionLo,1);
}
break;
default :
path.put(DEFAULT_PARTITION_NAME);
partitionLo=Long.MIN_VALUE;
partitionHi=Long.MAX_VALUE;
break;
}
}",0.9983610395691876
30931,"private void commitPendingPartitions(){
  long offset=8;
  for (int i=0; i < txPartitionCount - 1; i++) {
    try {
      long partitionTimestamp=columnSizeMem.getLong(offset);
      offset+=8;
      setStateForTimestamp(partitionTimestamp,false);
      long fd=openAppend(path.concat(ARCHIVE_FILE_NAME).$());
      try {
        int len=8;
        while (len > 0) {
          long l=Math.min(len,columnSizeMem.pageRemaining(offset));
          if (ff.write(fd,columnSizeMem.addressOf(offset),l,0) == -1) {
            throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
          }
          len-=l;
          offset+=l;
        }
      }
  finally {
        ff.close(fd);
      }
    }
  finally {
      path.trimTo(rootLen);
    }
  }
}","private void commitPendingPartitions(){
  long offset=0;
  for (int i=0; i < txPartitionCount - 1; i++) {
    try {
      long partitionTimestamp=columnSizeMem.getLong(offset + 8);
      setStateForTimestamp(partitionTimestamp,false);
      long fd=openAppend(path.concat(ARCHIVE_FILE_NAME).$());
      try {
        int len=8;
        long o=offset;
        while (len > 0) {
          long l=Math.min(len,columnSizeMem.pageRemaining(o));
          if (ff.write(fd,columnSizeMem.addressOf(o),l,0) != l) {
            throw CairoException.instance(ff.errno()).put(""String_Node_Str"").put(path);
          }
          len-=l;
          o+=l;
        }
      }
  finally {
        ff.close(fd);
      }
      offset+=16;
    }
  finally {
      path.trimTo(rootLen);
    }
  }
}",0.9440832249674902
30932,"/** 
 * path member variable has to be set to location of ""top"" file.
 * @return number of rows column doesn't have when column was added to table that already had data.
 */
static long readColumnTop(FilesFacade ff,CompositePath path,CharSequence name,int plen){
  try {
    if (ff.exists(topFile(path,name))) {
      long fd=ff.openRO(path);
      try {
        long buf=Unsafe.malloc(8);
        try {
          if (ff.read(fd,buf,8,0) != 8) {
            throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(path);
          }
          return Unsafe.getUnsafe().getLong(buf);
        }
  finally {
          Unsafe.free(buf,8);
        }
      }
  finally {
        ff.close(fd);
      }
    }
    return 0L;
  }
  finally {
    path.trimTo(plen);
  }
}","/** 
 * path member variable has to be set to location of ""top"" file.
 * @return number of rows column doesn't have when column was added to table that already had data.
 */
static long readColumnTop(FilesFacade ff,CompositePath path,CharSequence name,int plen){
  try {
    path.trimTo(path.length());
    if (ff.exists(topFile(path,name))) {
      long fd=ff.openRO(path);
      try {
        long buf=Unsafe.malloc(8);
        try {
          if (ff.read(fd,buf,8,0) != 8) {
            throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(path);
          }
          return Unsafe.getUnsafe().getLong(buf);
        }
  finally {
          Unsafe.free(buf,8);
        }
      }
  finally {
        ff.close(fd);
      }
    }
    return 0L;
  }
  finally {
    path.trimTo(plen);
  }
}",0.9797211660329532
30933,"private void cancelRow(){
  if ((masterRef & 1) == 0) {
    return;
  }
  if (transientRowCount == 0) {
    if (partitionBy != PartitionBy.NONE) {
      closeColumns(false);
      if (removeDirOnCancelRow) {
        try {
          setStateForTimestamp(maxTimestamp,false);
          if (!ff.rmdir(path.$())) {
            throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(path);
          }
          removeDirOnCancelRow=false;
        }
  finally {
          path.trimTo(rootLen);
        }
      }
      if (prevTimestamp > Long.MIN_VALUE) {
        columnSizeMem.jumpTo((txPartitionCount - 2) * 16);
        openPartition(prevTimestamp);
        setAppendPosition(prevTransientRowCount);
        txPartitionCount--;
      }
 else {
        rowFunction=openPartitionFunction;
      }
      transientRowCount=prevTransientRowCount;
      fixedRowCount-=prevTransientRowCount;
      maxTimestamp=prevTimestamp;
      removeDirOnCancelRow=true;
    }
 else {
      for (int i=0; i < columnCount; i++) {
        getPrimaryColumn(i).jumpTo(0);
        AppendMemory mem=getSecondaryColumn(i);
        if (mem != null) {
          mem.jumpTo(0);
        }
      }
    }
  }
 else {
    maxTimestamp=prevTimestamp;
    boolean rowChanged=false;
    for (int i=0; i < columnCount; i++) {
      if (refs.getQuick(i) == masterRef) {
        rowChanged=true;
        break;
      }
    }
    if (rowChanged) {
      setAppendPosition(transientRowCount);
    }
  }
  masterRef--;
}","private void cancelRow(){
  if ((masterRef & 1) == 0) {
    return;
  }
  if (transientRowCount == 0) {
    if (partitionBy != PartitionBy.NONE) {
      closeColumns(false);
      if (removeDirOnCancelRow) {
        try {
          setStateForTimestamp(maxTimestamp,false);
          if (!ff.rmdir(path.$())) {
            throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(path);
          }
          removeDirOnCancelRow=false;
        }
  finally {
          path.trimTo(rootLen);
        }
      }
      if (prevTimestamp > Long.MIN_VALUE) {
        try {
          columnSizeMem.jumpTo((txPartitionCount - 2) * 16);
          openPartition(prevTimestamp);
          setAppendPosition(prevTransientRowCount);
          txPartitionCount--;
        }
 catch (        CairoException e) {
          closeColumns(false);
          throw e;
        }
      }
 else {
        rowFunction=openPartitionFunction;
      }
      transientRowCount=prevTransientRowCount;
      fixedRowCount-=prevTransientRowCount;
      maxTimestamp=prevTimestamp;
      removeDirOnCancelRow=true;
    }
 else {
      for (int i=0; i < columnCount; i++) {
        getPrimaryColumn(i).jumpTo(0);
        AppendMemory mem=getSecondaryColumn(i);
        if (mem != null) {
          mem.jumpTo(0);
        }
      }
    }
  }
 else {
    maxTimestamp=prevTimestamp;
    boolean rowChanged=false;
    for (int i=0; i < columnCount; i++) {
      if (refs.getQuick(i) == masterRef) {
        rowChanged=true;
        break;
      }
    }
    if (rowChanged) {
      setAppendPosition(transientRowCount);
    }
  }
  masterRef--;
}",0.9588424437299036
30934,"private long mapPage(int page){
  long target=pageOffset(page + 1);
  if (Files.length(fd) < target && !Files.truncate(fd,target)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  return Files.mmap(fd,pageSize,pageOffset(page),Files.MAP_RW);
}","private long mapPage(int page){
  long target=pageOffset(page + 1);
  if (Files.length(fd) < target && !Files.truncate(fd,target)) {
    throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(target);
  }
  return Files.mmap(fd,pageSize,pageOffset(page),Files.MAP_RW);
}",0.852112676056338
30935,"public final void of(LPSZ name,long pageSize){
  close();
  setPageSize(pageSize);
  fd=Files.openRW(name);
  if (fd == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public final void of(LPSZ name,long pageSize){
  close();
  setPageSize(pageSize);
  fd=Files.openRW(name);
  if (fd == -1) {
    throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(name);
  }
  LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(fd).$(']').$();
}",0.7215189873417721
30936,"@Override protected long mapWritePage(int page){
  releaseCurrentPage();
  long address=mapPage(page);
  if (address == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  return pageAddress=address;
}","@Override protected long mapWritePage(int page){
  releaseCurrentPage();
  long address=mapPage(page);
  if (address == -1) {
    throw CairoException.instance(Os.errno()).put(""String_Node_Str"").put(fd).put(""String_Node_Str"").put(pageOffset(page));
  }
  return pageAddress=address;
}",0.8104838709677419
30937,"public void of(LPSZ name,long maxPageSize,long size){
  close();
  this.size=size;
  this.lastPageSize=Files.PAGE_SIZE;
  boolean exists=Files.exists(name);
  if (!exists) {
    throw new RuntimeException(""String_Node_Str"");
  }
  fd=Files.openRO(name);
  if (fd == -1) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (size > maxPageSize) {
    setPageSize(maxPageSize);
  }
 else {
    setPageSize(Math.max(Files.PAGE_SIZE,(size / Files.PAGE_SIZE) * Files.PAGE_SIZE));
  }
  pages.ensureCapacity((int)(size / this.pageSize + 1));
}","public void of(LPSZ name,long maxPageSize,long size){
}",0.1830282861896838
30938,"public TableWriter(CharSequence root,CharSequence name){
  this.path=new CompositePath().of(root).concat(name);
  this.rootLen=path.length();
  metaMem.of(path.concat(""String_Node_Str"").$(),Files.PAGE_SIZE,0);
  this.columnCount=metaMem.getInt(0);
  this.partitionBy=metaMem.getInt(4);
  this.refs.extendAndSet(columnCount,0);
  this.nullers=new Runnable[columnCount];
  path.trimTo(rootLen);
  configureColumnMemory();
  configureAppendPosition();
}","public TableWriter(CharSequence root,CharSequence name){
  this.path=new CompositePath().of(root).concat(name);
  this.rootLen=path.length();
  path.concat(""String_Node_Str"").$();
  metaMem.of(path,Files.PAGE_SIZE,Files.length(path));
  this.columnCount=metaMem.getInt(0);
  this.partitionBy=metaMem.getInt(4);
  this.refs.extendAndSet(columnCount,0);
  this.nullers=new Runnable[columnCount];
  path.trimTo(rootLen);
  configureColumnMemory();
  configureAppendPosition();
}",0.947027027027027
30939,"@Test public void testParseLargeFile() throws Exception {
  Path p=new Path(JsonLexerTest.class.getResource(""String_Node_Str"").getPath());
  long l=Files.length(p);
  long fd=Files.openRO(p);
  JsonListener listener=new NoOpListener();
  try {
    long buf=Unsafe.malloc(l);
    try {
      Files.read(fd,buf,(int)l,0);
      JsonLexer lexer=new JsonLexer(1024);
      long t=System.nanoTime();
      for (int i=0; i < l; i++) {
        try {
          lexer.clear();
          lexer.parse(buf,i,listener);
          lexer.parse(buf + i,l - i,listener);
          lexer.parseLast();
        }
 catch (        JsonException e) {
          System.out.println(i);
          throw e;
        }
      }
      System.out.println((System.nanoTime() - t) / l);
    }
  finally {
      Unsafe.free(buf,l);
    }
  }
  finally {
    Files.close(fd);
  }
}","@Test public void testParseLargeFile() throws Exception {
  Path p=new Path(JsonLexerTest.class.getResource(""String_Node_Str"").getPath());
  long l=Files.length(p);
  long fd=Files.openRO(p);
  JsonListener listener=new NoOpListener();
  try {
    long buf=Unsafe.malloc(l);
    try {
      Assert.assertEquals(l,Files.read(fd,buf,(int)l,0));
      JsonLexer lexer=new JsonLexer(1024);
      long t=System.nanoTime();
      for (int i=0; i < l; i++) {
        try {
          lexer.clear();
          lexer.parse(buf,i,listener);
          lexer.parse(buf + i,l - i,listener);
          lexer.parseLast();
        }
 catch (        JsonException e) {
          System.out.println(i);
          throw e;
        }
      }
      System.out.println((System.nanoTime() - t) / l);
    }
  finally {
      Unsafe.free(buf,l);
    }
  }
  finally {
    Files.close(fd);
  }
}",0.986573263280794
30940,"@Override public void clear(){
  objDepthStack.clear();
  arrayDepthStack.clear();
  state=S_START;
  objDepth=0;
  arrayDepth=0;
}","@Override public void clear(){
  objDepthStack.clear();
  arrayDepthStack.clear();
  state=S_START;
  objDepth=0;
  arrayDepth=0;
  ignoreNext=false;
  quoted=false;
  cacheSize=0;
  useCache=false;
}",0.7915407854984894
30941,"public void parse(long lo,long len,JsonListener listener) throws JsonException {
  long p=lo;
  long hi=lo + len;
  long valueStart=0;
  boolean quoted=false;
  boolean ignoreNext=false;
  while (p < hi) {
    char c=(char)Unsafe.getUnsafe().getByte(p++);
    if (ignoreNext) {
      ignoreNext=false;
      continue;
    }
    if (valueStart > 0 && ((quoted && c != '""') || (!quoted && (c == '-' || c == '.' || c == 'e' || c == 'E' || (c >= '0' && c <= '9'))))) {
      if (quoted && c == '\\') {
        ignoreNext=true;
      }
      continue;
    }
    if (valueStart > 0) {
      if (state == S_EXPECT_NAME || state == S_EXPECT_FIRST_NAME) {
        listener.onEvent(EVT_NAME,dbcs.of(valueStart,p - 1));
        state=S_EXPECT_COLON;
      }
 else {
        listener.onEvent(arrayDepth > 0 ? EVT_ARRAY_VALUE : EVT_VALUE,dbcs.of(valueStart,p - 1));
        state=S_EXPECT_COMMA;
      }
      valueStart=0;
      if (quoted) {
        continue;
      }
    }
switch (c) {
case '{':
      if (state != S_START && state != S_EXPECT_VALUE) {
        throw JsonException.with(""String_Node_Str"",(int)(p - lo));
      }
    arrayDepthStack.push(arrayDepth);
  arrayDepth=0;
listener.onEvent(EVT_OBJ_START,null);
objDepth++;
state=S_EXPECT_FIRST_NAME;
break;
case '}':
if (arrayDepth > 0) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
if (objDepth > 0) {
switch (state) {
case S_EXPECT_VALUE:
throw JsonException.with(""String_Node_Str"",(int)(p - lo - 1));
case S_EXPECT_NAME:
throw JsonException.with(""String_Node_Str"",(int)(p - lo - 1));
default :
break;
}
listener.onEvent(EVT_OBJ_END,null);
objDepth--;
arrayDepth=arrayDepthStack.pop();
state=S_EXPECT_COMMA;
}
 else {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
break;
case '[':
if (state != S_START && state != S_EXPECT_VALUE) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
listener.onEvent(EVT_ARRAY_START,null);
objDepthStack.push(objDepth);
objDepth=0;
arrayDepth++;
state=S_EXPECT_VALUE;
break;
case ']':
if (objDepth > 0) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
if (arrayDepth == 0) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
listener.onEvent(EVT_ARRAY_END,null);
arrayDepth--;
objDepth=objDepthStack.pop();
state=S_EXPECT_COMMA;
break;
case ' ':
case '\t':
case '\n':
case '\r':
break;
case ',':
if (state != S_EXPECT_COMMA) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
if (arrayDepth > 0) {
state=S_EXPECT_VALUE;
}
 else {
state=S_EXPECT_NAME;
}
break;
case ':':
if (state != S_EXPECT_COLON) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
state=S_EXPECT_VALUE;
break;
case '""':
if (state != S_EXPECT_NAME && state != S_EXPECT_FIRST_NAME && state != S_EXPECT_VALUE) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
valueStart=p;
quoted=true;
break;
default :
if (state != S_EXPECT_VALUE) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
valueStart=p - 1;
quoted=false;
}
}
}","public void parse(long lo,long len,JsonListener listener) throws JsonException {
  long p=lo;
  long hi=lo + len;
  long valueStart=useCache ? lo : 0;
  while (p < hi) {
    char c=(char)Unsafe.getUnsafe().getByte(p++);
    if (ignoreNext) {
      ignoreNext=false;
      continue;
    }
    if (valueStart > 0 && ((quoted && c != '""') || (!quoted && !unquotedTeminators.contains(c)))) {
      if (quoted && c == '\\') {
        ignoreNext=true;
      }
      continue;
    }
    if (valueStart > 0) {
      if (state == S_EXPECT_NAME || state == S_EXPECT_FIRST_NAME) {
        listener.onEvent(EVT_NAME,getCharSequence(valueStart,p));
        state=S_EXPECT_COLON;
      }
 else {
        listener.onEvent(arrayDepth > 0 ? EVT_ARRAY_VALUE : EVT_VALUE,getCharSequence(valueStart,p));
        state=S_EXPECT_COMMA;
      }
      valueStart=0;
      cacheSize=0;
      useCache=false;
      if (quoted) {
        continue;
      }
    }
switch (c) {
case '{':
      if (state != S_START && state != S_EXPECT_VALUE) {
        throw JsonException.with(""String_Node_Str"",(int)(p - lo));
      }
    arrayDepthStack.push(arrayDepth);
  arrayDepth=0;
listener.onEvent(EVT_OBJ_START,null);
objDepth++;
state=S_EXPECT_FIRST_NAME;
break;
case '}':
if (arrayDepth > 0) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
if (objDepth > 0) {
switch (state) {
case S_EXPECT_VALUE:
throw JsonException.with(""String_Node_Str"",(int)(p - lo - 1));
case S_EXPECT_NAME:
throw JsonException.with(""String_Node_Str"",(int)(p - lo - 1));
default :
break;
}
listener.onEvent(EVT_OBJ_END,null);
objDepth--;
arrayDepth=arrayDepthStack.pop();
state=S_EXPECT_COMMA;
}
 else {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
break;
case '[':
if (state != S_START && state != S_EXPECT_VALUE) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
listener.onEvent(EVT_ARRAY_START,null);
objDepthStack.push(objDepth);
objDepth=0;
arrayDepth++;
state=S_EXPECT_VALUE;
break;
case ']':
if (objDepth > 0) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
if (arrayDepth == 0) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
listener.onEvent(EVT_ARRAY_END,null);
arrayDepth--;
objDepth=objDepthStack.pop();
state=S_EXPECT_COMMA;
break;
case ' ':
case '\t':
case '\n':
case '\r':
break;
case ',':
if (state != S_EXPECT_COMMA) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
if (arrayDepth > 0) {
state=S_EXPECT_VALUE;
}
 else {
state=S_EXPECT_NAME;
}
break;
case ':':
if (state != S_EXPECT_COLON) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
state=S_EXPECT_VALUE;
break;
case '""':
if (state != S_EXPECT_NAME && state != S_EXPECT_FIRST_NAME && state != S_EXPECT_VALUE) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
valueStart=p;
quoted=true;
break;
default :
if (state != S_EXPECT_VALUE) {
throw JsonException.with(""String_Node_Str"",(int)(p - lo));
}
valueStart=p - 1;
quoted=false;
}
}
if (valueStart > 0) {
cacheIncompleteTag(valueStart,lo,hi);
useCache=true;
}
}",0.94404781670264
30942,"@Override public CharSequence getFlyweightStrB(Record rec){
  csB.init(lhs.getFlyweightStrB(rec),rhs.getFlyweightStrB(rec));
  return csB;
}","@Override public CharSequence getFlyweightStrB(Record rec){
  return csB.of(lhs.getFlyweightStrB(rec),rhs.getFlyweightStrB(rec));
}",0.9003690036900369
30943,"@Override public CharSequence getFlyweightStr(Record rec){
  csA.init(lhs.getFlyweightStr(rec),rhs.getFlyweightStr(rec));
  return csA;
}","@Override public CharSequence getFlyweightStr(Record rec){
  return csA.of(lhs.getFlyweightStr(rec),rhs.getFlyweightStr(rec));
}",0.8981132075471698
30944,"private void assertError(String expected,int expectedPosition,String input) throws JsonException {
  int len=input.length();
  long address=Unsafe.malloc(len);
  try {
    Chars.strcpy(input,len,address);
    try {
      parser.parse(address,len,listener);
      Assert.fail();
    }
 catch (    JsonException e) {
      Assert.assertEquals(expected,e.getMessage());
      Assert.assertEquals(expectedPosition,e.getPosition());
    }
  }
  finally {
    Unsafe.free(address,len);
  }
}","private void assertError(String expected,int expectedPosition,String input) throws JsonException {
  int len=input.length();
  long address=Unsafe.malloc(len);
  try {
    Chars.strcpy(input,len,address);
    try {
      parser.parse(address,len,listener);
      parser.parseLast();
      Assert.fail();
    }
 catch (    JsonException e) {
      Assert.assertEquals(expected,e.getMessage());
      Assert.assertEquals(expectedPosition,e.getPosition());
    }
  }
  finally {
    Unsafe.free(address,len);
  }
}",0.9738955823293172
30945,"private void assertThat(String expected,String input) throws JsonException {
  int len=input.length();
  long address=Unsafe.malloc(len);
  try {
    Chars.strcpy(input,len,address);
    parser.parse(address,len,listener);
    TestUtils.assertEquals(expected,listener.value());
  }
  finally {
    Unsafe.free(address,len);
  }
}","private void assertThat(String expected,String input) throws JsonException {
  int len=input.length();
  long address=Unsafe.malloc(len);
  try {
    Chars.strcpy(input,len,address);
    parser.parse(address,len,listener);
    parser.parseLast();
    TestUtils.assertEquals(expected,listener.value());
  }
  finally {
    Unsafe.free(address,len);
  }
}",0.9648093841642228
30946,"private void sendVanilla(IOContext context,LPSZ path,CharSequence contentType,boolean asAttachment) throws IOException {
  long fd=Files.openRO(path);
  if (fd == -1) {
    LOG.info().$(""String_Node_Str"").$(path).$('(').$(Os.errno()).$(')').$();
    context.simpleResponse().send(404);
  }
 else {
    FileDescriptorHolder h=lvFd.get(context);
    if (h == null) {
      lvFd.set(context,h=new FileDescriptorHolder());
    }
    h.fd=fd;
    h.bytesSent=0;
    final long length=Files.length(path);
    h.sendMax=Long.MAX_VALUE;
    final FixedSizeResponse r=context.fixedSizeResponse();
    r.status(200,contentType,length);
    if (asAttachment) {
      r.headers().put(""String_Node_Str"").put(path).put(""String_Node_Str"").put(Misc.EOL);
    }
    r.headers().put(""String_Node_Str"").put('""').put(Files.getLastModified(path)).put('""').put(Misc.EOL);
    r.sendHeader();
    resume(context);
  }
}","private void sendVanilla(IOContext context,LPSZ path,CharSequence contentType,boolean asAttachment) throws IOException {
  long fd=Files.openRO(path);
  if (fd == -1) {
    LOG.info().$(""String_Node_Str"").$(path).$('(').$(Os.errno()).$(')').$();
    context.simpleResponse().send(404);
  }
 else {
    FileDescriptorHolder h=lvFd.get(context);
    if (h == null) {
      lvFd.set(context,h=new FileDescriptorHolder());
    }
    h.fd=fd;
    h.bytesSent=0;
    final long length=Files.length(path);
    h.sendMax=Long.MAX_VALUE;
    final FixedSizeResponse r=context.fixedSizeResponse();
    r.status(200,contentType,length);
    if (asAttachment) {
      r.headers().put(""String_Node_Str"").put(FileNameExtractorCharSequence.get(path)).put(""String_Node_Str"").put(Misc.EOL);
    }
    r.headers().put(""String_Node_Str"").put('""').put(Files.getLastModified(path)).put('""').put(Misc.EOL);
    r.sendHeader();
    resume(context);
  }
}",0.976464148877942
30947,"private void writeNullString(long headerAddress){
  long addr=mem.allocate(4);
  Unsafe.getUnsafe().putLong(headerAddress,addr);
  Unsafe.getUnsafe().putInt(addr,-1);
}","private void writeNullString(long headerAddress){
  long addr=mem.allocate(4);
  Unsafe.getUnsafe().putLong(headerAddress,addr);
  Unsafe.getUnsafe().putInt(addr,VariableColumn.NULL_LEN);
}",0.9299719887955182
30948,"private void writeRec0(long addr,Record record){
  int varOffset=this.varOffset;
  for (int i=0, n=slaveValueIndexes.size(); i < n; i++) {
    int idx=slaveValueIndexes.getQuick(i);
    long address=addr + fixedOffsets.getQuick(i);
switch (slaveValueTypes.getQuick(i)) {
case ColumnType.INT:
case ColumnType.SYMBOL:
      Unsafe.getUnsafe().putInt(address,record.getInt(idx));
    break;
case ColumnType.LONG:
  Unsafe.getUnsafe().putLong(address,record.getLong(idx));
break;
case ColumnType.FLOAT:
Unsafe.getUnsafe().putFloat(address,record.getFloat(idx));
break;
case ColumnType.DOUBLE:
Unsafe.getUnsafe().putDouble(address,record.getDouble(idx));
break;
case ColumnType.BOOLEAN:
case ColumnType.BYTE:
Unsafe.getUnsafe().putByte(address,record.get(idx));
break;
case ColumnType.SHORT:
Unsafe.getUnsafe().putShort(address,record.getShort(idx));
break;
case ColumnType.DATE:
Unsafe.getUnsafe().putLong(address,record.getDate(idx));
break;
case ColumnType.STRING:
Unsafe.getUnsafe().putInt(address,varOffset);
varOffset+=Chars.strcpyw(record.getFlyweightStr(idx),addr + varOffset);
break;
default :
break;
}
}
}","private void writeRec0(long addr,Record record){
  int varOffset=this.varOffset;
  for (int i=0, n=slaveValueIndexes.size(); i < n; i++) {
    int idx=slaveValueIndexes.getQuick(i);
    long address=addr + fixedOffsets.getQuick(i);
switch (slaveValueTypes.getQuick(i)) {
case ColumnType.INT:
case ColumnType.SYMBOL:
      Unsafe.getUnsafe().putInt(address,record.getInt(idx));
    break;
case ColumnType.LONG:
  Unsafe.getUnsafe().putLong(address,record.getLong(idx));
break;
case ColumnType.FLOAT:
Unsafe.getUnsafe().putFloat(address,record.getFloat(idx));
break;
case ColumnType.DOUBLE:
Unsafe.getUnsafe().putDouble(address,record.getDouble(idx));
break;
case ColumnType.BOOLEAN:
case ColumnType.BYTE:
Unsafe.getUnsafe().putByte(address,record.get(idx));
break;
case ColumnType.SHORT:
Unsafe.getUnsafe().putShort(address,record.getShort(idx));
break;
case ColumnType.DATE:
Unsafe.getUnsafe().putLong(address,record.getDate(idx));
break;
case ColumnType.STRING:
Unsafe.getUnsafe().putInt(address,varOffset);
CharSequence cs=record.getFlyweightStr(idx);
if (cs == null) {
Unsafe.getUnsafe().putInt(addr + varOffset,VariableColumn.NULL_LEN);
varOffset+=4;
}
 else {
varOffset+=Chars.strcpyw(record.getFlyweightStr(idx),addr + varOffset);
}
break;
default :
break;
}
}
}",0.9335576114381834
30949,"public void write(Record record){
  this.held=true;
  int sz=varOffset;
  for (int i=0, n=strCols.size(); i < n; i++) {
    sz+=record.getStrLen(strCols.getQuick(i)) * 2 + 4;
  }
  if (sz > size) {
    alloc(sz);
  }
  int varOffset=this.varOffset;
  for (int i=0, n=types.size(); i < n; i++) {
    long address=this.address + offsets.getQuick(i);
switch (types.getQuick(i)) {
case ColumnType.INT:
case ColumnType.SYMBOL:
      Unsafe.getUnsafe().putInt(address,record.getInt(i));
    break;
case ColumnType.LONG:
  Unsafe.getUnsafe().putLong(address,record.getLong(i));
break;
case ColumnType.FLOAT:
Unsafe.getUnsafe().putFloat(address,record.getFloat(i));
break;
case ColumnType.DOUBLE:
Unsafe.getUnsafe().putDouble(address,record.getDouble(i));
break;
case ColumnType.BOOLEAN:
case ColumnType.BYTE:
Unsafe.getUnsafe().putByte(address,record.get(i));
break;
case ColumnType.SHORT:
Unsafe.getUnsafe().putShort(address,record.getShort(i));
break;
case ColumnType.DATE:
Unsafe.getUnsafe().putLong(address,record.getDate(i));
break;
case ColumnType.STRING:
Unsafe.getUnsafe().putInt(address,varOffset);
varOffset+=Chars.strcpyw(record.getFlyweightStr(i),this.address + varOffset);
break;
default :
break;
}
}
}","public void write(Record record){
  this.held=true;
  int sz=varOffset;
  for (int i=0, n=strCols.size(); i < n; i++) {
    sz+=record.getStrLen(strCols.getQuick(i)) * 2 + 4;
  }
  if (sz > size) {
    alloc(sz);
  }
  int varOffset=this.varOffset;
  for (int i=0, n=types.size(); i < n; i++) {
    long address=this.address + offsets.getQuick(i);
switch (types.getQuick(i)) {
case ColumnType.INT:
case ColumnType.SYMBOL:
      Unsafe.getUnsafe().putInt(address,record.getInt(i));
    break;
case ColumnType.LONG:
  Unsafe.getUnsafe().putLong(address,record.getLong(i));
break;
case ColumnType.FLOAT:
Unsafe.getUnsafe().putFloat(address,record.getFloat(i));
break;
case ColumnType.DOUBLE:
Unsafe.getUnsafe().putDouble(address,record.getDouble(i));
break;
case ColumnType.BOOLEAN:
case ColumnType.BYTE:
Unsafe.getUnsafe().putByte(address,record.get(i));
break;
case ColumnType.SHORT:
Unsafe.getUnsafe().putShort(address,record.getShort(i));
break;
case ColumnType.DATE:
Unsafe.getUnsafe().putLong(address,record.getDate(i));
break;
case ColumnType.STRING:
Unsafe.getUnsafe().putInt(address,varOffset);
CharSequence cs=record.getFlyweightStr(i);
if (cs == null) {
Unsafe.getUnsafe().putInt(this.address + varOffset,VariableColumn.NULL_LEN);
varOffset+=4;
}
 else {
varOffset+=Chars.strcpyw(cs,this.address + varOffset);
}
break;
default :
break;
}
}
}",0.9237387563551036
30950,"@BeforeClass public static void setUpClass() throws Exception {
  FACTORY_CONTAINER.getFactory().getConfiguration().exists(""String_Node_Str"");
  int xcount=100;
  int ycount=10;
  try (JournalWriter xw=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$double(""String_Node_Str"").$str(""String_Node_Str"").$sym(""String_Node_Str"").$float(""String_Node_Str"").$short(""String_Node_Str"").$long(""String_Node_Str"").$bool(""String_Node_Str"").recordCountHint(xcount).$())){
    try (JournalWriter yw=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$str(""String_Node_Str"").recordCountHint(ycount).$())){
      Rnd rnd=new Rnd();
      String[] ccy=new String[3];
      for (int i=0; i < ccy.length; i++) {
        ccy[i]=rnd.nextChars(6).toString();
      }
      long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
      for (int i=0; i < xcount; i++) {
        JournalEntryWriter w=xw.entryWriter();
        w.putDate(0,ts+=10000);
        w.putSym(1,ccy[rnd.nextPositiveInt() % ccy.length]);
        w.putDouble(2,rnd.nextDouble());
        w.putDouble(3,rnd.nextDouble());
        w.putStr(4,rnd.nextChars(rnd.nextPositiveInt() % 128));
        w.putSym(5,ccy[rnd.nextPositiveInt() % ccy.length]);
        w.putFloat(6,rnd.nextFloat());
        w.putShort(7,(short)rnd.nextInt());
        w.putLong(8,rnd.nextLong());
        w.putBool(9,rnd.nextBoolean());
        w.append();
      }
      xw.commit();
      ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
      for (int i=0; i < ycount; i++) {
        JournalEntryWriter w=yw.entryWriter();
        w.putDate(0,ts+=60000);
        w.putSym(1,ccy[rnd.nextPositiveInt() % ccy.length]);
        w.putDouble(2,rnd.nextDouble());
        w.putStr(3,rnd.nextChars(rnd.nextPositiveInt() % 128));
        w.append();
      }
      yw.commit();
      try (JournalWriter jwa=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$())){
        try (JournalWriter jwb=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$())){
          JournalEntryWriter ewa;
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,0.538);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.35);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.41);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,0.601);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.26);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.29);
          ewa.append();
          jwa.commit();
          JournalEntryWriter ewb;
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,1100);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,1200);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,1500);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,130);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,150);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,12000);
          ewb.append();
          jwb.commit();
        }
       }
     }
   }
 }","@BeforeClass public static void setUpClass() throws Exception {
  FACTORY_CONTAINER.getFactory().getConfiguration().exists(""String_Node_Str"");
  int xcount=100;
  int ycount=10;
  try (JournalWriter xw=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$double(""String_Node_Str"").$str(""String_Node_Str"").$sym(""String_Node_Str"").$float(""String_Node_Str"").$short(""String_Node_Str"").$long(""String_Node_Str"").$bool(""String_Node_Str"").recordCountHint(xcount).$())){
    try (JournalWriter yw=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$str(""String_Node_Str"").recordCountHint(ycount).$())){
      Rnd rnd=new Rnd();
      String[] ccy=new String[3];
      for (int i=0; i < ccy.length; i++) {
        ccy[i]=rnd.nextChars(6).toString();
      }
      long ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
      for (int i=0; i < xcount; i++) {
        JournalEntryWriter w=xw.entryWriter();
        w.putDate(0,ts+=10000);
        w.putSym(1,ccy[rnd.nextPositiveInt() % ccy.length]);
        w.putDouble(2,rnd.nextDouble());
        w.putDouble(3,rnd.nextDouble());
        if (rnd.nextBoolean()) {
          w.putStr(4,rnd.nextChars(rnd.nextPositiveInt() % 128));
        }
 else {
          w.putNull(4);
        }
        w.putSym(5,ccy[rnd.nextPositiveInt() % ccy.length]);
        w.putFloat(6,rnd.nextFloat());
        w.putShort(7,(short)rnd.nextInt());
        w.putLong(8,rnd.nextLong());
        w.putBool(9,rnd.nextBoolean());
        w.append();
      }
      xw.commit();
      ts=DateFormatUtils.parseDateTime(""String_Node_Str"");
      for (int i=0; i < ycount; i++) {
        JournalEntryWriter w=yw.entryWriter();
        w.putDate(0,ts+=60000);
        w.putSym(1,ccy[rnd.nextPositiveInt() % ccy.length]);
        w.putDouble(2,rnd.nextDouble());
        if (rnd.nextBoolean()) {
          w.putStr(3,rnd.nextChars(rnd.nextPositiveInt() % 128));
        }
 else {
          w.putNull(3);
        }
        w.append();
      }
      yw.commit();
      try (JournalWriter jwa=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$())){
        try (JournalWriter jwb=FACTORY_CONTAINER.getFactory().writer(new JournalStructure(""String_Node_Str"").$ts().$sym(""String_Node_Str"").$double(""String_Node_Str"").$())){
          JournalEntryWriter ewa;
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,0.538);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.35);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.41);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,0.601);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.26);
          ewa.append();
          ewa=jwa.entryWriter();
          ewa.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewa.putSym(1,""String_Node_Str"");
          ewa.putDouble(2,1.29);
          ewa.append();
          jwa.commit();
          JournalEntryWriter ewb;
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,1100);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,1200);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,1500);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,130);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,150);
          ewb.append();
          ewb=jwb.entryWriter();
          ewb.putDate(0,DateFormatUtils.parseDateTime(""String_Node_Str""));
          ewb.putSym(1,""String_Node_Str"");
          ewb.putDouble(2,12000);
          ewb.append();
          jwb.commit();
        }
       }
     }
   }
 }",0.982734669577297
30951,"@SuppressWarnings(""String_Node_Str"") public void of(long address,int len){
  long lim=address + len;
  long p=address;
  boolean suspended=false;
  int line=0;
  int comma=0;
  int pipe=0;
  int tab=0;
  int _comma=0;
  int _pipe=0;
  int _tab=0;
  commas.clear();
  pipes.clear();
  tabs.clear();
  this.avgRecLen=0;
  this.stdDev=Double.POSITIVE_INFINITY;
  this.delimiter=0;
  boolean eol=false;
  while (p < lim && line < maxLines) {
    char b=(char)Unsafe.getUnsafe().getByte(p++);
    if (suspended && b != '""') {
      continue;
    }
switch (b) {
case ',':
      comma++;
    if (eol) {
      eol=false;
    }
  break;
case '|':
pipe++;
if (eol) {
eol=false;
}
break;
case '\t':
tab++;
if (eol) {
eol=false;
}
break;
case '""':
suspended=!suspended;
if (eol) {
eol=false;
}
break;
case '\n':
if (eol) {
break;
}
line++;
commas.add(comma - _comma);
pipes.add(pipe - _pipe);
tabs.add(tab - _tab);
_comma=comma;
_pipe=pipe;
_tab=tab;
eol=true;
break;
default :
if (eol) {
eol=false;
}
break;
}
}
if (line == 0) {
return;
}
this.avgRecLen=len / line;
heap.clear();
heap.add(CSV,comma);
heap.add(PIPE,pipe);
heap.add(TAB,tab);
this.delimiter=(char)heap.peekBottom();
IntList test;
switch (delimiter) {
case CSV:
test=commas;
break;
case PIPE:
test=pipes;
break;
case TAB:
test=tabs;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + delimiter);
}
double temp;
int n=test.size();
if (n == 0) {
delimiter=0;
return;
}
temp=0;
for (int i=0; i < n; i++) {
temp+=test.getQuick(i);
}
double mean=temp / n;
temp=0;
for (int i=0; i < n; i++) {
int v=test.getQuick(i);
temp+=(mean - v) * (mean - v);
}
this.stdDev=Math.sqrt(temp / n);
}","@SuppressWarnings(""String_Node_Str"") public void of(long address,int len){
  long lim=address + len;
  long p=address;
  boolean suspended=false;
  int line=0;
  int comma=0;
  int pipe=0;
  int tab=0;
  int semicolon=0;
  int _comma=0;
  int _pipe=0;
  int _tab=0;
  int _semicolon=0;
  commas.clear();
  pipes.clear();
  tabs.clear();
  semicolons.clear();
  this.avgRecLen=0;
  this.stdDev=Double.POSITIVE_INFINITY;
  this.delimiter=0;
  boolean eol=false;
  while (p < lim && line < maxLines) {
    char b=(char)Unsafe.getUnsafe().getByte(p++);
    if (suspended && b != '""') {
      continue;
    }
switch (b) {
case ',':
      comma++;
    if (eol) {
      eol=false;
    }
  break;
case '|':
pipe++;
if (eol) {
eol=false;
}
break;
case '\t':
tab++;
if (eol) {
eol=false;
}
break;
case ';':
semicolon++;
if (eol) {
eol=false;
}
break;
case '""':
suspended=!suspended;
if (eol) {
eol=false;
}
break;
case '\n':
if (eol) {
break;
}
line++;
commas.add(comma - _comma);
pipes.add(pipe - _pipe);
tabs.add(tab - _tab);
semicolons.add(semicolon - _semicolon);
_comma=comma;
_pipe=pipe;
_tab=tab;
_semicolon=semicolon;
eol=true;
break;
default :
if (eol) {
eol=false;
}
break;
}
}
if (line == 0) {
return;
}
this.avgRecLen=len / line;
heap.clear();
heap.add(CSV,comma);
heap.add(PIPE,pipe);
heap.add(TAB,tab);
heap.add(';',semicolon);
this.delimiter=(char)heap.peekBottom();
IntList test;
switch (delimiter) {
case CSV:
test=commas;
break;
case PIPE:
test=pipes;
break;
case TAB:
test=tabs;
break;
case ';':
test=semicolons;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + delimiter);
}
double temp;
int n=test.size();
if (n == 0) {
delimiter=0;
return;
}
temp=0;
for (int i=0; i < n; i++) {
temp+=test.getQuick(i);
}
double mean=temp / n;
temp=0;
for (int i=0; i < n; i++) {
int v=test.getQuick(i);
temp+=(mean - v) * (mean - v);
}
this.stdDev=Math.sqrt(temp / n);
}",0.8966101694915254
30952,"@Override public void onFields(int line,ObjList<DirectByteCharSequence> values,int hi){
  boolean append=true;
  try {
    JournalEntryWriter w=writer.entryWriter();
    for (int i=0; i < hi; i++) {
      if (values.getQuick(i).length() == 0) {
        continue;
      }
      try {
        ImportedColumnMetadata m=metadata.getQuick(i);
switch (m.importedColumnType) {
case ColumnType.STRING:
          utf8Sink.clear();
        Chars.utf8Decode(values.getQuick(i),utf8Sink);
      w.putStr(i,(DirectBytes)utf8Sink);
    break;
case ColumnType.DOUBLE:
  w.putDouble(i,Numbers.parseDouble(values.getQuick(i)));
break;
case ColumnType.INT:
w.putInt(i,Numbers.parseInt(values.getQuick(i)));
break;
case ColumnType.FLOAT:
w.putFloat(i,Numbers.parseFloat(values.getQuick(i)));
break;
case ColumnType.DATE:
if (m.dateFormat != null && m.dateLocale != null) {
w.putDate(i,m.dateFormat.parse(values.getQuick(i),m.dateLocale));
}
 else {
throw NumericException.INSTANCE;
}
break;
case ColumnType.SYMBOL:
w.putSym(i,values.getQuick(i));
break;
case ColumnType.LONG:
w.putLong(i,Numbers.parseLong(values.getQuick(i)));
break;
case ColumnType.BOOLEAN:
w.putBool(i,Chars.equalsIgnoreCase(values.getQuick(i),""String_Node_Str""));
break;
default :
break;
}
}
 catch (Exception e) {
switch (atomicity) {
case ATOMICITY_STRICT:
LOG.info().$(""String_Node_Str"").$(line).$(',').$(i).$(')').$();
throw new JournalRuntimeException(""String_Node_Str"" + line + ""String_Node_Str""+ i);
default :
errors.increment(i);
LOG.debug().$(""String_Node_Str"").$(line).$(',').$(i).$(""String_Node_Str"").$(metadata.getQuick(i).importedColumnType).$(""String_Node_Str"").$(e.getMessage()).$();
append=false;
}
break;
}
}
if (append) {
w.append();
}
}
 catch (JournalException e) {
throw new JournalRuntimeException(e);
}
}","@Override public void onFields(int line,ObjList<DirectByteCharSequence> values,int hi){
  boolean append=true;
  try {
    JournalEntryWriter w=writer.entryWriter();
    for (int i=0; i < hi; i++) {
      if (values.getQuick(i).length() == 0) {
        continue;
      }
      try {
        ImportedColumnMetadata m=metadata.getQuick(i);
switch (m.importedColumnType) {
case ColumnType.STRING:
          utf8Sink.clear();
        Chars.utf8Decode(values.getQuick(i),utf8Sink);
      w.putStr(i,(DirectBytes)utf8Sink);
    break;
case ColumnType.DOUBLE:
  w.putDouble(i,Numbers.parseDouble(values.getQuick(i)));
break;
case ColumnType.INT:
w.putInt(i,Numbers.parseInt(values.getQuick(i)));
break;
case ColumnType.FLOAT:
w.putFloat(i,Numbers.parseFloat(values.getQuick(i)));
break;
case ColumnType.DATE:
if (m.dateFormat != null && m.dateLocale != null) {
w.putDate(i,m.dateFormat.parse(values.getQuick(i),m.dateLocale));
}
 else {
throw NumericException.INSTANCE;
}
break;
case ColumnType.SYMBOL:
utf8Sink.clear();
Chars.utf8Decode(values.getQuick(i),utf8Sink);
w.putSym(i,utf8Sink);
break;
case ColumnType.LONG:
w.putLong(i,Numbers.parseLong(values.getQuick(i)));
break;
case ColumnType.BOOLEAN:
w.putBool(i,Chars.equalsIgnoreCase(values.getQuick(i),""String_Node_Str""));
break;
default :
break;
}
}
 catch (Exception e) {
switch (atomicity) {
case ATOMICITY_STRICT:
LOG.info().$(""String_Node_Str"").$(line).$(',').$(i).$(')').$();
throw new JournalRuntimeException(""String_Node_Str"" + line + ""String_Node_Str""+ i);
default :
errors.increment(i);
LOG.debug().$(""String_Node_Str"").$(line).$(',').$(i).$(""String_Node_Str"").$(metadata.getQuick(i).importedColumnType).$(""String_Node_Str"").$(e.getMessage()).$();
append=false;
}
break;
}
}
if (append) {
w.append();
}
}
 catch (JournalException e) {
throw new JournalRuntimeException(e);
}
}",0.9748131746471076
30953,"@SuppressWarnings(""String_Node_Str"") private static float parseFloat(CharSequence sequence,int lo,int lim) throws NumericException {
  int p=lo;
  if (lim == p) {
    throw NumericException.INSTANCE;
  }
  boolean negative=sequence.charAt(p) == '-';
  if (negative) {
    p++;
  }
  if (p >= lim) {
    throw NumericException.INSTANCE;
  }
switch (sequence.charAt(p)) {
case 'N':
    return parseFloatConst(sequence,p,lim,NaN,Float.NaN);
case 'I':
  return parseFloatConst(sequence,p,lim,INFINITY,negative ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY);
default :
break;
}
int val=0;
int dp=-1;
int dpe=lim;
int exp=0;
out: for (int i=p; i < lim; i++) {
int c=sequence.charAt(i);
switch (c) {
case '.':
dp=i;
continue;
case 'E':
case 'e':
exp=parseInt(sequence,i + 1,lim);
if (dpe == lim) {
dpe=i;
}
break out;
case 'F':
case 'f':
if (i + 1 < lim) {
throw NumericException.INSTANCE;
}
if (dpe == lim) {
dpe=i;
}
break out;
default :
if (c < '0' || c > '9') {
throw NumericException.INSTANCE;
}
if (val <= INT_OVERFLOW_MAX) {
val=(val << 3) + (val << 1) + (c - '0');
}
 else if (dpe == lim) {
dpe=i;
}
break;
}
}
exp=dp == -1 ? exp : exp - (dpe - dp - 1);
if (exp > 38) {
exp=38;
}
 else if (exp < -38) {
exp=-38;
}
if (exp > 0) {
return (negative ? -val : val) * pow10f[exp];
}
 else {
return (negative ? -val : val) / pow10f[-exp];
}
}","@SuppressWarnings(""String_Node_Str"") private static float parseFloat(CharSequence sequence,int lo,int lim) throws NumericException {
  int p=lo;
  if (lim == p) {
    throw NumericException.INSTANCE;
  }
  boolean negative=sequence.charAt(p) == '-';
  if (negative) {
    p++;
  }
  if (p >= lim) {
    throw NumericException.INSTANCE;
  }
switch (sequence.charAt(p)) {
case 'N':
    return parseFloatConst(sequence,p,lim,NaN,Float.NaN);
case 'I':
  return parseFloatConst(sequence,p,lim,INFINITY,negative ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY);
default :
break;
}
int val=0;
int dp=-1;
int dpe=lim;
int exp=0;
out: for (int i=p; i < lim; i++) {
int c=sequence.charAt(i);
switch (c) {
case '.':
dp=i;
continue;
case 'E':
case 'e':
exp=parseInt(sequence,i + 1,lim);
if (dpe == lim) {
dpe=i;
}
break out;
case 'F':
case 'f':
if (i == 0 || i + 1 < lim) {
throw NumericException.INSTANCE;
}
if (dpe == lim) {
dpe=i;
}
break out;
default :
if (c < '0' || c > '9') {
throw NumericException.INSTANCE;
}
if (val <= INT_OVERFLOW_MAX) {
val=(val << 3) + (val << 1) + (c - '0');
}
 else if (dpe == lim) {
dpe=i;
}
break;
}
}
exp=dp == -1 ? exp : exp - (dpe - dp - 1);
if (exp > 38) {
exp=38;
}
 else if (exp < -38) {
exp=-38;
}
if (exp > 0) {
return (negative ? -val : val) * pow10f[exp];
}
 else {
return (negative ? -val : val) / pow10f[-exp];
}
}",0.9962880475129918
30954,"@SuppressWarnings(""String_Node_Str"") private static double parseDouble(CharSequence sequence,final int p,int lim) throws NumericException {
  if (lim == p) {
    throw NumericException.INSTANCE;
  }
  boolean negative=sequence.charAt(p) == '-';
  int i=p;
  if (negative) {
    i++;
  }
  if (i >= lim) {
    throw NumericException.INSTANCE;
  }
switch (sequence.charAt(i)) {
case 'N':
    return parseConst(sequence,i,lim,NaN,Double.NaN);
case 'I':
  return parseConst(sequence,i,lim,INFINITY,negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
default :
break;
}
long val=0;
int dp=-1;
int dpe=lim;
int exp=0;
out: for (; i < lim; i++) {
int c=sequence.charAt(i);
switch (c) {
case '.':
dp=i;
continue;
case 'E':
case 'e':
exp=parseInt(sequence,i + 1,lim);
if (dpe == lim) {
dpe=i;
}
break out;
case 'D':
case 'd':
if (i + 1 < lim) {
throw NumericException.INSTANCE;
}
if (dpe == lim) {
dpe=i;
}
break out;
default :
if (c < '0' || c > '9') {
throw NumericException.INSTANCE;
}
if (val <= LONG_OVERFLOW_MAX) {
val=(val << 3) + (val << 1) + (c - '0');
}
 else if (dpe == lim) {
dpe=i;
}
break;
}
}
exp=dp == -1 ? exp : exp - (dpe - dp - 1);
if (exp > 308) {
exp=308;
}
 else if (exp < -308) {
exp=-308;
}
if (exp > 0) {
return (negative ? -val : val) * pow10d[exp];
}
 else {
return (negative ? -val : val) / pow10d[-exp];
}
}","@SuppressWarnings(""String_Node_Str"") private static double parseDouble(CharSequence sequence,final int p,int lim) throws NumericException {
  if (lim == p) {
    throw NumericException.INSTANCE;
  }
  boolean negative=sequence.charAt(p) == '-';
  int i=p;
  if (negative) {
    i++;
  }
  if (i >= lim) {
    throw NumericException.INSTANCE;
  }
switch (sequence.charAt(i)) {
case 'N':
    return parseConst(sequence,i,lim,NaN,Double.NaN);
case 'I':
  return parseConst(sequence,i,lim,INFINITY,negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);
default :
break;
}
long val=0;
int dp=-1;
int dpe=lim;
int exp=0;
out: for (; i < lim; i++) {
int c=sequence.charAt(i);
switch (c) {
case '.':
dp=i;
continue;
case 'E':
case 'e':
exp=parseInt(sequence,i + 1,lim);
if (dpe == lim) {
dpe=i;
}
break out;
case 'D':
case 'd':
if (i + 1 < lim || i == 0) {
throw NumericException.INSTANCE;
}
if (dpe == lim) {
dpe=i;
}
break out;
default :
if (c < '0' || c > '9') {
throw NumericException.INSTANCE;
}
if (val <= LONG_OVERFLOW_MAX) {
val=(val << 3) + (val << 1) + (c - '0');
}
 else if (dpe == lim) {
dpe=i;
}
break;
}
}
exp=dp == -1 ? exp : exp - (dpe - dp - 1);
if (exp > 308) {
exp=308;
}
 else if (exp < -308) {
exp=-308;
}
if (exp > 0) {
return (negative ? -val : val) * pow10d[exp];
}
 else {
return (negative ? -val : val) / pow10d[-exp];
}
}",0.9962825278810408
30955,"private static long parseLong0(CharSequence sequence,final int p,int lim) throws NumericException {
  if (lim == p) {
    throw NumericException.INSTANCE;
  }
  boolean negative=sequence.charAt(p) == '-';
  int i=p;
  if (negative) {
    i++;
  }
  if (i >= lim) {
    throw NumericException.INSTANCE;
  }
  long val=0;
  for (; i < lim; i++) {
    int c=sequence.charAt(i);
    if (c == 'L' || c == 'l') {
      if (i + 1 < lim) {
        throw NumericException.INSTANCE;
      }
      break;
    }
    if (c < '0' || c > '9') {
      throw NumericException.INSTANCE;
    }
    long r=(val << 3) + (val << 1) - (c - '0');
    if (r > val) {
      throw NumericException.INSTANCE;
    }
    val=r;
  }
  if (val == Long.MIN_VALUE && !negative) {
    throw NumericException.INSTANCE;
  }
  return negative ? val : -val;
}","private static long parseLong0(CharSequence sequence,final int p,int lim) throws NumericException {
  if (lim == p) {
    throw NumericException.INSTANCE;
  }
  boolean negative=sequence.charAt(p) == '-';
  int i=p;
  if (negative) {
    i++;
  }
  if (i >= lim) {
    throw NumericException.INSTANCE;
  }
  long val=0;
  for (; i < lim; i++) {
    int c=sequence.charAt(i);
    if (c == 'L' || c == 'l') {
      if (i == 0 || i + 1 < lim) {
        throw NumericException.INSTANCE;
      }
      break;
    }
    if (c < '0' || c > '9') {
      throw NumericException.INSTANCE;
    }
    long r=(val << 3) + (val << 1) - (c - '0');
    if (r > val) {
      throw NumericException.INSTANCE;
    }
    val=r;
  }
  if (val == Long.MIN_VALUE && !negative) {
    throw NumericException.INSTANCE;
  }
  return negative ? val : -val;
}",0.993939393939394
30956,"@Override public void onLineCount(int count){
  if (calcTypes(count,true) && (forceHeader || !calcTypes(count - 1,false))) {
    for (int i=0; i < fieldCount; i++) {
      _metadata.getQuick(i).name=_headers.getQuick(i);
    }
    header=true;
  }
  if (!header) {
    for (int i=0; i < fieldCount; i++) {
      tempSink.clear();
      tempSink.put('f').put(i);
      _metadata.getQuick(i).name=tempSink.toString();
    }
  }
  if (schemaColumns.size() > 0) {
    for (int i=0, k=_metadata.size(); i < k; i++) {
      ImportedColumnMetadata _m=_metadata.getQuick(i);
      ImportedColumnMetadata m=schemaColumns.get(_m.name);
      if (m != null) {
        _m.importedColumnType=m.importedColumnType;
      }
    }
  }
}","@Override public void onLineCount(int count){
  if ((calcTypes(count,true) && !calcTypes(count - 1,false)) || forceHeader) {
    for (int i=0; i < fieldCount; i++) {
      _metadata.getQuick(i).name=_headers.getQuick(i);
    }
    header=true;
  }
  if (!header) {
    for (int i=0; i < fieldCount; i++) {
      tempSink.clear();
      tempSink.put('f').put(i);
      _metadata.getQuick(i).name=tempSink.toString();
    }
  }
  if (schemaColumns.size() > 0) {
    for (int i=0, k=_metadata.size(); i < k; i++) {
      ImportedColumnMetadata _m=_metadata.getQuick(i);
      ImportedColumnMetadata m=schemaColumns.get(_m.name);
      if (m != null) {
        _m.importedColumnType=m.importedColumnType;
      }
    }
  }
}",0.1763888888888889
30957,"@Override public boolean canClose(Journal journal){
  String name=journal.getName();
  if (journal instanceof R) {
    Entry e=entries.get(name);
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      return true;
    }
    long thread=Thread.currentThread().getId();
    R r=(R)journal;
    if (Unsafe.arrayGet(r.entry.allocations,r.index) == thread) {
      if (closed) {
        Unsafe.arrayPut(r.entry.readers,r.index,null);
        return true;
      }
      Unsafe.arrayPut(r.entry.releaseTimes,r.index,System.currentTimeMillis());
      Unsafe.arrayPutOrdered(r.entry.allocations,r.index,-1L);
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
      return false;
    }
    LOG.error().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(r.entry.index).$(',').$(r.index).$();
  }
 else {
    LOG.error().$(""String_Node_Str"").$(name).$();
  }
  return true;
}","@Override public boolean canClose(Journal journal){
  String name=journal.getName();
  if (journal instanceof R) {
    Entry e=entries.get(name);
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      return true;
    }
    long thread=Thread.currentThread().getId();
    R r=(R)journal;
    if (Unsafe.arrayGet(r.entry.allocations,r.index) == thread) {
      if (closed) {
        Unsafe.arrayPut(r.entry.readers,r.index,null);
        return true;
      }
      Unsafe.arrayPut(r.entry.releaseTimes,r.index,System.currentTimeMillis());
      Unsafe.arrayPutOrdered(r.entry.allocations,r.index,UNALLOCATED);
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
      return false;
    }
    LOG.error().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(r.entry.index).$(',').$(r.index).$();
  }
 else {
    LOG.error().$(""String_Node_Str"").$(name).$();
  }
  return true;
}",0.9939086294416244
30958,"@Override @SuppressWarnings(""String_Node_Str"") public <T>Journal<T> reader(JournalMetadata<T> metadata) throws JournalException {
  if (closed) {
    LOG.info().$(""String_Node_Str"");
    return null;
  }
  String name=metadata.getKey().getName();
  Entry e=entries.get(name);
  long thread=Thread.currentThread().getId();
  if (e == null) {
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    e=new Entry(0);
    Entry other=entries.putIfAbsent(name,e);
    if (other != null) {
      e=other;
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
 else {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
  }
  do {
    for (int i=0, n=e.allocations.length; i < n; i++) {
      if (Unsafe.cas(e.allocations,i,-1L,thread)) {
        LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$();
        R r=Unsafe.arrayGet(e.readers,i);
        if (r == null) {
          Unsafe.arrayPut(e.readers,i,r=new R<>(e,i,metadata));
          if (!closed) {
            r.setCloseInterceptor(this);
          }
        }
        if (closed) {
          r.setCloseInterceptor(null);
        }
        return r;
      }
    }
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
    if (e.nextStatus == 0) {
      if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,0,1)) {
        LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
        e.next=new Entry(e.index + 1);
      }
    }
    if (e.nextStatus == 2) {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
      return null;
    }
    e=e.next;
  }
 while (e.index < maxEntries);
  LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(this.maxEntries).$(')').$();
  return null;
}","@Override @SuppressWarnings(""String_Node_Str"") public <T>Journal<T> reader(JournalMetadata<T> metadata) throws JournalException {
  if (closed) {
    LOG.info().$(""String_Node_Str"");
    return null;
  }
  String name=metadata.getKey().getName();
  Entry e=entries.get(name);
  long thread=Thread.currentThread().getId();
  if (e == null) {
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    e=new Entry(0);
    Entry other=entries.putIfAbsent(name,e);
    if (other != null) {
      e=other;
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
 else {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
  }
  do {
    for (int i=0; i < ENTRY_SIZE; i++) {
      if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
        LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$();
        R r=Unsafe.arrayGet(e.readers,i);
        if (r == null) {
          r=new R(e,i,metadata);
          if (closed) {
            return r;
          }
          Unsafe.arrayPut(e.readers,i,r);
          r.setCloseInterceptor(this);
        }
        if (closed) {
          Unsafe.arrayPut(e.readers,i,null);
          r.setCloseInterceptor(null);
        }
        return r;
      }
    }
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
    if (e.nextStatus == 0) {
      if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,0,1)) {
        LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
        e.next=new Entry(e.index + 1);
      }
    }
    if (e.nextStatus == 2) {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
      return null;
    }
    e=e.next;
  }
 while (e != null && e.index < maxEntries);
  LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(this.maxEntries).$(')').$();
  return null;
}",0.8995699468757905
30959,"private void releaseAll(long deadline){
  long thread=Thread.currentThread().getId();
  R r;
  for (  Map.Entry<String,Entry> me : entries.entrySet()) {
    Entry e=me.getValue();
    do {
      for (int i=0; i < ENTRY_SIZE; i++) {
        if (deadline > Unsafe.arrayGet(e.releaseTimes,i) && (r=Unsafe.arrayGet(e.readers,i)) != null) {
          if (Unsafe.cas(e.allocations,i,-1L,thread)) {
            if (deadline > Unsafe.arrayGet(e.releaseTimes,i)) {
              r.setCloseInterceptor(null);
              try {
                r.close();
              }
 catch (              Throwable e1) {
                LOG.error().$(""String_Node_Str"").$(r.getName()).$(""String_Node_Str"").$(e1.getMessage()).$();
              }
              Unsafe.arrayPut(e.readers,i,null);
            }
          }
        }
      }
      e=e.next;
    }
 while (e != null);
  }
}","private void releaseAll(long deadline){
  long thread=Thread.currentThread().getId();
  R r;
  for (  Map.Entry<String,Entry> me : entries.entrySet()) {
    Entry e=me.getValue();
    do {
      for (int i=0; i < ENTRY_SIZE; i++) {
        if (deadline > Unsafe.arrayGet(e.releaseTimes,i) && (r=Unsafe.arrayGet(e.readers,i)) != null) {
          if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
            if (deadline > Unsafe.arrayGet(e.releaseTimes,i)) {
              r.setCloseInterceptor(null);
              try {
                r.close();
              }
 catch (              Throwable e1) {
                LOG.error().$(""String_Node_Str"").$(r.getName()).$(""String_Node_Str"").$(e1.getMessage()).$();
              }
              Unsafe.arrayPut(e.readers,i,null);
            }
            Unsafe.arrayPutOrdered(e.allocations,i,UNALLOCATED);
          }
        }
      }
      e=e.next;
    }
 while (e != null);
  }
}",0.9572933998890738
30960,"public int countFreeWriters(){
  int count=0;
  for (  Map.Entry<String,Entry> me : entries.entrySet()) {
    if (me.getValue().owner == -1L) {
      count++;
    }
  }
  return count;
}","int countFreeWriters(){
  int count=0;
  for (  Map.Entry<String,Entry> me : entries.entrySet()) {
    Entry e=me.getValue();
    if (e.owner == -1L) {
      count++;
    }
 else {
      LOG.info().$(""String_Node_Str"").$(me.getKey()).$(""String_Node_Str"").$(me.getValue().owner).$();
    }
  }
  return count;
}",0.7056451612903226
30961,"private boolean releaseAll(long deadline){
  long threadId=Thread.currentThread().getId();
  boolean removed=false;
  Iterator<Map.Entry<String,Entry>> iterator=entries.entrySet().iterator();
  while (iterator.hasNext()) {
    Map.Entry<String,Entry> me=iterator.next();
    Entry e=me.getValue();
    if ((deadline > e.lastReleaseTime && e.owner == -1)) {
      if (Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,threadId)) {
        LOG.info().$(""String_Node_Str"").$(me.getKey()).$('\'').$();
        e.writer.setCloseInterceptor(null);
        try {
          e.writer.close();
        }
 catch (        Throwable e1) {
          LOG.error().$(""String_Node_Str"").$(e.writer.getName()).$(""String_Node_Str"").$(e1.getMessage()).$();
        }
        iterator.remove();
        removed=true;
        Unsafe.getUnsafe().putOrderedLong(e,ENTRY_OWNER,-1L);
      }
    }
 else     if (e.allocationFailure) {
      LOG.info().$(""String_Node_Str"").$(me.getKey()).$('\'').$();
      iterator.remove();
      removed=true;
    }
  }
  return removed;
}","private boolean releaseAll(long deadline){
  long threadId=Thread.currentThread().getId();
  boolean removed=false;
  Iterator<Map.Entry<String,Entry>> iterator=entries.entrySet().iterator();
  while (iterator.hasNext()) {
    Map.Entry<String,Entry> me=iterator.next();
    Entry e=me.getValue();
    if ((deadline > e.lastReleaseTime && e.owner == -1)) {
      if (Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,threadId)) {
        LOG.info().$(""String_Node_Str"").$(me.getKey()).$('\'').$();
        JournalWriter w=e.writer;
        if (w != null) {
          w.setCloseInterceptor(null);
          try {
            w.close();
          }
 catch (          Throwable e1) {
            LOG.error().$(""String_Node_Str"").$(w.getName()).$(""String_Node_Str"").$(e1.getMessage()).$();
          }
        }
        iterator.remove();
        removed=true;
        Unsafe.getUnsafe().putOrderedLong(e,ENTRY_OWNER,-1L);
      }
    }
 else     if (e.allocationFailure) {
      LOG.info().$(""String_Node_Str"").$(me.getKey()).$('\'').$();
      iterator.remove();
      removed=true;
    }
  }
  return removed;
}",0.952073732718894
30962,"@Override @SuppressWarnings(""String_Node_Str"") public <T>JournalWriter<T> writer(JournalMetadata<T> metadata) throws JournalException {
  if (closed) {
    LOG.info().$(""String_Node_Str"").$();
    return null;
  }
  final String path=metadata.getKey().getName();
  Entry e=entries.get(path);
  if (e == null) {
    e=new Entry();
    if (entries.putIfAbsent(path,e) == null) {
      try {
        e.writer=super.writer(metadata);
        if (!closed) {
          e.writer.setCloseInterceptor(this);
        }
        LOG.info().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(e.owner).$();
        return e.writer;
      }
 catch (      JournalException ex) {
        LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(ex).$();
        e.allocationFailure=true;
        return null;
      }
    }
 else {
      LOG.info().$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(path).$('\'').$();
      e=entries.get(path);
    }
  }
  long threadId=Thread.currentThread().getId();
  if (e != null && Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,threadId)) {
    LOG.debug().$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(path).$();
    if (closed) {
      e.writer.setCloseInterceptor(null);
    }
    return e.writer;
  }
 else {
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$();
    }
 else {
      if (e.owner == threadId) {
        if (e.allocationFailure) {
          return null;
        }
        if (closed) {
          LOG.info().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$();
          e.writer.setCloseInterceptor(null);
        }
        return e.writer;
      }
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(e.owner).$();
    }
  }
  return null;
}","@Override @SuppressWarnings(""String_Node_Str"") public <T>JournalWriter<T> writer(JournalMetadata<T> metadata) throws JournalException {
  if (closed) {
    LOG.info().$(""String_Node_Str"").$();
    return null;
  }
  final String path=metadata.getKey().getName();
  Entry e=entries.get(path);
  if (e == null) {
    e=new Entry();
    if (entries.putIfAbsent(path,e) == null) {
      try {
        JournalWriter w=super.writer(metadata);
        if (closed) {
          return w;
        }
        w.setCloseInterceptor(this);
        LOG.info().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(e.owner).$();
        return e.writer=w;
      }
 catch (      JournalException ex) {
        LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(ex).$();
        e.allocationFailure=true;
        return null;
      }
    }
 else {
      LOG.info().$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(path).$('\'').$();
      e=entries.get(path);
    }
  }
  long threadId=Thread.currentThread().getId();
  if (e != null && Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,threadId)) {
    LOG.debug().$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(path).$();
    if (closed) {
      e.writer.setCloseInterceptor(null);
    }
    return e.writer;
  }
 else {
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$();
    }
 else {
      if (e.owner == threadId) {
        if (e.allocationFailure) {
          return null;
        }
        if (closed) {
          LOG.info().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$();
          e.writer.setCloseInterceptor(null);
        }
        return e.writer;
      }
      LOG.error().$(""String_Node_Str"").$(path).$(""String_Node_Str"").$(e.owner).$();
    }
  }
  return null;
}",0.9798842656379168
30963,"@Test public void testAllocateAndClear() throws Exception {
  final JournalMetadata<?> m=theFactory.getConfiguration().buildWithRootLocation(new JournalStructure(""String_Node_Str"").$date(""String_Node_Str"").$());
  final CachingWriterFactory wf=theFactory.getCachingWriterFactory();
  int n=2;
  final CyclicBarrier barrier=new CyclicBarrier(n);
  final CountDownLatch halt=new CountDownLatch(n);
  final AtomicInteger errors=new AtomicInteger();
  final AtomicInteger writerCount=new AtomicInteger();
  new Thread(){
    @Override public void run(){
      try {
        for (int i=0; i < 1000; i++) {
          try (JournalWriter w=wf.writer(m)){
            if (w != null) {
              writerCount.incrementAndGet();
            }
          }
           if (i == 1) {
            barrier.await();
          }
          LockSupport.parkNanos(10L);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
  }
.start();
  new Thread(){
    @Override public void run(){
      try {
        barrier.await();
        for (int i=0; i < 1000; i++) {
          wf.run();
          LockSupport.parkNanos(10L);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
  }
.start();
  halt.await();
  Assert.assertTrue(writerCount.get() > 0);
  Assert.assertEquals(0,errors.get());
  Assert.assertEquals(1,wf.countFreeWriters());
}","@Test public void testAllocateAndClear() throws Exception {
  final JournalMetadata<?> m=theFactory.getConfiguration().buildWithRootLocation(new JournalStructure(""String_Node_Str"").$date(""String_Node_Str"").$());
  final CachingWriterFactory wf=theFactory.getCachingWriterFactory();
  int n=2;
  final CyclicBarrier barrier=new CyclicBarrier(n);
  final CountDownLatch halt=new CountDownLatch(n);
  final AtomicInteger errors=new AtomicInteger();
  final AtomicInteger writerCount=new AtomicInteger();
  new Thread(){
    @Override public void run(){
      try {
        for (int i=0; i < 1000; i++) {
          try (JournalWriter w=wf.writer(m)){
            if (w != null) {
              writerCount.incrementAndGet();
            }
          }
           if (i == 1) {
            barrier.await();
          }
          LockSupport.parkNanos(10L);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
  }
.start();
  new Thread(){
    @Override public void run(){
      try {
        barrier.await();
        for (int i=0; i < 1000; i++) {
          wf.run();
          LockSupport.parkNanos(10L);
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        errors.incrementAndGet();
      }
 finally {
        halt.countDown();
      }
    }
  }
.start();
  halt.await();
  Assert.assertTrue(writerCount.get() > 0);
  Assert.assertEquals(0,errors.get());
}",0.984251968503937
30964,"private JournalWriter checkAndReturn(long thread,Entry e,String name,JournalMetadata<?> metadata) throws JournalException {
  JournalMetadata wm=e.writer.getMetadata();
  if (metadata.isCompatible(wm,false)) {
    if (metadata.getModelClass() != null && wm.getModelClass() == null) {
      closeWriter(thread,e,FactoryEventListener.EV_CLOSE,FactoryEventListener.EV_CLOSE_EX,FactoryConstants.CR_REOPEN);
      createWriter(thread,name,e,metadata);
    }
 else {
      notifyListener(thread,name,FactoryEventListener.EV_GET);
    }
    return e.writer;
  }
  JournalMetadataException ex=new JournalMetadataException(wm,metadata);
  notifyListener(thread,name,FactoryEventListener.EV_INCOMPATIBLE);
  if (closed) {
    closeWriter(thread,e,FactoryEventListener.EV_CLOSE,FactoryEventListener.EV_CLOSE_EX,FactoryConstants.CR_POOL_CLOSE);
  }
  e.owner=-1L;
  throw ex;
}","private JournalWriter checkAndReturn(long thread,Entry e,String name,JournalMetadata<?> metadata) throws JournalException {
  JournalMetadata wm=e.writer.getMetadata();
  if (metadata.isCompatible(wm,false)) {
    if (metadata.getModelClass() != null && wm.getModelClass() == null) {
      closeWriter(thread,e,FactoryEventListener.EV_CLOSE,FactoryEventListener.EV_CLOSE_EX,FactoryConstants.CR_REOPEN);
      return createWriter(thread,name,e,metadata);
    }
 else {
      LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(thread).$();
      notifyListener(thread,name,FactoryEventListener.EV_GET);
      return e.writer;
    }
  }
  JournalMetadataException ex=new JournalMetadataException(wm,metadata);
  notifyListener(thread,name,FactoryEventListener.EV_INCOMPATIBLE);
  if (closed) {
    closeWriter(thread,e,FactoryEventListener.EV_CLOSE,FactoryEventListener.EV_CLOSE_EX,FactoryConstants.CR_POOL_CLOSE);
  }
  e.owner=-1L;
  throw ex;
}",0.912685337726524
30965,"@Override protected boolean releaseAll(long deadline){
  long threadId=Thread.currentThread().getId();
  boolean removed=false;
  final int reason=deadline == Long.MAX_VALUE ? FactoryConstants.CR_POOL_CLOSE : FactoryConstants.CR_IDLE;
  Iterator<Entry> iterator=entries.values().iterator();
  while (iterator.hasNext()) {
    Entry e=iterator.next();
    if ((deadline > e.lastReleaseTime && e.owner == -1)) {
      if (Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,threadId)) {
        closeWriter(threadId,e,FactoryEventListener.EV_EXPIRE,FactoryEventListener.EV_EXPIRE_EX,reason);
        iterator.remove();
        removed=true;
        Unsafe.getUnsafe().putOrderedLong(e,ENTRY_OWNER,-1L);
      }
    }
 else     if (e.ex != null) {
      LOG.info().$(""String_Node_Str"").$();
      iterator.remove();
      removed=true;
    }
  }
  return removed;
}","@Override protected boolean releaseAll(long deadline){
  long thread=Thread.currentThread().getId();
  boolean removed=false;
  final int reason=deadline == Long.MAX_VALUE ? FactoryConstants.CR_POOL_CLOSE : FactoryConstants.CR_IDLE;
  Iterator<Entry> iterator=entries.values().iterator();
  while (iterator.hasNext()) {
    Entry e=iterator.next();
    if ((deadline > e.lastReleaseTime && e.owner == -1)) {
      if (Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,thread)) {
        closeWriter(thread,e,FactoryEventListener.EV_EXPIRE,FactoryEventListener.EV_EXPIRE_EX,reason);
        iterator.remove();
        removed=true;
        Unsafe.getUnsafe().putOrderedLong(e,ENTRY_OWNER,-1L);
      }
    }
 else     if (e.ex != null) {
      LOG.info().$(""String_Node_Str"").$();
      iterator.remove();
      removed=true;
    }
  }
  return removed;
}",0.996523754345307
30966,"@SuppressWarnings(""String_Node_Str"") private <T>void createWriter(long thread,String name,Entry e,JournalMetadata<T> metadata) throws JournalException {
  try {
    JournalMetadata<T> mo=getConfiguration().readMetadata(metadata.getName());
    if (mo != null && !mo.isCompatible(metadata,false)) {
      throw new JournalMetadataException(mo,metadata);
    }
    if (closed) {
      return;
    }
    JournalWriter<T> w=new JournalWriter<>(metadata,new File(getConfiguration().getJournalBase(),name));
    w.setCloseInterceptor(this);
    LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.owner).$();
    e.writer=w;
    notifyListener(thread,name,FactoryEventListener.EV_CREATE);
  }
 catch (  JournalException ex) {
    LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(ex).$();
    e.ex=ex;
    notifyListener(thread,name,FactoryEventListener.EV_CREATE_EX);
    throw ex;
  }
}","@SuppressWarnings(""String_Node_Str"") private <T>JournalWriter<T> createWriter(long thread,String name,Entry e,JournalMetadata<T> metadata) throws JournalException {
  try {
    JournalMetadata<T> mo=getConfiguration().readMetadata(metadata.getName());
    if (mo != null && !mo.isCompatible(metadata,false)) {
      throw new JournalMetadataException(mo,metadata);
    }
    if (closed) {
      throw FactoryClosedException.INSTANCE;
    }
    JournalWriter<T> w=new JournalWriter<>(metadata,new File(getConfiguration().getJournalBase(),name));
    w.setCloseInterceptor(this);
    LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.owner).$();
    e.writer=w;
    notifyListener(thread,name,FactoryEventListener.EV_CREATE);
    return w;
  }
 catch (  JournalException ex) {
    LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(ex).$();
    e.ex=ex;
    notifyListener(thread,name,FactoryEventListener.EV_CREATE_EX);
    throw ex;
  }
}",0.6405363589479113
30967,"@SuppressWarnings(""String_Node_Str"") <T>JournalWriter<T> writer(JournalMetadata<T> metadata) throws JournalException {
  if (metadata.isPartialMapped()) {
    throw JournalPartiallyMappedException.INSTANCE;
  }
  if (closed) {
    LOG.info().$(""String_Node_Str"").$();
    throw FactoryClosedException.INSTANCE;
  }
  final String name=metadata.getKey().getName();
  long thread=Thread.currentThread().getId();
  Entry e=entries.get(name);
  if (e == null) {
    e=new Entry();
    if (entries.putIfAbsent(name,e) == null) {
      createWriter(thread,name,e,metadata);
      return e.writer;
    }
 else {
      LOG.info().$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(name).$('\'').$();
      e=entries.get(name);
    }
  }
  if (e != null && Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,thread)) {
    if (closed) {
      e.writer.setCloseInterceptor(null);
    }
    return checkAndReturn(thread,e,name,metadata);
  }
 else {
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      throw FactoryInternalException.INSTANCE;
    }
 else {
      long owner=e.owner;
      if (owner == thread) {
        if (e.locked) {
          throw JournalLockedException.INSTANCE;
        }
        if (e.ex != null) {
          notifyListener(thread,name,FactoryEventListener.EV_EX_RESEND);
          throw e.ex;
        }
        if (closed) {
          LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
          e.writer.setCloseInterceptor(null);
        }
        return checkAndReturn(thread,e,name,metadata);
      }
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(owner).$();
      throw WriterBusyException.INSTANCE;
    }
  }
}","@SuppressWarnings(""String_Node_Str"") <T>JournalWriter<T> writer(JournalMetadata<T> metadata) throws JournalException {
  if (metadata.isPartialMapped()) {
    throw JournalPartiallyMappedException.INSTANCE;
  }
  if (closed) {
    LOG.info().$(""String_Node_Str"").$();
    throw FactoryClosedException.INSTANCE;
  }
  final String name=metadata.getKey().getName();
  long thread=Thread.currentThread().getId();
  Entry e=entries.get(name);
  if (e == null) {
    e=new Entry();
    if (entries.putIfAbsent(name,e) == null) {
      return createWriter(thread,name,e,metadata);
    }
 else {
      LOG.info().$(""String_Node_Str"").$(e.owner).$(""String_Node_Str"").$(name).$('\'').$();
      e=entries.get(name);
    }
  }
  if (e != null && Unsafe.getUnsafe().compareAndSwapLong(e,ENTRY_OWNER,-1L,thread)) {
    if (e.writer == null) {
      return createWriter(thread,name,e,metadata);
    }
    if (closed) {
      e.writer.setCloseInterceptor(null);
    }
    return checkAndReturn(thread,e,name,metadata);
  }
 else {
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      throw FactoryInternalException.INSTANCE;
    }
 else {
      long owner=e.owner;
      if (owner == thread) {
        if (e.locked) {
          throw JournalLockedException.INSTANCE;
        }
        if (e.ex != null) {
          notifyListener(thread,name,FactoryEventListener.EV_EX_RESEND);
          throw e.ex;
        }
        if (closed) {
          LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
          e.writer.setCloseInterceptor(null);
        }
        return checkAndReturn(thread,e,name,metadata);
      }
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(owner).$();
      throw WriterBusyException.INSTANCE;
    }
  }
}",0.9673388241976713
30968,"@Override public boolean canClose(Journal journal){
  String name=journal.getName();
  Entry e=entries.get(name);
  if (e != null) {
    long threadId=Thread.currentThread().getId();
    if (e.owner == threadId) {
      if (e.writer.isCommitOnClose()) {
        try {
          e.writer.commit();
        }
 catch (        JournalException ex) {
          throw new JournalRuntimeException(ex);
        }
      }
      LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      e.lastReleaseTime=System.currentTimeMillis();
      if (closed || e.writer.isInError()) {
        LOG.info().$(""String_Node_Str"").$(name).$('\'').$();
        e.writer.setCloseInterceptor(null);
        e.writer=null;
        entries.remove(name);
        return true;
      }
      e.owner=-1L;
    }
 else {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.owner).$();
    }
  }
 else {
    LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
    journal.setCloseInterceptor(null);
    return true;
  }
  return false;
}","@Override public boolean canClose(Journal journal){
  String name=journal.getName();
  Entry e=entries.get(name);
  if (e != null) {
    if (e.owner != -1) {
      if (e.writer.isCommitOnClose()) {
        try {
          e.writer.commit();
        }
 catch (        JournalException ex) {
          throw new JournalRuntimeException(ex);
        }
      }
      LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      e.lastReleaseTime=System.currentTimeMillis();
      if (closed || e.writer.isInError()) {
        LOG.info().$(""String_Node_Str"").$(name).$('\'').$();
        e.writer.setCloseInterceptor(null);
        e.writer=null;
        entries.remove(name);
        return true;
      }
      e.owner=-1L;
    }
 else {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.owner).$();
    }
  }
 else {
    LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
    journal.setCloseInterceptor(null);
    return true;
  }
  return false;
}",0.956989247311828
30969,"@Test public void testInvalidColumnName() throws Exception {
  File base=factoryContainer.getFactory().getConfiguration().getJournalBase();
  File dir=new File(base,""String_Node_Str"");
  Assert.assertFalse(dir.exists());
  try {
    getWriterFactory().writer(new JournalStructure(""String_Node_Str"").$sym(""String_Node_Str"").index().$sym(""String_Node_Str"").index().$sym(""String_Node_Str"").index().$());
    Assert.fail();
  }
 catch (  JournalException ignore) {
  }
  Assert.assertTrue(dir.exists());
  Assert.assertTrue(Files.delete(dir));
}","@Test public void testInvalidColumnName() throws Exception {
  File base=factoryContainer.getFactory().getConfiguration().getJournalBase();
  File dir=new File(base,""String_Node_Str"");
  Assert.assertFalse(dir.exists());
  try {
    getWriterFactory().writer(new JournalStructure(""String_Node_Str"").$sym(""String_Node_Str"").index().$sym(""String_Node_Str"").index().$sym(""String_Node_Str"").index().$());
    Assert.fail();
  }
 catch (  JournalException ignore) {
  }
  factoryContainer.getFactory().expire();
  Assert.assertTrue(dir.exists());
  Assert.assertTrue(Files.delete(dir));
}",0.9626334519572952
30970,"@After public void tearDown() throws Exception {
  origin.close();
  slave.close();
  master.close();
  masterReader.close();
  journalDeltaProducer.free();
  journalDeltaConsumer.free();
}","@After public void tearDown() throws Exception {
  origin.close();
  slave.close();
  master.close();
  masterReader.close();
  journalDeltaProducer.free();
  journalDeltaConsumer.free();
  super.tearDown();
}",0.949748743718593
30971,"@After public void tearDown() throws Exception {
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}","@After public void tearDown() throws Exception {
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyWriterCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}",0.9803921568627452
30972,"@After public void tearDown() throws Exception {
  bw.close();
  aw.close();
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}","@After public void tearDown() throws Exception {
  bw.close();
  aw.close();
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyWriterCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}",0.9827586206896552
30973,"@After public void tearDown() throws Exception {
  aw.close();
  bw.close();
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}","@After public void tearDown() throws Exception {
  aw.close();
  bw.close();
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyWriterCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}",0.9827586206896552
30974,"@After public void tearDown() throws Exception {
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyReaderCount());
}","@After public void tearDown() throws Exception {
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyWriterCount());
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyReaderCount());
}",0.9805825242718448
30975,"@After public void tearDown() throws Exception {
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyReaderCount());
}","@After public void tearDown() throws Exception {
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyWriterCount());
}",0.7664670658682635
30976,"@After public void tearDown() throws Exception {
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}","@After public void tearDown() throws Exception {
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyWriterCount());
  Assert.assertEquals(0,factoryContainer.getFactory().getBusyReaderCount());
}",0.9803921568627452
30977,"public static void main(String[] args) throws JournalException, IOException, JournalNetworkException, NumericException {
  final String pathToDatabase=args[0];
  final int instance=Numbers.parseInt(args[1]);
  final JournalConfiguration configuration=new JournalConfigurationBuilder(){
{
      $(Price.class).$ts();
    }
  }
.build(pathToDatabase);
  final WriterFactoryImpl writerFactory=new WriterFactoryImpl(configuration);
  final ReaderFactoryImpl readerFactory=new ReaderFactoryImpl(configuration);
  final JournalWriter<Price> writer=writerFactory.writer(new JournalKey<>(Price.class,null,PartitionBy.DEFAULT,1000000000));
  final WorkerController wc=new WorkerController(writer);
  final ClusterController cc=new ClusterController(new ServerConfig(){
{
      addNode(new ServerNode(1,""String_Node_Str""));
      addNode(new ServerNode(2,""String_Node_Str""));
    }
  }
,new ClientConfig(),writerFactory,readerFactory,instance,new ArrayList<JournalWriter>(){
{
      add(writer);
    }
  }
,wc);
  cc.start();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      cc.halt();
    }
  }
);
}","public static void main(String[] args) throws JournalException, IOException, JournalNetworkException, NumericException {
  final String pathToDatabase=args[0];
  final int instance=Numbers.parseInt(args[1]);
  final JournalConfiguration configuration=new JournalConfigurationBuilder(){
{
      $(Price.class).$ts();
    }
  }
.build(pathToDatabase);
  final MegaFactory factory=new MegaFactory(configuration,1000,1);
  final JournalWriter<Price> writer=factory.writer(new JournalKey<>(Price.class,null,PartitionBy.DEFAULT,1000000000));
  final WorkerController wc=new WorkerController(writer);
  final ClusterController cc=new ClusterController(new ServerConfig(){
{
      addNode(new ServerNode(1,""String_Node_Str""));
      addNode(new ServerNode(2,""String_Node_Str""));
    }
  }
,new ClientConfig(),factory,instance,new ArrayList<JournalWriter>(){
{
      add(writer);
    }
  }
,wc);
  cc.start();
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      cc.halt();
    }
  }
);
}",0.9158530915853093
30978,"public static void main(String[] args) throws Exception {
  System.err.printf(""String_Node_Str"",getVersion());
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    return;
  }
  if (Os.type == Os._32Bit) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final CharSequenceObjHashMap<String> optHash=hashArgs(args);
  String dir=optHash.get(""String_Node_Str"");
  extractSite(dir,optHash.get(""String_Node_Str"") != null);
  File conf=new File(dir,""String_Node_Str"");
  if (!conf.exists()) {
    System.err.println(""String_Node_Str"" + conf);
    return;
  }
  final ServerConfiguration configuration=new ServerConfiguration(conf);
  configureLoggers(configuration);
  final SimpleUrlMatcher matcher=new SimpleUrlMatcher();
  Factory factory=new Factory(configuration.getDbPath().getAbsolutePath(),60000,4);
  matcher.put(""String_Node_Str"",new ImportHandler(configuration,factory));
  matcher.put(""String_Node_Str"",new QueryHandler(factory,configuration));
  matcher.put(""String_Node_Str"",new CsvHandler(factory,configuration));
  matcher.put(""String_Node_Str"",new ExistenceCheckHandler(factory));
  matcher.setDefaultHandler(new StaticContentHandler(configuration));
  StringBuilder welcome=Misc.getThreadLocalBuilder();
  HttpServer server=new HttpServer(configuration,matcher);
  if (!server.start(LogFactory.INSTANCE.getJobs(),configuration.getHttpQueueDepth())) {
    welcome.append(""String_Node_Str"").append(configuration.getHttpIP()).append(':').append(configuration.getHttpPort());
    welcome.append(""String_Node_Str"");
    System.err.println(welcome);
    System.out.println(new Date() + ""String_Node_Str"");
  }
 else {
    welcome.append(""String_Node_Str"").append(configuration.getHttpIP()).append(':').append(configuration.getHttpPort());
    if (configuration.getSslConfig().isSecure()) {
      welcome.append(""String_Node_Str"");
    }
 else {
      welcome.append(""String_Node_Str"");
    }
    System.err.println(welcome);
    System.out.println(new Date() + ""String_Node_Str"");
    if (Os.type != Os.WINDOWS && optHash.get(""String_Node_Str"") == null) {
      Signal.handle(new Signal(""String_Node_Str""),new SignalHandler(){
        public void handle(        Signal signal){
        }
      }
);
    }
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
      public void run(){
        System.out.println(new Date() + ""String_Node_Str"");
      }
    }
));
  }
}","public static void main(String[] args) throws Exception {
  System.err.printf(""String_Node_Str"",getVersion());
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    return;
  }
  if (Os.type == Os._32Bit) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final CharSequenceObjHashMap<String> optHash=hashArgs(args);
  String dir=optHash.get(""String_Node_Str"");
  extractSite(dir,optHash.get(""String_Node_Str"") != null);
  File conf=new File(dir,""String_Node_Str"");
  if (!conf.exists()) {
    System.err.println(""String_Node_Str"" + conf);
    return;
  }
  final ServerConfiguration configuration=new ServerConfiguration(conf);
  configureLoggers(configuration);
  final SimpleUrlMatcher matcher=new SimpleUrlMatcher();
  final Factory factory=new Factory(configuration.getDbPath().getAbsolutePath(),60000,4);
  matcher.put(""String_Node_Str"",new ImportHandler(configuration,factory));
  matcher.put(""String_Node_Str"",new QueryHandler(factory,configuration));
  matcher.put(""String_Node_Str"",new CsvHandler(factory,configuration));
  matcher.put(""String_Node_Str"",new ExistenceCheckHandler(factory));
  matcher.setDefaultHandler(new StaticContentHandler(configuration));
  StringBuilder welcome=Misc.getThreadLocalBuilder();
  final HttpServer server=new HttpServer(configuration,matcher);
  if (!server.start(LogFactory.INSTANCE.getJobs(),configuration.getHttpQueueDepth())) {
    welcome.append(""String_Node_Str"").append(configuration.getHttpIP()).append(':').append(configuration.getHttpPort());
    welcome.append(""String_Node_Str"");
    System.err.println(welcome);
    System.out.println(new Date() + ""String_Node_Str"");
  }
 else {
    welcome.append(""String_Node_Str"").append(configuration.getHttpIP()).append(':').append(configuration.getHttpPort());
    if (configuration.getSslConfig().isSecure()) {
      welcome.append(""String_Node_Str"");
    }
 else {
      welcome.append(""String_Node_Str"");
    }
    System.err.println(welcome);
    System.out.println(new Date() + ""String_Node_Str"");
    if (Os.type != Os.WINDOWS && optHash.get(""String_Node_Str"") == null) {
      Signal.handle(new Signal(""String_Node_Str""),new SignalHandler(){
        public void handle(        Signal signal){
        }
      }
);
    }
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
      public void run(){
        System.out.println(new Date() + ""String_Node_Str"");
        server.halt();
        factory.close();
      }
    }
));
  }
}",0.9877551020408164
30979,"public void run(){
  System.out.println(new Date() + ""String_Node_Str"");
}","public void run(){
  System.out.println(new Date() + ""String_Node_Str"");
  server.halt();
  factory.close();
}",0.8043478260869565
30980,"@Override public boolean canClose(Journal journal){
  String name=journal.getName();
  if (journal instanceof R) {
    Entry e=entries.get(name);
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      return true;
    }
    long thread=Thread.currentThread().getId();
    R r=(R)journal;
    if (Unsafe.arrayGet(r.entry.allocations,r.index) == thread) {
      if (closed == TRUE) {
        Unsafe.arrayPut(r.entry.readers,r.index,null);
        return true;
      }
      Unsafe.arrayPut(r.entry.releaseTimes,r.index,System.currentTimeMillis());
      Unsafe.arrayPutOrdered(r.entry.allocations,r.index,UNALLOCATED);
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
      return false;
    }
    LOG.error().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(r.entry.index).$(',').$(r.index).$();
  }
 else {
    LOG.error().$(""String_Node_Str"").$(name).$();
  }
  return true;
}","@Override public boolean canClose(Journal journal){
  String name=journal.getName();
  if (journal instanceof R) {
    Entry e=entries.get(name);
    if (e == null) {
      LOG.error().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
      return true;
    }
    long thread=Thread.currentThread().getId();
    R r=(R)journal;
    if (Unsafe.arrayGet(r.entry.allocations,r.index) != UNALLOCATED) {
      if (closed == TRUE) {
        Unsafe.arrayPut(r.entry.readers,r.index,null);
        return true;
      }
      Unsafe.arrayPut(r.entry.releaseTimes,r.index,System.currentTimeMillis());
      Unsafe.arrayPutOrdered(r.entry.allocations,r.index,UNALLOCATED);
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
      return false;
    }
    LOG.error().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(r.entry.index).$(',').$(r.index).$();
  }
 else {
    LOG.error().$(""String_Node_Str"").$(name).$();
  }
  return true;
}",0.9894947473736868
30981,"@Override public final <T>Journal<T> reader(Class<T> clazz,String name,int recordHint) throws JournalException {
  return reader(new JournalKey<>(clazz,name,PartitionBy.DEFAULT,recordHint));
}","@Override @SuppressWarnings(""String_Node_Str"") public <T>Journal<T> reader(JournalMetadata<T> metadata) throws JournalException {
  if (closed == TRUE) {
    LOG.info().$(""String_Node_Str"");
    throw FactoryClosedException.INSTANCE;
  }
  String name=metadata.getName();
  Entry e=entries.get(name);
  long thread=Thread.currentThread().getId();
  if (e == null) {
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    e=new Entry(0);
    Entry other=entries.putIfAbsent(name,e);
    if (other != null) {
      e=other;
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
 else {
      if (getConfiguration().exists(name) != JournalConfiguration.EXISTS) {
        LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
        throw JournalDoesNotExistException.INSTANCE;
      }
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
  }
  long lockOwner=e.lockOwner;
  if (lockOwner != UNLOCKED) {
    LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(lockOwner).$();
    throw JournalLockedException.INSTANCE;
  }
  do {
    for (int i=0; i < ENTRY_SIZE; i++) {
      if (Unsafe.cas(e.allocations,i,UNALLOCATED,thread)) {
        LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$();
        R r=Unsafe.arrayGet(e.readers,i);
        if (r == null) {
          r=new R(e,i,metadata,new File(getConfiguration().getJournalBase(),metadata.getName()));
          if (closed == TRUE) {
            return r;
          }
          Unsafe.arrayPut(e.readers,i,r);
          r.setCloseInterceptor(this);
        }
 else {
          r.refresh();
        }
        if (closed == TRUE) {
          Unsafe.arrayPut(e.readers,i,null);
          r.setCloseInterceptor(null);
        }
        return r;
      }
    }
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
    if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,0,1)) {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
      e.next=new Entry(e.index + 1);
    }
    e=e.next;
  }
 while (e != null && e.index < maxSegments);
  LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(this.maxSegments).$(')').$();
  throw FactoryFullException.INSTANCE;
}",0.0746728252501924
30982,"@SuppressWarnings(""String_Node_Str"") <T>Journal<T> reader(JournalMetadata<T> metadata) throws JournalException {
  if (closed == TRUE) {
    LOG.info().$(""String_Node_Str"");
    throw FactoryClosedException.INSTANCE;
  }
  String name=metadata.getName();
  Entry e=entries.get(name);
  long thread=Thread.currentThread().getId();
  if (e == null) {
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    e=new Entry(0);
    Entry other=entries.putIfAbsent(name,e);
    if (other != null) {
      e=other;
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
 else {
      if (getConfiguration().exists(name) != JournalConfiguration.EXISTS) {
        LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
        throw JournalDoesNotExistException.INSTANCE;
      }
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
  }
  long lockOwner=e.lockOwner;
  if (lockOwner != UNLOCKED) {
    LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(lockOwner).$();
    throw JournalLockedException.INSTANCE;
  }
  do {
    for (int i=0; i < ENTRY_SIZE; i++) {
      if (Unsafe.cas(e.allocations,i,FactoryConstants.UNALLOCATED,thread)) {
        R r=Unsafe.arrayGet(e.readers,i);
        if (r == null) {
          LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$(')').$();
          r=new R(e,i,metadata,new File(getConfiguration().getJournalBase(),metadata.getName()));
          if (closed == TRUE) {
            return r;
          }
          Unsafe.arrayPut(e.readers,i,r);
          r.setCloseInterceptor(this);
        }
 else {
          LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$();
          r.refresh();
        }
        if (closed == TRUE) {
          Unsafe.arrayPut(e.readers,i,null);
          r.setCloseInterceptor(null);
        }
        return r;
      }
    }
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
    if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,0,1)) {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
      e.next=new Entry(e.index + 1);
    }
    e=e.next;
  }
 while (e != null && e.index < maxSegments);
  LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(this.maxSegments).$(')').$();
  throw FactoryFullException.INSTANCE;
}","@SuppressWarnings(""String_Node_Str"") <T>Journal<T> reader(JournalMetadata<T> metadata) throws JournalException {
  if (closed == TRUE) {
    LOG.info().$(""String_Node_Str"");
    throw FactoryClosedException.INSTANCE;
  }
  String name=metadata.getName();
  Entry e=entries.get(name);
  long thread=Thread.currentThread().getId();
  if (e == null) {
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    e=new Entry(0);
    Entry other=entries.putIfAbsent(name,e);
    if (other != null) {
      e=other;
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
 else {
      if (getConfiguration().exists(name) != JournalConfiguration.EXISTS) {
        LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$();
        throw JournalDoesNotExistException.INSTANCE;
      }
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$('\'').$();
    }
  }
  long lockOwner=e.lockOwner;
  if (lockOwner != UNLOCKED) {
    LOG.info().$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(lockOwner).$();
    throw JournalLockedException.INSTANCE;
  }
  do {
    for (int i=0; i < ENTRY_SIZE; i++) {
      if (Unsafe.cas(e.allocations,i,FactoryConstants.UNALLOCATED,thread)) {
        R r=Unsafe.arrayGet(e.readers,i);
        if (r == null) {
          LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$(')').$();
          r=new R(e,i,metadata,new File(getConfiguration().getJournalBase(),metadata.getName()));
          if (closed == TRUE) {
            return r;
          }
          Unsafe.arrayPut(e.readers,i,r);
          r.setCloseInterceptor(this);
        }
 else {
          LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(name).$(""String_Node_Str"").$(e.index).$(',').$(i).$(')').$();
          r.refresh();
        }
        if (closed == TRUE) {
          Unsafe.arrayPut(e.readers,i,null);
          r.setCloseInterceptor(null);
        }
        return r;
      }
    }
    LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
    if (Unsafe.getUnsafe().compareAndSwapInt(e,NEXT_STATUS,0,1)) {
      LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(e.index + 1).$();
      e.next=new Entry(e.index + 1);
    }
    e=e.next;
  }
 while (e != null && e.index < maxSegments);
  LOG.info().$(""String_Node_Str"").$(thread).$(""String_Node_Str"").$(this.maxSegments).$(')').$();
  throw FactoryFullException.INSTANCE;
}",0.998626643123406
30983,"@Test public void testLockBusyReader() throws Exception {
  final int readerCount=5;
  int threadCount=2;
  final int iterations=10000;
  final JournalMetadata<?>[] meta=new JournalMetadata[readerCount];
  for (int i=0; i < readerCount; i++) {
    final JournalMetadata<?> m=new JournalStructure(""String_Node_Str"" + i).$date(""String_Node_Str"").$().build();
    getWriterFactory().writer(m).close();
    meta[i]=m;
  }
  try {
    try (final CachingReaderFactory rf=new CachingReaderFactory(factoryContainer.getConfiguration(),1000,2)){
      final CyclicBarrier barrier=new CyclicBarrier(threadCount);
      final CountDownLatch halt=new CountDownLatch(threadCount);
      final AtomicInteger errors=new AtomicInteger();
      final LongList lockTimes=new LongList();
      final LongList workerTimes=new LongList();
      new Thread(){
        @Override public void run(){
          Rnd rnd=new Rnd();
          try {
            barrier.await();
            String name=null;
            for (int i=0; i < iterations; i++) {
              if (name == null) {
                name=meta[rnd.nextPositiveInt() % readerCount].getName();
              }
              while (true) {
                try {
                  rf.lock(name);
                  lockTimes.add(System.currentTimeMillis());
                  LockSupport.parkNanos(1L);
                  rf.unlock(name);
                  name=null;
                  break;
                }
 catch (                JournalException e) {
                  if (!(e instanceof RetryLockException)) {
                    e.printStackTrace();
                    errors.incrementAndGet();
                    break;
                  }
                }
              }
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            errors.incrementAndGet();
          }
          halt.countDown();
        }
      }
.start();
      new Thread(){
        @Override public void run(){
          Rnd rnd=new Rnd();
          workerTimes.add(System.currentTimeMillis());
          for (int i=0; i < iterations; i++) {
            JournalMetadata<?> metadata=meta[rnd.nextPositiveInt() % readerCount];
            try (Journal<?> ignored=rf.reader(metadata)){
              if (metadata == meta[readerCount - 1] && barrier.getNumberWaiting() > 0) {
                barrier.await();
              }
              LockSupport.parkNanos(1L);
            }
 catch (            JournalLockedException ignored) {
            }
catch (            Exception e) {
              e.printStackTrace();
              errors.incrementAndGet();
            }
          }
          workerTimes.add(System.currentTimeMillis());
          halt.countDown();
        }
      }
.start();
      halt.await();
      Assert.assertEquals(0,errors.get());
      int count=0;
      Assert.assertEquals(2,workerTimes.size());
      long lo=workerTimes.get(0);
      long hi=workerTimes.get(1);
      Assert.assertTrue(lockTimes.size() > 0);
      for (int i=0, n=lockTimes.size(); i < n; i++) {
        long t=lockTimes.getQuick(i);
        if (t > lo && t < hi) {
          count++;
        }
      }
      Assert.assertTrue(count > 0);
    }
   }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}","@Test public void testLockBusyReader() throws Exception {
  final int readerCount=5;
  int threadCount=2;
  final int iterations=10000;
  final JournalMetadata<?>[] meta=new JournalMetadata[readerCount];
  for (int i=0; i < readerCount; i++) {
    final JournalMetadata<?> m=new JournalStructure(""String_Node_Str"" + i).$date(""String_Node_Str"").$().build();
    getWriterFactory().writer(m).close();
    meta[i]=m;
  }
  try {
    try (final CachingReaderFactory rf=new CachingReaderFactory(factoryContainer.getConfiguration(),1000,2)){
      final CyclicBarrier barrier=new CyclicBarrier(threadCount);
      final CountDownLatch halt=new CountDownLatch(threadCount);
      final AtomicInteger errors=new AtomicInteger();
      final LongList lockTimes=new LongList();
      final LongList workerTimes=new LongList();
      new Thread(){
        @Override public void run(){
          Rnd rnd=new Rnd();
          try {
            barrier.await();
            String name=null;
            for (int i=0; i < iterations; i++) {
              if (name == null) {
                name=meta[rnd.nextPositiveInt() % readerCount].getName();
              }
              while (true) {
                try {
                  rf.lock(name);
                  lockTimes.add(System.currentTimeMillis());
                  LockSupport.parkNanos(100L);
                  rf.unlock(name);
                  name=null;
                  break;
                }
 catch (                JournalException e) {
                  if (!(e instanceof RetryLockException)) {
                    e.printStackTrace();
                    errors.incrementAndGet();
                    break;
                  }
                }
              }
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            errors.incrementAndGet();
          }
          halt.countDown();
        }
      }
.start();
      new Thread(){
        @Override public void run(){
          Rnd rnd=new Rnd();
          workerTimes.add(System.currentTimeMillis());
          for (int i=0; i < iterations; i++) {
            JournalMetadata<?> metadata=meta[rnd.nextPositiveInt() % readerCount];
            try (Journal<?> ignored=rf.reader(metadata)){
              if (metadata == meta[readerCount - 1] && barrier.getNumberWaiting() > 0) {
                barrier.await();
              }
              LockSupport.parkNanos(10L);
            }
 catch (            JournalLockedException ignored) {
            }
catch (            Exception e) {
              e.printStackTrace();
              errors.incrementAndGet();
            }
          }
          workerTimes.add(System.currentTimeMillis());
          halt.countDown();
        }
      }
.start();
      halt.await();
      Assert.assertEquals(0,errors.get());
      int count=0;
      Assert.assertEquals(2,workerTimes.size());
      long lo=workerTimes.get(0);
      long hi=workerTimes.get(1);
      Assert.assertTrue(lockTimes.size() > 0);
      for (int i=0, n=lockTimes.size(); i < n; i++) {
        long t=lockTimes.getQuick(i);
        if (t > lo && t < hi) {
          count++;
        }
      }
      Assert.assertTrue(count > 0);
    }
   }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}",0.9995407928975968
30984,"@Override public void run(){
  Rnd rnd=new Rnd();
  workerTimes.add(System.currentTimeMillis());
  for (int i=0; i < iterations; i++) {
    JournalMetadata<?> metadata=meta[rnd.nextPositiveInt() % readerCount];
    try (Journal<?> ignored=rf.reader(metadata)){
      if (metadata == meta[readerCount - 1] && barrier.getNumberWaiting() > 0) {
        barrier.await();
      }
      LockSupport.parkNanos(1L);
    }
 catch (    JournalLockedException ignored) {
    }
catch (    Exception e) {
      e.printStackTrace();
      errors.incrementAndGet();
    }
  }
  workerTimes.add(System.currentTimeMillis());
  halt.countDown();
}","@Override public void run(){
  Rnd rnd=new Rnd();
  workerTimes.add(System.currentTimeMillis());
  for (int i=0; i < iterations; i++) {
    JournalMetadata<?> metadata=meta[rnd.nextPositiveInt() % readerCount];
    try (Journal<?> ignored=rf.reader(metadata)){
      if (metadata == meta[readerCount - 1] && barrier.getNumberWaiting() > 0) {
        barrier.await();
      }
      LockSupport.parkNanos(10L);
    }
 catch (    JournalLockedException ignored) {
    }
catch (    Exception e) {
      e.printStackTrace();
      errors.incrementAndGet();
    }
  }
  workerTimes.add(System.currentTimeMillis());
  halt.countDown();
}",0.999205718824464
30985,"@AfterClass public static void tearDown2() throws Exception {
  server.halt();
}","@AfterClass public static void tearDown2() throws Exception {
  server.halt();
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyReaderCount());
  Assert.assertEquals(0,FACTORY_CONTAINER.getFactory().getBusyWriterCount());
}",0.5063291139240507
30986,"@Test public void testServerRestart() throws Exception {
  final int size=10000;
  try (JournalWriter<Quote> remote=getWriterFactory().writer(Quote.class,""String_Node_Str"",2 * size)){
    JournalServer server=newServer();
    server.publish(remote);
    server.start();
    final CountDownLatch connectedLatch=new CountDownLatch(1);
    JournalClient client=new JournalClient(new ClientConfig(""String_Node_Str""){
{
        getReconnectPolicy().setLoginRetryCount(3);
        getReconnectPolicy().setRetryCount(5);
        getReconnectPolicy().setSleepBetweenRetriesMillis(TimeUnit.SECONDS.toMillis(1));
      }
    }
,getWriterFactory(),null,new JournalClient.Callback(){
      @Override public void onEvent(      int evt){
        if (evt == JournalClientEvents.EVT_CONNECTED) {
          connectedLatch.countDown();
        }
      }
    }
);
    final CountDownLatch latch=new CountDownLatch(1);
    getWriterFactory().writer(Quote.class,""String_Node_Str"").close();
    try (final Journal<Quote> local=factoryContainer.getFactory().reader(Quote.class,""String_Node_Str"")){
      client.subscribe(Quote.class,""String_Node_Str"",""String_Node_Str"",2 * size,new JournalListener(){
        @Override public void onCommit(){
          try {
            if (local.refresh() && local.size() == 2 * size) {
              latch.countDown();
            }
          }
 catch (          JournalException e) {
            throw new JournalRuntimeException(e);
          }
        }
        @Override public void onEvent(        int event){
        }
      }
);
      client.start();
      Assert.assertTrue(connectedLatch.await(5,TimeUnit.SECONDS));
      TestUtils.generateQuoteData(remote,size,System.currentTimeMillis(),1);
      remote.commit();
      server.halt();
      server=newServer();
      server.publish(remote);
      server.start();
      TestUtils.generateQuoteData(remote,size,System.currentTimeMillis() + 2 * size,1);
      remote.commit();
      latch.await();
      client.halt();
      server.halt();
      TestUtils.assertDataEquals(remote,local);
    }
   }
 }","@Test @Ignore public void testServerRestart() throws Exception {
  final int size=10000;
  try (JournalWriter<Quote> remote=getWriterFactory().writer(Quote.class,""String_Node_Str"",2 * size)){
    JournalServer server=newServer();
    server.publish(remote);
    server.start();
    final CountDownLatch connectedLatch=new CountDownLatch(1);
    JournalClient client=new JournalClient(new ClientConfig(""String_Node_Str""){
{
        getReconnectPolicy().setLoginRetryCount(3);
        getReconnectPolicy().setRetryCount(5);
        getReconnectPolicy().setSleepBetweenRetriesMillis(TimeUnit.SECONDS.toMillis(1));
      }
    }
,getWriterFactory(),null,new JournalClient.Callback(){
      @Override public void onEvent(      int evt){
        if (evt == JournalClientEvents.EVT_CONNECTED) {
          connectedLatch.countDown();
        }
      }
    }
);
    final CountDownLatch latch=new CountDownLatch(1);
    getWriterFactory().writer(Quote.class,""String_Node_Str"").close();
    try (final Journal<Quote> local=factoryContainer.getFactory().reader(Quote.class,""String_Node_Str"")){
      client.subscribe(Quote.class,""String_Node_Str"",""String_Node_Str"",2 * size,new JournalListener(){
        @Override public void onCommit(){
          try {
            if (local.refresh() && local.size() == 2 * size) {
              latch.countDown();
            }
          }
 catch (          JournalException e) {
            throw new JournalRuntimeException(e);
          }
        }
        @Override public void onEvent(        int event){
        }
      }
);
      client.start();
      Assert.assertTrue(connectedLatch.await(5,TimeUnit.SECONDS));
      TestUtils.generateQuoteData(remote,size,System.currentTimeMillis(),1);
      remote.commit();
      server.halt();
      server=newServer();
      server.publish(remote);
      server.start();
      TestUtils.generateQuoteData(remote,size,System.currentTimeMillis() + 2 * size,1);
      remote.commit();
      latch.await();
      client.halt();
      server.halt();
      TestUtils.assertDataEquals(remote,local);
    }
   }
 }",0.9980732177263968
30987,"@SuppressWarnings(""String_Node_Str"") public static void copyNonBlocking(ReadableByteChannel channel,ByteBuffer to,final int retryCount) throws DisconnectedChannelException, SlowReadableChannelException, EndOfChannelException {
  int r=to.remaining();
  int target=r;
  int retriesRemaining=retryCount;
  OUT:   while (target > 0) {
    int result;
    try {
      result=channel.read(to);
    }
 catch (    IOException e) {
      throw DisconnectedChannelException.INSTANCE;
    }
    if (result > 0) {
      target-=result;
      continue;
    }
switch (result) {
case Net.ERETRY:
      if (target < r) {
        break OUT;
      }
    if (--retriesRemaining < 0) {
      throw SlowReadableChannelException.INSTANCE;
    }
  break;
case Net.EPEERDISCONNECT:
throw EndOfChannelException.INSTANCE;
default :
throw DisconnectedChannelException.INSTANCE;
}
}
}","@SuppressWarnings(""String_Node_Str"") public static void copyNonBlocking(NetworkChannel channel,ByteBuffer to,final int retryCount) throws DisconnectedChannelException, SlowReadableChannelException, EndOfChannelException {
  int r=to.remaining();
  int target=r;
  int retriesRemaining=retryCount;
  OUT:   while (target > 0) {
    int result;
    try {
      result=channel.read(to);
    }
 catch (    IOException e) {
      throw DisconnectedChannelException.INSTANCE;
    }
    if (result > 0) {
      target-=result;
      continue;
    }
switch (result) {
case Net.ERETRY:
      if (target < r) {
        break OUT;
      }
    if (--retriesRemaining < 0) {
      throw SlowReadableChannelException.INSTANCE;
    }
  break;
case Net.EPEERDISCONNECT:
throw EndOfChannelException.INSTANCE;
default :
throw DisconnectedChannelException.INSTANCE;
}
}
}",0.9888823873610298
30988,"private void disconnect(C context,int disconnectReason){
  LOG.info().$(""String_Node_Str"").$(context.getFd()).$(""String_Node_Str"").$(DisconnectReason.nameOf(disconnectReason)).$();
  context.close();
  connectionCount--;
}","private void disconnect(C context,int disconnectReason){
  LOG.info().$(""String_Node_Str"").$ip(context.getIp()).$(""String_Node_Str"").$(DisconnectReason.nameOf(disconnectReason)).$(']').$();
  context.close();
  connectionCount--;
}",0.9713024282560706
30989,"@Override protected boolean runSerially(){
  boolean useful=false;
  final int n=epoll.poll();
  int watermark=pending.size();
  final long timestamp=clock.getTicks();
  int offset=0;
  if (n > 0) {
    for (int i=0; i < n; i++) {
      epoll.setOffset(offset);
      offset+=Epoll.SIZEOF_EVENT;
      long id=epoll.getData();
      if (id == 0) {
        accept(timestamp);
      }
 else {
        int row=pending.binarySearch(id);
        if (row < 0) {
          LOG.error().$(""String_Node_Str"").$(id).$();
          continue;
        }
        final C context=pending.get(row);
        long cursor=ioSequence.nextBully();
        Event<C> evt=ioQueue.get(cursor);
        evt.context=context;
        evt.channelStatus=(epoll.getEvent() & Epoll.EPOLLIN) > 0 ? ChannelStatus.READ : ChannelStatus.WRITE;
        ioSequence.done(cursor);
        LOG.debug().$(""String_Node_Str"").$(id).$(""String_Node_Str"").$(context.getFd()).$();
        pending.deleteRow(row);
        watermark--;
      }
    }
    if (watermark < pending.size()) {
      enqueuePending(watermark);
    }
    useful=true;
  }
  long deadline=timestamp - timeout;
  if (pending.size() > 0 && pending.get(0,M_TIMESTAMP) < deadline) {
    processIdleConnections(deadline);
    useful=true;
  }
  return processRegistrations(timestamp) || useful;
}","@Override protected boolean runSerially(){
  boolean useful=false;
  final int n=epoll.poll();
  int watermark=pending.size();
  final long timestamp=clock.getTicks();
  int offset=0;
  if (n > 0) {
    for (int i=0; i < n; i++) {
      epoll.setOffset(offset);
      offset+=Epoll.SIZEOF_EVENT;
      long id=epoll.getData();
      if (id == 0) {
        accept(timestamp);
      }
 else {
        int row=pending.binarySearch(id);
        if (row < 0) {
          LOG.error().$(""String_Node_Str"").$(id).$();
          continue;
        }
        final C context=pending.get(row);
        long cursor=ioSequence.nextBully();
        Event<C> evt=ioQueue.get(cursor);
        evt.context=context;
        evt.channelStatus=(epoll.getEvent() & Epoll.EPOLLIN) > 0 ? ChannelStatus.READ : ChannelStatus.WRITE;
        ioSequence.done(cursor);
        LOG.debug().$(""String_Node_Str"").$(id).$(""String_Node_Str"").$(context.getFd()).$(""String_Node_Str"").$(evt.channelStatus).$();
        pending.deleteRow(row);
        watermark--;
      }
    }
    if (watermark < pending.size()) {
      enqueuePending(watermark);
    }
    useful=true;
  }
  long deadline=timestamp - timeout;
  if (pending.size() > 0 && pending.get(0,M_TIMESTAMP) < deadline) {
    processIdleConnections(deadline);
    useful=true;
  }
  return processRegistrations(timestamp) || useful;
}",0.9842696629213484
30990,"private boolean processRegistrations(long timestamp){
  long cursor;
  boolean useful=false;
  int offset=0;
  while ((cursor=interestSubSequence.next()) > -1) {
    useful=true;
    Event<C> evt=interestQueue.get(cursor);
    C context=evt.context;
    int channelStatus=evt.channelStatus;
    interestSubSequence.done(cursor);
    int fd=(int)context.getFd();
    LOG.debug().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(channelStatus).$();
    epoll.setOffset(offset);
    offset+=Epoll.SIZEOF_EVENT;
    final long id=fdid++;
switch (channelStatus) {
case ChannelStatus.READ:
      epoll.control(fd,id,Epoll.EPOLL_CTL_MOD,Epoll.EPOLLIN);
    break;
case ChannelStatus.WRITE:
  epoll.control(fd,id,Epoll.EPOLL_CTL_MOD,Epoll.EPOLLOUT);
break;
case ChannelStatus.DISCONNECTED:
disconnect(context,DisconnectReason.SILLY);
continue;
case ChannelStatus.EOF:
disconnect(context,DisconnectReason.PEER);
continue;
default :
break;
}
int r=pending.addRow();
pending.set(r,M_TIMESTAMP,timestamp);
pending.set(r,M_FD,fd);
pending.set(r,M_ID,id);
pending.set(r,context);
}
return useful;
}","private boolean processRegistrations(long timestamp){
  long cursor;
  boolean useful=false;
  int offset=0;
  while ((cursor=interestSubSequence.next()) > -1) {
    useful=true;
    Event<C> evt=interestQueue.get(cursor);
    C context=evt.context;
    int channelStatus=evt.channelStatus;
    interestSubSequence.done(cursor);
    int fd=(int)context.getFd();
    final long id=fdid++;
    LOG.debug().$(""String_Node_Str"").$(fd).$(""String_Node_Str"").$(channelStatus).$(""String_Node_Str"").$(id).$();
    epoll.setOffset(offset);
    offset+=Epoll.SIZEOF_EVENT;
switch (channelStatus) {
case ChannelStatus.READ:
      epoll.control(fd,id,Epoll.EPOLL_CTL_MOD,Epoll.EPOLLIN);
    break;
case ChannelStatus.WRITE:
  epoll.control(fd,id,Epoll.EPOLL_CTL_MOD,Epoll.EPOLLOUT);
break;
case ChannelStatus.DISCONNECTED:
disconnect(context,DisconnectReason.SILLY);
continue;
case ChannelStatus.EOF:
disconnect(context,DisconnectReason.PEER);
continue;
default :
break;
}
int r=pending.addRow();
pending.set(r,M_TIMESTAMP,timestamp);
pending.set(r,M_FD,fd);
pending.set(r,M_ID,id);
pending.set(r,context);
}
return useful;
}",0.9640418752844788
30991,"private void disconnect(C context,int disconnectReason){
  LOG.info().$(""String_Node_Str"").$(context.getFd()).$(""String_Node_Str"").$(DisconnectReason.nameOf(disconnectReason)).$();
  context.close();
  connectionCount--;
}","private void disconnect(C context,int disconnectReason){
  LOG.info().$(""String_Node_Str"").$ip(context.getIp()).$(""String_Node_Str"").$(DisconnectReason.nameOf(disconnectReason)).$(']').$();
  context.close();
  connectionCount--;
}",0.9713024282560706
30992,"@Override public int read(ByteBuffer dst) throws IOException {
  int read=Net.recv(fd,ByteBuffers.getAddress(dst) + dst.position(),dst.remaining());
  if (read > 0) {
    dst.position(dst.position() + read);
  }
  return read;
}","@Override public int read(ByteBuffer dst) throws IOException {
  int read=Net.recv(fd,ByteBuffers.getAddress(dst) + dst.position(),dst.remaining());
  if (read > 0) {
    dst.position(dst.position() + read);
    if (consecutiveBadReadCount > 0) {
      consecutiveBadReadCount=0;
    }
  }
 else {
    consecutiveBadReadCount++;
  }
  return read;
}",0.7452339688041595
30993,"public NetworkChannelImpl(long fd){
  this.fd=fd;
}","public NetworkChannelImpl(long fd){
  this.fd=fd;
  this.ip=Net.getPeerIP(fd);
}",0.7786259541984732
30994,"private void disconnect(C context,int disconnectReason){
  LOG.info().$(""String_Node_Str"").$(context.getFd()).$(""String_Node_Str"").$(DisconnectReason.nameOf(disconnectReason)).$();
  context.close();
  connectionCount--;
}","private void disconnect(C context,int disconnectReason){
  LOG.info().$(""String_Node_Str"").$ip(context.getIp()).$(""String_Node_Str"").$(DisconnectReason.nameOf(disconnectReason)).$(']').$();
  context.close();
  connectionCount--;
}",0.9713024282560706
30995,"@Override public void close(){
  if (open.compareAndSet(true,false)) {
    LOG.debug().$(""String_Node_Str"").$(channel.getFd()).$();
    Misc.free(map);
    Misc.free(channel);
    Misc.free(request);
    Misc.free(response);
    LOG.debug().$(""String_Node_Str"").$(channel.getFd()).$();
  }
}","@Override public void close(){
  if (open.compareAndSet(true,false)) {
    LOG.debug().$(""String_Node_Str"").$ip(channel.getIp()).$();
    Misc.free(map);
    Misc.free(channel);
    Misc.free(request);
    Misc.free(response);
    LOG.debug().$(""String_Node_Str"").$ip(channel.getIp()).$();
  }
}",0.9795221843003412
30996,"private static void logAccess(IOContext context){
  ACCESS.xinfo().$ip(Net.getPeerIP(context.channel.getFd())).$(""String_Node_Str"").$(""String_Node_Str"").$(""String_Node_Str"").$ts(System.currentTimeMillis()).$(""String_Node_Str"").$('""').$(context.request.getMethodLine()).$('""').$(' ').$(context.getResponseCode()).$(' ').$(context.channel.getTotalWrittenAndReset()).$();
}","private static void logAccess(IOContext context){
  ACCESS.xinfo().$ip(context.channel.getIp()).$(""String_Node_Str"").$(""String_Node_Str"").$(""String_Node_Str"").$ts(System.currentTimeMillis()).$(""String_Node_Str"").$('""').$(context.request.getMethodLine()).$('""').$(' ').$(context.getResponseCode()).$(' ').$(context.channel.getTotalWrittenAndReset()).$();
}",0.9213793103448276
30997,"public Request(NetworkChannel channel,ServerConfiguration configuration){
  this.channel=channel;
  this.hb=new RequestHeaderBuffer(configuration.getHttpBufReqHeader(),pool);
  this.in=ByteBuffer.allocateDirect(Numbers.ceilPow2(configuration.getHttpBufReqContent()));
  this.inAddr=ByteBuffers.getAddress(in);
  this.multipartParser=new MultipartParser(configuration.getHttpBufReqMultipart(),pool);
  this.soRcvSmall=configuration.getHttpSoRcvSmall();
  this.soRcvLarge=configuration.getHttpSoRcvLarge();
  this.soRetries=configuration.getHttpSoRetries();
}","public Request(NetworkChannel channel,ServerConfiguration configuration){
  this.channel=channel;
  this.hb=new RequestHeaderBuffer(configuration.getHttpBufReqHeader(),pool);
  this.in=ByteBuffer.allocateDirect(Numbers.ceilPow2(configuration.getHttpBufReqContent()));
  this.inAddr=ByteBuffers.getAddress(in);
  this.multipartParser=new MultipartParser(configuration.getHttpBufReqMultipart(),pool);
  this.soRcvSmall=configuration.getHttpSoRcvSmall();
  this.soRcvLarge=configuration.getHttpSoRcvLarge();
  this.soRetries=configuration.getHttpSoRetries();
  this.soConsecutiveBadReadLimit=configuration.getHttpSoConsecutiveBadReadLimit();
}",0.9306599832915622
30998,"private void drainChannel() throws IOException {
  in.clear();
  ByteBuffers.copyNonBlocking(channel,in,soRetries);
  in.flip();
}","private void drainChannel() throws IOException {
  try {
    in.clear();
    ByteBuffers.copyNonBlocking(channel,in,soRetries);
    in.flip();
  }
 catch (  SlowReadableChannelException e) {
    if (channel.getConsecutiveBadReadCount() > soConsecutiveBadReadLimit) {
      LOG.error().$(""String_Node_Str"").$();
      throw DisconnectedChannelException.INSTANCE;
    }
    throw e;
  }
}",0.4573643410852713
30999,"public ServerConfiguration(File conf) throws Exception {
  final Properties props=new Properties();
  final File root=conf.getParentFile().getParentFile();
  try (FileInputStream fis=new FileInputStream(conf)){
    props.load(fis);
  }
   int n;
  String s;
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.httpIP=s;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpPort=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpThreads=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpTimeout=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufReqHeader=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpMaxConnections=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpQueueDepth=Numbers.ceilPow2(n);
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpSoRcvSmall=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpSoRcvLarge=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpSoRetries=n;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    if (""String_Node_Str"".equals(s)) {
      httpAbortBrokenUploads=true;
    }
 else     if (""String_Node_Str"".equals(s)) {
      httpAbortBrokenUploads=false;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufReqContent=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufReqMultipart=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufRespHeader=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufRespContent=n;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.httpIndexFile=s;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.dbPath=mkdirs(normalize(root,new File(s)));
  }
 else {
    this.dbPath=mkdirs(normalize(root,this.dbPath));
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.journalPoolSize=n;
  }
 else {
    this.journalPoolSize=httpMaxConnections;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAsOfDataPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAsOfIndexPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAsOfRowPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSortKeyPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSortDataPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAggregatePage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbHashKeyPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbHashDataPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbHashRowPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSysViewPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSysMetaSize=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSysMaxMetaSize=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.dbCyclesBeforeCancel=Numbers.ceilPow2(n);
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAnalyticFuncPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAnalyticWindowPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbFnVarianceMeans=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbFnVarianceData=n;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.mimeTypes=normalize(root,new File(s));
  }
 else {
    this.mimeTypes=normalize(root,mimeTypes);
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.httpPublic=mkdirs(normalize(root,new File(s)));
  }
 else {
    this.httpPublic=mkdirs(normalize(root,this.httpPublic));
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.accessLog=normalize(root,new File(s));
  }
 else {
    this.accessLog=normalize(root,this.accessLog);
  }
  mkdirs(this.accessLog.getParentFile());
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.errorLog=normalize(root,new File(s));
  }
 else {
    this.errorLog=normalize(root,this.errorLog);
  }
  mkdirs(this.accessLog.getParentFile());
  if (this.httpMaxConnections > this.httpQueueDepth) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sslConfig.setSecure(""String_Node_Str"".equals(props.getProperty(""String_Node_Str"")));
  if (sslConfig.isSecure()) {
    if ((s=props.getProperty(""String_Node_Str"")) == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    File keystore=normalize(root,new File(s));
    if (!keystore.exists()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!keystore.isFile()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    try (InputStream is=new FileInputStream(keystore)){
      s=props.getProperty(""String_Node_Str"");
      sslConfig.setKeyStore(is,s == null ? ""String_Node_Str"" : s);
    }
     sslConfig.setRequireClientAuth(""String_Node_Str"".equals(props.getProperty(""String_Node_Str"")));
  }
}","public ServerConfiguration(File conf) throws Exception {
  final Properties props=new Properties();
  final File root=conf.getParentFile().getParentFile();
  try (FileInputStream fis=new FileInputStream(conf)){
    props.load(fis);
  }
   int n;
  String s;
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.httpIP=s;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpPort=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpThreads=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpTimeout=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufReqHeader=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpMaxConnections=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpQueueDepth=Numbers.ceilPow2(n);
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpSoRcvSmall=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpSoRcvLarge=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpSoRetries=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.httpSoConsecutiveBadReadLimit=n;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    if (""String_Node_Str"".equals(s)) {
      httpAbortBrokenUploads=true;
    }
 else     if (""String_Node_Str"".equals(s)) {
      httpAbortBrokenUploads=false;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufReqContent=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufReqMultipart=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufRespHeader=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.httpBufRespContent=n;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.httpIndexFile=s;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.dbPath=mkdirs(normalize(root,new File(s)));
  }
 else {
    this.dbPath=mkdirs(normalize(root,this.dbPath));
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.journalPoolSize=n;
  }
 else {
    this.journalPoolSize=httpMaxConnections;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAsOfDataPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAsOfIndexPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAsOfRowPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSortKeyPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSortDataPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAggregatePage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbHashKeyPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbHashDataPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbHashRowPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSysViewPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSysMetaSize=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbSysMaxMetaSize=n;
  }
  if ((n=parseInt(props,""String_Node_Str"")) > -1) {
    this.dbCyclesBeforeCancel=Numbers.ceilPow2(n);
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAnalyticFuncPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbAnalyticWindowPage=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbFnVarianceMeans=n;
  }
  if ((n=parseSize(props,""String_Node_Str"")) > -1) {
    this.dbFnVarianceData=n;
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.mimeTypes=normalize(root,new File(s));
  }
 else {
    this.mimeTypes=normalize(root,mimeTypes);
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.httpPublic=mkdirs(normalize(root,new File(s)));
  }
 else {
    this.httpPublic=mkdirs(normalize(root,this.httpPublic));
  }
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.accessLog=normalize(root,new File(s));
  }
 else {
    this.accessLog=normalize(root,this.accessLog);
  }
  mkdirs(this.accessLog.getParentFile());
  if ((s=props.getProperty(""String_Node_Str"")) != null) {
    this.errorLog=normalize(root,new File(s));
  }
 else {
    this.errorLog=normalize(root,this.errorLog);
  }
  mkdirs(this.accessLog.getParentFile());
  if (this.httpMaxConnections > this.httpQueueDepth) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  sslConfig.setSecure(""String_Node_Str"".equals(props.getProperty(""String_Node_Str"")));
  if (sslConfig.isSecure()) {
    if ((s=props.getProperty(""String_Node_Str"")) == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    File keystore=normalize(root,new File(s));
    if (!keystore.exists()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!keystore.isFile()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    try (InputStream is=new FileInputStream(keystore)){
      s=props.getProperty(""String_Node_Str"");
      sslConfig.setKeyStore(is,s == null ? ""String_Node_Str"" : s);
    }
     sslConfig.setRequireClientAuth(""String_Node_Str"".equals(props.getProperty(""String_Node_Str"")));
  }
}",0.9908394092353712
31000,"@Override public void handle(IOContext context) throws IOException {
  ExportHandlerContext ctx=localContext.get(context);
  if (ctx == null) {
    localContext.set(context,ctx=new ExportHandlerContext(context.channel.getFd(),context.getServerConfiguration().getDbCyclesBeforeCancel()));
  }
  ChunkedResponse r=context.chunkedResponse();
  if (ctx.parseUrl(r,context.request)) {
    ctx.compileQuery(r,factory,cacheMisses,cacheHits);
    resume(context);
  }
}","@Override public void handle(IOContext context) throws IOException {
  ExportHandlerContext ctx=localContext.get(context);
  if (ctx == null) {
    localContext.set(context,ctx=new ExportHandlerContext(context.getFd(),context.getServerConfiguration().getDbCyclesBeforeCancel()));
  }
  ChunkedResponse r=context.chunkedResponse();
  if (ctx.parseUrl(r,context.request)) {
    ctx.compileQuery(r,factory,cacheMisses,cacheHits);
    resume(context);
  }
}",0.9912472647702408
